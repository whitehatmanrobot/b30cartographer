            NULL);

    if (dwError != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    CHAR chBkChar = pszHostName[dwHostNameLength]; // save off char

    pszHostName[dwHostNameLength] = '\0';

    if (!IsValidHostNameA(pszHostName, IVHN_DISALLOW_IPV6_SCOPE_ID))
    {
        pszHostName[dwHostNameLength] = chBkChar; // put back char
        dwError = ERROR_WINHTTP_LOGIN_FAILURE;
        goto cleanup;
    }

    pszHostName[dwHostNameLength] = chBkChar; // put back char

    //
    // if there is an intra-page link on the redirected URL then get rid of it:
    // we don't send it to the server, and we have already indicated it to the
    // app
    //

    if (extraLength != 0) {

        INET_ASSERT(extra != NULL);
        INET_ASSERT(!IsBadWritePtr(extra, 1));

        if (*extra == '#') {
            *extra = '\0';
            // newUrlLength -= extraLength;
        } else {
            dwUrlPathLength += extraLength;
        }
    }

    if (port == INTERNET_INVALID_PORT_NUMBER) {
        port = (INTERNET_PORT)((schemeType == INTERNET_SCHEME_HTTPS)
            ? INTERNET_DEFAULT_HTTPS_PORT
            : INTERNET_DEFAULT_HTTP_PORT);
    }

    currentHostPort = _pRequest->GetHostPort();
    currentHostName = _pRequest->GetHostName(&currentHostNameLength);

    if (port != currentHostPort) {
        _pRequest->SetHostPort(port);
    }
    if ((dwHostNameLength != currentHostNameLength)
    || (strnicmp(pszHostName, currentHostName, dwHostNameLength) != 0)) {

        char hostValue[INTERNET_MAX_HOST_NAME_LENGTH + sizeof(":4294967295")];
        LPSTR hostValueStr;
        DWORD hostValueSize; 

        chBkChar = pszHostName[dwHostNameLength]; // save off char

        pszHostName[dwHostNameLength] = '\0';
        _pRequest->SetHostName(pszHostName);

        hostValueSize = dwHostNameLength;
        hostValueStr = pszHostName;            

        if ((port != INTERNET_DEFAULT_HTTP_PORT)
        &&  (port != INTERNET_DEFAULT_HTTPS_PORT)) {
            if (hostValueSize > INTERNET_MAX_HOST_NAME_LENGTH)
            {
                pszHostName[dwHostNameLength] = chBkChar; // put back char
                dwError = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            hostValueSize = wsprintf(hostValue, "%s:%d", pszHostName, (port & 0xffff));
            hostValueStr = hostValue;
        }

        pszHostName[dwHostNameLength] = chBkChar; // put back char

        //
        // replace the "Host:" header
        //

        _pRequest->ReplaceRequestHeader(HTTP_QUERY_HOST,
                             hostValueStr,
                             hostValueSize,
                             0, // dwIndex
                             ADD_HEADER
                             );

        //
        // and get the corresponding server info, resolving the name if
        // required
        //

        // _pRequest->SetServerInfo(FALSE);

        //
        // Since we are redirecting to a different host, force an update of the origin
        // server.  Otherwise, we will still pick up the proxy info of the first server.
        //
        
        // todo:
        // _pRequest->SetOriginServer(TRUE);
    }

    currentSchemeType = ((WINHTTP_FLAG_SECURE & _pRequest->GetOpenFlags()) ?
                            INTERNET_SCHEME_HTTPS :
                            INTERNET_SCHEME_HTTP);

    if ( currentSchemeType != schemeType )
    {
        DWORD OpenFlags = _pRequest->GetOpenFlags();

        // Switched From HTTPS to HTTP
        if ( currentSchemeType == INTERNET_SCHEME_HTTPS )
        {
            INET_ASSERT(schemeType != INTERNET_SCHEME_HTTPS );

            OpenFlags &= ~(WINHTTP_FLAG_SECURE);
        }

        // Switched From HTTP to HTTPS
        else if ( schemeType == INTERNET_SCHEME_HTTPS )
        {
            INET_ASSERT(currentSchemeType == INTERNET_SCHEME_HTTP );

            OpenFlags |= (WINHTTP_FLAG_SECURE);
        }

        _pRequest->SetOpenFlags(OpenFlags);
        _pRequest->SetSchemeType(schemeType);

    }

    _pRequest->SetURL(m_lpszRetUrl);

    if (_pRequest->IsRequestUsingProxy())
    {
        _pRequest->ModifyRequest(_pRequest->GetMethodType(),
                                 m_lpszRetUrl,
                                 strlen(m_lpszRetUrl),
                                 NULL,
                                 0);
    }
    else
    {
        _pRequest->ModifyRequest(_pRequest->GetMethodType(),
                                 pszUrlPath, // m_lpszRetUrl,
                                 strlen(pszUrlPath),//strlen(m_lpszRetUrl),
                                 NULL,
                                 0);
    }

cleanup:

    return dwError;
}


/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD PASSPORT_CTX::PreAuthUser(IN LPSTR pBuf, IN OUT LPDWORD pcbBuf)
{
    DEBUG_ENTER ((
		DBG_HTTP,
        Dword,
        "PASSPORT_CTX::PreAuthUser",
        "this=%#x pBuf=%#x pcbBuf=%#x {%d}",
        this,
        pBuf,
        pcbBuf,
        *pcbBuf
        ));

    if (!AuthLock())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DWORD dwError = ERROR_SUCCESS;
    LPWSTR pwszFromPP = NULL;

    // Prefix the header value with the auth type.
    const static BYTE szPassport[] = "Passport1.4 ";
    #define PASSPORT_LEN sizeof(szPassport)-1
    
    if (m_pszFromPP == NULL) 
    {
        if (m_hLogon == NULL)
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto cleanup;
        }

        DWORD dwFromPPLen = 0;
        BOOL fCredSet;
        dwError = SetCreds(&fCredSet);
        if (dwError != ERROR_SUCCESS)
        {
            goto cleanup;
        }

        LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();

        m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
        ::InternetSetThreadInfo(m_pNewThreadInfo);


        DWORD dwLogonStatus = ::PP_Logon(m_hLogon,
                                         FALSE,
                                         0,
                                         NULL,
                                         0);

        ::InternetSetThreadInfo(pCurrentThreadInfo);

        if (dwLogonStatus != PP_LOGON_SUCCESS)
        {
            if (dwLogonStatus == PP_LOGON_FAILED)
            {
                m_fPreauthFailed = TRUE;
            }
            
            dwError = ERROR_WINHTTP_INTERNAL_ERROR; // need to double check this return error
            goto cleanup;
        }

        dwError = HandleSuccessfulLogon(&pwszFromPP, &dwFromPPLen, TRUE);

        if (dwError == ERROR_WINHTTP_LOGIN_FAILURE)
        {
            goto cleanup;
        }
        
        m_pszFromPP = new CHAR [dwFromPPLen];
        if (m_pszFromPP == NULL)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        
        ::WideCharToMultiByte(CP_ACP, 0, pwszFromPP, -1, m_pszFromPP, dwFromPPLen, NULL, NULL);
    }

    // check to see if we need to update url

    if (m_lpszRetUrl)
    {
        dwError = ModifyRequestBasedOnRU();

        if (dwError != ERROR_SUCCESS)
        {
            // delete [] m_lpszRetUrl;
            // m_lpszRetUrl = NULL;
            
            goto cleanup;
        }

        // delete [] m_lpszRetUrl;
        // m_lpszRetUrl = NULL;
    }

    // Ticket and profile is already present
    
    if ((PASSPORT_LEN + ::strlen(m_pszFromPP) + 1) > (*pcbBuf))
    {
        DWORD dwRequiredSize = (DWORD)(PASSPORT_LEN + strlen(m_pszFromPP));
        *pcbBuf = HTTP_AUTHORIZATION_LEN + 1 + dwRequiredSize +  2 + 1;
        dwError = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }

    // put in the header
    memcpy (pBuf, szPassport, PASSPORT_LEN);
    pBuf += PASSPORT_LEN;

    // append the ticket
    strcpy(pBuf, m_pszFromPP);
    *pcbBuf = (DWORD)(PASSPORT_LEN + strlen(m_pszFromPP));

    // m_AuthComplete = TRUE;

cleanup:
    if (pwszFromPP)
        delete [] pwszFromPP;

    AuthUnlock();

    DEBUG_LEAVE(dwError);
    return dwError;
}

/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD PASSPORT_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    DEBUG_ENTER ((
		DBG_HTTP,
        Dword,
        "PASSPORT_CTX::UpdateFromHeaders", 
        "this=%#x request=%#x isproxy=%B",
        this,
        pRequest,
        fIsProxy
        ));

    if (!AuthLock())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DWORD dwAuthIdx, cbChallenge, dwError;
    LPSTR szChallenge = NULL;

    // Get the associated header.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto exit;

    //if (m_AuthComplete)
    //{
    //    _pRequest->SetStatusCode(401);  // this is needed to prevent send code from tracing Location: header
    //    dwError = ERROR_WINHTTP_LOGIN_FAILURE;
    //    goto exit;
    //}

    // Get the complete auth header.
    dwError = GetAuthHeaderData(pRequest, fIsProxy, NULL, 
        &szChallenge, &cbChallenge, ALLOCATE_BUFFER, dwAuthIdx);

    if (dwError != ERROR_SUCCESS)
    {
        szChallenge = NULL;
        goto exit;
    }

    if (_fChallengeSeen)
    {
        dwError = ERROR_HTTP_HEADER_NOT_FOUND;
        goto exit;
    }

    if (!_pCreds)
    {
        _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, NULL);
        if (!_pCreds)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
    }
    
    if (m_pwszPartnerInfo)
    {
        delete [] m_pwszPartnerInfo;
        m_pwszPartnerInfo = NULL;
    }

    {
        LPSTR lpszVerb;
        DWORD dwVerbLength;
        lpszVerb = _pRequest->_RequestHeaders.GetVerb(&dwVerbLength);
        #define MAX_VERB_LENGTH 16
        CHAR szOrgVerb[MAX_VERB_LENGTH] = {0};
        if (dwVerbLength > MAX_VERB_LENGTH - 1)
        {
            goto exit;
        }
        strncpy(szOrgVerb, lpszVerb, dwVerbLength+1);
        PCSTR pszOrgUrl = _pRequest->GetURL();

        const LPWSTR pwszOrgVerbAttr = L",OrgVerb=";
        const LPWSTR pwszOrgUrlAttr =  L",OrgUrl=";

        DWORD dwPartnerInfoLength = cbChallenge 
                                    +::wcslen(pwszOrgVerbAttr)
                                    +::strlen(szOrgVerb)
                                    +::wcslen(pwszOrgUrlAttr)
                                    +::strlen(pszOrgUrl)
                                    + 1; // NULL terminator
        
        DWORD dwSize = 0;
        PWSTR pwszPartnerInfo = NULL;

        m_pwszPartnerInfo = new WCHAR[dwPartnerInfoLength];
        if (m_pwszPartnerInfo == NULL)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        pwszPartnerInfo = m_pwszPartnerInfo;

        dwSize = ::MultiByteToWideChar(CP_ACP, 0, szChallenge, -1, pwszPartnerInfo, dwPartnerInfoLength) - 1;
        ::wcscat(pwszPartnerInfo, pwszOrgVerbAttr);
        pwszPartnerInfo += (dwSize + wcslen(pwszOrgVerbAttr));
        dwPartnerInfoLength -= (dwSize + wcslen(pwszOrgVerbAttr));
        dwSize = ::MultiByteToWideChar(CP_ACP, 0, szOrgVerb, -1, pwszPartnerInfo, dwPartnerInfoLength) - 1;
        ::wcscat(pwszPartnerInfo, pwszOrgUrlAttr);
        pwszPartnerInfo += (dwSize + wcslen(pwszOrgUrlAttr));
        dwPartnerInfoLength -= (dwSize + wcslen(pwszOrgUrlAttr));
        dwSize = ::MultiByteToWideChar(CP_ACP, 0, pszOrgUrl, -1, pwszPartnerInfo, dwPartnerInfoLength) - 1;

        dwError = ERROR_SUCCESS;
    }

    _fChallengeSeen = TRUE;

exit:

    if (szChallenge)
        delete []szChallenge;

    AuthUnlock();

    DEBUG_LEAVE(dwError);
    return dwError;
}

BOOL PASSPORT_CTX::InitLogonContext(void)
{
    // set up the thread context before calling the Passport auth library
    
    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);

    if (!m_hLogon)
    {
        INET_ASSERT(m_pInternet->GetPPContext()); // must have been initialized in the Init() call

        m_hLogon = ::PP_InitLogonContext(
                                        m_pInternet->GetPPContext(),
                                        m_pwszPartnerInfo,
                                        (_pRequest->GetOpenFlags() & INTERNET_FLAG_NO_COOKIES),
                                        NULL,
                                        NULL
                                        );
    }

    // restore the WinHttp thread context
    ::InternetSetThreadInfo(pCurrentThreadInfo);

    PCWSTR pwszRealm = ::wcsstr(m_pwszPartnerInfo, L"srealm");
    if (pwszRealm)
    {
        pwszRealm += ::wcslen(L"srealm");
        if (*pwszRealm == L'=')
        {
            pwszRealm++;
            DWORD i = 0;
            while (*pwszRealm != 0 && *pwszRealm != L',' && i < MAX_AUTH_REALM_LEN-1)
            {
                m_wRealm[i++] = *pwszRealm++;
            }

            m_wRealm[i] = 0; // null-terminate it
        }
    }

    if (!m_wRealm[0])
    {
        DWORD dwRealmLen = MAX_AUTH_REALM_LEN;
        PP_GetRealm(m_pInternet->GetPPContext(), m_wRealm, &dwRealmLen);
    }
    
    return m_hLogon != NULL;
}

/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD PASSPORT_CTX::PostAuthUser()
{
    DEBUG_ENTER ((
                 DBG_HTTP,
                 Dword,
                 "PASSPORT_CTX::PostAuthUser",
                 "this=%#x",
                 this
                 ));
    
    if (!AuthLock())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DWORD dwRet = ERROR_SUCCESS;

    if (InitLogonContext() == FALSE)
    {
        dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
        goto exit;
    }

    BOOL fCredSet;
    dwRet = SetCreds(&fCredSet);
    if (dwRet != ERROR_SUCCESS)
    {
        goto exit;
    }
        
    // Ok, Let's give it a try

    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);
    
    DWORD dwLogonStatus = ::PP_Logon(m_hLogon, 
                                     m_fAnonymous,                             
                                     0, 
                                     NULL, 
                                     0);

    // restore the WinHttp thread context
    ::InternetSetThreadInfo(pCurrentThreadInfo);

    if (dwLogonStatus == PP_LOGON_REQUIRED)
    {
        // no creds specified, we are required to sign on.
        
        // change from 302 to 401
        _pRequest->ReplaceResponseHeader(HTTP_QUERY_STATUS_CODE,
                                        "401", strlen("401"),
                                        0, HTTP_ADDREQ_FLAG_REPLACE);

        // biaow-todo: 1) nice to replace the status text as well; weird to have "HTTP/1.1 401 object moved"
        // for example 2) remove the Location: header

        BOOL fPrompt;
        DWORD dwCbUrlSize = 0;
        DWORD dwCbTxtSize = 0;
        ::PP_GetChallengeInfo(m_hLogon, 
                              &fPrompt, NULL, &dwCbUrlSize, NULL, &dwCbTxtSize, m_wRealm, MAX_AUTH_REALM_LEN);

        PWSTR pwszCbUrl = NULL;
        PWSTR pwszCbTxt = NULL;

        if (dwCbUrlSize)
        {
            pwszCbUrl = new WCHAR[dwCbUrlSize];    
        }

        if (dwCbTxtSize)
        {
            pwszCbTxt = new WCHAR[dwCbTxtSize];    
        }

        ::PP_GetChallengeInfo(m_hLogon, 
                              NULL, pwszCbUrl, &dwCbUrlSize, pwszCbTxt, &dwCbTxtSize, NULL, 0);

        if (pwszCbUrl)
        {
            m_pszCbUrl = new CHAR[wcslen(pwszCbUrl)+1];
            
            if (m_pszCbUrl)
            {
                ::WideCharToMultiByte(CP_ACP, 0, pwszCbUrl, -1, m_pszCbUrl, wcslen(pwszCbUrl)+1, NULL, NULL);
                UrlUnescapeA(m_pszCbUrl, NULL, NULL, URL_UNESCAPE_INPLACE);
            }
        }

        if (pwszCbTxt)
        {
            m_pszCbTxt = new CHAR[wcslen(pwszCbTxt)+1];
            if (m_pszCbTxt)
            {
                ::WideCharToMultiByte(CP_ACP, 0, pwszCbTxt, -1, m_pszCbTxt, wcslen(pwszCbTxt)+1, NULL, NULL);
                UrlUnescapeA(m_pszCbTxt, NULL, NULL, URL_UNESCAPE_INPLACE);
            }
        }

        delete [] pwszCbUrl;
        delete [] pwszCbTxt;

        if (fPrompt)
        {
            dwRet = ERROR_WINHTTP_INCORRECT_PASSWORD;
        }
        else
        {

            if (m_fAnonymous)
            {
                if (fCredSet)
                {
                    dwRet = ERROR_WINHTTP_RESEND_REQUEST;
                }
                else
                {
                    dwRet = ERROR_WINHTTP_INCORRECT_PASSWORD;
                }

                m_fAnonymous = FALSE;
            }
            else
            {
                dwRet = ERROR_WINHTTP_INCORRECT_PASSWORD;
            }
        }

        if (dwRet == ERROR_WINHTTP_INCORRECT_PASSWORD)
        {
            Transfer401ContentFromPP();
        }

        /*
        if (RetryLogon() == TRUE)
        {
            dwRet = ERROR_WINHTTP_RESEND_REQUEST;
        }
        else
        {
            dwRet = ERROR_WINHTTP_INCORRECT_PASSWORD;
        }
        */
    }
    else if (dwLogonStatus == PP_LOGON_SUCCESS)
    {
        // wow! we got in!!!

        DWORD dwFromPPLen = 0;
        LPWSTR pwszFromPP = NULL;

        dwRet = HandleSuccessfulLogon(&pwszFromPP, &dwFromPPLen, FALSE);
        if (dwRet != ERROR_WINHTTP_LOGIN_FAILURE)
        {
            if (m_pszFromPP)
            {
                delete [] m_pszFromPP;
            }

            m_pszFromPP = new CHAR [dwFromPPLen];
            if (m_pszFromPP)
            {
                ::WideCharToMultiByte(CP_ACP, 0, pwszFromPP, -1, m_pszFromPP, dwFromPPLen, NULL, NULL);
            }
        }
        if (pwszFromPP)
        {
            delete [] pwszFromPP;
        }

        m_fAnonymous = FALSE;
    }
    else
    {
        Transfer401ContentFromPP();

        dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
    }

exit:
    _pRequest->SetStatusCode(401);  // this is needed to prevent send code from tracing Location: header

    AuthUnlock();
    
    DEBUG_LEAVE(dwRet);
    return dwRet;
}

BOOL PASSPORT_CTX::Transfer401ContentFromPP(void)
{
    DWORD ContentLength = 0;
    ::PP_GetChallengeContent(m_hLogon, 
                             NULL,
                             &ContentLength);
    if (ContentLength > 0)
    {
        LPBYTE pContent = (LPBYTE)ALLOCATE_FIXED_MEMORY(ContentLength);
        if (pContent == NULL)
        {
            return FALSE;
        }

        if (::PP_GetChallengeContent(m_hLogon, 
                             pContent,
                             &ContentLength) == TRUE)
        {
            BOOL fDrained;
            
            // play with socket mode to force DrainResponse to return synchronously

            ICSocket* pSocket = _pRequest->_Socket;
            if (pSocket)
            {
                BOOL fSocketModeSet = FALSE;
                if (pSocket->IsNonBlocking())
                {
                    pSocket->SetNonBlockingMode(FALSE);
                    fSocketModeSet = TRUE;
                }

                INET_ASSERT(pSocket->IsNonBlocking() == FALSE);
                
                _pRequest->DrainResponse(&fDrained);

                if (fSocketModeSet)
                {
                    pSocket->SetNonBlockingMode(TRUE);
                }
            }

            _pRequest->_ResponseHeaders.FreeHeaders();
            _pRequest->FreeResponseBuffer();
            _pRequest->ResetResponseVariables();
            _pRequest->_ResponseHeaders.Initialize();

            // _pRequest->_dwCurrentStreamPosition = 0;

            _pRequest->CloneResponseBuffer(pContent, ContentLength);
        }
        FREE_MEMORY(pContent);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\auth\htuu.h ===
/*
   This file was derived from the libwww code, version 2.15, from CERN.
   A number of modifications have been made by Spyglass.

   eric@spyglass.com
 */

/*                              ENCODING TO PRINTABLE CHARACTERS

   File module provides functions HTUU_encode() and HTUU_decode() which convert a buffer
   of bytes to/from RFC 1113 printable encoding format. This technique is similar to the
   familiar Unix uuencode format in that it maps 6 binary bits to one ASCII character (or
   more aptly, 3 binary bytes to 4 ASCII characters).  However, RFC 1113 does not use the
   same mapping to printable characters as uuencode.

	Ported to WinINet Plug In DLL by arthurbi Dec-23-1995

 */

#ifndef HTUU_H
#define HTUU_H

#ifdef __cplusplus
extern "C" {
#endif

int HTUU_encode(unsigned char *bufin, int nbytes, char *bufout, int bufoutsize);
int HTUU_decode(char *bufin, unsigned char *bufout, int bufoutsize);

#ifdef __cplusplus
} // end extern "C"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\apsvc\svcctrl.cpp ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    apsvcc.cpp

Abstract:

    Implements the ServiceMain & Service Control Handler for the Auto-Proxy Service.

Author:

    Biao Wang (biaow) 10-May-2002

--*/

#include "wininetp.h"
#include <winsvc.h>
#include "apsvcdefs.h"
#include "apsvc.h"
#include "rpcsrv.h"

// global variables
SERVICE_STATUS_HANDLE   g_hSvcStatus    = NULL;
HANDLE                  g_hSvcStopEvent = NULL;
HANDLE                  g_hSvcStopWait  = NULL;
AUTOPROXY_RPC_SERVER*   g_pRpcSrv       = NULL;

#ifdef ENABLE_DEBUG
HKEY                    g_hKeySvcParams = NULL;
#endif

BOOL                    g_fShutdownInProgress   = FALSE;

CCritSec                g_SvcShutdownCritSec;

VOID SvcCleanUp(VOID);

VOID SvcHandlePowerEvents(
    WPARAM wParam,
    LPARAM lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);
    
    if (g_pRpcSrv == NULL)
    {
        LOG_EVENT(AP_ERROR, MSG_WINHTTP_AUTOPROXY_SVC_DATA_CORRUPT); 
        return;
    }

    switch (wParam)
    {
        case PBT_APMQUERYSUSPEND:
            
            g_pRpcSrv->Pause();
            break;

        case PBT_APMQUERYSUSPENDFAILED:
        case PBT_APMRESUMEAUTOMATIC:
        case PBT_APMRESUMESUSPEND:
            
            g_pRpcSrv->Resume();
            break;
        
        case PBT_APMRESUMECRITICAL:
        
            g_pRpcSrv->Refresh();

            break;

        case PBT_APMSUSPEND:
            break;
        
        default:
            ;
    }
}

DWORD WINAPI SvcControl(
    DWORD   dwControl,     // requested control code
    DWORD   dwEventType,   // event type
    LPVOID  lpEventData,  // event data
    LPVOID  lpContext     // user-defined context data
)
{
    UNREFERENCED_PARAMETER(lpContext);
    
    DWORD dwError = NO_ERROR;
    LPSERVICE_STATUS pSvcStatus = NULL;    
    
    if ((g_pRpcSrv == NULL) ||
        ((pSvcStatus = g_pRpcSrv->GetServiceStatus()) == NULL) ||
        (g_hSvcStatus == NULL))
    {
        LOG_EVENT(AP_ERROR, MSG_WINHTTP_AUTOPROXY_SVC_DATA_CORRUPT);
        return dwError;
    }

    switch (dwControl)
    {
        case SERVICE_CONTROL_INTERROGATE:
            break;
        case SERVICE_CONTROL_STOP:
//#ifdef ENABLE_DEBUG
//            LOG_DEBUG_EVENT(AP_WARNING, "[stopping-debug] received Service-Control-Stop from SCM");
//#endif
            if (g_hSvcStopEvent)
            {
                ::SetEvent(g_hSvcStopEvent);

//#ifdef ENABLE_DEBUG
//            LOG_DEBUG_EVENT(AP_WARNING, "[stopping-debug] signed the Wait-Stop event");
//#endif
                // rest of the stop work should be picked up by SvcTimerAndStop() callback
            }

            pSvcStatus->dwCurrentState = SERVICE_STOP_PENDING;
            pSvcStatus->dwWin32ExitCode = NO_ERROR;
            pSvcStatus->dwCheckPoint = 0;
            pSvcStatus->dwWaitHint = AUTOPROXY_SERVICE_STOP_WAIT_HINT;

            break;
        case SERVICE_CONTROL_POWEREVENT:
            SvcHandlePowerEvents(dwEventType, (LPARAM)lpEventData);
            break;
        default:
            dwError = ERROR_CALL_NOT_IMPLEMENTED;
    }

    ::SetServiceStatus(g_hSvcStatus, pSvcStatus);

    return dwError;
}

VOID CALLBACK SvcTimerAndStop(
    PVOID lpParameter,        // thread data
    BOOLEAN TimerOrWaitFired  // reason
)
{
    UNREFERENCED_PARAMETER(lpParameter);
    
//#ifdef ENABLE_DEBUG
//    LOG_DEBUG_EVENT(AP_WARNING, "[stopping-debug] Stop Callback function called");
//#endif
    if (g_fShutdownInProgress)
    {
//#ifdef ENABLE_DEBUG
//    LOG_DEBUG_EVENT(AP_WARNING, "[stopping-debug] svc is shuting down, return...");
//#endif
        return;
    }

    g_SvcShutdownCritSec.Lock();

    if (g_fShutdownInProgress)
    {
        goto exit;
    }

    LPSERVICE_STATUS pSvcStatus = NULL;

    if ((g_pRpcSrv == NULL) ||
        ((pSvcStatus = g_pRpcSrv->GetServiceStatus()) == NULL) ||
        (g_hSvcStatus == NULL))
    {
        LOG_EVENT(AP_ERROR, MSG_WINHTTP_AUTOPROXY_SVC_DATA_CORRUPT);
        goto exit;
    }

    if (TimerOrWaitFired == TRUE) // timed-out
    {
//#ifdef ENABLE_DEBUG
//        LOG_DEBUG_EVENT(AP_WARNING, "[stopping-debug] TimerOrWaitFired = TRUE");
//#endif
        DWORD dwIdleTimeout = AUTOPROXY_SVC_IDLE_TIMEOUT * 60 * 1000;

#ifdef ENABLE_DEBUG
        DWORD dwRegVal;
        DWORD dwValType;
        DWORD dwValSize = sizeof(dwRegVal);
        if (::RegQueryValueExW(g_hKeySvcParams,
                              L"IdleTimeout",
                              NULL,
                              &dwValType,
                              (LPBYTE)&dwRegVal,
                              &dwValSize) == ERROR_SUCCESS)
        {
            if ((dwValType == REG_DWORD) && (dwRegVal != 0))
            {
                dwIdleTimeout = dwRegVal; // the value unit from registry is milli-sec.
            }
        }
#endif

        if (!g_pRpcSrv->IsIdle(dwIdleTimeout))    // Has been idle for 3 minutes?
        {
//#ifdef ENABLE_DEBUG
//            LOG_DEBUG_EVENT(AP_WARNING, "[stopping-debug] idle timeout not yet expired, quit");
//#endif
            goto exit;
        }

        WCHAR wIdleTimeout[16] = {0};
        ::swprintf(wIdleTimeout, L"%d", AUTOPROXY_SVC_IDLE_TIMEOUT);
        LOG_EVENT(AP_INFO, MSG_WINHTTP_AUTOPROXY_SVC_IDLE_TIMEOUT, wIdleTimeout);

        // fall thru to kick start shutdown when idle for 3 minutes
    }

    g_fShutdownInProgress = TRUE;

    pSvcStatus->dwCurrentState = SERVICE_STOP_PENDING;
    pSvcStatus->dwWin32ExitCode = NO_ERROR;
    pSvcStatus->dwCheckPoint = 1;
    pSvcStatus->dwWaitHint = AUTOPROXY_SERVICE_STOP_WAIT_HINT;

    if (g_pRpcSrv->Close() == TRUE)
    {
#ifdef ENABLE_DEBUG
        DWORD dwShutdownDelay = 0;

        DWORD dwRegVal;
        DWORD dwValType;
        DWORD dwValSize = sizeof(dwRegVal);
        if (::RegQueryValueExW(g_hKeySvcParams,
                              L"ShutdownDelay",
                              NULL,
                              &dwValType,
                              (LPBYTE)&dwRegVal,
                              &dwValSize) == ERROR_SUCCESS)
        {
            if ((dwValType == REG_DWORD) && (dwRegVal != 0))
            {
                dwShutdownDelay = dwRegVal; // the value unit from registry is milli-sec.
            }
        }

        ::Sleep(dwShutdownDelay);
#endif        
        pSvcStatus->dwCurrentState = SERVICE_STOPPED;
        pSvcStatus->dwWaitHint = 0;

        ::SetServiceStatus(g_hSvcStatus, pSvcStatus);

        SvcCleanUp();
    }
    else
    {
        // so for some reason we couldn't shut down gracefully, and if the STOP is initiated
        // from SCM, then we will be stuck in the STOPPING state (if we are the last service
        // in the svchost.exe then we will be forcefully shutdown in 30 seconds). If we are
        // idle-stopping, we will revert course and transit back to the RUNNING state. In either
        // case we should resume the RPC service.

        g_pRpcSrv->Resume();

        if (TimerOrWaitFired == TRUE)   // we are idle-stopping, transit back to RUNNING
        {
            pSvcStatus->dwCurrentState = SERVICE_RUNNING;
            pSvcStatus->dwWin32ExitCode = NO_ERROR;
            pSvcStatus->dwCheckPoint = 0;
            pSvcStatus->dwWaitHint = 0;

            ::SetServiceStatus(g_hSvcStatus, pSvcStatus);

            g_fShutdownInProgress = FALSE; // we still allow future shutdown attempts
        }
        else
        {
            // we unregister the idle timer since there is no point of doing idle-shutdown

            if (g_hSvcStopWait)
            {
                ::UnregisterWaitEx(g_hSvcStopWait, NULL);
                g_hSvcStopWait = NULL;
            }
        }
    }

exit:

    g_SvcShutdownCritSec.Unlock();

    return;
}

VOID AutoProxySvcUnload(VOID)
{
    g_SvcShutdownCritSec.FreeLock();
}

EXTERN_C VOID WINAPI WinHttpAutoProxySvcMain(
    DWORD dwArgc,     // number of arguments
    LPWSTR *lpwszArgv  // array of arguments
)
{
    UNREFERENCED_PARAMETER(dwArgc);
    UNREFERENCED_PARAMETER(lpwszArgv);

    DWORD dwError;
    static SERVICE_STATUS          SvcStatus;

    SvcStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS; // we share svchost.exe w/ other Local Services
    SvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_POWEREVENT;
    SvcStatus.dwWin32ExitCode = NO_ERROR;
    SvcStatus.dwServiceSpecificExitCode = 0;
    SvcStatus.dwCheckPoint = 0;
    SvcStatus.dwWaitHint = 0;

    InitializeEventLog();

    g_hSvcStatus = ::RegisterServiceCtrlHandlerExW(WINHTTP_AUTOPROXY_SERVICE_NAME,
                                                   SvcControl,
                                                   NULL);
    if (g_hSvcStatus == NULL)
    {
        dwError = ::GetLastError();
        LOG_EVENT(AP_ERROR, 
                  MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR, 
                  L"RegisterServiceCtrlHandlerExW()", 
                  dwError);
        goto cleanup;
    }

    if (!g_SvcShutdownCritSec.IsInitialized())
    {
        if (g_SvcShutdownCritSec.Init() == FALSE)
        {
            LOG_EVENT(AP_ERROR, MSG_WINHTTP_AUTOPROXY_SVC_FAILED_ALLOCATE_RESOURCE);
            goto cleanup;
        }
    }

    g_hSvcStopEvent = ::CreateEvent(NULL, 
                                    FALSE,   // manual reset 
                                    FALSE,  // not signalled 
                                    NULL);
    if (g_hSvcStopEvent == NULL)
    {
        dwError = ::GetLastError();
        LOG_EVENT(AP_ERROR, MSG_WINHTTP_AUTOPROXY_SVC_FAILED_ALLOCATE_RESOURCE);
        goto cleanup;
    }

    g_pRpcSrv = new AUTOPROXY_RPC_SERVER;
    if (g_pRpcSrv == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        LOG_EVENT(AP_ERROR, MSG_WINHTTP_AUTOPROXY_SVC_FAILED_ALLOCATE_RESOURCE);    
        goto cleanup;
    }

#ifdef ENABLE_DEBUG
    long lError;
    if ((lError = ::RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                     L"SYSTEM\\CurrentControlSet\\Services\\WinHttpAutoProxySvc\\Parameters",
                     0,
                     KEY_QUERY_VALUE,
                     &g_hKeySvcParams)) != ERROR_SUCCESS)
    {
        g_hKeySvcParams = NULL;
        LOG_EVENT(AP_WARNING, 
                  MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR, 
                  L"RegOpenKeyExW()", 
                  lError);    
    }
#endif

    SvcStatus.dwCurrentState = SERVICE_START_PENDING;
    SvcStatus.dwCheckPoint = 0;
    SvcStatus.dwWaitHint = AUTOPROXY_SERVICE_START_WAIT_HINT;

    if (::SetServiceStatus(g_hSvcStatus, &SvcStatus) == FALSE)
    {
        dwError = ::GetLastError();
        LOG_EVENT(AP_ERROR, 
                 MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR,
                 L"SetServiceStatus()",
                 dwError);
        goto cleanup;
    }

    // ** after this point the HandleEx() control thread can start to call us

    if (g_pRpcSrv->Open(&SvcStatus) == FALSE)
    {
        SvcStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
        SvcStatus.dwServiceSpecificExitCode = g_pRpcSrv->GetLastError();
        SvcStatus.dwWaitHint = 0;

        //LOG_DEBUG_EVENT(AP_ERROR, 
        //         "The Auto-Proxy service failed to start due to a RPC server error; error = %d", 
        //         SvcStatus.dwServiceSpecificExitCode);
        goto cleanup;
    }

    SvcStatus.dwCurrentState = SERVICE_RUNNING;
    SvcStatus.dwWaitHint = 0;

    if (::SetServiceStatus(g_hSvcStatus, &SvcStatus) == FALSE)
    {
        dwError = ::GetLastError();
        LOG_EVENT(AP_ERROR, 
                  MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR, 
                  L"SetServiceStatus()",
                  dwError);
    
        // if for some reason we can't indicate that we are up & running (or stopped), the SCM 
        // should time-out and stop us; so we don't cleanup here
    }

    // Ok we are up & running, but before we return to SCM we need to direct a wait thread to 
    // wait on an service-stop event. We also configure the wait thread to call us periodically
    // so that we can detect and shut down after a idle period of time.

    DWORD dwTimerInterval = AUTOPROXY_SVC_IDLE_CHECK_INTERVAL * 1000;
    
#ifdef ENABLE_DEBUG
    DWORD dwRegVal;
    DWORD dwValType;
    DWORD dwValSize = sizeof(dwRegVal);
    if (::RegQueryValueExW(g_hKeySvcParams,
                           L"IdleTimerInterval",
                           NULL,
                           &dwValType,
                           (LPBYTE)&dwRegVal,
                           &dwValSize) == ERROR_SUCCESS)
    {
        if ((dwValType == REG_DWORD) && (dwRegVal != 0))
        {
            dwTimerInterval = dwRegVal; // the value unit from registry is millisec.
        }
    }
#endif

    if (::RegisterWaitForSingleObject(&g_hSvcStopWait, 
                                      g_hSvcStopEvent, 
                                      SvcTimerAndStop, 
                                      NULL,
                                      dwTimerInterval,
                                      0) == FALSE)
    {
        dwError = ::GetLastError();
        LOG_EVENT(AP_WARNING, 
                  MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR,
                  L"RegisterWaitForSingleObject()",
                  dwError);

        // we fail to direct a wait thread to wait on the service-stop event, so we hang on to the ServiceMain thread
        // to wait for the event (this should not happen)
        g_hSvcStopWait = NULL;

        ::WaitForSingleObject(g_hSvcStopEvent, INFINITE);

        // ServiceMain would wait until the service-stop event is fired by the SCM
        
        SvcTimerAndStop(NULL, 
                        FALSE   // event signaled
                        );
    }

    // if we successfully direct a wait thread to wait on the service-stop event, we exit out
    // of the ServiceMain thread

    return;

cleanup:

    if (g_hSvcStatus)
    {
        SvcStatus.dwCurrentState = SERVICE_STOPPED;
        
        ::SetServiceStatus(g_hSvcStatus, &SvcStatus);
    }

   SvcCleanUp();
}

VOID SvcCleanUp(VOID)
{
    if (g_hSvcStopWait)
    {
        ::UnregisterWaitEx(g_hSvcStopWait, NULL);
        g_hSvcStopWait = NULL;
    }

#ifdef ENABLE_DEBUG
    if (g_hKeySvcParams)
    {
        ::RegCloseKey(g_hKeySvcParams);
        g_hKeySvcParams = NULL;
    }
#endif

    if (g_hSvcStopEvent)
    {
        ::CloseHandle(g_hSvcStopEvent);
        g_hSvcStopEvent = NULL;
    }

    if (g_pRpcSrv)
    {
        // no need to call close here -- close() failed, otherwise we won't be here
        delete g_pRpcSrv;
        g_pRpcSrv = NULL;
    }

    // note: according to MSDN, g_hSvcStatus doesn't need to be closed

    TerminateEventLog();    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\auth\sspspm.h ===
//#----------------------------------------------------------------------------
//
//  File:           sspspm.h
//
//      Synopsis:   Definitions specific to SSPI SPM DLL.
//
//      Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
//
//  Authors:        LucyC       Created                         25 Sept 1995
//
//-----------------------------------------------------------------------------
#ifndef _SSPSPM_H_
#define _SSPSPM_H_

#include <platform.h>

#ifdef __cplusplus
extern "C" {
#endif

//
//  Names of secruity DLL
//
#define SSP_SPM_NT_DLL      "security.dll"
#define SSP_SPM_WIN95_DLL   "secur32.dll"


#define SSP_SPM_DLL_NAME_SIZE   16          // max. length of security DLL names

#define MAX_SSPI_PKG        32              // Max. no. of SSPI supported

#define SSPPKG_ERROR        ((UCHAR) 0xff)
#define SSPPKG_NO_PKG       SSPPKG_ERROR
#define MAX_AUTH_MSG_SIZE   10000
#define TCP_PRINT   fprintf
#define DBG_CONTEXT stderr

#define MAX_BLOB_SIZE       13000

//
//  Server host list definition.

//  The following defines an entry in the server host list.
//
typedef struct _ssp_host_list
{
    struct _ssp_host_list   *pNext;

    unsigned char           *pHostname; // name of server host
    unsigned char           pkgID;      // the package being used for this host

} SspHosts, *PSspHosts;

//
//  List of SSPI packages installed on this machine.
//  The following defines an entry of the SSPI package list.
//
typedef struct _ssp_auth_pkg
{
    LPTSTR       pName;         // package name
    DWORD        Capabilities ; // Interesting capabilities bit
    ULONG        cbMaxToken;    // max size of security token
} SSPAuthPkg, *PSSPAuthPkg;

#define SSPAUTHPKG_SUPPORT_NTLM_CREDS   0x00000001

//
//  The following defines the global data structure which the SPM DLL keeps
//  in the HTSPM structure.
//
typedef struct _ssp_htspm
{
    PSecurityFunctionTable pFuncTbl;

    SSPAuthPkg      **PkgList;          // array of pointers to auth packages
    UCHAR           PkgCnt;



    BOOLEAN         bKeepList;          // whether to keep a list of servers
    
    PSspHosts       pHostlist;

} SspData, *PSspData;

#define SPM_STATUS_OK                   0
#define SPM_ERROR                       1
#define SPM_STATUS_WOULD_BLOCK          2
#define SPM_STATUS_INSUFFICIENT_BUFFER  3

/////////////////////////////////////////////////////////////////////////////
//
//  Function headers from sspcalls.c
//
/////////////////////////////////////////////////////////////////////////////

DWORD
GetSecAuthMsg (
    PSspData        pData,
    PCredHandle     pCredential,
    DWORD           pkgID,              // the package index into package list
    PCtxtHandle     pInContext,
    PCtxtHandle     pOutContext,
    ULONG           fContextReq,        // Request Flags
    VOID            *pBuffIn,
    DWORD           cbBuffIn,
    char            *pFinalBuff,
    DWORD           *pcbBuffOut,
    SEC_CHAR        *pszTarget,         // Server Host Name
    BOOL            fTargetTrusted,
    UINT            bNonBlock,
    LPSTR           pszScheme,
	SECURITY_STATUS *pssResult
    );

INT
GetPkgId(LPTSTR  lpszPkgName);

DWORD
GetPkgCapabilities(
    INT Package
    );
ULONG
GetPkgMaxToken(
    INT Package
    );

/////////////////////////////////////////////////////////////////////////////
//
//  Function headers from buffspm.c
//
/////////////////////////////////////////////////////////////////////////////

PSspHosts
SspSpmNewHost (
    PSspData pData,
    UCHAR    *pHost,       // name of server host to be added
    UCHAR    Package
    );

VOID
SspSpmDeleteHost(
    SspData     *pData,
    PSspHosts   pDelHost
    );

VOID
SspSpmTrashHostList(
    SspData     *pData
    );

PSspHosts
SspSpmGetHost(
    PSspData pData,
    UCHAR *pHost
    );

#ifdef __cplusplus
} // end extern "C" {
#endif

#endif  /* _SSPSPM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\auth\htuu.c ===
/*
   This file was derived from the libwww code, version 2.15, from CERN.
   A number of modifications have been made by Spyglass.

   eric@spyglass.com

   This file was removed from LibWWW and placed into the
   Security Protocol Module.

   jeff@spyglass.com
 */

/* MODULE                           HTUU.c
   **           UUENCODE AND UUDECODE
   **
   ** ACKNOWLEDGEMENT:
   **   This code is taken from rpem distribution, and was originally
   **   written by Mark Riordan.
   **
   ** AUTHORS:
   **   MR  Mark Riordan    riordanmr@clvax1.cl.msu.edu
   **   AL  Ari Luotonen    luotonen@dxcern.cern.ch
   **
   ** HISTORY:
   **   Added as part of the WWW library and edited to conform
   **   with the WWW project coding standards by:   AL  5 Aug 1993
   **   Originally written by:              MR 12 Aug 1990
   **   Original header text:
   ** -------------------------------------------------------------
   **  File containing routines to convert a buffer
   **  of bytes to/from RFC 1113 printable encoding format.
   **
   **  This technique is similar to the familiar Unix uuencode
   **  format in that it maps 6 binary bits to one ASCII
   **  character (or more aptly, 3 binary bytes to 4 ASCII
   **  characters).  However, RFC 1113 does not use the same
   **  mapping to printable characters as uuencode.
   **
   **  Mark Riordan   12 August 1990 and 17 Feb 1991.
   **  This code is hereby placed in the public domain.
   ** -------------------------------------------------------------
   **
   ** BUGS:
   **
   **
 */

#define MAXCODE 64

static const char six2pr[MAXCODE] =
{
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
};

static unsigned char pr2six[256];


/*--- function HTUU_encode -----------------------------------------------
 *
 *   Encode a single line of binary data to a standard format that
 *   uses only printing ASCII characters (but takes up 33% more bytes).
 *
 *    Entry    bufin      points to a buffer of bytes.
 *             nbytes     is the number of bytes in that buffer.
 *                        This cannot be more than 48.
 *             bufcoded   points to an output buffer.  Be sure that this
 *                        can hold at least 1 + 4*(nbytes+2)/3 characters.
 *             outbufsize is the maximum number of bytes that
 *                        can fit in bufcoded.
 *
 *    Exit     bufcoded   contains the coded line.  The first 4*(nbytes+2)/3
 *                        bytes contain printing ASCII characters representing
 *                        those binary bytes. This may include one or two '='
 *                        characters used as padding at the end.  The last
 *                        byte is a zero byte.
 *
 *             Returns the number of ASCII characters in bufcoded or -1 in
 *                     the case of overflow.
 */
int HTUU_encode(unsigned char *bufin, int nbytes, char *bufout, int bufoutsize)
{
/* ENC is the basic 1 character encoding function to make a char printing */
#define ENC(c) six2pr[c]

    char *bufcoded = bufout;

    while (nbytes > 0)
    {
        if (bufoutsize < 4)
            return (-1);

        *(bufout++) = ENC(*bufin >> 2);

        *(bufout++) = nbytes > 1 ?
            ENC((*bufin << 4) & 060 | (bufin[1] >> 4) & 017) :
            ENC((*bufin << 4) & 060);

        *(bufout++) = nbytes > 2 ?
            ENC((bufin[1] << 2) & 074 | (bufin[2] >> 6) & 03) :
            nbytes > 1 ? ENC((bufin[1] << 2) & 074) : '=';

        *(bufout++) = nbytes > 2 ? ENC(bufin[2] & 077) : '=';

        bufoutsize -= 4;
        bufin += 3;
        nbytes -= 3;
    }

    if (bufoutsize > 0)
        *bufout = '\0';

    return (int)(bufout - bufcoded);
}


/*--- function HTUU_decode ------------------------------------------------
 *
 *  Decode an ASCII-encoded buffer back to its original binary form.
 *
 *    Entry    bufcoded    points to a uuencoded string.  It is 
 *                         terminated by any character not in
 *                         the printable character table six2pr, but
 *                         leading whitespace is stripped.
 *             bufplain    points to the output buffer; must be big
 *                         enough to hold the decoded string (generally
 *                         shorter than the encoded string) plus
 *                         as many as two extra bytes used during
 *                         the decoding process.
 *             outbufsize  is the maximum number of bytes that
 *                         can fit in bufplain.
 *
 *    Exit     Returns the number of binary bytes decoded.
 *             bufplain    contains these bytes.
 */
int HTUU_decode(char *bufin, unsigned char *bufout, int bufoutsize)
{
/* single character decode */
#define DEC(c) pr2six[(unsigned char) c]

    static int first = 1;
    int nbytesdecoded = 0, nbytes;
    unsigned char c, *pc;

    /* If this is the first call, initialize the mapping table.
     * This code should work even on non-ASCII machines.
     */
    if (first)
    {
        first = 0;
        memset(pr2six, MAXCODE, sizeof(pr2six));

        for (c = 0; c < MAXCODE; c++)
            DEC(six2pr[c]) = c;
#if 0
        pr2six['A'] =  0; pr2six['B'] =  1; pr2six['C'] =  2; pr2six['D'] =  3; 
        pr2six['E'] =  4; pr2six['F'] =  5; pr2six['G'] =  6; pr2six['H'] =  7; 
        pr2six['I'] =  8; pr2six['J'] =  9; pr2six['K'] = 10; pr2six['L'] = 11; 
        pr2six['M'] = 12; pr2six['N'] = 13; pr2six['O'] = 14; pr2six['P'] = 15; 
        pr2six['Q'] = 16; pr2six['R'] = 17; pr2six['S'] = 18; pr2six['T'] = 19; 
        pr2six['U'] = 20; pr2six['V'] = 21; pr2six['W'] = 22; pr2six['X'] = 23; 
        pr2six['Y'] = 24; pr2six['Z'] = 25; pr2six['a'] = 26; pr2six['b'] = 27; 
        pr2six['c'] = 28; pr2six['d'] = 29; pr2six['e'] = 30; pr2six['f'] = 31; 
        pr2six['g'] = 32; pr2six['h'] = 33; pr2six['i'] = 34; pr2six['j'] = 35; 
        pr2six['k'] = 36; pr2six['l'] = 37; pr2six['m'] = 38; pr2six['n'] = 39; 
        pr2six['o'] = 40; pr2six['p'] = 41; pr2six['q'] = 42; pr2six['r'] = 43; 
        pr2six['s'] = 44; pr2six['t'] = 45; pr2six['u'] = 46; pr2six['v'] = 47; 
        pr2six['w'] = 48; pr2six['x'] = 49; pr2six['y'] = 50; pr2six['z'] = 51; 
        pr2six['0'] = 52; pr2six['1'] = 53; pr2six['2'] = 54; pr2six['3'] = 55; 
        pr2six['4'] = 56; pr2six['5'] = 57; pr2six['6'] = 58; pr2six['7'] = 59; 
        pr2six['8'] = 60; pr2six['9'] = 61; pr2six['+'] = 62; pr2six['/'] = 63;
#endif
    }

    /* Strip leading whitespace. */

    while (*bufin == ' ' || *bufin == '\t')
        bufin++;

    /* Figure out how many characters are in the input buffer. */
    for (pc = (unsigned char*)bufin; DEC(*pc) < MAXCODE; pc++);
    nbytes = (int)(pc - (unsigned char*)bufin);

    while (nbytes > 1)
    {
        if (bufoutsize < 3)
            return nbytesdecoded;

        *(bufout++) = DEC(*bufin) << 2 | DEC(bufin[1]) >> 4;
        *(bufout++) = DEC(bufin[1]) << 4 | DEC(bufin[2]) >> 2;
        *(bufout++) = nbytes > 2 ? (DEC(bufin[2]) << 6 | DEC(bufin[3])) : 0;

        bufoutsize -= 3;
        bufin += 4;
        nbytes -= 4;
        nbytesdecoded += 3;
    }

    if (nbytes < 0)
        nbytesdecoded += nbytes;

    return nbytesdecoded;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\auth\uudec.c ===
#include <stdio.h>
#include "htuu.h"

int main (int argc, char **argv)
{
    char outbuf[500];
    char *pOut = outbuf;
    int cbOut = (strlen(argv[1]) * 3) / 4;

    if (argc != 2)
    {
        fprintf (stderr, "usage: uudec <base64-string>\n");
        exit (1);
    }
    
    HTUU_decode (argv[1], pOut, sizeof(outbuf));

    while (cbOut--)
    {
        printf ("%02x %c\n", (unsigned char) *pOut, *pOut);
        pOut++;
    }
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\auth\winctxt.h ===
#ifndef _WIN_SIC_CTXT_H_
#define _WIN_SIC_CTXT_H_

#define DEFAULT_SERVER_NAME_LEN		128

typedef struct _WINCONTEXT	{

    //
    //  Buffer for storing exchange blob returned by SSPI before 
    //  PreAuthenticateUser is called
    //
    char        *szOutBuffer;
    DWORD       cbOutBuffer;        // bytes associated with allocated szOutBuffer
	DWORD		dwOutBufferLength;

    char        *szInBuffer;
    DWORD       cbInBuffer;         // bytes associated with allocated szInBuffer
    PCHAR       pInBuffer;
	DWORD		dwInBufferLength;

	DWORD		dwCallId;

	DWORD		pkgId;

    CredHandle  Credential;     // SSPI credential handle for this connection
    PCredHandle pCredential;

	//
	// The SSPI Context Handle is stored here
	//
	CtxtHandle	SspContextHandle;
	PCtxtHandle	pSspContextHandle;  // before any ctxt is created, this is NULL

	LPSTR		lpszServerName;

	char		szServerName[DEFAULT_SERVER_NAME_LEN];

} WINCONTEXT, *PWINCONTEXT;

#endif  // _WIN_SIC_CTXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\apsvc\rpcsrv.h ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    rpcsrv.h

Abstract:

    L-PRC interface for the auto-proxy service.

Author:

    Biao Wang (biaow) 10-May-2002

--*/

#ifndef _AUTOPROXY_RPC_SERVER_H
#define _AUTOPROXY_RPC_SERVER_H

class AUTOPROXY_RPC_SERVER
{
public:
    AUTOPROXY_RPC_SERVER(VOID);
    ~AUTOPROXY_RPC_SERVER(VOID);

    BOOL Open(LPSERVICE_STATUS);

    BOOL Pause(VOID);   // 1) complete all pending calls /w error ERROR_WINHTTP_OPERATION_CANCELLED
                        // 2) abort all pending WinHttpGetProxyForUrl() calls
                        // 3) mark _fInService FALSE
    
    BOOL Resume(VOID);  // mark _fInService TRUE
    
    BOOL Refresh(VOID); // invalidate results of all pending calls and cause all calls to retry
                        // to be called in case of a Resume-Critical power event

    BOOL Close(VOID);   // 1) call Pause() and 2) wait till all calls to exit gracefully

    LPSERVICE_STATUS GetServiceStatus(VOID) const { return _pServiceStatus; }

    RPC_STATUS GetLastError(VOID) const { return _RpcStatus; }

    BOOL IsIdle(DWORD dwMilliSeconds);

private:
    RPC_STATUS OnSecurityCallback(void *Context);
    // BOOL SafeImpersonate(VOID);

    // RPC call defined in the IDL interface file; should always be keep in-sync w/ the generated header file
    VOID AUTOPROXY_RPC_SERVER::GetProxyForUrl(
    /* [in] */ PRPC_ASYNC_STATE GetProxyForUrl_AsyncHandle,
    /* [in] */ handle_t hBinding,
    /* [string][in] */ const wchar_t *pcwszUrl,
    /* [in] */ const P_AUTOPROXY_OPTIONS pAutoProxyOptions,
    /* [in] */ const P_SESSION_OPTIONS pSessionOptions,
    /* [out][in] */ P_AUTOPROXY_RESULT pAutoProxyResult,
    /* [out][in] */ unsigned long *pdwLastError);

private:
    struct PENDING_CALL
    {
        PENDING_CALL() { 
            hSession = NULL;
            fCallCancelled = FALSE;
            fDiscardAndRetry = FALSE;
        }

        ~PENDING_CALL() {
            if (hSession)
            {
                ::WinHttpCloseHandle(hSession);
            }
        }

        LIST_ENTRY List;
        
        HINTERNET hSession; // if client wants auto-logon, we than create a session per request
                            // otherwise, global session handle will be used.
        PRPC_ASYNC_STATE hAsyncRequest;
        handle_t hBinding;
        LPDWORD pdwLastError;
        BOOL fCallCancelled;
        BOOL fDiscardAndRetry;
    };

private:
    RPC_STATUS _RpcStatus;
    BOOL _fInService;

    HINTERNET _hSession; // "global" session for anonymous access
    SERIALIZED_LIST _PendingRequestList;
    LPSERVICE_STATUS _pServiceStatus;

    // RPC_BINDING_HANDLE _hClientBinding;

    HANDLE _hExitEvent;

    BOOL _fServiceIdle;
    DWORD _dwIdleTimeStamp;

friend
RPC_STATUS 
RPC_ENTRY
RpcSecurityCallback (
    IN RPC_IF_HANDLE  InterfaceUuid,
    IN void *Context
    );

friend
/* [async] */ void  GetProxyForUrl( 
    /* [in] */ PRPC_ASYNC_STATE GetProxyForUrl_AsyncHandle,
    /* [in] */ handle_t hBinding,
    /* [string][in] */ const wchar_t *pcwszUrl,
    /* [in] */ const P_AUTOPROXY_OPTIONS pAutoProxyOptions,
    /* [in] */ const P_SESSION_OPTIONS pSessionOptions,
    /* [out][in] */ P_AUTOPROXY_RESULT pAutoProxyResult,
    /* [out][in] */ unsigned long *pdwLastError);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\auth\plug.cxx ===
#include <wininetp.h>
#include <splugin.hxx>
#include "auth.h"
#include "sspspm.h"
#include "winctxt.h"

extern SspData  *g_pSspData;
/*-----------------------------------------------------------------------------
    PLUG_CTX
-----------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Load
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::Load()
{
    INET_ASSERT(_pSPMData == _pCreds->pSPM);

    DWORD_PTR dwAuthCode = 0;

    dwAuthCode = SSPI_InitScheme (GetScheme());

    if (!dwAuthCode)
    {
        _pSPMData->eState = STATE_ERROR;
        return ERROR_WINHTTP_INTERNAL_ERROR;
    }

    _pSPMData->eState = STATE_LOADED;
    return ERROR_SUCCESS;
}


/*---------------------------------------------------------------------------
    ClearAuthUser
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::ClearAuthUser(LPVOID *ppvContext, LPSTR szServer)
{
    if (GetState() == AUTHCTX::STATE_LOADED)
    {
        __try
        {
            UnloadAuthenticateUser(ppvContext, szServer, GetScheme());
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            DEBUG_PRINT(HTTP, ERROR,
                ("UnloadAuthenticateUser call down faulted\n"));
        }
        ENDEXCEPT
    }
    *ppvContext = 0;
    return ERROR_SUCCESS;
}

/*-----------------------------------------------------------------------------
    wQueryHeadersAlloc

Routine Description:

    Allocates a HTTP Header String, and queries the HTTP handle for it.

Arguments:

    hRequestMapped          - An open HTTP request handle
                               where headers can be quiered
    dwQuery                 - The Query Type to pass to HttpQueryHeaders
    lpdwQueryIndex          - The Index of the header to pass to HttpQueryHeaders,
                              make sure to inialize to 0.
    lppszOutStr             - On success, a pointer to Allocated string with header string,
    lpdwSize                - size of the string returned in lppszOutStr

Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - One of Several Error codes defined in winerror.h or wininet.w

Comments:

    On Error, lppszOutStr may still contain an allocated string that will need to be
    freed.
-----------------------------------------------------------------------------*/
DWORD PLUG_CTX::wQueryHeadersAlloc
(
    IN HINTERNET hRequestMapped,
    IN DWORD dwQuery,
    OUT LPDWORD lpdwQueryIndex,
    OUT LPSTR *lppszOutStr,
    OUT LPDWORD lpdwSize
)
{
    LPSTR lpszRawHeaderBuf = NULL;
    DWORD dwcbRawHeaderBuf = 0;
    DWORD error;
    DWORD length;
    HTTP_REQUEST_HANDLE_OBJECT * pHttpRequest;

    INET_ASSERT(lppszOutStr);
    INET_ASSERT(hRequestMapped);
    INET_ASSERT(lpdwSize);
    INET_ASSERT((dwQuery & HTTP_QUERY_HEADER_MASK) != HTTP_QUERY_CUSTOM);

    *lppszOutStr = NULL;
    error = ERROR_SUCCESS;
    pHttpRequest = (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;

    // Attempt to determine whether our header is there.
    length = 0;
    if (pHttpRequest->QueryInfo(dwQuery, NULL, NULL, &length, lpdwQueryIndex)
          != ERROR_INSUFFICIENT_BUFFER)
    {
        // no authentication happening, we're done
        error = ERROR_HTTP_HEADER_NOT_FOUND;
        goto quit;
    }

    // Allocate a Fixed Size Buffer
    lpszRawHeaderBuf = (LPSTR) ALLOCATE_ZERO_MEMORY(length);
    dwcbRawHeaderBuf = length;

    if ( lpszRawHeaderBuf == NULL )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    error = pHttpRequest->QueryInfo
        (dwQuery, NULL, lpszRawHeaderBuf, &dwcbRawHeaderBuf, lpdwQueryIndex);

    INET_ASSERT(error != ERROR_INSUFFICIENT_BUFFER );
    INET_ASSERT(error != ERROR_HTTP_HEADER_NOT_FOUND );

quit:

    if ( error != ERROR_SUCCESS  )
    {
        dwcbRawHeaderBuf = 0;

        if ( lpszRawHeaderBuf )
            *lpszRawHeaderBuf = '\0';
    }

    *lppszOutStr = lpszRawHeaderBuf;
    *lpdwSize = dwcbRawHeaderBuf;

    return error;
}

/*-----------------------------------------------------------------------------
    CrackAuthenticationHeader

Routine Description:

    Attempts to decode a HTTP 1.1 Authentication header into its
    components.

Arguments:

    hRequestMapped           - Mapped Request handle
    fIsProxy                 - Whether proxy or server auth
    lpdwAuthenticationIndex  - Index of current HTTP header. ( initally called with 0 )
    lppszAuthHeader          - allocated pointer which should be freed by client
    lppszAuthScheme          - Pointer to Authentication scheme string.
    lppszRealm               - Pointer to Realm string,
    lpExtra                  - Pointer to any Extra String data in the header that is not
                                   part of the Realm
    lpdwExtra                - Pointer to Size of Extra data.
    lppszAuthScheme

  Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - ERROR_NOT_ENOUGH_MEMORY,
              ERROR_HTTP_HEADER_NOT_FOUND

Comments:
-----------------------------------------------------------------------------*/
DWORD PLUG_CTX::CrackAuthenticationHeader
(
    IN HINTERNET hRequestMapped,
    IN BOOL      fIsProxy,
    IN     DWORD dwAuthenticationIndex,
    IN OUT LPSTR *lppszAuthHeader,
    IN OUT LPSTR *lppszExtra,
    IN OUT DWORD *lpdwExtra,
       OUT LPSTR *lppszAuthScheme
    )
{
    DWORD error = ERROR_SUCCESS;

    LPSTR lpszAuthHeader = NULL;
    DWORD cbAuthHeader = 0;
    LPSTR lpszExtra = NULL;
    LPSTR lpszAuthScheme = NULL;

    LPDWORD lpdwAuthenticationIndex = &dwAuthenticationIndex;
    INET_ASSERT(lpdwExtra);
    INET_ASSERT(lppszExtra);
    INET_ASSERT(lpdwAuthenticationIndex);

    DWORD dwQuery = fIsProxy?
        HTTP_QUERY_PROXY_AUTHENTICATE : HTTP_QUERY_WWW_AUTHENTICATE;

    error = wQueryHeadersAlloc (hRequestMapped, dwQuery,
        lpdwAuthenticationIndex, &lpszAuthHeader, &cbAuthHeader);

    if ( error != ERROR_SUCCESS )
    {
        INET_ASSERT(*lpdwAuthenticationIndex
            || error == ERROR_HTTP_HEADER_NOT_FOUND );
        goto quit;
    }


    //
    // Parse Header for Scheme type
    //
    lpszAuthScheme = lpszAuthHeader;

    while ( *lpszAuthScheme == ' ' )  // strip spaces
        lpszAuthScheme++;

    lpszExtra = strchr(lpszAuthScheme, ' ');

    if (lpszExtra)
        *lpszExtra++ = '\0';

    if (lstrcmpi(GetScheme(), lpszAuthScheme))
    {
        DEBUG_PRINT(HTTP, ERROR,
               ("Authentication: HTTP Scheme has changed!: Scheme=%q\n",
                lpszAuthScheme));
        goto quit;

    }


    DEBUG_PRINT (HTTP, INFO,
        ("Authentication: found in headers: Scheme=%q, Extra=%q\n",
        lpszAuthScheme, lpszExtra));

quit:
    *lppszExtra  = lpszExtra;
    *lpdwExtra   = lpszExtra ? lstrlen(lpszExtra) : 0;
    *lppszAuthHeader = lpszAuthHeader;
    *lppszAuthScheme = lpszAuthScheme;
    return error;
}


/*---------------------------------------------------------------------------
    ResolveProtocol
---------------------------------------------------------------------------*/
VOID PLUG_CTX::ResolveProtocol()
{
    SECURITY_STATUS ssResult;
    PWINCONTEXT pWinContext;
    SecPkgContext_NegotiationInfo SecPkgCtxtInfo;

    INET_ASSERT(GetSchemeType() == WINHTTP_AUTH_SCHEME_NEGOTIATE);
    
    SecPkgCtxtInfo.PackageInfo = NULL;

    // Call QueryContextAttributes on the context handle.
    pWinContext = (PWINCONTEXT) (_pvContext);
    ssResult = (*(g_pSspData->pFuncTbl->QueryContextAttributes))
        (pWinContext->pSspContextHandle, SECPKG_ATTR_NEGOTIATION_INFO, &SecPkgCtxtInfo);

    if (ssResult == SEC_E_OK 
        && (SecPkgCtxtInfo.NegotiationState == SECPKG_NEGOTIATION_COMPLETE
            || (SecPkgCtxtInfo.NegotiationState == SECPKG_NEGOTIATION_OPTIMISTIC)))
    {
        // Resolve actual auth protocol from package name.
        // update both the auth context and Creds entry.
        if (!lstrcmpi(SecPkgCtxtInfo.PackageInfo->Name, "NTLM"))
        {
            _eSubScheme = WINHTTP_AUTH_SCHEME_NTLM;
            _dwSubFlags = PLUGIN_AUTH_FLAGS_NO_REALM;
        }
        else if (!lstrcmpi(SecPkgCtxtInfo.PackageInfo->Name, "Kerberos"))
        {
            _eSubScheme = WINHTTP_AUTH_SCHEME_KERBEROS;            
            _dwSubFlags = PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_NO_REALM;
        }

// BUGBUG - This faults.
//        

    }

    if (SecPkgCtxtInfo.PackageInfo)
    {
        (*(g_pSspData->pFuncTbl->FreeContextBuffer))(SecPkgCtxtInfo.PackageInfo);
    }
}


/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
PLUG_CTX::PLUG_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy,
                 SPMData *pSPM, AUTH_CREDS* pCreds)
    : AUTHCTX(pSPM, pCreds)
{
    _fIsProxy = fIsProxy;
    _pRequest = pRequest;
    _szAlloc = NULL;
    _szData = NULL;
    _cbData = 0;
    _pRequest->SetAuthState(AUTHSTATE_NONE);
    _fNTLMProxyAuth = _fIsProxy && (GetSchemeType() == WINHTTP_AUTH_SCHEME_NTLM);

    _pszFQDN = NULL;

    _fChallengeSeen = FALSE;
}

/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
PLUG_CTX::~PLUG_CTX()
{
    if (GetState() == AUTHCTX::STATE_LOADED)
    {
        if (_pCreds)
        {
            if (_CtxCriSec.Lock())
            {
                ClearAuthUser(&_pvContext, _pCreds->lpszHost);

                _CtxCriSec.Unlock();
            }
        }
    }
    if (_pRequest)
    {
        _pRequest->SetAuthState(AUTHSTATE_NONE);
    }

    if (_pszFQDN)
    {
        FREE_MEMORY(_pszFQDN);
    }
}


/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::PreAuthUser(OUT LPSTR pBuf, IN OUT LPDWORD pcbBuf)
{
    if (!_CtxCriSec.Lock())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    INET_ASSERT(_pSPMData == _pCreds->pSPM);

    DWORD dwError;
    SECURITY_STATUS ssResult;

    //  Make sure the auth provider is loaded.
    if (GetState() != AUTHCTX::STATE_LOADED)
    {
        if (GetState() != AUTHCTX::STATE_ERROR )
            Load();
        if (GetState() != AUTHCTX::STATE_LOADED)
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
    }

    BOOL fCanUseLogon = _fIsProxy
                        ? _pRequest->SilentLogonToProxyOK()
                        : _pRequest->SilentLogonOK(_pCreds->lpszHost);

    LPSTR lpszFQDN = GetFQDN(_pCreds->lpszHost);
    LPSTR lpszHostName =  lpszFQDN ? lpszFQDN : _pCreds->lpszHost;

    LPSTR lpszPass = _pCreds->GetPass();

    __try
    {
        ssResult = SEC_E_INTERNAL_ERROR;
        dwError = PreAuthenticateUser(&_pvContext,
                               lpszHostName,
                               GetScheme(),
                               fCanUseLogon,
                               0, // dwFlags
                               pBuf,
                               pcbBuf,
                               _pCreds->lpszUser,
                               lpszPass,
                               &ssResult);


        // Transit to the correct auth state.
        if (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED)
        {
            if (GetSchemeType() == WINHTTP_AUTH_SCHEME_NEGOTIATE)
                ResolveProtocol();

            // Kerberos + SEC_E_OK or SEC_I_CONTINUE_NEEDED transits to challenge.
            // Negotiate does not transit to challenge.
            // Any other protocol + SEC_E_OK only transits to challenge.
            if ((GetSchemeType() == WINHTTP_AUTH_SCHEME_KERBEROS
                && (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED))
                || (GetSchemeType() != WINHTTP_AUTH_SCHEME_NEGOTIATE && ssResult == SEC_E_OK))
            {
                _pRequest->SetAuthState(AUTHSTATE_CHALLENGE);
            }        
        }
    }

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DEBUG_PRINT (HTTP, ERROR, ("preAuthenticateUser call down faulted\n"));
        _pSPMData->eState = STATE_ERROR;
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
    }

    ENDEXCEPT

    if (lpszPass)
    {
        SecureZeroMemory(lpszPass, strlen(lpszPass));
        FREE_MEMORY(lpszPass);
    }

exit:
    _CtxCriSec.Unlock();

    return dwError;
}


/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    DWORD dwError, cbExtra = 0, dwAuthIdx;
    LPSTR szAuthHeader = NULL, szExtra = NULL, szScheme;

    // Get the auth header index corresponding to the scheme of this ctx.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto quit;

    // Get the scheme and any extra data.
    if ((dwError = CrackAuthenticationHeader(pRequest, fIsProxy, dwAuthIdx,
        &szAuthHeader, &szExtra, &cbExtra, &szScheme)) != ERROR_SUCCESS)
        goto quit;
    
    if (!cbExtra)
    {
        if (_fChallengeSeen)
        {
            dwError = ERROR_HTTP_HEADER_NOT_FOUND;
            goto quit;
        }

        _pRequest->SetAuthState(AUTHSTATE_NEGOTIATE);
    }

    // Check if auth scheme requires keep-alive.
    if (!(GetFlags() & PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED))
    {
        // if in negotiate phase check if we are going via proxy.
        if (pRequest->GetAuthState() == AUTHSTATE_NEGOTIATE)
        {
            // BUGBUG: if via proxy, we are not going to get keep-alive
            // connection to the server.  It would be nice if we knew
            // a priori the whether proxy would allow us to tunnel to
            // http port on the server.  Otherwise if we try and fail,
            // we look bad vs. other browsers who are ignorant of ntlm
            // and fall back to basic.
            CHAR szBuffer[64];
            DWORD dwBufferLength = sizeof(szBuffer);
            DWORD dwIndex = 0;
            BOOL fSessionBasedAuth = FALSE;
            if (pRequest->QueryResponseHeader(HTTP_QUERY_PROXY_SUPPORT, 
                                          szBuffer, &dwBufferLength, 
                                          0, &dwIndex) == ERROR_SUCCESS)
            {
                if (!_stricmp(szBuffer, "Session-Based-Authentication"))
                {
                    fSessionBasedAuth = TRUE;
                }
            }
            if (!fIsProxy && pRequest->IsRequestUsingProxy()
                && !pRequest->IsTalkingToSecureServerViaProxy() && !fSessionBasedAuth)
            {
                // Ignore NTLM via proxy since we won't get k-a to server.
                dwError = ERROR_HTTP_HEADER_NOT_FOUND;
                goto quit;
            }
        }

        // Else if in challenge phase, we require a persistent connection.
        else
        {
            // If we don't have a keep-alive connection ...
            if (!(pRequest->IsPersistentConnection (fIsProxy)))
            {
                dwError = ERROR_HTTP_HEADER_NOT_FOUND;
                goto quit;
            }
        }

    } // end if keep-alive required

    _fChallengeSeen = TRUE;

    quit:

    if (dwError == ERROR_SUCCESS)
    {
        // If no password cache is set in the auth context,
        // find or create one and set it in the handle.
        if (!_pCreds)
        {
            _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, NULL);

            if (!_pCreds)
            {
                INET_ASSERT(FALSE);
                dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            }
            else
            {
                INET_ASSERT(_pCreds->pSPM == _pSPMData);
            }
        }
    }

    if (_szAlloc)
    {
        FREE_MEMORY(_szAlloc);
        _szAlloc = NULL;
        _szData = NULL;
    }
    
    if (dwError == ERROR_SUCCESS)
    {
        // Point to allocated data.
        _szAlloc = szAuthHeader;
        _szData = szExtra;
        _cbData = cbExtra;
    }
    else
    {
        // Free allocated data.
        _szAlloc = NULL;
        _szData = NULL;
        _cbData = 0;
    }

    // Return of non-success will cancel auth session.
    return dwError;
}



/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::PostAuthUser()
{
    if (!_CtxCriSec.Lock())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    INET_ASSERT(_pSPMData == _pCreds->pSPM);
    DWORD dwError;

    //  Make sure the auth provider is loaded.
    if (GetState() != AUTHCTX::STATE_LOADED)
    {
        if (GetState() != AUTHCTX::STATE_ERROR )
            Load();
        if (GetState() != AUTHCTX::STATE_LOADED)
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
    }

    BOOL fCanUseLogon = _fIsProxy
                        ? _pRequest->SilentLogonToProxyOK()
                        : _pRequest->SilentLogonOK(_pCreds->lpszHost);

    if (_fDisableAutoLogon)
    {
        fCanUseLogon = FALSE;
    }

    LPSTR lpszFQDN = GetFQDN(_pCreds->lpszHost);
    LPSTR lpszHostName = lpszFQDN ? lpszFQDN : _pCreds->lpszHost;

    LPSTR lpszPass = _pCreds->GetPass();

    SECURITY_STATUS ssResult;
    __try
    {
        ssResult = SEC_E_INTERNAL_ERROR;
        dwError = AuthenticateUser(&_pvContext,
                                   lpszHostName,
                                   GetScheme(),
                                   fCanUseLogon,
                                   _szData,
                                   _cbData,
                                   _pCreds->lpszUser,
                                   lpszPass,
                                   &ssResult);



        // Kerberos package can get into a bad state.
        if (GetSchemeType() == WINHTTP_AUTH_SCHEME_KERBEROS && ssResult == SEC_E_WRONG_PRINCIPAL)
            dwError = ERROR_WINHTTP_INCORRECT_PASSWORD;
            
        // Transit to the correct auth state.
        if (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED)
        {
            if (GetSchemeType() == WINHTTP_AUTH_SCHEME_NEGOTIATE)
                ResolveProtocol();

            // Kerberos + SEC_E_OK or SEC_I_CONTINUE_NEEDED transits to challenge.
            // Negotiate does not transit to challenge.
            // Any other protocol + SEC_E_OK only transits to challenge.
            if ((GetSchemeType() == WINHTTP_AUTH_SCHEME_KERBEROS
                && (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED))
                || (GetSchemeType() != WINHTTP_AUTH_SCHEME_NEGOTIATE && ssResult == SEC_E_OK))
            {
                _pRequest->SetAuthState(AUTHSTATE_CHALLENGE);
            }        
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DEBUG_PRINT (HTTP, ERROR, ("AuthenticateUser faulted!\n"));
        dwError = ERROR_BAD_FORMAT;
        _pSPMData->eState = STATE_ERROR;
    }
    ENDEXCEPT

    if (_szAlloc)
    {
        FREE_MEMORY(_szAlloc);
        _szAlloc = NULL;
        _szData = NULL;
    }

    if (lpszPass)
    {
        SecureZeroMemory(lpszPass, strlen(lpszPass));
        FREE_MEMORY(lpszPass);
    }

    _cbData = 0;

exit:
    _CtxCriSec.Unlock();
    return dwError;
}

LPSTR PLUG_CTX::GetFQDN(LPSTR lpszHostName)
{
    if (lstrcmpi(GetScheme(), "Negotiate")) // only need to get FQDN for Kerberos
    {
        return NULL;
    }

    if (_pszFQDN)
    {
        return _pszFQDN;
    }

    SERIALIZED_LIST* pResolverCache = GetRootHandle(_pRequest)->GetResolverCache()->GetResolverCacheList();
    LPADDRINFO lpAddrInfo;
    DWORD TTL;
    LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry;
    if ((lpResolverCacheEntry=QueryResolverCache(pResolverCache,
                                            (LPSTR)lpszHostName, 
                                            NULL, 
                                            &lpAddrInfo, 
                                            &TTL)) != NULL) 
    {
        _pszFQDN = (lpAddrInfo->ai_canonname ? NewString(lpAddrInfo->ai_canonname) : NULL);
        ReleaseResolverCacheEntry(pResolverCache, lpResolverCacheEntry);
        return _pszFQDN;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\auth\sspi.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sspi.c

Abstract:

    This file contains the implementation for SSPI Authentication 

    The following functions are exported by this module:

    UnloadAuthenticateUser
    AuthenticateUser
    PreAuthenticateUser
    AuthenticateUserUI

Author:

    Sudheer Koneru    (SudK)    Created    2/17/96

Revision History:


--*/

#include <wininetp.h>
#include "htuu.h"
//#include "msnspmh.h"
#ifdef DEBUG_WINSSPI
#include <stdio.h>
#endif

#include "auth.h"
//LPSTR StrChrA(LPCSTR lpStart, WORD wMatch); // from shlwapi.h

#include "sspspm.h"
#include "winctxt.h"

extern SspData  *g_pSspData;
LPVOID SSPI_InitGlobals(void);


DWORD g_cSspiContexts;

#define NAME_SEPERATOR  0x5c    // this is a backslash character which 
                                // seperates the domain name from user name

VOID
WINAPI
UnloadAuthenticateUser(LPVOID *lppvContext,
                       LPSTR lpszScheme,
                       LPSTR lpszHost)
{

    PWINCONTEXT        pWinContext = (PWINCONTEXT) (*lppvContext);

    UNREFERENCED_PARAMETER(lpszScheme);
    UNREFERENCED_PARAMETER(lpszHost);

    if (!SSPI_InitGlobals())
        return;

    if (*lppvContext == NULL)    {
        return;
    }

    if (pWinContext->pInBuffer != NULL && 
        pWinContext->pInBuffer != pWinContext->szInBuffer)
    {
        LocalFree (pWinContext->pInBuffer);
    }
    pWinContext->pInBuffer = NULL;
    pWinContext->dwInBufferLength = 0;

    // Free SSPI security context
    //
    if (pWinContext->pSspContextHandle != NULL)
        (*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);

    //  Free SSPI credential handle
    //
    if (pWinContext->pCredential)
        (*(g_pSspData->pFuncTbl->FreeCredentialHandle))(pWinContext->pCredential);
    pWinContext->pCredential = NULL;
    pWinContext->pSspContextHandle = NULL;
 
    if ( (pWinContext->lpszServerName != NULL) &&
         (pWinContext->lpszServerName != pWinContext->szServerName) )
    {
        LocalFree(pWinContext->lpszServerName);
    }

    LocalFree(pWinContext);

    *lppvContext = NULL;

    AuthLock();
    g_cSspiContexts--;
    AuthUnlock();

    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   SaveServerName
//
//  Synopsis:   This function saves the destination server name in this
//              connection context for AuthenticateUserUI
//
//  Arguments:  [lpszServerName] - points to the target server name
//              [pWinContext] - points to the connection context
//
//  Returns:    TRUE if server name is successfully saved in connection context.
//              Otherwise, FALSE is returned.
//
//----------------------------------------------------------------------------
BOOL
SaveServerName (
    LPSTR             lpszServerName,
    PWINCONTEXT        pWinContext
    )
{
    DWORD dwLen = lstrlen(lpszServerName);

    if (dwLen < DEFAULT_SERVER_NAME_LEN)
    {
        lstrcpy(pWinContext->szServerName, lpszServerName);
        pWinContext->lpszServerName = pWinContext->szServerName;
    }
    else
    {   //
        //  Server name is longer, need to allocate memory for the name
        //

        //  Free already allocated memory if any
        if (pWinContext->lpszServerName && 
            pWinContext->lpszServerName != pWinContext->szServerName)
        {
            LocalFree (pWinContext->lpszServerName);
        }

        pWinContext->lpszServerName = (char *) LocalAlloc(0, dwLen+1);

        if (pWinContext->lpszServerName == NULL)
            return FALSE;

        lstrcpy(pWinContext->lpszServerName, lpszServerName);
    }

    return TRUE;
}


//  Function bHasExtendedChars
//  Check if an ANSI string contains extended characters
BOOL bHasExtendedChars(char const *str)
{
    signed char const *p;

    for (p = (signed char const *)str; *p; p++)
        if ( *p < 0)
            return TRUE;

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   BuildNTLMauthData
//
//  Synopsis:   This function builds SEC_WINNT_AUTH_IDENTITY structure 
//              from the user name and password specified.  If domain name 
//              is not specified in the user name, the Domain field in 
//              the structure is set to NULL.  NOTE: This structure is 
//              specific to the NTLM SSPI package.
//              This function allocates a chunck of memory big enough for 
//              storing user name, domain, and password. Then setup 
//              pointers in pAuthData to use sections of this memory.
//
//  Arguments:  [pAuthData] - points to the SEC_WINNT_AUTH_IDENTITY structure
//              [lpszUserName] - points to the user name, which may also 
//                               include user's domain name.
//              [lpszPassword] - points to user's password
//
//  Returns:    TRUE if SEC_WINNT_AUTH_IDENTITY structure is successfully 
//              initialized and built.  Otherwise, FALSE is returned.
//
//----------------------------------------------------------------------------
BOOL
BuildNTLMauthData (
    PSEC_WINNT_AUTH_IDENTITY pAuthData, 
    LPTSTR       lpszUserName,
    LPTSTR       lpszPassword
    )
{
    DWORD  dwUserLen, dwDomainLen, dwPwdLen;
    LPTSTR pName;
    LPTSTR pDomain = NULL;
    BOOL bUnicodeAuth = FALSE;

    if ( bHasExtendedChars(lpszUserName) || bHasExtendedChars(lpszPassword))
        bUnicodeAuth = TRUE;

    pAuthData->Flags = bUnicodeAuth ? SEC_WINNT_AUTH_IDENTITY_UNICODE : SEC_WINNT_AUTH_IDENTITY_ANSI;

    //
    //  Check to see if domain name is specified in lpszUserName
    //
    pName = StrChrA (lpszUserName, NAME_SEPERATOR);

    if (pName)  // Domain name specified
    {
        // Make sure that we don't change the original string in lpszUserName 
        // because that it would be reused for other connections

        // Calculate no. of bytes in domain name
        dwDomainLen = (int)(pName - lpszUserName);

        // Convert to no. of characters
        pAuthData->DomainLength = dwDomainLen / sizeof(TCHAR);

        pDomain = lpszUserName;
        pName++;
    }
    else        // No domain specified
    {
        pName = lpszUserName;
        pAuthData->Domain = NULL;
        pDomain = NULL;
        dwDomainLen = pAuthData->DomainLength = 0;
    }

    dwUserLen = pAuthData->UserLength = lstrlen (pName);
    dwPwdLen = pAuthData->PasswordLength = lstrlen (lpszPassword);

    //
    //  Allocate memory for all: name, domain, and password
    //  The memory block is big enough for Unicode. Some bytes will be wasted in the ANSI case
    //
    pAuthData->User = (unsigned char*)LocalAlloc(LMEM_ZEROINIT, (dwUserLen + dwDomainLen + dwPwdLen + 3)*sizeof(WCHAR));
    //  Since the buffer is zero-initialized, strings don't need their '\0' copied over.

    if (pAuthData->User == NULL)
        return (FALSE);

    if (bUnicodeAuth)
    {
        // Convert the user name into Unicode and store in pAuthData->User
        if (0 == MultiByteToWideChar(CP_ACP, 0, pName, -1, (LPWSTR)(pAuthData->User), dwUserLen+1))
            return FALSE;
    }
    else
        CopyMemory (pAuthData->User, pName, dwUserLen);

    //  Setup memory pointer for password
    //
    pAuthData->Password = pAuthData->User + (dwUserLen + 1) * sizeof(WCHAR);

    if (bUnicodeAuth)
    {
        if (0 == MultiByteToWideChar(CP_ACP, 0, lpszPassword, -1, (LPWSTR)(pAuthData->Password), dwPwdLen+1))
            return FALSE;
    }
    else
        CopyMemory (pAuthData->Password, lpszPassword, dwPwdLen);

    if (pAuthData->DomainLength > 0)
    {
        //  Setup memory pointer for domain
        //
        pAuthData->Domain = pAuthData->Password + (dwPwdLen + 1) * sizeof(WCHAR);
        if (bUnicodeAuth)
        {
            // pDomain is not null terminated, so provide the length
            if (0 == MultiByteToWideChar(CP_ACP, 0, pDomain, dwDomainLen, (LPWSTR)(pAuthData->Domain), dwDomainLen+1))
                return FALSE;
        }
        else
            CopyMemory (pAuthData->Domain, pDomain, dwDomainLen);
    }
    else
    {
       pAuthData->Domain = NULL;
    }

    return (TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeNTLMauthData
//
//  Synopsis:   This function frees memory allocated for the 
//              SEC_WINNT_AUTH_IDENTITY structure
//
//  Arguments:  [pAuthData] - points to the SEC_WINNT_AUTH_IDENTITY structure
//
//  Returns:    void.
//
//----------------------------------------------------------------------------
VOID
FreeNTLMauthData (
    PSEC_WINNT_AUTH_IDENTITY pAuthData
    )
{
    //
    //  Free User which points to memory for all domain, name, and password
    //
    if (pAuthData->User)
    {
        int iCharacterSize = 0;
        if (pAuthData->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI)
            iCharacterSize = sizeof(char);
        else if (pAuthData->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE)
            iCharacterSize = sizeof(WCHAR);
        

        SecureZeroMemory(pAuthData->User, iCharacterSize * pAuthData->UserLength);
        SecureZeroMemory(pAuthData->Password, iCharacterSize * pAuthData->PasswordLength);

        LocalFree (pAuthData->User);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   NewWinContext
//
//  Synopsis:   This function creates a new context and a new credential 
//              handle for this connection.  If a user name/password is 
//              specified, the credential handle is created for the 
//              specified user.  Otherwise, the credential handle is created 
//              for the local logon user.
//
//  Arguments:  [pkgId] - the package ID (index into SSPI package list)
//              [lpszScheme] - the name of the current authentication scheme,
//                             which is also the SSPI package name
//              [ppCtxt] - this returns the pointer of the created context 
//                         to the caller.
//              [lpszUserName] - the name of a specific user to be used 
//                               for authentication. If this is NULL, the 
//                               credential of the currently logon user is 
//                               used for authentication.
//              [lpszPassword] - the password of the specified user, if any.
//
//  Returns:    ERROR_SUCCESS - if the new context is created successfully
//              ERROR_NOT_ENOUGH_MEMORY - if memory allocation failed
//              ERROR_INVALID_PARAMETER - the SSPI call for creating the 
//                              security credential handle failed
//
//----------------------------------------------------------------------------
DWORD
NewWinContext (
    INT         pkgId, 
    LPSTR       lpszScheme,
    PWINCONTEXT *ppCtxt,
    BOOL        fCanUseLogon,
    LPSTR       lpszUserName,
    LPSTR       lpszPassword
    )
{
    SECURITY_STATUS ss;
    TimeStamp   Lifetime;
    PWINCONTEXT pWinContext;
    SEC_WINNT_AUTH_IDENTITY  AuthData;
    PSEC_WINNT_AUTH_IDENTITY pAuthData;
    DWORD Capabilities ;

    DWORD SecurityBlobSize;

    //
    // need space for maxtoken size for in+out, + base64 encoding overhead for each.
    // really 1.34 overhead, but just round up to 1.5
    //
    SecurityBlobSize = GetPkgMaxToken(pkgId);
    SecurityBlobSize += (SecurityBlobSize/2);

    //
    // note: for compatibility sake, make the buffer size the MAX_BLOB_SIZE at the minimum
    // consider removing this once we're convinced all packages return good cbMaxToken values.
    //

    if( SecurityBlobSize < MAX_BLOB_SIZE )
    {
        SecurityBlobSize = MAX_BLOB_SIZE;
    }


    pWinContext = (PWINCONTEXT) LocalAlloc(
                        0,
                        sizeof(WINCONTEXT) +
                        (SecurityBlobSize*2)
                        );
    if (pWinContext == NULL)
        return (ERROR_NOT_ENOUGH_MEMORY);
        
    //  Initialize context
    //
    ZeroMemory( pWinContext, sizeof(WINCONTEXT) );
    pWinContext->pkgId = (DWORD)pkgId;
    
    pWinContext->szOutBuffer = (char*)(pWinContext+1);
    pWinContext->cbOutBuffer = SecurityBlobSize;

    pWinContext->szInBuffer = pWinContext->szOutBuffer + pWinContext->cbOutBuffer;
    pWinContext->cbInBuffer = SecurityBlobSize;

    //
    // Get bitmask representing the package capabilities
    //

    Capabilities = GetPkgCapabilities( pkgId );

    if ( ( Capabilities & SSPAUTHPKG_SUPPORT_NTLM_CREDS ) == 0 )
    {
        pAuthData = NULL;
    }
    else if (lpszUserName && lpszPassword)
    {
        //  Build AuthData from the specified user name/password
        if (!BuildNTLMauthData (&AuthData, lpszUserName, lpszPassword))
        {
            LocalFree (pWinContext);
            return (ERROR_NOT_ENOUGH_MEMORY);
        }

        pAuthData = &AuthData;
    }
    else if (fCanUseLogon && !lpszUserName && !lpszPassword)
    {
        // The zone policy allows silent use of the logon credential.
        pAuthData = NULL;
    }
    else
    {
        LocalFree (pWinContext);
        // We must prompt the user for credentials.
        return ERROR_WINHTTP_INCORRECT_PASSWORD;
    }

    //
    //  Call SSPI function acquire security credential for this package
    //
    ss = (*(g_pSspData->pFuncTbl->AcquireCredentialsHandle))(
                       NULL,                // New principal
                       lpszScheme,          // SSPI Package Name
                       SECPKG_CRED_OUTBOUND,// Credential Use
                       NULL,                // Logon ID
                       pAuthData,           // Auth Data
                       NULL,                // Get key func
                       NULL,                // Get key arg
                       &pWinContext->Credential,    // Credential Handle
                       &Lifetime );

    if (pAuthData)
        FreeNTLMauthData (pAuthData);

    if (ss != STATUS_SUCCESS)
    {
        LocalFree (pWinContext);
        return (ERROR_INVALID_PARAMETER);
    }

    pWinContext->pCredential = &pWinContext->Credential;

    *ppCtxt = pWinContext;

    AuthLock();
    g_cSspiContexts++;
    AuthUnlock();

    return (ERROR_SUCCESS);
}

//+---------------------------------------------------------------------------
//
//  Function:   RedoNTLMAuth4User
//
//  Synopsis:   This function recreates a NTLM credential handle for the 
//              specified user and generate a NEGOTIATE message in 
//              the provided buffer with the new credential handle.
//
//  Arguments:  [pWinContext] - points to the connection context
//              [pkgId] - specifies the SSPI pkg to be used for authentication
//              [lpszUserName] - the name of the specific user to be used 
//                               for authentication. 
//              [lpszPassword] - the password of the specified user,
//              [lpszServerName] - the target server name
//              [lpszScheme] - the name of the current authentication scheme,
//                             which is also the SSPI package name
//              [lpOutBuffer] - points to the buffer for the new authorization 
//                              header including the UUENCODED NEGOTIATE msg
//              [lpdwOutBufferLength] - returns the length of the generated 
//                                      authorization header.
//
//  Returns:    ERROR_SUCCESS - if the new authorization header is successfully 
//                              created for the new user name/password
//              ERROR_NOT_ENOUGH_MEMORY - if memory allocation failed
//              ERROR_INVALID_HANDLE - the SSPI call for generating the 
//                              new NEGOTIATE msg failed
//
//----------------------------------------------------------------------------
DWORD
RedoNTLMAuth4User (
    PWINCONTEXT    pWinContext, 
    INT         pkgId, 
    LPSTR       lpszUserName,
    LPSTR       lpszPassword, 
    LPSTR       lpszServerName,
    LPSTR       lpszScheme,
    IN BOOL     fCanUseLogon,
    LPSTR       lpOutBuffer,
    LPDWORD     lpdwOutBufferLength,
    SECURITY_STATUS *pssResult
    )
{
    SECURITY_STATUS         ss;
    DWORD                   dwStatus;
    TimeStamp               Lifetime;
    SEC_WINNT_AUTH_IDENTITY AuthData;
    ULONG                   fContextReq = ISC_REQ_DELEGATE;
    DWORD                   dwMaxLen;

       if (pWinContext->pSspContextHandle)
       {
        (*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);
           pWinContext->pSspContextHandle = NULL;
    }

    //  Free existing credential handle
    //
    if (pWinContext->pCredential)
    {
        (*(g_pSspData->pFuncTbl->FreeCredentialHandle))(pWinContext->pCredential);
        pWinContext->pCredential = NULL;
    }
    //
    //  Build the NTLM SSPI AuthData from the specified user name/password
    //
    if (!BuildNTLMauthData (&AuthData, lpszUserName, lpszPassword))
        return (ERROR_NOT_ENOUGH_MEMORY);

    //
    //  Call SSPI function acquire security credential for this user
    //
    ss = (*(g_pSspData->pFuncTbl->AcquireCredentialsHandle))(
                       NULL,                // New principal
                       lpszScheme,          // SSPI Package Name
                       SECPKG_CRED_OUTBOUND,// Credential Use
                       NULL,                // Logon ID
                       &AuthData,           // Auth Data
                       NULL,                // Get key func
                       NULL,                // Get key arg
                       &pWinContext->Credential,    // Credential Handle
                       &Lifetime );

    FreeNTLMauthData (&AuthData);   // don't need it any more

    if (ss != STATUS_SUCCESS)
    {
        return (ERROR_INVALID_HANDLE);
    }

    pWinContext->pCredential = &pWinContext->Credential;

    dwMaxLen = *lpdwOutBufferLength;

    //
    //  Generate NEGOTIATE message in the provided buffer for this user 
    //
    dwStatus =  GetSecAuthMsg( g_pSspData,
                                pWinContext->pCredential,
                                pkgId,
                                NULL, 
                                &(pWinContext->SspContextHandle),
                                fContextReq,
                                NULL,
                                0,
                                lpOutBuffer,
                                lpdwOutBufferLength,
                                lpszServerName,
                                fCanUseLogon,
                                TRUE,
                                lpszScheme,
                                pssResult);
    
    if (dwStatus != SPM_STATUS_OK)
    {
        *lpdwOutBufferLength = 0; // no exchange blob generated
        return(ERROR_INVALID_HANDLE);
    }

    pWinContext->pSspContextHandle = &(pWinContext->SspContextHandle);

    //
    //  If we are not in the initial state, continue to a RESPONSE message
    //
    if (pWinContext->pInBuffer != NULL && pWinContext->dwInBufferLength > 0)
    {
        *lpdwOutBufferLength = dwMaxLen;
        ZeroMemory( lpOutBuffer, dwMaxLen );

        dwStatus = GetSecAuthMsg( g_pSspData,
                                pWinContext->pCredential,
                                pWinContext->pkgId,
                                pWinContext->pSspContextHandle,
                                (PCtxtHandle) &(pWinContext->SspContextHandle),
                                fContextReq,
                                pWinContext->pInBuffer, 
                                pWinContext->dwInBufferLength, 
                                lpOutBuffer,
                                lpdwOutBufferLength,
                                pWinContext->lpszServerName,
                                fCanUseLogon,
                                TRUE,
                                lpszScheme,
                                pssResult);

        //  Clear out the input exchange blob
        //
        if (pWinContext->pInBuffer != NULL)
        {
            if (pWinContext->pInBuffer != pWinContext->szInBuffer)
                LocalFree (pWinContext->pInBuffer);
            pWinContext->pInBuffer = NULL;
            pWinContext->dwInBufferLength = 0;
        }

        if (dwStatus != SPM_STATUS_OK)
        {
            *lpdwOutBufferLength = 0; // no exchange blob generated
            return(ERROR_INVALID_HANDLE);
        }
    }

    return (ERROR_SUCCESS);
}


//
// functions
//

/*++

Routine Description:

    Generates a Basic User Authentication string for WinINet or 
    other callers can use

Arguments:

    lpContext               - if the package accepts the request & authentication
                    requires multiple transactions, the package will supply
                    a context value which will be used in subsequent calls,
                    Currently this contains a pointer to a pointer of a 
                    User defined Void Pointer.  Can be Assume to be NULL
                    if this is the first instance of a Realm - Host Combo

    lpszServerName  - the name of the server we are performing 
                    authentication for. We may want to supply the full URL
                    
    lpszScheme              - the name of the authentication scheme we are seeking, in case the package supports multiple schemes

    dwFlags                 - on input, flags modifying how the package should behave,
                    e.g. "only authenticate if you don't have to get user 
                    information"  On output contains flags relevant to
                    future HTTP requests, e.g. "don't cache any data from 
                    this connection". Note, this information should not be 
                    specific to HTTP - we may want to use the same flags 
                    for FTP, etc.
    
    lpszInBuffer              - pointer to the string containing the response from
                    the server (if any)

    dwInBufferLength - number of bytes in lpszInBuffer. No CR-LF sequence, no terminating NUL

    lpOutBuffer -   pointer to a buffer where the challenge response will be written by the 
                    package if it can handle the request

    lpdwOutBufferLength - on input, contains the size of lpOutBuffer. On output, contains the
                          number of bytes to return to the server in the next GET request 
                          (or whatever). If lpOutBuffer is too small, the package should 
                          return ERROR_INSUFFICIENT_BUFFER and set *lpdwOutBufferLength to be
                          the required length

    We will keep a list of the authentication packages and the schemes they support, 
    along with the entry point name (should be the same for all packages) in the registry. 

    Wininet should keep enough information such that it can make a reasonable guess as to
    whether we need to authenticate a connection attempt, or whether we can use previously 
    authenticated information


Return Value:

    DWORD
    Success - non-zero 
    Failure - 0. Error status is available by calling GetLastError()

--*/
DWORD
WINAPI
AuthenticateUser(
    IN OUT LPVOID *lppvContext,
    IN LPSTR lpszServerName,
    IN LPSTR lpszScheme,
    IN BOOL  fCanUseLogon,
    IN LPSTR lpszInBuffer,
    IN DWORD dwInBufferLength,
    IN LPSTR lpszUserName,
    IN LPSTR lpszPassword,
    OUT SECURITY_STATUS *pssResult
    )
{
    PWINCONTEXT        pWinContext;
    LPSTR           pServerBlob = NULL;
    int                pkgId;
    DWORD           SPMStatus;
    ULONG           fContextReq = ISC_REQ_DELEGATE;
    BOOL            bNonBlock = TRUE;

    if (!SSPI_InitGlobals())
        return ERROR_INVALID_PARAMETER;

    
    pkgId = GetPkgId(lpszScheme);

    if (pkgId == -1) 
        return (ERROR_INVALID_PARAMETER);

    if (*lppvContext == NULL)   // a new connection
    {
        DWORD dwStatus;

        //
        // First time we are getting called here, there should be no input blob
        //
        if (dwInBufferLength != 0)
            return (ERROR_INVALID_PARAMETER);

        dwStatus = NewWinContext (pkgId, lpszScheme, &pWinContext,
            fCanUseLogon, lpszUserName, lpszPassword);
        if (dwStatus != ERROR_SUCCESS)
            return (dwStatus);

        (*lppvContext) = (LPVOID) pWinContext;
#ifdef DEBUG_WINSSPI
        (void)wsprintf (msg, "AuthenticateUser> Scheme= %s  Server= '%s'\n", 
                       lpszScheme, lpszServerName);
        OutputDebugString(msg);
#endif
    }
    else
    {
        pWinContext = (PWINCONTEXT) (*lppvContext);

        //
        // The package Id better be the same. Cant just switch packageId 
        // arbitrarily
        //
        if (pWinContext->pkgId != (DWORD)pkgId)
            return (ERROR_INVALID_PARAMETER);
        
        pServerBlob = lpszInBuffer;

        //++(pWinContext->dwCallId);        // Increment Call Id

        //
        // BUGBUG: Hack for now to know when auth failed
        // The only time we get lpszInBuffer to be empty is when 
        // Web server failed the authentication request
        //
        if (dwInBufferLength == 0)
        {
            //
            // This means auth has failed as far as NTLM are concerned.
            // Will result in UI being done again for new passwd
            //

            // Make sure we should have the same server name as before
            //
            if ( pWinContext->lpszServerName != NULL &&  
                 lstrcmp (pWinContext->lpszServerName, lpszServerName) != 0 )
            {
                return(ERROR_INVALID_PARAMETER);
            }

            if (!SaveServerName (lpszServerName, pWinContext))
                return (ERROR_NOT_ENOUGH_MEMORY);

            //
            //    Delete the original SSPI context handle and 
            //    let UI recreate one.
            //
            if (pWinContext->pSspContextHandle)
            {
                (*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);
                pWinContext->pSspContextHandle = NULL;
            }

            if (pWinContext->pInBuffer != NULL && 
                pWinContext->pInBuffer != pWinContext->szInBuffer)
            {
                LocalFree (pWinContext->pInBuffer);
            }

            pWinContext->pInBuffer = NULL;
            pWinContext->dwInBufferLength = 0;

            //
            //  clear buffer length for the exchange blob
            //
            pWinContext->dwOutBufferLength = 0;

            return (ERROR_WINHTTP_INCORRECT_PASSWORD);
        }
    }

    //
    //  Setup dwOutBufferLength to represent max. memory in szOutBuffer
    //
    pWinContext->dwOutBufferLength = pWinContext->cbOutBuffer;
    ZeroMemory (pWinContext->szOutBuffer, pWinContext->cbOutBuffer);

    //
    // This will generate an authorization header with UUEncoded blob from SSPI.
    // BUGBUG: Better make sure outbuf buffer is big enough for this.
    //
    SPMStatus =  GetSecAuthMsg( g_pSspData,
                                pWinContext->pCredential,
                                pkgId,
                                pWinContext->pSspContextHandle,
                                &(pWinContext->SspContextHandle),
                                fContextReq,
                                pServerBlob, 
                                   dwInBufferLength,
                                pWinContext->szOutBuffer,
                                &pWinContext->dwOutBufferLength,
                                lpszServerName,
                                fCanUseLogon,
                                bNonBlock,
                                lpszScheme,
                                pssResult);

    if (SPMStatus != SPM_STATUS_OK)             // Fail to generate blob
    {
        pWinContext->dwOutBufferLength = 0;     // no exchange blob generated

        //
        //  if SSPI is requesting an opportunity to prompt for user credential
        //
        if (SPMStatus == SPM_STATUS_WOULD_BLOCK)
        {
            if (!SaveServerName (lpszServerName, pWinContext))
                return (ERROR_NOT_ENOUGH_MEMORY);

            //  If there is a exchange blob, this is not the first call
            //
            if (pServerBlob && dwInBufferLength > 0)
            {
                //  Save the exchange blob in the connection context
                //  so we can call SSPI again with the exchange blob
                if (dwInBufferLength > MAX_BLOB_SIZE)
                {
                    if (pWinContext->pInBuffer != NULL && 
                        pWinContext->pInBuffer != pWinContext->szInBuffer)
                    {
                        LocalFree (pWinContext->pInBuffer);
                    }
                    
                    pWinContext->pInBuffer = (PCHAR) LocalAlloc(0, 
                                                    dwInBufferLength);
                    if (pWinContext->pInBuffer == NULL)
                        return (ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                    pWinContext->pInBuffer = pWinContext->szInBuffer;

                CopyMemory( pWinContext->szInBuffer, pServerBlob, 
                            dwInBufferLength );
                pWinContext->dwInBufferLength = dwInBufferLength;
            }
            else
            {
                //
                //    Delete the original SSPI context handle and 
                //    let UI recreate one.
                //
                if (pWinContext->pSspContextHandle)
                {
                    (*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);
                    pWinContext->pSspContextHandle = NULL;
                }

                //
                //  clear buffer length for the exchange blob
                //
                if (pWinContext->pInBuffer != NULL && 
                    pWinContext->pInBuffer != pWinContext->szInBuffer)
                {
                    LocalFree (pWinContext->pInBuffer);
                }

                pWinContext->pInBuffer = NULL;
                pWinContext->dwInBufferLength = 0;
            }
            pWinContext->dwOutBufferLength = 0;

            return(ERROR_WINHTTP_INCORRECT_PASSWORD);
        }

        return (ERROR_WINHTTP_LOGIN_FAILURE);
    }
    else if (pWinContext->pSspContextHandle == NULL)
    {   
        //  This means that we've just created a security context
        //
        pWinContext->pSspContextHandle = &(pWinContext->SspContextHandle);
    }

    return ERROR_WINHTTP_RESEND_REQUEST;
}


DWORD
WINAPI
PreAuthenticateUser(
    IN OUT LPVOID *lppvContext,
    IN LPSTR lpszServerName,
    IN LPSTR lpszScheme,
    IN BOOL  fCanUseLogon,
    IN DWORD dwFlags,
    OUT LPSTR lpOutBuffer,
    IN OUT LPDWORD lpdwOutBufferLength,
    IN LPSTR lpszUserName,
    IN LPSTR lpszPassword,
    SECURITY_STATUS *pssResult
    )
{
    INT             pkgId;
    DWORD           dwStatus;
    PWINCONTEXT        pWinContext;
    BOOL            bNonBlock = TRUE;
    ULONG           fContextReq = ISC_REQ_DELEGATE;
    DWORD Capabilities ;

    UNREFERENCED_PARAMETER(dwFlags);

    if (!SSPI_InitGlobals())
        return ERROR_INVALID_PARAMETER;

    if (lpszServerName == NULL || *lpszServerName == '\0')
        return(ERROR_INVALID_PARAMETER);

    pkgId = GetPkgId(lpszScheme);

    if (pkgId == -1)    {
        return(ERROR_INVALID_PARAMETER);
    }

    Capabilities = GetPkgCapabilities( pkgId );

    //
    //  If this is for an existing connection
    //
    if (*lppvContext != NULL)
    {
        pWinContext = (PWINCONTEXT) (*lppvContext);

        if ((DWORD)pkgId != pWinContext->pkgId)
            return(ERROR_INVALID_PARAMETER);

        //
        //  For package that does not handle its own UI, if there is no 
        //  generated blob, it means that we have just collected 
        //  user name/password.
        //
        if ( ( pWinContext->dwOutBufferLength == 0 ) &&
                ( Capabilities & SSPAUTHPKG_SUPPORT_NTLM_CREDS ) )
        {
            if (lpszUserName == NULL || lpszPassword == NULL)
            {
                return(ERROR_INVALID_PARAMETER);
            }

            //
            // Need to recreate a credential handle and 
            // generate a new NEGOTIATE message in lpOutBuffer
            //
            dwStatus = RedoNTLMAuth4User (pWinContext, 
                                         pkgId,
                                         lpszUserName,
                                         lpszPassword, 
                                         lpszServerName ,
                                         lpszScheme,
                                         fCanUseLogon,
                                         lpOutBuffer,
                                         lpdwOutBufferLength,
                                         pssResult);

            if (dwStatus != ERROR_SUCCESS)
                return (dwStatus);

            return(ERROR_SUCCESS);
        }
        else if (pWinContext->dwOutBufferLength == 0)
        //
        //  For other packages, If there is no generated blob, 
        //  something is wrong 
        //
            return(ERROR_INVALID_PARAMETER);

    }
    // If not NTLM, don't pre-auth.
    else if ( (Capabilities & SSPAUTHPKG_SUPPORT_NTLM_CREDS ) == 0 )
    {
        return (ERROR_INVALID_HANDLE);
    }
    else
    {
        // probably sending 1st request on a new connection for the same URL
        //  Create a new context and SSPI credential handle for this connection
        //
        // Set fCanUseLogon to TRUE : we would not be pre-authing
        // unless we have a valid pwc which means we already checked
        // zone policy for silent logon.
        dwStatus = NewWinContext (pkgId, lpszScheme, &pWinContext, 
                                  fCanUseLogon, lpszUserName, lpszPassword);
        if (dwStatus != ERROR_SUCCESS)
            return (dwStatus);
        
#ifdef DEBUG_WINSSPI
        (void)wsprintf (msg, 
            "PreAuthenticateUser> New Context for Scheme= %s  Server= '%s'\n", 
            lpszScheme, lpszServerName);
        OutputDebugString(msg);
#endif
        pWinContext->dwOutBufferLength = pWinContext->cbOutBuffer;
        ZeroMemory (pWinContext->szOutBuffer, pWinContext->cbOutBuffer);
    
        //
        // This will generate an authorization header with the 
        // UUEncoded blob from SSPI. 
        // BUGBUG: Better make sure outbuf buffer is big enough for this.
        //
        dwStatus =  GetSecAuthMsg( g_pSspData,
                                    pWinContext->pCredential,
                                    pkgId,
                                    NULL, 
                                    &(pWinContext->SspContextHandle),
                                    fContextReq,
                                    NULL,
                                    0,
                                    pWinContext->szOutBuffer,
                                    &pWinContext->dwOutBufferLength,
                                    lpszServerName,
                                    fCanUseLogon,
                                    bNonBlock,
                                    lpszScheme,
                                    pssResult);
    
        if (dwStatus != SPM_STATUS_OK)
        {
            //  This is a rare case
            //
            pWinContext->dwOutBufferLength = 0; // no exchange blob generated
            return(ERROR_INVALID_HANDLE);
        }

        (*lppvContext) = (LPVOID) pWinContext;

        //  Save the pointer of the created security ctxt
        //
        pWinContext->pSspContextHandle = &(pWinContext->SspContextHandle);
    }

    //
    //  Copy exchange blob to the output buffer
    //    Make sure output buffer provided is big enough
    //
    if (*lpdwOutBufferLength < pWinContext->dwOutBufferLength)
    {
        *lpdwOutBufferLength = pWinContext->dwOutBufferLength + 1;
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    CopyMemory (lpOutBuffer, pWinContext->szOutBuffer, 
                pWinContext->dwOutBufferLength);
    if (*lpdwOutBufferLength > pWinContext->dwOutBufferLength)
        lpOutBuffer[pWinContext->dwOutBufferLength] = '\0';

    *lpdwOutBufferLength = pWinContext->dwOutBufferLength;

    //
    //  The exchange blob has being copied to request header, so clear its len
    //

    pWinContext->dwOutBufferLength = 0;

    return(ERROR_SUCCESS);
}

BOOL g_fUUEncodeData = TRUE;

typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT ;

typedef 
BOOL
(WINAPI * PFN_GET_COMPUTER_NAME_EX)(
    IN COMPUTER_NAME_FORMAT NameType,
    OUT LPSTR lpBuffer,
    IN OUT LPDWORD nSize
    );

PFN_GET_COMPUTER_NAME_EX g_pfnGetComputerNameExA = NULL;


/*-----------------------------------------------------------------------------
**
**  Function:   GetSecAuthMsg
**
**  Synopsis:   This function generates a SSPI NEGOTIATE or RESPONSE 
**                authorization string for the specified SSPI package.
**                The authorization string generated by this function 
**                follows the format: 
**                    "<Package Name> <Package Specific Auth. Data>"
**                If global uuencoding is turned on, this functions will 
**                uuencode the message before building it into an  
**                authorization string; by default, the uuencoding flag is 
**                always on.  
**                This functions calls InitializeSecurityContext() to 
**                generate the NEGOTIATE/RESPONSE message for the authori-
**                zation string. If the SSPI function returns NO_CREDENTIAL, 
**                and if the PROMPT_CREDS flag is not turned on when blocking
**                is permitted, this function will call the SSPI function 
**                again with the PROMPT_CREDS flag set; if SSPI returns 
**                NO_CREDENTIAL again, this SSPI will return ERROR to the 
**                caller.
**
**
**  Arguments:
**
**        pData - pointer to SspData containing the SSPI function table 
**                and the SSPI package list. 
**        pkgID - the package index of the SSPI package to use.
**        pInContext - pointer to a context handle. If NULL is specified, 
**                     this function will use a temporary space for the context
**                     handle and delete the handle before returning to the 
**                     caller. If non-NULL address is specified, the context 
**                     handle created by the SSPI is returned to the caller. 
**                     And the caller will have to delete the handle when it's
**                     done with it.
**        fContextReq - the SSPI request flag to pass to InitializeSecurityContext
**        pBuffIn - pointer to the uudecoded CHALLENGE message if any. 
**                  For generating NEGOTIATE message, this pointer should be NULL.
**        cbBuffIn - length of the CHALLENGE message. This should be zero when  
**                   when pBuffIn is NULL.
**        pFinalBuff - pointer to a buffer for the final authorization string.
**        pszTarget - Server Host Name
**        bNonBlock - a flag which is set if blocking is not permitted.
**
**  Return Value:
**
**        SPM_STATUS_OK    - if an authorization string is generated successfully
**      SPM_STATUS_WOULD_BLOCK - if generating an authorization string would 
**                    cause blocking when blocking is not permitted. 
**        SPM_ERROR - if any problem/error is encountered in generating an 
**                    authorization string, including user hitting cancel on 
**                    the SSPI dialog prompt for name/password.
**
**---------------------------------------------------------------------------*/
DWORD
GetSecAuthMsg (
    PSspData        pData,              
    PCredHandle     pCredential, 
    DWORD           pkgID,              // the package index into package list
    PCtxtHandle     pInContext,
    PCtxtHandle        pOutContext,
    ULONG           fContextReq,        // Request Flags
    VOID            *pBuffIn, 
    DWORD           cbBuffIn, 
    char            *pFinalBuff, 
    DWORD           *pcbBuffOut,
    SEC_CHAR        *pszTarget,         // Server Host Name
    BOOL            fTargetTrusted,
    UINT            bNonBlock,
    LPSTR           pszScheme,
    SECURITY_STATUS *pssResult
    )
{
    UNREFERENCED_PARAMETER(fTargetTrusted);

    char                  *SlowDecodedBuf = NULL;

    int                   retsize;
    SECURITY_STATUS       SecStat;
    TimeStamp             Lifetime;
    SecBufferDesc         OutBuffDesc;
    SecBuffer             OutSecBuff;
    SecBufferDesc         InBuffDesc;
    SecBuffer             InSecBuff;
    ULONG                 ContextAttributes;

    char                  *SlowOutBufPlain = NULL;

    char                  *pOutMsg = NULL;
    DWORD                 RetStatus;
    long                  maxbufsize;
    CHAR                  szDecoratedTarget[MAX_PATH + 6];
    DWORD                 cbTarget;

    ULONG                 cbMaxToken;


    //
    // BUGBUG: Deal with output buffer not being long enough


    if (pFinalBuff == NULL) {
        return(SPM_ERROR);
    }

    //
    //  Prepare our output buffer.  We use a temporary buffer because
    //  the real output buffer will most likely need to be uuencoded
    //
    OutBuffDesc.ulVersion = 0;
    OutBuffDesc.cBuffers  = 1;
    OutBuffDesc.pBuffers  = &OutSecBuff;

    OutSecBuff.cbBuffer   = MAX_AUTH_MSG_SIZE;
    OutSecBuff.BufferType = SECBUFFER_TOKEN;


    // Dynamically allocate since being in a service doesn't
    // give us the guaranteed luxury of 10+KB stack allocations.

    cbMaxToken = GetPkgMaxToken(pkgID);

    SlowOutBufPlain = (char *) ALLOCATE_FIXED_MEMORY(cbMaxToken);

    if( SlowOutBufPlain == NULL )
    {
        RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }
    OutSecBuff.pvBuffer = SlowOutBufPlain;
    OutSecBuff.cbBuffer = cbMaxToken;

    //
    //  Prepare our Input buffer if a CHALLENGE message is passed in.
    //
    if ( pBuffIn )
    {
        InBuffDesc.ulVersion = 0;
        InBuffDesc.cBuffers  = 1;
        InBuffDesc.pBuffers  = &InSecBuff;

        InSecBuff.BufferType = SECBUFFER_TOKEN;

        //
        // If this is UUENCODED, decode it first
        //
        if ( g_fUUEncodeData)
        {
            DWORD cbDecodedBuf;

            cbDecodedBuf = cbBuffIn;
            SlowDecodedBuf = (char*) ALLOCATE_FIXED_MEMORY(cbDecodedBuf);
            if( SlowDecodedBuf == NULL )
            {
                RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
                goto Cleanup;
            }

            InSecBuff.cbBuffer   = HTUU_decode ((char*)pBuffIn, (UCHAR*)SlowDecodedBuf,
                                                cbDecodedBuf);
            InSecBuff.pvBuffer   = SlowDecodedBuf;
        }
        else
        {
            InSecBuff.cbBuffer   = cbBuffIn;
            InSecBuff.pvBuffer   = pBuffIn;
        }
    }

    // If scheme is Negotiate, set ISC_REQ_MUTUAL_AUTH and decorate
    // the server name indicated by pszTarget
    if (pszScheme && !(lstrcmpi(pszScheme, "Negotiate")))
    {
        fContextReq |= ISC_REQ_MUTUAL_AUTH;
        cbTarget = (pszTarget ? strlen(pszTarget) : 0);
        if (cbTarget && (cbTarget <= MAX_PATH - sizeof( "HTTP/" )))
        {
            memcpy(szDecoratedTarget, "HTTP/", sizeof( "HTTP/" ) - 1 );
            memcpy(szDecoratedTarget + sizeof( "HTTP/" ) - 1, pszTarget, cbTarget + 1);
            pszTarget = szDecoratedTarget;
        }
    }


    //
    //    Call SSPI function generate the NEGOTIATE/RESPONSE message
    //

SspiRetry:

//
// BUGBUG: Same credential handle could be used by multiple threads at the
// same time.
//
    SecStat = (*(pData->pFuncTbl->InitializeSecurityContext))(
                                pCredential, 
                                pInContext,
                                pszTarget,
                                fContextReq,
                                0,
                                SECURITY_NATIVE_DREP,
                                (pBuffIn) ? &InBuffDesc : NULL, 
                                0,
                                pOutContext, 
                                &OutBuffDesc,
                                &ContextAttributes,
                                &Lifetime );
    *pssResult = SecStat;
    
    //
    //    If SSPI function fails 
    //
    if ( !NT_SUCCESS( SecStat ) )
    {
        RetStatus = SPM_ERROR;

        //
        //    If SSPI do not have user name/password for the secified package,
        //
        if (SecStat == SEC_E_NO_CREDENTIALS)
        {
            //
            //  If we have prompted the user and still get back "No Credential"
            //  error, it means the user does not have valid credential; the 
            //    user hit <CANCEL> on the UI box. If we have supplied a valid 
            //    credential, but get back a "No Credential" error, then something
            //    has gone wrong; we definitely should return to caller with ERROR
            //
            if ((fContextReq & ISC_REQ_PROMPT_FOR_CREDS) ||
                (fContextReq & ISC_REQ_USE_SUPPLIED_CREDS))
            {
                RetStatus = SPM_ERROR;    // return ERROR to caller
            }
            else if (bNonBlock)
            {
                //
                //    Blocking is not permitted, return WOULD_BLOCK to caller
                //
                RetStatus = SPM_STATUS_WOULD_BLOCK;
            }
            else
            {
                //    Blocking is permitted and we have not asked the SSPI to
                //  prompt the user for proper credential, we should call  
                //  the SSPI again with PROMPT_CREDS flag set.
                //
                fContextReq = fContextReq | ISC_REQ_PROMPT_FOR_CREDS;
                goto SspiRetry;
            }
        }
        SetLastError( SecStat );

        goto Cleanup;
    }

    RetStatus = SPM_STATUS_OK;

    //
    //  Only return the SSPI blob if a output buffer is specified
    //
    if (pFinalBuff)
    {
        //
        //    Initialize the final buffer to hold the package name followed by 
        //    a space. And setup the pOutMsg pointer to points to the character 
        //    following the space so that the final NEGOTIATE/RESPONSE can be 
        //    copied into the pFinalBuff starting at the character pointed to 
        //    by pOutMsg. 
        //
        wsprintf (pFinalBuff, "%s ", pData->PkgList[pkgID]->pName);
        pOutMsg = pFinalBuff + lstrlen(pFinalBuff);

        if ( g_fUUEncodeData)
        {
            maxbufsize = *pcbBuffOut - 
                         lstrlen(pData->PkgList[pkgID]->pName) - 1;
            //
            //  uuencode it, but make sure that it fits in the given buffer
            //
            retsize = HTUU_encode ((BYTE *) OutSecBuff.pvBuffer,
                                   OutSecBuff.cbBuffer,
                                   (CHAR *) pOutMsg, maxbufsize);
            if (retsize > 0)
                *pcbBuffOut = retsize + lstrlen(pData->PkgList[pkgID]->pName)+1;
            else
                RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
        }
        else if ( *pcbBuffOut >= lstrlen(pData->PkgList[pkgID]->pName) + 
                                 OutSecBuff.cbBuffer + 1 )
        {
            CopyMemory( (CHAR *) pOutMsg, 
                        OutSecBuff.pvBuffer,
                        OutSecBuff.cbBuffer );
            *pcbBuffOut = lstrlen(pData->PkgList[pkgID]->pName) + 1 +
                          OutSecBuff.cbBuffer;
        }
        else
        {
            *pcbBuffOut = lstrlen(pData->PkgList[pkgID]->pName) + 
                          OutSecBuff.cbBuffer + 1;
            RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
        }
    }

Cleanup:

    if( SlowOutBufPlain != NULL )
    {
        FREE_MEMORY( SlowOutBufPlain );
    }

    if( SlowDecodedBuf != NULL )
    {
        FREE_MEMORY( SlowDecodedBuf );
    }

    return (RetStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\aproxp.h ===
// precompiled header

//#include <wininetp.h>

//
// NT headers and our basterized versions of
//

#include <winsock.h>
#include <sockreg.h>
#include "vdhcpapi.h"
#include <wscntl.h>
#include <ntddtcp.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <llinfo.h>
#include <ipinfo.h>

#include <lmcons.h>
#include <optchg.h>


#include <dhcp.h>
#include <dhcplib.h>

//
//  Local header files
//

#include <dhcpdef.h>
#include <debug.h>
#include <dhcploc.h>
#include <dhcppro.h>

#include <options.h>
#include <optreg.h>
#include <stack.h>

#include <iphlpapi.h>
#include <apiappl.h>

#include "ipconfig.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\apdetect.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    apdetect.cxx

Abstract:

    This is the overall generic wrappers and entry code to the 
      auto-proxy, auto-detection code, that sends DHCP informs,
      and mundges through DNS to find an URL for proxy configuration

Author:

    Arthur Bierer (arthurbi)  15-Jul-1998

Environment:

    User Mode - Win32

Revision History:

    Arthur Bierer (arthurbi)  15-Jul-1998
        Created

    Josh Cohen (joshco)     7-oct-1998
        added proxydetecttype

    Stephen Sulzer (ssulzer) 24-Feb-2001
        WinHttp 5 Autoproxy support
        
--*/

#include <wininetp.h>
#include "aproxp.h"
#include "apdetect.h"


DWORD
DetectAutoProxyUrl(
    IN  DWORD   dwDetectFlags,
    OUT LPSTR * ppszAutoProxyUrl
    )
{
    DWORD       error;
    bool        bDetected = false;

    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "DetectAutoProxyUrl",
                 "%u, %x",
                 dwDetectFlags,
                 ppszAutoProxyUrl
                 ));

    INET_ASSERT(GlobalDataInitialized);

    error = LoadWinsock();

    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    if (PROXY_AUTO_DETECT_TYPE_DHCP & dwDetectFlags)
    {
        CIpConfig Interfaces;

        if (Interfaces.DoInformsOnEachInterface(ppszAutoProxyUrl))
        {
            //printf("success on DHCP search: got %s\n", szAutoProxyUrl);
            bDetected = true;
        }
    }

    if (!bDetected && (PROXY_AUTO_DETECT_TYPE_DNS_A & dwDetectFlags))
    {
        if (QueryWellKnownDnsName(ppszAutoProxyUrl) == ERROR_SUCCESS)
        {
            //printf("success on well qualified name search: got %s\n", szAutoProxyUrl);
            bDetected = true;
        }
    }

    if (bDetected)
    {
        INET_ASSERT(*ppszAutoProxyUrl);
        error = ERROR_SUCCESS;
    }
    else
    {
        *ppszAutoProxyUrl = NULL;
        error = ERROR_WINHTTP_AUTODETECTION_FAILED;
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\apiappl.h ===
//================================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: these are the exported dhcp client api function definitions
//================================================================================

#ifndef APIAPPL_H_INCLUDED
#define APIAPPL_H_INCLUDED

#ifndef DHCPAPI_PARAMS_DEFINED
#define DHCPAPI_PARAMS_DEFINED
typedef struct _DHCPAPI_PARAMS {                  // use this structure to request params
    ULONG                          Flags;         // for future use
    ULONG                          OptionId;      // what option is this?
    BOOL                           IsVendor;      // is this vendor specific?
    LPBYTE                         Data;          // the actual data
    DWORD                          nBytesData;    // how many bytes of data are there in Data?
} DHCPAPI_PARAMS, *PDHCPAPI_PARAMS, *LPDHCPAPI_PARAMS;
#endif DHCPAPI_PARAMS_DEFINED

DWORD                                             // win32 status
DhcpAcquireParameters(                            // acquire/renew a lease
    IN      LPWSTR                 AdapterName    // adapter to acquire lease on
);

DWORD                                             // win32 status
DhcpReleaseParameters(                            // release an existing lease
    IN      LPWSTR                 AdapterName    // adpater to release lease for
);

DWORD                                             // win32 status
DhcpEnableDynamicConfic(                          // convert from static to dhcp
    IN      LPWSTR                 AdapterName    // convert for this adapter
);

DWORD                                             // win32 status
DhcpDisableDynamicConfig(                         // convert from dhcp to static
    IN      LPWSTR                 AdapterName    // convert this adapter
);

DWORD                                             // win32 status
DhcpStaticRefreshParams(                          // some registry parameters may have changed, refresh them
    IN      LPWSTR                 AdapterName
);

DWORD
APIENTRY // Request client for options.. and get the options.
DhcpRequestOptions(
    LPWSTR             AdapterName,
    BYTE              *pbRequestedOptions,
    DWORD              dwNumberOfOptions,
    BYTE             **ppOptionList,        // out param
    DWORD             *pdwOptionListSize,   // out param
    BYTE             **ppbReturnedOptions,  // out param
    DWORD             *pdwNumberOfAvailableOptions // out param
);

DWORD
APIENTRY // Register with the client to get Event for notification.
DhcpRegisterOptions(
    LPWSTR             AdapterName ,  // Null implies ALL adapters.
    LPBYTE             OptionList  ,  // The list of options to check.
    DWORD              OptionListSz,  // The size of the above list
    HANDLE             *pdwHandle     // the handle of an event to wait for.
);  // returns an event.


DWORD
APIENTRY // Deregister with the client..
DhcpDeRegisterOptions(
    HANDLE             Event          // This MUST be the one returned by above fn.
);

DWORD                                             // win32 status
APIENTRY
DhcpRequestParameters(                            // request parameters of client
    IN      LPWSTR                 AdapterName,   // adapter name to request for
    IN      LPBYTE                 ClassId,       // byte stream of class id to use
    IN      DWORD                  ClassIdLen,    // # of bytes of class id to use
    IN      PDHCPAPI_PARAMS        SendParams,    // parameters to send to server
    IN      DWORD                  nSendParams,   // size of above array
    IN      DWORD                  Flags,         // must be zero, reserved
    IN OUT  PDHCPAPI_PARAMS        RecdParams,    // fill this array with received params
    IN OUT  LPDWORD                pnRecdParamsBytes // i/p: size of above in BYTES, o/p required bytes or filled up # of elements
);  // returns ERROR_MORE_DATA if o/p buffer is of insufficient size, and fills in reqd size in # of bytes

DWORD                                             // win32 status
APIENTRY
DhcpRegisterParameterChangeNofitication(          // notify if a parameter has changed
    IN      LPWSTR                 AdapterName,   // adapter of interest
    IN      LPBYTE                 ClassId,       // byte stream of class id to use
    IN      DWORD                  ClassIdLen,    // # of bytes of class id
    IN      PDHCPAPI_PARAMS        Params,        // params of interest
    IN      DWORD                  nParams,       // # of elts in above array
    IN      DWORD                  Flags,         // must be zero, reserved
    IN OUT  PHANDLE                hEvent         // handle to event that will be SetEvent'ed in case of param change
);

DWORD
APIENTRY
DhcpDeRegisterParameterChangeNofitication(        // undo the registration
    IN      HANDLE                 Event          // handle to event returned by DhcpRegisterParameterChangeNotification, NULL ==> everything
);

DWORD                                             // win32 status
APIENTRY
DhcpPersistentRequestParams(                      // parameters to request persistently
    IN      LPWSTR                 AdapterName,   // adapter name to request for
    IN      LPBYTE                 ClassId,       // byte stream of class id to use
    IN      DWORD                  ClassIdLen,    // # of bytes of class id
    IN      PDHCPAPI_PARAMS        SendParams,    // persistent parameters
    IN      DWORD                  nSendParams,   // size of above array
    IN      DWORD                  Flags,         // must be zero, reserved
    IN      LPWSTR                 AppName        // the name of the app that is to be used for this instance
);

DWORD                                             // win32 status
APIENTRY
DhcpDelPersistentRequestParams(                   // undo the effect of a persistent request -- currently undo from registry
    IN      LPWSTR                 AdapterName,   // the name of the adpater to delete for
    IN      LPWSTR                 AppName        // the name used by the app
);

#endif APIAPPL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\auth\sspspm.cxx ===
/*#----------------------------------------------------------------------------
**
**  File:           sspspm.c
**
**  Synopsis:   Security Protocol Module for SSPI Authentication providers.
**                  
**      This module contains major funtions of the SEC_SSPI.DLL which 
**      allows the Internet Explorer to use SSPI providers for authentication.
**      The function exported to the Internet Explorer is Ssp_Load() which 
**      passes the address of the Ssp__DownCall() function to the Explorer.
**      Then the Explorer will call Ssp__DownCall() when it needs service from 
**      this SPM DLL.  The two major functions called by Ssp__DownCall() to 
**      service Explorer's request are Ssp__PreProcessRequest() and 
**      Ssp__ProcessResponse().  In brief, Ssp__PreProcessRequest() is 
**      called before the Explorer sends out a request which does not have 
**      any 'Authorization' header yet.  And Ssp__ProcessResponse() is called 
**      whenever the Explorer receives an 401 'Unauthorized' response from the 
**      server.  This SPM DLL supports all SSPI packages which are installed 
**      on the machine.
**
**      This SPM DLL is called by the Internet Explorer only for its
**      The Internet Explorer only calls this SPM DLL when it needs 
**      authentication data in its request/response. In other words, the 
**      Explorer never calls this SPM DLL when an authentication succeeded; 
**      it never calls this DLL when it decide to give up on a connection 
**      because of server response timeout.  Because of this fact, this SPM 
**      DLL never has sufficient information on the state of each server 
**      connection; it only know its state based on the content of the last 
**      request and the content of the current response. For this reason, this 
**      SPM DLL does not keep state information for each host it has visited 
**      unless the information is essential. 
**      The security context handle returned from the first call of  
**      InitializeSecurityContext() for NEGOTIATE message generation is 
**      always the identical for a SSPI package when the same server host is 
**      passed.  Since the server host name is always in the request/response
**      header, the only information essential in generating a NEGOTIATE or 
**      RESPONSE is already available in the header. So unlike most SSPI 
**      application, this DLL will not keep the security context handle which 
**      it received from the SSPI function calls. Whenever it needs to call 
**      the SSPI function for generating a RESPONSE, it will first call the 
**      SSPI function without the CHALLENGE to get a security context handle.
**      Then it calls the SSPI function again with the CHALLENGE to generate 
**      a RESPONSE.
**
**
**      Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
**
**  Authors:        LucyC       Created                         25 Sept. 1995
**
**---------------------------------------------------------------------------*/
#include <wininetp.h>
#include <ntlmsp.h>
#include "sspspm.h"

//
// Global variable where all the SSPI Pkgs data is collected
//

SspData  *g_pSspData;


HINSTANCE g_hSecLib = NULL;

/*-----------------------------------------------------------------------------
**
**  Function:   SpmAddSSPIPkg
**
**  Synopsis:   This function adds a SSPI package to the SPM's package list.
**
**  Arguments:  pData - Points to the private SPM data structure containing 
**                      the package list and the package info.
**              pPkgName - package name
**              cbMaxToken - max size of security token
**
**  Returns:    The index in the package list where this new package is added.
**              If failed to add the new package, SSPPKG_ERROR is returned.
**
**  History:    LucyC       Created                             21 Oct. 1995
**
**---------------------------------------------------------------------------*/
static UCHAR
SpmAddSSPIPkg (
    SspData *pData, 
    LPTSTR   pPkgName,
    ULONG    cbMaxToken
    )
{
    if ( (pData->PkgList[pData->PkgCnt] =
                        (SSPAuthPkg *)LocalAlloc(0, sizeof(SSPAuthPkg))) == NULL)
    {
        return SSPPKG_ERROR;
    }

    if ( (pData->PkgList[pData->PkgCnt]->pName = 
                        (LPSTR)LocalAlloc(0, lstrlen(pPkgName)+1)) == NULL)
    {
        LocalFree(pData->PkgList[pData->PkgCnt]);
        pData->PkgList[pData->PkgCnt] = NULL;
        return SSPPKG_ERROR;
    }

    lstrcpy (pData->PkgList[pData->PkgCnt]->pName, pPkgName);
    pData->PkgList[ pData->PkgCnt ]->Capabilities = 0 ;

    pData->PkgList[ pData->PkgCnt ]->cbMaxToken = cbMaxToken;

    //
    // Determine if this package supports anything of interest to
    // us.
    //

    if ( lstrcmpi( pPkgName, NTLMSP_NAME_A ) == 0 )
    {
        //
        // NTLM supports the standard credential structure
        //

        pData->PkgList[ pData->PkgCnt ]->Capabilities |= SSPAUTHPKG_SUPPORT_NTLM_CREDS ;
    }
    else if ( lstrcmpi( pPkgName, "Negotiate" ) == 0 )
    {
        //
        // Negotiate supports that cred structure too
        //

        pData->PkgList[ pData->PkgCnt ]->Capabilities |= SSPAUTHPKG_SUPPORT_NTLM_CREDS ;

    }
    else
    {
        //
        // Add more comparisons here, eventually.
        //

        ;
    }

    pData->PkgCnt++;
    return (pData->PkgCnt - 1);
}

/*-----------------------------------------------------------------------------
**
**  Function:   SpmFreePkgList
**
**  Synopsis:   This function frees memory allocated for the package list. 
**
**  Arguments:  pData - Points to the private SPM data structure containing 
**                      the package list and the package info.
**
**  Returns:    void.
**
**  History:    LucyC       Created                             21 Oct. 1995
**
**---------------------------------------------------------------------------*/
static VOID
SpmFreePkgList (
    SspData *pData
    )
{
    int ii;

    for (ii = 0; ii < pData->PkgCnt; ii++)
    {
        LocalFree(pData->PkgList[ii]->pName);

        LocalFree(pData->PkgList[ii]);
    }

    LocalFree(pData->PkgList);
}


/*-----------------------------------------------------------------------------
**
**  Function:   Ssp__Unload
**
**  Synopsis:   This function is called by the Internet Explorer before 
**              the SPM DLL is unloaded from the memory.
**
**  Arguments:  fpUI - From Explorer for making all UI_SERVICE call
**              pvOpaqueOS - From Explorer for making all UI_SERVICE call
**              htspm - the SPM structure which contains the global data 
**                      storage for this SPM DLL.
**
**  Returns:    always returns SPM_STATUS_OK, which means successful.
**
**  History:    LucyC       Created                             25 Sept. 1995
**
**---------------------------------------------------------------------------*/
DWORD SSPI_Unload()
{
    if (!AuthLock())
    {
        return SPM_STATUS_INSUFFICIENT_BUFFER;
    }

    if (g_pSspData != NULL)
    {
        SpmFreePkgList(g_pSspData);
        LocalFree(g_pSspData);
        g_pSspData = NULL;
    }

    if (g_hSecLib)
    {
        FreeLibrary (g_hSecLib);
        g_hSecLib = NULL;
    }

    AuthUnlock();
        
    return SPM_STATUS_OK;
}

/*-----------------------------------------------------------------------------
**
**  Function:   SspSPM_InitData
**
**  Synopsis:   This function allocates and initializes global data structure 
**              of the SPM DLL.
**
**  Arguments:  
**
**  Returns:    Pointer to the allocated global data structure.
**
**  History:    LucyC       Created                             25 Sept. 1995
**
**---------------------------------------------------------------------------*/
LPVOID SSPI_InitGlobals(void)
{
    SspData *pData = NULL;
    OSVERSIONINFO   VerInfo;
    INIT_SECURITY_INTERFACE    addrProcISI = NULL;

    SECURITY_STATUS sstat;
    ULONG           ii, cntPkg;
    PSecPkgInfo     pPkgInfo = NULL;
    PSecurityFunctionTable    pFuncTbl = NULL;

    if (g_pSspData)
        return g_pSspData;

    static BOOL Initializing = FALSE;
    static BOOL Initialized = FALSE;

    if (!AuthLock())
    {
        goto done;
    }

    if (Initializing) 
    {
        //if re-entered on same thread, fail.
        goto leave;
    }
    else if (g_pSspData)
    {
        //else some other thread succeeded, and we can fall out.
        goto leave;
    }
    else if (Initialized)
    {
        //else if we've failed initialization for non-entrancy reasons, don't reattempt
        goto leave;
    }

    Initializing = TRUE;

    //Ensure that the AuthLock is never abandoned.
    __try
    {
        //
        // Initialize SSP SPM Global Data
        //

        VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
        if (!GetVersionEx (&VerInfo))   // If this fails, something has gone wrong
        {
            goto quit;
        }

        if (VerInfo.dwPlatformId != VER_PLATFORM_WIN32_NT)
        {
            goto quit;
        }

        if ((pData = (SspData *) LocalAlloc(0, sizeof(SspData))) == NULL)    {
            
            goto quit;

        }

        //
        //  Keep these information in global SPM
        //
        ZeroMemory (pData, sizeof(SspData));

        //
        //  Load Security DLL
        //
        g_hSecLib = LoadLibrary (SSP_SPM_NT_DLL);
        if (g_hSecLib == NULL)
        {
            // This should never happen.
            LocalFree(pData);
            pData = NULL;
            goto Cleanup;
        }

        addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress( g_hSecLib, 
                        SECURITY_ENTRYPOINT);       
        if (addrProcISI == NULL)
        {
            LocalFree(pData);
            pData = NULL;
            goto Cleanup;
        }

        //
        // Get the SSPI function table
        //
        pFuncTbl = (*addrProcISI)();

        if (pFuncTbl == NULL)
        {
            LocalFree(pData);
            pData = NULL;
            goto Cleanup;
        }
        
        //
        //  Get list of packages supported
        //
        sstat = (*(pFuncTbl->EnumerateSecurityPackages))(&cntPkg, &pPkgInfo);
        if (sstat != SEC_E_OK || pPkgInfo == NULL)
        {
            //
            // ??? Should we give up here ???
            // EnumerateSecurityPackage() failed
            //
            goto Cleanup;
        }

        if (cntPkg)
        {
            //
            //  Create the package list
            //
            if ((pData->PkgList = (PSSPAuthPkg *)LocalAlloc(0, 
                                                cntPkg*sizeof(PSSPAuthPkg))) == NULL)
            {
                goto Cleanup;
            }
        }

        for (ii = 0; ii < cntPkg; ii++)
        {
            //DebugTrace(SSPSPMID, "Found %s SSPI package\n", 
            //                     pPkgInfo[ii].Name);

            if (SpmAddSSPIPkg (pData, 
                               pPkgInfo[ii].Name,
                               pPkgInfo[ii].cbMaxToken
                               ) == SSPPKG_ERROR)
            {
                goto Cleanup;
            }
        }

        pData->pFuncTbl = pFuncTbl;
        pData->bKeepList = TRUE;

        if (pData->PkgCnt == 0)
        {
            goto Cleanup;
        }

        g_pSspData = pData;
        pData = NULL;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        goto Cleanup;
    }
    ENDEXCEPT

Cleanup:


    if( pPkgInfo != NULL )
    {
        //
        // Free buffer returned by the enumerate security package function
        //

        (*(pFuncTbl->FreeContextBuffer))(pPkgInfo);
    }

    if( pData != NULL )
    {
        SpmFreePkgList (pData);
    }

    /*
    if (g_hSecLib)
    {
        FreeLibrary (g_hSecLib);
        g_hSecLib = NULL;
    }
    */


quit: 
    Initialized = TRUE;
    Initializing = FALSE;

//jump here if you grabbed the auth lock but don't want to affect Init*
leave:
    AuthUnlock();

//jump here IFF you didn't grab the Authlock
done:
    return (g_pSspData);
}

INT
GetPkgId(LPTSTR  lpszPkgName)
{
    int ii;

    if ( g_pSspData == NULL )
    {
        return -1;
    }
    
    if (!AuthLock())
    {
        return -1;
    }
    
    for (ii = 0; ii < g_pSspData->PkgCnt; ii++)
    {
        if (!lstrcmp(g_pSspData->PkgList[ii]->pName, lpszPkgName))
        {
            AuthUnlock();
            return(ii);
        }
    }

    AuthUnlock();
    return(-1);
}

DWORD
GetPkgCapabilities(
    INT Package
    )
{
    if (!AuthLock())
    {
        return 0;
    }
    
    DWORD dwCaps;
    if ( Package < g_pSspData->PkgCnt )
    {
        dwCaps = g_pSspData->PkgList[ Package ]->Capabilities ;
    }
    else
        dwCaps = 0 ;

    AuthUnlock();
    return dwCaps;
}

ULONG
GetPkgMaxToken(
    INT Package
    )
{
    if (!AuthLock())
    {
        return MAX_AUTH_MSG_SIZE;
    }
    
    ULONG dwMaxToken;

    if ( Package < g_pSspData->PkgCnt )
    {
        dwMaxToken = g_pSspData->PkgList[ Package ]->cbMaxToken;
    }
    else {
        // be compatible with old static buffer size
        dwMaxToken = MAX_AUTH_MSG_SIZE;
    }

    AuthUnlock();
    return dwMaxToken;
}

//
//  Calls to this function are serialized
//

DWORD_PTR SSPI_InitScheme (LPCSTR lpszScheme)
{
    int ii;

       if (!SSPI_InitGlobals())
           return 0;
           
       if (!AuthLock())
       {
           return 0;
       }
    //  Once initialized, check to see if this scheme is installed 
    for (ii = 0; ii < g_pSspData->PkgCnt && 
        lstrcmp (g_pSspData->PkgList[ii]->pName, lpszScheme); ii++);

    if (ii >= g_pSspData->PkgCnt)
    {
        // This scheme is not installed on this machine
        AuthUnlock();
        return (0);
    }
    
    AuthUnlock();
    return ((DWORD_PTR)g_pSspData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\auth\splugin.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    splugin.cxx

Abstract:

    This file contains the implementation for Plug In Authentication

    The following functions are exported by this module:

    AuthOnRequest
    AuthOnResponse
    AuthCtxClose
    AuthInDialog
    AuthNotify
    AuthUnload

Author:

    Arthur Bierer (arthurbi) 25-Dec-1995

Revision History:
 
    Rajeev Dujari (rajeevd)  01-Oct-1996 overhauled

    Adriaan Canter (adriaanc) 01-03-1998 :
    AUTHCTX now a virtual base class, from which derived classes
    inherit to implement the different authentication protocols:

    BASIC_CTX  (Basic auth),
    PLUG_CTX   (NTLM, Negotiate)
    DIGEST_CTX (Digest auth, new)


--*/

#include <wininetp.h>
#include <splugin.hxx>
#include "auth.h"
#include "sspspm.h"

//
// constants
//

#define WILDCARD 0x05 // don't use '*' since it can appear in an URL
#define AssertHaveLock() INET_ASSERT(g_dwOwnerId == GetCurrentThreadId())

#define MAX_AUTH_HDR_SIZE (MAX_BLOB_SIZE + HTTP_PROXY_AUTHORIZATION_LEN + 2)

//
//  globals
//

// Global authentication providers list and state.
AUTHCTX::SPMState  AUTHCTX::g_eState;
AUTHCTX::SPMData  *AUTHCTX::g_pSPMList = NULL;


// Global auth crit sect.
CCritSec g_crstAuth;

#ifdef DBG
DWORD g_dwOwnerId = 0;
LONG g_nLockCount = 0;
#endif

//
// private prototypes
//

//-----------------------------------------------------------------------------
//
//  AUTH_CREDS class definition.
//
//
PRIVATE AUTH_CREDS *Creds_Create
(
    LPSTR lpszHost,
    LPSTR lpszRealm,
    AUTHCTX::SPMData* pSPM
);

void  Creds_Free (AUTH_CREDS *Creds);



//-----------------------------------------------------------------------------
//
//  Utilities
//
//

PRIVATE VOID SspiFlush (LPSTR pszDll);
PRIVATE BOOL TemplateMatch(LPSTR lpszTemplate, LPSTR lpszFilename);
PRIVATE LPSTR MakeTemplate (LPSTR docname);
PRIVATE LPSTR GetProxyName (HTTP_REQUEST_HANDLE_OBJECT *pRequest);

PRIVATE BOOL ReadRegKey(
    BYTE * pbRegValue,
    DWORD * pdwNumBytes,
    LPSTR  pszRegKey,
    LPSTR  pszRegValueName,
    DWORD  dwRegTypeExpected);



//-----------------------------------------------------------------------------
//
//
//      AUTH_CREDS functions
//
//          Creds_CREATE
//          Creds_FREE
//          SetUser
//          SetPass
//          FlushCredsList
//

PRIVATE AUTH_CREDS *Creds_Create // AUTH_CREDS constructor
(
    LPSTR lpszHost,     // Host Name to place in structure.
    LPSTR lpszRealm,    // Realm string to add.
    AUTHCTX::SPMData * pSPM
)
{
    AUTH_CREDS* Creds = (AUTH_CREDS *) ALLOCATE_ZERO_MEMORY(sizeof(*Creds));
    if (!Creds)
        return NULL;

    INET_ASSERT (!Creds->lpszHost);
    Creds->lpszHost    = lpszHost ?  NewString(lpszHost)   : NULL;
    
    INET_ASSERT (!Creds->lpszRealm);
    Creds->lpszRealm   = lpszRealm ? NewString(lpszRealm)  : NULL;
    Creds->pSPM         = pSPM;

    Creds->xszPass.SetSecuritySensitive();

    if (  (!Creds->lpszHost  && lpszHost)
       || (!Creds->lpszRealm && lpszRealm)
       )
    {
        Creds_Free(Creds);
        return NULL;
    }

    return Creds;
}

PRIVATE VOID Creds_Free(AUTH_CREDS *Creds) // AUTH_CREDS destructor
{
    if ( Creds )
    {
        if (Creds->lpszHost)
            FREE_MEMORY(Creds->lpszHost);
        if ( Creds->lpszUser )
        {
            SecureZeroMemory(Creds->lpszUser, strlen(Creds->lpszUser));
            FREE_MEMORY(Creds->lpszUser);
        }
        Creds->xszPass.Free();
        if ( Creds->lpszRealm )
            FREE_MEMORY(Creds->lpszRealm);
        FREE_MEMORY(Creds);
    }
}

PUBLIC DWORD AUTH_CREDS::SetUser (LPSTR lpszInput)
{
    //AssertHaveLock();
    if (!lpszInput)
    {
        if (lpszUser)
        {
            SecureZeroMemory(lpszUser, strlen(lpszUser));
            FREE_MEMORY (lpszUser);
        }
        lpszUser = NULL;
        return ERROR_SUCCESS;
    }
    if (lpszUser && !lstrcmp (lpszUser, lpszInput))
        return ERROR_SUCCESS; // didn't change
    LPSTR lpszTemp = NewString(lpszInput);
    if (!lpszTemp)
        return ERROR_NOT_ENOUGH_MEMORY;
    if (lpszUser)
    {
        SecureZeroMemory(lpszUser, strlen(lpszUser));
        FREE_MEMORY (lpszUser);
    }
    lpszUser = lpszTemp;
    return ERROR_SUCCESS;
}

PUBLIC DWORD AUTH_CREDS::SetPass (LPSTR lpszInput)
{
    //AssertHaveLock();
    if (!lpszInput)
    {
        xszPass.Free();
        return ERROR_SUCCESS;
    }

    return xszPass.SetData(lpszInput) ? ERROR_SUCCESS : ERROR_NOT_ENOUGH_MEMORY;
}


/*++
Delete some entries from a singly linked list.
--*/
/*
PRIVATE void FlushCredsList (AUTH_CREDS **ppList)
{
    AssertHaveLock();

    AUTH_CREDS *Creds = *ppList;
    while (Creds)
    {
        AUTH_CREDS *CredsNext = Creds->pNext;

        if (!Creds->nLockCount)
            Creds_Free (Creds);
        else
        {
            *ppList = Creds;
            ppList = &(Creds->pNext);
        }

        Creds = CredsNext;
    }
    *ppList = NULL;
}
*/


//-----------------------------------------------------------------------------
//
//
//      Auth* functions
//
//          AuthOpen
//          AuthClose
//          AuthLock
//          AuthUnlock
//          AuthInDialog
//          AuthNotify
//
//

BOOL AuthOpen (void)
{
    INET_ASSERT (!g_dwOwnerId && !g_nLockCount);
    return g_crstAuth.Init();
}

void AuthClose (void)
{
    g_crstAuth.FreeLock();
    INET_ASSERT (!g_dwOwnerId && !g_nLockCount);
}

BOOL AuthLock (void)
{
    INET_ASSERT(g_crstAuth.IsInitialized() == TRUE);
    if (!g_crstAuth.Lock())
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }
    DEBUG_ONLY (if (!g_nLockCount++) g_dwOwnerId = GetCurrentThreadId();)
    return TRUE;
}

void AuthUnlock (void)
{
    INET_ASSERT(g_crstAuth.IsInitialized() == TRUE);
    INET_ASSERT (g_nLockCount > 0);
    DEBUG_ONLY (if (!--g_nLockCount) g_dwOwnerId = 0;)
    g_crstAuth.Unlock();
}


PUBLIC void AuthUnload (void)
/*++
Routine Description:
    Frees all Cached URLs, and unloads any loaded DLL authentication modeles.

--*/
{
    if (g_crstAuth.IsInitialized())
    {
        if (AuthLock())
        {
            AUTHCTX::UnloadAll();
            AuthUnlock();
        }
    }

    DIGEST_CTX::GlobalRelease();
}


//-----------------------------------------------------------------------------
//
//
//      Utility Functions:
//
//          SspiFlush
//          TemplateMatch
//          MakeTemplate
//          GetProxyName
//          ReadRegKey
//          TrimQuotes
//          TrimWhiteSpace
//          GetDelimitedToken
//          GetKeyValuePair
//
//


typedef BOOL (WINAPI * SSPI_FLUSH) (VOID) ;

void SspiFlush (LPSTR pszDll)
{
    __try
    {
        HINSTANCE hinst = GetModuleHandle (pszDll);

        if (hinst)
        {
            SSPI_FLUSH pfnFlush = (SSPI_FLUSH)
                GetProcAddress (hinst, "CleanupCredentialCache");

            if (pfnFlush)
            {
                (*pfnFlush) ();
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT (FALSE);
    }
    ENDEXCEPT
}



PRIVATE BOOL TemplateMatch(LPSTR lpszTemplate, LPSTR lpszFilename)

/*++

Routine Description:

    Attempts to match a template URL string with a URL ( FileName )

Arguments:

    lpszTemplate             - Template to match against.
    lpszFilename             - URL to match with the template

Return Value:

    BOOL
    Success - TRUE - match
    Failure - FALSE - no match

Comments:

    Note: This Legacy code from the SpyGlass IE 1.0 browser

--*/

{
    /* code for this routine cloned from HTAA_templateMatch() */

    CHAR *p = lpszTemplate;
    CHAR *q = lpszFilename;
    int m;

    if (!lpszTemplate || !lpszFilename)
        return 0;

    for (; *p && *q && *p == *q; p++, q++)  /* Find first mismatch */
        ;                                                                       /* do nothing else */

    if (!*p && !*q)
        return 1;                                                       /* Equally long equal strings */
    else if (WILDCARD == *p)
    {                                                                               /* Wildcard */
        p++;                                                            /* Skip wildcard character */
        m = strlen(q) - strlen(p);                      /* Amount to match to wildcard */
        if (m < 0)
            return 0;                                               /* No match, filename too short */
        else
        {                                                                       /* Skip the matched characters and compare */
        if (lstrcmp(p, q + m))
                return 0;                                       /* Tail mismatch */
            else
                return 1;                                       /* Tail match */
        }
    }                                                                               /* if wildcard */
    else
        return 0;                                                       /* Length or character mismatch */
}


PRIVATE LPSTR MakeTemplate (LPSTR docname)

/*++
Routine Description:
    Makes a Template String (from a URL) that can later be used to match a range of URLs.

Arguments:
    ppszTemplate             - pointer to pointer of where Template can be stored
    docname                  - URL to create a template with.

Return Value: BOOL
    Success - TRUE - created
    Failure - FALSE - error

Comments:
    Note: This Legacy code from the SpyGlass IE 1.0 browser
--*/

{
    CHAR *pszTemplate = NULL;
    unsigned long k;
    k = 0;

    if (docname)
    {
        CHAR *slash;
        CHAR *first_slash;

        //
        // Ignore everything after first reserved character.
        //

        BYTE chSave = 0;
        LPSTR lpszScan = docname;
        while (*lpszScan)
        {
            if (*lpszScan == '?' || *lpszScan == ';')
            {
                chSave = *lpszScan;
                *lpszScan = 0;
                break;
            }
            lpszScan++;
        }

        slash = strrchr(docname, '/');

        //
        // If there is a "//" and no other slashes,
        //  then make sure not to chop the hostname off
        //  the URL. ex: http://www.netscape.com
        //  should be //www.netscape.com* not //*
        //

        if (slash)
        {
            first_slash = strchr(docname, '/' );
            if ((first_slash+1) == slash)
                k = lstrlen(docname);
            else
                k = (unsigned long)(slash-docname)+1;
        }

        // Restore any reserved character (or rewrite terminating null)
        *lpszScan = chSave;
    }

    pszTemplate = (CHAR *) ALLOCATE_FIXED_MEMORY(k+2);
    if (!pszTemplate)
        return 0;

    memcpy(pszTemplate, docname, k);
    pszTemplate[k]= WILDCARD;
    pszTemplate[k+1]=0;

    DEBUG_PRINT(HTTP, INFO, ("MakeTemplate: made template [%s] from [%s]\n",
        pszTemplate, docname ));

    return pszTemplate;
}

LPSTR GetProxyName (HTTP_REQUEST_HANDLE_OBJECT *pRequest)
{
    // Get the proxy name.
    LPSTR lpszProxy;
    DWORD cbProxy;
    INTERNET_PORT port;

   pRequest->GetProxyName(
                &lpszProxy,
                &cbProxy,
                &port);

   return lpszProxy;
}


//++------------------------------------------------------------------------
//
//   Function: ReadRegKey
//
//   Synopsis: This function reads a registry key.
//
//   Arguments:
//
//   Returns:   TRUE     no error
//                 FALSE    a fatal error happened
//
//   History:      AshishS    Created     5/22/96
//------------------------------------------------------------------------

BOOL ReadRegKey(
    BYTE * pbRegValue, // The value of the reg key will be
                 // stored here
    DWORD * pdwNumBytes, // Pointer to DWORD conataining
     // the number of bytes in the above buffer - will be
     // set to actual bytes stored.
    LPSTR  pszRegKey, // Reg Key to be opened
    LPSTR  pszRegValueName, // Reg Value to query
    DWORD  dwRegTypeExpected) // Expected type of Value
{
    HKEY   hRegKey;
    DWORD  dwRegType;
    LONG lResult;

     //read registry to find out name of the file
    if ( (lResult = REGOPENKEYEX(HKEY_LOCAL_MACHINE,
                                 pszRegKey, // address of subkey name
                                 0,          // reserved
                                 KEY_READ,   // samDesired
                                 &hRegKey
                                  // address of handle of open key
        )) != ERROR_SUCCESS )
    {
        goto cleanup;
    }


    if ( (lResult =RegQueryValueEx( hRegKey,
                                    pszRegValueName,
                                    0,           // reserved
                                    &dwRegType,// address of buffer
                                     // for value type
                                    pbRegValue,
                                    pdwNumBytes)) != ERROR_SUCCESS )
    {
        REGCLOSEKEY(hRegKey);
        goto cleanup;
    }

    REGCLOSEKEY(hRegKey);

    if ( dwRegType != dwRegTypeExpected )
    {
        goto cleanup;
    }

    return TRUE;

cleanup:

    return FALSE;

}


/*-----------------------------------------------------------------------------
Inplace trim of one leading and one trailing quote.
-----------------------------------------------------------------------------*/
VOID TrimQuotes(LPSTR *psz, LPDWORD pcb)
{
    if (*pcb && (**psz == '"'))
    {
        (*psz)++;
        (*pcb)--;
    }
    if (*pcb && (*(*psz + *pcb - 1) == '"'))
        (*pcb)--;
}

/*-----------------------------------------------------------------------------
Inplace trim of leading and trailing whitespace.
-----------------------------------------------------------------------------*/
VOID TrimWhiteSpace(LPSTR *psz, LPDWORD pcb)
{
    DWORD cb = *pcb;
    CHAR* beg = *psz;
    CHAR* end = beg + cb - 1;

    while ((cb != 0) && ((*beg == ' ') || (*beg == '\t')))
    {
        beg++;
        cb--;
    }

    while ((cb != 0) && ((*end == ' ') || (*end == '\t')))
    {
        end--;
        cb--;
    }

    *psz = beg;
    *pcb = cb;
}

/*-----------------------------------------------------------------------------
Inplace strtok based on one delimiter. Ignores delimiter scoped by quotes.
-----------------------------------------------------------------------------*/
BOOL GetDelimitedToken(LPSTR* pszBuf,   LPDWORD pcbBuf,
                       LPSTR* pszTok,   LPDWORD pcbTok,
                       CHAR   cDelim)
{
    CHAR *pEnd;
    BOOL fQuote = FALSE,
         fRet   = FALSE;

    *pcbTok = 0;
    *pszTok = *pszBuf;
    pEnd = *pszBuf + *pcbBuf - 1;

    while (*pcbBuf)
    {
        if ( ((**pszBuf == cDelim) && !fQuote)
            || (*pszBuf == pEnd)
            || (**pszBuf =='\r')
            || (**pszBuf =='\n'))
        {
            fRet = TRUE;
            break;
        }

        if (**pszBuf == '"')
            fQuote = !fQuote;

        (*pszBuf)++;
        (*pcbBuf)--;
    }

    if (fRet)
    {
        *pcbBuf = (DWORD) (pEnd - *pszBuf);
        if (**pszBuf == cDelim)
        {
            *pcbTok = (DWORD)(*pszBuf - *pszTok);
            (*pszBuf)++;
        }
        else
            *pcbTok = (DWORD) (*pszBuf - *pszTok) + 1;
    }

    return fRet;
}


/*-----------------------------------------------------------------------------
Inplace retrieval of key and value from a buffer of form key = <">value<">
-----------------------------------------------------------------------------*/
BOOL GetKeyValuePair(LPSTR  szB,    DWORD cbB,
                     LPSTR* pszK,   LPDWORD pcbK,
                     LPSTR* pszV,   LPDWORD pcbV)
{
    if (GetDelimitedToken(&szB, &cbB, pszK, pcbK, '='))
    {
        TrimWhiteSpace(pszK, pcbK);

        if (cbB)
        {
            *pszV = szB;
            *pcbV = cbB;
            TrimWhiteSpace(pszV, pcbV);
        }
        else
        {
            *pszV = NULL;
            *pcbV = 0;
        }
        return TRUE;
    }

    else
    {
        *pszK  = *pszV  = NULL;
        *pcbK  = *pcbV = 0;
    }
    return FALSE;
}


//-----------------------------------------------------------------------------
//
//
//      Main authentication functions:
//
//          AddAuthorizationHeader
//          AuthOnRequest
//          ProcessResponseHeader
//          AuthOnRequest
//
//



/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
PRIVATE void AddAuthorizationHeader
(
    HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    AUTHCTX* pAuthCtx
)
{
    if (!pAuthCtx)
        return;

    INET_ASSERT(pAuthCtx->_pSPMData);

    // AssertHaveLock();

    // Call the auth package.
    // CHAR *szHeader;
    // DWORD dwFastHeaderSize = MAX_BLOB_SIZE + HTTP_PROXY_AUTHORIZATION_LEN + 2;
    // CHAR* pszFastHeader = NULL;
    CHAR *szSlowHeader = NULL;
    // ULONG cbHeader;
    LPSTR pBuf;
    DWORD cbBuf;
    DWORD dwPlugInError;
    // CHAR *pszHeader;

    /*
    pszFastHeader = (CHAR*)ALLOCATE_FIXED_MEMORY(dwFastHeaderSize);
    if (!pszFastHeader)
    {
        // Don't worry about reporting an error.
        // Since this is a low mem condition, the only failure resulting
        // from this is that the header won't be added, and this won't
        // directly cause any more harm than unexpectedly failing to
        // authenticate, which isn't bad, given the low mem state.
        return;
    }
    */


    INT PackageId;
    ULONG cbMaxToken;

    //
    // GetPkgMaxToken() will return 10000 if invalid pkg.
    //

    if( (pAuthCtx->_pSPMData) &&
        (pAuthCtx->_pSPMData->szScheme) &&
        ((PackageId = GetPkgId( pAuthCtx->_pSPMData->szScheme )) != -1)
        )
    {
        cbMaxToken = GetPkgMaxToken( PackageId );
    } else {
        cbMaxToken = MAX_AUTH_MSG_SIZE;
    }

    //
    // add space for base64 overhead (33%, but round up)
    //

    cbMaxToken += (cbMaxToken/2);
    
    // Prefix with the appropriate header.

    BOOL fOkToRetry = TRUE;


    cbBuf = HTTP_PROXY_AUTHORIZATION_LEN + 1 + cbMaxToken +  2 + 1;

retry_alloc:

    szSlowHeader = (CHAR*)ALLOCATE_FIXED_MEMORY(cbBuf);

    if( szSlowHeader == NULL )
    {
        return;
    }

    if (pAuthCtx->_fIsProxy)
    {
        memcpy (szSlowHeader, HTTP_PROXY_AUTHORIZATION_SZ, HTTP_PROXY_AUTHORIZATION_LEN);
        pBuf = szSlowHeader + HTTP_PROXY_AUTHORIZATION_LEN;

        // Don't reuse this keep-alive socket after a password cache flush.
        pRequest->SetAuthorized();
    }
    else
    {
        memcpy (szSlowHeader, HTTP_AUTHORIZATION_SZ, HTTP_AUTHORIZATION_LEN);
        pBuf = szSlowHeader + HTTP_AUTHORIZATION_LEN;

        // Don't reuse a keep-alive socket after a password cache flush.
        pRequest->SetAuthorized();
    }

    *pBuf++ = ' ';
    INET_ASSERT (HTTP_PROXY_AUTHORIZATION_LEN >= HTTP_AUTHORIZATION_LEN);

    dwPlugInError =
        pAuthCtx->PreAuthUser(pBuf, &cbBuf);

    if ((dwPlugInError == ERROR_INSUFFICIENT_BUFFER) && (pAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_PASSPORT))
    {
        if (fOkToRetry)
        {
            fOkToRetry = FALSE;
            FREE_MEMORY(szSlowHeader);
            szSlowHeader = NULL;
            goto retry_alloc;
        }
    }

    //  If the plug in did not fail, add its header to the outgoing header list
    if (dwPlugInError == ERROR_SUCCESS && pAuthCtx->GetState() != AUTHCTX::STATE_ERROR)
    {
        // Append CR-LF.
        pBuf += cbBuf;
        *pBuf++ = '\r';
        *pBuf++ = '\n';
        *pBuf = 0;
        cbBuf = (DWORD) (pBuf - szSlowHeader);

        // Add or replace the (proxy-)authorization header.
        wHttpAddRequestHeaders (pRequest, szSlowHeader, cbBuf,
            HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE);

    }

    // delete [] pszHeader;
    if( szSlowHeader )
    {
        FREE_MEMORY( szSlowHeader );
    }

    /*
    if (pszFastHeader)
    {
        FREE_MEMORY( pszFastHeader );
    }
    */

    //DEBUG_LEAVE(0);
}

// biaow: move this to a better place

PSTR DwordSchemeToString(DWORD dwScheme)
{
    switch (dwScheme)
    {
    case WINHTTP_AUTH_SCHEME_BASIC:
        return "Basic";
    case WINHTTP_AUTH_SCHEME_NTLM:
        return "NTLM";
    case WINHTTP_AUTH_SCHEME_PASSPORT:
        return "Passport1.4";
    case WINHTTP_AUTH_SCHEME_DIGEST:
        return "Digest";
    case WINHTTP_AUTH_SCHEME_NEGOTIATE:
        return "Negotiate";
    default:
        return "";
    }
}

DWORD DwordSchemeToFlags(DWORD dwScheme)
{
    switch (dwScheme)
    {
    case WINHTTP_AUTH_SCHEME_BASIC:
        return PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED;
    case WINHTTP_AUTH_SCHEME_NTLM:
        return PLUGIN_AUTH_FLAGS_NO_REALM;
    case WINHTTP_AUTH_SCHEME_PASSPORT:
        return PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED;
    case WINHTTP_AUTH_SCHEME_DIGEST:
        return PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_CAN_HANDLE_UI;
    case WINHTTP_AUTH_SCHEME_NEGOTIATE:
        return PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_NO_REALM;
    default:
        return 0;
    }
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
PUBLIC DWORD AuthOnRequest (IN HINTERNET hRequestMapped)
{
    DEBUG_ENTER ((DBG_HTTP, Dword, "AuthOnRequest", "%#x", hRequestMapped));

    DWORD dwError = ERROR_SUCCESS;
    LPSTR lpszUser, lpszPass = NULL;
    
    // Get username, password, url, and auth context from request handle.
    HTTP_REQUEST_HANDLE_OBJECT *pRequest =
        (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;


    AUTHCTX *pAuthCtx = pRequest->GetAuthCtx();
    BOOL fCredsChanged = FALSE;
    
    // PROXY AUTHENTICATION
    //
    // CERN proxies should remove proxy-authorization headers before forwarding
    // requests to servers.  Otherwise, don't add proxy authorization headers
    // that would be seen by servers on a direct connect or via SSL tunneling.

    if  (pRequest->IsRequestUsingProxy()
      && !pRequest->IsTalkingToSecureServerViaProxy())
    {
        // if an app sets proxy creds, we want to make sure that the specified
        // auth scheme is the same as the auth scheme in progress. Otherwise, we
        // will delete the current auth context and build a new one based on the
        // new scheme.
        if (pRequest->_pProxyCreds 
            && (pAuthCtx && pAuthCtx->_fIsProxy)
            && (pAuthCtx->GetRawSchemeType() != pRequest->_pProxyCreds->_AuthScheme))
        {
            delete pAuthCtx;
            pAuthCtx = NULL;
            pRequest->SetAuthCtx(NULL);
        }

        if (pAuthCtx && pAuthCtx->_fIsProxy)
        {
            // We have a proxy authentication in progress.
            // If a user/pass set on handle, transfer to AUTH_CREDS.

            // First check for proxy credentials and fallback to server
            // for legacy wininet apps. This will invalidate the credentials
            // on the handle they were found for any subsequent calls to
            // GetUserAndPass.
            
            // Serialize access to globals.
            if (AuthLock())
            {
                if (pRequest->_pProxyCreds)
                {
                    lpszPass = pRequest->_pProxyCreds->GetPassword();
                    pAuthCtx->_pCreds->SetUser(pRequest->_pProxyCreds->_pszUserName);
                    pAuthCtx->_pCreds->SetPass(lpszPass);

                }
                else if (pRequest->GetUserAndPass(IS_PROXY, &lpszUser, &lpszPass))
                {
                    pAuthCtx->_pCreds->SetUser(lpszUser);
                    pAuthCtx->_pCreds->SetPass(lpszPass);
                }

                AuthUnlock();

                // Add the authorization header.
                AddAuthorizationHeader (pRequest, pAuthCtx);
            }
        }

        // NO PROXY AUTHENTICATION CONTEXT -> SEE IF A AUTH_CREDS EXISTS.
        else  // See if we have a cached proxy user/pass.
        {
            if (pRequest->_pProxyCreds && pRequest->_pProxyCreds->_AuthScheme == WINHTTP_AUTH_SCHEME_BASIC)
            {
                AUTHCTX::SPMData* pSPMData = AUTHCTX::SPMLookup(DwordSchemeToString(pRequest->_pProxyCreds->_AuthScheme));

                    /*
                    reinterpret_cast<AUTHCTX::SPMData*>(New AUTHCTX::SPMData(
                        DwordSchemeToString(pRequest->_pProxyCreds->_AuthScheme), 
                        DwordSchemeToFlags(pRequest->_pProxyCreds->_AuthScheme)));
                    */

                if (pSPMData)
                {
                    AUTH_CREDS *pCreds = AUTHCTX::CreateCreds(pRequest, TRUE,
                                                      pSPMData, pRequest->_pProxyCreds->_pszRealm);
                    if (pCreds)
                    {
                        lpszPass = pRequest->_pProxyCreds->GetPassword();
                        pCreds->SetUser(pRequest->_pProxyCreds->_pszUserName);
                        pCreds->SetPass(lpszPass);

                        AUTHCTX* pNewAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, IS_PROXY, pCreds);
                        if (pNewAuthCtx && pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_BASIC)
                        {
                            AddAuthorizationHeader (pRequest, pNewAuthCtx);
                        }
                        delete pNewAuthCtx;
                        pNewAuthCtx = NULL;
                    }
                }
            }
        }
    }

    if (lpszPass)
    {
        SecureZeroMemory(lpszPass, strlen(lpszPass));
        FREE_MEMORY(lpszPass);
        lpszPass = NULL;
    }

    // SERVER AUTHENTICATION
    //
    // Don't send server authorization when initiating SSL tunneling with proxy.
    if (!pRequest->IsTunnel())
    {
        // if an app sets server creds, we want to make sure that the specified
        // auth scheme is the same as the auth scheme in progress. Otherwise, we
        // will delete the current auth context and build a new one based on the
        // new scheme.

        BOOL fNonePreferredSchemeUsed = FALSE;

        if (pRequest->_pServerCreds 
            && (pAuthCtx && !pAuthCtx->_fIsProxy)
            && (pAuthCtx->GetRawSchemeType() != pRequest->_pServerCreds->_AuthScheme))
        {
            delete pAuthCtx;
            pAuthCtx = NULL;
            pRequest->SetAuthCtx(NULL);

            fNonePreferredSchemeUsed = TRUE;
        }

        // See if we have a server authentication in progress
        if (pAuthCtx && !pAuthCtx->_fIsProxy)
        {
            // Server authentication in progress.

            // If a user/pass set on handle, transfer to AUTH_CREDS.
            // This will invalidate the credentials on the handle they
            // were found for any subsequent calls to GetUserAndPass.

            if (AuthLock())
            {
                if (pRequest->_pServerCreds)
                {
                    lpszPass = pRequest->_pServerCreds->GetPassword();
                    pAuthCtx->_pCreds->SetUser(pRequest->_pServerCreds->_pszUserName);
                    pAuthCtx->_pCreds->SetPass(lpszPass);
                }
                else if (pRequest->GetUserAndPass(IS_SERVER, &lpszUser, &lpszPass))
                {
                    pAuthCtx->_pCreds->SetUser(lpszUser);
                    pAuthCtx->_pCreds->SetPass(lpszPass);
                }

                AuthUnlock();

                // Add the authorization header.
                AddAuthorizationHeader (pRequest, pAuthCtx);
            }
        }
        else  // See if we have a cached server user/pass.
        {
            // NO PROXY AUTHENTICATION CONTEXT -> SEE IF A AUTH_CREDS EXISTS
                
            if (pRequest->_pServerCreds)
            {
                AUTHCTX *pNewAuthCtx = NULL;

                AUTHCTX::SPMData* pSPMData = AUTHCTX::SPMLookup(DwordSchemeToString(pRequest->_pServerCreds->_AuthScheme));

                    /*
                    reinterpret_cast<AUTHCTX::SPMData*>(New AUTHCTX::SPMData(
                        DwordSchemeToString(pRequest->_pServerCreds->_AuthScheme), 
                        DwordSchemeToFlags(pRequest->_pServerCreds->_AuthScheme)));
                    */
                
                INET_ASSERT(pSPMData);

                AUTH_CREDS *pCreds = AUTHCTX::CreateCreds(pRequest, FALSE,
                                                  pSPMData, pRequest->_pServerCreds->_pszRealm,
                                                  pRequest->_pServerCreds);
                if (pCreds)
                {
                    if (pRequest->_pServerCreds->_AuthScheme != WINHTTP_AUTH_SCHEME_PASSPORT)
                    {
                        pNewAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, IS_SERVER, pCreds);
                    }
                    
                    if(pNewAuthCtx)
                    {
                        if (pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_NTLM
                            || pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_NEGOTIATE)
                        {
                            // NTLM or Negotiate (in which case we don't really know the
                            // protocol yet) - create the auth context, set it in the handle
                            // and set state to AUTHSTATE_NEGOTIATE. Handle now has
                            // a valid auth context and is in the correct auth state
                            // for the remainder of the authorization sequence.

                            // It's possible that the Creds entry was created when no proxy
                            // was in use and the user set a proxy. Check that this is
                            // not the case.

                            if (!fNonePreferredSchemeUsed &&

                                (!pRequest->IsMethodBody() 
                                || (pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_NTLM
                                    && pRequest->IsDisableNTLMPreauth())
                                || (pRequest->IsRequestUsingProxy()
                                    && !pRequest->IsTalkingToSecureServerViaProxy())))
                            {
                                // NTLM preauth disabled or over proxy; no preauth.
                                delete pNewAuthCtx;
                                pNewAuthCtx = NULL;
                            }
                            else
                            {
                                // Set the auth context in the handle and
                                // add the auth header.
                                pRequest->SetAuthCtx(pNewAuthCtx);
                                pRequest->SetAuthState(AUTHSTATE_NEGOTIATE);
                                AddAuthorizationHeader (pRequest, pNewAuthCtx);
                                pNewAuthCtx = NULL;
                            }
                        }
                        else
                        {
                            if ((pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_DIGEST && !fCredsChanged)
                                || (pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_BASIC))
                            {
                                pRequest->SetAuthCtx(pNewAuthCtx);
                                AddAuthorizationHeader (pRequest, pNewAuthCtx);
                                pRequest->SetCreds(pNewAuthCtx->_pCreds);
                                pNewAuthCtx = NULL;
                            }
                            //else if (pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_PASSPORT)
                            //{
                            //    pRequest->SetAuthCtx(pNewAuthCtx);
                            //    AddAuthorizationHeader (pRequest, pNewAuthCtx);
                            //    pNewAuthCtx = NULL;
                            //}
                        }

                        if (pNewAuthCtx != NULL)
                        {
                            delete pNewAuthCtx;
                            pNewAuthCtx = NULL;
                        }
                    }
                }
            }
        }
    }

    if (lpszPass)
    {
        SecureZeroMemory(lpszPass, strlen(lpszPass));
        FREE_MEMORY(lpszPass);
        lpszPass = NULL;
    }

    DEBUG_LEAVE(dwError);
    return dwError;
}


/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
DWORD ProcessResponseHeaders
(
    HINTERNET hRequestMapped,
    BOOL fIsProxy
)
{
    DEBUG_ENTER ((DBG_HTTP, Dword, "ProcessResponseHeaders", "%#x", hRequestMapped));

    DWORD dwError = ERROR_SUCCESS;

    // Get context from request handle.
    HTTP_REQUEST_HANDLE_OBJECT *pRequest
        = (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;
    AUTHCTX* pAuthCtx = pRequest->GetAuthCtx();
    BOOL fDoNotSetCreds = FALSE;

    if (pAuthCtx)
    {
        if ((dwError = pAuthCtx->UpdateFromHeaders(pRequest, fIsProxy))
            != ERROR_SUCCESS)
        {
            // Delete the auth context and fail auth 
            // immediately if any other error than
            // scheme has been changed.
            delete pAuthCtx;
            pRequest->SetAuthCtx(NULL);
            if (dwError != ERROR_HTTP_HEADER_NOT_FOUND)
            {
                goto cleanup;
            }

            fDoNotSetCreds = TRUE;

            if (fIsProxy)
            {
                if (pRequest->_pProxyCreds)
                {
                    delete pRequest->_pProxyCreds;
                    pRequest->_pProxyCreds = NULL;
                }
            }
            else
            {
                if (pRequest->_pServerCreds)
                {
                    delete pRequest->_pServerCreds;
                    pRequest->_pServerCreds = NULL;
                }
            }

            pRequest->ClearUserAndPass(fIsProxy);

            // Attempt to create a new auth context using
            // the challenge received from the server.
            // If this fails, we follow logic as commented
            // below.
            pAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, fIsProxy);        
            if (!pAuthCtx)
            {
                dwError = ERROR_SUCCESS;
                goto cleanup;
            }

            pAuthCtx->DisableAutoLogon();
        }
    }
    else
    {
        // CreateAuthCtx returns NULL if auth scheme not
        // supported (fall through from HttpFiltOnResponse
        // in sendreq.cxx) or if scheme is NTLM and the
        // socket is not keep-alive or via proxy.
        // In these cases it is necessary to check for a NULL
        // return value. The correct return code for these cases is
        // ERROR_SUCCESS, which will be returned by AuthOnResponse.
        pAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, fIsProxy);
        if (!pAuthCtx)
        {
            dwError = ERROR_SUCCESS;
            goto cleanup;
        }
    }

    LPSTR lpszUser, lpszPass = NULL;

    // First check for proxy credentials and fallback to server
    // for legacy wininet apps. This will invalidate the credentials
    // on the handle they were found for any subsequent calls to
    // GetUserAndPass.

    // I believe we should be putting the credentials in the
    // password cache at this time. The scenario is that a client
    // sets credentials on a handle, after a successful authentication
    // the Creds will have null credentials. Pre-auth will then pull up
    // credentials for the default user!!!!!!!!!!!
    
        // Serialize access to globals.
    if (AuthLock())
    {
        if (pRequest->_pServerCreds && !fIsProxy)
        {
            lpszUser = pRequest->_pServerCreds->_pszUserName;
            lpszPass = pRequest->_pServerCreds->GetPassword();
        }
        else if (pRequest->_pProxyCreds && fIsProxy)
        {
            lpszUser = pRequest->_pProxyCreds->_pszUserName;
            lpszPass = pRequest->_pProxyCreds->GetPassword();
        }
        else if ((!pRequest->GetUserAndPass(fIsProxy, &lpszUser, &lpszPass)) && fIsProxy)
        {
            pRequest->GetUserAndPass(IS_SERVER, &lpszUser, &lpszPass);
        }

        AuthUnlock();
    }
    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // If we retrieved credentials from the handle set
    // them in the Creds.
    if (lpszUser && lpszPass && !fDoNotSetCreds)
    {
       pAuthCtx->_pCreds->SetUser(lpszUser);
       pAuthCtx->_pCreds->SetPass(lpszPass);
    }

    if (lpszPass)
    {
        SecureZeroMemory(lpszPass, strlen(lpszPass));
        FREE_MEMORY(lpszPass);
        lpszPass = NULL;
    }

    // Post authenticate user.
    dwError = pAuthCtx->PostAuthUser();

    // Map all unexpected error codes to login failure.
    if (dwError != ERROR_WINHTTP_FORCE_RETRY
        && dwError != ERROR_WINHTTP_INCORRECT_PASSWORD)
    {
        dwError = ERROR_WINHTTP_LOGIN_FAILURE;
    }

    pRequest->SetAuthCtx(pAuthCtx);

cleanup:

    DEBUG_LEAVE (dwError);
    return dwError;
}


BOOL IsSameDomain(LPCSTR pszTarget, LPCSTR pszResponse)
{
    LPCSTR pszTargetR = pszTarget + strlen(pszTarget);
    DWORD dwDotsSeen = 0;
    while (--pszTargetR > pszTarget)
    {
        if (*pszTargetR == '.')
        {
            if (++dwDotsSeen == 2)
            {
                break;
            }
        }
    }

    if (dwDotsSeen == 2)
    {
        ++pszTargetR;
        DWORD dwOffsetR = strlen(pszTargetR);
        if (strlen(pszResponse) < dwOffsetR)
        {
            return FALSE;
        }

        LPCSTR pszResponseR = pszResponse + strlen(pszResponse) - dwOffsetR;

        return !strcmp(pszTargetR, pszResponseR);
    }
    else
    {
        return FALSE;
    }
}

VOID CheckForTweenerLogout(HTTP_REQUEST_HANDLE_OBJECT *pRequest)
{
    DWORD dwIndex = 0;
    DWORD dwError;

    do
    {
        LPSTR szData;
        DWORD cbData;
        dwError = pRequest->FastQueryResponseHeader(HTTP_QUERY_AUTHENTICATION_INFO,
                                                    (LPVOID*) &szData,
                                                    &cbData,
                                                    dwIndex);
        if (dwError == ERROR_SUCCESS)
        {
            BOOL fLogout = FALSE;
            CHAR TempChar = szData[cbData];
            szData[cbData] = '\0';

            if (strstr(szData, "Passport1.4") && strstr(szData, "logout"))
            {
                fLogout = TRUE;
            }
            szData[cbData] = TempChar;

            if (fLogout)
            {
                PP_CONTEXT hPP = GetRootHandle(pRequest)->GetPPContext();
                if (hPP != NULL)
                {
                    WCHAR wszDAHost[256];
                    DWORD dwDAHostLen = 256;
                    CHAR szDAHost[256];
                    
                    ::PP_GetEffectiveDAHost(hPP, wszDAHost, &dwDAHostLen);
                    ::WideCharToMultiByte(CP_ACP, 0, wszDAHost, -1, szDAHost, 256, NULL, NULL);
                    
                    if (IsSameDomain(pRequest->GetServerName(), szDAHost))
                    {
                        ::PP_Logout(hPP, 0);
                    }
                }
                
                break;
            }
        }

        ++dwIndex;

    } while (dwError == ERROR_SUCCESS);
}


/*-----------------------------------------------------------------------------

Routine Description:

    Validates, and Caches Authentication Request headers if needed. If a URL matches a
    cached set of templates it is assumed to require specific authentication information.

Arguments:

    hRequest                - An open HTTP request handle
                              where headers will be added if needed.

Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - One of Several Error codes defined in winerror.h or wininet.w

Comments:

    Need to handle mutiple authentication pages.

-----------------------------------------------------------------------------*/
PUBLIC DWORD AuthOnResponse (HINTERNET hRequestMapped)
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AuthOnResponse",
                 "%#x [%#x]",
                 hRequestMapped,
                 ((INTERNET_HANDLE_BASE *)hRequestMapped)->GetPseudoHandle()
                 ));

    // Get URL and password cache entry from request handle.
    HTTP_REQUEST_HANDLE_OBJECT *pRequest =
        (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;

    AUTHCTX *pAuthCtx = pRequest->GetAuthCtx();
    DWORD dwStatus = pRequest->GetStatusCode();

    if (pAuthCtx)
    {
        if (pAuthCtx->_fIsProxy && dwStatus != HTTP_STATUS_PROXY_AUTH_REQ)
        {
            if (dwStatus == HTTP_STATUS_REDIRECT)   // we might need to do Tweener auth
            {
                if (pRequest->_pTweenerProxyCreds)
                {
                    Creds_Free(pRequest->_pTweenerProxyCreds);
                    pRequest->_pTweenerProxyCreds = NULL;
                }                
                pRequest->_pTweenerProxyCreds = pAuthCtx->_pCreds;
                pAuthCtx->_pCreds = NULL;
            }

            // We are done with proxy authentication.
            delete pAuthCtx;
            pRequest->SetAuthCtx (NULL);
            
            if (pRequest->_pProxyCreds)
            {
                delete pRequest->_pProxyCreds;
                pRequest->_pProxyCreds = NULL;
            }

            pRequest->ClearUserAndPass(IS_PROXY);
        }
        else if (!pAuthCtx->_fIsProxy && dwStatus != HTTP_STATUS_DENIED)
        {
			if ((pAuthCtx->GetSchemeType() != WINHTTP_AUTH_SCHEME_PASSPORT) || dwStatus != HTTP_STATUS_REDIRECT)
            {
                // We are done with server authentication.

                if (pAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_PASSPORT)
                {
                    delete [] pRequest->m_lpszRetUrl;
                    pRequest->m_lpszRetUrl = ((PASSPORT_CTX*)pAuthCtx)->m_lpszRetUrl;
                    ((PASSPORT_CTX*)pAuthCtx)->m_lpszRetUrl = NULL;
                }

                delete pAuthCtx;
                pRequest->SetAuthCtx (NULL);

                if (pRequest->_pServerCreds)
                {
                    delete pRequest->_pServerCreds;
                    pRequest->_pServerCreds = NULL;
                }

                pRequest->ClearUserAndPass(IS_SERVER);
            }
			else
            {
                // in the case of Passport Auth, 302 is still not done yet, 
                // but this is quite strange since 302 came a second time
                // biaow-todo: we could be in a loop here
            }
        }
    }

    // Remove any stale authorization headers in case wHttpSendRequest
    // loops, for example, to handle a redirect.  To ignore trailing colon,
    // subtract 1 from header lengths passed to ReplaceRequestHeader.
    pRequest->ReplaceRequestHeader
        (HTTP_QUERY_AUTHORIZATION,
                    "", 0, 0, HTTP_ADDREQ_FLAG_REPLACE);
    pRequest->ReplaceRequestHeader
        (HTTP_QUERY_PROXY_AUTHORIZATION,
            "", 0, 0, HTTP_ADDREQ_FLAG_REPLACE);

    DWORD error;

//
// note: Negotiate MUTUAL_AUTH can return dwStatus = 200 with a final
// WWW-Authenticate blob to process.  logic below could be adjusted
// to ProcessResponseHeaders() in this situation, which allows MUTUAL_AUTH
// to be enforced.
//
    
    switch (dwStatus)
    {
        case HTTP_STATUS_PROXY_AUTH_REQ: // 407
            if (pRequest->IsRequestUsingProxy())
                error = ProcessResponseHeaders(pRequest, IS_PROXY);
            else
                error = ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
            break;

        case HTTP_STATUS_REDIRECT: // 302
            {
                INTERNET_HANDLE_OBJECT * pInternet = GetRootHandle((INTERNET_HANDLE_BASE*)pRequest);
                if (pInternet->TweenerDisabled())
                {
                    // biaow-todo: no passport support for down-levels yet

                    pRequest->SetAuthState(AUTHSTATE_NONE);
                    error = ERROR_SUCCESS;

                    break;
                }
            }
    
            // process the header to see whether this is a 302 passport1.4 challenge

        case HTTP_STATUS_DENIED: // 401

            error = ProcessResponseHeaders(pRequest, IS_SERVER);
            break;

        default:
            pRequest->SetAuthState(AUTHSTATE_NONE);
            error = ERROR_SUCCESS;
    }

    // creds set by WinHttpSetCredentials() is good for one "authentication attempt" only. 
    // Since we are done authentication here, we are deleting it.

    // biaow: detect the "final" failure so that we can delete the creds.
    
    if (pRequest->_pTweenerProxyCreds)
    {
        Creds_Free(pRequest->_pTweenerProxyCreds);
        pRequest->_pTweenerProxyCreds = NULL;
    }
    
    CheckForTweenerLogout(pRequest);
    
    DEBUG_LEAVE(error);
    return error;
}




//-----------------------------------------------------------------------------
//
//
//      AUTHCTX Base class definitions
//
//
//
//      static funcs:
//          InitializeSPMList
//          UnloadAll
//          CreateAuthCtx
//          CreateAuthCtx (using Creds*)
//          GetSPMListState
//          SearchCredsList
//          FindOrCreateCreds
//          GetAuthHeaderData
//
//      base funcs:
//          FindHdrIdxFromScheme
//          GetScheme
//          GetSchemeType - returns enum
//          GetFlags      - returns SPM flags
//          GetState      - returns state of SPM provider
//
//
//      virtual overrides: defined in basic.cxx, plug.cxx and digest.cxx
//          UpdateFromHeaders
//          PreAuthUser
//          PostAuthUser
//
//
//


/*---------------------------------------------------------------------------
AUTHCTX::SPMData constructor
---------------------------------------------------------------------------*/
AUTHCTX::SPMData::SPMData(LPSTR _szScheme, DWORD _dwFlags)
{
    if (_szScheme)
    {
        szScheme = NewString(_szScheme);
        cbScheme = strlen(_szScheme);
    }
    else
    {
        szScheme = NULL;
        cbScheme = 0;
    }

    if (szScheme)
    {
        if (!lstrcmpi(szScheme, "Basic"))
            eScheme = WINHTTP_AUTH_SCHEME_BASIC;
        else if (!lstrcmpi(szScheme, "NTLM"))
            eScheme = WINHTTP_AUTH_SCHEME_NTLM;
        else if (!lstrcmpi(szScheme, "Digest"))
            eScheme = WINHTTP_AUTH_SCHEME_DIGEST;
        else if (!lstrcmpi(szScheme, "Negotiate"))
            eScheme = WINHTTP_AUTH_SCHEME_NEGOTIATE;
        else if (!lstrcmpi(szScheme, "Passport1.4"))
            eScheme = WINHTTP_AUTH_SCHEME_PASSPORT;
        else
            eScheme = 0;

        dwFlags    = _dwFlags;
        eState     = STATE_NOTLOADED;
    }
    else
    {
        dwFlags    = 0;
        eState     = STATE_ERROR;
    }
}

/*---------------------------------------------------------------------------
AUTHCTX::SPMData destructor
---------------------------------------------------------------------------*/
AUTHCTX::SPMData::~SPMData()
{ delete szScheme; }


/*---------------------------------------------------------------------------
AUTHCTX constructor
---------------------------------------------------------------------------*/
AUTHCTX::AUTHCTX(SPMData *pData, AUTH_CREDS *pCreds)
{
    _pSPMData = pData;
    _pCreds = pCreds;
    _pRequest = NULL;
    _fIsProxy = FALSE;
    _pvContext = NULL;
    _eSubScheme = 0;
    _dwSubFlags = 0;

    _fDisableAutoLogon = FALSE;

    _CtxCriSec.Init();
}


/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
AUTHCTX::~AUTHCTX()
{
    if (AuthLock())
    {
        if (_pCreds)
            Creds_Free(_pCreds);
        AuthUnlock();
    }

    _CtxCriSec.FreeLock();
}


// ------------------------  Static Functions ---------------------------------


/*---------------------------------------------------------------------------
    InitializeSPMList
---------------------------------------------------------------------------*/
BOOL AUTHCTX::InitializeSPMList()
{
    BOOL retVal = FALSE;
    
    struct SchemeFlagsPair
    {
        LPSTR pszScheme;
        DWORD Flags;
    };

    SchemeFlagsPair SchemeFlags[] = {
                        {"NTLM", PLUGIN_AUTH_FLAGS_NO_REALM},
                        {"Basic", PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED},
                        {"Digest", PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_CAN_HANDLE_UI},
                        {"Negotiate", PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_NO_REALM},
                        {"Passport1.4",  PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED}
                        };
    
    if( GetSPMListState() == STATE_LOADED)
    {
        retVal = TRUE;
        goto done;
    }

    SPMData   *pNew;
    g_pSPMList = NULL;
    g_eState = STATE_ERROR;

    AssertHaveLock();

    // Hard-wired Basic, NTLM and Digest
    for (DWORD dwIndex = 0; dwIndex < sizeof(SchemeFlags) / sizeof(SchemeFlagsPair); dwIndex++)
    {
        if (!GlobalPlatformVersion5 // we don't support Negotiate on NT4 or Win9x
            && !stricmp(SchemeFlags[dwIndex].pszScheme, "Negotiate"))
        {
            continue;
        }

        pNew = (AUTHCTX::SPMData*) New SPMData(SchemeFlags[dwIndex].pszScheme, SchemeFlags[dwIndex].Flags);
        if (!pNew)
            goto done;

        // Add to head of list.
        if (pNew->eState != STATE_ERROR)
        {
            pNew->pNext = g_pSPMList;
            g_pSPMList = pNew;
        }
    }

    // The list is now in the correct state.
    g_eState = STATE_LOADED;
    retVal = TRUE;

done:
    return retVal;
}


VOID AUTHCTX::UnloadAll()
{

    SPMData *pData = g_pSPMList;
    while (pData)
    {
        SPMData *pNext = pData->pNext;
        delete pData;
        pData = pNext;
    }

    SSPI_Unload();

    g_eState = STATE_NOTLOADED;
    g_pSPMList = NULL;
}

DWORD StringSchemeToDword(LPSTR szScheme)
{
    if (!stricmp(szScheme, "Basic"))
    {
        return WINHTTP_AUTH_SCHEME_BASIC;
    }
    else if (!stricmp(szScheme, "Digest"))
    {
        return WINHTTP_AUTH_SCHEME_DIGEST;
    }
    else if (!stricmp(szScheme, "Passport1.4"))
    {
        return WINHTTP_AUTH_SCHEME_PASSPORT;
    }
    else if (!stricmp(szScheme, "NTLM"))
    {
        return WINHTTP_AUTH_SCHEME_NTLM;
    }
    else if (!stricmp(szScheme, "Negotiate"))
    {
        return WINHTTP_AUTH_SCHEME_NEGOTIATE;
    }
    else
    {
        return 0;
    }
}

/*---------------------------------------------------------------------------
    CreateAuthCtx
    Create an AUTHCTX* from headers - initially the authentication context
    is created without a AUTH_CREDS entry. The AUTH_CREDS entry will be found or created
    and possibly updated in UpdateFromHeaders.
---------------------------------------------------------------------------*/
AUTHCTX* AUTHCTX::CreateAuthCtx(HTTP_REQUEST_HANDLE_OBJECT * pRequest, BOOL fIsProxy)
{
    LPSTR szScheme = NULL;
    DWORD cbScheme = 0, dwError = 0, dwAuthIdx = 0;
    AUTHCTX *pAuthCtx = NULL;
    WINHTTP_REQUEST_CREDENTIALS* pRequestCreds = fIsProxy ? pRequest->_pProxyCreds : pRequest->_pServerCreds;
    
    pRequest->_PreferredScheme = 0;
    pRequest->_SupportedSchemes = 0;
    
    // Get scheme. This is assumed to be the first
    // non-ws token in the auth header info.
    do
    {
        DWORD dwScheme = 0;
        AUTHCTX::SPMData *pSPM = NULL;

        delete [] szScheme;
        szScheme = NULL;

        // It is necessary to hold on to the auth index
        // in this loop because we could have gone through
        // more than one scheme.
        dwError = GetAuthHeaderData(pRequest, fIsProxy, NULL,
            &szScheme, &cbScheme, ALLOCATE_BUFFER | GET_SCHEME, dwAuthIdx++);

        if (dwError != ERROR_SUCCESS)
            goto quit;

        pSPM = SPMLookup(szScheme);

        if (pSPM == NULL)
            continue;
        
        dwScheme = pSPM ? pSPM->eScheme : 0;

        pRequest->_KnowSupportedSchemes = TRUE;
        pRequest->_SupportedSchemes |= dwScheme;
        pRequest->_AuthTarget = fIsProxy ? WINHTTP_AUTH_TARGET_PROXY : WINHTTP_AUTH_TARGET_SERVER;
        
        DEBUG_PRINT(API,
                    INFO,
                    ("CreateAuthCtx(%x) : Auth Target = %x\n",
                    fIsProxy,
                    pRequest->_AuthTarget
                    ));

        if (pRequest->_PreferredScheme == 0)
            pRequest->_PreferredScheme = dwScheme;

        //  If we haven't created an auth context yet, maybe create one.
        if (pAuthCtx == NULL)
        {
            //  If there is a scheme we have credentials for, 
            //only create an auth context for that scheme.
            if (pRequestCreds && pRequestCreds->_AuthScheme == dwScheme)
            {
                AUTH_CREDS* pAuthCreds = AUTHCTX::CreateCreds(pRequest, fIsProxy,
                                                              pSPM, pRequestCreds->_pszRealm,
                                                              pRequestCreds);
                if (pAuthCreds)
                {
                    pAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, fIsProxy, pAuthCreds);
                }
            }
            //  If there isn't a scheme we have credentials for, 
            //create an auth context for the first scheme.
            else if (pRequestCreds == NULL)
            {
                pAuthCtx = CreateAuthCtx(pRequest, fIsProxy, szScheme);
            }

            // If creation of an auth context is successful, update
            // the context from any header info.
            if (pAuthCtx)
            {
                if (pAuthCtx->UpdateFromHeaders(pRequest, fIsProxy) != ERROR_SUCCESS)
                {
                    delete pAuthCtx;
                    pAuthCtx = NULL;
                }
            }
        }
    } while (1);

quit:

    if (szScheme)
        delete szScheme;

    return pAuthCtx;
}

AUTHCTX::SPMData* AUTHCTX::SPMLookup(LPSTR szScheme)
{
    if (!AuthLock())
    {
        return NULL;
    }

    AUTHCTX::SPMData *pSPM = NULL;

    if (!AUTHCTX::InitializeSPMList())
    {
        // not critical, just no authentication
        goto quit;
    }

    pSPM = g_pSPMList;

    // Find SPMData to create from scheme.
    while (pSPM)
    {
        if (!lstrcmpi(pSPM->szScheme, szScheme))
            break;

        pSPM = pSPM->pNext;
    }

quit:
    AuthUnlock();
    return pSPM;
}

/*---------------------------------------------------------------------------
    CreateAuthCtx
    Create an AUTHCTX without a AUTH_CREDS from scheme
---------------------------------------------------------------------------*/
AUTHCTX* AUTHCTX::CreateAuthCtx(HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    BOOL fIsProxy, LPSTR szScheme)
{
    if (!AuthLock())
    {
        return NULL;
    }

    AUTHCTX *pNewAuthCtx = NULL;

    // we don't want to create a Passport1.4 context on 401 response (from DA)
    if (!lstrcmpi("Passport1.4", szScheme))
    {
        if (pRequest->GetStatusCode() == HTTP_STATUS_DENIED)
        {
            goto quit;
        }
    }

    SPMData *pSPM = SPMLookup( szScheme);

    if (!pSPM)
    {
        // No matching auth scheme found.
        // Not critical, just no auth.
        goto quit;
    }

    // Create an auth context without Creds
    switch(pSPM->eScheme)
    {
        // Create BASIC_CTX with NULL AUTH_CREDS.
        case WINHTTP_AUTH_SCHEME_BASIC:
            pNewAuthCtx = New BASIC_CTX(pRequest, fIsProxy, pSPM, NULL);
            break;

        // Create DIGEST_CTX with NULL AUTH_CREDS.
        case WINHTTP_AUTH_SCHEME_DIGEST:
            pNewAuthCtx = New DIGEST_CTX(pRequest, fIsProxy, pSPM, NULL);
            break;

        case WINHTTP_AUTH_SCHEME_PASSPORT:
            pNewAuthCtx = new PASSPORT_CTX(pRequest, fIsProxy, pSPM, NULL);
            if (pNewAuthCtx)
            {
                if (((PASSPORT_CTX*)pNewAuthCtx)->Init() == FALSE)
                {
                    delete pNewAuthCtx;
                    pNewAuthCtx = NULL;
                }
            }
            break;

        // Create PLUG_CTX with NULL AUTH_CREDS.
        case WINHTTP_AUTH_SCHEME_NTLM:
        case WINHTTP_AUTH_SCHEME_NEGOTIATE:

        default:
            pNewAuthCtx = New PLUG_CTX(pRequest, fIsProxy, pSPM, NULL);

    }


quit:
    AuthUnlock();
    return pNewAuthCtx;
}


/*---------------------------------------------------------------------------
    CreateAuthCtx
    Create an AUTHCTX from a AUTH_CREDS.
---------------------------------------------------------------------------*/
AUTHCTX* AUTHCTX::CreateAuthCtx(HTTP_REQUEST_HANDLE_OBJECT *pRequest,
                    BOOL fIsProxy, AUTH_CREDS* pCreds)
{
    if (!AuthLock())
    {
        return NULL;
    }
    
    AUTHCTX *pNewAuthCtx = NULL;

    if (!AUTHCTX::InitializeSPMList())
    {
        // not critical, just no authentication
        goto quit;
    }

    // Handle tests (via proxy, is keep-alive)
    // will be done in UpdateFromHeaders. Here
    // we just construct the AUTHCTX.
    switch(pCreds->pSPM->eScheme)
    {
        // Create BASIC_CTX.
        case WINHTTP_AUTH_SCHEME_BASIC:

            pNewAuthCtx = New BASIC_CTX(pRequest, fIsProxy, pCreds->pSPM, pCreds);
            break;

        // Create DIGEST_CTX.
        case WINHTTP_AUTH_SCHEME_DIGEST:
            pNewAuthCtx = New DIGEST_CTX(pRequest, fIsProxy, pCreds->pSPM, pCreds);
            break;

        case WINHTTP_AUTH_SCHEME_PASSPORT:
            pNewAuthCtx = new PASSPORT_CTX(pRequest, fIsProxy, pCreds->pSPM, pCreds);
            if (pNewAuthCtx)
            {
                if (((PASSPORT_CTX*)pNewAuthCtx)->Init() == FALSE)
                {
                    delete pNewAuthCtx;
                    pNewAuthCtx = NULL;
                }
            }
            break;

        // Create PLUG_CTX.
        case WINHTTP_AUTH_SCHEME_NTLM:
        case WINHTTP_AUTH_SCHEME_NEGOTIATE:

        default:
            pNewAuthCtx = New PLUG_CTX(pRequest, fIsProxy, pCreds->pSPM, pCreds);

    }


quit:
    AuthUnlock();
    return pNewAuthCtx;
}

AUTHCTX::SPMState AUTHCTX::GetSPMListState()
    { return g_eState; }


/*-----------------------------------------------------------------------------
    SearchCredsList
-----------------------------------------------------------------------------*/
//AUTH_CREDS* AUTHCTX::SearchCredsList
//    (AUTH_CREDS* Creds, LPSTR lpszHost, LPSTR lpszUri, LPSTR lpszRealm, SPMData *pSPM)
/*++

Routine Description:
    Scans the Linked List Cache for URLs, Realms, and Servers.  Also allows
    filter fields, to narrow searches.

Arguments:
    Creds                   - Pointer to first item to search from.
    lpszHost              - Host, or Server name to search on.
    lpszUri               - URL to search on.
    lpszRealm             - Security Realm to search on
    lpszScheme            - Authentication scheme to search on.
Return Value:

    AUTH_CREDS *
    Success - Pointer to found item.

    Failure - NULL pointer.

Comments:
    Note: This Legacy code from the SpyGlass IE 1.0 browser

    The AUTH_CREDS lists are searched on every request.  Could optimize by keeping
    a hash value of the server/proxy name.

    If an exact match isn't found on a 401 response, the list is walked again
    to search for a realm match.  Could add a parameter to do both at once.
--*/

/*
{
    AssertHaveLock();

    while (Creds)
    {
        if (   (!pSPM || pSPM == Creds->pSPM)
            && (!lpszHost  || !lstrcmpi(Creds->lpszHost,lpszHost))
            && (!lpszRealm || !lstrcmpi(Creds->lpszRealm,lpszRealm))
            && (!lpszUri   || TemplateMatch (Creds->lpszUrl, lpszUri))
           )
        {

            DEBUG_PRINT(HTTP, INFO, ("Lookup: Found template match [%q]\n",
                Creds->lpszUser));
            return Creds;
        }
        else
        {
            Creds = Creds->pNext;
        }
    }

    return NULL;
}
*/



/*-----------------------------------------------------------------------------
    FindOrCreateCreds
-----------------------------------------------------------------------------*/
AUTH_CREDS* AUTHCTX::CreateCreds(
    HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    BOOL     fIsProxy,
    SPMData *pSPM,
    LPSTR    lpszRealm,
    WINHTTP_REQUEST_CREDENTIALS* pRequestCredentials // defaults to NULL
)
{
    //AssertHaveLock();

    // Create a AUTH_CREDS.
    AUTH_CREDS *Creds;
    Creds = NULL;

    if (!pSPM)
    {
        INET_ASSERT(FALSE);
        goto quit;
    }

    // Get host from request handle.
    LPSTR lpszHost;
    lpszHost = fIsProxy?
        GetProxyName(pRequest) : pRequest->GetServerName();

    // For NTLM, use the hostname analagously to basic realm.
    if (pSPM->eScheme == WINHTTP_AUTH_SCHEME_NTLM || pSPM->eScheme == WINHTTP_AUTH_SCHEME_NEGOTIATE)
    {
        INET_ASSERT (!lpszRealm);
        lpszRealm = lpszHost;
    }

    Creds = Creds_Create (lpszHost, lpszRealm, pSPM);

    if (pRequestCredentials)
    {
        LPSTR lpszPass = pRequestCredentials->GetPassword();

        if( ERROR_SUCCESS != Creds->SetUser(pRequestCredentials->_pszUserName)
            || ERROR_SUCCESS != Creds->SetPass(lpszPass))
        {
            Creds_Free(Creds);
            Creds = NULL;
        }

        if (lpszPass)
        {
            SecureZeroMemory(lpszPass, strlen(lpszPass));
            FREE_MEMORY(lpszPass);
        }
    }

quit:
    
    return Creds;
}

/*-----------------------------------------------------------------------------
    GetAuthHeaderData
-----------------------------------------------------------------------------*/
DWORD AUTHCTX::GetAuthHeaderData(
    HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    BOOL      fIsProxy,
    LPSTR     szItem,
    LPSTR    *pszData,
    LPDWORD   pcbData,
    DWORD     dwFlags,
    DWORD     dwIndex)
{
    LPSTR szData;
    DWORD cbData, cbItem, dwError = ERROR_SUCCESS;;
    CHAR *szTok, *szKey, *szValue;
    DWORD cbTok, cbKey, cbValue;

    szTok = szKey = szValue = NULL;
    cbTok = cbKey = cbValue = NULL;

    cbItem = szItem ? strlen(szItem) : 0;

    DWORD dwQuery = fIsProxy?
        HTTP_QUERY_PROXY_AUTHENTICATE : HTTP_QUERY_WWW_AUTHENTICATE;

    // NULL item passed in means get up to the first \r\n, or
    // possibly only the scheme is desired depending on dwFlags.
    if (!cbItem)
    {
        if ((dwError = pRequest->FastQueryResponseHeader(dwQuery,
            (LPVOID*) &szData,
            &cbData,
            dwIndex)) != ERROR_SUCCESS)
        {
            goto quit;
        }

        // Only the scheme is desired.
        if (dwFlags & GET_SCHEME)
        {
            CHAR* ptr;
            ptr = szValue = szData;
            cbValue = 0;
            while (!(*ptr == ' ' || *ptr == '\t' || *ptr == '\r' || *ptr == '\n'))
            {
                ptr++;
                cbValue++;
            }
        }
        else
        {
            // The entire header is desired.
            szValue = szData;
            cbValue = cbData;
        }

    }
    else
    {
        // An item was passed in - attempt to parse this
        // from the headers and return the corresponding
        // value.
        if ((dwError = pRequest->FastQueryResponseHeader(dwQuery,
                  (LPVOID*) &szData,
                  &cbData,
                  dwIndex)) != ERROR_SUCCESS)
        {
            goto quit;
        }

        // Successfully retrieved header. Parse for the desired item.

        // Point past scheme
        while (!(*szData == ' ' || *szData == '\t' || *szData == '\r' || *szData == '\n'))
        {
            szData++;
            cbData--;
        }

        // Attempt to parse an item of the format 'key = <">value<">'
        // from a comma delmited list of items.
        dwError = ERROR_HTTP_HEADER_NOT_FOUND;
        while (GetDelimitedToken(&szData, &cbData, &szTok, &cbTok, ','))
        {
            if (GetKeyValuePair(szTok, cbTok, &szKey, &cbKey, &szValue, &cbValue))
            {
                if ((cbItem == cbKey) && !strnicmp(szKey, szItem, cbItem))
                {
                    TrimQuotes(&szValue, &cbValue);
                    dwError = ERROR_SUCCESS;
                    break;
                }
            }
        }

    }

    if (dwError == ERROR_SUCCESS)
    {
        // Allocate buffer containing data
        // or return reference.
        if (dwFlags & ALLOCATE_BUFFER)
        {
            *pszData = New CHAR[cbValue+1];
            if (!*pszData)
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
            memcpy(*pszData, szValue, cbValue);
            (*pszData)[cbValue] = '\0';
            *pcbData = cbValue;
        }
        else
        {
            *pszData = szValue;
            *pcbData = cbValue;
        }
    }

quit:

    if (dwError != ERROR_SUCCESS)
    {
        INET_ASSERT(dwIndex || dwError == ERROR_HTTP_HEADER_NOT_FOUND);
    }

    return dwError;
}


// ------------------------  Base class funcs---------------------------------




/*-----------------------------------------------------------------------------
FindHdrIdxFromScheme
-----------------------------------------------------------------------------*/
DWORD AUTHCTX::FindHdrIdxFromScheme(LPDWORD pdwIndex)
{
    LPSTR szHeader;
    DWORD cbHeader, dwQuery, dwError;

    dwQuery = _fIsProxy?
        HTTP_QUERY_PROXY_AUTHENTICATE : HTTP_QUERY_WWW_AUTHENTICATE;

    *pdwIndex = 0;

    while ((dwError = _pRequest->FastQueryResponseHeader(dwQuery,
            (LPVOID*) &szHeader,
            &cbHeader,
            *pdwIndex)) == ERROR_SUCCESS)
    {
        DWORD cb = 0;
        CHAR *ptr = szHeader;
        while (!(*ptr == ' ' || *ptr == '\t' || *ptr == '\r' || *ptr == '\n'))
        {
            ptr++;
            cb++;
        }

        if ((_pSPMData->cbScheme == cb)
            && (!strnicmp(_pSPMData->szScheme, szHeader, cb)))
        {
            break;
        }
        (*pdwIndex)++;
    }
    return dwError;
}

/*-----------------------------------------------------------------------------
    Get funcs.
-----------------------------------------------------------------------------*/
LPSTR AUTHCTX::GetScheme()
    { return _pSPMData->szScheme; }

DWORD AUTHCTX::GetSchemeType()
{
    if (_pSPMData->eScheme == WINHTTP_AUTH_SCHEME_NEGOTIATE)
    {
        if (_eSubScheme == WINHTTP_AUTH_SCHEME_NTLM || _eSubScheme == WINHTTP_AUTH_SCHEME_KERBEROS)
        {
            return _eSubScheme;
        }
    }
    return _pSPMData->eScheme;
}

DWORD AUTHCTX::GetRawSchemeType()
{
    return _pSPMData->eScheme;
}

DWORD AUTHCTX::GetFlags()
{
    if (_pSPMData->eScheme == WINHTTP_AUTH_SCHEME_NEGOTIATE)
    {
        if (_eSubScheme == WINHTTP_AUTH_SCHEME_NTLM || _eSubScheme == WINHTTP_AUTH_SCHEME_KERBEROS)
        {
            return _dwSubFlags;
        }
    }
    return _pSPMData->dwFlags;
}

AUTHCTX::SPMState AUTHCTX::GetState()
    { return _pSPMData->eState; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\debug.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file contains debugging macros for the DHCP server.

Author:

    Manny Weiser  (mannyw)  10-Oct-1992

Environment:

    User Mode - Win32

Revision History:

    Madan Appiah (madana)  21-Oct-1993

--*/

#if DBG

//
// Critical debug output flags.
//

#define DEBUG_ERRORS                0x00000001
#define DEBUG_PROTOCOL              0x00000002
#define DEBUG_LEASE                 0x00000004
#define DEBUG_MISC                  0x00000008
#define DEBUG_INIT                  0x00000010
#define DEBUG_TIMESTAMP             0x00000020
#define DEBUG_ASSERT                0x00001000
#define DEBUG_TRACK                 0x00002000
//
// more verbose debug output flags.
//

#define DEBUG_PROTOCOL_DUMP         0x00010000
#define DEBUG_STACK                 0x00020000
#define DEBUG_TCP_INFO              0x00040000
#define DEBUG_DNS                   0x00080000

#define DEBUG_BACKDOOR              0x01000000
#define DEBUG_ALLOC                 0x02000000
#define DEBUG_PERF                  0x04000000
#define DEBUG_TRACE                 0x08000000

#define DEBUG_API                   0x10000000
#define DEBUG_OPTIONS               0x20000000
#define DEBUG_BREAK_POINT           0x40000000
#define DEBUG_TRACE_CALLS           0x80000000

#endif DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\cscpsite.cpp ===
#include <wininetp.h>
#include <cscpsite.h>
#include <objsafe.h>
#include "jsproxy.h"
#include "utils.h"


/*******************************************************************************
*    CScriptSite Functions
********************************************************************************/
CScriptSite::CScriptSite(CAutoProxy * pAutoProxy)
{
    m_refCount = 1;
    m_pios = NULL;
    m_pasp = NULL; 
    m_pScriptDispatch = NULL;
    m_Scriptdispid = -1;
    m_punkJSProxy = NULL;
    m_fInitialized = FALSE;
    m_dwScriptStartTime = 0;
    m_pAutoProxy = pAutoProxy;
}
CScriptSite::~CScriptSite()
{
    if (m_fInitialized)
        DeInit();
}

STDMETHODIMP CScriptSite::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    if (riid == IID_IUnknown)
    {            
        *ppvObject = (LPVOID)(LPUNKNOWN)static_cast<IActiveScriptSite *>(this);
    }
    else if (riid == IID_IActiveScriptSite)
    {
        *ppvObject = (LPVOID)static_cast<IActiveScriptSite *>(this);
    }
    else if (riid == IID_IServiceProvider)
    {
        *ppvObject = (LPVOID)static_cast<IServiceProvider *>(this);
    }
    else if (riid == IID_IInternetHostSecurityManager)
    {
        *ppvObject = (LPVOID)static_cast<IInternetHostSecurityManager *>(this);
    }
    else if (riid == IID_IActiveScriptSiteInterruptPoll)
    {
        *ppvObject = (LPVOID)static_cast<IActiveScriptSiteInterruptPoll *>(this);
    }
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDMETHODIMP CScriptSite::Init(AUTO_PROXY_HELPER_APIS* pAPHA, LPCSTR szScript)
{
    CHAR szClassId[64];    
    CLSID clsid;
    HRESULT hr = S_OK;
    BSTR    bstrClsID = NULL;
    BSTR    bstrScriptText = NULL;
    OLECHAR *    rgwszNames[1] = {L"FindProxyForURL"};
    EXCEPINFO    exceptinfo;
    IObjectSafety * pIObjSafety = NULL;

    // pAPHA can be null - it is checked in the autoproxy object!
    if (!szScript)
        return E_POINTER;

    if (m_fInitialized)
        return hr;
    // CoCreateInstance the JScript engine.

    if(!DelayLoad(&g_moduleOle32)
       || !DelayLoad(&g_moduleOleAut32))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Get the class id of the desired language engine
    hr = GetScriptEngineClassIDFromName(
        "JavaScript",
        szClassId,
        sizeof(szClassId)
        );
    if (FAILED(hr)) {
        return E_FAIL;
    }
    //convert CLSID string to clsid

    bstrClsID = BSTRFROMANSI(szClassId);
    if (!bstrClsID)
        goto exit;
    hr = DL(CLSIDFromString)(bstrClsID, &clsid);
    DL(SysFreeString)(bstrClsID);
    if (FAILED(hr))
        goto exit;

    // Instantiate the script engine
    hr = DL(CoCreateInstance)(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void**)&m_pios);
    if (FAILED(hr))
        goto exit;

    // Get the IActiveScriptParse interface, if any
    hr = m_pios->QueryInterface(IID_IActiveScriptParse, (void**) &m_pasp);
    if (FAILED(hr))
        goto exit;

    hr = m_pasp->InitNew();
    if (FAILED(hr))
        goto exit;

    // SetScriptSite to this
    hr = m_pios->SetScriptSite((IActiveScriptSite *)this);
    if (FAILED(hr))
        goto exit;
    hr = m_pios->SetScriptState(SCRIPTSTATE_INITIALIZED);

    //
    // Inform the script engine that this host implements
    // the IInternetHostSecurityManager interface, which
    // is used to prevent the script code from using any
    // ActiveX objects.
    //
    hr = m_pios->QueryInterface(IID_IObjectSafety, (void **)&pIObjSafety);

    if (SUCCEEDED(hr) && (pIObjSafety != NULL))
    {
        pIObjSafety->SetInterfaceSafetyOptions(IID_NULL, 
                INTERFACE_USES_SECURITY_MANAGER,
                INTERFACE_USES_SECURITY_MANAGER);

        pIObjSafety->Release();
        pIObjSafety = NULL;
    }

    // AddNamedItem for pUnk and set m_punkJSProxy to pUnk.
    // If we added JSProxy to the name space the store away the JSProxy objects punk.
    m_punkJSProxy = new CJSProxy;
    if( !m_punkJSProxy )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    m_punkJSProxy->Init(pAPHA);
    hr = m_pios->AddNamedItem(L"JSProxy",SCRIPTITEM_ISVISIBLE | SCRIPTITEM_GLOBALMEMBERS);
    if (FAILED(hr))
        goto exit;
    
    // Convert the ANSI script text to a bstr.
    bstrScriptText = BSTRFROMANSI(szScript);
    if (!bstrScriptText)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    // Add the script text to the parser
    hr = m_pasp->ParseScriptText(
             bstrScriptText,
             NULL,
             NULL,
             NULL,
             0,
             0,
             SCRIPTTEXT_ISEXPRESSION|SCRIPTTEXT_ISVISIBLE,
             NULL,
             &exceptinfo);
    
    DL(SysFreeString)(bstrScriptText);
    if (FAILED(hr))
        goto exit;

    m_dwScriptStartTime = GetTickCount();

    hr = m_pios->SetScriptState(SCRIPTSTATE_STARTED);
    if (FAILED(hr))
        goto exit;
    // Now get the script dispatch and find the DISPID for the method just added.  since this is a single use dll
    // I can do this otherwise this would be bad.
    hr = m_pios->GetScriptDispatch(NULL,&m_pScriptDispatch);
    if (FAILED(hr))
        goto exit;
    hr = m_pScriptDispatch->GetIDsOfNames(IID_NULL,rgwszNames,1,LOCALE_SYSTEM_DEFAULT,&m_Scriptdispid);
    if (FAILED(hr))
        goto exit;

    m_fInitialized = TRUE;

    return hr;

exit: // we come here if something fails  -  release everything and set to null.
    if (m_pasp)
        m_pasp->Release();
    if (m_pScriptDispatch)
        m_pScriptDispatch->Release();
    if (m_pios)
    {
        m_pios->Close();
        m_pios->Release();
    }
    if (m_punkJSProxy)
        m_punkJSProxy->Release();
    m_pios = NULL;
    m_pasp = NULL;
    m_pScriptDispatch = NULL;
    m_Scriptdispid = -1;
    m_punkJSProxy = NULL;
    
    return hr;
}

STDMETHODIMP CScriptSite::DeInit()
{
    HRESULT hr = S_OK;

    if (m_pasp)
        m_pasp->Release();

    if (m_pScriptDispatch)
        m_pScriptDispatch->Release();

    if (m_pios)
    {
        hr = m_pios->Close();
        m_pios->Release();
    }

    if (m_punkJSProxy)
        m_punkJSProxy->Release();

    m_pios = NULL;
    m_pasp = NULL;
    m_pScriptDispatch = NULL;
    m_Scriptdispid = -1;
    m_fInitialized = FALSE;

    return hr;
}

STDMETHODIMP CScriptSite::RunScript(LPCSTR szURL, LPCSTR szHost, LPSTR* result)
{
    HRESULT        hr = S_OK;
    UINT        puArgErr = 0;
    EXCEPINFO    excep;
    VARIANT        varresult;
    DISPPARAMS    dispparams;
    VARIANT        args[2]; // We always call with 2 args!

    
    if (!szURL || !szHost || !result)
        return E_POINTER;

    if (!m_fInitialized)
        return E_UNEXPECTED;
        
    DL(VariantInit)(&varresult);

    *result = NULL;

    dispparams.cArgs = 2;
    DL(VariantInit)(&args[0]);
    DL(VariantInit)(&args[1]);

    args[0].vt = VT_BSTR;
    args[1].vt = VT_BSTR;

    args[0].bstrVal = BSTRFROMANSI(szHost);
    args[1].bstrVal = BSTRFROMANSI(szURL);

    if (args[0].bstrVal==NULL || args[1].bstrVal==NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    dispparams.rgvarg = args;

    dispparams.cNamedArgs = 0;    
    dispparams.rgdispidNamedArgs = NULL; 

    // Call invoke on the stored dispid
    hr = m_pScriptDispatch->Invoke(m_Scriptdispid,
                    IID_NULL,LOCALE_SYSTEM_DEFAULT,
                    DISPATCH_METHOD,
                    &dispparams,
                    &varresult,
                    &excep,
                    &puArgErr);

    if (FAILED(hr))
        goto Cleanup;

    // convert result into bstr and return ansi version of the string!
    if (varresult.vt == VT_BSTR)
    {
        MAKE_ANSIPTR_FROMWIDE(rescpy, varresult.bstrVal);
        *result = (LPSTR) GlobalAlloc(GPTR|GMEM_ZEROINIT,lstrlen(rescpy)+1);
        if (!*result)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        lstrcpy(*result,rescpy);

    }
    else
    {
        VARIANT    resvar;

        DL(VariantInit)(&resvar);
        hr = DL(VariantChangeType)(&resvar,&varresult,NULL,VT_BSTR);
        if (SUCCEEDED(hr))
        {
            MAKE_ANSIPTR_FROMWIDE(rescpy, resvar.bstrVal);
            *result = (LPSTR) GlobalAlloc(GPTR|GMEM_ZEROINIT,lstrlen(rescpy)+1);
            if (!*result)
            {
                hr = E_OUTOFMEMORY;
                DL(VariantClear)(&resvar);
                goto Cleanup;
            }
            lstrcpy(*result,rescpy);
        }
        else
            *result = NULL;
        DL(VariantClear)(&resvar);
    }

Cleanup:
    DL(VariantClear)(&varresult);
    DL(VariantClear)(&args[0]);
    DL(VariantClear)(&args[1]);
    
    return hr;
}

STDMETHODIMP CScriptSite::GetLCID(LCID *plcid)
{
    UNREFERENCED_PARAMETER(plcid);
    return E_NOTIMPL;
}
STDMETHODIMP CScriptSite::GetItemInfo(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown **ppunkItem, ITypeInfo **ppTypeInfo)
{
    UNREFERENCED_PARAMETER(ppTypeInfo);
    if (!pstrName || !ppunkItem)
        return E_POINTER;

    if ((StrCmpW(L"JSProxy",pstrName) == 0) && (dwReturnMask == SCRIPTINFO_IUNKNOWN))
    {
        *ppunkItem = (LPUNKNOWN)(IDispatch*)(CJSProxy*)m_punkJSProxy;
        (*ppunkItem)->AddRef();
        return S_OK;
    }
    else
        return TYPE_E_ELEMENTNOTFOUND;
}
STDMETHODIMP CScriptSite::GetDocVersionString(BSTR *pstrVersionString)
{
    UNREFERENCED_PARAMETER(pstrVersionString);
    return E_NOTIMPL;
}

// I am not interested it the transitioning of state or the status of where we are in
// the executing of the script.
STDMETHODIMP CScriptSite::OnScriptTerminate(const VARIANT *pvarResult,const EXCEPINFO *pexcepinfo)
{
    UNREFERENCED_PARAMETER(pvarResult);
    UNREFERENCED_PARAMETER(pexcepinfo);
    return S_OK;
}
STDMETHODIMP CScriptSite::OnStateChange(SCRIPTSTATE ssScriptState)
{
     UNREFERENCED_PARAMETER(ssScriptState);
     return S_OK;
}
STDMETHODIMP CScriptSite::OnScriptError(IActiveScriptError *pase)
{
     UNREFERENCED_PARAMETER(pase);
     return S_OK;
}
STDMETHODIMP CScriptSite::OnEnterScript()
{
    return S_OK;
}
STDMETHODIMP CScriptSite::OnLeaveScript()
{
    return S_OK;
}

//
// IServiceProvider
//
//      Implemented to help wire up the script engine with our
//      IInternetHostSecurityManager interface.
//

STDMETHODIMP CScriptSite::QueryService(
    REFGUID guidService,
    REFIID  riid,
    void ** ppvObject)
{
    if (guidService == SID_SInternetHostSecurityManager)
    {
        return QueryInterface(riid, ppvObject);
    }
    else
    {
        return E_NOINTERFACE;
    }
}


//
// IActiveScriptSiteInterruptPoll
//
STDMETHODIMP CScriptSite::QueryContinue(void)
{
    if (m_pAutoProxy->IsSessionAborted())
        return E_ABORT;
    
    if (GetTickCount() > (m_dwScriptStartTime + MAX_PAC_SCRIPT_RUN_TIMEOUT))
        return E_ABORT;

    return NOERROR;
}

//
// IInternetHostSecurityManager
// 
//      Implemented to prevent the script code from using ActiveX objects.
//

STDMETHODIMP CScriptSite::GetSecurityId( 
    BYTE *      pbSecurityId,
    DWORD *     pcbSecurityId,
    DWORD_PTR   dwReserved)
{
    UNREFERENCED_PARAMETER(pbSecurityId);
    UNREFERENCED_PARAMETER(pcbSecurityId);
    UNREFERENCED_PARAMETER(dwReserved);

    return E_NOTIMPL;
}


STDMETHODIMP CScriptSite::ProcessUrlAction( 
    DWORD   dwAction,
    BYTE *  pPolicy,
    DWORD   cbPolicy,
    BYTE *  pContext,
    DWORD   cbContext,
    DWORD   dwFlags,
    DWORD   dwReserved)
{
    UNREFERENCED_PARAMETER(dwAction);
    UNREFERENCED_PARAMETER(pContext);
    UNREFERENCED_PARAMETER(cbContext);
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(dwReserved);

    //
    // Deny the script any capabilites. In particular, this
    // will disallow the script code from instantiating 
    // ActiveX objects.
    //

    if (cbPolicy == sizeof(DWORD))
    {
        *(DWORD *)pPolicy = URLPOLICY_DISALLOW;
    }

    return S_FALSE; // S_FALSE means the policy != URLPOLICY_ALLOW.
}


STDMETHODIMP CScriptSite::QueryCustomPolicy( 
    REFGUID guidKey,
    BYTE ** ppPolicy,
    DWORD * pcbPolicy,
    BYTE *  pContext,
    DWORD   cbContext,
    DWORD   dwReserved)
{
    UNREFERENCED_PARAMETER(guidKey);
    UNREFERENCED_PARAMETER(ppPolicy);
    UNREFERENCED_PARAMETER(pcbPolicy);
    UNREFERENCED_PARAMETER(pContext);
    UNREFERENCED_PARAMETER(cbContext);
    UNREFERENCED_PARAMETER(dwReserved);

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\dhcpcli.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpcli.h

Abstract:

    This file is the central include file for the DHCP client service.

Author:

    Manny Weiser  (mannyw)  20-Oct-1992

Environment:

    User Mode - Win32

Revision History:

    Madan Appiah (madana)  21-Oct-1993

--*/

#ifndef _DHCPCLI_H_
#define _DHCPCLI_H_

//
//  NT public header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef VXD
#define WIN32_LEAN_AND_MEAN         // Don't include extraneous headers
#endif

#include <windows.h>                // (spec. winsock.h)
#include <winsock.h>

//
//  DHCP public header files
//

#include <dhcp.h>
#include <dhcplib.h>
#if !defined(VXD)
#include <dhcpcapi.h>
#endif

//
// C Runtime Lib.
//

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

//
//  Local header files
//

#include <dhcpdef.h>
#include <debug.h>
#include <gmacros.h>

#ifdef VXD
#include <vxdmsg.h>
#else
#include <dhcpmsg.h>
#endif

#if     defined(_PNP_POWER_)
#include <ipexport.h>
#ifndef VXD
#include <ntddip.h>
#endif
#endif _PNP_POWER_

#include <proto.h>


#ifdef VXD
#include <vxdprocs.h>
#endif


//
// debug heap
//
#include <heapx.h>

#ifndef VXD
#ifdef DBG
#ifdef __DHCP_USE_DEBUG_HEAP__

#pragma message ( "*** DHCP Client will use debug heap ***" )

#define DhcpAllocateMemory(x) ALLOCATE_ZERO_MEMORY(x)
#define DhcpFreeMemory(x)     FREE_MEMORY(x)

#endif
#endif
#endif

#ifdef CHICAGO
#define _WINNT_
#include <vmm.h>
#endif  // CHICAGO
//
// Macros for pageable code.
//
#define CTEMakePageable( _Page, _Routine )  \
    alloc_text(_Page,_Routine)

#ifdef CHICAGO
#define ALLOC_PRAGMA
#undef  INIT
#define INIT _ITEXT
#undef  PAGE
#define PAGE _PTEXT
#define PAGEDHCP _PTEXT
#endif // CHICAGO

#if     defined(CHICAGO) && defined(DEBUG)
//
// This is asserts when the pageable code is called at inappropriate time.
// Since in reality all our pageable code is dynamically locked, there is no
// need for this.
//
//#define CTEPagedCode() _Debug_Flags_Service(DFS_TEST_REENTER+DFS_TEST_BLOCK)
#define CTEPagedCode()
#else
#define CTEPagedCode()
#endif

#include <options.h>
#include <optreg.h>
#include <stack.h>

#endif //_DHCPCLI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\apsvcc.cpp ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    apsvcc.cpp

Abstract:

    Implements the client side L-RPC functions for the Auto-Proxy Service.

Author:

    Biao Wang (biaow) 10-May-2002

--*/

#include "wininetp.h"
#include "apsvc.h"
#include "..\apsvc\apsvcdefs.h"

SC_HANDLE g_hSCM = NULL;
SC_HANDLE g_hAPSvc = NULL;

BOOL      g_fIsAPSvcAvailable = FALSE;
DWORD     g_dwAPSvcIdleTimeStamp;

#define ESTIMATED_SVC_IDLE_TIMEOUT_IN_SECONDS (((AUTOPROXY_SVC_IDLE_TIMEOUT * 60) * 2) / 3)

BOOL ConnectToAutoProxyService(VOID);

// Return TRUE if the WinHttp Autoproxy Service is available on
// the current platform.
BOOL IsAutoProxyServiceAvailable()
{
    if (!GlobalPlatformDotNet)
    {
        return FALSE;
    }

    BOOL fRet = FALSE;

    if (g_fIsAPSvcAvailable && 
        ((::GetTickCount() - g_dwAPSvcIdleTimeStamp) < ESTIMATED_SVC_IDLE_TIMEOUT_IN_SECONDS * 1000))
    {
        // the svc is marked "loaded" AND we are within the svc idle timtout period, so
        // the svc is likey still up & running
        fRet = TRUE;
    }
    else
    {
        g_fIsAPSvcAvailable = FALSE;    // assume the svc is stopped

        fRet = ConnectToAutoProxyService();        
    }

    return fRet;
}

DWORD OutProcGetProxyForUrl(
    INTERNET_HANDLE_OBJECT*     pSession,
    LPCWSTR                     lpcwszUrl,
    WINHTTP_AUTOPROXY_OPTIONS * pAutoProxyOptions,
    WINHTTP_PROXY_INFO *        pProxyInfo
    )
{
    DWORD dwError = ERROR_SUCCESS;
    RPC_STATUS RpcStatus;
    RPC_ASYNC_STATE Async;

    Async.u.hEvent = NULL;

    if (pSession->_hAPBinding == NULL)
    {
        GeneralInitCritSec.Lock();  // make sure one thread initialize the per-session L-RPC binding handle at a time
        
        if (pSession->_hAPBinding == NULL)
        {
            LPWSTR pwszBindingString;
            RpcStatus = ::RpcStringBindingComposeW(NULL,
                                                AUTOPROXY_L_RPC_PROTOCOL_SEQUENCE,
                                                NULL,    // this is a L-RPC service
                                                NULL,    // end-point (we are using dynamic endpoints, so this is NULL)
                                                NULL,
                                                &pwszBindingString);
            if (RpcStatus != RPC_S_OK)
            {
                dwError = ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR;
                GeneralInitCritSec.Unlock();
                goto exit;
            }

            INET_ASSERT(pwszBindingString != NULL);

            RpcStatus = ::RpcBindingFromStringBindingW(pwszBindingString,
                                                    &pSession->_hAPBinding);

            ::RpcStringFreeW(&pwszBindingString);
                                                        
            if (RpcStatus != RPC_S_OK)
            {
                dwError = ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR;
                GeneralInitCritSec.Unlock();
                goto exit;
            }
        }

        GeneralInitCritSec.Unlock();
    }

    INET_ASSERT(pSession->_hAPBinding != NULL);

    RPC_SECURITY_QOS SecQos;
    DWORD dwAuthnSvc;
    DWORD dwAuthnLevel;
    SecQos.Version = RPC_C_SECURITY_QOS_VERSION;
    SecQos.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
    SecQos.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC; // id don't change per session

    if (pAutoProxyOptions->fAutoLogonIfChallenged)
    {
        SecQos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
        dwAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
        dwAuthnSvc = RPC_C_AUTHN_WINNT;
    }
    else
    {
        SecQos.ImpersonationType = RPC_C_IMP_LEVEL_ANONYMOUS;
        dwAuthnLevel = RPC_C_AUTHN_LEVEL_NONE;
        dwAuthnSvc = RPC_C_AUTHN_NONE;
    }

    RpcStatus = ::RpcBindingSetAuthInfoExW(pSession->_hAPBinding,
                                           NULL, // only needed by kerberos; but we are L-PRC
                                           dwAuthnLevel,
                                           dwAuthnSvc,
                                           NULL,
                                           0,
                                           &SecQos);

    if (RpcStatus != RPC_S_OK)
    {
        dwError = ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR;
        goto exit;
    }

    RpcStatus = ::RpcAsyncInitializeHandle(&Async, sizeof(RPC_ASYNC_STATE));
    if (RpcStatus != RPC_S_OK)
    {
        dwError = ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR;
        goto exit;
    }

    Async.UserInfo = NULL;
    Async.NotificationType = RpcNotificationTypeEvent;
    
    Async.u.hEvent = CreateEvent(NULL, 
                                 FALSE, // auto reset
                                 FALSE, // not initially set
                                 NULL);
    if (Async.u.hEvent == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    pAutoProxyOptions->lpvReserved = NULL;

    pProxyInfo->dwAccessType = 0;
    pProxyInfo->lpszProxy = NULL;
    pProxyInfo->lpszProxyBypass = NULL;

    SESSION_OPTIONS Timeouts;
    DWORD dwTimeout;
    pSession->GetTimeout(WINHTTP_OPTION_RESOLVE_TIMEOUT, (LPDWORD)&Timeouts.nResolveTimeout);
    pSession->GetTimeout(WINHTTP_OPTION_CONNECT_TIMEOUT, (LPDWORD)&Timeouts.nConnectTimeout);
    pSession->GetTimeout(WINHTTP_OPTION_CONNECT_RETRIES, (LPDWORD)&Timeouts.nConnectRetries);
    pSession->GetTimeout(WINHTTP_OPTION_SEND_TIMEOUT,    (LPDWORD)&Timeouts.nSendTimeout);
    pSession->GetTimeout(WINHTTP_OPTION_RECEIVE_TIMEOUT, (LPDWORD)&Timeouts.nReceiveTimeout);

    RpcTryExcept
    {
        // ClientGetProxyForUrl is the MIDL-generated client stub function; the server stub 
        // is called GetProxyForUrl. Since both RPC client & server stub is in the same DLL,
        // we used the -prefix MIDL switch to prepend "Client" to the client stub to avoid
        // name collisions

        ClientGetProxyForUrl(&Async,
                             pSession->_hAPBinding,
                             lpcwszUrl,
                             (P_AUTOPROXY_OPTIONS)pAutoProxyOptions,
                             &Timeouts,
                             (P_AUTOPROXY_RESULT)pProxyInfo,
                             &dwError);
    }
    RpcExcept(1)
    {
        if (::RpcExceptionCode() == EPT_S_NOT_REGISTERED)
        {
            // we thought the svc is available because the idle timeout hasn't expired yet but
            // we got an exception here saying the L-RPC endpoint isn't available. So someone
            // much have stopped the service manually.

            g_fIsAPSvcAvailable = FALSE;
        }

        dwError = ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR;
        goto exit;
    }
    RpcEndExcept

    if ((Timeouts.nResolveTimeout == INFINITE) || 
        (Timeouts.nConnectTimeout == INFINITE) || 
        (Timeouts.nSendTimeout    == INFINITE) || 
        (Timeouts.nReceiveTimeout == INFINITE))
    {
        dwTimeout = INFINITE;
    }
    else
    {
        dwTimeout = Timeouts.nResolveTimeout +
                    Timeouts.nConnectTimeout +
                    Timeouts.nSendTimeout    +
                    Timeouts.nReceiveTimeout;
    }

    DWORD dwWaitResult;
    DWORD dwWaitTime = 0;

    // we are going to wait for the result. But we won't wait for it more than half a sec.
    // at a time, so that app can cancel this API call. the minimum wait is half a sec. Also
    // we won't wait longer than the app specified time-out.

    if (dwTimeout < 500)
    {
        dwTimeout = 500;
    }

    do
    {
        dwWaitResult = ::WaitForSingleObject(Async.u.hEvent, 500);
        if (dwWaitResult == WAIT_OBJECT_0)
        {
            break;
        }

        if (pSession->IsInvalidated())
        {
            dwError = ERROR_WINHTTP_OPERATION_CANCELLED;
            break;
        }

        dwWaitTime += 500;

    } while (dwWaitTime < dwTimeout);

    if (dwWaitResult != WAIT_OBJECT_0)
    {
        (void)::RpcAsyncCancelCall(&Async, TRUE); // cancel immediately
        dwError = ERROR_WINHTTP_TIMEOUT;
        goto exit;
    }

    // result has come back

    BOOL fRet;
    RpcStatus = ::RpcAsyncCompleteCall(&Async, &fRet);
    if (RpcStatus != RPC_S_OK)
    {
        dwError = ((RpcStatus == RPC_S_CALL_CANCELLED) ? ERROR_WINHTTP_OPERATION_CANCELLED : ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR);
        goto exit;
    }

    if (fRet == FALSE)
    {
        // dwError should be updated by the RPC call itself
        goto exit;
    }

exit:

    if (Async.u.hEvent)
    {
        ::CloseHandle(Async.u.hEvent);
    }

    return dwError;
}


VOID AutoProxySvcDetach(VOID)
{
    if (g_hAPSvc)
    {
        ::CloseServiceHandle(g_hAPSvc);
        g_hAPSvc = NULL;
    }

    if (g_hSCM)
    {
        ::CloseServiceHandle(g_hSCM);
        g_hSCM = NULL;
    }

}

BOOL ConnectToAutoProxyService(VOID)
{
    // this function is not thread safe, caller must assure only one thread can call
    // this function at a time.

    if (g_hAPSvc == NULL)
    {
        GeneralInitCritSec.Lock();
        
        if (g_hAPSvc == NULL)
        {
            if (g_hSCM == NULL)
            {
                g_hSCM = ::OpenSCManagerW(NULL, // Local Computer for L-RPC accesss
                                        NULL, // default SCM DB
                                        SC_MANAGER_CONNECT);

                if (g_hSCM == NULL)
                {
                    GeneralInitCritSec.Unlock();
                    return FALSE;
                }
            }

            g_hAPSvc = ::OpenServiceW(g_hSCM,
                                    WINHTTP_AUTOPROXY_SERVICE_NAME,
                                    SERVICE_START | 
                                    SERVICE_QUERY_STATUS | 
                                    SERVICE_INTERROGATE);

            if (g_hAPSvc == NULL)
            {
                GeneralInitCritSec.Unlock();
                return FALSE;
            }
        }

        GeneralInitCritSec.Unlock();
    }

    INET_ASSERT(g_hAPSvc != NULL);

    BOOL fRet = FALSE;

    GeneralInitCritSec.Lock(); // one thread to init at a time

    if (!g_fIsAPSvcAvailable)
    {
        SERVICE_STATUS SvcStatus;
        if (::QueryServiceStatus(g_hAPSvc, &SvcStatus) == FALSE)
        {
            goto exit;
        }

        if (SvcStatus.dwCurrentState == SERVICE_RUNNING || 
            SvcStatus.dwCurrentState == SERVICE_STOP_PENDING    // there is a possibility that the service failed to shutdown gracefully
                                                                // and it's stucked in the STOP_PENDING state. In that case, however, the
                                                                // L-RPC service will continue be available
            )
        {
            g_dwAPSvcIdleTimeStamp = ::GetTickCount();
            g_fIsAPSvcAvailable = TRUE;
            
            fRet = TRUE;
            goto exit;
        }

        if (SvcStatus.dwCurrentState == SERVICE_STOPPED)
        {
            if (::StartServiceW(g_hAPSvc, 0, NULL) == FALSE)
            {
                DWORD dwError = ::GetLastError();
                if (dwError == ERROR_SERVICE_ALREADY_RUNNING)
                {
                    g_dwAPSvcIdleTimeStamp = ::GetTickCount();
                    g_fIsAPSvcAvailable = TRUE;

                    fRet = TRUE;
                }
                
                goto exit;
            }
        }
        else if (SvcStatus.dwCurrentState != SERVICE_START_PENDING)
        {
            goto exit;
        } 

        // at this point either 1) WinHttp.dll is starting the Svc, or 2
        // the SVC is being started otuside WinHttp.dll (e.g. admin starting it using SCM)
        // either case we just need to wait for the Svc to run

        // the code below is based on an MSDN sample

        //wait for service to complete init
        if (::QueryServiceStatus(g_hAPSvc, &SvcStatus) == FALSE)
        {
            goto exit;
        }
     
        // Save the tick count and initial checkpoint.
        DWORD dwStartTickCount = GetTickCount();
        DWORD dwOldCheckPoint = SvcStatus.dwCheckPoint;

        while (SvcStatus.dwCurrentState == SERVICE_START_PENDING) 
        { 
            // Do not wait longer than the wait hint. A good interval is 
            // one tenth the wait hint, but no less than 1 second and no 
            // more than 10 seconds. 
     
            //DWORD dwWaitTime = SvcStatus.dwWaitHint / 10;

            //if (dwWaitTime < 1000)
            //    dwWaitTime = 1000;
            //else if (dwWaitTime > 10000)
            //    dwWaitTime = 10000;

            Sleep(250);

            if (::QueryServiceStatus(g_hAPSvc, &SvcStatus) == FALSE)
            {
                goto exit;
            }
     
            if (SvcStatus.dwCheckPoint > dwOldCheckPoint)
            {
                // The service is making progress.
                dwStartTickCount = GetTickCount();
                dwOldCheckPoint = SvcStatus.dwCheckPoint;
            }
            else
            {
                if(GetTickCount() - dwStartTickCount > SvcStatus.dwWaitHint)
                {
                    break;
                }
            }
        } 

        if (SvcStatus.dwCurrentState != SERVICE_RUNNING) 
        {
            goto exit;
        }
    }

    g_dwAPSvcIdleTimeStamp = ::GetTickCount();
    g_fIsAPSvcAvailable = TRUE;

    fRet = TRUE;

exit:
    GeneralInitCritSec.Unlock();
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\dhcpdef.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpdef.h

Abstract:

    This module contains data type definitions for the DHCP client.

Author:

    Madan Appiah (madana) 31-Oct-1993

Environment:

    User Mode - Win32

Revision History:

--*/
//
// init.c will #include this file with GLOBAL_DATA_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//

#ifndef _DHCPDEF_
#define _DHCPDEF_

#ifdef  GLOBAL_DATA_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

//
// the registry key is of different type between NT and Memphis.
//
#ifdef VXD
typedef VMMHKEY   DHCPKEY;
#else  //  NT
typedef HKEY      DHCPKEY;
#endif


#ifndef VXD
#define RUNNING_IN_RAS_CONTEXT()     (!DhcpGlobalIsService)
#else
#define RUNNING_IN_RAS_CONTEXT()     FALSE
#endif


//
// The amount of time to wait for a retry if we have no IP address
//

#define ADDRESS_ALLOCATION_RETRY        300 //  5 minutes
#define EASYNET_ALLOCATION_RETRY        300 //  5 minutes

//
// The amount of time to wait for a retry if we have an IP address,
// but the renewal on startup failed.
//

#if !DBG
#define RENEWAL_RETRY                   600 // 10 minutes
#else
#define RENEWAL_RETRY                   60  // 1 minute
#endif

//
// The number of times to send a request before giving up waiting
// for a response.
//

#define DHCP_MAX_RETRIES                4
#define DHCP_ACCEPT_RETRIES             2
#define DHCP_MAX_RENEW_RETRIES          2


//
// amount of time required between consequtive send_informs..
//

#define DHCP_DEFAULT_INFORM_SEPARATION_INTERVAL   60 // one minute

//
// amount of time to wait after an address conflict is detected
//

#define ADDRESS_CONFLICT_RETRY          10 // 10 seconds

//
//
// Expoenential backoff delay.
//

#define DHCP_EXPO_DELAY                  4

//
// The maximum total amount of time to spend trying to obtain an
// initial address.
//
// This delay is computed as below:
//
// DHCP_MAX_RETRIES - n
// DHCP_EXPO_DELAY - m
// WAIT_FOR_RESPONSE_TIME - w
// MAX_STARTUP_DELAY - t
//
// Binary Exponential backup Algorithm.
//
// t > m * (n*(n+1)/2) + n + w*n
//     -------------------   ---
//        random wait      + response wait
//

#define MAX_STARTUP_DELAY \
    DHCP_EXPO_DELAY * \
        (( DHCP_MAX_RETRIES * (DHCP_MAX_RETRIES + 1)) / 2) + \
            DHCP_MAX_RETRIES + DHCP_MAX_RETRIES * WAIT_FOR_RESPONSE_TIME

#define MAX_RENEW_DELAY \
    DHCP_EXPO_DELAY * \
        (( DHCP_MAX_RENEW_RETRIES * (DHCP_MAX_RENEW_RETRIES + 1)) / 2) + \
            DHCP_MAX_RENEW_RETRIES + DHCP_MAX_RENEW_RETRIES * \
                WAIT_FOR_RESPONSE_TIME

//
// The maximum amount of time to wait between renewal retries, if the
// lease period is between T1 and T2.
//

#define MAX_RETRY_TIME                  3600    // 1 hour

//
// Minimum time to sleep between retries.
//

#if DBG
#define MIN_SLEEP_TIME                  1 * 60      // 1 min.
#else
#define MIN_SLEEP_TIME                  5 * 60      // 5 min.
#endif

//
// Minimum lease time.
//

#define DHCP_MINIMUM_LEASE              60*60   // 24 hours.

#ifdef __DHCP_DYNDNS_ENABLED__

#define DHCP_DNS_TTL                    0       // let the DNS api decide..

#endif


//
// IP Autoconfiguration defaults
//

#define DHCP_IPAUTOCONFIGURATION_DEFAULT_SUBNET  "169.254.0.0"
#define DHCP_IPAUTOCONFIGURATION_DEFAULT_MASK    "255.255.0.0"

// define the reserved range of autonet addresses..

#define DHCP_RESERVED_AUTOCFG_SUBNET             "169.254.255.0"
#define DHCP_RESERVED_AUTOCFG_MASK               "255.255.255.0"

// will dhcp pick any reserved autonet addr? NO!
#define DHCP_RESERVED_AUTOCFG_FLAG                (1)

// self default route (0,0,<self>) will have a metric of (3)
#define DHCP_SELF_DEFAULT_METRIC                  (3)

//
// General purpose macros
//

#define MIN(a,b)                        ((a) < (b) ? (a) : (b))
#define MAX(a,b)                        ((a) > (b) ? (a) : (b))

#if DBG
#define STATIC
#else
#define STATIC static
#endif

/*#define LOCK_RENEW_LIST()       EnterCriticalSection(&DhcpGlobalRenewListCritSect)
#define UNLOCK_RENEW_LIST()     LeaveCriticalSection(&DhcpGlobalRenewListCritSect)

#define LOCK_INTERFACE()        EnterCriticalSection(&DhcpGlobalSetInterfaceCritSect)
#define UNLOCK_INTERFACE()      LeaveCriticalSection(&DhcpGlobalSetInterfaceCritSect)

#define LOCK_OPTIONS_LIST()     EnterCriticalSection(&DhcpGlobalOptionsListCritSect)
#define UNLOCK_OPTIONS_LIST()   LeaveCriticalSection(&DhcpGlobalOptionsListCritSect)
*/
#define LOCK_RENEW_LIST()       
#define UNLOCK_RENEW_LIST()     

#define LOCK_INTERFACE()        
#define UNLOCK_INTERFACE()      

#define LOCK_OPTIONS_LIST()     
#define UNLOCK_OPTIONS_LIST()   


#define ZERO_TIME                       0x0         // in secs.

//
// length of the time string returned by ctime.
// actually it is 26.
//

#define TIME_STRING_LEN                 32

//
// String size when a long converted to printable string.
// 2^32 = 4294967295 (10 digits) + termination char.
//

#define LONG_STRING_SIZE                12

//
// A renewal function.
//

typedef
DWORD
(*PRENEWAL_FUNCTION) (
    IN PVOID Context,
    LPDWORD Sleep
    );

//
// DHCP Client-Identifier (option 61)
//
typedef struct _DHCP_CLIENT_IDENTIFIER
{
    BYTE  *pbID;
    DWORD  cbID;
    BYTE   bType;
    BOOL   fSpecified;
} DHCP_CLIENT_IDENTIFIER;


//
// state information for IP autoconfiguration
//

typedef struct _DHCP_IPAUTOCONFIGURATION_CONTEXT
{
    DHCP_IP_ADDRESS   Address;
    DHCP_IP_ADDRESS   Subnet;
    DHCP_IP_ADDRESS   Mask;
    DWORD             Seed;
} DHCP_IPAUTOCONFIGURATION_CONTEXT;

//
// A DHCP context block.  One block is maintained per NIC (network
// interface Card).
//

typedef struct _DHCP_CONTEXT {

        // list of adapters.
    //LIST_ENTRY NicListEntry;

        // hardware type.
    BYTE HardwareAddressType;
        // HW address, just follows this context structure.
    LPBYTE HardwareAddress;
        // Length of HW address.
    DWORD HardwareAddressLength;

        // Selected IpAddress, NetworkOrder.
    DHCP_IP_ADDRESS IpAddress;
        // Selected subnet mask. NetworkOrder.
    //DHCP_IP_ADDRESS SubnetMask;
        // Selected DHCP server address. Network Order.
    DHCP_IP_ADDRESS DhcpServerAddress;
        // Desired IpAddress the client request in next discover.
    //DHCP_IP_ADDRESS DesiredIpAddress;
        // The ip address that was used just before losing this..
    //DHCP_IP_ADDRESS LastKnownGoodAddress; // ONLY DNS uses this..
        // the domain name that was used with last registration..
    //WCHAR LastUsedDomainName[257]; // dns domain name is atmost 255 bytes.
        // current domain name for this adapter.
    //BYTE  DomainName[257];

        // IP Autoconfiguration state
    //DHCP_IPAUTOCONFIGURATION_CONTEXT IPAutoconfigurationContext;

    DHCP_CLIENT_IDENTIFIER ClientIdentifier;

        // Lease time in seconds.
    //DWORD Lease;
        // Time the lease was obtained.
    //time_t LeaseObtained;
        // Time the client should start renew its address.
    //time_t T1Time;
        // Time the client should start broadcast to renew address.
    time_t T2Time;
        // Time the lease expires. The clinet should stop using the
        // IpAddress.
        // LeaseObtained  < T1Time < T2Time < LeaseExpires
    //time_t LeaseExpires;
        // when was the last time an inform was sent?
    time_t LastInformSent;
        // how many seconds between consecutive informs?
    //DWORD  InformSeparationInterval;
        // # of gateways and the currently plumbed gateways are stored here
    //DWORD  nGateways;
    //DHCP_IP_ADDRESS *GatewayAddresses;

        // # of static routes and the actual static routes are stored here
    //DWORD  nStaticRoutes;
    //DHCP_IP_ADDRESS *StaticRouteAddresses;

        // to place in renewal list.
    //LIST_ENTRY RenewalListEntry;
        // Time for next renewal state.
    //time_t RunTime;

        // seconds passed since boot.
    DWORD SecondsSinceBoot;

        // should we ping the g/w or always assume g/w is NOT present?
    //BOOL  DontPingGatewayFlag;

        // can we use DHCP_INFORM packets or should we use DHCP_REQUEST instead?
    //BOOL  UseInformFlag;

    //WORD  ClientPort;

        // what to function at next renewal state.
    //PRENEWAL_FUNCTION RenewalFunction;

    	// A semaphore for synchronization to this structure
    //HANDLE RenewHandle;

        // the list of options to send and the list of options received
    LIST_ENTRY  SendOptionsList;
    LIST_ENTRY  RecdOptionsList;

        // the opened key to the adapter info storage location
    //DHCPKEY AdapterInfoKey;

        // the class this adapter belongs to
    LPBYTE ClassId;
    DWORD  ClassIdLength;

        // Message buffer to send and receive DHCP message.
    PDHCP_MESSAGE MessageBuffer;

        // state information for this interface. see below for manifests
    struct /* anonymous */ {
        unsigned Plumbed       : 1 ;    // is this interface plumbed
        unsigned ServerReached : 1 ;    // Did we reach the server ever
        unsigned AutonetEnabled: 1 ;    // Autonet enabled?
        unsigned HasBeenLooked : 1 ;    // Has this context been looked at?
        unsigned DhcpEnabled   : 1 ;    // Is this context dhcp enabled?
        unsigned AutoMode      : 1 ;    // Currently in autonet mode?
        unsigned MediaState    : 2 ;    // One of connected, disconnected, reconnected
        unsigned MDhcp         : 1 ;    // Is this context created for Mdhcp?
        unsigned PowerResumed  : 1 ;    // Was power just resumed on this interface?
        unsigned Broadcast     : 1 ;
    }   State;

	    // machine specific information
    //PVOID LocalInformation;
     
//    DWORD  IpInterfaceInstance;  // needed for BringUpInterface
    LPTSTR AdapterName;
//    LPWSTR DeviceName;
//    LPWSTR NetBTDeviceName;
//    LPWSTR RegistryKey;
    SOCKET Socket;
    DWORD  IpInterfaceContext;
//    BOOL DefaultGatewaysSet;

    CHAR szMessageBuffer[DHCP_MESSAGE_SIZE];
} DHCP_CONTEXT, *PDHCP_CONTEXT;

#define ADDRESS_PLUMBED(Ctxt)        ((Ctxt)->State.Plumbed = 1)
#define ADDRESS_UNPLUMBED(Ctxt)      ((Ctxt)->State.Plumbed = 0)
#define IS_ADDRESS_PLUMBED(Ctxt)     ((Ctxt)->State.Plumbed)
#define IS_ADDRESS_UNPLUMBED(Ctxt)   (!(Ctxt)->State.Plumbed)

#define CONNECTION_BROADCAST(Ctxt)        ((Ctxt)->State.Broadcast = 1)
#define CONNECTION_NO_BROADCAST(Ctxt)      ((Ctxt)->State.Broadcast = 0)
#define IS_CONNECTION_BROADCAST(Ctxt)     ((Ctxt)->State.Broadcast)
#define IS_CONNECTION_NOBROADCAST(Ctxt)   (!(Ctxt)->State.Broadcast)

#define SERVER_REACHED(Ctxt)         ((Ctxt)->State.ServerReached = 1)
#define SERVER_UNREACHED(Ctxt)       ((Ctxt)->State.ServerReached = 0)
#define IS_SERVER_REACHABLE(Ctxt)    ((Ctxt)->State.ServerReached)
#define IS_SERVER_UNREACHABLE(Ctxt)  (!(Ctxt)->State.ServerReached)

#define AUTONET_ENABLED(Ctxt)        ((Ctxt)->State.AutonetEnabled = 1)
#define AUTONET_DISABLED(Ctxt)       ((Ctxt)->State.AutonetEnabled = 0)
#define IS_AUTONET_ENABLED(Ctxt)     ((Ctxt)->State.AutonetEnabled)
#define IS_AUTONET_DISABLED(Ctxt)    (!(Ctxt)->State.AutonetEnabled)

#define CTXT_WAS_LOOKED(Ctxt)        ((Ctxt)->State.HasBeenLooked = 1)
#define CTXT_WAS_NOT_LOOKED(Ctxt)    ((Ctxt)->State.HasBeenLooked = 0)
#define WAS_CTXT_LOOKED(Ctxt)        ((Ctxt)->State.HasBeenLooked)
#define WAS_CTXT_NOT_LOOKED(Ctxt)    (!(Ctxt)->State.HasBeenLooked)

#define DHCP_ENABLED(Ctxt)           ((Ctxt)->State.DhcpEnabled = 1)
#define DHCP_DISABLED(Ctxt)          ((Ctxt)->State.DhcpEnabled = 0)
#define IS_DHCP_ENABLED(Ctxt)        ((Ctxt)->State.DhcpEnabled )
#define IS_DHCP_DISABLED(Ctxt)       (!(Ctxt)->State.DhcpEnabled )

#define ADDRESS_TYPE_AUTO            1
#define ADDRESS_TYPE_DHCP            0

#define ACQUIRED_DHCP_ADDRESS(Ctxt)  ((Ctxt)->State.AutoMode = 0 )
#define ACQUIRED_AUTO_ADDRESS(Ctxt)  ((Ctxt)->State.AutoMode = 1 )
#define IS_ADDRESS_DHCP(Ctxt)        (!(Ctxt)->State.AutoMode)
#define IS_ADDRESS_AUTO(Ctxt)        ((Ctxt)->State.AutoMode)

#define MEDIA_CONNECTED(Ctxt)        ((Ctxt)->State.MediaState = 0)
#define MEDIA_RECONNECTED(Ctxt)      ((Ctxt)->State.MediaState = 1)
#define MEDIA_DISCONNECTED(Ctxt)     ((Ctxt)->State.MediaState = 2)
#define IS_MEDIA_CONNECTED(Ctxt)     ((Ctxt)->State.MediaState == 0)
#define IS_MEDIA_RECONNECTED(Ctxt)   ((Ctxt)->State.MediaState == 1)
#define IS_MEDIA_DISCONNECTED(Ctxt)  ((Ctxt)->State.MediaState == 2)

#define _INIT_STATE1(Ctxt)           do{(Ctxt)->State.Plumbed = 0; (Ctxt)->State.AutonetEnabled=0;}while(0)
#define _INIT_STATE2(Ctxt)           do{(Ctxt)->State.HasBeenLooked = 0; (Ctxt)->State.DhcpEnabled=1;}while(0)
#define _INIT_STATE3(Ctxt)           do{(Ctxt)->State.AutoMode = 0; (Ctxt)->State.MediaState = 0;}while(0)
#define INIT_STATE(Ctxt)             do{_INIT_STATE1(Ctxt);_INIT_STATE2(Ctxt);_INIT_STATE3(Ctxt);}while(0)

#define MDHCP_CTX(Ctxt)           ((Ctxt)->State.MDhcp = 1)
#define NONMDHCP_CTX(Ctxt)          ((Ctxt)->State.MDhcp = 0)
#define IS_MDHCP_CTX(Ctxt)        ((Ctxt)->State.MDhcp )
#define SET_MDHCP_STATE( Ctxt ) { \
    ADDRESS_PLUMBED( Ctxt ), MDHCP_CTX( Ctxt ); \
}

#define POWER_RESUMED(Ctxt)           ((Ctxt)->State.PowerResumed = 1)
#define POWER_NOT_RESUMED(Ctxt)       ((Ctxt)->State.PowerResumed = 0)
#define IS_POWER_RESUMED(Ctxt)        ((Ctxt)->State.PowerResumed )


/*LPSTR _inline                        //  the string'ed version of state (same as Buffer)
ConvertStateToString(                //  convert from bits to string
    IN PDHCP_CONTEXT   Ctxt,         //  The context to print state for
    IN LPBYTE          Buffer        //  The input buffer to write state into
) {
    strcpy(Buffer, IS_DHCP_ENABLED(Ctxt)?"DhcpEnabled ":"DhcpDisabled ");
    strcat(Buffer, IS_AUTONET_ENABLED(Ctxt)?"AutonetEnabled ":"AutonetDisabled ");
    strcat(Buffer, IS_ADDRESS_DHCP(Ctxt)?"DhcpMode ":"AutoMode ");
    strcat(Buffer, IS_ADDRESS_PLUMBED(Ctxt)?"Plumbed ":"UnPlumbed ");
    strcat(Buffer, IS_SERVER_REACHABLE(Ctxt)?"(server-present) ":"(server-absent) ");
    strcat(Buffer, WAS_CTXT_LOOKED(Ctxt)? "(seen) ":"(not-seen) ");

    if(IS_MEDIA_CONNECTED(Ctxt) ) strcat(Buffer, "MediaConnected\n");
    else if(IS_MEDIA_RECONNECTED(Ctxt)) strcat(Buffer, "MediaReConnected\n");
    else if(IS_MEDIA_DISCONNECTED(Ctxt)) strcat(Buffer, "MediaDisConnected\n");
    else strcat(Buffer, "MediaUnknownState\n");

    strcat(Buffer, IS_MDHCP_CTX(Ctxt)? "(MDhcp) ":"");
    strcat(Buffer, IS_POWER_RESUMED(Ctxt)? "Pwr Resumed ":"");

    return Buffer;
}
*/

//
// The types of machines.. laptop would have aggressive EASYNET behaviour.
//

#define MACHINE_NONE   0
#define MACHINE_LAPTOP 1

//
//  Here is the set of expected options by the client -- If they are absent, not much can be done
//

typedef struct _DHCP_EXPECTED_OPTIONS {
    BYTE            UNALIGNED*     MessageType;
    DHCP_IP_ADDRESS UNALIGNED*     SubnetMask;
    DHCP_IP_ADDRESS UNALIGNED*     LeaseTime;
    DHCP_IP_ADDRESS UNALIGNED*     ServerIdentifier;
    BYTE            UNALIGNED*     DomainName;
    DWORD                          DomainNameSize;
    // Wpad Auto-Proxy Url
    BYTE            UNALIGNED*     WpadUrl;
    DWORD                          WpadUrlSize;
} DHCP_EXPECTED_OPTIONS, *PDHCP_EXPECTED_OPTIONS, *LPDHCP_EXPECTED_OPTIONS;

//
//  Here is the set of options understood by the client
//
typedef struct _DHCP_FULL_OPTIONS {
    BYTE            UNALIGNED*     MessageType;   // What kind of message is this?

    // Basic IP Parameters

    DHCP_IP_ADDRESS UNALIGNED*     SubnetMask;
    DHCP_IP_ADDRESS UNALIGNED*     LeaseTime;
    DHCP_IP_ADDRESS UNALIGNED*     T1Time;
    DHCP_IP_ADDRESS UNALIGNED*     T2Time;
    DHCP_IP_ADDRESS UNALIGNED*     GatewayAddresses;
    DWORD                          nGateways;
    DHCP_IP_ADDRESS UNALIGNED*     StaticRouteAddresses;
    DWORD                          nStaticRoutes;

    DHCP_IP_ADDRESS UNALIGNED*     ServerIdentifier;

    // DNS parameters

    BYTE            UNALIGNED*     DnsFlags;
    BYTE            UNALIGNED*     DnsRcode1;
    BYTE            UNALIGNED*     DnsRcode2;
    BYTE            UNALIGNED*     DomainName;
    DWORD                          DomainNameSize;
    DHCP_IP_ADDRESS UNALIGNED*     DnsServerList;
    DWORD                          nDnsServers;

    // Multicast options.
    DWORD           UNALIGNED*     MCastLeaseStartTime;
    BYTE            UNALIGNED     *MCastTTL;

    // Server message is something that the server may inform us of

    BYTE            UNALIGNED*     ServerMessage;
    DWORD                          ServerMessageLength;

    // Wpad Auto-Proxy Url
    BYTE            UNALIGNED*     WpadUrl;
    DWORD                          WpadUrlSize;

} DHCP_FULL_OPTIONS, *PDHCP_FULL_OPTIONS, *LPDHCP_FULL_OPTIONS;

typedef DHCP_FULL_OPTIONS DHCP_OPTIONS, *PDHCP_OPTIONS;

//
// structure for a list of messages
//

typedef struct _MSG_LIST {
    LIST_ENTRY     MessageListEntry;
    DWORD          ServerIdentifier;
    DWORD          MessageSize;
    DWORD          LeaseExpirationTime;
    DHCP_MESSAGE   Message;
} MSGLIST, *PMSGLIST, *LPMSGLIST;


//
// DHCP Global data.
//

extern BOOL DhcpGlobalServiceRunning;   // initialized global.

EXTERN LPSTR DhcpGlobalHostName;
EXTERN LPWSTR DhcpGlobalHostNameW;
EXTERN LPSTR DhcpGlobalHostComment;

//
// NIC List.
//

EXTERN LIST_ENTRY DhcpGlobalNICList;
EXTERN LIST_ENTRY DhcpGlobalRenewList;

//
// Synchronization variables.
//

EXTERN CRITICAL_SECTION DhcpGlobalRenewListCritSect;
EXTERN CRITICAL_SECTION DhcpGlobalSetInterfaceCritSect;
EXTERN CRITICAL_SECTION DhcpGlobalOptionsListCritSect;
EXTERN HANDLE DhcpGlobalRecomputeTimerEvent;
EXTERN HANDLE DhcpGlobalResumePowerEvent;

// waitable timer
EXTERN HANDLE DhcpGlobalWaitableTimerHandle;

//
// to display success message.
//

EXTERN BOOL DhcpGlobalProtocolFailed;

//
// This varible tells if we are going to provide the DynDns api support to external clients
// and if we are going to use the corresponding DnsApi.  The define below gives the default
// value.
//

EXTERN DWORD UseMHAsyncDns;
#define DEFAULT_USEMHASYNCDNS             1

//
// This flag tells if we need to use inform or request packets
//
EXTERN DWORD DhcpGlobalUseInformFlag;

//
// This flag tells if pinging the g/w is disabled. (in this case the g/w is always NOT present)
//
EXTERN DWORD DhcpGlobalDontPingGatewayFlag;

//
// The # of seconds before retrying according to AUTONET... default is EASYNET_ALLOCATION_RETRY
//

EXTERN DWORD AutonetRetriesSeconds;

//
// Not used on NT.  Just here for memphis.
//

EXTERN DWORD DhcpGlobalMachineType;

//
// Do we need to do a global refresh?
//

EXTERN ULONG DhcpGlobalDoRefresh;


//
// options related lists
//

EXTERN LIST_ENTRY DhcpGlobalClassesList;
EXTERN LIST_ENTRY DhcpGlobalOptionDefList;


//
// dhcpmsg.c.. list for doing parallel recv on..
//

EXTERN LIST_ENTRY DhcpGlobalRecvFromList;
EXTERN CRITICAL_SECTION DhcpGlobalRecvFromCritSect;

//
// the client vendor name ( "MSFT 5.0" or something like that )
//

EXTERN LPSTR   DhcpGlobalClientClassInfo;

//
// The following global keys are used to avoid re-opening each time
//
EXTERN DHCPKEY DhcpGlobalParametersKey;
EXTERN DHCPKEY DhcpGlobalTcpipParametersKey;
EXTERN DHCPKEY DhcpGlobalClientOptionKey;
EXTERN DHCPKEY DhcpGlobalServicesKey;

//
// debug variables.
//

#if DBG
EXTERN DWORD DhcpGlobalDebugFlag;
#endif

#endif // _DHCPDEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\dhcplib.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcplib.h

Abstract:

    This file contains proto type definitions for the dhcp lib
    functions.

Author:

    Madan Appiah  (madana)  12-Aug-1993

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/
#ifndef DHCPLIB_H_INCLUDED
#define DHCPLIB_H_INCLUDED


#define DhcpAllocateMemory(x) ALLOCATE_ZERO_MEMORY(x)
#define DhcpFreeMemory(x)     FREE_MEMORY(x)


//
// network.c
//

DHCP_IP_ADDRESS
DhcpDefaultSubnetMask(
    DHCP_IP_ADDRESS IpAddress
    );

//
// dhcp.c
//


/*PVOID
DhcpAllocateMemory(
    DWORD Size
    );

VOID
DhcpFreeMemory(
    PVOID Memory
    );*/


#if DBG

#ifndef DEBUG_ALLOC
#define DEBUG_ALLOC 0x02000000
#endif

/*
PVOID _inline
DhcpAllocateMemoryEx(
    DWORD Size,
    DWORD LineNo,
    LPSTR FileName
) {
    LPVOID Ptr = DhcpAllocateMemory(Size);

    DhcpPrint(("Allocate %010x %04x %04d %s\n", Ptr, Size, LineNo, FileName));
    return Ptr;
}

VOID _inline
DhcpFreeMemoryEx(
    LPVOID Ptr,
    DWORD  LineNo,
    LPSTR  FileName
) {
    DhcpFreeMemory(Ptr);
    DhcpPrint("Free %010x %04x %04d %s\n", Ptr, 0, LineNo, FileName));
} 
*/

//#define DhcpAllocateMemory(Sz)    DhcpAllocateMemoryEx(Sz, __LINE__, __FILE__)
//#define DhcpFreeMemory(Ptr)       DhcpFreeMemoryEx(Ptr, __LINE__, __FILE__)

#endif

LPOPTION
DhcpAppendOption(
    LPOPTION Option,
    BYTE OptionType,
    PVOID OptionValue,
    ULONG OptionLength,
    LPBYTE OptionEnd
    );

LPOPTION
DhcpAppendClientIDOption(
    LPOPTION Option,
    BYTE ClientHWType,
    LPBYTE ClientHWAddr,
    BYTE ClientHWAddrLength,
    LPBYTE OptionEnd

    );

LPBYTE
DhcpAppendMagicCookie(
    LPBYTE Option,
    LPBYTE OptionEnd

    );

LPOPTION
DhcpAppendEnterpriseName(
    LPOPTION Option,
    PCHAR    DSEnterpriseName,
    LPBYTE   OptionEnd
    );

DATE_TIME
DhcpCalculateTime(
    DWORD RelativeTime
    );

DATE_TIME
DhcpGetDateTime(
    VOID
    );

DWORD
DhcpReportEventW(
    LPWSTR Source,
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPWSTR *Strings,
    LPVOID Data
    );

DWORD
DhcpReportEventA(
    LPWSTR Source,
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPSTR *Strings,
    LPVOID Data
    );

DWORD
DhcpLogUnknownOption(
    LPWSTR Source,
    DWORD EventID,
    LPOPTION Option
    );

VOID
DhcpCancelWaitableTimer(
    HANDLE TimerHandle
    );

DWORD
DhcpStartWaitableTimer(
    HANDLE TimerHandle,
    DWORD SleepTime);


//
// convert.c
//

LPWSTR
DhcpOemToUnicodeN(
    IN      LPSTR   Ansi,
    IN OUT  LPWSTR  Unicode,
    IN      USHORT  cChars
    );

LPWSTR
DhcpOemToUnicode(
    IN LPSTR Ansi,
    IN OUT LPWSTR Unicode
    );

LPSTR
DhcpUnicodeToOem(
    IN LPWSTR Unicode,
    IN LPSTR Ansi
    );

#if 0

VOID
DhcpIpAddressToString(
    LPWSTR Buffer,
    DWORD HexNumber
    );

VOID
DhcpStringToIpAddress(
    LPSTR Buffer,
    LPDHCP_IP_ADDRESS IpAddress,
    BOOL NetOrder
    );

#endif

VOID
DhcpHexToString(
    LPWSTR Buffer,
    LPBYTE HexNumber,
    DWORD Length
    );

VOID
DhcpHexToAscii(
    LPSTR Buffer,
    LPBYTE HexNumber,
    DWORD Length
    );

VOID
DhcpDecimalToString(
    LPWSTR Buffer,
    BYTE Number
    );

DWORD
DhcpDottedStringToIpAddress(
    LPSTR String
    );

LPSTR
DhcpIpAddressToDottedString(
    DWORD IpAddress
    );

DWORD
DhcpStringToHwAddress(
    LPSTR AddressBuffer,
    LPSTR AddressString
    );

#if 0

DHCP_IP_ADDRESS
DhcpHostOrder(
    DHCP_IP_ADDRESS NetworkOrderAddress
    );

DHCP_IP_ADDRESS
DhcpNetworkOrder(
    DHCP_IP_ADDRESS NetworkOrderAddress
    );

#endif

LPWSTR
DhcpRegIpAddressToKey(
    DHCP_IP_ADDRESS IpAddress,
    LPWSTR KeyBuffer
    );

DWORD
DhcpRegKeyToIpAddress(
    LPWSTR Key
    );

LPWSTR
DhcpRegOptionIdToKey(
    DHCP_OPTION_ID OptionId,
    LPWSTR KeyBuffer
    );

DHCP_OPTION_ID
DhcpRegKeyToOptionId(
    LPWSTR Key
    );

#if 0 //DBG

VOID
DhcpDumpMessage(
    DWORD DhcpDebugFlag,
    LPDHCP_MESSAGE DhcpMessage
    );

VOID
DhcpAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    );

#define DhcpAssert(Predicate) \
    { \
        if (!(Predicate)) \
            DhcpAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }


#define DhcpVerify(Predicate) \
    { \
        if (!(Predicate)) \
            DhcpAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }


#else

#define DhcpAssert(_x_)
#define DhcpDumpMessage(_x_, _y_)
#define DhcpVerify(_x_) (_x_)

#endif // not DBG

VOID
DhcpNTToNTPTime(
    LPDATE_TIME AbsNTTime,
    DWORD       Offset,
    PULONG      NTPTimeStamp
    );

VOID
DhcpNTPToNTTime(
    PULONG          NTPTimeStamp,
    DWORD           Offset,
    DATE_TIME       *NTTime
    );


#endif DHCPLIB_H_INCLUDED

//------------------------------------------------------------------------
// End of file
//------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\dhcp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcp.h

Abstract:

    This module defines the DHCP server service definitions and structures.

Author:

    Manny Weiser  (mannyw)  11-Aug-1992

Revision History:

    Madan Appiah (madana) 10-Oct-1993

--*/

#ifndef _DHCP_
#define _DHCP_

#define WS_VERSION_REQUIRED     MAKEWORD( 1, 1)

//
// update dhcpapi.h also if you modify the following three typedefs.
//

typedef DWORD DHCP_IP_ADDRESS, *PDHCP_IP_ADDRESS, *LPDHCP_IP_ADDRESS;
typedef DWORD DHCP_OPTION_ID;

typedef struct _DATE_TIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} DATE_TIME, *LPDATE_TIME;

#define DHCP_DATE_TIME_ZERO_HIGH        0
#define DHCP_DATE_TIME_ZERO_LOW         0

#define DHCP_DATE_TIME_INFINIT_HIGH     0x7FFFFFFF
#define DHCP_DATE_TIME_INFINIT_LOW      0xFFFFFFFF

#define DOT_IP_ADDR_SIZE                16          // XXX.XXX.XXX.XXX + '\0'
#define NO_DHCP_IP_ADDRESS              ((DHCP_IP_ADDRESS)-1)
#define DHCP_IP_KEY_LEN                 32          //arbitary size.

#define INFINIT_TIME                    0x7FFFFFFF  // time_t is int
#define INFINIT_LEASE                   0xFFFFFFFF  // in secs. (unsigned int.)
#define MDHCP_SERVER_IP_ADDRESS         0x0100efef // 239.239.0.1
//
// hardware types.
//
#define HARDWARE_TYPE_NONE              0 // used for non-hardware type client id
#define HARDWARE_TYPE_10MB_EITHERNET    1
#define HARDWARE_TYPE_IEEE_802          6
#define HARDWARE_ARCNET                 7
#define HARDWARE_PPP                    8
#define HARDWARE_IEEE1394               24

//
// Client-server protoocol reserved ports
//

#define DHCP_CLIENT_PORT    68
#define DHCP_SERVR_PORT     67

//
// DHCP BROADCAST flag.
//

#define DHCP_BROADCAST      0x8000
#define DHCP_NO_BROADCAST   0x0000

// MDHCP flag
#define DHCP_MBIT           0x4000
#define IS_MDHCP_MESSAGE( _msg ) ( _I_ntohs((_msg)->Reserved) & DHCP_MBIT ? TRUE : FALSE )
#define MDHCP_MESSAGE( _msg ) ( (_msg)->Reserved |= htons(DHCP_MBIT) )

#define CLASSD_NET_ADDR(a)  ( (a & 0xf0) == 0xe0)
#define CLASSD_HOST_ADDR(a)  ((a & 0xf0000000) == 0xe0000000)

#define DHCP_MESSAGE_SIZE       576
#define DHCP_SEND_MESSAGE_SIZE  548
#define BOOTP_MESSAGE_SIZE      300 // the options field for bootp is 64 bytes.

//
// The amount of time to wait for a DHCP response after a request
// has been sent.
//

#if !DBG
#define WAIT_FOR_RESPONSE_TIME          5
#else
#define WAIT_FOR_RESPONSE_TIME          10
#endif

//
// DHCP Operations
//

#define BOOT_REQUEST   1
#define BOOT_REPLY     2

//
// DHCP Standard Options.
//

#define OPTION_PAD                      0
#define OPTION_SUBNET_MASK              1
#define OPTION_TIME_OFFSET              2
#define OPTION_ROUTER_ADDRESS           3
#define OPTION_TIME_SERVERS             4
#define OPTION_IEN116_NAME_SERVERS      5
#define OPTION_DOMAIN_NAME_SERVERS      6
#define OPTION_LOG_SERVERS              7
#define OPTION_COOKIE_SERVERS           8
#define OPTION_LPR_SERVERS              9
#define OPTION_IMPRESS_SERVERS          10
#define OPTION_RLP_SERVERS              11
#define OPTION_HOST_NAME                12
#define OPTION_BOOT_FILE_SIZE           13
#define OPTION_MERIT_DUMP_FILE          14
#define OPTION_DOMAIN_NAME              15
#define OPTION_SWAP_SERVER              16
#define OPTION_ROOT_DISK                17
#define OPTION_EXTENSIONS_PATH          18

//
// IP layer parameters - per host
//

#define OPTION_BE_A_ROUTER              19
#define OPTION_NON_LOCAL_SOURCE_ROUTING 20
#define OPTION_POLICY_FILTER_FOR_NLSR   21
#define OPTION_MAX_REASSEMBLY_SIZE      22
#define OPTION_DEFAULT_TTL              23
#define OPTION_PMTU_AGING_TIMEOUT       24
#define OPTION_PMTU_PLATEAU_TABLE       25

//
// Link layer parameters - per interface.
//

#define OPTION_MTU                      26
#define OPTION_ALL_SUBNETS_MTU          27
#define OPTION_BROADCAST_ADDRESS        28
#define OPTION_PERFORM_MASK_DISCOVERY   29
#define OPTION_BE_A_MASK_SUPPLIER       30
#define OPTION_PERFORM_ROUTER_DISCOVERY 31
#define OPTION_ROUTER_SOLICITATION_ADDR 32
#define OPTION_STATIC_ROUTES            33
#define OPTION_TRAILERS                 34
#define OPTION_ARP_CACHE_TIMEOUT        35
#define OPTION_ETHERNET_ENCAPSULATION   36

//
// TCP Paramters - per host
//

#define OPTION_TTL                      37
#define OPTION_KEEP_ALIVE_INTERVAL      38
#define OPTION_KEEP_ALIVE_DATA_SIZE     39

//
// Application Layer Parameters
//

#define OPTION_NETWORK_INFO_SERVICE_DOM 40
#define OPTION_NETWORK_INFO_SERVERS     41
#define OPTION_NETWORK_TIME_SERVERS     42

//
// Vender specific information option
//

#define OPTION_VENDOR_SPEC_INFO         43

//
// NetBIOS over TCP/IP Name server option
//

#define OPTION_NETBIOS_NAME_SERVER      44
#define OPTION_NETBIOS_DATAGRAM_SERVER  45
#define OPTION_NETBIOS_NODE_TYPE        46
#define OPTION_NETBIOS_SCOPE_OPTION     47

//
// X Window System Options.
//

#define OPTION_XWINDOW_FONT_SERVER      48
#define OPTION_XWINDOW_DISPLAY_MANAGER  49

//
// Other extensions
//

#define OPTION_REQUESTED_ADDRESS        50
#define OPTION_LEASE_TIME               51
#define OPTION_OK_TO_OVERLAY            52
#define OPTION_MESSAGE_TYPE             53
#define OPTION_SERVER_IDENTIFIER        54
#define OPTION_PARAMETER_REQUEST_LIST   55
#define OPTION_MESSAGE                  56
#define OPTION_MESSAGE_LENGTH           57
#define OPTION_RENEWAL_TIME             58      // T1
#define OPTION_REBIND_TIME              59      // T2
#define OPTION_CLIENT_CLASS_INFO        60
#define OPTION_CLIENT_ID                61

#define OPTION_TFTP_SERVER_NAME         66
#define OPTION_BOOTFILE_NAME            67

//
//  user class id
//
#define OPTION_USER_CLASS               77

//
//  Dynamic DNS Stuff.  Tells if we should do both A+PTR updates?
//
#define OPTION_DYNDNS_BOTH              81

// Multicast options.
#define OPTION_MCAST_SCOPE_ID           101
#define OPTION_MCAST_LEASE_START        102
#define OPTION_MCAST_TTL                103
#define OPTION_CLIENT_PORT              105
#define OPTION_MCAST_SCOPE_LIST         107

// special option to extend options
#define     OPTION_LARGE_OPTION    127

#define OPTION_WPAD_URL                 252 

#define OPTION_END                      255

// default mcast_ttl value.
#define DEFAULT_MCAST_TTL               32

//
// Different option values for the DYNDNS_BOTH option ...
//

#define DYNDNS_REGISTER_AT_CLIENT       0     // Client will do both registrations
#define DYNDNS_REGISTER_AT_SERVER       1     // Server will do registrations
#define DYNDNS_DOWNLEVEL_CLIENT         3     // arbitraty # diff from above

//
// Microsoft-specific options
//
#define OPTION_MSFT_DSDOMAINNAME_REQ    94    // send me your DS Domain name
#define OPTION_MSFT_DSDOMAINNAME_RESP   95    // sending my DS Domain name
#define OPTION_MSFT_CONTINUED           250   // the previous option is being continued..

//
// DHCP Message types
//

#define DHCP_DISCOVER_MESSAGE  1
#define DHCP_OFFER_MESSAGE     2
#define DHCP_REQUEST_MESSAGE   3
#define DHCP_DECLINE_MESSAGE   4
#define DHCP_ACK_MESSAGE       5
#define DHCP_NACK_MESSAGE      6
#define DHCP_RELEASE_MESSAGE   7
#define DHCP_INFORM_MESSAGE    8

#define DHCP_MAGIC_COOKIE_BYTE1     99
#define DHCP_MAGIC_COOKIE_BYTE2     130
#define DHCP_MAGIC_COOKIE_BYTE3     83
#define DHCP_MAGIC_COOKIE_BYTE4     99

#define BOOT_FILE_SIZE          128
#define BOOT_SERVER_SIZE        64
#define BOOT_FILE_SIZE_W        ( BOOT_FILE_SIZE * sizeof( WCHAR ))
#define BOOT_SERVER_SIZE_W      ( BOOT_SERVER_SIZE * sizeof( WCHAR ))

//
// DHCP APP names - used to indentify to the eventlogger.
//

#define DHCP_EVENT_CLIENT     TEXT("Dhcp")
#define DHCP_EVENT_SERVER     TEXT("DhcpServer")


typedef struct _OPTION {
    BYTE OptionType;
    BYTE OptionLength;
    BYTE OptionValue[1];
} OPTION, *POPTION, *LPOPTION;

//
// A DHCP message buffer
//


#pragma pack(1)         /* Assume byte packing */
typedef struct _DHCP_MESSAGE {
    BYTE Operation;
    BYTE HardwareAddressType;
    BYTE HardwareAddressLength;
    BYTE HopCount;
    DWORD TransactionID;
    WORD SecondsSinceBoot;
    WORD Reserved;
    DHCP_IP_ADDRESS ClientIpAddress;
    DHCP_IP_ADDRESS YourIpAddress;
    DHCP_IP_ADDRESS BootstrapServerAddress;
    DHCP_IP_ADDRESS RelayAgentIpAddress;
    BYTE HardwareAddress[16];
    BYTE HostName[ BOOT_SERVER_SIZE ];
    BYTE BootFileName[BOOT_FILE_SIZE];
    OPTION Option;
} DHCP_MESSAGE, *PDHCP_MESSAGE, *LPDHCP_MESSAGE;
#pragma pack()

#define DHCP_MESSAGE_FIXED_PART_SIZE \
            (sizeof(DHCP_MESSAGE) - sizeof(OPTION))

#define DHCP_MIN_SEND_RECV_PK_SIZE \
            (DHCP_MESSAGE_FIXED_PART_SIZE + 64)

//
// JET - DHCP database constants.
//

#define DB_TABLE_SIZE       10      // table size in 4K pages.
#define DB_TABLE_DENSITY    80      // page density
#define DB_LANGID           0x0409  // language id
#define DB_CP               1252    // code page

#if DBG

//
// debug functions.
//

#ifdef CHICAGO // No Tracing available on CHICAGO
#define DhcpPrintTrace
#endif

//#define IF_DEBUG(flag) if (DhcpGlobalDebugFlag & (DEBUG_ ## flag))
#define DhcpPrint(_x_) DEBUG_PRINT(UTIL,INFO,_x_)
#define Trace          DhcpPrintTrace

#ifndef CHICAGO
VOID
DhcpPrintTrace(
    IN LPSTR Format,
    ...
    );

#endif

#if DBG

/*
VOID
//extern "C"
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )
{

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length = 0;

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    va_end(arglist);

    //DhcpAssert(length <= MAX_PRINTF_LEN);

    //
    // Output to the debug terminal,
    //

    printf( "%s", OutputBuffer);
}
*/
#endif // DBG


#else

//#define IF_DEBUG(flag) if (FALSE)
#define DhcpPrint(_x_)
#define Trace       (void)

#endif // DBG

#define OpenDriver     DhcpOpenDriver

#endif // _DHCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\dhcploc.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    local.h

Abstract:

    This module contains various declarations for implementation
    specific "stuff".

Author:

    Manny Weiser (mannyw)  21-Oct-1992

Environment:

    User Mode - Win32

Revision History:

    Madan Appiah (madana)  21-Oct-1993

--*/

#ifndef _LOCAL_
#define _LOCAL_

//
// dhcp.c will #include this file with GLOBAL_DATA_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//

#ifdef  GLOBAL_DATA_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

#define DAY_LONG_SLEEP                          24*60*60    // in secs.
#define INVALID_INTERFACE_CONTEXT               0xFFFF

#define DHCP_NEW_IPADDRESS_EVENT_NAME   TEXT("DHCPNEWIPADDRESS"

//
// Registry keys and values we're interested in.
//

#define DHCP_SERVICES_KEY                       TEXT("System\\CurrentControlSet\\Services")

#define DHCP_ADAPTERS_KEY                       TEXT("System\\CurrentControlSet\\Services\\TCPIP\\Linkage")
#define DHCP_ADAPTERS_VALUE                     TEXT("Bind")
#define DHCP_ADAPTERS_VALUE_TYPE                REG_MULTI_SZ
#define DHCP_ADAPTERS_DEVICE_STRING             TEXT("\\Device\\")
#define DHCP_TCPIP_DEVICE_STRING                TEXT("\\Device\\TCPIP_")
#if     defined(_PNP_POWER_)
#define DHCP_NETBT_DEVICE_STRING                TEXT("NetBT_TCPIP_")
#else
#define DHCP_NETBT_DEVICE_STRING                TEXT("NetBT_")
#endif _PNP_POWER_

#define DHCP_CLIENT_ENABLE_DYNDNS_VALUE         TEXT("EnableDynDNS")
#define DHCP_CLIENT_ENABLE_DYNDNS_VALUE_TYPE    REG_DWORD

#ifdef DYNDNS_DNS_OVERRIDE_ENABLED

#define DHCP_CLIENT_DYNDNS_DNS_OVERRIDE_VALUE   TEXT("DynDNSServer")
#define DHCP_CLIENT_DYNDNS_DNS_OVERRIDE_VALUE_TYPE REG_DWORD

#endif

#define DHCP_CLIENT_PARAMETER_KEY               TEXT("System\\CurrentControlSet\\Services\\Dhcp\\Parameters")

#if DBG
#define DHCP_DEBUG_FLAG_VALUE                   TEXT("DebugFlag")
#define DHCP_DEBUG_FLAG_VALUE_TYPE              REG_DWORD
#endif

#define DHCP_CLIENT_OPTION_KEY                  TEXT("System\\CurrentControlSet\\Services\\Dhcp\\Parameters\\Options")

#define DHCP_CLIENT_GLOBAL_CLASSES_KEY          TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Classes")
#define DHCP_CLIENT_CLASS_VALUE                 TEXT("DhcpMachineClass")

#if     defined(_PNP_POWER_)
#define DHCP_ADAPTER_PARAMETERS_KEY             TEXT("\\TCPIP\\Parameters\\Interfaces")
#else
#define DHCP_ADAPTER_PARAMETERS_KEY             TEXT("\\Parameters\\TCPIP")
#endif _PNP_POWER_

#define DHCP_DEFAULT_GATEWAY_PARAMETER          TEXT("DefaultGateway")
#define DHCP_DONT_ADD_DEFAULT_GATEWAY_FLAG      TEXT("DontAddDefaultGateway")
#define DHCP_DONT_PING_GATEWAY_FLAG             TEXT("DontPingGateway")
#define DHCP_USE_MHASYNCDNS_FLAG                TEXT("UseMHAsyncDns")
#define DHCP_USE_INFORM_FLAG                    TEXT("UseInform")
#define DHCP_INFORM_SEPARATION_INTERVAL         TEXT("DhcpInformInterval")

#define DHCP_TCPIP_PARAMETERS_KEY               DHCP_SERVICES_KEY TEXT("\\TCPIP\\Parameters")
#define DHCP_TCPIP_ADAPTER_PARAMETERS_KEY       NULL
#define DHCP_NAME_SERVER_VALUE                  TEXT("NameServer")
#define DHCP_IPADDRESS_VALUE                    TEXT("IPAddress")
#define DHCP_HOSTNAME_VALUE                     TEXT("Hostname")
#define DHCP_DOMAINNAME_VALUE                   TEXT("Domain")
#define DHCP_STATIC_DOMAIN_VALUE_A              "Domain"

#ifdef __DHCP_CLIENT_OPTIONS_API_ENABLED__

#define DHCP_CLIENT_OPTION_SIZE                 TEXT("OptionSize")
#define DHCP_CLIENT_OPTION_SIZE_TYPE            REG_DWORD
#define DHCP_CLIENT_OPTION_VALUE                TEXT("OptionValue")
#define DHCP_CLIENT_OPTION_VALUE_TYPE           REG_BINARY

#endif

#define REGISTRY_CONNECT                        L'\\'
#define REGISTRY_CONNECT_STRING                 TEXT("\\")

#define DHCP_CLIENT_OPTION_REG_LOCATION         TEXT("RegLocation")
#define DHCP_CLIENT_OPTION_REG_LOCATION_TYPE    REG_SZ

#define DHCP_CLIENT_OPTION_REG_KEY_TYPE         TEXT("KeyType")
#define DHCP_CLIENT_OPTION_REG_KEY_TYPE_TYPE    REG_DWORD

#define DHCP_CLASS_LOCATION_VALUE               TEXT("DhcpClientClassLocation")
#define DHCP_CLASS_LOCATION_TYPE                REG_MULTI_SZ

#define DEFAULT_USER_CLASS_LOCATION             TEXT("Tcpip\\Parameters\\Interfaces\\?\\DhcpClassIdBin")
#define DEFAULT_USER_CLASS_LOC_FULL             DHCP_SERVICES_KEY REGISTRY_CONNECT_STRING DEFAULT_USER_CLASS_LOCATION

#define DEFAULT_USER_CLASS_UI_LOCATION          TEXT("Tcpip\\Parameters\\Interfaces\\?\\DhcpClassId")
#define DEFAULT_USER_CLASS_UI_LOC_FULL          DHCP_SERVICES_KEY REGISTRY_CONNECT_STRING DEFAULT_USER_CLASS_UI_LOCATION

// ******** Don;t chagne regloc for below.. it also affects DHCP_REGISTER_OPTION_LOC below
#define DEFAULT_REGISTER_OPT_LOC            TEXT("Tcpip\\Parameters\\Interfaces\\?\\DhcpRequestOptions")

#define DHCP_OPTION_LIST_VALUE                  TEXT("DhcpOptionLocationList")
#define DHCP_OPTION_LIST_TYPE                   REG_MULTI_SZ

#define NETBIOSLESS_OPT                         TEXT("DhcpNetbiosLessOption\0")
#define DEFAULT_DHCP_KEYS_LIST_VALUE            (L"1\0" L"15\0" L"3\0" L"44\0" L"46\0" L"47\0" L"6\0" NETBIOSLESS_OPT)

#define DHCP_OPTION_OPTIONID_VALUE              TEXT("OptionId")
#define DHCP_OPTION_OPTIONID_TYPE               REG_DWORD

#define DHCP_OPTION_ISVENDOR_VALUE              TEXT("VendorType")
#define DHCP_OPTION_ISVENDOR_TYPE               REG_DWORD

#define DHCP_OPTION_SAVE_TYPE_VALUE             TEXT("KeyType")
#define DHCP_OPTION_SAVE_TYPE_TYPE              REG_DWORD

#define DHCP_OPTION_CLASSID_VALUE               TEXT("ClassId")
#define DHCP_OPTION_CLASSID_TYPE                REG_BINARY

#define DHCP_OPTION_SAVE_LOCATION_VALUE         TEXT("RegLocation")
#define DHCP_OPTION_SAVE_LOCATION_TYPE          REG_MULTI_SZ

#define DHCP_OPTION_SEND_LOCATION_VALUE         TEXT("RegSendLocation")
#define DHCP_OPTION_SEND_LOCATION_TYPE          REG_MULTI_SZ



#define DHCP_ENABLE_STRING                      TEXT("EnableDhcp")
#define DHCP_ENABLE_STRING_TYPE                 REG_DWORD

#define DHCP_IP_ADDRESS_STRING                  TEXT("DhcpIPAddress")
#define DHCP_IP_ADDRESS_STRING_TYPE             REG_SZ

#define DHCP_SUBNET_MASK_STRING                 TEXT("DhcpSubnetMask")
#define DHCP_SUBNET_MASK_STRING_TYPE            REG_SZ

#define DHCP_SERVER                             TEXT("DhcpServer")
#define DHCP_SERVER_TYPE                        REG_SZ

#define DHCP_LEASE                              TEXT("Lease")
#define DHCP_LEASE_TYPE                         REG_DWORD

#define DHCP_LEASE_OBTAINED_TIME                TEXT("LeaseObtainedTime")
#define DHCP_LEASE_OBTAINED_TIME_TYPE           REG_DWORD

#define DHCP_LEASE_T1_TIME                      TEXT("T1")
#define DHCP_LEASE_T1_TIME_TYPE                 REG_DWORD

#define DHCP_LEASE_T2_TIME                      TEXT("T2")
#define DHCP_LEASE_T2_TIME_TYPE                 REG_DWORD

#define DHCP_LEASE_TERMINATED_TIME              TEXT("LeaseTerminatesTime")
#define DHCP_LEASE_TERMINATED_TIME_TYPE         REG_DWORD

#define DHCP_IP_INTERFACE_CONTEXT               TEXT("IpInterfaceContext")
#define DHCP_IP_INTERFACE_CONTEXT_TYPE          REG_DWORD

#define DHCP_IP_INTERFACE_CONTEXT_MAX           TEXT("IpInterfaceContextMax")
#define DHCP_IP_INTERFACE_CONTEXT_MAX_TYPE      REG_DWORD

#if     defined(_PNP_POWER_)
#define DHCP_NTE_CONTEXT_LIST                   TEXT("NTEContextList")
#define DHCP_NTE_CONTEXT_LIST_TYPE              REG_MULTI_SZ
#endif _PNP_POWER_

#define DHCP_CLIENT_IDENTIFIER_FORMAT           TEXT("DhcpClientIdentifierType")
#define DHCP_CLIENT_IDENTIFIER_FORMAT_TYPE      REG_DWORD

#define DHCP_CLIENT_IDENTIFIER_VALUE            TEXT("DhcpClientIdentifier")

#define DHCP_DYNDNS_UPDATE_REQUIRED             TEXT("DNSUpdateRequired")
#define DHCP_DYNDNS_UPDATE_REQUIRED_TYPE        REG_DWORD

#define DHCP_IPAUTOCONFIGURATION_ENABLED        TEXT("IPAutoconfigurationEnabled")
#define DHCP_IPAUTOCONFIGURATION_ENABLED_TYPE   REG_DWORD

#define DHCP_IPAUTOCONFIGURATION_ADDRESS        TEXT("IPAutoconfigurationAddress")
#define DHCP_IPAUTOCONFIGURATION_ADDRESS_TYPE   REG_SZ

#define DHCP_IPAUTOCONFIGURATION_SUBNET         TEXT("IPAutoconfigurationSubnet")
#define DHCP_IPAUTOCONFIGURATION_SUBNET_TYPE    REG_SZ

#define DHCP_IPAUTOCONFIGURATION_MASK           TEXT("IPAutoconfigurationMask")
#define DHCP_IPAUTOCONFIGURATION_MASK_TYPE      REG_SZ

#define DHCP_IPAUTOCONFIGURATION_SEED           TEXT("IPAutoconfigurationSeed")
#define DHCP_IPAUTOCONFIGURATION_SEED_TYPE      REG_DWORD

#define DHCP_OPTION_EXPIRATION_DATE             TEXT("ExpirationTime")
#define DHCP_OPTION_EXPIRATION_DATE_TYPE        REG_BINARY

#define DHCP_MACHINE_TYPE                       TEXT("MachineType")
#define DHCP_MACHINE_TYPE_TYPE                  REG_DWORD

#define DHCP_AUTONET_RETRIES_VALUE              TEXT("AutonetRetries")
#define DHCP_AUTONET_RETRIES_VALUE_TYPE         REG_DWORD

#define DHCP_ADDRESS_TYPE_VALUE                 TEXT("AddressType")
#define DHCP_ADDRESS_TYPE_TYPE                  REG_DWORD

#if DBG

#define DHCP_LEASE_OBTAINED_CTIME               TEXT("LeaseObtainedCTime"
#define DHCP_LEASE_OBTAINED_CTIME_TYPE          REG_SZ

#define DHCP_LEASE_T1_CTIME                     TEXT("T1CTime")
#define DHCP_LEASE_T1_CTIME_TYPE                REG_SZ

#define DHCP_LEASE_T2_CTIME                     TEXT("T2CTime")
#define DHCP_LEASE_T2_CTIME_TYPE                REG_SZ

#define DHCP_LEASE_TERMINATED_CTIME             TEXT("LeaseTerminatesCTime")
#define DHCP_LEASE_TERMINATED_CTIME_TYPE        REG_SZ

#define DHCP_OPTION_EXPIRATION_CDATE            TEXT("ExpirationCTime")
#define DHCP_OPTION_EXPIRATION_CDATE_TYPE       REG_SZ


#endif

// options api specials
#define DHCPAPI_VALID_VALUE                     TEXT("Valid")
#define DHCPAPI_VALID_VALUE_TYPE                REG_DWORD

#define DHCPAPI_AVAIL_VALUE                     TEXT("AvailableOptions")
#define DHCPAPI_AVAIL_VALUE_TYPE                REG_BINARY

#define DHCPAPI_REQUESTED_VALUE                 TEXT("RequestedOptions")
#define DHCPAPI_REQUESTED_VALUE_TYPE            REG_BINARY

#define DHCPAPI_RAW_OPTIONS_VALUE               TEXT("RawOptionsValue")
#define DHCPAPI_RAW_OPTIONS_VALUE_TYPE          REG_BINARY

#define DHCPAPI_RAW_LENGTH_VALUE                TEXT("RawOptionsLength")
#define DHCPAPI_RAW_LENGTH_VALUE_TYPE           REG_DWORD

#define DHCPAPI_GATEWAY_VALUE                   TEXT("LastGateWay")
#define DHCPAPI_GATEWAY_VALUE_TYPE              REG_DWORD

// this tag is used to locate dns updates requests on the renewal list
#define DHCP_DNS_UPDATE_CONTEXT_TAG             TEXT("DNSUpdateRetry")

// This semaphore cannot have backward slashes in it.
#define DHCP_REQUEST_OPTIONS_API_SEMAPHORE      TEXT("DhcpRequestOptionsAPI")

// the client vendor name (DhcpGlobalClientClassInfo) value is this..
#define DHCP_DEFAULT_CLIENT_CLASS_INFO          "MSFT 5.0"

// the location for storing options for DhcpRegisterOptions API.
// ****** Don't change the foll value -- it also changes DEFAULT_REGISTER_OPT_LOC above
//
#define DHCP_REGISTER_OPTIONS_LOC               DHCP_TCPIP_PARAMETERS_KEY L"\\Interfaces\\?\\DhcpRequestOptions"

//
// size of the largest adapter name in unicode.
//
#define ADAPTER_STRING_SIZE 512

//
// windows version info.
//

#define HOST_COMMENT_LENGTH                     128
#define WINDOWS_32S                             "Win32s on Windows 3.1"
#define WINDOWS_NT                              "Windows NT"

#define DHCP_NAMESERVER_BACKUP                  TEXT("Backup")
#define DHCP_NAMESERVER_BACKUP_LIST             TEXT("BackupList")

//
// Adapter Key - replacement character.
//
#define OPTION_REPLACE_CHAR                     L'\?'

//
// registry access key.
//

#define DHCP_CLIENT_KEY_ACCESS  (KEY_QUERY_VALUE |           \
                                    KEY_SET_VALUE |          \
                                    KEY_CREATE_SUB_KEY |     \
                                    KEY_ENUMERATE_SUB_KEYS)

//
// Dhcp registry class.
//

#define DHCP_CLASS                      TEXT("DhcpClientClass")
#define DHCP_CLASS_SIZE                 sizeof(DHCP_CLASS)


//
// Option ID key length.
//

#define DHCP_OPTION_KEY_LEN             32

//
// The name of the DHCP service DLL
//

#define DHCP_SERVICE_DLL                TEXT("dhcpcsvc.dll")

//
// command values for SetDefaultGateway function.

#define DEFAULT_GATEWAY_ADD             0
#define DEFAULT_GATEWAY_DELETE          1


//
// A block NT specific context information, appended the the DHCP work
// context block.
//

typedef struct _LOCAL_CONTEXT_INFO {
    DWORD  IpInterfaceContext;
    DWORD  IpInterfaceInstance;  // needed for BringUpInterface
    LPWSTR AdapterName;
#if     !defined(_PNP_POWER_)
    LPWSTR DeviceName;
#endif _PNP_POWER_
    LPWSTR NetBTDeviceName;
    LPWSTR RegistryKey;
    SOCKET Socket;
    BOOL DefaultGatewaysSet;
} LOCAL_CONTEXT_INFO, *PLOCAL_CONTEXT_INFO;

//
// Other service specific options info struct.
//

typedef struct _SERVICE_SPECIFIC_DHCP_OPTION {
    DHCP_OPTION_ID OptionId;
    LPWSTR RegKey;              // alloted memory.
    LPWSTR ValueName;           // embedded in the RegKey memory.
    DWORD ValueType;
    DWORD OptionLength;
#ifdef __DHCP_CLIENT_OPTIONS_API_ENABLED__
    time_t ExpirationDate; // this value is used to decide when to stop
                           // requested unneeded options.
#endif
    LPBYTE RawOptionValue;
} SERVICE_SPECIFIC_DHCP_OPTION, *LPSERVICE_SPECIFIC_DHCP_OPTION;


//
// Key query Info.
//

typedef struct _DHCP_KEY_QUERY_INFO {
    WCHAR Class[DHCP_CLASS_SIZE];
    DWORD ClassSize;
    DWORD NumSubKeys;
    DWORD MaxSubKeyLen;
    DWORD MaxClassLen;
    DWORD NumValues;
    DWORD MaxValueNameLen;
    DWORD MaxValueLen;
    DWORD SecurityDescriptorLen;
    FILETIME LastWriteTime;
} DHCP_KEY_QUERY_INFO, *LPDHCP_KEY_QUERY_INFO;

//
// Global variables.
//

//
// client specific option list.
//


EXTERN HINSTANCE DhcpGlobalMessageFileHandle;

EXTERN DWORD DhcpGlobalOptionCount;
EXTERN LPSERVICE_SPECIFIC_DHCP_OPTION DhcpGlobalOptionInfo;
EXTERN LPBYTE DhcpGlobalOptionList;

//
// Service variables
//

EXTERN SERVICE_STATUS DhcpGlobalServiceStatus;
EXTERN SERVICE_STATUS_HANDLE DhcpGlobalServiceStatusHandle;

//
// To signal to stop the service.
//

EXTERN HANDLE DhcpGlobalTerminateEvent;

//
// multi home flag.
//

EXTERN BOOL DhcpGlobalMultiHomedHost;

//
// Client APIs over name pipe variables.
//

EXTERN HANDLE DhcpGlobalClientApiPipe;
EXTERN HANDLE DhcpGlobalClientApiPipeEvent;
EXTERN OVERLAPPED DhcpGlobalClientApiOverLapBuffer;

//
// Message Popup Thread handle.
//

EXTERN HANDLE DhcpGlobalMsgPopupThreadHandle;
EXTERN BOOL DhcpGlobalDisplayPopup;
EXTERN CRITICAL_SECTION DhcpGlobalPopupCritSect;

#define LOCK_POPUP()   EnterCriticalSection(&DhcpGlobalPopupCritSect)
#define UNLOCK_POPUP() LeaveCriticalSection(&DhcpGlobalPopupCritSect)


//
// winsock variables.
//

EXTERN WSADATA DhcpGlobalWsaData;
EXTERN BOOL DhcpGlobalWinSockInitialized;

EXTERN BOOL DhcpGlobalGatewaysSet;

EXTERN BOOL DhcpGlobalIsService;

//
// a named event that notifies the ip address changes to
// external apps.
//

EXTERN HANDLE DhcpGlobalNewIpAddressNotifyEvent;
EXTERN UINT   DhcpGlobalIPEventSeqNo;


#endif // _LOCAL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\dllmain.cpp ===
/********************************************************************************
/    This is the base file to the Microsoft JScript Proxy Configuration 
/    This file implements the code to provide the script site and the JSProxy psuedo
/    object for the script engine to call against.
/
/    Created        11/27/96    larrysu
/
/
/
/
/
/
/
/
/
*/

#include "dllmain.h"

CScriptSite    *g_ScriptSite = NULL;
BOOL fOleInited = FALSE;

/*******************************************************************************
*    dll initialization and destruction

********************************************************************************/
EXTERN_C
BOOL APIENTRY DllMain(HMODULE hModule,DWORD ul_reason_for_call,LPVOID lpReserved)
{
    
    switch( ul_reason_for_call ) {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hModule);
        break;
    case DLL_PROCESS_DETACH:        
        break;
    }
    return TRUE;
}


STDAPI_(BOOL) AUTOCONF_InternetInitializeAutoProxyDll(DWORD dwVersion, 
                                                      LPSTR lpszDownloadedTempFile,
                                                      LPSTR lpszMime,
                                                      AUTO_PROXY_HELPER_APIS *pAutoProxyCallbacks, 
                                                      LPAUTO_PROXY_EXTERN_STRUC lpExtraData)
{
    HRESULT    hr = E_FAIL;
    HANDLE    hFile = 0;
    LPSTR    szScript = NULL;
    DWORD    dwFileSize = 0;
    DWORD    dwBytesRead = 0;
    LPSTR    result;
    LPSTR   szAllocatedScript = NULL;


    if ( !fOleInited ) 
    {
#ifndef unix
        CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
        CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
#endif /* unix */
    }


    // get the script text from the downloaded file!
    // open the file

    if ( lpExtraData == NULL ||
         lpExtraData->dwStructSize != sizeof(AUTO_PROXY_EXTERN_STRUC) ||
         lpExtraData->lpszScriptBuffer == NULL )
    {
        if (!lpszDownloadedTempFile)
            return FALSE;

        hFile = CreateFile((LPCSTR)lpszDownloadedTempFile,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
        if (hFile == INVALID_HANDLE_VALUE)
            return FALSE;

        // Get the size
        dwFileSize = GetFileSize(hFile,NULL);
        // allocate the buffer to hold the data.
        szScript = (LPSTR) GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,dwFileSize+1);
        szAllocatedScript = szScript;

        BOOL f = TRUE;
        // if the memory was allocated
        if (szScript)
        {
            // read the data
            f = ReadFile(hFile,(LPVOID) szScript,dwFileSize,&dwBytesRead,NULL);
        }
        CloseHandle(hFile);

        if (!f)
            goto Cleanup;
    }
    else
    {
        szScript = (LPSTR) lpExtraData->lpszScriptBuffer;
    }

    // Create a new CScriptSite object and initiate it with the autoconfig script.
    g_ScriptSite = new CScriptSite;
    if (g_ScriptSite)
        hr = g_ScriptSite->Init(pAutoProxyCallbacks, szScript);
    else
        hr = E_OUTOFMEMORY;

Cleanup:

    if ( szAllocatedScript ) 
    {
        // Free the script text
        GlobalFree(szAllocatedScript);
        szAllocatedScript = NULL;
    }

    if (SUCCEEDED(hr))
        return TRUE;
    else
        return FALSE;
}

// This function frees the script engine and destroys the script site.
EXTERN_C BOOL CALLBACK AUTOCONF_InternetDeInitializeAutoProxyDll(LPSTR lpszMime, DWORD dwReserved)
{

    // Release and destroy the CScriptSite object and initiate it with the autoconfig script.
    // DeInit the script site.
    if (g_ScriptSite)
    {
        g_ScriptSite->DeInit();
        g_ScriptSite->Release();
        g_ScriptSite = NULL;
    }

    if ( fOleInited ) 
    {
        CoUninitialize();    
    }

    return TRUE;
}

// This function is called when the host wants to run the script.
EXTERN_C BOOL CALLBACK InternetGetProxyInfo(LPCSTR lpszUrl,
                                            DWORD dwUrlLength,
                                            LPSTR lpszUrlHostName,
                                            DWORD dwUrlHostNameLength,
                                            LPSTR *lplpszProxyHostName,
                                            LPDWORD lpdwProxyHostNameLength)
{
    HRESULT    hr = S_OK;
    LPSTR    szHost;
    
    // The host passed in may be too big.  Copy it an make the 
    // HostLength + 1 position will be slammed with \0.
    szHost = (LPSTR) GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,dwUrlHostNameLength+1);
    if (!szHost)
        return FALSE;
    if(lpszUrlHostName && !lstrcpyn(szHost,lpszUrlHostName,dwUrlHostNameLength+1))
    {
        GlobalFree(szHost);
        return FALSE;
    }

    // construct a jscript call with the passed in url and host.
    if (g_ScriptSite)
//        hr = g_ScriptSite->RunScript(lpszUrl,lpszUrlHostName,lplpszProxyHostName);
        hr = g_ScriptSite->RunScript(lpszUrl,szHost,lplpszProxyHostName);

    GlobalFree(szHost);

    if (SUCCEEDED(hr))
    {
        *lpdwProxyHostNameLength = lstrlen(*lplpszProxyHostName) +1;
        return TRUE;
    }
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\ipconfig.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ipconfig.cxx

Abstract:

    CIpConfig class implementation

    Contents:
        CIpAddress::GetAddress

        CIpAddressList::Find
        CIpAddressList::Add(CIpAddress *)
        CIpAddressList::Add(DWORD, DWORD, DWORD)
        CIpAddressList::GetAddress
        CIpAddressList::ThrowOutUnfoundEntries

        CAdapterInterface::CAdapterInterface
        CAdapterInterface::~CAdapterInterface

        CIpConfig::CIpConfig
        CIpConfig::~CIpConfig
        CIpConfig::GetRouterAddress
        CIpConfig::GetDnsAddress
        CIpConfig::IsKnownIpAddress
        CIpConfig::Refresh
        (CIpConfig::GetAdapterList)
        (CIpConfig::LoadEntryPoints)
        (CIpConfig::UnloadEntryPoints)
        (CIpConfig::FindOrCreateInterface)
        (CIpConfig::FindInterface)
        (CIpConfig::ThrowOutUnfoundEntries)

        WsControl
        (WinNtWsControl)
        (OpenTcpipDriverHandle)
        (CloseTcpipDriverHandle)
        (GetEntityList)
        [InternetMapEntity]
        [InternetMapInterface]

Author:

    Richard L Firth (rfirth) 29-Oct-1996

Environment:

    Win32 user-mode DLL

Notes:

    In order to operate correctly, we require the Microsoft Winsock implementation
    (WSOCK32.DLL) and the Microsoft TCP/IP stack to be loaded

Revision History:

    29-Oct-1996 rfirth
        Created

    15-Jul-1998 arthurbi
        Resurrected from the dead

--*/

#include <wininetp.h>
#include "aproxp.h"
#include <dhcpcsdk.h>

//
// manifests
//

#define MAX_ADAPTER_DESCRIPTION_LENGTH  128 // arbitrary
//#define DEFAULT_MINIMUM_ENTITIES        MAX_TDI_ENTITIES

//
// macros
//

//
// IS_INTERESTING_ADAPTER - TRUE if the type of this adapter (IFEntry) is NOT
// loopback. Loopback (corresponding to local host) is the only one we filter
// out right now
//

#define IS_INTERESTING_ADAPTER(p)   (!((p)->if_type == IF_TYPE_LOOPBACK))
#define IS_INTERESTING_ADAPTER_NT5(p) (!((p)->Type == IF_TYPE_RFC877_X25))

//
// globals
//

const char SERVICES_KEY_NAME[] = "SYSTEM\\CurrentControlSet\\Services";

HKEY TcpipLinkageKey = NULL;//     = INVALID_HANDLE_VALUE;
HKEY ServicesKey = NULL;  //       = INVALID_HANDLE_VALUE;

BOOL CIpConfig::m_Loaded;


//
// private prototypes
//

PRIVATE
DWORD
WinNtWsControl(
    DWORD dwProtocol,
    DWORD dwRequest,
    LPVOID lpInputBuffer,
    LPDWORD lpdwInputBufferLength,
    LPVOID lpOutputBuffer,
    LPDWORD lpdwOutputBufferLength
    );

PRIVATE
DWORD
OpenTcpipDriverHandle(
    VOID
    );

PRIVATE
VOID
CloseTcpipDriverHandle(
    VOID
    );

PRIVATE
DWORD
GetEntityList(
    OUT TDIEntityID * * lplpEntities
    );

//
// private debug prototypes
//

PRIVATE
LPCSTR
InternetMapEntity(
    IN INT EntityId
    );

PRIVATE
LPCSTR
InternetMapInterface(
    IN DWORD InterfaceType
    );

PRIVATE
LPCSTR
InternetMapInterfaceOnNT5(
    IN DWORD InterfaceType
    );


//
// private data
//

//
// NTDLL info - if the platform is NT then we use the following entry points in
// NTDLL.DLL to talk to the TCP/IP device driver
//

PRIVATE VOID (* _I_RtlInitUnicodeString)(PUNICODE_STRING, PCWSTR) = NULL;
PRIVATE NTSTATUS (* _I_NtCreateFile)(PHANDLE,
                                     ACCESS_MASK,
                                     POBJECT_ATTRIBUTES,
                                     PIO_STATUS_BLOCK,
                                     PLARGE_INTEGER,
                                     ULONG,
                                     ULONG,
                                     ULONG,
                                     ULONG,
                                     PVOID,
                                     ULONG
                                     ) = NULL;
PRIVATE ULONG (* _I_RtlNtStatusToDosError)(NTSTATUS) = NULL;

PRIVATE DLL_ENTRY_POINT NtDllEntryPoints[] = {
    DLL_ENTRY_POINT_ELEMENT(RtlInitUnicodeString),
    DLL_ENTRY_POINT_ELEMENT(NtCreateFile),
    DLL_ENTRY_POINT_ELEMENT(RtlNtStatusToDosError)
};

PRIVATE DLL_INFO NtDllInfo = DLL_INFO_INIT("NTDLL.DLL", NtDllEntryPoints);

PRIVATE HANDLE TcpipDriverHandle = INVALID_HANDLE_VALUE;

//
// Iphlpapi - Ip Helper APIs only found on NT 5 and Win 98, must dynaload,
//   Used to gather information on what adapters are avaible on the machine
//

PRIVATE DWORD (PASCAL FAR * _I_GetAdaptersInfo)(PIP_ADAPTER_INFO,
                                          PULONG
                                          ) = NULL;

PRIVATE DLL_ENTRY_POINT IpHlpApiEntryPoints[] = {
    DLL_ENTRY_POINT_ELEMENT(GetAdaptersInfo)
};

PRIVATE DLL_INFO IpHlpApiDllInfo = DLL_INFO_INIT("IPHLPAPI.DLL", IpHlpApiEntryPoints);

//
// DhcpcSvc - DHCP dll, Only found on Win'98 and NT 5.  This function does almost all the
//   work for us using the native DHCP services found on these cool new OSes.
//

PRIVATE DWORD (__stdcall * _I_DhcpRequestParams)(DWORD,
                                LPVOID,
                                LPWSTR,
                                LPDHCPCAPI_CLASSID,
                                DHCPCAPI_PARAMS_ARRAY,
                                DHCPCAPI_PARAMS_ARRAY,
                                LPBYTE,
                                LPDWORD,
                                LPWSTR
                          ) = NULL;

PRIVATE DLL_ENTRY_POINT DhcpcSvcEntryPoints[] = {
    DLL_ENTRY_POINT_ELEMENT(DhcpRequestParams)
};

PRIVATE DLL_INFO DhcpcSvcDllInfo = DLL_INFO_INIT("DHCPCSVC.DLL", DhcpcSvcEntryPoints);


//
// global data
//

// none.

//
// methods
//

//
// public CIpAddress methods
//


BOOL
CIpAddress::GetAddress(
    OUT LPBYTE lpbAddress,
    IN OUT LPDWORD lpdwAddressLength
    )

/*++

Routine Description:

    Returns the IP address from this CIpAddress

Arguments:

    lpbAddress          - pointer to returned address

    lpdwAddressLength   - size of IP address

Return Value:

    BOOL
        TRUE    - address copied

        FALSE   - address not copied (buffer not large enough)

--*/

{
    if (*lpdwAddressLength >= sizeof(DWORD)) {
        *(LPDWORD)lpbAddress = m_dwIpAddress;
        *lpdwAddressLength = sizeof(DWORD);
        return TRUE;
    }
    return FALSE;
}


//
// public CIpAddressList methods
//

BOOL
CIpAddressList::IsContextInList(
    IN DWORD dwContext
    )
{
   for (CIpAddress * pEntry = m_List; pEntry != NULL; pEntry = pEntry->m_Next) {
       if (pEntry->Context() == dwContext) {
           return TRUE;
       }
   }
   return FALSE;
}




CIpAddress *
CIpAddressList::Find(
    IN DWORD dwIpAddress,
    IN DWORD dwIpMask
    )

/*++

Routine Description:

    Finds the CIpAddress object corresponding to (dwIpAddress, dwIpMask)

Arguments:

    dwIpAddress - IP address to find

    dwIpMask    - IP address mask, or INADDR_ANY (0) if we don't care

Return Value:

    CIpAddress *
        Success - pointer to found object

        Failure - NULL

--*/

{
    for (CIpAddress * pEntry = m_List; pEntry != NULL; pEntry = pEntry->m_Next) {
        if ((pEntry->IpAddress() == dwIpAddress)
        && ((dwIpMask == INADDR_ANY) || (pEntry->IpMask() == dwIpMask))) {
            break;
        }
    }
    return pEntry;
}


VOID
CIpAddressList::Add(
    IN CIpAddress * pAddress
    )

/*++

Routine Description:

    Adds an IP address entry to the list

Arguments:

    pAddress    - pointer to CIpAddress to add

Return Value:

    None.

--*/

{
    INET_ASSERT(pAddress->m_Next == NULL);

    CIpAddress * pEntry = (CIpAddress *)&m_List;

    while (pEntry->m_Next != NULL) {
        pEntry = pEntry->m_Next;
    }
    pEntry->m_Next = pAddress;
}


BOOL
CIpAddressList::Add(
    IN DWORD dwIpAddress,
    IN DWORD dwIpMask,
    IN DWORD dwContext
    )

/*++

Routine Description:

    Adds an IP address entry to the list

Arguments:

    dwIpAddress - IP address to add

    dwIpMask    - IP subnet mask

    dwContext   - unique interface context value

Return Value:

    BOOL
        TRUE    - item added

        FALSE   - out of memory

--*/

{
    CIpAddress * pIpAddress = new CIpAddress(dwIpAddress, dwIpMask, dwContext);

    if (pIpAddress != NULL) {
        Add(pIpAddress);
        return TRUE;
    }
    return FALSE;
}


BOOL
CIpAddressList::GetAddress(
    IN OUT LPDWORD lpdwIndex,
    OUT LPBYTE lpbAddress,
    IN OUT LPDWORD lpdwAddressLength
    )

/*++

Routine Description:

    Returns the *lpdwIndex'th address from the list

Arguments:

    lpdwIndex           - which address to return. Updated on output

    lpbAddress          - pointer to returned address

    lpdwAddressLength   - pointer to returned address length

Return Value:

    BOOL
        TRUE    - address returned

        FALSE   - address not returned

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpAddressList::GetAddress",
                 "%#x [%d], %#x, %#x [%d]",
                 lpdwIndex,
                 *lpdwIndex,
                 lpbAddress,
                 lpdwAddressLength,
                 *lpdwAddressLength
                 ));

    CIpAddress * p = m_List;

    for (DWORD i = 0; (i < *lpdwIndex) && (p != NULL); ++i) {
        p = p->m_Next;
    }

    BOOL found;

    if (p != NULL) {
        found = p->GetAddress(lpbAddress, lpdwAddressLength);
        if (found) {
            ++*lpdwIndex;
        }
    } else {
        found = FALSE;
    }

    DEBUG_LEAVE(found);

    return found;
}


PRIVATE
BOOL
CIpAddressList::ThrowOutUnfoundEntries(
    VOID
    )

/*++

Routine Description:

    Throws out (deletes) any addresses that are marked not-found

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - interfaces thrown out

        FALSE   -      "     not "   "

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpAddressList::ThrowOutUnfoundEntries",
                 NULL
                 ));

    CIpAddress * pLast = (CIpAddress *)&m_List;
    CIpAddress * pEntry;
    BOOL bThrownOut = FALSE;

    for (pEntry = m_List; pEntry != NULL; pEntry = pEntry->m_Next) {
        if (!pEntry->IsFound()) {
            pLast->m_Next = pEntry->m_Next;
            delete pEntry;
            bThrownOut = TRUE;
            pEntry = pLast;
        } else {
            pLast = pEntry;
        }
    }

    DEBUG_LEAVE(bThrownOut);

    return bThrownOut;
}

//
// public CAdapterInterface methods
//


CAdapterInterface::CAdapterInterface(
    IN DWORD dwIndex,
    IN DWORD dwType,
    IN DWORD dwSpeed,
    IN LPSTR lpszDescription,
    IN DWORD dwDescriptionLength,
    IN LPBYTE lpPhysicalAddress,
    IN DWORD dwPhysicalAddressLength
    )

/*++

Routine Description:

    CAdapterInterface constructor

Arguments:

    dwIndex             - unique adapter interface index

    dwType              - type of interface

    dwSpeed             - speed of interface

    lpszDescription     - pointer to descriptive name of adapter

    dwDescriptionLength - length of lpszDescription

    lpPhysicalAddress   -
    dwPhysicalAddressLength -


Return Value:

    None.

--*/

{
    if ((lpszDescription != NULL) && (dwDescriptionLength != 0)) {
        m_lpszDescription = new char[dwDescriptionLength + 1];
        if (m_lpszDescription != NULL) {
            memcpy(m_lpszDescription, lpszDescription, dwDescriptionLength);
        } else {
            dwDescriptionLength = 0;
        }
    }

    if ((lpPhysicalAddress != NULL) && (dwPhysicalAddressLength != 0)) {
        m_lpPhysicalAddress = new BYTE[dwPhysicalAddressLength];
        if ( m_lpPhysicalAddress != NULL ) {
            memcpy(m_lpPhysicalAddress, lpPhysicalAddress, dwPhysicalAddressLength);
        }
        else {
            dwPhysicalAddressLength = 0;
        }
    }

    switch( dwType )
    {
        case IF_TYPE_ETHERNET:
            m_dwPhysicalAddressType  = HARDWARE_TYPE_10MB_EITHERNET;
            break;

        case IF_TYPE_TOKENRING:
        case IF_TYPE_FDDI:
            m_dwPhysicalAddressType = HARDWARE_TYPE_IEEE_802;
            break;

        case IF_TYPE_OTHER:
            m_dwPhysicalAddressType = HARDWARE_ARCNET;
            break;

        case IF_TYPE_PPP:
            m_dwPhysicalAddressType = HARDWARE_PPP;
            break;

        case IF_TYPE_IEEE1394:
            m_dwPhysicalAddressType = HARDWARE_IEEE1394;
            break;

        default:
            m_dwPhysicalAddressType = HARDWARE_ARCNET;
            break;
    }

    m_dwPhysicalAddressLength = dwPhysicalAddressLength;
    m_dwDescriptionLength = dwDescriptionLength;
    m_lpszAdapterName = NULL;
    m_dwIndex = dwIndex;
    m_dwType = dwType;
    m_dwSpeed = dwSpeed;
    m_Flags.Word = 0;
    SetFound(TRUE);
}


CAdapterInterface::~CAdapterInterface(
    VOID
    )

/*++

Routine Description:

    CAdapterInterface destructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (m_lpszDescription != NULL) {
        delete m_lpszDescription;
    }

    if (m_lpPhysicalAddress != NULL) {
        delete m_lpPhysicalAddress;
    }

    if ( m_lpszAdapterName != NULL) {
        FREE_MEMORY(m_lpszAdapterName);
    }
}


BOOL
CAdapterInterface::DhcpDoInformNT5(
    OUT LPSTR * ppszAutoProxyUrl
    )

/*++

Routine Description:

     For a given Interface, this nifly little method uses the new wizbang NT 5/Win'98 specific API
       to do the DHCP Inform request and determine an auto-proxy Url that we can use.

     Kinda of nice when we're on NT 5, otherwise we need to pull in the kitchen sink equivlent of
       DHCP code that has been ripped off from the NT 4/Win'95 code base

Arguments:

    lpszAutoProxyUrl  - a piece of memory where we can stuff our new auto-proxy URL

    dwAutoProxyUrlLength - size of the space to store the string above

Return Value:

    BOOL
        TRUE    - successfully talked to server and got Url

        FALSE   - failed to allocate memory or failure talking to TCP/IP or failure to get an Url needed to continue

--*/

{
    DWORD   error;
    WCHAR   wszAdapterName[(MAX_ADAPTER_NAME_LENGTH + 6)];
    int     len;
    LPSTR   lpszAutoProxyUrl = NULL;

    len = MultiByteToWideChar(
        CP_ACP,
        0, // flags
        GetAdapterName(),
        -1, // assume null-terminated
        wszAdapterName,
        (MAX_ADAPTER_NAME_LENGTH + 6)
        );

    if ( len == 0 ) {
        return FALSE;  // failed to convert string
    }

    if (_I_DhcpRequestParams == NULL)
    {
        return FALSE;
    }

    DHCPCAPI_PARAMS_ARRAY   SendParams;
    DHCPCAPI_PARAMS_ARRAY   RecvParams;
    DHCPAPI_PARAMS          WpadParam;
    BYTE *                  pBuffer = NULL;
    BYTE                    Buffer[400];
    DWORD                   dwBufferSize = sizeof(Buffer);

    ZeroMemory(&WpadParam, sizeof(WpadParam));
    WpadParam.OptionId = OPTION_WPAD_URL;
    WpadParam.IsVendor = FALSE;

    SendParams.nParams = 0;
    SendParams.Params  = NULL;

    RecvParams.nParams = 1;
    RecvParams.Params  = &WpadParam;

    error = _I_DhcpRequestParams(
                DHCPCAPI_REQUEST_SYNCHRONOUS,
                NULL,
                wszAdapterName,
                NULL,
                SendParams,
                RecvParams,
                Buffer,
                &dwBufferSize,
                NULL
                );

    if (error == ERROR_MORE_DATA)
    {
        dwBufferSize += 400;

        pBuffer = new BYTE[dwBufferSize];

        if (pBuffer != NULL)
        {
            ZeroMemory(&WpadParam, sizeof(WpadParam));

            WpadParam.OptionId = OPTION_WPAD_URL;
            WpadParam.IsVendor = FALSE;

            SendParams.nParams = 0;
            SendParams.Params  = NULL;

            RecvParams.nParams = 1;
            RecvParams.Params  = &WpadParam;

            error = _I_DhcpRequestParams(
                        DHCPCAPI_REQUEST_SYNCHRONOUS,
                        NULL,
                        wszAdapterName,
                        NULL,
                        SendParams,
                        RecvParams,
                        pBuffer,
                        &dwBufferSize,
                        NULL
                        );
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (error == ERROR_SUCCESS && WpadParam.Data != NULL && WpadParam.nBytesData != 0)
    {
        lpszAutoProxyUrl = NewString((LPCSTR)WpadParam.Data, WpadParam.nBytesData);

        if (lpszAutoProxyUrl)
        {
            *ppszAutoProxyUrl = lpszAutoProxyUrl;
        }

    }

    if (pBuffer)
        delete [] pBuffer;

    return (lpszAutoProxyUrl != NULL);
}



BOOL
CAdapterInterface::CopyAdapterInfoToDhcpContext(
    PDHCP_CONTEXT pDhcpContext
    )
{
    memset ((void *) pDhcpContext, 0, sizeof(DHCP_CONTEXT));

    // hardware address, length, and type
    pDhcpContext->HardwareAddressType = m_dwPhysicalAddressType;
    pDhcpContext->HardwareAddress = m_lpPhysicalAddress;
    pDhcpContext->HardwareAddressLength = m_dwPhysicalAddressLength;

    if (m_IpList.m_List) {
        // Selected IpAddress, NetworkOrder. htonl
        // note: assumed to be in network order
        pDhcpContext->IpAddress = ((m_IpList.m_List)->IpAddress());
        pDhcpContext->IpInterfaceContext = ((m_IpList.m_List)->Context());
    }

    if (m_DhcpList.m_List) {
        // Selected DHCP server address. Network Order. htonl
        // note: assumed to be in network order
        pDhcpContext->DhcpServerAddress = ((m_DhcpList.m_List)->IpAddress());
    }

    pDhcpContext->ClientIdentifier.fSpecified = FALSE;
    pDhcpContext->T2Time = 0;
    // when was the last time an inform was sent?
    pDhcpContext->LastInformSent = 0;
    // seconds passed since boot.
    pDhcpContext->SecondsSinceBoot = 0;

    // the list of options to send and the list of options received
    InitializeListHead(&pDhcpContext->RecdOptionsList);
    InitializeListHead(&pDhcpContext->SendOptionsList);

    // the class this adapter belongs to

    if (  m_lpszAdapterName )
    {
        pDhcpContext->ClassId = (unsigned char *) m_lpszAdapterName;
        pDhcpContext->ClassIdLength = lstrlen(m_lpszAdapterName);
    }
    else
    {
        pDhcpContext->ClassId = NULL;
        pDhcpContext->ClassIdLength = 0;
    }

    // Message buffer to send and receive DHCP message.
    pDhcpContext->MessageBuffer = (PDHCP_MESSAGE) pDhcpContext->szMessageBuffer;
    memset(pDhcpContext->szMessageBuffer, 0, sizeof(pDhcpContext->szMessageBuffer));

    //LocalInfo = (PLOCAL_CONTEXT_INFO)((*pDhcpContext)->LocalInformation);
    //LocalInfo->IpInterfaceContext = IpInterfaceContext;
    //LocalInfo->IpInterfaceInstance = IpInterfaceInstance;
    // IpInterfaceInstance is filled in make context

    pDhcpContext->Socket = INVALID_SOCKET;
    pDhcpContext->State.Plumbed = TRUE;
    pDhcpContext->State.ServerReached = FALSE;
    pDhcpContext->State.AutonetEnabled= FALSE;
    pDhcpContext->State.HasBeenLooked = FALSE;
    pDhcpContext->State.DhcpEnabled   = FALSE;
    pDhcpContext->State.AutoMode      = FALSE;
    pDhcpContext->State.MediaState    = FALSE;
    pDhcpContext->State.MDhcp         = FALSE;
    pDhcpContext->State.PowerResumed  = FALSE;
    pDhcpContext->State.Broadcast     = FALSE;

    return TRUE;
}



//
// public CIpConfig methods
//


CIpConfig::CIpConfig(
    VOID
    )

/*++

Routine Description:

    CIpConfig constructor - initializes the object & loads the requird DLLs if
    not already loaded

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CIpConfig::CIpConfig",
                 NULL
                 ));

    InitializeListHead(&m_List);
    m_dwNumberOfInterfaces = 0;

    DWORD error = LoadEntryPoints();

    if (error == ERROR_SUCCESS) {
#ifndef unix
        GetAdapterList();
#endif /* unix */
    }

    DEBUG_LEAVE(0);
}


CIpConfig::~CIpConfig()

/*++

Routine Description:

    CIpConfig destructor - destroys this object and unloads (or reduces the
    reference count on) the DLLs

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CIpConfig::~CIpConfig",
                 NULL
                 ));

    while (!IsListEmpty(&m_List)) {

        PLIST_ENTRY pEntry = RemoveHeadList(&m_List);

        //
        // BUGBUG - need CONTAINING_RECORD() if m_List is not @ start of
        //          CAdapterInterface
        //

        CAdapterInterface * pInterface = (CAdapterInterface *)pEntry;

        delete pInterface;
    }

    CloseTcpipDriverHandle();

    DEBUG_LEAVE(0);
}


BOOL
CIpConfig::GetRouterAddress(
    IN LPBYTE lpbInterfaceAddress OPTIONAL,
    IN DWORD dwInterfaceAddressLength,
    IN OUT LPDWORD lpdwIndex,
    OUT LPBYTE lpbAddress,
    IN OUT LPDWORD lpdwAddressLength
    )

/*++

Routine Description:

    Returns the *lpdwIndex'th router address belonging to the interface
    corresponding to the address in lpbInterfaceAddress

Arguments:

    lpbInterfaceAddress         - pointer to interface address

    dwInterfaceAddressLength    - length of interface address

    lpdwIndex                   - index of router address to return

    lpbAddress                  - returned router address

    lpdwAddressLength           - length of router address

Return Value:

    BOOL
        TRUE    - *lpdwIndex'th router address returned for requested interface

        FALSE   - requested address not returned

--*/

{   
    UNREFERENCED_PARAMETER(lpbInterfaceAddress); 
    UNREFERENCED_PARAMETER(dwInterfaceAddressLength);
    UNREFERENCED_PARAMETER(lpdwIndex);
    UNREFERENCED_PARAMETER(lpbAddress);
    UNREFERENCED_PARAMETER(lpdwAddressLength);

    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::GetRouterAddress",
                 "%#x, %d, %#x [%d], %#x, %#x [%d]",
                 lpbInterfaceAddress,
                 dwInterfaceAddressLength,
                 lpdwIndex,
                 *lpdwIndex,
                 lpbAddress,
                 lpdwAddressLength,
                 *lpdwAddressLength
                 ));

    //
    // for now, we default to 1st interface
    //

    INET_ASSERT(lpbInterfaceAddress == NULL);
    INET_ASSERT(dwInterfaceAddressLength == sizeof(DWORD));

    BOOL found;

    //
    // no one uses this any more
    //

    INET_ASSERT(FALSE);

    //if (!IsListEmpty(&m_List)) {
    //    found = ((CAdapterInterface *)m_List.Flink)->m_RouterList.GetAddress(
    //                lpdwIndex,
    //                lpbAddress,
    //                lpdwAddressLength
    //                );
    //} else {
        found = FALSE;
    //}

    DEBUG_LEAVE(found);

    return found;
}


BOOL
CIpConfig::GetDnsAddress(
    IN LPBYTE lpbInterfaceAddress OPTIONAL,
    IN DWORD dwInterfaceAddressLength,
    IN OUT LPDWORD lpdwIndex,
    OUT LPBYTE lpbAddress,
    IN OUT LPDWORD lpdwAddressLength
    )

/*++

Routine Description:

    Returns the *lpdwIndex'th DNS address belonging to the interface
    corresponding to the address in lpbInterfaceAddress

Arguments:

    lpbInterfaceAddress         - pointer to interface address

    dwInterfaceAddressLength    - length of interface address

    lpdwIndex                   - index of DNS address to return

    lpbAddress                  - returned DNS address

    lpdwAddressLength           - length of DNS address

Return Value:

    BOOL
        TRUE    - *lpdwIndex'th DNS address returned for requested interface

        FALSE   - requested address not returned

--*/

{
    UNREFERENCED_PARAMETER(lpbInterfaceAddress);
    UNREFERENCED_PARAMETER(dwInterfaceAddressLength);
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::GetDnsAddress",
                 "%#x, %d, %#x [%d], %#x, %#x [%d]",
                 lpbInterfaceAddress,
                 dwInterfaceAddressLength,
                 lpdwIndex,
                 *lpdwIndex,
                 lpbAddress,
                 lpdwAddressLength,
                 *lpdwAddressLength
                 ));

    //
    // for now, we only return the global DNS info
    //

    INET_ASSERT(lpbInterfaceAddress == NULL);
    INET_ASSERT(dwInterfaceAddressLength == sizeof(DWORD));

    BOOL found;

    if (!m_DnsList.IsEmpty()) {
        found = m_DnsList.GetAddress(lpdwIndex,
                                     lpbAddress,
                                     lpdwAddressLength
                                     );
    } else {
        found = FALSE;
    }

    DEBUG_LEAVE(found);

    return found;
}


BOOL
CIpConfig::IsKnownIpAddress(
    IN LPBYTE lpbInterfaceAddress OPTIONAL,
    IN DWORD dwInterfaceAddressLength,
    IN LPBYTE lpbAddress,
    IN DWORD dwAddressLength
    )

/*++

Routine Description:

    Return TRUE if lpbAddress is a known interface address

Arguments:

    lpbInterfaceAddress         - pointer to interface address

    dwInterfaceAddressLength    - length of interface address

    lpbAddress                  - pointer to address to check

    dwAddressLength             - length of address

Return Value:

    BOOL

--*/

{
    UNREFERENCED_PARAMETER(lpbInterfaceAddress);
    UNREFERENCED_PARAMETER(dwInterfaceAddressLength);
    UNREFERENCED_PARAMETER(dwAddressLength);
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::IsKnownIpAddress",
                 "%#x, %d, %#x, %d",
                 lpbInterfaceAddress,
                 dwInterfaceAddressLength,
                 lpbAddress,
                 dwAddressLength
                 ));

    BOOL found = FALSE;

    for (CAdapterInterface * pEntry = (CAdapterInterface *)m_List.Flink;
         pEntry != (CAdapterInterface *)&m_List.Flink;
         pEntry = (CAdapterInterface *)pEntry->m_List.Flink) {

        if (pEntry->FindIpAddress(*(LPDWORD)lpbAddress)) {
            found = TRUE;
            break;
        }
    }

    DEBUG_LEAVE(found);

    return found;
}


BOOL
CIpConfig::Refresh(
    VOID
    )

/*++

Routine Description:

    Refreshes the interface information - re-reads the interfaces and IP
    addresses

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - interfaces or IP address changed

        FALSE   - nothing changed

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::Refresh",
                 NULL
                 ));

    BOOL bChanged;

    GetAdapterList(&bChanged);

    if (bChanged) {
//dprintf("flushing hostent cache\n");
//        FlushHostentCache();
    }

    DEBUG_LEAVE(bChanged);

    return bChanged;
}

//
// private CIpConfig methods
//


PRIVATE
BOOL
CIpConfig::GetAdapterList(
    OUT LPBOOL lpbChanged
    )

/*++

Routine Description:

    Builds a list of interfaces corresponding to physical and logical adapters,
      Uses Win'95 and NT 4 private VxD driver/registry entry points to get this data.

Arguments:

    lpbChanged  - if present, returns interface changed state

Return Value:

    BOOL
        TRUE    - successfully built list

        FALSE   - failed to allocate memory or failure talking to TCP/IP

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::GetAdapterList",
                 "%#x",
                 lpbChanged
                 ));

    TCP_REQUEST_QUERY_INFORMATION_EX req;
    TDIObjectID id;
    UINT numberOfEntities;
    TDIEntityID* pEntity;
    TDIEntityID* entityList = NULL;
    IPRouteEntry* routeTable = NULL;
    LPVOID buffer = NULL;
    DWORD status;
    DWORD inputLen;
    DWORD outputLen;
    BOOL ok = FALSE;
    UINT i; // major loop index
    UINT j; // minor loop index
    BOOL bChanged = FALSE;

    //
    // default is interfaces unchanged
    //

    if (lpbChanged) {
        *lpbChanged = FALSE;
    }

    //
    // On NT 5 we override and use a different method for
    //   getting network settings.
    //

    if ( GlobalPlatformVersion5 ) {
        return GetAdapterListOnNT5();
    }

    //
    // get the list of entities supported by TCP/IP then make 2 passes on the
    // list. Pass 1 scans for IF_ENTITY's (interface entities perhaps?) which
    // describe adapter instances (physical and virtual). Once we have our list
    // of adapters, on pass 2 we look for CL_NL_ENTITY's (connection-less
    // network layer entities peut-etre?) which will give us the list of IP
    // addresses for the adapters we found in pass 1
    //

    numberOfEntities = GetEntityList(&entityList);
    if (numberOfEntities == 0) {

        INET_ASSERT(entityList == NULL);

        DEBUG_PRINT(UTIL,
                    ERROR,
                    ("GetAdapterList: failed to get entity list\n"
                    ));

        goto quit;
    }

    //
    // first off, mark all the current interfaces (if any), including current
    // IP addresses, as not found
    //

    SetNotFound();

    //
    // pass 1
    //

    for (i = 0, pEntity = entityList; i < numberOfEntities; ++i, ++pEntity) {

        DEBUG_PRINT(UTIL,
                    INFO,
                    ("Pass 1: Entity %#x (%s) Instance #%d\n",
                    pEntity->tei_entity,
                    InternetMapEntity(pEntity->tei_entity),
                    pEntity->tei_instance
                    ));

        if (pEntity->tei_entity != IF_ENTITY) {

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("Entity %#x (%s) Instance #%d not IF_ENTITY - skipping\n",
                        pEntity->tei_entity,
                        InternetMapEntity(pEntity->tei_entity),
                        pEntity->tei_instance
                        ));

            continue;
        }

        //
        // IF_ENTITY: this entity/instance describes an adapter
        //

        DWORD isMib;
        BYTE info[sizeof(IFEntry) + MAX_ADAPTER_DESCRIPTION_LENGTH + 1];
        IFEntry* pIfEntry = (IFEntry*)info;
        int len;

        //
        // find out if this entity supports MIB requests
        //

        memset(&req, 0, sizeof(req));

        id.toi_entity = *pEntity;
        id.toi_class = INFO_CLASS_GENERIC;
        id.toi_type = INFO_TYPE_PROVIDER;
        id.toi_id = ENTITY_TYPE_ID;

        req.ID = id;

        inputLen = sizeof(req);
        outputLen = sizeof(isMib);

        status = WsControl(IPPROTO_TCP,
                           WSCNTL_TCPIP_QUERY_INFO,
                           (LPVOID)&req,
                           &inputLen,
                           (LPVOID)&isMib,
                           &outputLen
                           );

        //
        // BUGBUG - this returns 0 as outputLen
        //

//        if ((status != TDI_SUCCESS) || (outputLen != sizeof(isMib))) {
        if (status != TDI_SUCCESS) {

            //
            // unexpected results - bail out
            //

            DEBUG_PRINT(UTIL,
                        ERROR,
                        ("WsControl(ENTITY_TYPE_ID): status = %d, outputLen = %d\n",
                        status,
                        outputLen
                        ));

            goto error_exit;
        }
        if (isMib != IF_MIB) {

            //
            // entity doesn't support MIB requests - try another
            //

            DEBUG_PRINT(UTIL,
                        WARNING,
                        ("Entity %#x, Instance #%d doesn't support MIB (%#x)\n",
                        id.toi_entity.tei_entity,
                        id.toi_entity.tei_instance,
                        isMib
                        ));

            continue;
        }

        //
        // MIB requests supported - query the adapter info
        //

        id.toi_class = INFO_CLASS_PROTOCOL;
        id.toi_id = IF_MIB_STATS_ID;

        memset(&req, 0, sizeof(req));
        req.ID = id;

        inputLen = sizeof(req);
        outputLen = sizeof(info);

        status = WsControl(IPPROTO_TCP,
                           WSCNTL_TCPIP_QUERY_INFO,
                           (LPVOID)&req,
                           &inputLen,
                           (LPVOID)info,
                           &outputLen
                           );
        if (status != TDI_SUCCESS) {

            //
            // unexpected results - bail out
            //

            DEBUG_PRINT(UTIL,
                        ERROR,
                        ("WsControl(IF_MIB_STATS_ID) returns %d\n",
                        status
                        ));

            goto error_exit;
        }

        //
        // we only want physical adapters
        //

        if (!IS_INTERESTING_ADAPTER(pIfEntry)) {

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("ignoring adapter #%d [%s]\n",
                        pIfEntry->if_index,
                        InternetMapInterface(pIfEntry->if_type)
                        ));

            continue;
        }

        //
        // got this adapter info ok. Find or create an interface object and fill
        // in what we can
        //

        CAdapterInterface * pInterface;

        len = min(MAX_ADAPTER_ADDRESS_LENGTH, (size_t)pIfEntry->if_physaddrlen);

        pInterface = FindOrCreateInterface(pIfEntry->if_index,
                                           pIfEntry->if_type,
                                           pIfEntry->if_speed,
                                           (LPSTR)pIfEntry->if_descr,
                                           pIfEntry->if_descrlen,
                                           (LPBYTE)pIfEntry->if_physaddr,
                                           (DWORD) len
                                           );
        if (pInterface == NULL) {

            DEBUG_PRINT(UTIL,
                        ERROR,
                        ("failed to allocate memory for CAdapterInterface\n"
                        ));

            goto error_exit;
        }
    }

    //
    // pass 2
    //

    for (i = 0, pEntity = entityList; i < numberOfEntities; ++i, ++pEntity) {

        DEBUG_PRINT(UTIL,
                    INFO,
                    ("Pass 2: Entity %#x (%s) Instance %d\n",
                    pEntity->tei_entity,
                    InternetMapEntity(pEntity->tei_entity),
                    pEntity->tei_instance
                    ));

        if (pEntity->tei_entity != CL_NL_ENTITY) {

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("Entity %#x (%s) Instance %d - not CL_NL_ENTITY - skipping\n",
                        pEntity->tei_entity,
                        InternetMapEntity(pEntity->tei_entity),
                        pEntity->tei_instance
                        ));

            continue;
        }

        IPSNMPInfo info;
        DWORD type;

        //
        // first off, see if this network layer entity supports IP
        //

        memset(&req, 0, sizeof(req));

        id.toi_entity = *pEntity;
        id.toi_class = INFO_CLASS_GENERIC;
        id.toi_type = INFO_TYPE_PROVIDER;
        id.toi_id = ENTITY_TYPE_ID;

        req.ID = id;

        inputLen = sizeof(req);
        outputLen = sizeof(type);

        status = WsControl(IPPROTO_TCP,
                           WSCNTL_TCPIP_QUERY_INFO,
                           (LPVOID)&req,
                           &inputLen,
                           (LPVOID)&type,
                           &outputLen
                           );

        //
        // BUGBUG - this returns 0 as outputLen
        //

//        if ((status != TDI_SUCCESS) || (outputLen != sizeof(type))) {
        if (status != TDI_SUCCESS) {

            //
            // unexpected results - bail out
            //

            DEBUG_PRINT(UTIL,
                        ERROR,
                        ("WsControl(ENTITY_TYPE_ID): status = %d, outputLen = %d\n",
                        status,
                        outputLen
                        ));

            goto error_exit;
        }
        if (type != CL_NL_IP) {

            //
            // nope, not IP - try next one
            //

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("CL_NL_ENTITY #%d not CL_NL_IP - skipping\n",
                        pEntity->tei_instance
                        ));

            continue;
        }

        //
        // okay, this NL provider supports IP. Let's get them addresses: First
        // we find out how many by getting the SNMP stats and looking at the
        // number of addresses supported by this interface
        //

        memset(&req, 0, sizeof(req));

        id.toi_class = INFO_CLASS_PROTOCOL;
        id.toi_id = IP_MIB_STATS_ID;

        req.ID = id;

        inputLen = sizeof(req);
        outputLen = sizeof(info);

        status = WsControl(IPPROTO_TCP,
                           WSCNTL_TCPIP_QUERY_INFO,
                           (LPVOID)&req,
                           &inputLen,
                           (LPVOID)&info,
                           &outputLen
                           );
        if ((status != TDI_SUCCESS) || (outputLen != sizeof(info))) {

            //
            // unexpected results - bail out
            //

            DEBUG_PRINT(UTIL,
                        ERROR,
                        ("WsControl(IP_MIB_STATS_ID): status = %d, outputLen = %d\n",
                        status,
                        outputLen
                        ));

            goto error_exit;
        }

        //
        // get the IP addresses & subnet masks
        //

        if (info.ipsi_numaddr != 0) {

            //
            // this interface has some addresses. What are they?
            //

            UINT numberOfAddresses;
            IPAddrEntry* pAddr;

            outputLen = info.ipsi_numaddr * sizeof(IPAddrEntry);
            buffer = (LPVOID)ALLOCATE_MEMORY(outputLen);
            if (buffer == NULL) {

                //
                // unexpected results - bail out
                //

                DEBUG_PRINT(UTIL,
                            ERROR,
                            ("failed to allocate %d bytes\n",
                            outputLen
                            ));

                goto error_exit;
            }

            memset(&req, 0, sizeof(req));

            id.toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;

            req.ID = id;

            inputLen = sizeof(req);

            status = WsControl(IPPROTO_TCP,
                               WSCNTL_TCPIP_QUERY_INFO,
                               (LPVOID)&req,
                               &inputLen,
                               (LPVOID)buffer,
                               &outputLen
                               );
            if (status != TDI_SUCCESS) {

                //
                // unexpected results - bail out
                //

                DEBUG_PRINT(UTIL,
                            ERROR,
                            ("WsControl(IP_MIB_ADDRTABLE_ENTRY_ID): status = %d, outputLen = %d\n",
                            status,
                            outputLen
                            ));

                goto error_exit;
            }

            //
            // now loop through this list of IP addresses, applying them
            // to the correct adapter
            //

            numberOfAddresses = min((UINT)(outputLen / sizeof(IPAddrEntry)),
                                    (UINT)info.ipsi_numaddr
                                    );

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("%d IP addresses\n",
                        numberOfAddresses
                        ));

            pAddr = (IPAddrEntry *)buffer;
            for (j = 0; j < numberOfAddresses; ++j, ++pAddr) {

                DEBUG_PRINT(UTIL,
                            INFO,
                            ("IP address %d.%d.%d.%d, index %d, context %d\n",
                            ((LPBYTE)&pAddr->iae_addr)[0] & 0xff,
                            ((LPBYTE)&pAddr->iae_addr)[1] & 0xff,
                            ((LPBYTE)&pAddr->iae_addr)[2] & 0xff,
                            ((LPBYTE)&pAddr->iae_addr)[3] & 0xff,
                            pAddr->iae_index,
                            pAddr->iae_context
                            ));

                CAdapterInterface * pInterface = FindInterface(pAddr->iae_index);

                if (pInterface != NULL) {

                    CIpAddress * pIpAddress;

                    pIpAddress = pInterface->m_IpList.Find(pAddr->iae_addr,
                                                           pAddr->iae_mask
                                                           );
                    if (pIpAddress == NULL) {
                        pInterface->m_IpList.Add(pAddr->iae_addr,
                                                 pAddr->iae_mask,
                                                 pAddr->iae_context
                                                 );

                        //
                        // added an address - interface is changed
                        //
//dprintf("adding IP address %d.%d.%d.%d - changed\n",
//        ((LPBYTE)&pAddr->iae_addr)[0] & 0xff,
//        ((LPBYTE)&pAddr->iae_addr)[1] & 0xff,
//        ((LPBYTE)&pAddr->iae_addr)[2] & 0xff,
//        ((LPBYTE)&pAddr->iae_addr)[3] & 0xff
//        );
                        bChanged = TRUE;
                    } else {

                        INET_ASSERT(pAddr->iae_context == pIpAddress->Context());

                        pIpAddress->SetFound(TRUE);
                    }
                }
            }

            INET_ASSERT(buffer);

            FREE_MEMORY(buffer);

            buffer = NULL;
        }
    }

    //
    // add the DNS servers, read from registry or DHCP depending on platform.
    // Even if we don't get any DNS servers, we deem that this function has
    // succeeded
    //

    char dnsBuffer[1024];   // arbitrary (how many DNS entries?)
    UINT error;

    error = SockGetSingleValue(CONFIG_NAME_SERVER,
                               (LPBYTE)dnsBuffer,
                               sizeof(dnsBuffer)
                               );
    if (error == ERROR_SUCCESS) {
        //m_DnsList.Clear();

        char ipString[4 * 4];
        LPSTR p = dnsBuffer;
        DWORD buflen = (DWORD)lstrlen(dnsBuffer);

        do {
            if (SkipWhitespace(&p, &buflen)) {

                i = 0;

                while ((*p != '\0')
                       && (*p != ',')
                       && (buflen != 0)
                       && (i < sizeof(ipString))
                       && !isspace(*p)) {
                    ipString[i++] = *p++;
                    --buflen;
                }
                ipString[i] = '\0';

                DWORD ipAddress = _I_inet_addr(ipString);

                if (IS_VALID_NON_LOOPBACK_IP_ADDRESS(ipAddress)) {

                    CIpAddress * pIpAddress;

                    pIpAddress = m_DnsList.Find(ipAddress);
                    if (pIpAddress == NULL) {
                        m_DnsList.Add(ipAddress);

                        //
                        // added a DNS address - interface is changed
                        //

//dprintf("adding DNS address %d.%d.%d.%d - changed\n",
//        ((LPBYTE)&ipAddress)[0] & 0xff,
//        ((LPBYTE)&ipAddress)[1] & 0xff,
//        ((LPBYTE)&ipAddress)[2] & 0xff,
//        ((LPBYTE)&ipAddress)[3] & 0xff
//        );
                        bChanged = TRUE;
                    } else {
                        pIpAddress->SetFound(TRUE);
                    }
                }
                while ((*p == ',') && (buflen != 0)) {
                    ++p;
                    --buflen;
                }
            } else {
                break;
            }
        } while (TRUE);
    }

    //
    // Refresh registry settings of DHCP server stuff
    //  and figure out what DHCP server we have
    //

    GetAdapterInfo();

    //
    // throw out any adapter interfaces which were not found this time. This may
    // happen if we support PnP devices that are unplugged
    //

    BOOL bThrownOut;

    bThrownOut = ThrowOutUnfoundEntries();
    if (!bChanged) {
        bChanged = bThrownOut;
    }

    INET_ASSERT(entityList != NULL);

    FREE_MEMORY(entityList);

    ok = TRUE;

    //
    // return the change state of the interfaces, if required
    //

    if (lpbChanged) {
        *lpbChanged = bChanged;
    }

quit:

    if (routeTable != NULL) {
        FREE_MEMORY(routeTable);
    }

    if (buffer != NULL) {
        FREE_MEMORY(buffer);
    }

    DEBUG_LEAVE(ok);

    return ok;

error_exit:

    //
    // here because of an error. Throw out all interfaces
    //

    SetNotFound();
    ThrowOutUnfoundEntries();

    INET_ASSERT(!ok);

    goto quit;
}



PRIVATE
BOOL
CIpConfig::GetAdapterListOnNT5(
    OUT LPBOOL lpbChanged
    )

/*++

Routine Description:

    Builds a list of interfaces corresponding to physical and logical adapters
     using the new NT 5 and Win98 APIs.

Arguments:

    lpbChanged  - if present, returns interface changed state

Return Value:

    BOOL
        TRUE    - successfully built list

        FALSE   - failed to allocate memory or failure talking to TCP/IP

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::GetAdapterListOnNT5",
                 "%#x",
                 lpbChanged
                 ));

    BOOL ok = FALSE;
    BOOL bChanged = FALSE;
    int len;

    PIP_ADAPTER_INFO pAdapterInfo = NULL;
    PIP_ADAPTER_INFO pAdapterInfoAllocation = NULL;
    DWORD dwError;
    ULONG uSize;

    //
    // Load the IPHLPAPI DLL, cause we need this function find adapter info on NT 5/Win98
    //

    if (_I_GetAdaptersInfo == NULL )
    {
        DEBUG_PRINT(UTIL,
            ERROR,
            ("GetAdapterListOnNT5: IPHLPAPI dll could not be found with correct entry point\n"
            ));

        goto quit;
    }

    //
    // get the list of adapters supported by TCP/IP
    //

    uSize = sizeof(IP_ADAPTER_INFO) * 5;

    pAdapterInfoAllocation = (IP_ADAPTER_INFO *) ALLOCATE_FIXED_MEMORY(uSize);

    // Alias the pAdapterInfoAllocation pointer. pAdapterInfo will be used
    // to traverse the list of adapter info records. We need the
    // pAdapterInfoAllocation pointer in order to free the memory block at
    // the end of this function.
    pAdapterInfo = pAdapterInfoAllocation;

    if (pAdapterInfo == NULL)
    {
        goto quit;
    }

    dwError = _I_GetAdaptersInfo(pAdapterInfo, &uSize);

    if (dwError == ERROR_BUFFER_OVERFLOW)
    {
        pAdapterInfoAllocation = (IP_ADAPTER_INFO *) ResizeBuffer(pAdapterInfoAllocation, uSize, FALSE);

        pAdapterInfo = pAdapterInfoAllocation;

        if (pAdapterInfo == NULL)
        {
            goto quit;
        }

        dwError = _I_GetAdaptersInfo(pAdapterInfo, &uSize);
    }

    if ( dwError != ERROR_SUCCESS )
    {

        DEBUG_PRINT(UTIL,
            ERROR,
            ("GetAdapterListOnNT5: failed to get adapters list\n"
            ));

        goto quit;
    }

    //
    // first off, mark all the current interfaces (if any), including current
    // IP addresses, as not found
    //

    SetNotFound();

    //
    // pass 1
    //

    for (; pAdapterInfo; pAdapterInfo = pAdapterInfo->Next)
    {

        DEBUG_PRINT(UTIL,
                    INFO,
                    ("Adapter Pass: [#%u] Adapter name=%s, description=%s\n",
                    pAdapterInfo->Index,
                    pAdapterInfo->AdapterName,
                    pAdapterInfo->Description
                    ));

        //
        // we only want physical adapters
        //

        if (!IS_INTERESTING_ADAPTER_NT5(pAdapterInfo)) {

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("ignoring adapter #%u [%s]\n",
                        pAdapterInfo->Index,
                        InternetMapInterfaceOnNT5(pAdapterInfo->Type)
                        ));

            continue;
        }

        //
        // got this adapter info ok. Find or create an interface object and fill
        // in what we can
        //

        CAdapterInterface * pInterface;

        len = min(MAX_ADAPTER_ADDRESS_LENGTH, (size_t)pAdapterInfo->AddressLength);


        pInterface = FindOrCreateInterface(pAdapterInfo->Index,
                                           pAdapterInfo->Type,
                                           0,                   // speed
                                           pAdapterInfo->Description,
                                           lstrlen(pAdapterInfo->Description),
                                           pAdapterInfo->Address,
                                           (DWORD) len
                                           );
        if (pInterface == NULL) {

            DEBUG_PRINT(UTIL,
                        ERROR,
                        ("failed to allocate memory for CAdapterInterface\n"
                        ));

            goto error_exit;
        }

        //
        // Update the Adapter Name, this is the critical glue to make the new NT 5 DHCP Apis work,
        //   as they need this Adapter name as an ID to work.
        //

        if ( pInterface->GetAdapterName() == NULL )  {
            pInterface->SetAdapterName(pAdapterInfo->AdapterName);
        } else {
            INET_ASSERT(lstrcmpi(pInterface->GetAdapterName(), pAdapterInfo->AdapterName) == 0 );
        }

        //
        // Update the IP address found in the structure, as we're not getting anything back with this filled in.
        //

        if (  pAdapterInfo->CurrentIpAddress == NULL )
        {
            pAdapterInfo->CurrentIpAddress = &pAdapterInfo->IpAddressList;
        }
        else
        {
            INET_ASSERT(FALSE);  // want to know about this case.
        }

        //
        // Gather the IP addresses from the structure, doing all the necessary,
        //  IP string to network-ordered DWORD thingie usable for winsock.
        //
        //  BUGBUG [arthurbi] do we really need to do this anymore? As the
        //    the new NT 5 APIs can handle themselves without IP addresses...
        //


        if ( pAdapterInfo->CurrentIpAddress->IpAddress.String &&
             pAdapterInfo->CurrentIpAddress->IpMask.String )
        {
            DWORD dwAddress = _I_inet_addr(pAdapterInfo->CurrentIpAddress->IpAddress.String);
            DWORD dwMask = _I_inet_addr(pAdapterInfo->CurrentIpAddress->IpMask.String);
            DWORD dwContext = pAdapterInfo->CurrentIpAddress->Context;

            if ( dwAddress   != INADDR_NONE &&
                 dwMask      != INADDR_NONE  )
            {

                DEBUG_PRINT(UTIL,
                            INFO,
                            ("IP address %d.%d.%d.%d, index %d, context %d\n",
                            ((LPBYTE)&dwAddress)[0] & 0xff,
                            ((LPBYTE)&dwAddress)[1] & 0xff,
                            ((LPBYTE)&dwAddress)[2] & 0xff,
                            ((LPBYTE)&dwAddress)[3] & 0xff,
                            pAdapterInfo->Index,
                            dwContext
                            ));

                INET_ASSERT(pInterface != NULL);

                CIpAddress * pIpAddress;

                pIpAddress = pInterface->m_IpList.Find(dwAddress,
                                                       dwMask
                                                       );
                if (pIpAddress == NULL) {
                    pInterface->m_IpList.Add(dwAddress,
                                             dwMask,
                                             dwContext
                                             );

                    //
                    // added an address - interface is changed
                    //

                    bChanged = TRUE;
                } else {

                    INET_ASSERT(dwContext == pIpAddress->Context());

                    pIpAddress->SetFound(TRUE);
                }
            }
        }

        //
        // Gather DHCP server addresses to use, once again do we need this info on NT 5?
        //

        if ( pAdapterInfo->DhcpEnabled )
        {
            PIP_ADDR_STRING pDhcpServer;
            INET_ASSERT(pInterface != NULL);

            for ( pDhcpServer = &pAdapterInfo->DhcpServer; pDhcpServer; pDhcpServer = pDhcpServer->Next )
            {

                DWORD dwAddress = _I_inet_addr(pDhcpServer->IpAddress.String);
                DWORD dwMask = _I_inet_addr(pDhcpServer->IpMask.String);
                DWORD dwContext = pDhcpServer->Context;

                if ( dwAddress   != INADDR_NONE )
                {
                    CIpAddress * pIpAddress;

                    pInterface->SetDhcp();

                    pIpAddress = pInterface->m_DhcpList.Find(dwAddress,
                                                           dwMask
                                                           );
                    if (pIpAddress == NULL)
                    {
                        pInterface->m_DhcpList.Add(dwAddress,
                                                  dwMask,
                                                  dwContext
                                                  );

                        //
                        // added an address - interface is changed
                        //

                        bChanged = TRUE;
                    } else {

                        INET_ASSERT(dwContext == pIpAddress->Context());

                        pIpAddress->SetFound(TRUE);
                    }
                }

            }
        }
    }

    //
    // add the DNS servers, read from registry or DHCP depending on platform.
    // Even if we don't get any DNS servers, we deem that this function has
    // succeeded
    //

    char dnsBuffer[1024];   // arbitrary (how many DNS entries?)
    UINT error;

    error = SockGetSingleValue(CONFIG_NAME_SERVER,
                               (LPBYTE)dnsBuffer,
                               sizeof(dnsBuffer)
                               );
    if (error == ERROR_SUCCESS) {
        //m_DnsList.Clear();

        char ipString[4 * 4];
        LPSTR p = dnsBuffer;
        DWORD buflen = (DWORD)lstrlen(dnsBuffer);

        do {
            if (SkipWhitespace(&p, &buflen)) {

                int i = 0;

                while ((*p != '\0')
                       && (*p != ',')
                       && (buflen != 0)
                       && (i < sizeof(ipString))
                       && !isspace(*p)) {
                    ipString[i++] = *p++;
                    --buflen;
                }
                ipString[i] = '\0';

                DWORD ipAddress = _I_inet_addr(ipString);

                if (IS_VALID_NON_LOOPBACK_IP_ADDRESS(ipAddress)) {

                    CIpAddress * pIpAddress;

                    pIpAddress = m_DnsList.Find(ipAddress);
                    if (pIpAddress == NULL) {
                        m_DnsList.Add(ipAddress);

                        //
                        // added a DNS address - interface is changed
                        //

                        bChanged = TRUE;
                    } else {
                        pIpAddress->SetFound(TRUE);
                    }
                }
                while ((*p == ',') && (buflen != 0)) {
                    ++p;
                    --buflen;
                }
            } else {
                break;
            }
        } while (TRUE);
    }

    //
    // throw out any adapter interfaces which were not found this time. This may
    // happen if we support PnP devices that are unplugged
    //
    //  Do we need to still do this ???
    //

    BOOL bThrownOut;

    bThrownOut = ThrowOutUnfoundEntries();
    if (!bChanged) {
        bChanged = bThrownOut;
    }

    ok = TRUE;

    //
    // return the change state of the interfaces, if required
    //

    if (lpbChanged) {
        *lpbChanged = bChanged;
    }

quit:

    if (pAdapterInfoAllocation)
    {
        FREE_MEMORY(pAdapterInfoAllocation);
    }

    DEBUG_LEAVE(ok);

    return ok;

error_exit:

    //
    // here because of an error. Throw out all interfaces
    //

    SetNotFound();
    ThrowOutUnfoundEntries();

    INET_ASSERT(!ok);

    goto quit;
}


BOOL
CIpConfig::DoInformsOnEachInterface(
    OUT LPSTR * ppszAutoProxyUrl
    )
{
    for (CAdapterInterface * pEntry = (CAdapterInterface *)m_List.Flink;
         pEntry != (CAdapterInterface *)&m_List.Flink;
         pEntry =  (CAdapterInterface *)pEntry->m_List.Flink)
    {
        if ( pEntry->IsDhcp() )
        {
            BOOL fSuccess;

            if ( GlobalPlatformVersion5 )
            {
                fSuccess = pEntry->DhcpDoInformNT5(ppszAutoProxyUrl);
            }
            else
            {
                fSuccess = DhcpDoInform(     // send an inform packet if necessary
                        pEntry,
                        FALSE,
                        ppszAutoProxyUrl
                        );
            }

            if ( fSuccess ) {
                return TRUE;
            }
        }
    }

    return FALSE;
}


/*******************************************************************************
 *
 *  GetAdapterInfo
 *
 *  Gets a list of all adapters to which TCP/IP is bound and reads the per-
 *  adapter information that we want to display. Most of the information now
 *  comes from the TCP/IP stack itself. In order to keep the 'short' names that
 *  exist in the registry to refer to the individual adapters, we read the names
 *  from the registry then match them to the adapters returned by TCP/IP by
 *  matching the IPInterfaceContext value with the adapter which owns the IP
 *  address with that context value
 *
 *  ENTRY   nothing
 *
 *  EXIT    nothing
 *
 *  RETURNS pointer to linked list of ADAPTER_INFO structures
 *
 *  ASSUMES
 *
 ******************************************************************************/

VOID
CIpConfig::GetAdapterInfo()
{
    LPSTR* boundAdapterNames = NULL;
    DWORD err = ERROR_SUCCESS;

    if (GlobalPlatformType == PLATFORM_TYPE_WINNT)
    {
        if ( ServicesKey == NULL )
        {
            err = REGOPENKEY(HKEY_LOCAL_MACHINE,
                             SERVICES_KEY_NAME,
                             &ServicesKey
                             );
        }

        if ( err == ERROR_SUCCESS && TcpipLinkageKey == NULL )
        {
            err = REGOPENKEY(ServicesKey,
                             "Tcpip\\Linkage",
                             //"Tcpip\\Parameters\\Interfaces",
                             &TcpipLinkageKey
                             );
        }

        if (err == ERROR_SUCCESS && (NULL != (boundAdapterNames = GetBoundAdapterList(TcpipLinkageKey))))
        {
            int i;

            //
            // apply the short name to the right adapter info by comparing
            // the IPInterfaceContext value in the adapter\Parameters\Tcpip
            // section with the context values read from the stack for the
            // IP addresses
            //

            for (i = 0; boundAdapterNames[i]; ++i) {

                LPSTR name;
                DWORD context;
                HKEY key;

                name = boundAdapterNames[i];

                if (!OpenAdapterKey(KEY_TCP, name, &key)) {
                    DEBUG_PRINT(UTIL, ERROR, ("GetAdapterInfo cannot open %s\n",
                                 name ));

                    goto quit;
                }
                if (!ReadRegistryDword(key,
                                       "IPInterfaceContext",
                                       &context
                                       )) {
                    DEBUG_PRINT(UTIL, ERROR, ("GetAdapterInfo: IPInterfaceContext failed\n"));
                    goto quit;
                }
                REGCLOSEKEY(key);

                //
                // now search through the list of adapters, looking for the one
                // that has the IP address with the same context value as that
                // just read. When found, apply the short name to that adapter
                //

                for (CAdapterInterface * pEntry = (CAdapterInterface *)m_List.Flink;
                     pEntry != (CAdapterInterface *)&m_List.Flink;
                     pEntry =  (CAdapterInterface *)pEntry->m_List.Flink)
                {
                    if ( pEntry->IsContextInIPAddrList(context) )
                    {
                        pEntry->SetAdapterName(name);
                        GetDhcpServerFromDhcp(pEntry);
                        break;
                    }
                }
            }

        } else {
            DEBUG_PRINT(UTIL, ERROR, ("GetAdapterInfo failed\n"));
        }
    }
    else
    {
        //
        // Win95: search through the list of adapters, gather DHCP server names
        //  for each.
        //

        for (CAdapterInterface * pEntry = (CAdapterInterface *)m_List.Flink;
             pEntry != (CAdapterInterface *)&m_List.Flink;
             pEntry =  (CAdapterInterface *)pEntry->m_List.Flink)
        {
            GetDhcpServerFromDhcp(pEntry);
        }

    }

quit:

    if (boundAdapterNames != NULL )
    {
        FREE_MEMORY(boundAdapterNames);
    }

    return;
}



PRIVATE
DWORD
CIpConfig::LoadEntryPoints(
    VOID
    )

/*++

Routine Description:

    Loads IPHLPAPI.DLL and DHCPCSVC.DLL entry points if platform is
    Windows 2000 (or later), or NTDLL.DLL entry points if Windows NT.

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CIpConfig::LoadEntryPoints",
                 NULL
                 ));

    DWORD error = ERROR_SUCCESS;

    if (!m_Loaded)
    {
        if (GlobalDataInitCritSec.Lock())
        {
            if (!m_Loaded)
            {
                INET_ASSERT(GlobalPlatformType == PLATFORM_TYPE_WINNT);

                if (GlobalPlatformVersion5)
                {
                    INET_ASSERT(_I_GetAdaptersInfo == NULL);
                    
                    error = LoadDllEntryPoints(&IpHlpApiDllInfo, 0);

                    if (error == ERROR_SUCCESS)
                    {
                        error = LoadDllEntryPoints(&DhcpcSvcDllInfo, 0);
                    }

                }
                else
                {   INET_ASSERT(_I_RtlInitUnicodeString == NULL);
                    error = LoadDllEntryPoints(&NtDllInfo, 0);
                }

                m_Loaded = (error == ERROR_SUCCESS);
            }

            GlobalDataInitCritSec.Unlock();
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
        
    DEBUG_LEAVE(error);

    return error;
}


DWORD
CIpConfig::UnloadEntryPoints(
    VOID
    )

/*++

Routine Description:

    Unloads NTDLL.DLL if platform is Windows NT

Arguments:

    None.

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CIpConfig::UnloadEntryPoints",
                 NULL
                 ));

    DWORD error = ERROR_SUCCESS;

    if (m_Loaded)
    {
        if (GlobalDataInitCritSec.Lock())
        {
            if (m_Loaded)
            {
                if (GlobalPlatformVersion5)
                {
                    if (_I_GetAdaptersInfo != NULL)
                    {
                        error = UnloadDllEntryPoints(&IpHlpApiDllInfo, FALSE);
                    }

                    if (_I_DhcpRequestParams != NULL)
                    {
                        error = UnloadDllEntryPoints(&DhcpcSvcDllInfo, FALSE);
                    }
                }
                else
                {
                    error = UnloadDllEntryPoints(&NtDllInfo, FALSE);
                }

                m_Loaded = FALSE;
            }

            GlobalDataInitCritSec.Unlock();
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


//
// UnloadAutoProxy()
//
// Called from GlobalDataTerminate to unload IPHLPAPI.DLL & DHCPCSVC.DLL (Win2K+)
// or NTDLL.DLL (NT4) if necessary.
//
void UnloadAutoProxy()
{
    CIpConfig::UnloadEntryPoints();
}



PRIVATE
CAdapterInterface *
CIpConfig::FindOrCreateInterface(
    IN DWORD dwIndex,
    IN DWORD dwType,
    IN DWORD dwSpeed,
    IN LPSTR lpszDescription,
    IN DWORD dwDescriptionLength,
    IN LPBYTE lpPhysicalAddress,
    IN DWORD dwPhysicalAddressLength
    )

/*++

Routine Description:

    Returns a pointer to the CAdapterInterface object corresponding to dwIndex.
    If none found in the list, a new entry is created

Arguments:

    dwIndex             - unique interface identifier to find or create

    dwType              - type of adapter

    dwSpeed             - adapter media speed

    lpszDescription     - name of this interface

    dwDescriptionLength - length of the name

Return Value:

    CAdapterInterface *
        Success - pointer to found or created object

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Pointer,
                 "CIpConfig::FindOrCreateInterface",
                 "%d, %s (%d), %d, %.*q, %d, %x, (%u)",
                 dwIndex,
                 InternetMapInterface(dwType),
                 dwType,
                 dwSpeed,
                 dwDescriptionLength,
                 lpszDescription,
                 dwDescriptionLength,
                 lpPhysicalAddress,
                 dwPhysicalAddressLength
                 ));

    CAdapterInterface * pInterface = FindInterface(dwIndex);

    if (pInterface == NULL) {
        pInterface = new CAdapterInterface(dwIndex,
                                           dwType,
                                           dwSpeed,
                                           lpszDescription,
                                           dwDescriptionLength,
                                           lpPhysicalAddress,
                                           dwPhysicalAddressLength
                                           );
        if (pInterface != NULL) {
            InsertHeadList(&m_List, &pInterface->m_List);
            ++m_dwNumberOfInterfaces;
        }
    }

    DEBUG_LEAVE(pInterface);

    return pInterface;
}


PRIVATE
CAdapterInterface *
CIpConfig::FindInterface(
    IN DWORD dwIndex
    )

/*++

Routine Description:

    Returns a pointer to the CAdapterInterface object corresponding to dwIndex

Arguments:

    dwIndex - unique interface identifier to find

Return Value:

    CAdapterInterface *
        Success - pointer to found object

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Pointer,
                 "CIpConfig::FindInterface",
                 "%d",
                 dwIndex
                 ));

    CAdapterInterface * pInterface = NULL;

    for (PLIST_ENTRY pEntry = m_List.Flink;
        pEntry != (PLIST_ENTRY)&m_List;
        pEntry = pEntry->Flink) {

        if (((CAdapterInterface *)pEntry)->m_dwIndex == dwIndex) {
            ((CAdapterInterface *)pEntry)->SetFound(TRUE);

            //
            // ASSUMES: pEntry == &CAdapterInterface
            //

            pInterface = (CAdapterInterface *)pEntry;
            break;
        }
    }

    DEBUG_LEAVE(pInterface);

    return pInterface;
}


PRIVATE
BOOL
CIpConfig::ThrowOutUnfoundEntries(
    VOID
    )

/*++

Routine Description:

    Throws out (deletes) any entries that are marked not-found

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - interfaces thrown out

        FALSE   -      "     not "   "

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::ThrowOutUnfoundEntries",
                 NULL
                 ));

    //
    // ASSUMES: CAdapterInterface.m_List.Flink is first element in structure
    //

    PLIST_ENTRY pPrevious = (PLIST_ENTRY)&m_List.Flink;
    PLIST_ENTRY pEntry = m_List.Flink;
    BOOL bThrownOut = FALSE;

    while (pEntry != (PLIST_ENTRY)&m_List) {

        CAdapterInterface * pInterface = (CAdapterInterface *)pEntry;

        if (!pInterface->IsFound()) {

            DEBUG_PRINT(UTIL,
                        WARNING,
                        ("adapter index %d (%q) not located in list\n",
                        pInterface->m_dwIndex,
                        pInterface->m_lpszDescription
                        ));

            RemoveEntryList(&pInterface->m_List);
            --m_dwNumberOfInterfaces;

            INET_ASSERT((int)m_dwNumberOfInterfaces >= 0);

            delete pInterface;
            bThrownOut = TRUE;
        } else {

            //
            // throw out any IP addresses
            //

            bThrownOut |= pInterface->m_IpList.ThrowOutUnfoundEntries();
            //bThrownOut |= pInterface->m_RouterList.ThrowOutUnfoundEntries();
            //bThrownOut |= pInterface->m_DnsList.ThrowOutUnfoundEntries();
            pPrevious = pEntry;
        }
        pEntry = pPrevious->Flink;
    }

    DEBUG_LEAVE(bThrownOut);

    return bThrownOut;
}

//
// public functions
//


DWORD
WsControl(
    IN DWORD dwProtocol,
    IN DWORD dwRequest,
    IN LPVOID lpInputBuffer,
    IN OUT LPDWORD lpdwInputBufferLength,
    OUT LPVOID lpOutputBuffer,
    IN OUT LPDWORD lpdwOutputBufferLength
    )

/*++

Routine Description:

    Makes device-dependent driver call based on O/S

Arguments:

    dwProtocol              - ignored

    dwRequest               - ignored

    lpInputBuffer           - pointer to request buffer

    lpdwInputBufferLength   - pointer to DWORD: IN = request buffer length

    lpOutputBuffer          - pointer to output buffer

    lpdwOutputBufferLength  - pointer to DWORD: IN = length of output buffer;
                                               OUT = length of returned data

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "WsControl",
                 "%d, %d, %#x, %#x [%d], %#x, %#x [%d]",
                 dwProtocol,
                 dwRequest,
                 lpInputBuffer,
                 lpdwInputBufferLength,
                 *lpdwInputBufferLength,
                 lpOutputBuffer,
                 lpdwOutputBufferLength,
                 *lpdwOutputBufferLength
                 ));

    DWORD error;

    if (GlobalPlatformType == PLATFORM_TYPE_WINNT)
    {
        error = WinNtWsControl(dwProtocol,
                               dwRequest,
                               lpInputBuffer,
                               lpdwInputBufferLength,
                               lpOutputBuffer,
                               lpdwOutputBufferLength
                               );
    }
    else
    {
        error = ERROR_NOT_SUPPORTED;
    }

    DEBUG_LEAVE(error);

    return error;
}

//
// private functions
//


PRIVATE
DWORD
WinNtWsControl(
    DWORD dwProtocol,
    DWORD dwRequest,
    LPVOID lpInputBuffer,
    LPDWORD lpdwInputBufferLength,
    LPVOID lpOutputBuffer,
    LPDWORD lpdwOutputBufferLength
    )

/*++

Routine Description:

    Handles WsControl() functionality on NT platform. Assumes NTDLL.DLL has
    already been loaded

Arguments:

    dwProtocol              - unused

    dwRequest               - unused

    lpInputBuffer           - contains driver request structure

    lpdwInputBufferLength   - pointer to length of InputBuffer

    lpOutputBuffer          - pointer to buffer where results written

    lpdwOutputBufferLength  - pointer to length of OutputBuffer. Updated with
                              returned data length on successful return

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "WinNtWsControl",
                 "%d, %d, %#x, %#x [%d], %#x, %#x [%d]",
                 dwProtocol,
                 dwRequest,
                 lpInputBuffer,
                 lpdwInputBufferLength,
                 *lpdwInputBufferLength,
                 lpOutputBuffer,
                 lpdwOutputBufferLength,
                 *lpdwOutputBufferLength
                 ));

    UNREFERENCED_PARAMETER(dwProtocol);
    UNREFERENCED_PARAMETER(dwRequest);

    DWORD error;

    if (TcpipDriverHandle == INVALID_HANDLE_VALUE) {
        error = OpenTcpipDriverHandle();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    DWORD bytesReturned;
    BOOL ok;

    ok = DeviceIoControl(TcpipDriverHandle,
                         IOCTL_TCP_QUERY_INFORMATION_EX,
                         lpInputBuffer,
                         *lpdwInputBufferLength,
                         lpOutputBuffer,
                         *lpdwOutputBufferLength,
                         &bytesReturned,
                         NULL
                         );
    if (!ok) {
        error = GetLastError();
    } else {
        *lpdwOutputBufferLength = bytesReturned;
        error = ERROR_SUCCESS;
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
OpenTcpipDriverHandle(
    VOID
    )

/*++

Routine Description:

    Opens handle to TCP/IP device driver

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DWORD error = ERROR_SUCCESS;

    if (TcpipDriverHandle == INVALID_HANDLE_VALUE) {

        OBJECT_ATTRIBUTES objectAttributes;
        IO_STATUS_BLOCK iosb;
        UNICODE_STRING string;
        NTSTATUS status;

        _I_RtlInitUnicodeString(&string, DD_TCP_DEVICE_NAME);

        InitializeObjectAttributes(&objectAttributes,
                                   &string,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                   );
        status = _I_NtCreateFile(&TcpipDriverHandle,
                                 SYNCHRONIZE | GENERIC_EXECUTE,
                                 &objectAttributes,
                                 &iosb,
                                 NULL,
                                 FILE_ATTRIBUTE_NORMAL,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 FILE_OPEN_IF,
                                 FILE_SYNCHRONOUS_IO_NONALERT,
                                 NULL,
                                 0
                                 );
        if (!NT_SUCCESS(status)) {
            error = _I_RtlNtStatusToDosError(status);
        }
    }
    return error;
}


PRIVATE
VOID
CloseTcpipDriverHandle(
    VOID
    )

/*++

Routine Description:

    Closes TCP/IP device driver handle

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (TcpipDriverHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(TcpipDriverHandle);
        TcpipDriverHandle = INVALID_HANDLE_VALUE;
    }
}


PRIVATE
DWORD
GetEntityList(
    OUT TDIEntityID * * lplpEntities
    )

/*++

Routine Description:

    Allocates a buffer for, and retrieves, the list of entities supported by the
    TCP/IP device driver

Arguments:

    lplpEntities    - pointer to allocated returned list of entities. Caller
                      must free

Return Value:

    UINT    - number of entities returned

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Int,
                 "GetEntityList",
                 "%#x",
                 lplpEntities
                 ));

    TCP_REQUEST_QUERY_INFORMATION_EX req;

    memset(&req, 0, sizeof(req));

    req.ID.toi_entity.tei_entity = GENERIC_ENTITY;
    req.ID.toi_entity.tei_instance = 0;
    req.ID.toi_class = INFO_CLASS_GENERIC;
    req.ID.toi_type = INFO_TYPE_PROVIDER;
    req.ID.toi_id = ENTITY_LIST_ID;

    DWORD inputLen = sizeof(req);
    DWORD outputLen = sizeof(TDIEntityID) * DEFAULT_MINIMUM_ENTITIES;
    TDIEntityID * pEntity = NULL;
    DWORD status = TDI_SUCCESS;

    //
    // this is over-engineered - its very unlikely that we'll ever get >32
    // entities returned, never mind >64K's worth
    //
    // Go round this loop a maximum of 4 times - length of list shouldn't
    // change between calls. Stops us getting stuck in infinite loop if
    // something bad happens with outputLen
    //

    for (int i = 0; i < 4; ++i) {

        DWORD previousOutputLen = outputLen;

        pEntity = (TDIEntityID *)ResizeBuffer(pEntity, outputLen, FALSE);
        if (pEntity == NULL) {
            outputLen = 0;
            break;
        }

        status = WsControl(IPPROTO_TCP,
                           WSCNTL_TCPIP_QUERY_INFO,
                           (LPVOID)&req,
                           &inputLen,
                           (LPVOID)pEntity,
                           &outputLen
                           );

        //
        // TDI_SUCCESS is returned if all data is not returned: driver
        // communicates all/partial data via outputLen
        //

        if (status == TDI_SUCCESS) {

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("GENERIC_ENTITY required length = %d\n",
                        outputLen
                        ));

            if (outputLen && (outputLen <= previousOutputLen)) {
                break;
            }
        } else {
            outputLen = 0;
        }
    }

    if ((status != TDI_SUCCESS) && (pEntity != NULL)) {
        ResizeBuffer(pEntity, 0, FALSE);
    }

    DEBUG_PRINT(UTIL,
                INFO,
                ("%d entities returned in %#x\n",
                (outputLen / sizeof(TDIEntityID)),
                pEntity
                ));

    *lplpEntities = pEntity;

    DEBUG_LEAVE((UINT)(outputLen / sizeof(TDIEntityID)));

    return (UINT)(outputLen / sizeof(TDIEntityID));
}

//
// private debug functions
//

#if INET_DEBUG

PRIVATE
LPCSTR
InternetMapEntity(
    IN INT EntityId
    ) {
    switch (EntityId) {
    case CO_TL_ENTITY:
        return "CO_TL_ENTITY";

    case CL_TL_ENTITY:
        return "CL_TL_ENTITY";

    case ER_ENTITY:
        return "ER_ENTITY";

    case CO_NL_ENTITY:
        return "CO_NL_ENTITY";

    case CL_NL_ENTITY:
        return "CL_NL_ENTITY";

    case AT_ENTITY:
        return "AT_ENTITY";

    case IF_ENTITY:
        return "IF_ENTITY";

    }
    return "*** UNKNOWN ENTITY ***";
}

PRIVATE
LPCSTR
InternetMapInterface(
    IN DWORD InterfaceType
    ) {
    switch (InterfaceType) {
    case IF_TYPE_OTHER:
        return "other";

    case IF_TYPE_ETHERNET:
        return "ethernet";

    case IF_TYPE_TOKENRING:
        return "token ring";

    case IF_TYPE_FDDI:
        return "FDDI";

    case IF_TYPE_PPP:
        return "PPP";

    case IF_TYPE_LOOPBACK:
        return "loopback";
    }
    return "???";
}

PRIVATE
LPCSTR
InternetMapInterfaceOnNT5(
    IN DWORD InterfaceType
    ) {
    switch (InterfaceType) {
    case IF_TYPE_OTHER:
        return "other";

    case IF_TYPE_ETHERNET_CSMACD:
        return "ethernet";

    case IF_TYPE_ISO88025_TOKENRING:
        return "token ring";

    case IF_TYPE_FDDI:
        return "FDDI";

    case IF_TYPE_PPP:
        return "PPP";

    case IF_TYPE_SOFTWARE_LOOPBACK:
        return "loopback";

    case IF_TYPE_SLIP:
        return "SLIP";

    default:
        break;
    }
    return "???";
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\gmacros.h ===
/*================================================================================
  File: gmacros.h
  Contains: Macros used in common by both the DHCP Server and the DHCP Client.
  	Most of them are inlines for sake of elegance and ease of usage.
  Author: RameshV
  Created: 04-Jun-97 00:01

================================================================================*/
//#include <align.h>

//  Some block macros; usage at end

#define _shorten(string)    ( strrchr(string, '\\')? strrchr(string, '\\') : (string) )

// print a message and the file and line # of whoever is printing this.
#define _TracePrintLine(Msg)  DhcpPrint((DEBUG_TRACE_CALLS, "%s:%d %s\n", _shorten(__FILE__), __LINE__, Msg))

#define BlockBegin(Name)    { BlockStart_ ## Name : _TracePrintLine( "Block -> " #Name );
#define BlockEnd(Name)      BlockEnd_ ## Name : _TracePrintLine( "Block <- " #Name ) ;}
#define BlockContinue(Name) do { _TracePrintLine( "Continue to " #Name); goto BlockStart_ ## Name; } while (0)
#define BlockBreak(Name)    do { _TracePrintLine( "Breaking out of " #Name); goto BlockEnd_ ## Name; } while (0)
#define RetFunc(F,Ret)      do {_TracePrintLine( "Quitting function " #F ); return Ret ; } while (0)

// The way to use the above set of simple block macros is as follows: (example usage)
#if     0
int
DummyFunction(VOID) {
    BlockBegin(DummyFunctionMain) {
        if(GlobalCount > 0 )
            BlockContinue(DummyFunctionMain);
        else GlobalCount ++;

        if(GlobalCount > GlobalCountMax)
            BlockBreak(DummyFunctionMain);
    } BlockEnd(DummyFunctionMain);

    RetFunc(DummyFunction, RetVal);
}
#endif

// now come some little more complicated functions..
// note that these can be freely mixed with the above set of simple functions.
#define BlockBeginEx(Name, String)    {BlockStart_ ## Name : _TracePrintLine( #String );
#define BlockEndEx(Name, String)      BlockEnd_## Name : _TracePrintLine( #String );}
#define BlockContinueEx(Name, String) do {_TracePrintLine( #String); goto BlockStart_ ## Name; } while (0)
#define BlockBreakEx(Name, String)    do {_TracePrintLine( #String); goto BlockEnd_ ## Name; } while(0)

#define RetFuncEx(Name,Ret,DebMsg)    do {_TracePrintLine( "QuittingFunction " #Name); DhcpPrint(DebMsg); return Ret;} while(0)

// usage example:

#if 0
int
DummyFunction(VOID) {
    BlockBeginEx(Main, "Entering Dummy Function" ) {
        if( GlobalCount > 0)
            BlockContinueEx(Main, GlobalCount > 0);
        else GlobalCount ++;

        if(GlobalCount > GlobalCountMax)
            BlockBreak(Main);
    } BlockEndEx(Main, "Done Dummy Function");

    RetFunc(DummyFunc, RetVal);
    // OR
    RetFuncEx(DummyFunc, RetVal, (DEBUG_ERRROS, "Function returning, gcount = %ld\n", GlobalCount));

}

#endif 0


#define NOTHING

// Now if a VOID function (procedure) returns, we can say RetFunc(VoidFunc, NOTHING) and things will work.


//================================================================================
//  Now some useful inlines.
//================================================================================

VOID _inline
FreeEx(LPVOID Ptr) {
    if(Ptr) DhcpFreeMemory(Ptr);
}

VOID _inline
FreeEx2(LPVOID Ptr1, LPVOID Ptr2) {
    FreeEx(Ptr1); FreeEx(Ptr2);
}

VOID _inline
FreeEx3(LPVOID Ptr1, LPVOID Ptr2, LPVOID Ptr3) {
    FreeEx(Ptr1); FreeEx(Ptr2); FreeEx(Ptr3);
}

VOID _inline
FreeEx4(LPVOID Ptr1, LPVOID Ptr2, LPVOID Ptr3, LPVOID Ptr4) {
    FreeEx2(Ptr1, Ptr2); FreeEx2(Ptr3, Ptr4);
}

//--------------------------------------------------------------------------------
//  All the alloc functions below, allocate in one shot a few pointers,
//  and initialize them.. aligning them correctly.
//--------------------------------------------------------------------------------
LPVOID _inline
AllocEx(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) + Size2;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);

    return Ptr;
}

LPVOID _inline
AllocEx2(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) + Size2;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);

    return Ptr;
}

LPVOID _inline
AllocEx3(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2, LPVOID *Ptr3, DWORD Size3) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) + ROUND_UP_COUNT(Size2, ALIGN_WORST) + Size3;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);
    (*Ptr3) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST) + ROUND_UP_COUNT(Size2, ALIGN_WORST);
    return Ptr;
}

LPVOID _inline
AllocEx4(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2,
         LPVOID *Ptr3, DWORD Size3, LPVOID *Ptr4, DWORD Size4) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) +
    	ROUND_UP_COUNT(Size2, ALIGN_WORST) + ROUND_UP_COUNT(Size3, ALIGN_WORST) + Size4;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);
    (*Ptr3) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST) + ROUND_UP_COUNT(Size2, ALIGN_WORST);
    (*Ptr4) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST) +
    	ROUND_UP_COUNT(Size2, ALIGN_WORST) + ROUND_UP_COUNT(Size3, ALIGN_WORST);
    return Ptr;
}

//--------------------------------------------------------------------------------
//  This function takes an input string and a static buffer and if the input
//  string is not nul terminated, copies it to the static buffer and then null
//  terminates it.  It also change the size to reflect the new size..
//--------------------------------------------------------------------------------
LPBYTE _inline
AsciiNulTerminate(LPBYTE Input, DWORD *Size, LPBYTE StaticBuf, DWORD BufSize) {
    if( 0 == *Size) return Input;   // nothing to copy
    if(!Input[(*Size)-1]) return Input; // Everything is fine.

    if(*Size >= BufSize) {
        // Nothing much can be done here.. this is an error.. insufficient buffer space.
        DhcpAssert(FALSE);

        *Size = BufSize - 1;
    }

    memcpy(StaticBuf, Input, (*Size));
    StaticBuf[*Size] = '\0';
    (*Size) ++;
    return StaticBuf;
}

#if DBG
#define INLINE
#else
#define INLINE _inline
#endif

#define BEGIN_EXPORT
#define END_EXPORT

#define AssertReturn(Condition, RetVal )    do { DhcpAssert(Condition); return RetVal ;} while(0)

//================================================================================
//  End of File.
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\jsproxy.cpp ===
/********************************************************************************
/    This is the base file to the Microsoft JScript Proxy Configuration 
/    This file implements the code to provide the script site and the JSProxy psuedo
/    object for the script engine to call against.
/
/    Created        11/27/96    larrysu
/
/
/
/
/
/
/
/
/
*/
#include <wininetp.h>
#include "jsproxy.h"


/*******************************************************************************
*    JSProxy functions.
********************************************************************************/
CJSProxy::CJSProxy()
{
    m_refCount = 1;
    m_fDestroyable = FALSE;
    m_fInitialized = FALSE;
    m_pCallout = NULL;
}

CJSProxy::~CJSProxy()
{
    if(m_fInitialized)
        DeInit();
}

STDMETHODIMP CJSProxy::Init(AUTO_PROXY_HELPER_APIS* pAPHA)
{
    if(!DelayLoad(&g_moduleOleAut32))
        return FALSE;

    m_strings[0] = L"isPlainHostName";
    m_strings[1] = L"dnsDomainIs";
    m_strings[2] = L"localHostOrDomainIs";
    m_strings[3] = L"isResolvable";
    m_strings[4] = L"isInNet";
    m_strings[5] = L"dnsResolve";
    m_strings[6] = L"myIpAddress";
    m_strings[7] = L"dnsDomainLevels";
    m_strings[8] = L"shExpMatch";
    m_strings[9] = L"weekdayRange";
    m_strings[10] = L"dateRange";
    m_strings[11] = L"timeRange";
    m_strings[12] = L"alert";
    
    m_pCallout = pAPHA;
    m_fInitialized = TRUE;
    return S_OK;
}

STDMETHODIMP CJSProxy::DeInit()
{
    m_pCallout = NULL;
    m_fInitialized = FALSE;
    return S_OK;
}
//IDispatch functions for JSProxy.  I want these to be light and fast.
STDMETHODIMP CJSProxy::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames,UINT cNames, LCID lcid, DISPID FAR* rgdispid)
{
    // Use addition of first 4 chars to make quick cheesy hash of which function wants to be called.
    // These are values are #defined in JSProxy.h
    HRESULT        hr = S_OK;
    long        strval = 0;
    unsigned long        nameindex = 0;
    OLECHAR*    currentName = NULL;

    UNREFERENCED_PARAMETER(riid);
    UNREFERENCED_PARAMETER(lcid);
    
    if (!*rgszNames)
        return E_POINTER;
    if (cNames < 1)
        return E_INVALIDARG;

    while (nameindex < cNames)
    {
        currentName = rgszNames[nameindex];
        if (currentName == NULL)
            break;
        
        //
        // All script host functions are at least 5 characters in length,
        // so shorter strings should fail match.
        //
        if (lstrlenW(currentName) < 5)
            strval = 0;
        else
            strval = currentName[0]+currentName[1]+currentName[2]+currentName[3]+currentName[4];

        switch (strval)
        {

            case VAL_myIpAddress :
                    if (StrCmpW(m_strings[6],currentName) == 0)
                        rgdispid[nameindex] = DISPID_myIpAddress;
                    else
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;

            case VAL_isInNet :
                    if (StrCmpW(m_strings[4],currentName) == 0)
                        rgdispid[nameindex] = DISPID_isInNet;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            case VAL_dateRange :
                    if (StrCmpW(m_strings[10],currentName) == 0)
                        rgdispid[nameindex] = DISPID_dateRange;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            case VAL_dnsDomainIs : // This is also VAL_dnsDomainLevels check for both strings.
                    if (StrCmpW(m_strings[7],currentName) == 0)
                        rgdispid[nameindex] = DISPID_dnsDomainLevels;
                    else 
                    {
                        if (StrCmpW(m_strings[1],currentName) == 0)
                            rgdispid[nameindex] = DISPID_dnsDomainIs;
                        else 
                        {
                            rgdispid[nameindex] = DISPID_UNKNOWN;
                            hr = DISP_E_UNKNOWNNAME;
                        }
                    }
                    break;
            
            case VAL_isPlainHostName :
                    if (StrCmpW(m_strings[0],currentName) == 0)
                        rgdispid[nameindex] = DISPID_isPlainHostName;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            case VAL_dnsResolve :
                    if (StrCmpW(m_strings[5],currentName) == 0)
                        rgdispid[nameindex] = DISPID_dnsResolve;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            case VAL_timeRange :
                    if (StrCmpW(m_strings[11],currentName) == 0)
                        rgdispid[nameindex] = DISPID_timeRange;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            case VAL_isResolvable :
                    if (StrCmpW(m_strings[3],currentName) == 0)
                        rgdispid[nameindex] = DISPID_isResolvable;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            case VAL_shExpMatch :
                    if (StrCmpW(m_strings[8],currentName) == 0)
                        rgdispid[nameindex] = DISPID_shExpMatch;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            case VAL_localHostOrDomainIs :
                    if (StrCmpW(m_strings[2],currentName) == 0)
                        rgdispid[nameindex] = DISPID_localHostOrDomainIs;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            case VAL_weekdayRange :
                    if (StrCmpW(m_strings[9],currentName) == 0)
                        rgdispid[nameindex] = DISPID_weekdayRange;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            case VAL_alert :
                    if (StrCmpW(m_strings[12],currentName) == 0)
                        rgdispid[nameindex] = DISPID_alert;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            case 0:
            default :
                    rgdispid[nameindex] = DISPID_UNKNOWN;
                    hr = DISP_E_UNKNOWNNAME;
                    break;

        }
        nameindex++;
    }
    return hr;
    
}

STDMETHODIMP CJSProxy::Invoke(
                DISPID dispidMember,
                REFIID riid,
                LCID lcid,
                WORD wFlags,
                DISPPARAMS* pdispparams,
                VARIANT* pvarResult,
                EXCEPINFO* pexcepinfo,
                UINT* puArgErr)
{
    HRESULT hr = S_OK;
    
    UNREFERENCED_PARAMETER(riid);
    UNREFERENCED_PARAMETER(lcid);
    UNREFERENCED_PARAMETER(pexcepinfo);
    UNREFERENCED_PARAMETER(puArgErr);
    
    if (dispidMember > 0x000d)
        return DISP_E_MEMBERNOTFOUND;

    if (!(wFlags & (DISPATCH_PROPERTYGET|DISPATCH_METHOD)))
    {
        return DISP_E_MEMBERNOTFOUND;
    }

    if(!m_fInitialized)
        return DISP_E_BADCALLEE;

    // The big switch based on DISPID!
    switch (dispidMember)
    {
/*****************************************************************************
    Calling isPlainHostName 
*****************************************************************************/
    case DISPID_isPlainHostName :
        {
            // look in the DISPARAMS to make sure the signature is correct for this function.
            if (pdispparams->cArgs != 1)
                hr = DISP_E_BADPARAMCOUNT;
            if (pdispparams->cNamedArgs > 0)
                hr = DISP_E_NONAMEDARGS;

            if (FAILED(hr))
                break;
            
            VARIANT arg1;
            
            // check the type of the variant in the disparams and if it is a bstr use it
            if (pdispparams->rgvarg[0].vt == VT_BSTR)
                arg1 = pdispparams->rgvarg[0];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            // call isPlainHostName.
            hr = isPlainHostName(arg1.bstrVal,pvarResult);
            break;
        }
/*****************************************************************************
    Calling dnsDomainIs
*****************************************************************************/
    case DISPID_dnsDomainIs :
        {
            if (pdispparams->cArgs != 2)
            {
                hr = DISP_E_BADPARAMCOUNT;
                break;
            }
            if (pdispparams->cNamedArgs > 0)
            {
                hr = DISP_E_NONAMEDARGS;
                break;
            }

            VARIANT arg1;
            VARIANT arg2;
            
            // check the type of the variant in the disparams and if it is a bstr use it
            if (pdispparams->rgvarg[0].vt == VT_BSTR)
                arg2 = pdispparams->rgvarg[0];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg2,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            if (pdispparams->rgvarg[1].vt == VT_BSTR)
                arg1 = pdispparams->rgvarg[1];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg1,&(pdispparams->rgvarg[1]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            // call dnsDomainIs
            hr = dnsDomainIs(arg1.bstrVal,arg2.bstrVal,pvarResult);
            break;
        }
/*****************************************************************************
    Calling localHostOrDomainIs
*****************************************************************************/
    case DISPID_localHostOrDomainIs :
        {
            if (pdispparams->cArgs != 2)
            {
                hr = DISP_E_BADPARAMCOUNT;
                break;
            }
            if (pdispparams->cNamedArgs > 0)
            {
                hr = DISP_E_NONAMEDARGS;
                break;
            }
            
            VARIANT arg1;
            VARIANT arg2;
            
            // check the type of the variant in the disparams and if it is a bstr use it
            if (pdispparams->rgvarg[0].vt == VT_BSTR)
                arg2 = pdispparams->rgvarg[0];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg2,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            if (pdispparams->rgvarg[1].vt == VT_BSTR)
                arg1 = pdispparams->rgvarg[1];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg1,&(pdispparams->rgvarg[1]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            // call localHostOrDomainIs
            hr = localHostOrDomainIs(arg1.bstrVal,arg2.bstrVal,pvarResult);
            break;
        }
/*****************************************************************************
    Calling isResolvable
*****************************************************************************/
    case DISPID_isResolvable :
        {
            if (pdispparams->cArgs != 1)
            {
                hr = DISP_E_BADPARAMCOUNT;
                break;
            }
            if (pdispparams->cNamedArgs > 0)
            {
                hr = DISP_E_NONAMEDARGS;
                break;
            }
            
            VARIANT arg1;
            
            // check the type of the variant in the disparams and if it is a bstr use it
            if (pdispparams->rgvarg[0].vt == VT_BSTR)
                arg1 = pdispparams->rgvarg[0];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            // call isResolvable
            hr = isResolvable(arg1.bstrVal,pvarResult);
            break;
        }
/*****************************************************************************
    Calling isInNet
*****************************************************************************/
    case DISPID_isInNet :
        {
            int x;

            if (pdispparams->cArgs != 3)
            {
                hr = DISP_E_BADPARAMCOUNT;
                break;
            }
            if (pdispparams->cNamedArgs > 0)
            {
                hr = DISP_E_NONAMEDARGS;
                break;
            }
            
            VARIANT args[3];
            
            for (x=0;x<3;x++)
            {
                // check the type of the variant in the disparams and if it is a bstr use it
                if (pdispparams->rgvarg[x].vt == VT_BSTR)
                    args[x] = pdispparams->rgvarg[x];
                // otherwise change it into one!  if this fails the return an error.
                else
                {
                    hr = DL(VariantChangeType)(&args[x],&(pdispparams->rgvarg[x]),NULL,VT_BSTR);
                    if (FAILED(hr))
                    {
                        hr = DISP_E_TYPEMISMATCH;
                        break;
                    }
                }
            }
            if (FAILED(hr))
                break;
            // call isInNet.  Args need to be reversed
            hr = isInNet(args[2].bstrVal,args[1].bstrVal,args[0].bstrVal,pvarResult);
            break;
        }
/*****************************************************************************
    Calling dnsResolve
*****************************************************************************/
    case DISPID_dnsResolve :
        {
            if (pdispparams->cArgs != 1)
            {
                hr = DISP_E_BADPARAMCOUNT;
                break;
            }
            if (pdispparams->cNamedArgs > 0)
            {
                hr = DISP_E_NONAMEDARGS;
                break;
            }
            
            VARIANT arg1;
            
            // check the type of the variant in the disparams and if it is a bstr use it
            if (pdispparams->rgvarg[0].vt == VT_BSTR)
                arg1 = pdispparams->rgvarg[0];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            // call dnsResolve
            hr = dnsResolve(arg1.bstrVal,pvarResult);
            break;
        }
/*****************************************************************************
    Calling myIpAddress
*****************************************************************************/
    case DISPID_myIpAddress :
        // Should have no args and 1 named arg and the name should be DISPATCH_PROPERTYGET!
/*        if (pdispparams->cNamedArgs != 1)
        {
            hr = DISP_E_BADPARAMCOUNT;
            break;
        }
*/
        // call myIpAddress
        hr = myIpAddress(pvarResult);
        break;
/*****************************************************************************
    Calling dnsDomainLevels
*****************************************************************************/
    case DISPID_dnsDomainLevels :
        {
            if (pdispparams->cArgs != 1)
            {
                hr = DISP_E_BADPARAMCOUNT;
                break;
            }
            if (pdispparams->cNamedArgs > 0)
            {
                hr = DISP_E_NONAMEDARGS;
                break;
            }
            
            VARIANT arg1;
            
            // check the type of the variant in the disparams and if it is a bstr use it
            if (pdispparams->rgvarg[0].vt == VT_BSTR)
                arg1 = pdispparams->rgvarg[0];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            // call dnsDomainLevels
            hr = dnsDomainLevels(arg1.bstrVal,pvarResult);
            break;
        }
/*****************************************************************************
    Calling shExpMatch
*****************************************************************************/
    case DISPID_shExpMatch :
        {
            if (pdispparams->cArgs != 2)
            {
                hr = DISP_E_BADPARAMCOUNT;
                break;
            }
            if (pdispparams->cNamedArgs > 0)
            {
                hr = DISP_E_NONAMEDARGS;
                break;
            }
            
            VARIANT arg1;
            VARIANT arg2;
            
            // check the type of the variant in the disparams and if it is a bstr use it
            if (pdispparams->rgvarg[0].vt == VT_BSTR)
                arg2 = pdispparams->rgvarg[0];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg2,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            if (pdispparams->rgvarg[1].vt == VT_BSTR)
                arg1 = pdispparams->rgvarg[1];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg1,&(pdispparams->rgvarg[1]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            // call isPlainHostName.
            hr = shExpMatch(arg1.bstrVal,arg2.bstrVal,pvarResult);
            break;
        }
/*****************************************************************************
    Calling weekdayRange
*****************************************************************************/
    case DISPID_weekdayRange :
        {
            unsigned int x;

            if ((pdispparams->cArgs > 3) || (pdispparams->cArgs < 1))
            {
                hr = DISP_E_BADPARAMCOUNT;
                break;
            }
            if (pdispparams->cNamedArgs > 0)
            {
                hr = DISP_E_NONAMEDARGS;
                break;
            }
            
            VARIANT* args[3] = {NULL,NULL,NULL};
            
            for (x=0;x<pdispparams->cArgs;x++)
            {
                args[x] = new(VARIANT);
                if( !(args[x]) )
                {
                       hr = E_OUTOFMEMORY;
                       break;
                }

                // check the type of the variant in the disparams and if it is a bstr use it
                if (pdispparams->rgvarg[x].vt == VT_BSTR)
                    *args[x] = pdispparams->rgvarg[x];
                // otherwise change it into one!  if this fails the return an error.
                else
                {
                    hr = DL(VariantChangeType)(args[x],&(pdispparams->rgvarg[x]),NULL,VT_BSTR);
                    if (FAILED(hr))
                    {
                        hr = DISP_E_TYPEMISMATCH;
                        break;
                    }
                }
            }
            if (FAILED(hr))
                break;
            // call isInNet.  Args need to be reversed
            switch (pdispparams->cArgs)
            {
            case 1:
                hr = weekdayRange(args[0]->bstrVal,NULL,NULL,pvarResult);
                break;
            case 2:
                if ((args[0]->bstrVal[0] == 'G') || (args[0]->bstrVal[0] == 'g'))
                    hr = weekdayRange(args[1]->bstrVal,NULL,args[0]->bstrVal,pvarResult);
                else
                    hr = weekdayRange(args[1]->bstrVal,args[0]->bstrVal,NULL,pvarResult);
                break;
            case 3:
                hr = weekdayRange(args[2]->bstrVal,args[1]->bstrVal,args[0]->bstrVal,pvarResult);
                break;
            }
            break;
        }
/*****************************************************************************
    Calling dateRange
*****************************************************************************/
    case DISPID_dateRange :
        break;
/*****************************************************************************
    Calling timeRange
*****************************************************************************/
    case DISPID_timeRange :
        break;
/*****************************************************************************
    Calling alert 
*****************************************************************************/
    case DISPID_alert :
        {
            // look in the DISPARAMS to make sure the signiture is correct for this function.
            if (pdispparams->cArgs != 1)
                hr = DISP_E_BADPARAMCOUNT;
            if (pdispparams->cNamedArgs > 0)
                hr = DISP_E_NONAMEDARGS;

            if (FAILED(hr))
                break;
            
            VARIANT arg1;
            
            // check the type of the variant in the disparams and if it is a bstr use it
            if (pdispparams->rgvarg[0].vt == VT_BSTR)
                arg1 = pdispparams->rgvarg[0];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            // call alert.
            hr = alert(arg1.bstrVal,pvarResult);
            break;
        }
/*****************************************************************************
    Default returning error code
*****************************************************************************/
    default:
        hr = DISP_E_MEMBERNOTFOUND;
    }

    return hr;
}


//  JScript Auto-Proxy config functions.
STDMETHODIMP CJSProxy::isPlainHostName(BSTR host, VARIANT* retval)
{
    WCHAR    *currentch;
    BOOL    bfound = FALSE;

    if (!host || !retval)
        return E_POINTER;

    retval->vt = VT_BOOL;

    // check to detemine whether this is a plain host name!
    currentch = host;
    while ((*currentch != '\0') && !bfound)
    {
        if (*currentch == '.')
            bfound = TRUE;
        else
            currentch++;
    }

    if (bfound)
        retval->boolVal = VARIANT_FALSE;
    else
        retval->boolVal = VARIANT_TRUE;

    return S_OK;
}

STDMETHODIMP CJSProxy::dnsDomainIs(BSTR host,BSTR domain, VARIANT* retval)
{
    WCHAR *result = NULL;

    if (!host || !domain || !retval)
        return E_POINTER;
    
    result = StrStrW(host,domain);
    retval->vt = VT_BOOL;
    if (result)
        retval->boolVal = VARIANT_TRUE;
    else
        retval->boolVal = VARIANT_FALSE;

    return S_OK;
}

STDMETHODIMP CJSProxy::localHostOrDomainIs(BSTR host,BSTR hostdom, VARIANT* retval)
{
    HRESULT    hr = S_OK;

    if (!host || !hostdom || !retval)
        return E_POINTER;

    // check to see if it is a local host
    hr = isPlainHostName(host,retval);
    if (SUCCEEDED(hr))
    {
        if (retval->boolVal != VARIANT_TRUE)
        {
            //
            // this is a strange function, if its not a local hostname
            //  we do a strait compare against the passed in domain
            //  string.  If its not a direct match, then its FALSE,
            //  even if the root of the domain/hostname are the same.
            //  Blame Netscape for this, we are just following their
            //  behavior and docs.
            //

            if ( StrCmpIW(host, hostdom) == 0 )
            {
                retval->boolVal = VARIANT_TRUE;
            }
            else
            {
                retval->boolVal = VARIANT_FALSE;
            }

        }
    }

    return hr;
}

// Functions that need to call back on wininet.
STDMETHODIMP CJSProxy::isResolvable(BSTR host, VARIANT* retval)
{
    
    if (!host || !retval)
        return E_POINTER;
    // call into wininet provided functions!
    retval->vt = VT_BOOL;
    if (m_pCallout)
    {
        MAKE_ANSIPTR_FROMWIDE(szhost,host);
        if (m_pCallout->IsResolvable(szhost)) 
            retval->boolVal = VARIANT_TRUE;
        else
            retval->boolVal = VARIANT_FALSE;
    }
    else
        retval->boolVal = VARIANT_FALSE;

    return S_OK;
}

STDMETHODIMP CJSProxy::isInNet(BSTR host, BSTR pattern, BSTR mask, VARIANT* retval)
{
    VARIANT    myretval;
    HRESULT    hr = S_OK;

    //  Because isInNet() is only called from Invoke(), a non-debug
    //check on m_fInitialized has already been done.
    INET_ASSERT(m_fInitialized);  
    
    // call into wininet provided functions!
    if (!host || !pattern || !mask || !retval)
        return E_POINTER;
    // call into wininet provided functions!
    retval->vt = VT_BOOL;
    DL(VariantInit)(&myretval);

    if (m_pCallout)
    {
        hr = dnsResolve(host,&myretval);
        if (SUCCEEDED(hr))
        {
            if (myretval.vt != VT_BSTR)
            {    
                DL(VariantClear)(&myretval);
                retval->boolVal = VARIANT_FALSE;        
                return hr;
            }
        }
        else
        {
            DL(VariantClear)(&myretval);
            retval->boolVal = VARIANT_FALSE;
            return hr;    
        }

        // Fallthrough to code to check IP/pattern and mask!
    
        MAKE_ANSIPTR_FROMWIDE(szhost,myretval.bstrVal);
        MAKE_ANSIPTR_FROMWIDE(szpattern,pattern);
        MAKE_ANSIPTR_FROMWIDE(szmask,mask);

        //  Check to see if IP address from dnsResolve matches the pattern/mask!
        if ( m_pCallout->IsInNet(szhost, szpattern, szmask ) ) 
            retval->boolVal = VARIANT_TRUE;
        else
            retval->boolVal = VARIANT_FALSE;
    }
    else
        retval->boolVal = VARIANT_FALSE;
    
    DL(VariantClear)(&myretval);
    return S_OK;
}

STDMETHODIMP CJSProxy::dnsResolve(BSTR host, VARIANT* retval)
{
    char ipaddress[16];
    DWORD dwretval;
    DWORD dwipsize = 16;

    if (!host || !retval)
        return E_POINTER;
    // call into wininet provided functions!

    if (m_pCallout)
    {
        MAKE_ANSIPTR_FROMWIDE(szhost,host);
        dwretval = m_pCallout->ResolveHostName(szhost,ipaddress,&dwipsize); 
        if (dwretval == ERROR_SUCCESS)
        {
            retval->vt = VT_BSTR;
            retval->bstrVal = MakeWideStrFromAnsi((LPSTR)ipaddress,STR_BSTR);
        }
        else
        {
            retval->vt = VT_BOOL;
            retval->boolVal = VARIANT_FALSE;
        }
    }
    else
    {    
        retval->vt = VT_BOOL;
        retval->boolVal = VARIANT_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CJSProxy::myIpAddress(VARIANT* retval)
{
    char ipaddress[16];
    DWORD dwretval;
    DWORD dwipsize = 16;

    if (!retval)
        return E_POINTER;
    // call into wininet provided functions!

    if (m_pCallout)
    {
        dwretval = m_pCallout->GetIPAddress(ipaddress,&dwipsize);
        if (dwretval == ERROR_SUCCESS)
        {
            retval->vt = VT_BSTR;
            retval->bstrVal = MakeWideStrFromAnsi((LPSTR)ipaddress,STR_BSTR);
        }
        else
        {
            retval->vt = VT_BOOL;
            retval->boolVal = VARIANT_FALSE;
        }
    }
    else
    {    
        retval->vt = VT_BOOL;
        retval->boolVal = VARIANT_FALSE;
    }

    return S_OK;
}

// Back to functions implemented here.
STDMETHODIMP CJSProxy::dnsDomainLevels(BSTR host, VARIANT* retval)
{
    WCHAR    *currentch;
    DWORD    dwlevels = 0;

    if (!host || !retval)
        return E_POINTER;

    retval->vt = VT_I4;

    // check to detemine whether this is a plain host name!
    currentch = host;
    while (*currentch != L'\0')
    {
        if (*currentch == L'.')
            dwlevels++;

        currentch++;
    }

    retval->lVal = dwlevels;

    return S_OK;
}

STDMETHODIMP CJSProxy::shExpMatch(BSTR str, BSTR shexp, VARIANT* retval)
{

    if (!str || !shexp || !retval)
        return E_POINTER;

    retval->vt = VT_BOOL;
    // convert BSTR to ansi - these macros allocate memory that is freed when they
    // go out of scope!  No need to free!
    MAKE_ANSIPTR_FROMWIDE(szstr, str);
    MAKE_ANSIPTR_FROMWIDE(szshexp, shexp);
    // Call into the regular expression matching code.
    if (match(szstr,szshexp))
        retval->boolVal = VARIANT_TRUE;
    else
        retval->boolVal = VARIANT_FALSE;

    return S_OK;
}

// These are to do last!!!.
STDMETHODIMP CJSProxy::weekdayRange(BSTR wd1, BSTR wd2, BSTR gmt, VARIANT* retval)
{
    SYSTEMTIME    systime;
    char        szday[4];
    int            today = -1;
    int            day1 = -1; // days are as follows SUN = 0; MON = 1; ...;SAT = 6.
    int            day2 = -1;  
    BOOL        bIsInRange = FALSE;

    if (!wd1)
        return E_POINTER;
    if (gmt)
        GetSystemTime(&systime);

    GetDateFormat(//LOCALE_SYSTEM_DEFAULT,
                    MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US),SORT_DEFAULT),
                    NULL,
                    gmt? &systime:NULL,
                    "ddd",
                    szday,
                    4);

    if (szday)
    {
        int lcv;
        //convert all chars to upper if lowercase (don't use runtimes)
        for (lcv=0;lcv<3;lcv++)
        {
            if ((short)szday[lcv] > 90)
                szday[lcv]-=32;
        }

        today = ConvertAnsiDayToInt(szday);
    }
    
    if (today == -1)
        return E_FAIL;
    
    // compare day ranges!
    if (wd2)
    {
        // These are by definition in ALL CAPS
        MAKE_ANSIPTR_FROMWIDE(szwd1, wd1);
        MAKE_ANSIPTR_FROMWIDE(szwd2, wd2);
        if (szwd1 && szwd2)
        {
            day1 = ConvertAnsiDayToInt(szwd1);
            day2 = ConvertAnsiDayToInt(szwd2);
        }

        if ((day1 == -1) || (day2 == -1))
            return E_INVALIDARG;

        if (day1 < day2)
        {
            if ((today >= day1) && (today <= day2))
                bIsInRange = TRUE;
            else
                bIsInRange = FALSE;
        }
        else if ( day1 == day2 )
        {
            if (today == day1)
            {
                bIsInRange = TRUE;
            }
            else
            {
                bIsInRange = FALSE;
            }
        }
        else
        {
            if ((today >= day1) || (today <= day2))
                bIsInRange = TRUE;
            else
                bIsInRange = FALSE;
        }

    }
    else // only one day to check!
    {
        MAKE_ANSIPTR_FROMWIDE(szwd1, wd1);
        if (lstrcmp(szday,szwd1) == 0)
            bIsInRange = TRUE;
        else
            bIsInRange = FALSE;
    }

    if (bIsInRange)
    {
        retval->vt = VT_BOOL;
        retval->boolVal = VARIANT_TRUE;
    }
    else
    {
        retval->vt = VT_BOOL;
        retval->boolVal = VARIANT_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CJSProxy::dateRange(long day, BSTR month, BSTR gmt, VARIANT* retval)
{
    UNREFERENCED_PARAMETER(day);
    UNREFERENCED_PARAMETER(month);
    UNREFERENCED_PARAMETER(gmt);
    UNREFERENCED_PARAMETER(retval);
    return S_OK;
}
STDMETHODIMP CJSProxy::timeRange(long hour, long min, long sec, BSTR gmt, VARIANT* retval)
{
    UNREFERENCED_PARAMETER(hour);
    UNREFERENCED_PARAMETER(min);
    UNREFERENCED_PARAMETER(sec);
    UNREFERENCED_PARAMETER(gmt);
    UNREFERENCED_PARAMETER(retval);
    return S_OK;
}

STDMETHODIMP CJSProxy::alert(BSTR message, VARIANT* retval)
{
    if (!message)
        return E_POINTER;

    // Return true if available...not needed?
    if (retval)
    {
        retval->vt = VT_BOOL;
        retval->vt = VARIANT_FALSE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\dhcppro.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    lproto.h

Abstract:

    This file contains function proto types for the NT specific
    functions.

Author:

    Madan Appiah (madana)  Dec-7-1993

Environment:

    User Mode - Win32

Revision History:


--*/

//
// dhcpreg.c
//

DWORD
DhcpRegQueryInfoKey(
    HKEY KeyHandle,
    LPDHCP_KEY_QUERY_INFO QueryInfo
    );

DWORD
GetRegistryString(
    HKEY Key,
    LPVOID ValueStringName,
    LPTSTR *String,
    LPDWORD StringSize
    );

DWORD
DhcpRegReadParamString(
    LPWSTR     AdapterName,
    LPWSTR     RegKeyLocation,
    LPWSTR     ValueName,
    LPWSTR    *ReturnValue
);

DWORD
RegSetIpAddress(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    DHCP_IP_ADDRESS IpAddress
    );

#if DBG
DWORD
RegSetTimeField(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    time_t Time
    );
#endif

DWORD
DhcpGetRegistryValue(
    LPWSTR RegKey,
    LPWSTR ValueName,
    DWORD ValueType,
    PVOID *Data
    );

DWORD
DhcpSetDNSAddress(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    DHCP_IP_ADDRESS UNALIGNED *Data,
    DWORD DataLength
    );

DWORD
SetDhcpOption(
    LPWSTR AdapterName,
    DHCP_OPTION_ID OptionId,
    LPBOOL DefaultGatewaysSet,
    BOOL LastKnownDefaultGateway
    );

DWORD
DhcpMakeNICList(
    VOID
    );

DWORD
DhcpAddNICtoList(
    LPWSTR AdapterName,
    LPWSTR DeviceName,
    PDHCP_CONTEXT *DhcpContext
    );

#if     defined(_PNP_POWER_)
DWORD
DhcpAddNICtoListEx(
    LPWSTR AdapterName,
    DWORD  ipInterfaceContext,
    PDHCP_CONTEXT *DhcpContext
    );

#endif _PNP_POWER_
BOOL
SetOverRideDefaultGateway(
    LPWSTR AdapterName
    );

BOOL
DhcpGetAddressOption(
    DHCP_IP_ADDRESS **ppDNSServerList,
    DWORD            *pNumberOfServers
    );


BOOL
DhcpRegReadUseMHAsyncDnsFlag(
    VOID
);

DWORD                                             // Win32 status
DhcpInitRegistry(                                 // Initialize registry based globals
    VOID
);

VOID
DhcpCleanupRegistry(                              // undo the effects of InitReg call
    VOID
);


DHCP_IP_ADDRESS                                   // the static ip address of the adapter
DhcpRegReadIpAddress(                             // get the first ip address
    LPWSTR    AdapterName,                        // the adaptor of interest
    LPWSTR    ValueName                           // the ip address value to read
);

DWORD                                             // status
DhcpRegReadIpAddresses(                           // read a set of ip addresses
    IN      DHCPKEY                RegKeyHandle,  // open key handle
    IN      LPWSTR                 ValueName,     // name of value to read frm
    IN      WCHAR                  Separation,    // a MULTI_SZ has L'\0', SZ has L' ' or L',' etc.
    OUT     PDHCP_IP_ADDRESS      *AddressArray,  // an array of addresses
    OUT     LPDWORD                AddressCount   // the output size of above array
);

VOID
DhcpRegInitializeClasses(                         // initialize the classes list
    IN OUT  PDHCP_CONTEXT          DhcpContext    // NULL or adpater context
);

DWORD                                             // status
DhcpGetRegistryValueWithKey(                      // see defn of GetRegistryValue
    IN      HKEY                   KeyHandle,     // keyhandle NOT location
    IN      LPTSTR                 ValueName,     // value to read from registry
    IN      DWORD                  ValueType,     // type of value
    OUT     LPVOID                 Data           // this will be filled in
);

DWORD                                             // status
DhcpRegExpandString(                              // replace '?' with AdapterName
    IN      LPWSTR                 InString,      // input string to expand
    IN      LPWSTR                 AdapterName,   // the adapter name
    OUT     LPWSTR                *OutString,     // the output ptr to store string
    IN OUT  LPWSTR                 Buffer         // the buffer to use if non NULL
);

DWORD                                             // status
DhcpRegReadFromLocation(                          // read from one location
    IN      LPWSTR                 OneLocation,   // value to read from
    IN      LPWSTR                 AdapterName,   // replace '?' with adapternames
    OUT     LPBYTE                *Value,         // output value
    OUT     DWORD                 *ValueType,     // data type of value
    OUT     DWORD                 *ValueSize      // the size in bytes
);

DWORD                                             // status
DhcpRegReadFromAnyLocation(                       // read from one of many locations
    IN      LPWSTR                 MzRegLocation, // multiple locations thru REG_MULTI_MZ
    IN      LPWSTR                 AdapterName,   // may have to replace '?' with AdapterName
    OUT     LPBYTE                *Value,         // data for the value read
    OUT     DWORD                 *ValueType,     // type of the data
    OUT     DWORD                 *ValueSize      // the size of data
);

DWORD                                             // win32 status
DhcpRegFillParams(                                // get the registry config for this adapter
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // adapter context to fill in
    IN      BOOL                   ReadAllInfo    // read EVERYTHING or only some critical info?
);

VOID
DhcpRegReadClassId(                               // Read the class id stuff
    IN      PDHCP_CONTEXT          DhcpContext    // Input context to read for
);

//
// ioctl.c
//

DWORD
IPSetIPAddress(
    DWORD IpInterfaceContext,
    DHCP_IP_ADDRESS IpAddress,
    DHCP_IP_ADDRESS SubnetMask
    );

DWORD
IPAddIPAddress(
    LPWSTR AdapterName,
    DHCP_IP_ADDRESS Address,
    DHCP_IP_ADDRESS SubnetMask
    );

DWORD
IPResetIPAddress(
    DWORD           dwInterfaceContext,
    DHCP_IP_ADDRESS SubnetMask
    );


DWORD
SetIPAddressAndArp(
    PVOID         pvLocalInformation,
    DWORD         dwAddress,
    DWORD         dwSubnetMask
    );


DWORD
NetBTSetIPAddress(
    LPWSTR DeviceName,
    DHCP_IP_ADDRESS IpAddress,
    DHCP_IP_ADDRESS SubnetMask
    );

DWORD
NetBTResetIPAddress(
    LPWSTR DeviceName,
    DHCP_IP_ADDRESS SubnetMask
    );

DWORD
NetBTNotifyRegChanges(
    LPWSTR DeviceName
    );

DWORD
SetDefaultGateway(
    DWORD Command,
    DHCP_IP_ADDRESS GatewayAddress
    );

HANDLE
DhcpOpenGlobalEvent(
    void
    );

#if     defined(_PNP_POWER_) && !defined(VXD)
DWORD
IPGetIPEventRequest(
    HANDLE  handle,
    HANDLE  event,
    UINT    seqNo,
    PIP_GET_IP_EVENT_RESPONSE  responseBuffer,
    DWORD                responseBufferSize,
    PIO_STATUS_BLOCK     ioStatusBlock
    );

DWORD
IPCancelIPEventRequest(
    HANDLE  handle,
    PIO_STATUS_BLOCK     ioStatusBlock
    );

#endif _PNP_POWER_ && !VXD

//
// api.c
//

DWORD
DhcpApiInit(
    VOID
    );



VOID
DhcpApiCleanup(
    VOID
    );

DWORD
ProcessApiRequest(
    HANDLE PipeHandle,
    LPOVERLAPPED Overlap
    );

//
// util.c
//


PDHCP_CONTEXT
FindDhcpContextOnRenewalList(
    LPWSTR AdapterName,
    DWORD  InterfaceContext
    );

PDHCP_CONTEXT
FindDhcpContextOnNicList(
    LPWSTR AdapterName,
    DWORD  InterfaceContext
    );

BOOL
IsMultiHomeMachine(
    VOID
    );


//
// options.c
//


SERVICE_SPECIFIC_DHCP_OPTION *
FindDhcpOption(
    DHCP_OPTION_ID OptionID
    );


DWORD
ReadGlobalOptionList();

DWORD
LoseAllEnvSpecificOptions(
    PDHCP_CONTEXT   dhcpContext
);


//
// dhcp.c
//

DWORD
SetIpConfigurationForNIC(
    HKEY            KeyHandle,
    PDHCP_CONTEXT   DhcpContext,
    PDHCP_OPTIONS   DhcpOptions,
    DHCP_IP_ADDRESS ServerIpAddress,
    DWORD           dwLeaseTime,
    DWORD           dwT1Time,
    DWORD           dwT2Time,
    BOOL            ObtainedNewAddress
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\llinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//** LLINFO.H - Lower layer SNMP information definitions.
//
// This file contains all of the definitions for SNMP information collected
// by layers below IP.

#ifndef	LLINFO_INCLUDED
#define	LLINFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


#define	IF_MIB_STATS_ID		1

#define	MAX_PHYSADDR_SIZE	8

typedef struct IPNetToMediaEntry {
	ulong			inme_index;
	ulong			inme_physaddrlen;
	uchar			inme_physaddr[MAX_PHYSADDR_SIZE];
	ulong			inme_addr;
	ulong			inme_type;
} IPNetToMediaEntry;

#define	INME_TYPE_OTHER			1
#define	INME_TYPE_INVALID		2
#define	INME_TYPE_DYNAMIC		3
#define	INME_TYPE_STATIC		4

#define	MAX_IFDESCR_LEN			256

#define	IFE_FIXED_SIZE	offsetof(struct IFEntry, if_descr)

typedef struct IFEntry {
	ulong			if_index;
	ulong			if_type;
	ulong			if_mtu;
	ulong			if_speed;
	ulong			if_physaddrlen;
	uchar			if_physaddr[MAX_PHYSADDR_SIZE];
	ulong			if_adminstatus;
	ulong			if_operstatus;
	ulong			if_lastchange;
	ulong			if_inoctets;
	ulong			if_inucastpkts;
	ulong			if_innucastpkts;
	ulong			if_indiscards;
	ulong			if_inerrors;
	ulong			if_inunknownprotos;
	ulong			if_outoctets;
	ulong			if_outucastpkts;
	ulong			if_outnucastpkts;
	ulong			if_outdiscards;
	ulong			if_outerrors;
	ulong			if_outqlen;
	ulong			if_descrlen;
	uchar			if_descr[1];
} IFEntry;

#define	IF_TYPE_OTHER	  	1
#define	IF_TYPE_ETHERNET	6
#define	IF_TYPE_TOKENRING	9
#define	IF_TYPE_FDDI		15
#define	IF_TYPE_PPP			23
#define	IF_TYPE_LOOPBACK	24
#define	IF_TYPE_SLIP		28

#define	IF_STATUS_UP		1
#define	IF_STATUS_DOWN		2
#define	IF_STATUS_TESTING	3


#endif // LLINFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\jsproxy.h ===
#ifndef __JSPROXY_H__
#define __JSPROXY_H__

#include <windows.h>
#include <olectl.h>
#include "utils.h"
#include "regexp.h"

#define VAL_isPlainHostName			0x01f9
#define VAL_dnsDomainIs				0x01f8
#define VAL_localHostOrDomainIs		0x020b
#define VAL_isResolvable			0x0206
#define VAL_isInNet					0x01e1
#define VAL_dnsResolve				0x01fc
#define VAL_myIpAddress				0x01e0
#define VAL_dnsDomainLevels			0x01f8
#define VAL_shExpMatch				0x0208
#define VAL_weekdayRange			0x0210
#define VAL_dateRange				0x01f0
#define VAL_timeRange				0x0201
#define VAL_alert				0x0218

#define DISPID_isPlainHostName		0x0001
#define DISPID_dnsDomainIs			0x0002
#define DISPID_localHostOrDomainIs	0x0003
#define DISPID_isResolvable			0x0004
#define DISPID_isInNet				0x0005
#define DISPID_dnsResolve			0x0006
#define DISPID_myIpAddress			0x0007
#define DISPID_dnsDomainLevels		0x0008
#define DISPID_shExpMatch			0x0009
#define DISPID_weekdayRange			0x000a
#define DISPID_dateRange			0x000b
#define DISPID_timeRange			0x000c
#define DISPID_alert				0x000d

/************************************************************************************************/
// This class implements the Dispatch interface that will allow the script engine to call the 
// auto-proxy configuration functions.  This interface does not have a typelib and does not provide type
// info.
class CJSProxy : public IDispatch
{

public:

	CJSProxy();
	~CJSProxy();
	// IUnknown Methods
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObject)
	{

		if (riid == IID_IUnknown || 
            riid == IID_IDispatch)
		{
			*ppvObject = (LPVOID)(LPUNKNOWN)this;
            AddRef();
			return S_OK;
		}
		else
		{
			if (riid == IID_IDispatch)
			{
				*ppvObject = (LPVOID)(IDispatch*)this;
                AddRef();
				return S_OK;
			}
			else
			{
				*ppvObject = 0;
				return E_NOINTERFACE;
			}
		}

	}

	STDMETHODIMP_(ULONG) AddRef()
	{
		return ++m_refCount;
	}

	STDMETHODIMP_(ULONG) Release()
	{
		if (--m_refCount)
			return m_refCount;

		delete this;
		return 0;
	}

	// IDispatch Methods
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo)
	{
		*pctinfo = 0;
		return S_OK;
	}

    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{
        UNREFERENCED_PARAMETER(itinfo);
        UNREFERENCED_PARAMETER(lcid);
        UNREFERENCED_PARAMETER(pptinfo);
		return TYPE_E_ELEMENTNOTFOUND;
	}

    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames,UINT cNames, LCID lcid, DISPID FAR* rgdispid);

    STDMETHODIMP Invoke(
					DISPID dispidMember,
					REFIID riid,
					LCID lcid,
					WORD wFlags,
					DISPPARAMS* pdispparams,
					VARIANT* pvarResult,
					EXCEPINFO* pexcepinfo,
					UINT* puArgErr);

	//  JScript Auto-Proxy config functions.
	STDMETHODIMP isPlainHostName(BSTR host, VARIANT* retval);
	STDMETHODIMP dnsDomainIs(BSTR host,BSTR domain, VARIANT* retval);
	STDMETHODIMP localHostOrDomainIs(BSTR host,BSTR hostdom, VARIANT* retval);
	STDMETHODIMP isResolvable(BSTR host, VARIANT* retval);
	STDMETHODIMP isInNet(BSTR host, BSTR pattern, BSTR mask, VARIANT* retval);
	STDMETHODIMP dnsResolve(BSTR host, VARIANT* retval);
	STDMETHODIMP myIpAddress(VARIANT* retval);
	STDMETHODIMP dnsDomainLevels(BSTR host, VARIANT* retval);
	STDMETHODIMP shExpMatch(BSTR str, BSTR shexp, VARIANT* retval);
	STDMETHODIMP alert(BSTR message, VARIANT* retval);

	// These are to do last!!!.
	STDMETHODIMP weekdayRange(BSTR wd1, BSTR wd2, BSTR gmt, VARIANT* retval);
	STDMETHODIMP dateRange(long day, BSTR month, BSTR gmt, VARIANT* retval);
	STDMETHODIMP timeRange(long hour, long min, long sec, BSTR gmt, VARIANT* retval);
	//	ProxyConfig.bindings 

	STDMETHODIMP Init(AUTO_PROXY_HELPER_APIS* pAPHA);
	STDMETHODIMP DeInit();
	
	// JScript private members
private:
	long					m_refCount;
	BOOL					m_fDestroyable;
	BOOL					m_fInitialized;
	AUTO_PROXY_HELPER_APIS*	m_pCallout;
	LPCWSTR					m_strings[13];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\ipinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//** IPINFO.H - IP SNMP information definitions..
//
// This file contains all of the definitions for IP that are
// related to SNMP information gathering.

#ifndef IPINFO_INCLUDED
#define IPINFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


typedef struct IPSNMPInfo {
        ulong           ipsi_forwarding;
        ulong           ipsi_defaultttl;
        ulong           ipsi_inreceives;
        ulong           ipsi_inhdrerrors;
        ulong           ipsi_inaddrerrors;
        ulong           ipsi_forwdatagrams;
        ulong           ipsi_inunknownprotos;
        ulong           ipsi_indiscards;
        ulong           ipsi_indelivers;
        ulong           ipsi_outrequests;
        ulong           ipsi_routingdiscards;
        ulong           ipsi_outdiscards;
        ulong           ipsi_outnoroutes;
        ulong           ipsi_reasmtimeout;
        ulong           ipsi_reasmreqds;
        ulong           ipsi_reasmoks;
        ulong           ipsi_reasmfails;
        ulong           ipsi_fragoks;
        ulong           ipsi_fragfails;
        ulong           ipsi_fragcreates;
        ulong           ipsi_numif;
        ulong           ipsi_numaddr;
        ulong           ipsi_numroutes;
} IPSNMPInfo;

typedef struct ICMPStats {
        ulong           icmps_msgs;
        ulong           icmps_errors;
        ulong           icmps_destunreachs;
        ulong           icmps_timeexcds;
        ulong           icmps_parmprobs;
        ulong           icmps_srcquenchs;
        ulong           icmps_redirects;
        ulong           icmps_echos;
        ulong           icmps_echoreps;
        ulong           icmps_timestamps;
        ulong           icmps_timestampreps;
        ulong           icmps_addrmasks;
        ulong           icmps_addrmaskreps;
} ICMPStats;

typedef struct ICMPSNMPInfo {
        ICMPStats       icsi_instats;
        ICMPStats       icsi_outstats;
} ICMPSNMPInfo;

#define IP_FORWARDING           1
#define IP_NOT_FORWARDING       2

typedef struct IPAddrEntry {
        ulong           iae_addr;
        ulong           iae_index;
        ulong           iae_mask;
        ulong           iae_bcastaddr;
        ulong           iae_reasmsize;
        ushort          iae_context;
        ushort          iae_pad;
} IPAddrEntry;

typedef struct IPRouteEntry {
        ulong           ire_dest;
        ulong           ire_index;
        ulong           ire_metric1;
        ulong           ire_metric2;
        ulong           ire_metric3;
        ulong           ire_metric4;
        ulong           ire_nexthop;
        ulong           ire_type;
        ulong           ire_proto;
        ulong           ire_age;
        ulong           ire_mask;
        ulong           ire_metric5;
        ulong           ire_context;
} IPRouteEntry;

typedef struct IPRouteEntry95 {
        ulong           ire_dest;
        ulong           ire_index;
        ulong           ire_metric1;
        ulong           ire_metric2;
        ulong           ire_metric3;
        ulong           ire_metric4;
        ulong           ire_nexthop;
        ulong           ire_type;
        ulong           ire_proto;
        ulong           ire_age;
        ulong           ire_mask;
        ulong           ire_metric5;
} IPRouteEntry95;

typedef struct AddrXlatInfo {
        ulong           axi_count;
        ulong           axi_index;
} AddrXlatInfo;

#define IRE_TYPE_OTHER          1
#define IRE_TYPE_INVALID        2
#define IRE_TYPE_DIRECT         3
#define IRE_TYPE_INDIRECT       4

#define IRE_PROTO_OTHER         1
#define IRE_PROTO_LOCAL         2
#define IRE_PROTO_NETMGMT       3
#define IRE_PROTO_ICMP          4
#define IRE_PROTO_EGP           5
#define IRE_PROTO_GGP           6
#define IRE_PROTO_HELLO         7
#define IRE_PROTO_RIP           8
#define IRE_PROTO_IS_IS         9
#define IRE_PROTO_ES_IS         10
#define IRE_PROTO_CISCO         11
#define IRE_PROTO_BBN           12
#define IRE_PROTO_OSPF          13
#define IRE_PROTO_BGP           14

#define IRE_METRIC_UNUSED       0xffffffff

#define IP_MIB_STATS_ID                                 1
#define ICMP_MIB_STATS_ID                               1

#define AT_MIB_ADDRXLAT_INFO_ID                 1
#define AT_MIB_ADDRXLAT_ENTRY_ID                0x101

#define IP_MIB_RTTABLE_ENTRY_ID                 0x101
#define IP_MIB_ADDRTABLE_ENTRY_ID               0x102

#define IP_INTFC_FLAG_P2P   1

typedef struct IPInterfaceInfo {
    ulong       iii_flags;
    ulong       iii_mtu;
    ulong       iii_speed;
    ulong       iii_addrlength;
    uchar       iii_addr[1];
} IPInterfaceInfo;

#define IP_INTFC_INFO_ID                0x103

#endif // IPINFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\options.h ===
//================================================================================
//  Copyright (C) Microsoft Corporation 1997.
//  Author: RameshV
//  Date: 09-Sep-97 06:20
//  Description: Manages the class-id and options information
//================================================================================

#ifndef OPTIONS_H
#define OPTIONS_H

#define MAX_DATA_LEN               255            // atmost 255 bytes for an option

typedef struct _DHCP_CLASSES {                    // common pool of class names
    LIST_ENTRY                     ClassList;     // global list of classes
    LPBYTE                         ClassName;     // name of the class
    DWORD                          ClassLen;      // # of bytes in class name
    DWORD                          RefCount;      // # of references to this
} DHCP_CLASSES, *LPDHCP_CLASSES, *PDHCP_CLASSES;

typedef struct _DHCP_OPTION  {                    // list of options
    LIST_ENTRY                     OptionList;    // the fwd/back ptrs
    BYTE                           OptionId;      // the option value
    BOOL                           IsVendor;      // is this vendor specific
    LPBYTE                         ClassName;     // the class of this option
    DWORD                          ClassLen;      // the length of above option
    time_t                         ExpiryTime;    // when this option expires
    LPBYTE                         Data;          // the data value for this option
    DWORD                          DataLen;       // the # of bytes of above
} DHCP_OPTION , *LPDHCP_OPTION , *PDHCP_OPTION ;

typedef struct _DHCP_OPTION_DEF {
    LIST_ENTRY                     OptionDefList; // list of option definitions
    BYTE                           OptionId;      // the option id
    BOOL                           IsVendor;      // is this vendor specific?
    LPBYTE                         ClassName;     // the class this belongs to
    DWORD                          ClassLen;      // the size of above in bytes

    LPWSTR                         RegSendLoc;    // where is the info about sending this out
    LPWSTR                         RegSaveLoc;    // where is this option going to be stored?
    DWORD                          RegValueType;  // as what value should this be stored?
} DHCP_OPTION_DEF, *LPDHCP_OPTION_DEF, *PDHCP_OPTION_DEF;


//================================================================================
//  exported functions classes
//================================================================================

//--------------------------------------------------------------------------------
// In all of the following functions, ClassesList is unprotected within the fn.
// Caller has to take a lock on it.
//--------------------------------------------------------------------------------
LPBYTE                                            // data bytes, or NULL (no mem)
DhcpAddClass(                                     // add a new class
    IN OUT  PLIST_ENTRY            ClassesList,   // list to add to
    IN      LPBYTE                 Data,          // input class name
    IN      DWORD                  Len            // # of bytes of above
);  // Add the new class into the list or bump up ref count if already there

DWORD                                             // status (FILE_NOT_FOUND => no such class)
DhcpDelClass(                                     // de-refernce a class
    IN OUT  PLIST_ENTRY            ClassesList,   // the list to delete off
    IN      LPBYTE                 Data,          // the data ptr
    IN      DWORD                  Len            // the # of bytes of above
);  // decrease refcount in the list and if becomes zero, free the struct

VOID                                              // always succeeds
DhcpFreeAllClasses(                               // free each elt of the list
    IN OUT  PLIST_ENTRY            ClassesList    // input list of classes
);  // free every class in the list

//--------------------------------------------------------------------------------
// In all the following functions, OptionsList is unprotected within the fn.
// Caller has to take a lock on it.
//--------------------------------------------------------------------------------

PDHCP_OPTION                                      // the reqd structure or NULL
DhcpFindOption(                                   // find a specific option
    IN OUT  PLIST_ENTRY            OptionsList,   // the list of options to search
    IN      BYTE                   OptionId,      // the option id to search for
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // is there a class associated?
    IN      DWORD                  ClassLen       // # of bytes of above parameter
);  // search for the required option in the list, return NULL if not found

DWORD                                             // status or ERROR_FILE_NOT_FOUND
DhcpDelOption(                                    // remove a particular option
    IN      PDHCP_OPTION           Option2Delete  // delete this option
);  // delete an existing option in the list, and free up space used

DWORD                                             // status
DhcpAddOption(                                    // add a new option
    IN OUT  PLIST_ENTRY            OptionsList,   // list to add to
    IN      BYTE                   OptionId,      // option id to add
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // what is the class?
    IN      DWORD                  ClassLen,      // size of above in bytes
    IN      LPBYTE                 Data,          // data for this option
    IN      DWORD                  DataLen,       // # of bytes of above
    IN      time_t                 ExpiryTime     // when the option expires
);  // replace or add new option to the list.  fail if not enough memory

VOID                                              // always succeeds
DhcpFreeAllOptions(                               // frees all the options
    IN OUT  PLIST_ENTRY            OptionsList    // input list of options
);  // free every option in the list

time_t                                            // 0 || time for next expiry (absolute)
DhcpGetExpiredOptions(                            // delete all expired options
    IN OUT  PLIST_ENTRY            OptionsList,   // list to search frm
    OUT     PLIST_ENTRY            ExpiredOptions // o/p list of expired options
);  // move expired options between lists and return timer. 0 => switch off timer.

//--------------------------------------------------------------------------------
//  In all the following functions, OptionsDefList is unprotected.  Caller has
//  to take a lock on it.
//--------------------------------------------------------------------------------

DWORD                                             // status
DhcpAddOptionDef(                                 // add a new option definition
    IN OUT  PLIST_ENTRY            OptionDefList, // input list of options to add to
    IN      BYTE                   OptionId,      // option to add
    IN      BOOL                   IsVendor,      // is it vendor specific
    IN      LPBYTE                 ClassName,     // name of class it belongs to
    IN      DWORD                  ClassLen,      // the size of above in bytes
    IN      LPWSTR                 RegSendLoc,    // where to get info about sending this out
    IN      LPWSTR                 RegSaveLoc,    // where to get info about saving this
    IN      DWORD                  ValueType      // what is the type when saving it?
);

PDHCP_OPTION_DEF                                  // NULL, or requested option def
DhcpFindOptionDef(                                // search for a particular option
    IN      PLIST_ENTRY            OptionDefList, // list to search in
    IN      BYTE                   OptionId,      // the option id to search for
    IN      BOOL                   IsVendor,      // is it vendor specific
    IN      LPBYTE                 ClassName,     // the class, if one exists
    IN      DWORD                  ClassLen       // # of bytes of class name
);

DWORD                                             // status
DhcpDelOptionDef(                                 // delete a particular option def
    IN      PLIST_ENTRY            OptionDefList, // list to delete from
    IN      BYTE                   OptionId,      // the option id to delete
    IN      BOOL                   IsVendor,      // is it vendor specific
    IN      LPBYTE                 ClassName,     // the class, if one exists
    IN      DWORD                  ClassLen       // # of bytes of class name
);

VOID
DhcpFreeAllOptionDefs(                            // free each element of a list
    IN OUT  PLIST_ENTRY            OptionDefList, // the list to free
    IN OUT  PLIST_ENTRY            ClassesList    // classes to de-ref off
);

BOOL                                              // TRUE==>found..
DhcpOptionsFindDomain(                            // find the domain name option values
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // for this adapter
    OUT     LPBYTE                *Data,          // fill this ptr up
    OUT     LPDWORD                DataLen
);

#endif  OPTIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\optchg.h ===
//================================================================================
// Copyright (c) 1997 Microsoft Corporation
// Author: RameshV
// Description: handles the noticiations and other mechanisms for parameter
//      changes (options )
//================================================================================

#ifndef OPTCHG_H_INCLUDED
#define OPTCHG_H_INCLUDED

//================================================================================
// exported APIS
//================================================================================
DWORD                                             // win32 status
DhcpAddParamChangeRequest(                        // add a new param change notification request
    IN      LPWSTR                 AdapterName,   // for this adapter, can be NULL
    IN      LPBYTE                 ClassId,       // what class id does this belong to?
    IN      DWORD                  ClassIdLength, // how big is this class id?
    IN      LPBYTE                 OptList,       // this is the list of options of interest
    IN      DWORD                  OptListSize,   // this is the # of bytes of above
    IN      BOOL                   IsVendor,      // is this vendor specific?
    IN      DWORD                  ProcId,        // which is the calling process?
    IN      DWORD                  Descriptor,    // what is the unique descriptor in this process?
    IN      HANDLE                 Handle         // what is the handle in the calling process space?
);

DWORD                                             // win32 status
DhcpDelParamChangeRequest(                        // delete a particular request
    IN      DWORD                  ProcId,        // the process id of the caller
    IN      HANDLE                 Handle         // the handle as used by the calling process
);

DWORD                                             // win32 status
DhcpMarkParamChangeRequests(                      // find all params that are affected and mark then as pending
    IN      LPTSTR                 AdapterName,   // adapter of relevance
    IN      BYTE                   OptionId,      // the option id itself
    IN      BOOL                   IsVendor,      // is this vendor specific
    IN      LPBYTE                 ClassId        // which class --> this must be something that has been ADD-CLASSED
);

typedef DWORD (*DHCP_NOTIFY_FUNC)(                // this is the type of the fucntion that actually notifies clients of option change
    IN      DWORD                  ProcId,        // <ProcId + Descriptor> make a unique key used for finding the event
    IN      DWORD                  Descriptor     // --- on Win98, only Descriptor is really needed.
);                                                // if return value is NOT error success, we delete this request

DWORD                                             // win32 status
DhcpNotifyMarkedParamChangeRequests(              // notify pending param change requests
    IN      DHCP_NOTIFY_FUNC       NotifyHandler  // call this function for each unique id that is present
);


DWORD                                             // win32 status
DhcpNotifyClientOnParamChange(                    // notify clients
    IN      DWORD                  ProcId,        // which process called this
    IN      DWORD                  Descriptor     // unique descriptor for that process
);

DWORD                                             // win32 status
DhcpInitializeParamChangeRequests(                // initialize everything in this file
    VOID
);

VOID
DhcpCleanupParamChangeRequests(                   // unwind this module
    VOID
);

DWORD                                             // win32 status
DhcpAddParamRequestChangeRequestList(             // add to the request list the list of params registered for notifications
    IN      LPWSTR                 AdapterName,   // which adatper is this request list being requested for?
    IN      LPBYTE                 Buffer,        // buffer to add options to
    IN OUT  LPDWORD                Size,          // in: existing filled up size, out: total size filled up
    IN      LPBYTE                 ClassName,     // ClassId
    IN      DWORD                  ClassLen       // size of ClassId in bytes
);

#endif OPTCHG_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\optreg.h ===
//--------------------------------------------------------------------------------
// Copyright (C) Micorosoft Confidential 1997
// Author: RameshV
// Description: Option related registry handling -- common between NT and VxD
//--------------------------------------------------------------------------------
#ifndef  OPTREG_H
#define  OPTREG_H
//--------------------------------------------------------------------------------
// Exported functions: Caller must take locks and any lists accessed
//--------------------------------------------------------------------------------

POPTION                                           // option from which more appends can occur
DhcpAppendSendOptions(                            // append all configured options
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // this is the context to append for
    IN      PLIST_ENTRY            SendOptionsList,
    IN      LPBYTE                 ClassName,     // current class
    IN      DWORD                  ClassLen,      // len of above in bytes
    IN      LPBYTE                 BufStart,      // start of buffer
    IN      LPBYTE                 BufEnd,        // how far can we go in this buffer
    IN OUT  LPBYTE                 SentOptions,   // BoolArray[OPTION_END+1] to avoid repeating options
    IN OUT  LPBYTE                 VSentOptions,  // to avoid repeating vendor specific options
    IN OUT  LPBYTE                 VendorOpt,     // Buffer[OPTION_END+1] Holding Vendor specific options
    OUT     LPDWORD                VendorOptLen   // the # of bytes filled into that
);

DWORD                                             // status
DhcpDestroyOptionsList(                           // destroy a list of options, freeing up memory
    IN OUT  PLIST_ENTRY            OptionsList,   // this is the list of options to destroy
    IN      PLIST_ENTRY            ClassesList    // this is where to remove classes off
);

DWORD                                             // win32 status
DhcpClearAllOptions(                              // remove all turds from off registry
    IN OUT  PDHCP_CONTEXT          DhcpContext    // the context to clear for
);


POPTION                                           // buffer after filling option
DhcpAppendClassIdOption(                          // fill class id if exists
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // the context to fillfor
    OUT     LPBYTE                 BufStart,      // start of message buffer
    IN      LPBYTE                 BufEnd         // end of message buffer
);


#endif OPTREG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\ntddtcp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ntddtcp.h

Abstract:

    This header file defines constants and types for accessing the NT
    TCP driver.

Author:

    Mike Massa (mikemas)    August 13, 1993

Revision History:

--*/

#ifndef _NTDDTCP_
#define _NTDDTCP_

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtCreateFile when accessing the device.
//
#define DD_TCP_DEVICE_NAME      L"\\Device\\Tcp"
#define DD_UDP_DEVICE_NAME      L"\\Device\\Udp"
#define DD_RAW_IP_DEVICE_NAME   L"\\Device\\RawIp"


//
// Security Filter Support
//
// Security filters provide a mechanism by which the transport protocol
// traffic accepted on IP interfaces may be controlled. Security filtering
// is globally enabled or disabled for all IP interfaces and transports.
// If filtering is enabled, incoming traffic is filtered based on registered
// {interface, protocol, transport value} tuples. The tuples specify
// permissible traffic. All other values will be rejected. For UDP datagrams
// and TCP connections, the transport value is the port number. For RawIP
// datagrams, the transport value is the IP protocol number. An entry exists
// in the filter database for all active interfaces and protocols in the
// system.
//
// The following ioctls may be used to access the security filter
// database. The ioctls may be issued on any TCP/IP device object. All of them
// require Administrator privilege. These ioctls do not update the registry
// parameters used to initialize security filtering when an interface is
// installed.
//
// The TCP_QUERY_SECURITY_FILTER_STATUS ioctl returns the current status of
// security filtering - enabled or disabled.
//
// The TCP_SET_SECURITY_FILTER_STATUS ioctl modifies the status of security
// filtering. Changing the filtering status does not change the contents of
// the filter database.
//
// The following ioctls manipulate the filter database. They operate the same
// whether security filtering is enabled or disabled. If filtering is disabled,
// any changes will take effect only when filtering is enabled.
//
// The TCP_ADD_SECURITY_FILTER ioctl registers an {Interface, Protocol, Value}
// tuple. The TCP_DELETE_SECURITY_FILTER ioctl deregisters an
// {Interface, Protocol, Value} tuple. The TCP_ENUMERATE_SECURITY_FILTER ioctl
// returns the list of {Interface, Protocol, Value} filters currently
// registered.
//
// Each of these ioctls takes an {Interface, Protocol, Value} tuple as an input
// parameter. Zero is a wildcard value. If the Interface or Protocol elements
// are zero, the operation applies to all interfaces or protocols, as
// appropriate. The meaning of a zero Value element depends on the ioctl.
// For an ADD, a zero Value causes all values to be permissible. For a DELETE,
// a zero Value causes all all values to be rejected. In both cases, any
// previously registered values are purged from the database. For an
// ENUMERATE, a zero Value just causes all registered values to be enumerated,
// as opposed to a specific value.
//
// For all ioctls, a return code of STATUS_INVALID_ADDRESS indicates that
// the IP address submitted in the input buffer does not correspond to
// an interface which exists in the system. A code of
// STATUS_INVALID_PARAMETER possibly indicates that the Protocol number
// submitted in the input buffer does not correspond to a transport protocol
// available in the system.
//

//
// Structures used in Security Filter IOCTLs.
//

//
// Structure contained in the input buffer of
// TCP_SET_SECURITY_FILTER_STATUS ioctls and the output buffer of
// TCP_QUERY_SECURITY_FILTER_STATUS ioctls.
//
struct tcp_security_filter_status {
    ULONG  FilteringEnabled;   // FALSE if filtering is (to be) disabled.
};                             // Any other value indicates that filtering
                               // is (to be) enabled.

typedef struct tcp_security_filter_status
                    TCP_SECURITY_FILTER_STATUS,
                   *PTCP_SECURITY_FILTER_STATUS;


//
// The TCPSecurityFilterEntry structure, defined in tcpinfo.h, is contained in
// the input buffer of TCP_[ADD|DELETE|ENUMERATE]_SECURITY_FILTER ioctls.
//

//
// The TCPSecurityFilterEnum structure, defined in tcpinfo.h, is  contained
// in the output buffer of TCP_ENUMERATE_SECURITY_FILTER ioctls. The output
// buffer passed in the ioctl must be large enough to contain at least this
// structure or the call will fail. The structure is followed immediately in
// the buffer by an array of zero or more TCPSecurityFilterEntry structures.
// The number of TCPSecurityFilterEntry structures is specified by the
// tfe_entries_returned field of the TCPSecurityFilterEnum.
//

//
// TCP/UDP/RawIP IOCTL code definitions
//

#define FSCTL_TCP_BASE     FILE_DEVICE_NETWORK

#define _TCP_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_TCP_BASE, function, method, access)

#define IOCTL_TCP_QUERY_INFORMATION_EX  \
            _TCP_CTL_CODE(0, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_TCP_SET_INFORMATION_EX  \
            _TCP_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_QUERY_SECURITY_FILTER_STATUS  \
            _TCP_CTL_CODE(2, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_SET_SECURITY_FILTER_STATUS  \
            _TCP_CTL_CODE(3, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_ADD_SECURITY_FILTER  \
            _TCP_CTL_CODE(4, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_DELETE_SECURITY_FILTER  \
            _TCP_CTL_CODE(5, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_ENUMERATE_SECURITY_FILTER  \
            _TCP_CTL_CODE(6, METHOD_BUFFERED, FILE_WRITE_ACCESS)


#endif  // ifndef _NTDDTCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\regexp.cpp ===
#include <wininetp.h>
#include "regexp.h"

BOOL test_match(int m, LPSTR target, int pattern[])     /* m = length of target */
{
    int    *match;
    int     i = -1;     /* Will be advanced to 0 */
    int     j = 0;      /* i = index to pattern, j = index to target */
    BOOL    fResult = FALSE;

    match = new int[INTERNET_MAX_URL_LENGTH];
    if (match == NULL)
        goto Cleanup;

advance:
    ++i;
    if (j > m)
        goto Cleanup;

    switch (pattern[i]) {
    case PAT_START:  if (j != 0) goto Cleanup; match[i] = 0; goto advance;
    case PAT_END:    if (target[j] == 0) {fResult = TRUE; goto Cleanup;} else goto retreat;
    case PAT_STAR:   match[i] = j = m; goto advance;
    case PAT_QUES:   if (j < m) goto match_one; else goto retreat;
    case PAT_AUGDOT: if (target[j] == '.') goto match_one;
             else if (target[j] == 0) goto match_zero;
             else goto retreat;
    case PAT_AUGQUES: if (target[j] && target[j] != '.')
            goto match_one; else goto match_zero;
    case PAT_AUGSTAR: if (target[j] && target[j] != '.') 
            goto match_one; else goto retreat;
    default:          if (target[j] == pattern[i])
            goto match_one; else goto retreat;
    }
match_one: match[i] = ++j; goto advance;
match_zero: match[i] = j; goto advance;

retreat:
    --i;
    switch (pattern[i]) {
    case PAT_START:  goto Cleanup;
    case PAT_END:    goto Cleanup;     /* Cannot happen */
    case PAT_STAR:   if (match[i] == match[i-1]) goto retreat;
             j = --match[i]; goto advance;
    case PAT_QUES:   goto retreat;
    case PAT_AUGDOT: goto retreat;
    case PAT_AUGQUES: if (match[i] == match[i-1]) goto retreat;
             j = --match[i]; goto advance;
    case PAT_AUGSTAR: goto retreat;
    default:          goto retreat;
    }

Cleanup:
    if (match)
        delete [] match;

    return fResult;
}

BOOL parse_pattern(LPSTR s, int pattern[])
{
    int i = 1;

    pattern[0] = PAT_START; /* Can be hard-coded into pattern[] */
    for (;;) {
    switch (*s) {
        case '*':   pattern[i] = PAT_STAR; break;
        case '?':   pattern[i] = PAT_QUES; break;
        case '^':
        switch (*++s) {
        case '.': pattern[i] = PAT_AUGDOT; break;
        case '?': pattern[i] = PAT_AUGQUES; break;
        case '*': pattern[i] = PAT_AUGSTAR; break;
        default: return FALSE;
        }
        break;
        case 0: pattern[i] = PAT_END; return TRUE;
        default:    pattern[i] = *s; break;
    }
    if (++i >= INTERNET_MAX_URL_LENGTH) return FALSE;
    ++s;
    }
}

BOOL match( LPSTR target, LPSTR regexp) 
{
    int *pattern;
    BOOL result;

    pattern = new int[INTERNET_MAX_URL_LENGTH];

    if (!target || (pattern==NULL))
        return FALSE;

    if (!parse_pattern(regexp,pattern)) 
        return FALSE;
    if (lstrlen(target) >= INTERNET_MAX_URL_LENGTH) 
        return FALSE;

    result = test_match(lstrlen(target),target,pattern);
    delete [] pattern;
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\protocol.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    protocol.cxx

Abstract:

    This module contains the server to client protocol for DHCP.

Author:

    Manny Weiser (mannyw)  21-Oct-1992

Environment:

    User Mode - Win32

Revision History:

    Madan Appiah (madana)  21-Oct-1993

    Arthur Bierer (arthurbi) 15-July-1998
        hacked up to use with Wininet's auto-proxy detection code

--*/

#include <wininetp.h>
#include "aproxp.h"

#include "apdetect.h"

#ifndef VXD
// ping routines.. ICMP
#include <ipexport.h>
//#include <icmpif.h>
#include <icmpapi.h>
#endif

#ifdef NEWNT
extern BOOL DhcpGlobalIsService;
#endif // NEWNT

DWORD                                             // Time in seconds
DhcpCalculateWaitTime(                            // how much time to wait
    IN      DWORD                  RoundNum,      // which round is this
    OUT     DWORD                 *WaitMilliSecs  // if needed the # in milli seconds
);


POPTION
FormatDhcpInform(
    PDHCP_CONTEXT DhcpContext
);

DWORD
SendDhcpInform(
    PDHCP_CONTEXT DhcpContext,
    PDWORD TransactionId
);

DWORD                                             // status
SendInformAndGetReplies(                          // send an inform packet and collect replies
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to send out of
    IN      DWORD                  nInformsToSend,// how many informs to send?
    IN      DWORD                  MaxAcksToWait, // how many acks to wait for
    OUT     DHCP_EXPECTED_OPTIONS *pExpectedOptions // list of things parsed out of request
);

VOID
DhcpExtractFullOrLiteOptions(                     // Extract some important options alone or ALL
    IN      PDHCP_CONTEXT          DhcpContext,
    IN      LPBYTE                 OptStart,      // start of the options stuff
    IN      DWORD                  MessageSize,   // # of bytes of options
    IN      BOOL                   LiteOnly,      // next struc is EXPECTED_OPTIONS and not FULL_OPTIONS
    OUT     LPVOID                 DhcpOptions,   // this is where the options would be stored
    IN OUT  PLIST_ENTRY            RecdOptions,   // if !LiteOnly this gets filled with all incoming options
    IN OUT  DWORD                 *LeaseExpiry,   // if !LiteOnly input expiry time, else output expiry time
    IN      LPBYTE                 ClassName,     // if !LiteOnly this is used to add to the option above
    IN      DWORD                  ClassLen       // if !LiteOnly this gives the # of bytes of classname
);

DWORD
SendDhcpMessage(
    PDHCP_CONTEXT DhcpContext,
    DWORD MessageLength,
    PDWORD TransactionId
    );

DWORD
OpenDhcpSocket(
    PDHCP_CONTEXT DhcpContext
    );

DWORD
GetSpecifiedDhcpMessage(
    PDHCP_CONTEXT DhcpContext,
    PDWORD BufferLength,
    DWORD TransactionId,
    DWORD TimeToWait
    );

DWORD
CloseDhcpSocket(
    PDHCP_CONTEXT DhcpContext
    );

//
// functions
//


DWORD                                             // Time in seconds
DhcpCalculateWaitTime(                            // how much time to wait
    IN      DWORD                  RoundNum,      // which round is this
    OUT     DWORD                 *WaitMilliSecs  // if needed the # in milli seconds
) {
    DWORD                          MilliSecs;
    //DWORD                          WaitTimes[4] = { 4000, 8000, 16000, 32000 };
    DWORD                          WaitTimes[4] = { 2000, 4000, 8000, 16000 };

    if( WaitMilliSecs ) *WaitMilliSecs = 0;
    if( RoundNum >= sizeof(WaitTimes)/sizeof(WaitTimes[0]) )
        return 0;

    MilliSecs = WaitTimes[RoundNum] - 1000 + ((rand()*((DWORD) 2000))/RAND_MAX);
    if( WaitMilliSecs ) *WaitMilliSecs = MilliSecs;

    return (MilliSecs + 501)/1000;
}


VOID        _inline
ConcatOption(
    IN OUT  LPBYTE                *Buf,           // input buffer to re-alloc
    IN OUT  ULONG                 *BufSize,       // input buffer size
    IN      BYTE UNALIGNED        *Data,          // data to append
    IN      ULONG                  DataSize       // how many bytes to add?
)
{
    LPBYTE                         NewBuf;
    ULONG                          NewSize;

    NewSize = (*BufSize) + DataSize;
    NewBuf = (LPBYTE) DhcpAllocateMemory(NewSize);
    if( NULL == NewBuf ) {                        // could not alloc memory?
        return;                                   // can't do much
    }

    memcpy(NewBuf, *Buf, *BufSize);               // copy existing part
    memcpy(NewBuf + *BufSize, Data, DataSize);    // copy new stuff

    if( NULL != *Buf ) DhcpFreeMemory(*Buf);      // if we alloc'ed mem, free it now
    *Buf = NewBuf;
    *BufSize = NewSize;                           // fill in new values..
}

VOID
DhcpExtractFullOrLiteOptions(                     // Extract some important options alone or ALL
    IN      PDHCP_CONTEXT          DhcpContext,   // input context
    IN      LPBYTE                 OptStart,      // start of the options stuff
    IN      DWORD                  MessageSize,   // # of bytes of options
    IN      BOOL                   LiteOnly,      // next struc is EXPECTED_OPTIONS and not FULL_OPTIONS
    OUT     LPVOID                 DhcpOptions,   // this is where the options would be stored
    IN OUT  PLIST_ENTRY            RecdOptions,   // if !LiteOnly this gets filled with all incoming options
    IN OUT  DWORD                 *LeaseExpiry,   // if !LiteOnly input expiry time, else output expiry time
    IN      LPBYTE                 ClassName,     // if !LiteOnly this is used to add to the option above
    IN      DWORD                  ClassLen       // if !LiteOnly this gives the # of bytes of classname
) {
    BYTE    UNALIGNED*             ThisOpt;
    BYTE    UNALIGNED*             NextOpt;
    BYTE    UNALIGNED*             EndOpt;
    BYTE    UNALIGNED*             MagicCookie;
    DWORD                          Size, ThisSize, UClassSize = 0;
    LPBYTE                         UClass= NULL;  // concatenation of all OPTION_USER_CLASS options
    PDHCP_EXPECTED_OPTIONS         ExpOptions;
    PDHCP_FULL_OPTIONS             FullOptions;
    BYTE                           ReqdCookie[] = {
        (BYTE)DHCP_MAGIC_COOKIE_BYTE1,
        (BYTE)DHCP_MAGIC_COOKIE_BYTE2,
        (BYTE)DHCP_MAGIC_COOKIE_BYTE3,
        (BYTE)DHCP_MAGIC_COOKIE_BYTE4
    };

    UNREFERENCED_PARAMETER(DhcpContext);
    UNREFERENCED_PARAMETER(RecdOptions);
    UNREFERENCED_PARAMETER(ClassName);
    UNREFERENCED_PARAMETER(ClassLen);
    
    EndOpt = OptStart + MessageSize;              // all options should be < EndOpt;
    ExpOptions = (PDHCP_EXPECTED_OPTIONS)DhcpOptions;
    FullOptions = (PDHCP_FULL_OPTIONS)DhcpOptions;
    RtlZeroMemory((LPBYTE)DhcpOptions, LiteOnly?sizeof(*ExpOptions):sizeof(*FullOptions));
    // if(!LiteOnly) InitializeListHead(RecdOptions); -- clear off this list for getting ALL options
    // dont clear off options... just accumulate over..

    MagicCookie = OptStart;
    if( 0 == MessageSize ) goto DropPkt;          // nothing to do in this case
    if( 0 != memcmp(MagicCookie, ReqdCookie, sizeof(ReqdCookie)) )
        goto DropPkt;                             // oops, cant handle this packet

    NextOpt = &MagicCookie[sizeof(ReqdCookie)];
    while( NextOpt < EndOpt && OPTION_END != *NextOpt ) {
        if( OPTION_PAD == *NextOpt ) {            // handle pads right away
            NextOpt++;
            continue;
        }

        ThisOpt = NextOpt;                        // take a good look at this option
        if( NextOpt + 2 >  EndOpt ) {             // goes over boundary?
            break;
        }

        NextOpt += 2 + (unsigned)ThisOpt[1];      // Option[1] holds the size of this option
        Size = ThisOpt[1];

        if( NextOpt > EndOpt ) {                  // illegal option that goes over boundary!
            break;                                // ignore the error, but dont take this option
        }

        if(!LiteOnly) do {                        // look for any OPTION_MSFT_CONTINUED ..
            if( NextOpt >= EndOpt ) break;        // no more options
            if( OPTION_MSFT_CONTINUED != NextOpt[0] ) break;
            if( NextOpt + 1 + NextOpt[1] > EndOpt ) {
                NextOpt = NULL;                   // do this so that we know to quit at the end..
                break;
            }

            NextOpt++;                            // skip opt code
            ThisSize = NextOpt[0];                // # of bytes to shift back..
            memcpy(ThisOpt+2+Size, NextOpt+1,ThisSize);
            NextOpt += ThisSize+1;
            Size += ThisSize;
        } while(1);                               // keep stringing up any "continued" options..

        if( NULL == NextOpt ) {                   // err parsing OPTION_MSFT_CONTINUED ..
            break;
        }

        if( LiteOnly ) {                          // handle the small subnet of options
            switch( ThisOpt[0] ) {                // ThisOpt[0] is OptionId, ThisOpt[1] is size
            case OPTION_MESSAGE_TYPE:
                if( ThisOpt[1] != 1 ) goto DropPkt;
                ExpOptions->MessageType = &ThisOpt[2];
                continue;
            case OPTION_SUBNET_MASK:
                if( ThisOpt[1] != sizeof(DWORD) ) goto DropPkt;
                ExpOptions->SubnetMask = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                continue;
            case OPTION_LEASE_TIME:
                if( ThisOpt[1] != sizeof(DWORD) ) goto DropPkt;
                ExpOptions->LeaseTime = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                continue;
            case OPTION_SERVER_IDENTIFIER:
                if( ThisOpt[1] != sizeof(DWORD) ) goto DropPkt;
                ExpOptions->ServerIdentifier = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                continue;
            case OPTION_DOMAIN_NAME:
                if( ThisOpt[1] == 0 ) goto DropPkt;
                ExpOptions->DomainName = (BYTE UNALIGNED *)&ThisOpt[2];
                ExpOptions->DomainNameSize = ThisOpt[1];
                break;
            case OPTION_WPAD_URL:
                if( ThisOpt[1] == 0 ) goto DropPkt;
                ExpOptions->WpadUrl = (BYTE UNALIGNED *)&ThisOpt[2];
                ExpOptions->WpadUrlSize = ThisOpt[1];
                break;

            default:
                continue;
            }
        } else {                                  // Handle the full set of options
            switch( ThisOpt[0] ) {
            case OPTION_MESSAGE_TYPE:
                if( Size != 1 ) goto DropPkt;
                FullOptions->MessageType = &ThisOpt[2];
                break;
            case OPTION_SUBNET_MASK:
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->SubnetMask = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_LEASE_TIME:
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->LeaseTime = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_SERVER_IDENTIFIER:
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->ServerIdentifier = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_RENEWAL_TIME:             // T1Time
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->T1Time = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_REBIND_TIME:              // T2Time
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->T2Time = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_ROUTER_ADDRESS:
                if( Size < sizeof(DWORD) || (Size % sizeof(DWORD) ) )
                    goto DropPkt;                 // There can be many router addresses
                FullOptions->GatewayAddresses = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                FullOptions->nGateways = Size / sizeof(DWORD);
                break;
            case OPTION_STATIC_ROUTES:
                if( Size < 2*sizeof(DWORD) || (Size % (2*sizeof(DWORD))) )
                    goto DropPkt;                 // the static routes come in pairs
                FullOptions->StaticRouteAddresses = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                FullOptions->nStaticRoutes = Size/(2*sizeof(DWORD));
                break;
            case OPTION_DYNDNS_BOTH:
                if( Size < 3 ) goto DropPkt;
                FullOptions->DnsFlags = (BYTE UNALIGNED *)&ThisOpt[2];
                FullOptions->DnsRcode1 = (BYTE UNALIGNED *)&ThisOpt[3];
                FullOptions->DnsRcode2 = (BYTE UNALIGNED *)&ThisOpt[3];
                break;
            case OPTION_DOMAIN_NAME:
                if( Size == 0 ) goto DropPkt;
                FullOptions->DomainName = (BYTE UNALIGNED *)&ThisOpt[2];
                FullOptions->DomainNameSize = Size;
                break;
            case OPTION_WPAD_URL:
                if( Size == 0 ) goto DropPkt;
                FullOptions->WpadUrl = (BYTE UNALIGNED *)&ThisOpt[2];
                FullOptions->WpadUrlSize = Size;
                break;
            case OPTION_DOMAIN_NAME_SERVERS:
                if( Size < sizeof(DWORD) || (Size % sizeof(DWORD) ))
                    goto DropPkt;
                FullOptions->DnsServerList = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                FullOptions->nDnsServers = Size / sizeof(DWORD);
                break;
            case OPTION_MESSAGE:
                if( Size == 0 ) break;      // ignore zero sized packets
                FullOptions->ServerMessage = &ThisOpt[2];
                FullOptions->ServerMessageLength = ThisOpt[1];
                break;
            case OPTION_MCAST_LEASE_START:
                if ( Size != sizeof(DATE_TIME) ) goto DropPkt;
                FullOptions->MCastLeaseStartTime = (DWORD UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_MCAST_TTL:
                if ( Size != 1 ) goto DropPkt;
                FullOptions->MCastTTL = (BYTE UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_USER_CLASS:
                if( Size <= 6) goto DropPkt;
                ConcatOption(&UClass, &UClassSize, &ThisOpt[2], Size);
                continue;                         // don't add this option yet...

            default:
                // unknowm message, nothing to do.. especially dont log this
                break;
            }

        } // if LiteOnly then else
    } // while NextOpt < EndOpt

    if( LiteOnly && LeaseExpiry ) {               // If asked to calculate lease expiration time..
        DWORD    LeaseTime;
        time_t   TimeNow, ExpirationTime;

        // BBUGBUGBUG [arthurbi] broken intensionlly, dead code.
        //if( ExpOptions->LeaseTime ) LeaseTime = _I_ntohl(*ExpOptions->LeaseTime);
        if( ExpOptions->LeaseTime ) LeaseTime = 0;
        else LeaseTime = DHCP_MINIMUM_LEASE;
        ExpirationTime = (TimeNow = time(NULL)) + (time_t)LeaseTime;
        if( ExpirationTime < TimeNow ) {
            ExpirationTime = INFINIT_TIME;
        }

        *LeaseExpiry = (DWORD)ExpirationTime ;
    }

    if( !LiteOnly && NULL != UClass ) {           // we have a user class list to pass on..
        DhcpAssert(UClassSize != 0 );             // we better have something here..
        DhcpFreeMemory(UClass); UClass = NULL;
    }

    return;

  DropPkt:
    RtlZeroMemory(DhcpOptions, LiteOnly?sizeof(ExpOptions):sizeof(FullOptions));
    if( LiteOnly && LeaseExpiry ) *LeaseExpiry = (DWORD) time(NULL) + DHCP_MINIMUM_LEASE;
    //if(!LiteOnly) DhcpFreeAllOptions(RecdOptions);// ok undo the options that we just added
    if(!LiteOnly && NULL != UClass ) DhcpFreeMemory(UClass);
}

POPTION                                           // ptr to add additional options
FormatDhcpInform(                                 // format the packet for an INFORM
    IN      PDHCP_CONTEXT          DhcpContext    // format for this context
) {
    LPOPTION option;
    LPBYTE OptionEnd;

    BYTE value;
    PDHCP_MESSAGE dhcpMessage;


    dhcpMessage = DhcpContext->MessageBuffer;
    RtlZeroMemory( dhcpMessage, DHCP_SEND_MESSAGE_SIZE );

    //
    // BUGBUG [arthurbi] - 
    // For RAS client, use broadcast bit, otherwise the router will try
    // to send as unicast to made-up RAS client hardware address, which
    // will not work.  So will this work without it?
    //

    //
    // Transaction ID is filled in during send
    //

    dhcpMessage->Operation             = BOOT_REQUEST;
    dhcpMessage->HardwareAddressType   = DhcpContext->HardwareAddressType;
    dhcpMessage->SecondsSinceBoot      = (WORD) DhcpContext->SecondsSinceBoot;
    memcpy(dhcpMessage->HardwareAddress,DhcpContext->HardwareAddress,DhcpContext->HardwareAddressLength);
    dhcpMessage->HardwareAddressLength = (BYTE)DhcpContext->HardwareAddressLength;
    dhcpMessage->ClientIpAddress       = DhcpContext->IpAddress;
    //dhcpMessage->Reserved = 0;
    //dhcpMessage->Reserved = _I_htons(DHCP_BROADCAST);
    //if ( IS_MDHCP_CTX(DhcpContext ) ) MDHCP_MESSAGE( dhcpMessage );

    option = &dhcpMessage->Option;
    OptionEnd = (LPBYTE)dhcpMessage + DHCP_SEND_MESSAGE_SIZE;

    //
    // always add magic cookie first
    //

    option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) option, OptionEnd );

    value = DHCP_INFORM_MESSAGE;
    option = DhcpAppendOption(
        option,
        OPTION_MESSAGE_TYPE,
        &value,
        1,
        OptionEnd
    );

    //
    // BUGBUG [arthurbi], shouldn't we uncomment this?
    //

    // un comment later on
    /*option = DhcpAppendClassIdOption(
        DhcpContext,
        (LPBYTE)option,
        OptionEnd
    );*/

    return( option );
}


DWORD                                             // status
SendDhcpInform(                                   // send an inform packet after filling required options
    IN      PDHCP_CONTEXT          DhcpContext,   // sned out for this context
    IN OUT  DWORD                 *pdwXid         // use this Xid (if zero fill something and return it)
) {
    DWORD                          size;
    POPTION                        option;
    LPBYTE                         OptionEnd;
    BYTE                           SentOpt[OPTION_END+1];
    BYTE                           SentVOpt[OPTION_END+1];
    BYTE                           VendorOpt[OPTION_END+1];
    DWORD                          VendorOptSize;

    RtlZeroMemory(SentOpt, sizeof(SentOpt));      // initialize boolean arrays
    RtlZeroMemory(SentVOpt, sizeof(SentVOpt));    // so that no option is presumed sent
    VendorOptSize = 0;                            // encapsulated vendor option is empty
    option = FormatDhcpInform( DhcpContext );     // core format

    OptionEnd = (LPBYTE)(DhcpContext->MessageBuffer) + DHCP_SEND_MESSAGE_SIZE;

    if( DhcpContext->ClientIdentifier.fSpecified) // client id specified in registy
        option = DhcpAppendClientIDOption(        // ==> use this client id as option
            option,
            DhcpContext->ClientIdentifier.bType,
            DhcpContext->ClientIdentifier.pbID,
            (BYTE)DhcpContext->ClientIdentifier.cbID,
            OptionEnd
        );
    else                                          // client id was not specified
        option = DhcpAppendClientIDOption(        // ==> use hw addr as client id
            option,
            DhcpContext->HardwareAddressType,
            DhcpContext->HardwareAddress,
            (BYTE)DhcpContext->HardwareAddressLength,
            OptionEnd
        );

    {   // add hostname and comment options
        char szHostName[255];

        if ( _I_gethostname(szHostName, ARRAY_ELEMENTS(szHostName)) != SOCKET_ERROR  ) 
        {
            option = DhcpAppendOption(
                option,
                OPTION_HOST_NAME,
                (LPBYTE)szHostName,
                (BYTE)((strlen(szHostName) + 1) * sizeof(CHAR)),
                OptionEnd
            );
        }
    }

    if( NULL != DhcpGlobalClientClassInfo ) {     // if we have any info on client class..
        option = DhcpAppendOption(
            option,
            OPTION_CLIENT_CLASS_INFO,
            (LPBYTE)DhcpGlobalClientClassInfo,
            strlen(DhcpGlobalClientClassInfo),
            OptionEnd
        );
    }

    SentOpt[OPTION_MESSAGE_TYPE] = TRUE;          // these must have been added by now
    if(DhcpContext->ClassIdLength) SentOpt[OPTION_USER_CLASS] = TRUE;
    SentOpt[OPTION_CLIENT_CLASS_INFO] = TRUE;
    SentOpt[OPTION_CLIENT_ID] = TRUE;
    SentOpt[OPTION_REQUESTED_ADDRESS] = TRUE;
    SentOpt[OPTION_HOST_NAME] = TRUE;

    option = DhcpAppendSendOptions(               // append all other options we need to send
        DhcpContext,                              // for this context
        &DhcpContext->SendOptionsList,            // this is the list of options to send out
        DhcpContext->ClassId,                     // which class.
        DhcpContext->ClassIdLength,               // how many bytes are there in the class id
        (LPBYTE)option,                           // start of the buffer to add the options
        (LPBYTE)OptionEnd,                        // end of the buffer up to which we can add options
        SentOpt,                                  // this is the boolean array that marks what opt were sent
        SentVOpt,                                 // this is for vendor spec options
        VendorOpt,                                // this would contain some vendor specific options
        &VendorOptSize                            // the # of bytes of vendor options added to VendorOpt param
    );

    if( !SentOpt[OPTION_VENDOR_SPEC_INFO] && VendorOptSize && VendorOptSize <= OPTION_END )
        option = DhcpAppendOption(                // add vendor specific options if we havent already sent it
            option,
            OPTION_VENDOR_SPEC_INFO,
            VendorOpt,
            (BYTE)VendorOptSize,
            OptionEnd
        );

    option = DhcpAppendOption( option, OPTION_END, NULL, 0, OptionEnd );
    size = (DWORD)((PBYTE)option - (PBYTE)DhcpContext->MessageBuffer);

    return  SendDhcpMessage(                      // finally send the message and return
        DhcpContext,
        size,
        pdwXid
    );
}

DWORD
InitializeDhcpSocket(
    SOCKET *Socket,
    DHCP_IP_ADDRESS IpAddress
    )
/*++

Routine Description:

    This function initializes and binds a socket to the specified IP address.

Arguments:

    Socket - Returns a pointer to the initialized socket.

    IpAddress - The IP address to bind the socket to.  It is legitimate
        to bind a socket to 0.0.0.0 if the card has no current IP address.

Return Value:

    The status of the operation.

--*/
{
    DWORD error;
    DWORD closeError;
    DWORD value;
    struct sockaddr_in socketName;
    DWORD i;
    SOCKET sock;

    //
    // Sockets initialization
    //

    sock = _I_socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );

    if ( sock == INVALID_SOCKET ) {
        error = _I_WSAGetLastError();
        DhcpPrint(("socket failed, error = %ld\n", error ));
        return( error );
    }

    //
    // Make the socket share-able
    //

    value = 1;

    error = _I_setsockopt( sock, SOL_SOCKET, SO_REUSEADDR, (char FAR *)&value, sizeof(value) );
    if ( error != 0 ) {
        error = _I_WSAGetLastError();
        DhcpPrint(("setsockopt failed, err = %ld\n", error ));

        closeError = _I_closesocket( sock );
        if ( closeError != 0 ) {
            DhcpPrint(("closesocket failed, err = %d\n", closeError ));
        }
        return( error );
    }

    error = _I_setsockopt( sock, SOL_SOCKET, SO_BROADCAST, (char FAR *)&value, sizeof(value) );
    if ( error != 0 ) {
        error = _I_WSAGetLastError();
        DhcpPrint(("setsockopt failed, err = %ld\n", error ));

        closeError = _I_closesocket( sock );
        if ( closeError != 0 ) {
            DhcpPrint(("closesocket failed, err = %d\n", closeError ));
        }
        return( error );
    }

    //
    // If the IpAddress is zero, set the special socket option to make
    // stack work with zero address.
    //

    if( IpAddress == 0 ) {
        value = 1234;
        error = _I_setsockopt( sock, SOL_SOCKET, 0x8000, (char FAR *)&value, sizeof(value) );
        if ( error != 0 ) {
            error = _I_WSAGetLastError();
            DhcpPrint(("setsockopt failed, err = %ld\n", error ));

            closeError = _I_closesocket( sock );
            if ( closeError != 0 ) {
                DhcpPrint(("closesocket failed, err = %d\n", closeError ));
            }
            return( error );
        }
    }

    socketName.sin_family = PF_INET;
    socketName.sin_port = _I_htons( DHCP_CLIENT_PORT );
    socketName.sin_addr.s_addr = IpAddress;

    for ( i = 0; i < 8 ; i++ ) {
        socketName.sin_zero[i] = 0;
    }

    //
    // Bind this socket to the DHCP server port
    //

    error = _I_bind(
               sock,
               (struct sockaddr FAR *)&socketName,
               sizeof( socketName )
               );

    if ( error != 0 ) {
        error = _I_WSAGetLastError();
        DhcpPrint(("bind failed (address 0x%lx), err = %ld\n", IpAddress, error ));
        closeError = _I_closesocket( sock );
        if ( closeError != 0 ) {
            DhcpPrint(("closesocket failed, err = %d\n", closeError ));
        }
        return( error );
    }

    *Socket = sock;
    return( NO_ERROR );
}


DWORD                                             // status
SendInformAndGetReplies(                          // send an inform packet and collect replies
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to send out of
    IN      DWORD                  nInformsToSend,// how many informs to send?
    IN      DWORD                  MaxAcksToWait, // how many acks to wait for
    OUT     DHCP_EXPECTED_OPTIONS *pExpectedOptions // list of things parsed out of request
) {
    time_t                         StartTime;
    time_t                         TimeNow;
    DWORD                          TimeToWait;
    DWORD                          Error;
    DWORD                          Xid;
    DWORD                          MessageSize;
    DWORD                          RoundNum;
    DWORD                          MessageCount;
    DWORD                          LeaseExpirationTime;
    DHCP_FULL_OPTIONS              FullOptions;

    DhcpPrint(("SendInformAndGetReplies entered\n"));

    if((Error = OpenDhcpSocket(DhcpContext)) != ERROR_SUCCESS) {
        DhcpPrint(("Could not open socket for this interface! (%ld)\n", Error));
        return Error;
    }

    Xid                           = 0;            // Will be generated by first SendDhcpPacket
    MessageCount                  = 0;            // total # of messages we have got

    DhcpContext->SecondsSinceBoot = 0;            // start at zero..
    for( RoundNum = 0; RoundNum < nInformsToSend;  RoundNum ++ ) {
        Error = SendDhcpInform(DhcpContext, &Xid);
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint(("SendDhcpInform: %ld\n", Error));
            goto Cleanup;
        } else {
            DhcpPrint(("Sent DhcpInform\n"));
        }

        TimeToWait = DhcpCalculateWaitTime(RoundNum, NULL);
        DhcpContext->SecondsSinceBoot += TimeToWait; // do this so that next time thru it can go thru relays..
        StartTime  = time(NULL);
        while ( TRUE ) {                          // wiat for the specified wait time
            MessageSize =  DHCP_MESSAGE_SIZE;

            DhcpPrint(("Waiting for ACK[Xid=%x]: %ld seconds\n",Xid, TimeToWait));
            Error = GetSpecifiedDhcpMessage(      // try to receive an ACK
                DhcpContext,
                &MessageSize,
                Xid,
                (DWORD)TimeToWait
            );
            if ( Error == ERROR_SEM_TIMEOUT ) break;
            if( Error != ERROR_SUCCESS ) {
                DhcpPrint(("GetSpecifiedDhcpMessage: %ld\n", Error));
                goto Cleanup;
            }

            DhcpExtractFullOrLiteOptions(         // Need to see if this is an ACK
                DhcpContext,
                (LPBYTE)&DhcpContext->MessageBuffer->Option,
                MessageSize - DHCP_MESSAGE_FIXED_PART_SIZE,
                TRUE,                             // do lite extract only
                pExpectedOptions,                 // check for only expected options
                NULL,                             // unused
                &LeaseExpirationTime,
                NULL,                             // unused
                0                                 // unused
            );

            if( NULL == pExpectedOptions->MessageType ) {
                DhcpPrint(("Received no message type!\n"));
            } else if( DHCP_ACK_MESSAGE != *(pExpectedOptions->MessageType) ) {
                DhcpPrint(("Received unexpected message type: %ld\n", *(pExpectedOptions->MessageType)));
            } else if( NULL == pExpectedOptions->ServerIdentifier ) {
                DhcpPrint(("Received no server identifier, dropping inform ACK\n"));
            } else {
                MessageCount ++;
                DhcpPrint(("Received %ld ACKS so far\n", MessageCount));
                DhcpExtractFullOrLiteOptions(     // do FULL options..
                    DhcpContext,
                    (LPBYTE)&DhcpContext->MessageBuffer->Option,
                    MessageSize - DHCP_MESSAGE_FIXED_PART_SIZE,
                    FALSE,
                    &FullOptions,
                    &(DhcpContext->RecdOptionsList),
                    &LeaseExpirationTime,
                    DhcpContext->ClassId,
                    DhcpContext->ClassIdLength
                );
                if( MessageCount >= MaxAcksToWait ) goto Cleanup;
            } // if( it is an ACK and ServerId present )

            TimeNow     = time(NULL);             // Reset the time values to reflect new time
            if( TimeToWait < (DWORD) (TimeNow - StartTime) ) {
                break;                            // no more time left to wait..
            }
            TimeToWait -= (DWORD)(TimeNow - StartTime);  // recalculate time now
            StartTime   = TimeNow;                // reset start time also
        } // end of while ( TimeToWait > 0)
    } // for (RoundNum = 0; RoundNum < nInformsToSend ; RoundNum ++ )

  Cleanup:
    CloseDhcpSocket(DhcpContext);
    if( MessageCount ) Error = ERROR_SUCCESS;
    DhcpPrint(("SendInformAndGetReplies: got %d ACKS (returning %ld)\n", MessageCount,Error));
    return Error;
}

//--------------------------------------------------------------------------------
//  This function gets the options from the server using DHCP_INFORM message.
//  It picks the first ACK and then processes it.
//  It ignores any errors caused by TIME_OUTS as that only means there is no
//  server, or the server does not have this functionality.  No point giving up
//  because of that.
//--------------------------------------------------------------------------------
BOOL                                              // win32 status
DhcpDoInform(                                     // send an inform packet if necessary
    IN      CAdapterInterface *    pAdapterInterface,
    IN      BOOL                   fBroadcast,    // Do we broadcast this inform, or unicast to server?
    OUT     LPSTR *                ppszAutoProxyUrl
) {
    DHCP_CONTEXT                   StackDhcpContext;   // input context to do inform on
    PDHCP_CONTEXT                  DhcpContext = &StackDhcpContext;
    DWORD                          Error;
    DWORD                          LocalError;
    BOOL                           WasPlumbedBefore;
    time_t                         OldT2Time;
    DHCP_EXPECTED_OPTIONS          ExpectedOptions;

    if ( ! pAdapterInterface->IsDhcp() ) {
        return FALSE;
    }

    if (! pAdapterInterface->CopyAdapterInfoToDhcpContext(DhcpContext) ) {
        return FALSE;
    }
   
    // mdhcp uses INADDR_ANY so it does not have to have an ipaddress.
    if( 0 == DhcpContext->IpAddress && !IS_MDHCP_CTX( DhcpContext) ) {
        DhcpPrint(("Cannot do DhcpInform on an adapter without ip address!\n"));
        return FALSE;
    }

    // Open the socket ahead... so that things work. Tricky, else does not work!!!
    if((Error = OpenDhcpSocket(DhcpContext)) != ERROR_SUCCESS ) {
        DhcpPrint(("Could not open socket (%ld)\n", Error));
        return FALSE;
    }

    // If you always need to broadcast this message, the KLUDGE is to
    // set pContext->T2Time = 0; and pContext->fFlags &= ~DHCP_CONTEXT_FLAGS_PLUMBED
    // and that should do the trick! Safe to change the struct as it was cloned.
    OldT2Time = DhcpContext->T2Time;
    WasPlumbedBefore = IS_ADDRESS_PLUMBED(DhcpContext);
    if(fBroadcast) {
        DhcpContext->T2Time = 0; // !!!! KLUDGE.. look at SendDhcpMessage to understand this ..
        ADDRESS_UNPLUMBED(DhcpContext);
        CONNECTION_BROADCAST(DhcpContext);
    } else {
        DhcpContext->T2Time = (-1);
    }

    memset((void *) &ExpectedOptions, 0, sizeof(DHCP_EXPECTED_OPTIONS));

    Error = SendInformAndGetReplies(              // get replies on this
        DhcpContext,                              // context to send on
        2,                                        // send atmost 2 informs
        1,                                        // wait for as many as 4 packets..
        &ExpectedOptions
    );
    DhcpContext->LastInformSent = time(NULL);     // record when the last inform was sent
    DhcpContext->T2Time = OldT2Time;
    if( WasPlumbedBefore ) ADDRESS_PLUMBED(DhcpContext);

    LocalError = CloseDhcpSocket(DhcpContext);
    DhcpAssert(ERROR_SUCCESS == LocalError);

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint(("DhcpDoInform:return [0x%lx]\n", Error));
    }
    else
    {
        //
        // Did we actually get a response with an URL that can be used ? 
        //

        if (ExpectedOptions.WpadUrl && ExpectedOptions.WpadUrlSize > 0)
        {
            LPSTR   lpszAutoProxyUrl = NewString(NULL, ExpectedOptions.WpadUrlSize);

            if (lpszAutoProxyUrl)
            {
                memcpy(lpszAutoProxyUrl, ExpectedOptions.WpadUrl, ExpectedOptions.WpadUrlSize);
                *ppszAutoProxyUrl = lpszAutoProxyUrl;
            }
            return (lpszAutoProxyUrl != NULL);
        }            
    }

    return FALSE;
}


DWORD
SendDhcpMessage(
    PDHCP_CONTEXT DhcpContext,
    DWORD MessageLength,
    PDWORD TransactionId
    )
/*++

Routine Description:

    This function sends a UDP message to the DHCP server specified
    in the DhcpContext.

Arguments:

    DhcpContext - A pointer to a DHCP context block.

    MessageLength - The length of the message to send.

    TransactionID - The transaction ID for this message.  If 0, the
        function generates a random ID, and returns it.

Return Value:

    The status of the operation.

--*/
{
    DWORD error;
    int i;
    struct sockaddr_in socketName;
    time_t TimeNow;
    BOOL   LockedInterface = FALSE;

    if ( *TransactionId == 0 ) {
        *TransactionId = (rand() << 16) + rand();
    }

    DhcpContext->MessageBuffer->TransactionID = *TransactionId;

    //
    // Initialize the outgoing address.
    //

    socketName.sin_family = PF_INET;
    socketName.sin_port = _I_htons( DHCP_SERVR_PORT );

    if ( IS_MDHCP_CTX(DhcpContext) ) {
        socketName.sin_addr.s_addr = DhcpContext->DhcpServerAddress;
        if ( CLASSD_NET_ADDR( DhcpContext->DhcpServerAddress ) ) {
            int   TTL = 16;
            //
            // Set TTL
            // MBUG: we need to read this from the registry.
            //
            if (_I_setsockopt(
                  DhcpContext->Socket,
                  IPPROTO_IP,
                  IP_MULTICAST_TTL,
                  (char *)&TTL,
                  sizeof((int)TTL)) == SOCKET_ERROR){

                 error = _I_WSAGetLastError();
                 DhcpPrint(("could not set MCast TTL %ld\n",error ));
                 return error;
            }

        }
    } else if( IS_ADDRESS_PLUMBED(DhcpContext) &&
               !IS_MEDIA_RECONNECTED(DhcpContext) &&    // media reconnect - braodcast
               !IS_POWER_RESUMED(DhcpContext) ) {       // power resumed - broadcast

        //
        // If we are past T2, use the broadcast address; otherwise,
        // direct this to the server.
        //

        TimeNow = time( NULL );

        // BUGBUG why did we broadcast here before ?
        if ( TimeNow > DhcpContext->T2Time && IS_CONNECTION_BROADCAST(DhcpContext)) {
            socketName.sin_addr.s_addr = (DHCP_IP_ADDRESS)(INADDR_BROADCAST);
        } else {
            socketName.sin_addr.s_addr = DhcpContext->DhcpServerAddress;
        }
    }
    else {
        socketName.sin_addr.s_addr = (DHCP_IP_ADDRESS)(INADDR_BROADCAST);
        INET_ASSERT(FALSE);
    }

    for ( i = 0; i < 8 ; i++ ) {
        socketName.sin_zero[i] = 0;
    }

    if( socketName.sin_addr.s_addr ==
            (DHCP_IP_ADDRESS)(INADDR_BROADCAST) ) {

        DWORD Error = ERROR_SUCCESS;

        //
        // BUGBUG TODO [arthurbi] This code below is needed for 
        //  Broadcasts to work.  We need to make some fancy driver
        //  calls to work...
        //

        //
        // if we broadcast a message, inform IP stack - the adapter we
        // like to send this broadcast on, otherwise it will pick up the
        // first uninitialized adapter.
        //

//        InterfaceId = DhcpContext->IpInterfaceContext;            
//
//        if( !IPSetInterface( InterfaceId ) ) {
//            // DhcpAssert( FALSE );
//            Error = ERROR_GEN_FAILURE;
//        }

//        InterfaceId = ((PLOCAL_CONTEXT_INFO)
//            DhcpContext->LocalInformation)->IpInterfaceContext;
//
//        LOCK_INTERFACE();
//        LockedInterface = TRUE;
//        Error = IPSetInterface( InterfaceId );
        // DhcpAssert( Error == ERROR_SUCCESS );

        if( ERROR_SUCCESS != Error ) {
            DhcpPrint(("IPSetInterface failed with %lx error\n", Error));
            UNLOCK_INTERFACE();
            return Error;
        }
    }

    //
    // send minimum DHCP_MIN_SEND_RECV_PK_SIZE (300) bytes, otherwise
    // bootp relay agents don't like the packet.
    //

    MessageLength = (DWORD)((MessageLength > DHCP_MIN_SEND_RECV_PK_SIZE) ?
                        MessageLength : DHCP_MIN_SEND_RECV_PK_SIZE);
    error = _I_sendto(
                DhcpContext->Socket,
                (PCHAR)DhcpContext->MessageBuffer,
                MessageLength,
                0,
                (struct sockaddr *)&socketName,
                sizeof( struct sockaddr )
                );

#ifndef VXD
    if( LockedInterface ) { UNLOCK_INTERFACE(); }
#endif  VXD

    if ( error == SOCKET_ERROR ) {
        error = _I_WSAGetLastError();
        DhcpPrint(("Send failed, error = %ld\n", error ));
    } else {
        IF_DEBUG( PROTOCOL ) {
            DhcpPrint(("Sent message to %s: \n", _I_inet_ntoa( socketName.sin_addr )));
        }

        DhcpDumpMessage( DEBUG_PROTOCOL_DUMP, DhcpContext->MessageBuffer );
        error = NO_ERROR;
    }

    return( error );
}

DWORD
OpenDhcpSocket(
    PDHCP_CONTEXT DhcpContext
    )
{

    DWORD Error;

    if ( DhcpContext->Socket != INVALID_SOCKET ) {
        return ( ERROR_SUCCESS );
    }

    //
    // create a socket for the dhcp protocol.  it's important to bind the
    // socket to the correct ip address.  There are currently three cases:
    //
    // 1.  If the interface has been autoconfigured, it already has an address,
    //     say, IP1.  If the client receives a unicast offer from a dhcp server
    //     the offer will be addressed to IP2, which is the client's new dhcp
    //     address.  If we bind the dhcp socket to IP1, the client won't be able
    //     to receive unicast responses.  So, we bind the socket to 0.0.0.0.
    //     This will allow the socket to receive a unicast datagram addressed to
    //     any address.
    //
    // 2.  If the interface in not plumbed (i.e. doesn't have an address) bind
    //     the socket to 0.0.0.0
    //
    // 3.  If the interface has been plumbed has in *not* autoconfigured, then
    //     bind to the current address.


    Error =  InitializeDhcpSocket(
                 &DhcpContext->Socket,
                 DhcpContext->IpAddress 
                 );

    if( Error != ERROR_SUCCESS ) {
        DhcpContext->Socket = INVALID_SOCKET;
        DhcpPrint((" Socket Open failed, %ld\n", Error ));
    }

    return(Error);
}

DWORD
CloseDhcpSocket(
    PDHCP_CONTEXT DhcpContext
    )
{

    DWORD Error = ERROR_SUCCESS;

    if( DhcpContext->Socket != INVALID_SOCKET ) {


        Error = _I_closesocket( DhcpContext->Socket );

        if( Error != ERROR_SUCCESS ) {
            DhcpPrint((" Socket close failed, %ld\n", Error ));
        }

        DhcpContext->Socket = INVALID_SOCKET;

        //
        // Reset the IP stack to send DHCP broadcast to first
        // uninitialized stack.
        //

        //Bool = IPResetInterface();
        //DhcpAssert( Bool == TRUE );
    }

    return( Error );
}


typedef     struct  /* anonymous */ {             // structure to hold waiting recvfroms
    LIST_ENTRY                     RecvList;      // other elements in this list
    PDHCP_CONTEXT                  Ctxt;          // which context is this wait for?
    DWORD                          InBufLen;      // what was the buffer size to recv in?
    PDWORD                         BufLen;        // how many bytes did we recvd?
    DWORD                          Xid;           // what xid is this wait for?
    time_t                         ExpTime;       // wait until what time?
    HANDLE                         WaitEvent;     // event for waiting on..
    BOOL                           Recd;          // was a packet received..?
} RECV_CTXT, *PRECV_CTXT;                         // ctxt used to recv on..

VOID
InsertInPriorityList(                             // insert in priority list according to Secs
    IN OUT  PRECV_CTXT             Ctxt,          // Secs field changed to hold offset
    IN      PLIST_ENTRY            List,
    OUT     PBOOL                  First          // adding in first location?
)
{

    if( IsListEmpty(List) ) {                     // no element in list? add this and quit
        *First = TRUE;                            // adding at head
    } else {
        *First = FALSE;                           // adding at tail..
    }

    InsertTailList( List, &Ctxt->RecvList);       // insert element..
    //LeaveCriticalSection( &DhcpGlobalRecvFromCritSect );
}

DWORD
TryReceive(                                       // try to recv pkt on 0.0.0.0 socket
    IN      SOCKET                 Socket,        // socket to recv on
    IN      LPBYTE                 Buffer,        // buffer to fill
    OUT     PDWORD                 BufLen,        // # of bytes filled in buffer
    OUT     PDWORD                 Xid,           // Xid of recd pkt
    IN      DWORD                  Secs           // # of secs to spend waiting?
)
{
    DWORD                          Error;
    struct timeval                 timeout;
    fd_set                         SockSet;
    struct sockaddr                SockName;
    int                            SockNameSize;

    FD_ZERO(&SockSet);
    FD_SET(Socket,&SockSet);

    SockNameSize = sizeof( SockName );

    timeout.tv_sec = Secs;
    timeout.tv_usec = 0;

    DhcpPrint(("Select: waiting for: %ld seconds\n", Secs));
    Error = _I_select( 0, &SockSet, NULL, NULL, &timeout );
    if( ERROR_SUCCESS == Error ) {            // timed out..
        DhcpPrint(("Recv timed out..\n"));
        return ERROR_SEM_TIMEOUT;
    }

    Error = _I_recvfrom(Socket,(char *)Buffer,*BufLen, 0, &SockName, &SockNameSize);
    if( SOCKET_ERROR == Error ) {
        Error = _I_WSAGetLastError();
        DhcpPrint(("Recv failed 0x%lx\n",Error));
    } else {
        *BufLen = Error;
        Error = ERROR_SUCCESS;
        *Xid = ((PDHCP_MESSAGE)Buffer)->TransactionID;
        DhcpPrint(("Recd msg XID: 0x%lx [Mdhcp? %s]\n", *Xid,
                   IS_MDHCP_MESSAGE(((PDHCP_MESSAGE)Buffer))?"yes":"no" ));

    }

    return Error;
}

VOID
DispatchPkt(                                      // find out any takers for Xid
    IN OUT  PRECV_CTXT             Ctxt,          // ctxt that has buffer and buflen
    IN      DWORD                  Xid            // recd Xid
)
{
    do {                                          // not a loop, just for ease of use
        LPBYTE                     Tmp;
        PLIST_ENTRY                Entry;
        PRECV_CTXT                 ThisCtxt;

        Entry = DhcpGlobalRecvFromList.Flink;
        while(Entry != &DhcpGlobalRecvFromList ) {
            ThisCtxt = CONTAINING_RECORD(Entry, RECV_CTXT, RecvList);
            Entry = Entry->Flink;

            if(Xid != ThisCtxt->Xid ) continue;   // mismatch.. nothing more todo

            // now check for same type of message and ctxt...
            if( (unsigned)IS_MDHCP_MESSAGE((Ctxt->Ctxt->MessageBuffer))
                !=
                IS_MDHCP_CTX( (ThisCtxt->Ctxt) )
            ) {
                //
                // The contexts dont match.. give up
                //
                continue;
            }

            //
            // check for same hardware address..
            //

            if( ThisCtxt->Ctxt->HardwareAddressLength != Ctxt->Ctxt->MessageBuffer->HardwareAddressLength ) {
                continue;
            }

            if( 0 != memcmp(ThisCtxt->Ctxt->HardwareAddress,
                            Ctxt->Ctxt->MessageBuffer->HardwareAddress,
                            ThisCtxt->Ctxt->HardwareAddressLength
            ) ) {
                continue;
            }

            // matched.. switch buffers to give this guy this due..

            DhcpDumpMessage(DEBUG_PROTOCOL_DUMP, (PDHCP_MESSAGE)(Ctxt->Ctxt->MessageBuffer) );

            *(ThisCtxt->BufLen) = *(Ctxt->BufLen);
            Tmp = (LPBYTE)(Ctxt->Ctxt)->MessageBuffer;
            (Ctxt->Ctxt)->MessageBuffer = (ThisCtxt->Ctxt)->MessageBuffer;
            (ThisCtxt->Ctxt)->MessageBuffer = (PDHCP_MESSAGE)Tmp;

            RemoveEntryList(&ThisCtxt->RecvList);
            InitializeListHead(&ThisCtxt->RecvList);
            DhcpAssert(FALSE == ThisCtxt->Recd);
            ThisCtxt->Recd = TRUE;
            if( 0 == SetEvent(ThisCtxt->WaitEvent) ) {
                DhcpAssert(FALSE);
            }

            break;
        }
    } while (FALSE);
    //LeaveCriticalSection(&DhcpGlobalRecvFromCritSect);
}

DWORD
ProcessRecvFromSocket(                            // wait using select and process incoming pkts
    IN OUT  PRECV_CTXT             Ctxt           // ctxt to use
)
{
    time_t                         TimeNow;
    SOCKET                         Socket;
    LPBYTE                         Buffer;
    DWORD                          Xid;
    DWORD                          Error;
    PLIST_ENTRY                    Entry;

    Socket = (Ctxt->Ctxt)->Socket;
    TimeNow = time(NULL);
    Xid = 0;

    Error = ERROR_SEM_TIMEOUT;
    while(TimeNow <= Ctxt->ExpTime ) {            // while required to wait
        Buffer = (LPBYTE)((Ctxt->Ctxt)->MessageBuffer);
        *(Ctxt->BufLen) = Ctxt->InBufLen;
        Error = TryReceive(Socket, Buffer, Ctxt->BufLen, &Xid, (DWORD)(Ctxt->ExpTime - TimeNow));
        if( ERROR_SUCCESS != Error ) {            // did not recv?
            if( WSAECONNRESET != Error ) break;   // ignore possibly spurious conn-resets..
            else {  TimeNow = time(NULL); continue; }
        }

        if( Xid == Ctxt->Xid ) break;             // this was destined for this ctxt only..

        DispatchPkt(Ctxt, Xid);
        TimeNow = time(NULL);
    }

    if( TimeNow > Ctxt->ExpTime ) {               // we timed out.
        Error = ERROR_SEM_TIMEOUT;
    }

    // now done.. so we must remove this ctxt from the list and signal first guy
    //EnterCriticalSection(&DhcpGlobalRecvFromCritSect);
    RemoveEntryList(&Ctxt->RecvList);
    CloseHandle(Ctxt->WaitEvent);
    if( !IsListEmpty(&DhcpGlobalRecvFromList)) {  // ok got an elt.. signal this.
        Entry = DhcpGlobalRecvFromList.Flink;
        Ctxt = CONTAINING_RECORD(Entry, RECV_CTXT, RecvList);
        if( 0 == SetEvent(Ctxt->WaitEvent) ) {
            DhcpAssert(FALSE);
        }
    }
    //LeaveCriticalSection(&DhcpGlobalRecvFromCritSect);

    return Error;
}

//================================================================================
//  get dhcp message with requested transaction id, but also make sure only one
//  socket is used at any given time (one socket bound to 0.0.0.0), and also
//  re-distribute message for some other thread if that is also required..
//================================================================================
DWORD
GetSpecifiedDhcpMessageEx(
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // which context to recv for
    OUT     PDWORD                 BufferLength,  // how big a buffer was read?
    IN      DWORD                  Xid,           // which xid to look for?
    IN      DWORD                  TimeToWait     // how many seconds to sleep?
)
{
    RECV_CTXT                      Ctxt;          // element in list for this call to getspe..
    BOOL                           First;         // is this the first element in list?
    DWORD                          Result;

    Ctxt.Ctxt = DhcpContext;                      // fill in the context
    Ctxt.InBufLen = *BufferLength;
    Ctxt.BufLen = BufferLength;
    Ctxt.Xid = Xid;
    Ctxt.ExpTime = time(NULL) + TimeToWait;
    Ctxt.WaitEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    Ctxt.Recd = FALSE;
    if( NULL == Ctxt.WaitEvent ) {
        DhcpAssert(NULL != Ctxt.WaitEvent);
        return GetLastError();
    }

    First = FALSE;
    InsertInPriorityList(&Ctxt, &DhcpGlobalRecvFromList, &First);

    if( First ) {                                 // this *is* the first call to GetSpec..
        Result = ProcessRecvFromSocket(&Ctxt);
    } else {                                      // we wait for other calls to go thru..
        Result = WaitForSingleObject(Ctxt.WaitEvent, TimeToWait * 1000);
        //EnterCriticalSection(&DhcpGlobalRecvFromCritSect);
        if( Ctxt.Recd || WAIT_FAILED == Result || WAIT_TIMEOUT == Result ) {
            if( WAIT_FAILED == Result ) Result = GetLastError();
            else if (WAIT_TIMEOUT == Result ) Result = ERROR_SEM_TIMEOUT;
            else Result = ERROR_SUCCESS;

            RemoveEntryList(&Ctxt.RecvList);      // remove it from list
            //LeaveCriticalSection(&DhcpGlobalRecvFromCritSect);
            CloseHandle(Ctxt.WaitEvent);
            return Result;
        } else {
            DhcpAssert(WAIT_OBJECT_0 == Result && Ctxt.Recd == FALSE );
            // have not received a packet but have been woken up? must be first in line now..
            //LeaveCriticalSection(&DhcpGlobalRecvFromCritSect);
            Result = ProcessRecvFromSocket(&Ctxt);
        }
    }

    return Result;
}


#define RATIO 1
DWORD
GetSpecifiedDhcpMessage(
    PDHCP_CONTEXT DhcpContext,
    PDWORD BufferLength,
    DWORD TransactionId,
    DWORD TimeToWait
    )
/*++

Routine Description:

    This function waits TimeToWait seconds to receives the specified
    DHCP response.

Arguments:

    DhcpContext - A pointer to a DHCP context block.

    BufferLength - Returns the size of the input buffer.

    TransactionID - A filter.  Wait for a message with this TID.

    TimeToWait - Time, in milli seconds, to wait for the message.

Return Value:

    The status of the operation.  If the specified message has been
    been returned, the status is ERROR_TIMEOUT.

--*/
{
    struct sockaddr socketName;
    int socketNameSize = sizeof( socketName );
    struct timeval timeout;
    time_t startTime, now;
    DWORD error;
    DWORD actualTimeToWait;
    SOCKET clientSocket;
    fd_set readSocketSet;

    if( !IS_ADDRESS_PLUMBED(DhcpContext) ) {
        //
        // For RAS server Lease API this call won't happen as we don't have to do this nonsense
        //
        error = GetSpecifiedDhcpMessageEx(
            DhcpContext,
            BufferLength,
            TransactionId,
            TimeToWait
        );
        if( ERROR_SUCCESS == error ) {
            // received a message frm the dhcp server..
            SERVER_REACHED(DhcpContext);
        }
        return error;
    }

    startTime = time( NULL );
    actualTimeToWait = TimeToWait;

    //
    // Setup the file descriptor set for select.
    //

    clientSocket = DhcpContext->Socket;

    FD_ZERO( &readSocketSet );
    FD_SET( clientSocket, &readSocketSet );

    while ( 1 ) {

        timeout.tv_sec  = actualTimeToWait / RATIO;
        timeout.tv_usec = actualTimeToWait % RATIO;
        DhcpPrint(("Select: waiting for: %ld seconds\n", actualTimeToWait));
        error = _I_select( 0, &readSocketSet, NULL, NULL, &timeout );

        if ( error == 0 ) {

            //
            // Timeout before read data is available.
            //

            DhcpPrint(("Recv timed out\n", 0 ));
            error = ERROR_SEM_TIMEOUT;
            break;
        }

        error = _I_recvfrom(
                    clientSocket,
                    (PCHAR)DhcpContext->MessageBuffer,
                    *BufferLength,
                    0,
                    &socketName,
                    &socketNameSize
                    );

        if ( error == SOCKET_ERROR ) {
            error = _I_WSAGetLastError();
            DhcpPrint(("Recv failed, error = %ld\n", error ));

            if( WSAECONNRESET != error ) break;

            //
            // ignore connreset -- this could be caused by someone sending random ICMP port unreachable.
            //

        } else if (DhcpContext->MessageBuffer->TransactionID == TransactionId ) {
             
            DhcpPrint((  "Received Message, XID = %lx, MDhcp = %d.\n",
                            TransactionId,
                            IS_MDHCP_MESSAGE( DhcpContext->MessageBuffer) ));

            if (((unsigned)IS_MDHCP_MESSAGE( DhcpContext->MessageBuffer) == IS_MDHCP_CTX( DhcpContext))) {
                DhcpDumpMessage(DEBUG_PROTOCOL_DUMP, DhcpContext->MessageBuffer );

                *BufferLength = error;
                error = NO_ERROR;

                if( DhcpContext->MessageBuffer->HardwareAddressLength == DhcpContext->HardwareAddressLength
                    && 0 == memcmp(DhcpContext->MessageBuffer->HardwareAddress,
                                   DhcpContext->HardwareAddress,
                                   DhcpContext->HardwareAddressLength
                    )) {

                    //
                    // Transction IDs match, same type (MDHCP/DHCP), Hardware addresses match!
                    //

                    break;
                }
            }
        } else {            
            DhcpPrint(( "Received a buffer with unknown XID = %lx\n",
                         DhcpContext->MessageBuffer->TransactionID ));
        }

        //
        // We received a message, but not the one we're interested in.
        // Reset the timeout to reflect elapsed time, and wait for
        // another message.
        //
        now = time( NULL );
        actualTimeToWait = (DWORD)(TimeToWait - RATIO * (now - startTime));
        if ( (LONG)actualTimeToWait < 0 ) {
            error = ERROR_SEM_TIMEOUT;
            break;
        }
    }

    if ( ERROR_SEM_TIMEOUT != error )
    {
        //
        // a message was received from a DHCP server.  disable IP autoconfiguration.
        //

        SERVER_REACHED(DhcpContext);
    }

    return( error );
}


DWORD 
QueryWellKnownDnsName(
    OUT LPSTR * ppszAutoProxyUrl
    )
/*++

Routine Description:

    This function walks a list of standard DNS names trying to find
     an entry for "wpad.some-domain-here.org"  If it does, it constructs
     an URL that is suitable for use in auto-proxy.

Arguments:

    lpszAutoProxyUrl - Url used to return a successful auto-proxy discover

    dwAutoProxyUrlLength - length of buffer passed in above

Return Value:
        
    ERROR_SUCCESS - if we found a URL/DNS name

    ERROR_NOT_FOUND - on error

revised: joshco 7-oct-1998
  if we dont get a valid domain back, be sure and try
  the netbios name ("wpad") no trailing dot.

  revised: joshco 7-oct-1998
        use the define PROXY_AUTO_DETECT_PATH instead
        of hardcoding "wpad.dat"
        
--*/

{
#define WORK_BUFFER_SIZE 356

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "QueryWellKnownDnsName",
                 "%x",
                 ppszAutoProxyUrl
                 ));

    char szHostDomain[WORK_BUFFER_SIZE + 2];
    char * pszTemp = szHostDomain ;
    char *pszDot1 = NULL;
    char *pszDot2 = NULL;
    DWORD error = ERROR_NOT_FOUND;
    DWORD dwMinDomain = 2;  //  By default, assume domain is of the form: .domain-name.org

    lstrcpy(szHostDomain, "wpad.");
    pszTemp += (sizeof("wpad.") - 1);

    if ( SockGetSingleValue(CONFIG_DOMAIN,
                            (LPBYTE)pszTemp,
                            WORK_BUFFER_SIZE - sizeof("wpad.")
                            ) != ERROR_SUCCESS )
    {
        lstrcpy(szHostDomain, "wpad.");
        pszTemp = szHostDomain ;
        pszTemp += (sizeof("wpad.") - 1);
    }

    if (*pszTemp == '\0') 
    {
        // if the debug setting for no domain (netbios) or 
        // we didnt get back a valid domain, then just do the
        // netbios name.  
        // XXBUG sockgetsinglevalue returns true even if there is no domain

        INET_ASSERT(*(pszTemp  - 1 ) == '.');

        *(pszTemp - 1) = '\0';
    }

    // Now determine which form the domain name follows:
    //     domain-name.org
    //     domain-name.co.uk
    pszDot1 = &szHostDomain[lstrlen(szHostDomain)-1];

    while (pszDot1 >= szHostDomain && *pszDot1 != '.')
        pszDot1--;

    // Only check .?? endings
    if (pszDot1 >= szHostDomain && (pszDot1 + 3 == &szHostDomain[lstrlen(szHostDomain)]) )
    {
        pszDot2 = pszDot1 - 1;

        while (pszDot2 >= szHostDomain && *pszDot2 != '.')
           pszDot2--;
   
        if (pszDot2 >= szHostDomain && pszDot2 + 3 >= pszDot1)
        {
           // Domain ended in something of the form: .co.uk
           // This requires at least 3 pieces then to be considered a domain
           dwMinDomain = 3;
        }
        else if ((pszDot2 + 4) == pszDot1)
        {
            // Check domain endings of the form ending in .com.uk
            // These special 3-letter pieces also need 3 dots to be classified
            // as a domain.  Unfortunately, we can't leverage the equivalent
            // code used by cookies because there, the strings are reversed.
            static const char *s_pachSpecialDomains[] = {"COM", "EDU", "NET", "ORG", "GOV", "MIL", "INT" };

            for (int i=0; i < ARRAY_ELEMENTS(s_pachSpecialDomains); i++)
            {
                if (StrCmpNIC(pszDot2+1, s_pachSpecialDomains[i], 3) == 0)
                {
                    dwMinDomain = 3;
                    break;
                }
            }
        }
    }

    // Append a "." suffix to the domain name in order to suppress
    // the DNS suffix search list.
    if (lstrlen(szHostDomain)+1 < ARRAY_ELEMENTS(szHostDomain))
    {
        lstrcat(szHostDomain, ".");
        dwMinDomain++;
    }

    while (TRUE)
    {
        PHOSTENT lpHostent = _I_gethostbyname(szHostDomain);

        if ( lpHostent != NULL )
        {
            //
            // Found a host, extract the IP address and form an URL to use.
            //

            char *pszAddressStr;
            LPBYTE * addressList;
            struct  in_addr sin_addr;
            LPSTR lpszAutoProxyUrl;

            addressList         = (LPBYTE *)lpHostent->h_addr_list;
            *(LPDWORD)&sin_addr = *(LPDWORD)addressList[0] ;

            pszAddressStr = _I_inet_ntoa (sin_addr);

            INET_ASSERT(pszAddressStr);

            lpszAutoProxyUrl = NewString(NULL,
                                    lstrlen(pszAddressStr)
                                    + sizeof("http:///")
                                    + sizeof(PROXY_AUTO_DETECT_PATH));
            if (lpszAutoProxyUrl)
            {
                wsprintf(lpszAutoProxyUrl, "http://%s/%s", pszAddressStr, PROXY_AUTO_DETECT_PATH );
                *ppszAutoProxyUrl = lpszAutoProxyUrl;
                error = ERROR_SUCCESS;
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
            
            goto quit;
        }
        else
        {
            //
            // Did not find anything yet, reduce the domain level, 
            //  and if we're in the root domain stop and return error
            //

            DWORD dwPeriodCnt = 0, dwNewEndLength = 0;
            LPSTR lpszPeriod1 = NULL, lpszPeriod2 = NULL;

            for (pszTemp = szHostDomain; *pszTemp; pszTemp++ )
            {
                if ( *pszTemp == '.' ) {
                    dwPeriodCnt ++;
                    if ( lpszPeriod1 == NULL ) {
                        lpszPeriod1 = pszTemp;
                    }
                    else if ( lpszPeriod2 == NULL ) {
                        lpszPeriod2 = pszTemp;
                    }
                }
            }

            if ( dwPeriodCnt <= dwMinDomain) 
            {
                error = ERROR_NOT_FOUND;
                goto quit;
            }

            dwNewEndLength = lstrlen(lpszPeriod2);
            MoveMemory(lpszPeriod1, lpszPeriod2, dwNewEndLength);
            *(lpszPeriod1 + dwNewEndLength) = '\0';
        }
    }
quit:

    DEBUG_LEAVE(error);

    return error;    
}


//================================================================================
// End of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\nameser.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nameser.h

Abstract:

    Definitions for the DNS resolver and nameserver.

Author:

    Mike Massa (mikemas)           Jan 31, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-31-92     created

Notes:

--*/

/******************************************************************
 *
 *  SpiderTCP BIND
 *
 *  Copyright 1990  Spider Systems Limited
 *
 *  NAMESER.H
 *
 ******************************************************************/

/*
 *   /usr/projects/tcp/SCCS.rel3/rel/src/include/arpa/0/s.nameser.h
 *  @(#)nameser.h   5.3
 *
 *  Last delta created  14:06:04 3/4/91
 *  This file extracted 11:19:28 3/8/91
 *
 *  Modifications:
 *
 *      GSS 20 Jul 90   New File
 */

/*
 * Copyright (c) 1983, 1989 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that: (1) source distributions retain this entire copyright
 * notice and comment, and (2) distributions including binaries display
 * the following acknowledgement:  ``This product includes software
 * developed by the University of California, Berkeley and its contributors''
 * in the documentation or other materials provided with the distribution
 * and in all advertising materials mentioning features or use of this
 * software. Neither the name of the University nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  @(#)nameser.h   5.24 (Berkeley) 6/1/90
 */

#ifndef _NAMESER_INCLUDED
#define _NAMESER_INCLUDED


/*
 * Define constants based on rfc883
 */
#define PACKETSZ    512     /* maximum packet size */
#define MAXDNAME    256     /* maximum domain name */
#define MAXCDNAME   255     /* maximum compressed domain name */
#define MAXLABEL    63      /* maximum length of domain label */
    /* Number of bytes of fixed size data in query structure */
#define QFIXEDSZ    4
    /* number of bytes of fixed size data in resource record */
#define RRFIXEDSZ   10

/*
 * Internet nameserver port number
 */
#define NAMESERVER_PORT 53

/*
 * Currently defined opcodes
 */
#define QUERY       0x0     /* standard query */
#define IQUERY      0x1     /* inverse query */
#define STATUS      0x2     /* nameserver status query */
/*#define xxx       0x3     /* 0x3 reserved */
    /* non standard */
#define UPDATEA     0x9     /* add resource record */
#define UPDATED     0xa     /* delete a specific resource record */
#define UPDATEDA    0xb     /* delete all nemed resource record */
#define UPDATEM     0xc     /* modify a specific resource record */
#define UPDATEMA    0xd     /* modify all named resource record */

#define ZONEINIT    0xe     /* initial zone transfer */
#define ZONEREF     0xf     /* incremental zone referesh */

/*
 * Currently defined response codes
 */
#ifndef NOERROR
#define NOERROR     0       /* no error */
#endif
#define FORMERR     1       /* format error */
#define SERVFAIL    2       /* server failure */
#define NXDOMAIN    3       /* non existent domain */
#define NOTIMP      4       /* not implemented */
#define REFUSED     5       /* query refused */
    /* non standard */
#define NOCHANGE    0xf     /* update failed to change db */

/*
 * Type values for resources and queries
 */
#define T_A     1       /* host address */
#define T_NS        2       /* authoritative server */
#define T_MD        3       /* mail destination */
#define T_MF        4       /* mail forwarder */
#define T_CNAME     5       /* connonical name */
#define T_SOA       6       /* start of authority zone */
#define T_MB        7       /* mailbox domain name */
#define T_MG        8       /* mail group member */
#define T_MR        9       /* mail rename name */
#define T_NULL      10      /* null resource record */
#define T_WKS       11      /* well known service */
#define T_PTR       12      /* domain name pointer */
#define T_HINFO     13      /* host information */
#define T_MINFO     14      /* mailbox information */
#define T_MX        15      /* mail routing information */
#define T_TXT       16      /* text strings */
#define T_AFSDB     18      /* AFS database servers */
    /* non standard */
#define T_UINFO     100     /* user (finger) information */
#define T_UID       101     /* user ID */
#define T_GID       102     /* group ID */
#define T_UNSPEC    103     /* Unspecified format (binary data) */
    /* Query type values which do not appear in resource records */
#define T_AXFR      252     /* transfer zone of authority */
#define T_MAILB     253     /* transfer mailbox records */
#define T_MAILA     254     /* transfer mail agent records */
#define T_ANY       255     /* wildcard match */

/*
 * Values for class field
 */

#define C_IN        1       /* the arpa internet */
#define C_CHAOS     3       /* for chaos net at MIT */
#define C_HS        4       /* for Hesiod name server at MIT */
    /* Query class values which do not appear in resource records */
#define C_ANY       255     /* wildcard match */

/*
 * Status return codes for T_UNSPEC conversion routines
 */
#define CONV_SUCCESS 0
#define CONV_OVERFLOW -1
#define CONV_BADFMT -2
#define CONV_BADCKSUM -3
#define CONV_BADBUFLEN -4

#ifndef BYTE_ORDER
#define LITTLE_ENDIAN   1234    /* least-significant byte first (vax) */
#define BIG_ENDIAN  4321    /* most-significant byte first (IBM, net) */
#define PDP_ENDIAN  3412    /* LSB first in word, MSW first in long (pdp) */

#if defined(vax) || defined(ns32000) || defined(sun386) || defined(MIPSEL) || \
    defined(BIT_ZERO_ON_RIGHT)
#define BYTE_ORDER  LITTLE_ENDIAN

#endif
#if defined(sel) || defined(pyr) || defined(mc68000) || defined(sparc) || \
    defined(is68k) || defined(tahoe) || defined(ibm032) || defined(ibm370) || \
    defined(MIPSEB) || defined(ux10) || defined (BIT_ZERO_ON_LEFT)
#define BYTE_ORDER  BIG_ENDIAN
#endif
#ifndef BYTE_ORDER      /* still not defined */
#if defined(u3b2) || defined(m68k)
#define BYTE_ORDER  BIG_ENDIAN
#endif
#if defined(i286) || defined(i386) || defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
#define BYTE_ORDER  LITTLE_ENDIAN
#endif
#endif /* ~BYTE_ORDER */
#endif /* BYTE_ORDER */

#ifndef BYTE_ORDER
    /* you must determine what the correct bit order is for your compiler */
    UNDEFINED_BIT_ORDER;
#endif
/*
 * Structure for query header, the order of the fields is machine and
 * compiler dependent, in our case, the bits within a byte are assignd
 * least significant first, while the order of transmition is most
 * significant first.  This requires a somewhat confusing rearrangement.
 */

typedef struct {
    unsigned short  id;     /* query identification number */
#if BYTE_ORDER == BIG_ENDIAN
            /* fields in third byte */
    unsigned char   qr:1;       /* response flag */
    unsigned char   opcode:4;   /* purpose of message */
    unsigned char   aa:1;       /* authoritive answer */
    unsigned char   tc:1;       /* truncated message */
    unsigned char   rd:1;       /* recursion desired */
            /* fields in fourth byte */
    unsigned char   ra:1;       /* recursion available */
    unsigned char   pr:1;       /* primary server required (non standard) */
    unsigned char   unused:2;   /* unused bits */
    unsigned char   rcode:4;    /* response code */
#endif
#if BYTE_ORDER == LITTLE_ENDIAN || BYTE_ORDER == PDP_ENDIAN
            /* fields in third byte */
    unsigned char   rd:1;       /* recursion desired */
    unsigned char   tc:1;       /* truncated message */
    unsigned char   aa:1;       /* authoritive answer */
    unsigned char   opcode:4;   /* purpose of message */
    unsigned char   qr:1;       /* response flag */
            /* fields in fourth byte */
    unsigned char   rcode:4;    /* response code */
    unsigned char   unused:2;   /* unused bits */
    unsigned char   pr:1;       /* primary server required (non standard) */
    unsigned char   ra:1;       /* recursion available */
#endif
            /* remaining bytes */
    unsigned short  qdcount;    /* number of question entries */
    unsigned short  ancount;    /* number of answer entries */
    unsigned short  nscount;    /* number of authority entries */
    unsigned short  arcount;    /* number of resource entries */
} HEADER;

/*
 * Defines for handling compressed domain names
 */
#define INDIR_MASK  0xc0

/*
 * Structure for passing resource records around.
 */
struct rrec {
    short           r_zone;         /* zone number */
    short           r_class;        /* class number */
    short           r_type;         /* type number */
    unsigned long   r_ttl;          /* time to live */
    int         r_size;         /* size of data area */
    char           *r_data;             /* pointer to data */
};

extern  unsigned short  _getshort(char *);
extern  unsigned long   _getlong(char *);

/*
 * Inline versions of get/put short/long.
 * Pointer is advanced; we assume that both arguments
 * are lvalues and will already be in registers.
 * cp MUST be unsigned char *.
 */
#define GETSHORT(s, cp) { \
    (s) = *(cp)++ << 8; \
    (s) |= *(cp)++; \
}

#define GETLONG(l, cp) { \
    (l) = *(cp)++ << 8; \
    (l) |= *(cp)++; (l) <<= 8; \
    (l) |= *(cp)++; (l) <<= 8; \
    (l) |= *(cp)++; \
}


#define PUTSHORT(s, cp) { \
    *(cp)++ = (s) >> 8; \
    *(cp)++ = (s); \
}

/*
 * Warning: PUTLONG destroys its first argument.
 */
#define PUTLONG(l, cp) { \
    (cp)[3] = l; \
    (cp)[2] = (l >>= 8); \
    (cp)[1] = (l >>= 8); \
    (cp)[0] = l >> 8; \
    (cp) += sizeof(unsigned long); \
}

#endif  // _NAMESER_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\optreg.cxx ===
//--------------------------------------------------------------------------------
// Copyright (C) Micorosoft Confidential 1997
// Author: RameshV
// Description: Option related registry handling -- common between NT and VxD
//--------------------------------------------------------------------------------

#include <wininetp.h>
#include "aproxp.h"

#ifndef  OPTREG_H
#define  OPTREG_H

//--------------------------------------------------------------------------------
// function definitions
//--------------------------------------------------------------------------------

POPTION                                           // option from which more appends can occur
DhcpAppendSendOptions(                            // append all configured options
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // this is the context to append for
    IN      PLIST_ENTRY            SendOptionsList,
    IN      LPBYTE                 ClassName,     // current class
    IN      DWORD                  ClassLen,      // len of above in bytes
    IN      LPBYTE                 BufStart,      // start of buffer
    IN      LPBYTE                 BufEnd,        // how far can we go in this buffer
    IN OUT  LPBYTE                 SentOptions,   // BoolArray[OPTION_END+1] to avoid repeating options
    IN OUT  LPBYTE                 VSentOptions,  // to avoid repeating vendor specific options
    IN OUT  LPBYTE                 VendorOpt,     // Buffer[OPTION_END+1] Holding Vendor specific options
    OUT     LPDWORD                VendorOptLen   // the # of bytes filled into that
);

DWORD                                             // status
DhcpDestroyOptionsList(                           // destroy a list of options, freeing up memory
    IN OUT  PLIST_ENTRY            OptionsList,   // this is the list of options to destroy
    IN      PLIST_ENTRY            ClassesList    // this is where to remove classes off
);

DWORD                                             // win32 status
DhcpClearAllOptions(                              // remove all turds from off registry
    IN OUT  PDHCP_CONTEXT          DhcpContext    // the context to clear for
);


#endif OPTREG_H

// internal private function that takes the lock on OPTIONS_LIST

DWORD                                             // status
DhcpRegClearOptDefs(                              // clear all standard options
    IN      LPTSTR                 AdapterName    // clear for this adapter
);


//
// options related lists
//


LIST_ENTRY DhcpGlobalRecvFromList;
LPSTR   DhcpGlobalClientClassInfo = NULL;


LPBYTE                                            // ptr to buf loc where more appends can occur
DhcpAppendParamRequestList(                       // append the param request list option
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to append for
    IN      PLIST_ENTRY            SendOptionsList,// look thru this list
    IN      LPBYTE                 ClassName,     // which class does this belong to?
    IN      DWORD                  ClassLen,      // size of above in bytes
    IN      LPBYTE                 BufStart,      // where to start adding this option
    IN      LPBYTE                 BufEnd         // limit for this option
) {
    BYTE                           Buffer[OPTION_END+1];
    LPBYTE                         Tmp;
    DWORD                          FirstSize;
    DWORD                          Size;
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                   ThisOpt;
    DWORD                          i, j;

    UNREFERENCED_PARAMETER(DhcpContext);

    Size = FirstSize = 0;
    Buffer[Size++] = OPTION_SUBNET_MASK;          // standard requested options
    Buffer[Size++] = OPTION_DOMAIN_NAME;
    Buffer[Size++] = OPTION_ROUTER_ADDRESS;
    Buffer[Size++] = OPTION_DOMAIN_NAME_SERVERS;
    Buffer[Size++] = OPTION_NETBIOS_NAME_SERVER;
    Buffer[Size++] = OPTION_NETBIOS_NODE_TYPE;
    Buffer[Size++] = OPTION_NETBIOS_SCOPE_OPTION;
    Buffer[Size++] = OPTION_VENDOR_SPEC_INFO;
    Buffer[Size++] = OPTION_USER_CLASS;
    Buffer[Size++] = OPTION_WPAD_URL;

    ThisEntry = SendOptionsList->Flink;
    while( ThisEntry != SendOptionsList ) {
        ThisOpt = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);
        ThisEntry = ThisEntry->Flink;

        if( ThisOpt->IsVendor) continue;

        if( ThisOpt->ClassLen ) {
            if( ThisOpt->ClassLen != ClassLen ) continue;
            if( ThisOpt->ClassName != ClassName )
                continue;                         // this option is not used for this client
        }

        if( OPTION_PARAMETER_REQUEST_LIST != ThisOpt->OptionId ) {
            //
            // only if the option is param_request_list do we request..
            //
            continue;
        }

        for( i = 0; i < ThisOpt->DataLen ; i ++ ) {
            for( j = 0; j < Size; j ++ )
                if( ThisOpt->Data[i] == Buffer[j] ) break;
            if( j < Size ) continue;              // option already plugged in
            Buffer[Size++] = ThisOpt->Data[i]; // add this option
        }

        if( 0 == FirstSize ) FirstSize = Size;
    }

    if( 0 == FirstSize ) FirstSize = Size;

    Tmp = BufStart;
    BufStart = (LPBYTE)DhcpAppendOption(          // now add the param request list
        (POPTION)BufStart,
        (BYTE)OPTION_PARAMETER_REQUEST_LIST,
        Buffer,
        (BYTE)Size,
        BufEnd
    );

    if( Tmp == BufStart ) {                       // did not really add the option
        BufStart = (LPBYTE)DhcpAppendOption(      // now try adding the first request we saw instead of everything
            (POPTION)BufStart,
            (BYTE)OPTION_PARAMETER_REQUEST_LIST,
            Buffer,
            (BYTE)FirstSize,
            BufEnd
        );
    }

    return BufStart;
}

POPTION                                           // option from which more appends can occur
DhcpAppendSendOptions(                            // append all configured options
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // this is the context to append for
    IN      PLIST_ENTRY            SendOptionsList,
    IN      LPBYTE                 ClassName,     // current class
    IN      DWORD                  ClassLen,      // len of above in bytes
    IN      LPBYTE                 BufStart,      // start of buffer
    IN      LPBYTE                 BufEnd,        // how far can we go in this buffer
    IN OUT  LPBYTE                 SentOptions,   // BoolArray[OPTION_END+1] to avoid repeating options
    IN OUT  LPBYTE                 VSentOptions,  // to avoid repeating vendor specific options
    IN OUT  LPBYTE                 VendorOpt,     // Buffer[OPTION_END+1] Holding Vendor specific options
    OUT     LPDWORD                VendorOptLen   // the # of bytes filled into that
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                  ThisOpt;

    DhcpAssert(FALSE == SentOptions[OPTION_PARAMETER_REQUEST_LIST]);
    BufStart = DhcpAppendParamRequestList(
        DhcpContext,
        SendOptionsList,
        ClassName,
        ClassLen,
        BufStart,
        BufEnd
    );
    SentOptions[OPTION_PARAMETER_REQUEST_LIST] = TRUE;

    ThisEntry = SendOptionsList->Flink;
    while( ThisEntry != SendOptionsList ) {
        ThisOpt = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);
        ThisEntry = ThisEntry->Flink;

        if( ThisOpt->IsVendor ? VSentOptions[ThisOpt->OptionId] : SentOptions[ThisOpt->OptionId] )
            continue;

        // if( ThisOpt->IsVendor) continue;       // No vendor specific information this round through
        if( ThisOpt->ClassLen ) {
            if( ThisOpt->ClassLen != ClassLen ) continue;
            if( ThisOpt->ClassName != ClassName )
                continue;                         // this option is not used for this client
        }

        if( !ThisOpt->IsVendor ) {                // easy to add non-vendor spec options
            SentOptions[ThisOpt->OptionId] = TRUE;
            BufStart = (LPBYTE)DhcpAppendOption(
                (POPTION)BufStart,
                ThisOpt->OptionId,
                ThisOpt->Data,
                (BYTE)ThisOpt->DataLen,
                BufEnd
            );
        } else {                                  // ENCAPSULATE vendor specific options
            if( SentOptions[OPTION_VENDOR_SPEC_INFO] )
                continue;                         // Vendor spec info already added

            VSentOptions[ThisOpt->OptionId] = TRUE;

            if( ThisOpt->DataLen + 2 + *VendorOptLen > OPTION_END )
                continue;                         // this option overflows the buffer

            VendorOpt[(*VendorOptLen)++] = ThisOpt->OptionId;
            VendorOpt[(*VendorOptLen)++] = (BYTE)ThisOpt->DataLen;
            memcpy(&VendorOpt[*VendorOptLen], ThisOpt->Data, ThisOpt->DataLen);
            (*VendorOptLen) += ThisOpt->DataLen;
        }
    }
    return (POPTION)BufStart;
}


DWORD                                             // status
DhcpDestroyOptionsList(                           // destroy a list of options, freeing up memory
    IN OUT  PLIST_ENTRY            OptionsList,   // this is the list of options to destroy
    IN      PLIST_ENTRY            ClassesList    // this is where to remove classes off
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                   ThisOption;
    DWORD                          Error;
    DWORD                          LastError;

    LastError = ERROR_SUCCESS;
    while(!IsListEmpty(OptionsList) ) {           // for each element of this list
        ThisEntry  = RemoveHeadList(OptionsList);
        ThisOption = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);

        if( NULL != ThisOption->ClassName ) {     // if there is a class, deref it
            Error = DhcpDelClass(
                ClassesList,
                ThisOption->ClassName,
                ThisOption->ClassLen
            );
            if( ERROR_SUCCESS != Error ) {
                DhcpAssert( ERROR_SUCCESS == Error);
                LastError = Error;
            }
        }

        DhcpFreeMemory(ThisOption);               // now really free this
    }
    return LastError;
}

DWORD                                             // win32 status
DhcpClearAllOptions(                              // clear all the options information
    IN OUT  PDHCP_CONTEXT          DhcpContext    // the context to clear for
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                   ThisOption;

    //(void) DhcpRegClearOptDefs(DhcpContext->AdapterName));

    ThisEntry = DhcpContext->RecdOptionsList.Flink;
    while(ThisEntry != &DhcpContext->RecdOptionsList) {
        ThisOption = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);
        ThisEntry  = ThisEntry->Flink;

        // bug bug, need to return space?
        ThisOption->Data = NULL;
        ThisOption->DataLen = 0;

        //LocalError = DhcpMarkParamChangeRequests(
        //    DhcpContext->AdapterName,
        //    ThisOption->OptionId,
        //    ThisOption->IsVendor,
        //    ThisOption->ClassName
        //);
        DhcpAssert(ERROR_SUCCESS == LocalError);
    }
    return ERROR_SUCCESS;
}

POPTION                                           // buffer after filling option
DhcpAppendClassIdOption(                          // fill class id if exists
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // the context to fillfor
    OUT     LPBYTE                 BufStart,      // start of message buffer
    IN      LPBYTE                 BufEnd         // end of message buffer
) {
    DWORD                          Size;

    Size = (DWORD)(BufEnd - BufStart);

    if( DhcpContext->ClassId ) {
        DhcpAssert(DhcpContext->ClassIdLength);
        BufStart = (LPBYTE)DhcpAppendOption(
            (POPTION)BufStart,
            OPTION_USER_CLASS,
            DhcpContext->ClassId,
            (BYTE)DhcpContext->ClassIdLength,
            BufEnd
        );
    }

    return (POPTION) BufStart;
}

LPOPTION
DhcpAppendOption(
    LPOPTION Option,
    BYTE OptionType,
    PVOID OptionValue,
    ULONG OptionLength,
    LPBYTE OptionEnd
)
/*++

Routine Description:

    This function writes a DHCP option to message buffer.

Arguments:

    Option - A pointer to a message buffer.

    OptionType - The option number to append.

    OptionValue - A pointer to the option data.

    OptionLength - The lenght, in bytes, of the option data.

    OptionEnd - End of Option Buffer.

Return Value:

    A pointer to the end of the appended option.

--*/
{
    DWORD  i;

    if ( OptionType == OPTION_END ) {

        //
        // we should alway have atleast one BYTE space in the buffer
        // to append this option.
        //

        DhcpAssert( (LPBYTE)Option < OptionEnd );


        Option->OptionType = OPTION_END;
        return( (LPOPTION) ((LPBYTE)(Option) + 1) );

    }

    if ( OptionType == OPTION_PAD ) {

        //
        // add this option only iff we have enough space in the buffer.
        //

        if(((LPBYTE)Option + 1) < (OptionEnd - 1) ) {
            Option->OptionType = OPTION_PAD;
            return( (LPOPTION) ((LPBYTE)(Option) + 1) );
        }

        DhcpPrint(("DhcpAppendOption failed to append Option "
                    "%ld, Buffer too small.\n", OptionType ));
        return Option;
    }


    //
    // add this option only iff we have enough space in the buffer.
    //

    if(((LPBYTE)Option + 2 + OptionLength) >= (OptionEnd - 1) ) {
        DhcpPrint(("DhcpAppendOption failed to append Option "
                    "%ld, Buffer too small.\n", OptionType ));
        return Option;
    }

    if( OptionLength <= 0xFF ) {
        // simple option.. no need to use OPTION_MSFT_CONTINUED
        Option->OptionType = OptionType;
        Option->OptionLength = (BYTE)OptionLength;
        memcpy( Option->OptionValue, OptionValue, OptionLength );
        return( (LPOPTION) ((LPBYTE)(Option) + Option->OptionLength + 2) );
    }

    // option size is > 0xFF --> need to continue it using multiple ones..
    // there are OptionLenght / 0xFF occurances using 0xFF+2 bytes + one
    // using 2 + (OptionLength % 0xFF ) space..

    // check to see if we have the space first..

    if( 2 + (OptionLength%0xFF) + 0x101*(OptionLength/0xFF)
        + (LPBYTE)Option >= (OptionEnd - 1) ) {
        DhcpPrint(("DhcpAppendOption failed to append Option "
                    "%ld, Buffer too small.\n", OptionType ));
        return Option;
    }

    // first finish off all chunks of 0xFF size that we can do..

    i = OptionLength/0xFF;
    while(i) {
        Option->OptionType = OptionType;
        Option->OptionLength = 0xFF;
        memcpy(Option->OptionValue, OptionValue, 0xFF);
        OptionValue = 0xFF+(LPBYTE)OptionValue;
        Option = (LPOPTION)(0x101 + (LPBYTE)Option);
        OptionType = OPTION_MSFT_CONTINUED;       // all but the first use this ...
        OptionLength -= 0xFF;
    }

    // now finish off the remaining stuff..
    DhcpAssert(OptionLength <= 0xFF);
    Option->OptionType = OPTION_MSFT_CONTINUED;
    Option->OptionLength = (BYTE)OptionLength;
    memcpy(Option->OptionValue, OptionValue, OptionLength);
    Option = (LPOPTION)(2 + OptionLength + (LPBYTE)Option);
    DhcpAssert((LPBYTE)Option < OptionEnd);

    return Option;
}


LPBYTE
DhcpAppendMagicCookie(
    LPBYTE Option,
    LPBYTE OptionEnd
    )
/*++

Routine Description:

    This routine appends magic cookie to a DHCP message.

Arguments:

    Option - A pointer to the place to append the magic cookie.

    OptionEnd - End of Option buffer.

Return Value:

    A pointer to the end of the appended cookie.

    Note : The magic cookie is :

     --------------------
    | 99 | 130 | 83 | 99 |
     --------------------

--*/
{
    DhcpAssert( (Option + 4) < (OptionEnd - 1) );
    if( (Option + 4) < (OptionEnd - 1) ) {
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE1;
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE2;
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE3;
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE4;
    }

    return( Option );
}

LPOPTION
DhcpAppendClientIDOption(
    LPOPTION Option,
    BYTE ClientHWType,
    LPBYTE ClientHWAddr,
    BYTE ClientHWAddrLength,
    LPBYTE OptionEnd

    )
/*++

Routine Description:

    This routine appends client ID option to a DHCP message.

History:
    8/26/96 Frankbee    Removed 16 byte limitation on the hardware
                        address

Arguments:

    Option - A pointer to the place to append the option request.

    ClientHWType - Client hardware type.

    ClientHWAddr - Client hardware address

    ClientHWAddrLength - Client hardware address length.

    OptionEnd - End of Option buffer.

Return Value:

    A pointer to the end of the newly appended option.

    Note : The client ID option will look like as below in the message:

     -----------------------------------------------------------------
    | OpNum | Len | HWType | HWA1 | HWA2 | .....               | HWAn |
     -----------------------------------------------------------------

--*/
{
#pragma warning(push)           // save current warning state
#pragma warning(disable : 4200) // disable 0-sized array warning

    struct _CLIENT_ID {
        BYTE    bHardwareAddressType;
        BYTE    pbHardwareAddress[0];
    } *pClientID;

#pragma warning(pop)            // restore previous warning state

    LPOPTION lpNewOption;

    pClientID = (_CLIENT_ID *) DhcpAllocateMemory( sizeof( struct _CLIENT_ID ) + ClientHWAddrLength );

    //
    // currently there is no way to indicate failure.  simply return unmodified option
    // list
    //

    if ( !pClientID )
        return Option;

    pClientID->bHardwareAddressType    = ClientHWType;
    memcpy( pClientID->pbHardwareAddress, ClientHWAddr, ClientHWAddrLength );

    lpNewOption =  DhcpAppendOption(
                         Option,
                         OPTION_CLIENT_ID,
                         (LPBYTE)pClientID,
                         (BYTE)(ClientHWAddrLength + sizeof(BYTE)),
                         OptionEnd );

    DhcpFreeMemory( pClientID );

    return lpNewOption;
}

// data locks on ClassesList must be taken before calling this function
PDHCP_CLASSES PRIVATE                             // the required classes struct
DhcpFindClass(                                    // find a specified class
    IN OUT  PLIST_ENTRY            ClassesList,   // list of classes to srch in
    IN      LPBYTE                 Data,          // non-NULL data bytes
    IN      DWORD                  Len            // # of bytes of above, > 0
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_CLASSES                  ThisClass;

    ThisEntry = ClassesList->Flink;               // first element in list
    while( ThisEntry != ClassesList ) {           // search the full list
        ThisClass = CONTAINING_RECORD( ThisEntry, DHCP_CLASSES, ClassList );
        ThisEntry = ThisEntry->Flink;

        if( ThisClass->ClassLen == Len ) {        // lengths must match
            if( ThisClass->ClassName == Data )    // data ptrs can match OR data can match
                return ThisClass;
            if( 0 == memcmp(ThisClass->ClassName, Data, Len) )
                return ThisClass;
        }
    }
    return NULL;
}

// locks on ClassesList should be taken when using this function
LPBYTE                                            // data bytes, or NULL
DhcpAddClass(                                     // add a new class
    IN OUT  PLIST_ENTRY            ClassesList,   // list to add to
    IN      LPBYTE                 Data,          // input class name
    IN      DWORD                  Len            // # of bytes of above
) {
    PDHCP_CLASSES                  Class;
    DWORD                          MemSize;       // amt of memory reqd

    if( NULL == ClassesList ) {                   // invalid parameter
        DhcpAssert( NULL != ClassesList );
        return NULL;
    }

    if( 0 == Len || NULL == Data ) {              // invalid parameters
        DhcpAssert(0 != Len && NULL != Data );
        return NULL;
    }

    Class = DhcpFindClass(ClassesList,Data,Len);  // already there in list?
    if(NULL != Class) {                           // yes, found
        Class->RefCount++;                        // increase ref-count
        return Class->ClassName;
    }

    MemSize = sizeof(*Class)+Len;                 // amt of memory reqd
    Class = (PDHCP_CLASSES) DhcpAllocateMemory(MemSize);
    if( NULL == Class ) {                         // not enough memory
        DhcpAssert( NULL != Class);
        return NULL;
    }

    Class->ClassLen = Len;
    Class->RefCount = 1;
    Class->ClassName = ((LPBYTE)Class) + sizeof(*Class);
    memcpy(Class->ClassName, Data, Len);

    InsertHeadList(ClassesList, &Class->ClassList);

    return Class->ClassName;
}

// locks on ClassesList must be taken before calling this function
DWORD                                             // status
DhcpDelClass(                                     // de-refernce a class
    IN OUT  PLIST_ENTRY            ClassesList,   // the list to delete off
    IN      LPBYTE                 Data,          // the data ptr
    IN      DWORD                  Len            // the # of bytes of above
) {
    PDHCP_CLASSES                  Class;

    if( NULL == ClassesList ) {
        DhcpAssert( NULL != ClassesList );
        return ERROR_INVALID_PARAMETER;
    }

    if( 0 == Len || NULL == Data ) {              // invalid parameter
        DhcpAssert( 0 != Len && NULL != Data );
        return ERROR_INVALID_PARAMETER;
    }

    Class = DhcpFindClass(ClassesList,Data,Len);
    if( NULL == Class ) {                         // did not find this class?
        DhcpAssert( NULL != Class );
        return ERROR_FILE_NOT_FOUND;
    }

    Class->RefCount --;
    if( 0 == Class->RefCount ) {                  // all references removed
        RemoveEntryList( &Class->ClassList );     // remove this from the list
        DhcpFreeMemory(Class);                    // free it
    }

    return ERROR_SUCCESS;
}

// locks on ClassesList must be taken before calling this function
VOID                                              // always succeed
DhcpFreeAllClasses(                               // free each elt of the list
    IN OUT  PLIST_ENTRY            ClassesList    // input list of classes
) {
    PDHCP_CLASSES                  ThisClass;
    PLIST_ENTRY                    ThisEntry;

    if( NULL == ClassesList ) {
        DhcpAssert( NULL != ClassesList && "DhcpFreeAllClasses" );
        return ;
    }

    while( !IsListEmpty(ClassesList) ) {
        ThisEntry = RemoveHeadList(ClassesList);
        ThisClass = CONTAINING_RECORD(ThisEntry, DHCP_CLASSES, ClassList);

        if( ThisClass->RefCount ) {
            DhcpPrint(("Freeing with refcount = %ld\n", ThisClass->RefCount));
        }

        DhcpFreeMemory(ThisClass);
    }

    InitializeListHead(ClassesList);
}

//--------------------------------------------------------------------------------
// exported functions, options
//--------------------------------------------------------------------------------

// data locks need to be taken on OptionsList before calling this function
PDHCP_OPTION                                     // the reqd structure or NULL
DhcpFindOption(                                   // find a specific option
    IN OUT  PLIST_ENTRY            OptionsList,   // the list of options to search
    IN      BYTE                   OptionId,      // the option id to search for
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // is there a class associated?
    IN      DWORD                  ClassLen       // # of bytes of above parameter
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                  ThisOption;

    if( NULL == OptionsList ) {
        DhcpAssert( NULL != OptionsList );
        return NULL;
    }

    ThisEntry = OptionsList->Flink;
    while( ThisEntry != OptionsList ) {           // search the set of options
        ThisOption = CONTAINING_RECORD( ThisEntry, DHCP_OPTION, OptionList );
        ThisEntry  = ThisEntry->Flink;

        if( ThisOption->OptionId != OptionId ) continue;
        if( ThisOption->IsVendor != IsVendor ) continue;
        if( ThisOption->ClassLen != ClassLen ) continue;
        if( ClassLen && ThisOption->ClassName != ClassName )
            continue;                             // mismatched so far

        return ThisOption;                        // found the option
    }

    return NULL;                                  // did not find any match
}

// locks on OptionsList need to be taken before calling this function
DWORD                                             // status
DhcpDelOption(                                    // remove a particular option
    IN      PDHCP_OPTION           ThisOption     // option to delete
) {
    if( NULL == ThisOption)                       // nope, did not find this option
        return ERROR_FILE_NOT_FOUND;

    RemoveEntryList( &ThisOption->OptionList);    // found it.  remove and free
    DhcpFreeMemory(ThisOption);

    return ERROR_SUCCESS;
}

// locks on OptionsList need to be taken before calling this function
DWORD                                             // status
DhcpAddOption(                                    // add a new option
    IN OUT  PLIST_ENTRY            OptionsList,   // list to add to
    IN      BYTE                   OptionId,      // option id to add
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // what is the class?
    IN      DWORD                  ClassLen,      // size of above in bytes
    IN      LPBYTE                 Data,          // data for this option
    IN      DWORD                  DataLen,       // # of bytes of above
    IN      time_t                 ExpiryTime     // when the option expires
) {
    PDHCP_OPTION                  ThisOption;
    DWORD                          MemSize;

    if( NULL == OptionsList ) {
        DhcpAssert( NULL != OptionsList && "DhcpAddOption" );
        return ERROR_INVALID_PARAMETER;
    }

    if( 0 != ClassLen && NULL == ClassName ) {
        DhcpAssert( 0 == ClassLen || NULL != ClassName && "DhcpAddOption" );
        return ERROR_INVALID_PARAMETER;
    }

    if( 0 != DataLen && NULL == Data ) {
        DhcpAssert( 0 == DataLen || NULL != Data && "DhcpAddOption" );
        return ERROR_INVALID_PARAMETER;
    }

    MemSize = sizeof(DHCP_OPTION) + DataLen ;
    ThisOption = (PDHCP_OPTION) DhcpAllocateMemory(MemSize);
    if( NULL == ThisOption )                      // could not allocate memory
        return ERROR_NOT_ENOUGH_MEMORY;

    ThisOption->OptionId   = OptionId;
    ThisOption->IsVendor   = IsVendor;
    ThisOption->ClassName  = ClassName;
    ThisOption->ClassLen   = ClassLen;
    ThisOption->ExpiryTime = ExpiryTime;
    ThisOption->DataLen    = DataLen;
    ThisOption->Data       = ((LPBYTE)ThisOption) + sizeof(DHCP_OPTION);
    memcpy(ThisOption->Data, Data, DataLen);

    InsertHeadList( OptionsList, &ThisOption->OptionList );

    return ERROR_SUCCESS;
}



//================================================================================
//   end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\sockreg.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    sockreg.h

Abstract:

    Prototypes for sockreg.cxx

    stolen from Win95 winsock project (& modified)

Author:

    Richard L Firth (rfirth) 10-Feb-1994

Environment:

    Chicago/Snowball (i.e. Win32/Win16)

Revision History:

    10-Feb-1994 (rfirth)
        Created

--*/

//
// registry/config/ini items
//

#define CONFIG_HOSTNAME     1
#define CONFIG_DOMAIN       2
#define CONFIG_SEARCH_LIST  3
#define CONFIG_NAME_SERVER  4

//
// prototypes
//

UINT
SockGetSingleValue(
    IN UINT ParameterId,
    OUT LPBYTE Data,
    IN UINT DataLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\regexp.h ===
#ifndef __REGEXP_H__
#define __REGEXP_H__

#include <windows.h>
#include "utils.h"

#define PAT_START	128	/* Special beginning-of-pattern marker */
#define PAT_END		129	/* Special end-of-pattern marker */
#define PAT_STAR	130	/* Zero or more of any character */
#define PAT_QUES	131	/* Exactly one of any character */
#define PAT_AUGDOT	132	/* Literal '.' or end-of-string */
#define PAT_AUGQUES	133	/* Empty string or non-'.' */
#define PAT_AUGSTAR	134	/* Single character that isn't a '.' */

BOOL test_match(int m, LPSTR target, int pattern[]);
BOOL parse_pattern(LPSTR s, int pattern[]);
BOOL match( LPSTR target, LPSTR regexp);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\stack.h ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// All dealings with the stack and other non-Dhcp components go through the API
// given here
//================================================================================

#ifndef STACK_H_INCLUDED
#define STACK_H_INCLUDED

//================================================================================
// Exported API's
//================================================================================

DWORD                                             // win32 status
DhcpClearAllStackParameters(                      // undo the effects
    IN      PDHCP_CONTEXT          DhcpContext    // the adapter to undo
);

DWORD                                             // win32 status
DhcpSetAllStackParameters(                        // set all stack details
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to set stuff
    IN      PDHCP_FULL_OPTIONS     DhcpOptions    // pick up the configuration from off here
);

#endif STACK_H_INCLUDED

#ifndef SYSSTACK_H_INCLUDED
#define SYSSTACK_H_INCLUDED
//================================================================================
// imported api's
//================================================================================
DWORD                                             // return interface index or -1
DhcpIpGetIfIndex(                                 // get the IF index for this adapter
    IN      PDHCP_CONTEXT          DhcpContext    // context of adapter to get IfIndex for
);

DWORD                                             // win32 status
DhcpSetRoute(                                     // set a route with the stack
    IN      DWORD                  Dest,          // network order destination
    IN      DWORD                  DestMask,      // network order destination mask
    IN      DWORD                  IfIndex,       // interface index to route
    IN      DWORD                  NextHop,       // next hop n/w order address
    IN      BOOL                   IsLocal,       // is this a local address? (IRE_DIRECT)
    IN      BOOL                   IsDelete       // is this route being deleted?
);

#endif SYSSTACK_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\tdistat.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TDISTAT.H - TDI status code definitions.
//
// This file contains the TDI status code definitions.

#ifndef NT

#define TDI_SUCCESS             0           // Success
#define TDI_NO_RESOURCES        1           // No resources.
#define TDI_ADDR_IN_USE         2           // Address already in use.
#define TDI_BAD_ADDR            3           // Address given is bad.
#define TDI_NO_FREE_ADDR        4           // No addresses available.
#define TDI_ADDR_INVALID        6           // Address object is invalid.
#define TDI_ADDR_DELETED        7           // Address object was deleted.
#define TDI_BUFFER_OVERFLOW     9           // Buffer overflowed.
#define TDI_BAD_EVENT_TYPE      10          // Bad event type.
#define TDI_BAD_OPTION          11          // Bad option or length.
#define TDI_CONN_REFUSED        14          // Connection was refused.
#define TDI_INVALID_CONNECTION  15          // Invalid connection.
#define TDI_ALREADY_ASSOCIATED  16          // Connection already associated.
#define TDI_NOT_ASSOCIATED      17          // Connection not associated.
#define TDI_CONNECTION_ACTIVE   18          // Connection is still active.
#define TDI_CONNECTION_ABORTED  19          // Connection was aborted.
#define TDI_CONNECTION_RESET    20          // Connection was reset.
#define TDI_TIMED_OUT           21          // Connection timed out.
#define TDI_GRACEFUL_DISC       22          // Received a graceful disconnect.
#define TDI_NOT_ACCEPTED        23          // Data not accepted.
#define TDI_MORE_PROCESSING     24          // More processing required.
#define TDI_INVALID_STATE       25          // TCB in an invalid state.
#define TDI_INVALID_PARAMETER   26          // An invalid parameter.
#define TDI_DEST_NET_UNREACH    27          // Destination net is unreachable.
#define TDI_DEST_HOST_UNREACH   28          // Dest. host is unreachable.
#define TDI_DEST_UNREACHABLE    TDI_DEST_HOST_UNREACH
#define TDI_DEST_PROT_UNREACH   29          // Destination protocol is
                                            // unreachable.
#define TDI_DEST_PORT_UNREACH   30          // Dest. port is unreachable.
#define TDI_INVALID_QUERY       31          // Invalid query type specified.
#define TDI_REQ_ABORTED         32          // Request was aborted for some
                                            // reason.
#define TDI_BUFFER_TOO_SMALL    33          // Buffer was too small.
#define TDI_CANCELLED           34          // The request was cancelled.
#define	TDI_BUFFER_TOO_BIG		35			// Send buffer was too big.
#define TDI_ITEM_NOT_FOUND      36          // Item not found.
#define TDI_INVALID_REQUEST     0xfe        // Invalid request.
#define TDI_PENDING             0xff        // Pending

#else

//
// Map to NT STATUS codes.
//
#define TDI_SUCCESS             STATUS_SUCCESS
#define TDI_NO_RESOURCES        STATUS_INSUFFICIENT_RESOURCES
#define TDI_ADDR_IN_USE         STATUS_ADDRESS_ALREADY_EXISTS
#define TDI_BAD_ADDR            STATUS_INVALID_ADDRESS_COMPONENT
#define TDI_NO_FREE_ADDR        STATUS_TOO_MANY_ADDRESSES
#define TDI_ADDR_INVALID        STATUS_INVALID_ADDRESS
#define TDI_ADDR_DELETED        STATUS_ADDRESS_CLOSED
#define TDI_BUFFER_OVERFLOW     STATUS_BUFFER_OVERFLOW
#define TDI_BAD_EVENT_TYPE      STATUS_INVALID_PARAMETER
#define TDI_BAD_OPTION          STATUS_INVALID_PARAMETER
#define TDI_CONN_REFUSED        STATUS_CONNECTION_REFUSED
#define TDI_INVALID_CONNECTION  STATUS_CONNECTION_INVALID
#define TDI_ALREADY_ASSOCIATED  STATUS_ADDRESS_ALREADY_ASSOCIATED
#define TDI_NOT_ASSOCIATED      STATUS_ADDRESS_NOT_ASSOCIATED
#define TDI_CONNECTION_ACTIVE   STATUS_CONNECTION_ACTIVE
#define TDI_CONNECTION_ABORTED  STATUS_CONNECTION_ABORTED
#define TDI_CONNECTION_RESET    STATUS_CONNECTION_RESET
#define TDI_TIMED_OUT           STATUS_IO_TIMEOUT
#define TDI_GRACEFUL_DISC       STATUS_GRACEFUL_DISCONNECT
#define TDI_NOT_ACCEPTED        STATUS_DATA_NOT_ACCEPTED
#define TDI_MORE_PROCESSING     STATUS_MORE_PROCESSING_REQUIRED
#define TDI_INVALID_STATE       STATUS_INVALID_DEVICE_STATE
#define TDI_INVALID_PARAMETER   STATUS_INVALID_PARAMETER
#define TDI_DEST_NET_UNREACH    STATUS_NETWORK_UNREACHABLE
#define TDI_DEST_HOST_UNREACH   STATUS_HOST_UNREACHABLE
#define TDI_DEST_UNREACHABLE    TDI_DEST_HOST_UNREACH
#define TDI_DEST_PROT_UNREACH   STATUS_PROTOCOL_UNREACHABLE
#define TDI_DEST_PORT_UNREACH   STATUS_PORT_UNREACHABLE
#define TDI_INVALID_QUERY       STATUS_INVALID_DEVICE_REQUEST
#define TDI_REQ_ABORTED         STATUS_REQUEST_ABORTED
#define TDI_BUFFER_TOO_SMALL    STATUS_BUFFER_TOO_SMALL
#define TDI_CANCELLED           STATUS_CANCELLED
#define	TDI_BUFFER_TOO_BIG		STATUS_INVALID_BUFFER_SIZE
#define TDI_INVALID_REQUEST     STATUS_INVALID_DEVICE_REQUEST
#define TDI_PENDING             STATUS_PENDING
#define TDI_ITEM_NOT_FOUND      STATUS_OBJECT_NAME_NOT_FOUND


#endif  // NT

#define	TDI_OPTION_EOL				0

#define	TDI_ADDRESS_OPTION_REUSE	1
#define	TDI_ADDRESS_OPTION_DHCP		2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\sockreg.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    sockreg.cxx

Abstract:

    Contains the registry/ini-file specific functions from gethost.c

    Taken from Win95 Winsock 1.1 project

    Contents:
        SockGetSingleValue
        (CheckRegistryForParameter)

Author:

    Richard L Firth (rfirth) 10-Feb-1994

Environment:

    Win32 user-mode DLL

Revision History:

    10-Feb-1994 (rfirth)
        Created

    24-Feb-2001 (ssulzer)
        Updated for WinHttp5

--*/

//
// includes
//


#include <wininetp.h>
#include "aproxp.h"



//
// manifests
//

//#define PLATFORM_TYPE_UNKNOWN       ((DWORD)(-1))
//#define PLATFORM_TYPE_WIN95         ((DWORD)(0))
//#define PLATFORM_TYPE_WINNT         ((DWORD)(1))

//#define PLATFORM_SUPPORTS_UNICODE   0x00000001
#define DEVICE_PREFIX       "\\Device\\"


//
// manifests
//

//
// macros
//

#define FSTRLEN(p)      lstrlen((LPSTR)(p))
#define FSTRCPY(p1, p2) lstrcpy((LPSTR)(p1), (LPSTR)(p2))
#define FSTRCAT(p1, p2) lstrcat((LPSTR)(p1), (LPSTR)(p2))

//
// MAP_PARAMETER_ID - returns a string corresponding to the database parameter
//
// N.B. id MUST start at 1
//

#define MAP_PARAMETER_ID(id)    ParameterNames[(id) - 1]

//
// globally available registry keys
//

extern HKEY ServicesKey;  //       = INVALID_HANDLE_VALUE;


//
// private prototypes
//

PRIVATE
UINT
CheckRegistryForParameter(
    IN UINT ParameterId,
    OUT LPBYTE Data,
    IN UINT DataLength
    );

//
// private data
//

//
// ParameterNames - the names of the registry values corresponding to the
// variables retrieved by SockGetSingleValue.
//
// N.B. These MUST be in order of the CONFIG_ manifests in sockreg.h
//

PRIVATE const LPCSTR ParameterNames[] = {
    "HostName",
    "Domain",
    "SearchList",
    "NameServer"
};

//
// functions
//

/*******************************************************************************
 *
 *  GetBoundAdapterList
 *
 *  Gets a list of names of all adapters bound to a protocol (TCP/IP). Returns
 *  a pointer to an array of pointers to strings - basically an argv list. The
 *  memory for the strings is concatenated to the array and the array is NULL
 *  terminated. If Elnkii1 and IbmTok2 are bound to TCP/IP then this function
 *  will return:
 *
 *          ---> addr of string1   \
 *               addr of string2    \
 *               NULL                > allocated as one block
 *     &string1: "Elnkii1"          /
 *     &string2: "IbmTok2"         /
 *
 *  ENTRY   BindingsSectionKey
 *              - Open registry handle to a linkage key (e.g. Tcpip\Linkage)
 *
 *  EXIT
 *
 *  RETURNS pointer to argv[] style array, or NULL
 *
 *  ASSUMES
 *
 ******************************************************************************/

LPSTR* GetBoundAdapterList(HKEY BindingsSectionKey)
{

    LPSTR* resultBuffer;

    LONG err;
    DWORD valueType;
    PBYTE valueBuffer = NULL;
    DWORD valueLength;
    LPSTR* nextResult;
    int len;
    DWORD resultLength;
    LPSTR nextValue;
    LPSTR variableData;
    DWORD numberOfBindings;

    //
    // get required size of value buffer
    //

    valueLength = 0;
    resultBuffer = NULL;

    err = RegQueryValueEx(BindingsSectionKey,
                          "Bind",
                          NULL, // reserved
                          &valueType,
                          NULL,
                          &valueLength
                          );
    if (err != ERROR_SUCCESS) {
        goto quit;
    }
    if (valueType != REG_MULTI_SZ) {
        goto quit;
    }
    if (!valueLength) {
        goto quit;
    }
    valueBuffer = (PBYTE)ALLOCATE_ZERO_MEMORY(valueLength);
    if ( valueBuffer == NULL ) {
        goto quit;
    }

    err = RegQueryValueEx(BindingsSectionKey,
                          "Bind",
                          NULL, // reserved
                          &valueType,
                          valueBuffer,
                          &valueLength
                          );
    if (err != ERROR_SUCCESS) {
        goto quit;
    }
    resultLength = sizeof(LPSTR);   // the NULL at the end of the list
    numberOfBindings = 0;
    nextValue = (LPSTR)valueBuffer;
    while (0 != (len = strlen(nextValue))) {
        resultLength += sizeof(LPSTR) + len + 1;
        if (!_strnicmp(nextValue, DEVICE_PREFIX, sizeof(DEVICE_PREFIX) - 1)) {
            resultLength -= sizeof(DEVICE_PREFIX) - 1;
        }
        nextValue += len + 1;
        ++numberOfBindings;
    }
    resultBuffer = (LPSTR*)ALLOCATE_ZERO_MEMORY(resultLength);
    if ( resultBuffer == NULL ) {
        goto quit;
    }
    nextValue = (LPSTR)valueBuffer;
    nextResult = resultBuffer;
    variableData = (LPSTR)(((LPSTR*)resultBuffer) + numberOfBindings + 1);
    while (numberOfBindings--) {

        LPSTR adapterName;

        adapterName = nextValue;
        if (!_strnicmp(adapterName, DEVICE_PREFIX, sizeof(DEVICE_PREFIX) - 1)) {
            adapterName += sizeof(DEVICE_PREFIX) - 1;
        }
        *nextResult++ = variableData;
        strcpy(variableData, adapterName);
        while (*variableData) {
            ++variableData;
        }
        ++variableData;
        while (*nextValue) {
            ++nextValue;
        }
        ++nextValue;
    }

    *nextResult = NULL;

quit:

    if ( valueBuffer != NULL )
    {
        FREE_MEMORY(valueBuffer);
    }

    return resultBuffer;
}


/*******************************************************************************
 *
 *  OpenAdapterKey
 *
 *  Opens one of the 2 per-adapter registry keys: <Adapter>\Parameters\Tcpip, or
 *  NetBT\Adapters\<Adapter>
 *
 *  ENTRY   KeyType - KEY_TCP or KEY_NBT
 *          Name    - pointer to adapter name to use
 *          Key     - pointer to returned key
 *
 *  EXIT    Key updated
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL OpenAdapterKey(DWORD KeyType, LPSTR Name, PHKEY Key)
{

    LONG err;
    CHAR keyName[MAX_ADAPTER_NAME_LENGTH + sizeof("\\Parameters\\Tcpip")];

    if ((lstrlen(Name)+sizeof("\\Parameters\\Tcpip")) < ARRAY_ELEMENTS(keyName))
    {
        if (KeyType == KEY_TCP) {

            //
            // open the handle to this adapter's TCPIP parameter key
            //

            strcpy(keyName, Name);
            strcat(keyName, "\\Parameters\\Tcpip");
        } else if (KeyType == KEY_NBT) {

            //
            // open the handle to the NetBT\Adapters\<Adapter> handle
            //

            strcpy(keyName, "NetBT\\Adapters\\");
            strcat(keyName, Name);
        }
    }
    else
    {
        INET_ASSERT((lstrlen(Name)+sizeof("\\Parameters\\Tcpip")) < ARRAY_ELEMENTS(keyName));
        return FALSE;
    }

    err = REGOPENKEY(ServicesKey,
                     keyName,
                     Key
                     );


    DEBUG_PRINT( SOCKETS,
                 INFO,
                 ("RegOpenKey %s %s %s %d\n",
                 SERVICES_KEY_NAME, keyName,
                 (err != ERROR_SUCCESS )? "failed":"success",
                 GetLastError()                              ));


    return (err == ERROR_SUCCESS);
}

/*******************************************************************************
 *
 *  ReadRegistryDword
 *
 *  Reads a registry value that is stored as a DWORD
 *
 *  ENTRY   Key             - open registry key where value resides
 *          ParameterName   - name of value to read from registry
 *          Value           - pointer to returned value
 *
 *  EXIT    *Value = value read
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL ReadRegistryDword(HKEY Key, LPSTR ParameterName, LPDWORD Value)
{

    LONG err;
    DWORD valueLength;
    DWORD valueType;

    valueLength = sizeof(*Value);

    err = RegQueryValueEx(Key,
                          ParameterName,
                          NULL, // reserved
                          &valueType,
                          (LPBYTE)Value,
                          &valueLength
                          );

    if(    (err         == ERROR_SUCCESS )
        && (valueType   == REG_DWORD     )
        && (valueLength == sizeof(DWORD))) {

        return 1;
    } else {
        DEBUG_PRINT(SOCKETS, INFO,
                 ("ReadRegistryDword(%s): err=%d\n", ParameterName, err ));
        return 0;
    }

}

/*******************************************************************************
 *
 *  ReadRegistryString
 *
 *  Reads a registry value that is stored as a string
 *
 *  ENTRY   Key             - open registry key
 *          ParameterName   - name of value to read from registry
 *          String          - pointer to returned string
 *          Length          - IN: length of String buffer. OUT: length of returned string
 *
 *  EXIT    String contains string read
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL
ReadRegistryString(HKEY Key, LPSTR ParameterName, LPSTR String, LPDWORD Length)
{

    LONG err;
    DWORD valueType;

    *String = '\0';
    err = RegQueryValueEx(Key,
                          ParameterName,
                          NULL, // reserved
                          &valueType,
                          (LPBYTE)String,
                          Length
                          );

    if (err == ERROR_SUCCESS) {

        INET_ASSERT(valueType == REG_SZ || valueType == REG_MULTI_SZ);

        return  (*Length) > sizeof(char);

    } else {
        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("ReadRegistryString(%s): err=%d\n", ParameterName, err ));
        return 0;
    }

}



UINT
SockGetSingleValue(
    IN UINT ParameterId,
    OUT LPBYTE Data,
    IN UINT DataLength
    )

/*++

Routine Description:

    Retrieve parameter from Registry/DHCP/TCPIP

    This is what we look for and where:

        HostName:   1. HKLM\Services\CurrentControlSet\System\Vxd\MSTCP\HostName                (Win95)
                       HKLM\Services\CurrentControlSet\System\Tcpip\Parameters\Hostname         (NT)
                    2. (SYSTEM.INI:DNS.HostName)*                                               (N/A)
                    3. GetComputerName()

        DomainName: 1. HKLM\Services\CurrentControlSet\System\Vxd\MSTCP\Domain                  (Win95)
                       HKLM\Services\CurrentControlSet\System\Tcpip\Parameters\DhcpDomain       (NT)
                       HKLM\Services\CurrentControlSet\System\Tcpip\Parameters\Domain           (NT)
                    2. (SYSTEM.INI:DNS.DomainName)*                                             (N/A)
                    3. DHCP                                                                     (Win95)

        SearchList: 1. HKLM\Services\CurrentControlSet\System\Vxd\MSTCP\SearchList              (Win95)
                       HKLM\Services\CurrentControlSet\System\Tcpip\Parameters\SearchList       (NT)
                    2. (SYSTEM.INI:DNS.DNSDomains)*                                             (N/A)

        NameServer: 1. HKLM\Services\CurrentControlSet\System\Vxd\MSTCP\NameServer              (Win95)
                       HKLM\Services\CurrentControlSet\System\Tcpip\Parameters\DhcpNameServer   (NT)
                       HKLM\Services\CurrentControlSet\System\Tcpip\Parameters\NameServer       (NT)
                    2. (SYSTEM.INI:DNS.DNSServers)*                                             (N/A)
                    3. DHCP                                                                     (Win95)

        * Entries marked thus are registry backups from SYSTEM.INI until all
          keys are moved into registry or if platform is WFW 3.11 (in which
          case there is no registry)

    ASSUMES 1. Data is big enough to hold the default value (single byte for
               strings, dword for dwords)
            2. Registry is accessible from 16-bit code too

Arguments:

    ParameterId - identifier of parameter to retrieve

    Data        - pointer to untyped storage space for parameter

    DataLength  - length of data returned (in bytes)

Return Value:

    UINT
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                    can't locate required parameter in registry/ini/etc.

--*/

{
    UINT error = CheckRegistryForParameter(ParameterId, Data, DataLength);

    //
    // if the value was not in the registry then we must attempt to get it from
    // another place, specific to the particular variable requested
    //

    if (error != ERROR_SUCCESS) {
        if (ParameterId == CONFIG_HOSTNAME) {

            //
            // on Win32 platform we can call GetComputerName() to provide the
            // computer name, which is the default host name, if none is
            // specified elsewhere
            //

            DWORD length;

            length = DataLength;
            if (!GetComputerName((LPSTR)Data, &length)) {
                error = GetLastError();
            }
        } else if (ParameterId == CONFIG_DOMAIN) {
            if (GlobalPlatformType == PLATFORM_TYPE_WIN95) {
//                error = GetDomainNameFromDhcp(Data, DataLength);
                  INET_ASSERT(FALSE && "Not implemented on Win9x; port code from WinInet");
            }
        } else if (ParameterId == CONFIG_NAME_SERVER) {
            if (GlobalPlatformType == PLATFORM_TYPE_WIN95) {
//                error = GetDnsServerListFromDhcp(Data, DataLength);
                  INET_ASSERT(FALSE && "Not implemented on Win9x; port code from WinInet");
            }
        } else {

            //
            // the caller is requesting the domain list (or an invalid config
            // parameter value?!?). We have nowhere else to get this value -
            // return an error
            //

            error = ERROR_PATH_NOT_FOUND;
        }
    }

    IF_DEBUG(REGISTRY) {
        if (error != ERROR_SUCCESS) {
            DEBUG_PRINT(SOCKETS, INFO,
                        ("SockGetSingleValue(%s) returns %d\r",
                        MAP_PARAMETER_ID(ParameterId),
                        error
                        ));
        } else {
            DEBUG_PRINT(SOCKETS, INFO,
                        ("SockGetSingleValue(%s) returns \"%s\"\n",
                        MAP_PARAMETER_ID(ParameterId),
                        Data
                        ));
        }
    }

    return error;
}


PRIVATE
UINT
CheckRegistryForParameter(
    IN UINT ParameterId,
    OUT LPBYTE Data,
    IN UINT DataLength
    )

/*++

Routine Description:

    Retrieve parameter from registry

    ASSUMES 1. Data is big enough to hold the default value (single byte for
               strings, dword for dwords)

Arguments:

    ParameterId - identifier of parameter to retrieve

    Data        - pointer to untyped storage space for parameter

    DataLength  - length of data returned (in bytes)

Return Value:

    UINT
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                  ERROR_INSUFFICIENT_BUFFER

--*/

{
    HKEY key;
    LONG error = REGOPENKEY(HKEY_LOCAL_MACHINE,
                            (GlobalPlatformType == PLATFORM_TYPE_WINNT)
                            ? "System\\CurrentControlSet\\Services\\Tcpip\\Parameters"
                            : "System\\CurrentControlSet\\Services\\VxD\\MSTCP",
                            &key
                            );
    if (error == ERROR_SUCCESS) {

        char dhcpBuffer[128];   // arbitrary
        LPSTR p;
        DWORD length;
        DWORD type;
        BOOL tryDhcp;

        if (GlobalPlatformType == PLATFORM_TYPE_WINNT) {
            FSTRCPY(dhcpBuffer, "Dhcp");
            p = &dhcpBuffer[sizeof("Dhcp") - 1];
            tryDhcp = TRUE;
        } else {
            p = dhcpBuffer;
            tryDhcp = FALSE;
        }

        FSTRCPY(p, MAP_PARAMETER_ID(ParameterId));

        //
        // on NT, we look first for the manually-entered variables e.g. "Domain"
        // and if not found, we look a second time for the DHCP-configured
        // variant, e.g. "DhcpDomain"
        //

        for (int i = 0; i < 2; ++i) {

            //
            // if NT, first we try the transient key which is written to the
            // registry when we have a dial-up connection
            //

            if ((i == 0) && (GlobalPlatformType == PLATFORM_TYPE_WINNT)) {

                HKEY transientKey;

                error = REGOPENKEY(key, "Transient", &transientKey);
                if (error == ERROR_SUCCESS) {
                    length = DataLength;
                    error = RegQueryValueEx(transientKey,
                                            p,
                                            NULL,   // reserved
                                            &type,
                                            Data,
                                            &length
                                            );
                    REGCLOSEKEY(transientKey);

                    //
                    // if we succeeded in retrieving a non-empty string then
                    // we're done.
                    //
                    // We test for > 1 because the registry returns the length
                    // including the zero-terminator
                    //

                    if ((error == ERROR_SUCCESS) && (length > 1)) {
                        break;
                    }
                }
            }


            length = DataLength;
            error = RegQueryValueEx(key,
                                    p,
                                    NULL,   // reserved
                                    &type,
                                    Data,
                                    &length
                                    );

            //
            // if the key exists, but there is no value then return an error OR
            // if we didn't find the key (or value) AND NT then try for the DHCP
            // version (Note: We try for DhcpSearchList even though it doesn't
            // exist)
            //

            if ((error != ERROR_SUCCESS)
            || (length == 0)
            || ((length == 1) && (Data[0] == '\0'))) {
                if (tryDhcp) {
                    p = dhcpBuffer;
                    tryDhcp = FALSE;
                    continue;
                } else {
                    error = ERROR_PATH_NOT_FOUND;
                    break;
                }
            } else if ((UINT)length > DataLength) {
                error = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
        }
        REGCLOSEKEY(key);
    }

    IF_DEBUG(REGISTRY) {
        DEBUG_PRINT(SOCKETS, INFO,
                    ("CheckRegistryForParameter(%s): returning %d\n",
                    MAP_PARAMETER_ID(ParameterId),
                    error
                    ));
    }

    return (UINT)error;
}



UINT
GetDhcpServerFromDhcp(
    IN OUT CAdapterInterface * paiInterface
    )

/*******************************************************************************
 *
 *  GetDhcpServerFromDhcp
 *
 *  Updates an CAdapterInterface with the DHCP server from the DHCP info
 *
 *  ENTRY   paiInterface - pointer to CAdapterInterface to update
 *
 *  EXIT    paiInterface - DhcpServer may be updated
 *
 *  RETURNS TRUE if AdapterInfo->DhcpServer updated
 *
 *  ASSUMES 1. AdapterInfo->Address is valid
 *
 ******************************************************************************/

{
    if ( GlobalPlatformType == PLATFORM_TYPE_WINNT )
    {
        HKEY key;

        if (paiInterface->GetAdapterName() &&
            OpenAdapterKey(KEY_TCP, paiInterface->GetAdapterName(), &key))
        {
            char dhcpServerAddress[4 * 4];
            DWORD addressLength;
            DWORD fDhcpEnabled = FALSE;

            ReadRegistryDword(key,
                              "EnableDHCP",
                              &fDhcpEnabled
                              );

            if ( fDhcpEnabled )
            {

                addressLength = sizeof(dhcpServerAddress);
                if (ReadRegistryString(key,
                                       "DhcpServer",
                                       dhcpServerAddress,
                                       &addressLength
                                       ))
                {
                    DWORD ipAddress = _I_inet_addr(dhcpServerAddress);

                    if ( IS_VALID_NON_LOOPBACK_IP_ADDRESS(ipAddress) )
                    {
                        paiInterface->AddDhcpServer(ipAddress);
                        paiInterface->SetDhcp();
                    }
                }
            }

            //ReadRegistryDword(key,
            //                  "LeaseObtainedTime",
            //                  &AdapterInfo->LeaseObtained
            //                  );

            //ReadRegistryDword(key,
            //                  "LeaseTerminatesTime",
            //                  &AdapterInfo->LeaseExpires
            //                  );


            REGCLOSEKEY(key);
            return fDhcpEnabled;
        }
    }
    else
    {
        INET_ASSERT(FALSE && "GetDhcpServerFromDhcp() not implemented on Win9x; port code from WinInet");
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\utils.cpp ===
#include <wininetp.h>
#include "utils.h"

//----------------------------------------------------------------------------
// HELPER FUNCTIONS
//----------------------------------------------------------------------------


// Function to get the coclass ClassId of a script engine given its name

HRESULT GetScriptEngineClassIDFromName(
	LPCSTR pszLanguage,
	LPSTR pszBuff,
	UINT cBuffSize)
{
	HKEY hKey = NULL;
	HKEY hKeySub;
	LONG result;
	HRESULT hr;
	LONG cClassIdLen;

	// Open \HKEY_CLASSES_ROOT\[pszLanguage]

	// LONG RegOpenKeyEx(
    //	HKEY	hKey,		// handle of open key
    //	LPCTSTR	lpSubKey,	// address of name of subkey to open
    //	DWORD	ulOptions,	// reserved
    //	REGSAM	samDesired,	// security access mask
    //	PHKEY	phkResult 	// address of handle of open key
	// );	

	result = RegOpenKeyEx(HKEY_CLASSES_ROOT, pszLanguage, 0, KEY_READ, &hKey);

	if (result != ERROR_SUCCESS) {
		hr = E_FAIL;
		goto exit;
	}

	// Make sure this object supports OLE Scripting

	result = RegOpenKeyEx(hKey, "OLEScript", 0, KEY_READ, &hKeySub);

	if (result != ERROR_SUCCESS) {
		hr = E_FAIL;
		goto exit;
	}

	RegCloseKey(hKeySub);

	// Get the class ID

	// LONG RegQueryValueEx(
    //	HKEY	hKey,			// handle of key to query
    //	LPTSTR	lpValueName,	// address of name of value to query
    //	LPDWORD	lpReserved,		// reserved
    //	LPDWORD	lpType,			// address of buffer for value type
    //	LPBYTE	lpData,			// address of data buffer
    //	LPDWORD	lpcbData	 	// address of data buffer size
    // );

	result = RegOpenKeyEx(hKey, "CLSID", 0, KEY_READ, &hKeySub);

	if (result != ERROR_SUCCESS) {
		hr = E_FAIL;
		goto exit;
	}

	cClassIdLen = cBuffSize;
	result = RegQueryValue(hKeySub, NULL, pszBuff, &cClassIdLen);

	RegCloseKey(hKeySub);

	if (result != ERROR_SUCCESS) {
		hr = E_FAIL;
		goto exit;
	}

	pszBuff[cBuffSize-1] = '\0';

	hr = S_OK;

exit:
	if (hKey) {
		RegCloseKey(hKey);
	}

	return hr;
}


//=--------------------------------------------------------------------------=
// MakeWideFromAnsi
//=--------------------------------------------------------------------------=
// given a string, make a BSTR out of it.
//
// Parameters:
//    LPSTR         - [in]
//    BYTE          - [in]
//
// Output:
//    LPWSTR        - needs to be cast to final desired result
//
// Notes:
//
LPWSTR MakeWideStrFromAnsi
(
    LPCSTR psz,
    BYTE  bType
)
{
    LPWSTR pwsz;
    int i;

    //  Because delayloaded(DL) functions are being used, need to check
    //that they are loaded.  MakeWideStrFromAnsi() is now currently
    //called only through JSProxy::Invoke, so a check not done in
    //debug mode has already been done.  This check is more to make sure
    //people don't add calls to MakeWideStrFromAnsi without having called
    //DelayLoad( &g_moduleOleAut32)
    INET_ASSERT( g_moduleOleAut32._hDllHandle != NULL);

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate the widestr, +1 for terminating null
    //
    switch (bType) {
      case STR_BSTR:
        // -1 since it'll add it's own space for a NULL terminator
        //
        pwsz = (LPWSTR) DL(SysAllocStringLen)(NULL, i - 1);
        break;
      case STR_OLESTR:
        pwsz = (LPWSTR) DL(CoTaskMemAlloc)(i * sizeof(WCHAR));
        break;
      default:
        return NULL;
                ;
    }

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}

int ConvertAnsiDayToInt(LPSTR szday)
{
	int today = -1;
	if (szday)  // GetDateFormat always returns mixed caps and since this comes from a Win32 API I will
	{			// assume a properly formatted string! :)
		switch (szday[0])
		{
		case 'S' :
			if (lstrcmp(szday,"SUN") == 0)
				today = 0;
			else
			{
				if (lstrcmp(szday,"SAT") == 0)	
					today = 6;
			}
			break;

		case 'M' :
			if (lstrcmp(szday,"MON") == 0)
				today = 1;
			break;

		case 'T' :
			if (lstrcmp(szday,"TUE") == 0)
				today = 2;
			else
			{
				if (lstrcmp(szday,"THU") == 0)	
				today = 4;
			}
			break;

		case 'W' :
			if (lstrcmp(szday,"WED") == 0)
				today = 3;
			break;

		case 'F' :
			if (lstrcmp(szday,"FRI") == 0)
				today = 5;
			break;
		
		}
	}
	return today;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\utils.h ===
#ifndef __UTILS_H__
#define __UTILS_H__

#include <windows.h>
#include <olectl.h>
#include <shlwapi.h>

// BUGBUG - remove and include wininet.h
#include "autoprox.hxx"

/********************************************************************************************/
// ClassID and GUID helpers
HRESULT GetScriptEngineClassIDFromName(LPCSTR pszLanguage,LPSTR pszBuff,UINT cBuffSize);

/********************************************************************************************/
// String Helper functions and macros
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? (char *)&m_szTmpBuf : (new(char[cBytes]));
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) delete [] m_pBuf;
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPSTR pszA;
//  pszA = MyGetAnsiStringRoutine();
//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//  MyUseWideStringRoutine(pwsz);
//  ...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * 2 * sizeof(char); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()

LPWSTR MakeWideStrFromAnsi( LPCSTR, BYTE bType);
#define STR_BSTR   0
#define STR_OLESTR 1
#define BSTRFROMANSI(x)    (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x)  (LPOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR)

int ConvertAnsiDayToInt(LPSTR szday);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\tdiinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TDIINFO.H - TDI Query/SetInfoEx definitons.
//
//	This file contains definitions for the extended TDI query and set info.
//	calls.
//

#ifndef TDI_INFO_INCLUDED
#define TDI_INFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


//* Structure of an entity ID.
typedef struct TDIEntityID {
	ulong		tei_entity;
	ulong		tei_instance;
} TDIEntityID;

//* Structure of an object ID.
typedef struct TDIObjectID {
	TDIEntityID	toi_entity;
	ulong		toi_class;
	ulong		toi_type;
	ulong		toi_id;
} TDIObjectID;

#define	MAX_TDI_ENTITIES			512

#define	INFO_CLASS_GENERIC			0x100
#define	INFO_CLASS_PROTOCOL			0x200
#define	INFO_CLASS_IMPLEMENTATION	0x300

#define	INFO_TYPE_PROVIDER			0x100
#define	INFO_TYPE_ADDRESS_OBJECT	0x200
#define	INFO_TYPE_CONNECTION		0x300

#define	ENTITY_LIST_ID				0

#define	GENERIC_ENTITY				0

#define	CO_TL_ENTITY				0x400
#define	CL_TL_ENTITY				0x401

#define	ER_ENTITY					0x380

#define	CO_NL_ENTITY				0x300
#define	CL_NL_ENTITY				0x301

#define	AT_ENTITY					0x280

#define	IF_ENTITY					0x200

#define	CONTEXT_SIZE				16


//* The following are IDs supported by all entities. They are of class
//	GENERIC and type PROVIDER.

#define	ENTITY_TYPE_ID				1			// The ID to get the entity
												// type. The return from this
												// type is an unsigned integer
												// (see below).


// Valid values to get back from entity type ID query.
#define	CO_TL_NBF					0x400		// Entity implements NBF prot.
#define	CO_TL_SPX					0x402		// Entity implements SPX prot.
#define	CO_TL_TCP					0x404		// Entity implements TCP prot.
#define	CO_TL_SPP					0x406		// Entity implements SPP prot.

#define	CL_TL_NBF					0x401		// CL NBF protocol.
#define	CL_TL_UDP					0x403		// Entity implements UDP.

#define	ER_ICMP						0x380		// The ICMP protocol.

#define	CL_NL_IPX					0x301		// Entity implements IPX.
#define	CL_NL_IP					0x303		// Entity implements IP.

#define	AT_ARP						0x280		// Entity implements ARP.
#define	AT_NULL						0x282		// Entity does no address
												// translation.

#define	IF_GENERIC					0x200		// Generic interface.
#define	IF_MIB						0x202		// Supports MIB-2 interface.


/*NOINC*/
//
// NT DeviceIoControl definitions for TdiExtendedInformationEx functions.
//

//
// QueryInformationEx IOCTL. The return buffer is passed as the OutputBuffer
// in the DeviceIoControl request. This structure is passed as the
// InputBuffer.
//
struct tcp_request_query_information_ex {
	TDIObjectID   ID;                     // object ID to query.
	uchar         Context[CONTEXT_SIZE];  // multi-request context. Zeroed
	                                      // for the first request.
};

typedef struct tcp_request_query_information_ex
        TCP_REQUEST_QUERY_INFORMATION_EX,
        *PTCP_REQUEST_QUERY_INFORMATION_EX;

//
// SetInformationEx IOCTL request structure. This structure is passed as the
// InputBuffer. The space allocated for the structure must be large enough
// to contain the structure and the set data buffer, which begins at the
// Buffer field. The OutputBuffer parameter in the DeviceIoControl is not used.
//
struct tcp_request_set_information_ex {
	TDIObjectID   ID;                // object ID to set.
	unsigned int  BufferSize;        // size of the set data buffer in bytes
	unsigned char Buffer[1];         // beginning of the set data buffer
};

typedef struct tcp_request_set_information_ex
               TCP_REQUEST_SET_INFORMATION_EX,
			   *PTCP_REQUEST_SET_INFORMATION_EX;


#endif // TDI_INFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\vdhcpapi.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    vdhcpapi.h

Abstract:

    Worker functions for VDHCP APIs.

Author:

    Madan Appiah (madana)  28-May-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef VDHCPAPI_H_
#define VDHCPAPI_H_

#define DHCP_QUERY_INFO             1
#define DHCP_RENEW_IPADDRESS        2
#define DHCP_RELEASE_IPADDRESS      3

typedef struct _DHCP_NIC_INFO {
    DWORD OffsetHardwareAddress;
    DWORD HardwareLength;
    DWORD IpAddress;
    DWORD Lease;
    DWORD LeaseObtainedTime;
    DWORD LeaseExpiresTime;
    DWORD DhcpServerAddress;
    DWORD DNSServersLen;
    DWORD OffsetDNSServers;
    DWORD DomainNameLen;
    DWORD OffsetDomainName;
} DHCP_NIC_INFO, *LPDHCP_NIC_INFO;

typedef struct _DHCP_HW_INFO {
    DWORD OffsetHardwareAddress;
    DWORD HardwareLength;
} DHCP_HW_INFO, *LPDHCP_HW_INFO;

typedef struct _DHCP_QUERYINFO {
    DWORD NumNICs;
    DHCP_NIC_INFO NicInfo[1];
} DHCP_QUERYINFO, *LPDHCP_QUERYINFO;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\autoproxy\wscntl.h ===
/**********************************************************************/
/**                        Microsoft Windows                         **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    wscntl.h

    Semi-public include file for the WsControl API in the Chicago/
    Snowball Windows Sockets implementation.


    FILE HISTORY:
        KeithMo     04-Feb-1994 Created.

*/


#ifndef _WSCNTL_H_
#define _WSCNTL_H_


//
//  Function prototypes.
//

DWORD
PASCAL FAR
WsControl(
	DWORD	Protocol,
	DWORD	Action,
	LPVOID	InputBuffer,
	LPDWORD	InputBufferLength,
	LPVOID	OutputBuffer,
	LPDWORD	OutputBufferLength
	);

typedef DWORD (PASCAL FAR * LPWSCONTROL)( DWORD   Protocol,
                                          DWORD   Action,
                                          LPVOID  InputBuffer,
                                          LPDWORD InputBufferLength,
                                          LPVOID  OutputBuffer,
                                          LPDWORD OutputBufferLength );


//
//  TCP/IP action codes.
//

#define WSCNTL_TCPIP_QUERY_INFO             0x00000000
#define WSCNTL_TCPIP_SET_INFO               0x00000001


#endif	// _WSCNTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\browseinfo\makefile.inc ===
$(O)\sbrlist.inc:
    perl.exe gensbrlists.pl .. $(O)

!if "$(BUILD_PASS)" == "PASS2"

!include $(O)\sbrlist.inc

$(O)\WinHttp5.bsc: $(SBRLIST) 
    $(MAKEDIR)\tools\x86\bscmake -nologo -o $@ @<<
$(SBRLIST: =
)
<<NOKEEP

!else

$(O)\WinHttp5.bsc: 

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\buffer.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    buffer.cxx

Abstract:

    Contains code to impliment a double buffering class used in SSL/PCT (secure channel)
        transactions.


Author:

    Arthur L Bierer (arthurbi) 20-March-1996

Revision History:

    20-March-1996 arthurbi
        Created

--*/

#include <wininetp.h>


BOOL
DBLBUFFER::InitBuffer(
    BOOL fDblBufferMode
    )

/*++

Routine Description:

    Allocates, and initalizes internal buffers.

Arguments:

    fDblBufferMode  - TRUE if we are to maintain to buffers,
                      FALSE if we treat the output and input buffers the same

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, not enough memory to allocate buffers.

Comments:


--*/

{
    DEBUG_ENTER((DBG_BUFFER,
                 Bool,
                 "DBLBUFFER::InitBuffer",
                 "%B",
                 fDblBufferMode
                 ));

    INET_ASSERT(_lpBuffer == NULL);
    INET_ASSERT(_dwInitDefaultBufferSize > 0 );

    _lpBuffer = (LPBYTE)ALLOCATE_FIXED_MEMORY(_dwInitDefaultBufferSize);

    DEBUG_PRINT(API,
                INFO,
                ("allocated %d byte buffer %#x\n",
                _dwInitDefaultBufferSize,
                _lpBuffer
                ));

    BOOL success = FALSE;

    if (_lpBuffer != NULL) {

        INET_ASSERT(_dwBufferOut == 0);
        INET_ASSERT(_dwBufferIn == 0);

        _fDblBufferMode = fDblBufferMode;

        _dwBufferLength = _dwInitDefaultBufferSize ;
        _lpBufferOut = _lpBuffer + _dwBufferLength;
        _lpBufferIn      = _lpBuffer + _dwBufferLength;

        success = TRUE;
    }

    DEBUG_LEAVE(success);

    return success;
}

DWORD
DBLBUFFER::GetInputBufferRemaining(
    VOID
    )

/*++

Routine Description:

    Determines the amount of free bytes availble for reading into the input buffer.
        Will attempt to push current data to the front of the buffer, to make the
        most room in the currently allocated buffer.

Arguments:

    none.

Return Value:

    DWORD
        Number of bytes free.

Comments:

        Assumed to only be called in DblBuffer mode.

--*/


{
    DEBUG_ENTER((DBG_INET,
                 Int,
                 "DBLBUFFER::GetInputBufferRemaining",
                 NULL
                 ));


    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_dwBufferOut == 0 );
    INET_ASSERT(_fDblBufferMode );


    BOOL fIsInputBufferCompressed = (_lpBufferIn == _lpBuffer);

    if ( ! fIsInputBufferCompressed )
    {
        BOOL fIsSuccess;

        fIsSuccess = CompressInputBufferUsage( ) ;

        INET_ASSERT(fIsSuccess);
    }

    INET_ASSERT(_lpBufferIn == _lpBuffer );

    DEBUG_LEAVE((DWORD) (_lpEndOfBuffer - (_dwBufferIn + _lpBuffer) ));

    return (DWORD) (_lpEndOfBuffer - (_dwBufferIn + _lpBuffer) );
}

BOOL
DBLBUFFER::CopyIn(
    IN LPBYTE lpBuffer,
    IN DWORD dwBufferSize
    )
{

    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::CopyIn",
                 "%x, %d",
                 lpBuffer,
                 dwBufferSize
                 ));


    INET_ASSERT(lpBuffer);
    INET_ASSERT(dwBufferSize > 0);

    LPBYTE pbPointer;
    DWORD  dwCurInputSize;

    //
    // Get the current input buffer size
    //

    dwCurInputSize = GetInputBufferSize();

    if ( ! ResizeBufferIfNeeded(dwBufferSize) )
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    pbPointer = GetInputBufferPointer()+dwCurInputSize;
    SetInputBufferSize(dwBufferSize+dwCurInputSize);


    CopyMemory(
        pbPointer,             // dest
        lpBuffer,              // src
        dwBufferSize           // size
        );


    DEBUG_LEAVE(TRUE);

    return TRUE;

}

BOOL
DBLBUFFER::CopyOut(
    OUT LPBYTE     lpBuffer,
    IN OUT LPDWORD lpdwBufferRemaining,
    IN OUT LPDWORD lpdwBytesReceived,
    IN OUT LPDWORD lpdwBytesRead
    )

/*++

Routine Description:

    Fills passed in buffer with the contents of the output buffer.

Arguments:

    lpBuffer                    -       Buffer to fill with output buffer bytes

        lpdwBufferRemaining -   Number of bytes remaining in Buffer to fill.

        lpdwBytesReceived       -       Number of bytes currently in Buffer to fill.

        lpdwBytesRead           -       Current total of bytes copied into Buffer to fill.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

Comments:


--*/

{

    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::CopyOut",
                 "%x, %u, %u, %u",
                 lpBuffer,
                 (lpdwBufferRemaining ? *lpdwBufferRemaining : 0),
                 (lpdwBytesReceived ? *lpdwBytesReceived : 0),
                 (lpdwBytesRead ? *lpdwBytesRead : 0)
                 ));


    INET_ASSERT(lpBuffer);
    INET_ASSERT(lpdwBufferRemaining);
    INET_ASSERT(lpdwBytesReceived);
    INET_ASSERT(lpdwBytesRead);

    //
    // Figure out the max number of bytes we can copy into our user's buffer
    //      We need to make sure it will fit into the user's buffer.
    //

    DWORD dwBytesToCopy = (*lpdwBufferRemaining  >= _dwBufferOut)
            ? _dwBufferOut : *lpdwBufferRemaining;


    DEBUG_PRINT(API,
                INFO,
                ("DBLBUFFER::CopyOut: Copying ( to: %x bytes-to-copy=%d )\n",
                (lpBuffer+*lpdwBytesReceived),
                dwBytesToCopy
                ));


    //
    // Transfer Data to User's buffer.
    //

    CopyMemory ((lpBuffer+*lpdwBytesReceived),
                            _lpBufferOut,
                            dwBytesToCopy);


    //
    // Update the number of bytes we copied to the user buffer
    //

    *lpdwBytesRead                  += dwBytesToCopy;
    *lpdwBytesReceived              += dwBytesToCopy;
    *lpdwBufferRemaining    -= dwBytesToCopy;

    //
    // Update Our Internal Vars
    //

    _dwBufferOut                    -= dwBytesToCopy;
    _lpBufferOut                    += dwBytesToCopy;

    UpdateVars();

    //
    // We always succeed for now !
    //

    DEBUG_LEAVE(TRUE);

    return TRUE;
}

BOOL
DBLBUFFER::CompressInputBufferUsage(
    VOID
    )
/*++

Routine Description:

        Moves the input buffer to the begining of the internal allocated buffer.
        This produces a larger block of internal free space.

Arguments:

        none.

Return Value:

    BOOL
    Success - TRUE

    Success     - FALSE, there was no need to compress the buffer.

Comments:

  Assumed to be called only if DblBufferMode is enabled.

--*/


{
    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::CompressInputBufferUsage",
                 NULL
                 ));

    BOOL bResult = FALSE;

    //
    // Maximize use of buffer by moving input data to the front
    // of the buffer.
    //

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_dwBufferOut == 0);
    INET_ASSERT(_fDblBufferMode);

    INET_ASSERT(((_lpBufferIn != _lpEndOfBuffer) || (_dwBufferIn == 0)));

    if (_lpBufferIn > _lpBuffer) {

        DEBUG_PRINT(API,
                    INFO,
                    ("compressing input buffer %d (%#x) @ %#x => %#x\n",
                    _dwBufferIn,
                    _dwBufferIn,
                    _lpBufferIn,
                    _lpBuffer
                    ));

        MoveMemory(_lpBuffer,
                   _lpBufferIn,
                   _dwBufferIn
                   );

        //
        // Input Buffer now starts at the begining of the allocated buffer
        //

        _lpBufferIn = _lpBuffer;
        bResult = TRUE;
    }

    DEBUG_LEAVE(bResult);

    return bResult;
}



BOOL
DBLBUFFER::ConcatenateOutputBufferUsage(
    IN LPBYTE lpSecondOutputBuffer,
    IN DWORD  dwSecondOutputBufferSize
    )

/*++

Routine Description:

    Combines the current output buffer with the contents of a new buffer.
    (Note: intented for use in combining decrypted data which may be seperated by
    header or trailer data)

Arguments:

    lpSecondOutputBuffer        - New Buffer to combine with internal output buffer.

    dwSecondOutputBufferSize    - Size of New Buffer in bytes.


Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

Comments:

    If the internal buffer is sized 0, the new buffer replaces the internal buffer.
    Its assumed that the New buffer is a former input buffer turned output by
    some external operation, such as a block decryption operation.
--*/

{


    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::ConcatenateOutputBufferUsage",
                 "%x, %u",
                 lpSecondOutputBuffer,
                 dwSecondOutputBufferSize
                 ));


    //
    // Combinate Two buffers into one.
    //

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_fDblBufferMode );
    INET_ASSERT(lpSecondOutputBuffer);
    INET_ASSERT(dwSecondOutputBufferSize);

    INET_ASSERT(_lpBufferOut < _lpBufferIn );
    INET_ASSERT(lpSecondOutputBuffer >= _lpBuffer && lpSecondOutputBuffer <=_lpEndOfBuffer );



    if ( _dwBufferOut != 0 )
    {
        DEBUG_PRINT(API,
                    INFO,
                    ("DBLBUFFER::ConcatenateOutputBufferUsage: Combining new data with output buffer\n"
                    ));

        MoveMemory((_lpBufferOut+_dwBufferOut),
                   lpSecondOutputBuffer,
                   dwSecondOutputBufferSize);
        //
        // Output Buffer is now bigger ( sum of orginal + new buffer size )
        //

        _dwBufferOut += dwSecondOutputBufferSize;

    }
    else
    {
        //
        // No previous output buffer, new buffer becomes output buffer
        //

        INET_ASSERT(_lpBufferOut == _lpEndOfBuffer );

        _lpBufferOut = lpSecondOutputBuffer;
        _dwBufferOut = dwSecondOutputBufferSize;

    }

    DEBUG_LEAVE(TRUE);

    return TRUE;
}


BOOL
DBLBUFFER::ResizeBufferIfNeeded(
    IN DWORD dwAddlBufferNeeded
    )

/*++

Routine Description:

    ReSizes internal buffer space to extend size of the buffer by dwAddlBufferNeeded.
    If the additional bytes can be made availble by compressing currently stored
    into one place ( ie the start of the buffer ), the reallocation of the buffer
    will not be done.

Arguments:

    dwAddlBufferNeeded  - Number of additional bytes to resize

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, the reallocation failed due to lack of memory.

Comments:

    Its assumed the caller will only use this function in dbl buffering mode.

 --*/

{

    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::ResizeBufferIfNeeded",
                 "%u",
                 dwAddlBufferNeeded
                 ));

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_dwBufferOut == 0 );
    INET_ASSERT(_fDblBufferMode );

    DWORD dwInputBytesFree = GetInputBufferRemaining();

    INET_ASSERT(_lpBuffer == _lpBufferIn );

    //
    // #bytes needed > #bytes left free in Buffer.
    //

    if ( dwAddlBufferNeeded > dwInputBytesFree )
    {
        HLOCAL hBuffer;

        hBuffer = (HLOCAL) _lpBuffer;

        //
        // length increases by (bytes needed - current bytes free[in old buffer])
        //

        _dwBufferLength += (dwAddlBufferNeeded - dwInputBytesFree);

        DEBUG_PRINT(API,
                    INFO,
                    ("DBLBUFFER::ResizeBufferIfNeeded: Resizing Buffer to %d, addl=%d, free=%d\n",
                    _dwBufferLength,
                    dwAddlBufferNeeded,
                    dwInputBytesFree
                    ));

        INET_ASSERT(_dwBufferLength < DBLBUFFER_MAX_SIZE);

        //
        // Do Resize, and store result
        //

        _lpBuffer = (LPBYTE)ResizeBuffer(hBuffer, _dwBufferLength, FALSE);

        DEBUG_PRINT(BUFFER,
                    INFO,
                    ("resized %#x => %#x, %d bytes\n",
                    hBuffer,
                    _lpBuffer,
                    _dwBufferLength
                    ));

        if ( ! _lpBuffer )
        {
            DEBUG_PRINT(API,
                        ERROR,
                        ("DBLBUFFER::ResizeBufferIfNeeded: Failed while Resizing, Out of Mem?\n"
                        ));

            DEBUG_LEAVE(FALSE);

            return FALSE;  // failing due to NOT_ENOUGH_MEMORY
        }

        //
        // Update ReSized Buffer pointers
        //

        _lpBufferIn = _lpBuffer;

        UpdateVars();
    }

    DEBUG_LEAVE(TRUE);

    return TRUE;
}

BOOL
DBLBUFFER::SetOutputInputBuffer(
    IN LPBYTE lpNewOutputBuffer,
    IN DWORD  dwNewOutputBufferSize,
    IN LPBYTE lpNewInputBuffer,
    IN DWORD  dwNewInputBufferSize,
    IN BOOL   fConcatenatePreviousOutput
    )

/*++

Routine Description:

    Allows caller to specify new addresses for input and output buffer.
    If fConcatenatePreviousOutput is set, SetOutputInputBuffer will combine
    the passed in output buffer with any internal output buffer.
    Also allows size changes to buffers.

Arguments:

    lpNewOutputBuffer           - New Output Buffer.

    dwNewOutputBufferSize       - Size of New Output Buffer.

    lpNewInputBuffer            - New Input Buffer.

    dwNewInputBufferSize        - New Input Buffer Size.

    fConcatenatePreviousOutput  - TRUE if we are to combine internal output buffer
                                  with (passed in) new output buffer
                                  FALSE if we are to just replace output buffer pointers.

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

Comments:

    Assumed to be called from double buffering mode.

--*/


{

    INET_ASSERT(_lpBuffer);
    INET_ASSERT((lpNewOutputBuffer >= _lpBuffer && lpNewOutputBuffer <= _lpEndOfBuffer) || dwNewOutputBufferSize == 0 );
    INET_ASSERT((lpNewInputBuffer >= _lpBuffer && lpNewInputBuffer <= _lpEndOfBuffer) || dwNewInputBufferSize == 0);
    INET_ASSERT(fConcatenatePreviousOutput || _dwBufferOut == 0 );
    INET_ASSERT(_fDblBufferMode );

    DEBUG_PRINT(API,
         INFO,
         ("DBLBUFFER::SetOutputInputBuffer: Getting New Output( %x, size=%d ) New Input( %x, size=%d)\n",
         lpNewOutputBuffer,
         dwNewOutputBufferSize,
         lpNewInputBuffer,
         dwNewInputBufferSize
         ));


    if ( fConcatenatePreviousOutput )
    {
        ConcatenateOutputBufferUsage(
                    lpNewOutputBuffer,
                    dwNewOutputBufferSize
                    );
    }
    else
    {
        _lpBufferOut = lpNewOutputBuffer;
        _dwBufferOut = dwNewOutputBufferSize;
    }


    _lpBufferIn = lpNewInputBuffer;
    _dwBufferIn = dwNewInputBufferSize;

    UpdateVars();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\caddrlst.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    caddrlst.cxx

Abstract:

    Contains CAddressList class definition

    Contents:
        CAddressList::FreeList
        CAddressList::SetList
        CAddressList::SetList
        CAddressList::SetList
        CAddressList::GetNextAddress
        CAddressList::InvalidateAddress
        CAddressList::ResolveHost
        CFsm_ResolveHost::RunSM
        (CAddressList::IPAddressToAddressList)
        (CAddressList::HostentToAddressList)
        (CAddressList::AddrInfoToAddressList)

Author:

    Richard L Firth (rfirth) 19-Apr-1997

Environment:

    Win32 user-mode DLL

Revision History:

    19-Apr-1997 rfirth
        Created

    28-Jan-1998 rfirth
        No longer randomly index address list. NT5 and Win98 are modified to
        return the address list in decreasing order of desirability by RTT/
        route

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//#define TEST_CODE

//Thread-procedure for async gethostbyname
DWORD WINAPI AsyncGetHostByName(LPVOID lpParameter);

//The destructor is called only when all refcounts have dropped to 0.
// i.e. when the INTERNET_HANDLE_OBJECT has released its reference, 
//      AND when all the GHBN threads are done.
//  At this point, we can flush the hostent cache and terminate list.
CResolverCache::~CResolverCache()
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CResolverCache::~CResolverCache",
                 "%#x",
                 this
                 ));

    FlushResolverCache(&_ResolverCache);
    TerminateSerializedList(&_ResolverCache);

    if (_pHandlesList)
        delete _pHandlesList;

    DEBUG_LEAVE (0);
}

CGetHostItem::~CGetHostItem()
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CGetHostItem::~CGetHostItem",
                 "%#x, %.100q, %B, %#x, %#x",
                 this, _lpszHostName, _fDelete, _pAlloc, _pSession
                 ));

    FREE_FIXED_MEMORY(_lpszHostName);
    if (_hThread)
        CloseHandle(_hThread);
    if (_fDelete && _pAlloc)
        FREE_FIXED_MEMORY(_pAlloc);
    if (_pSession)
        DereferenceObject(_pSession);

    DEBUG_LEAVE(0);
}
#if 0
void CResolverCache::ForceEmptyAndDeleteHandlesList()
{
    INET_ASSERT(_pHandlesList);
        
    _pHandlesList->LockList();

    CListItem* pItem = _pHandlesList->GetHead();

    while(pItem)
    {
        CListItem* pNext = pItem->GetNext();

        (((CGetHostItem*)pItem)->ForceDelete());
        delete pItem;
        _pHandlesList->ReduceCount();

        pItem = pNext;
    }

    //it's not going to be reused after this, so head and tail don't have to be set to NULL
    // on _pHandlesList
    _pHandlesList->UnlockList();
}
#endif
void CResolverCache::EmptyHandlesList()
{
    if (_pHandlesList)
    {
        _pHandlesList->LockList();

        CListItem* pItem = _pHandlesList->GetHead();

        while(pItem)
        {
            CListItem* pNext = pItem->GetNext();

            (((CGetHostItem*)pItem)->WaitDelete());
            delete pItem;
            _pHandlesList->ReduceCount();

            pItem = pNext;
        }

        //it's not going to be reused after this, so head and tail don't have to be set to NULL
        // on _pHandlesList
        _pHandlesList->UnlockList();
    }
}

void CResolverCache::TrimHandlesListSize(ULONG nTrimSize)
{        
    _pHandlesList->LockList();

    if (_pHandlesList->GetCount() >= nTrimSize)
    {
        CListItem* pItem = _pHandlesList->GetHead();
        CListItem* pPrev = NULL;

        while(pItem)
        {
            CListItem* pNext = pItem->GetNext();
            
            if (((CGetHostItem*)pItem)->CanBeDeleted())
            {
                if (pPrev)
                {
                    pPrev->SetNext(pNext);
                }
                else
                {
                    //The item being removed WAS the head.
                    _pHandlesList->SetHead(pNext);
                }

                if (!pNext)
                {
                    //The item being removed WAS the tail.
                    _pHandlesList->SetTail(pPrev);
                }

                delete pItem;
                _pHandlesList->ReduceCount();
            }
            else
            {  
                pPrev = pItem;
            }
            
            pItem = pNext;
        }
    }

    _pHandlesList->UnlockList();
}

BOOL CResolverCache::AddToHandlesList(HANDLE hThread, CGetHostItem* pGetHostItem)
{
    BOOL bRetval = TRUE;

    INET_ASSERT(_pHandlesList);
    pGetHostItem->SetThreadHandle(hThread);
    
    TrimHandlesListSize();
    _pHandlesList->AddToTail(pGetHostItem);

    return bRetval;    
}

DWORD WINAPI AsyncGetHostByName(LPVOID lpParameter)
{
#ifdef WINHTTP_FOR_MSXML
    //
    // MSXML needs to initialize is thread local storage data.
    // It does not do this during DLL_THREAD_ATTACH, so our
    // worker thread must explicitly call into MSXML to initialize
    // its TLS for this thread.
    //
    InitializeMsxmlTLS();
#endif

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "AsyncGetHostByName",
                 "%#x, %.100q",
                 lpParameter,
                 lpParameter ? ((CGetHostItem*)lpParameter)->GetHostName() : "NULL"
                 ));

    CGetHostItem* pGetHostItem = (CGetHostItem*)lpParameter;

    if (!pGetHostItem)
    {
        INET_ASSERT (FALSE);

        DEBUG_LEAVE (ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LPSTR lpszHostName = pGetHostItem->GetHostName();
    LPADDRINFO lpAddrInfo = NULL;
    ADDRINFO Hints;
    memset(&Hints, 0, sizeof(struct addrinfo));
    Hints.ai_flags = AI_CANONNAME;
    Hints.ai_family = PF_UNSPEC;      // Accept any protocol family.
    Hints.ai_socktype = SOCK_STREAM;  // Constrain results to stream socket.
    Hints.ai_protocol = IPPROTO_TCP;  // Constrain results to TCP.

    DWORD dwError = 0;

    if (0 == (dwError = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo)))
    {
        VOID* pAlloc = pGetHostItem->GetAllocPointer();
        AddResolverCacheEntry((pGetHostItem->GetResolverCache())->GetResolverCacheList(), lpszHostName, lpAddrInfo, LIVE_DEFAULT, &pAlloc, pGetHostItem->GetAllocSize());
        if (pAlloc)
        {
            //pAlloc is overwritten to NULL in CacheHostent if the memory is used,
            //we need to delete the alloced memory only if non-NULL
            pGetHostItem->SetDelete();
        }
    }

    DEBUG_LEAVE (dwError);
    return dwError;
}

DWORD AsyncGetHostByNameCleanup(LPVOID lpParameter)
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "AsyncGetHostByNameCleanup",
                 "%#x, %.100q",
                 lpParameter,
                 lpParameter ? ((CGetHostItem*)lpParameter)->GetHostName() : "NULL"
                 ));

    CGetHostItem* pGetHostItem = (CGetHostItem*)lpParameter;

    if (!pGetHostItem)
    {
        INET_ASSERT (FALSE);

        DEBUG_LEAVE (ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CFsm_ResolveHost* pFsm = (CFsm_ResolveHost *)pGetHostItem->GetAllocPointer();

    if (!pFsm->TestAndSetScheduled())
    {
        pFsm->QueueWorkItem();
    }
    else
    {
        DWORD dwDummy = 0;
        
        //only release reference && cleanup
        pFsm->Dereference(&dwDummy);
    }

    delete pGetHostItem;

    DEBUG_LEAVE (ERROR_SUCCESS);
    return ERROR_SUCCESS;
}

DWORD AsyncGetHostByNameWorker(LPVOID lpParameter)
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "AsyncGetHostByNameWorker",
                 "%#x, %.100q",
                 lpParameter,
                 lpParameter ? ((CGetHostItem*)lpParameter)->GetHostName() : "NULL"
                 ));

    CGetHostItem* pGetHostItem = (CGetHostItem*)lpParameter;

    if (!pGetHostItem)
    {
        INET_ASSERT (FALSE);

        DEBUG_LEAVE (ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    LPSTR lpszHostName = pGetHostItem->GetHostName();
    HMODULE hMod = pGetHostItem->GetModuleHandle();
    LPADDRINFO lpAddrInfo = NULL;
    ADDRINFO Hints;
    memset(&Hints, 0, sizeof(struct addrinfo));
    Hints.ai_flags = AI_CANONNAME;
    Hints.ai_family = PF_UNSPEC;      // Accept any protocol family.
    Hints.ai_socktype = SOCK_STREAM;  // Constrain results to stream socket.
    Hints.ai_protocol = IPPROTO_TCP;  // Constrain results to TCP.

    DWORD dwError = 0;

    if (0 == (dwError = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo)))
    {
        AddResolverCacheEntry((pGetHostItem->GetResolverCache())->GetResolverCacheList(), lpszHostName, lpAddrInfo, LIVE_DEFAULT);
    }

    dwError = AsyncGetHostByNameCleanup(lpParameter);

    DEBUG_LEAVE (dwError);
    
    if (hMod)
        FreeLibraryAndExitThread(hMod, dwError);
    
    return dwError;
}

//
// methods
//

VOID
CAddressList::FreeList(
    VOID
    )

/*++

Routine Description:

    Free address list

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (m_Addresses != NULL) {
        m_Addresses = (LPRESOLVED_ADDRESS)FREE_MEMORY((HLOCAL)m_Addresses);

        INET_ASSERT(m_Addresses == NULL);

        m_AddressCount = 0;
        m_BadAddressCount = 0;
        m_CurrentAddress = 0;
    }
}


DWORD
CAddressList::SetList(
    IN struct addrinfo FAR *lpAddrInfo
    )

/*++

Routine Description:

    Sets the list contents from the addrinfo.  Basically just a wrapper
    around AddrInfoToAddressList() that also grabs the critical section.

Arguments:

    lpAddrInfo  - Pointer to addrinfo containing resolved addresses to add.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    if (!Acquire())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    FreeList();

    DWORD error = AddrInfoToAddressList(lpAddrInfo);

    Release();

    return error;
}



BOOL
CAddressList::GetNextAddress(
    OUT LPDWORD lpdwResolutionId,
    IN OUT LPDWORD lpdwIndex,
    IN INTERNET_PORT nPort,
    OUT LPCSADDR_INFO lpAddressInfo
    )

/*++

Routine Description:

    Get next address to use when connecting. If we already have a preferred
    address, use that. We make a copy of the address to use in the caller's
    data space

Arguments:

    lpdwResolutionId    - used to determine whether the address list has been
                          resolved between calls

    lpdwIndex           - IN: current index tried; -1 if we want to try default
                          OUT: index of address address returned if successful

    nPort               - which port we want to connect to

    lpAddressInfo       - pointer to returned address if successful

Return Value:

    BOOL
        TRUE    - lpResolvedAddress contains resolved address to use

        FALSE   - need to (re-)resolve name

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CAddressList::GetNextAddress",
                 "%#x [%d], %#x [%d], %d, %#x",
                 lpdwResolutionId,
                 *lpdwResolutionId,
                 lpdwIndex,
                 *lpdwIndex,
                 nPort,
                 lpAddressInfo
                 ));

    PERF_ENTER(GetNextAddress);

    BOOL bOk = TRUE;

    //
    // if we tried all the addresses and failed already, re-resolve the name
    //

    if (!Acquire())
    {
        bOk = FALSE;
        goto quit;
    }

    if (m_BadAddressCount < m_AddressCount) {
        if (*lpdwIndex != (DWORD)-1) {

            INET_ASSERT(m_BadAddressCount < m_AddressCount);

            INT i = 0;

            m_CurrentAddress = *lpdwIndex;

            INET_ASSERT((m_CurrentAddress >= 0)
                        && (m_CurrentAddress < m_AddressCount));

            if ((m_CurrentAddress < 0) || (m_CurrentAddress >= m_AddressCount)) {
                m_CurrentAddress = 0;
            }
            do {
                NextAddress();
                if (++i == m_AddressCount) {
                    bOk = FALSE;
                    break;
                }
            } while (!IsCurrentAddressValid());
        }

        //
        // check to make sure this address hasn't expired
        //

        //if (!CheckHostentCacheTtl()) {
        //    bOk = FALSE;
        //}
    } else {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("exhausted %d addresses\n",
                    m_BadAddressCount
                    ));

        bOk = FALSE;
    }
    if (bOk) {

        DWORD dwLocalLength = LocalSockaddrLength();
        LPBYTE lpRemoteAddr = (LPBYTE)(lpAddressInfo + 1) + dwLocalLength;

        memcpy(lpAddressInfo + 1, LocalSockaddr(), dwLocalLength);
        memcpy(lpRemoteAddr, RemoteSockaddr(), RemoteSockaddrLength());
        lpAddressInfo->LocalAddr.lpSockaddr = (LPSOCKADDR)(lpAddressInfo + 1);
        lpAddressInfo->LocalAddr.iSockaddrLength = dwLocalLength;
        lpAddressInfo->RemoteAddr.lpSockaddr = (LPSOCKADDR)lpRemoteAddr;
        lpAddressInfo->RemoteAddr.iSockaddrLength = RemoteSockaddrLength();
        lpAddressInfo->iSocketType = SocketType();
        lpAddressInfo->iProtocol = Protocol();
        //
        // The port number field is in the same location in both a
        // sockaddr_in and a sockaddr_in6, so it is safe to cast the
        // sockaddr to sockaddr_in here - this works for IPv4 or IPv6.
        //
        INET_ASSERT(offsetof(SOCKADDR_IN, sin_port) ==
                    offsetof(SOCKADDR_IN6, sin6_port));

        ((LPSOCKADDR_IN)lpAddressInfo->RemoteAddr.lpSockaddr)->sin_port =
            _I_htons((unsigned short)nPort);
        *lpdwIndex = m_CurrentAddress;

        DEBUG_PRINT(SOCKETS,
                     INFO,
                   ("current address = %A\n",
                   RemoteSockaddr())
                   );
                  
//dprintf("returning address %d.%d.%d.%d, index %d:%d\n",
//        ((LPBYTE)RemoteSockaddr())[4] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[5] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[6] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[7] & 0xff,
//        m_ResolutionId,
//        m_CurrentAddress
//        );
    }
    *lpdwResolutionId = m_ResolutionId;

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("ResolutionId = %d, Index = %d\n",
                m_ResolutionId,
                m_CurrentAddress
                ));

    Release();

quit:
    PERF_LEAVE(GetNextAddress);

    DEBUG_LEAVE(bOk);

    return bOk;
}
	

VOID
CAddressList::InvalidateAddress(
    IN DWORD dwResolutionId,
    IN DWORD dwAddressIndex
    )

/*++

Routine Description:

    We failed to create a connection. Invalidate the address so other requests
    will try another address

Arguments:

    dwResolutionId  - used to ensure coherency of address list

    dwAddressIndex  - which address to invalidate

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "CAddressList::InvalidateAddress",
                 "%d, %d\n",
                 dwResolutionId,
                 dwAddressIndex
                 ));
//dprintf("invalidating %d.%d.%d.%d, index %d:%d\n",
//        ((LPBYTE)RemoteSockaddr())[4] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[5] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[6] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[7] & 0xff,
//        dwResolutionId,
//        dwAddressIndex
//        );
    if (!Acquire())
        goto quit;  // just take the hit of trying again, if we can.

    //
    // only do this if the list is the same age as when the caller last tried
    // an address
    //

    if (dwResolutionId == m_ResolutionId) {

        INET_ASSERT(((INT)dwAddressIndex >= 0)
                    && ((INT)dwAddressIndex < m_AddressCount));

        if (dwAddressIndex < (DWORD)m_AddressCount) {
            m_Addresses[dwAddressIndex].IsValid = FALSE;

        DEBUG_PRINT(SOCKETS,
                    INFO,
                   ("invalidated address %A\n",
                   RemoteSockaddr()));

            INET_ASSERT(m_BadAddressCount <= m_AddressCount);

            if (m_BadAddressCount < m_AddressCount) {
                ++m_BadAddressCount;
                if (m_BadAddressCount < m_AddressCount) {
                    for (int i = 0;
                         !IsCurrentAddressValid() && (i < m_AddressCount);
                         ++i) {
                        NextAddress();
                    }
                }
            }
        }
    }
    Release();

quit:

    DEBUG_LEAVE(0);
}


DWORD
CAddressList::ResolveHost(
    IN LPSTR lpszHostName,
    IN OUT LPDWORD lpdwResolutionId,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Resolves host name (or (IP-)address)

    BUGBUG: Ideally, we don't want to keep hold of worker threads if we are in
            the blocking gethostbyname() call. But correctly handling this is
            difficult, so we always block the thread while we are resolving.
            For this reason, an async request being run on an app thread should
            have switched to a worker thread before calling this function.

Arguments:

    lpszHostName        - host name (or IP-address) to resolve

    lpdwResolutionId    - used to determine whether entry changed

    dwFlags             - controlling request:

                            SF_INDICATE - if set, make indications via callback

                            SF_FORCE    - if set, force (re-)resolve

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Name successfully resolved

        Failure - ERROR_WINHTTP_NAME_NOT_RESOLVED
                    Couldn't resolve the name

                  ERROR_NOT_ENOUGH_MEMORY
                    Couldn't allocate memory for the FSM
--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CAddressList::ResolveHost",
                 "%q, %d, %#x",
                 lpszHostName,
                 *lpdwResolutionId,
                 dwFlags
                 ));

    DWORD error;

    error = DoFsm(New CFsm_ResolveHost(lpszHostName,
                                       lpdwResolutionId,
                                       dwFlags,
                                       this
                                       ));

//quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_ResolveHost::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CFsm_ResolveHost::RunSM",
                 "%#x",
                 Fsm
                 ));

    CAddressList * pAddressList = (CAddressList *)Fsm->GetContext();
    CFsm_ResolveHost * stateMachine = (CFsm_ResolveHost *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
        error = pAddressList->ResolveHost_Fsm(stateMachine);
        break;

    case FSM_STATE_CONTINUE:
        error = pAddressList->ResolveHost_Continue(stateMachine);
        break;
        
    case FSM_STATE_ERROR:
        error = Fsm->GetError();
        Fsm->SetDone();
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CAddressList::ResolveHost_Continue(
    IN CFsm_ResolveHost * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CAddressList::ResolveHost_Continue",
                 "%#x(%q, %#x [%d], %#x)",
                 Fsm,
                 Fsm->m_lpszHostName,
                 Fsm->m_lpdwResolutionId,
                 *Fsm->m_lpdwResolutionId,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(ResolveHost);

    //
    // restore variables from FSM object
    //

    CFsm_ResolveHost & fsm = *Fsm;
    LPSTR lpszHostName = fsm.m_lpszHostName;
    LPDWORD lpdwResolutionId = fsm.m_lpdwResolutionId;
    DWORD dwFlags = fsm.m_dwFlags;
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();
    INTERNET_HANDLE_BASE * pHandle = fsm.GetMappedHandleObject();
    DWORD error = ERROR_SUCCESS;
    CResolverCache* pResolverCache = GetRootHandle(pHandle)->GetResolverCache();
    LPADDRINFO lpAddrInfo = NULL;
    DWORD ttl;

    UNREFERENCED_PARAMETER(lpThreadInfo); // avoid C4189 warning on free builds

    if (!Acquire())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // if the resolution id is different then the name has already been resolved
    //

    if (*lpdwResolutionId == m_ResolutionId) 
    {
        INET_ASSERT(lpThreadInfo->IsAsyncWorkerThread
                    || !pHandle->IsAsyncHandle());

        FreeList();
        
        //
        // now try to find the name or address in the cache. If it's not in the
        // cache then resolution failed
        //
        LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry;

        if (NULL != (lpResolverCacheEntry=QueryResolverCache(pResolverCache->GetResolverCacheList(), lpszHostName, NULL, &lpAddrInfo, &ttl)))
        {
            error = SetList(lpAddrInfo);
            ReleaseResolverCacheEntry(pResolverCache->GetResolverCacheList(), lpResolverCacheEntry);
            ++m_ResolutionId;
        }
        else
        {
            error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
        }

        if ((error == ERROR_SUCCESS) && (dwFlags & SF_INDICATE))
        {
            //
            // inform the app that we have resolved the name
            //

            InternetIndicateStatusAddress(WINHTTP_CALLBACK_STATUS_NAME_RESOLVED,
                                          RemoteSockaddr(),
                                          RemoteSockaddrLength()
                                          );
        }
        *lpdwResolutionId = m_ResolutionId;
    }
    
    Release();
    
exit:
    fsm.SetDone();

    PERF_LEAVE(ResolveHost);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CAddressList::ResolveHost_Fsm(
    IN CFsm_ResolveHost * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CAddressList::ResolveHost_Fsm",
                 "%#x(%q, %#x [%d], %#x)",
                 Fsm,
                 Fsm->m_lpszHostName,
                 Fsm->m_lpdwResolutionId,
                 *Fsm->m_lpdwResolutionId,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(ResolveHost);

    //
    // restore variables from FSM object
    //

    CFsm_ResolveHost & fsm = *Fsm;
    LPSTR lpszHostName = fsm.m_lpszHostName;
    LPDWORD lpdwResolutionId = fsm.m_lpdwResolutionId;
    DWORD dwFlags = fsm.m_dwFlags;
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();
    INTERNET_HANDLE_BASE * pHandle = fsm.GetMappedHandleObject();

    UNREFERENCED_PARAMETER(lpThreadInfo); // avoid C4189 warning on free builds

    INET_ASSERT (pHandle);
    
    DWORD error = ERROR_SUCCESS;
    INTERNET_HANDLE_OBJECT * pRoot = GetRootHandle(pHandle);

    INET_ASSERT (pRoot);
    
    CResolverCache* pResolverCache = pRoot->GetResolverCache();
    DWORD dwWaitTime;
    
    LPADDRINFO lpAddrInfo = NULL;
    ADDRINFO Hints;
    DWORD ttl;

    
    //
    // BUGBUG - RLF 04/23/97
    //
    // This is sub-optimal. We want to block worker FSMs and free up the worker
    // thread. Sync client threads can wait. However, since a clash is not very
    // likely, we'll block all threads for now and come up with a better
    // solution later (XTLock).
    //
    // Don't have time to implement the proper solution now
    //

    if (!Acquire())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // if the resolution id is different then the name has already been resolved
    //

    if (*lpdwResolutionId != m_ResolutionId) 
    {
        goto done;
    }

    //
    // if we're an app thread making an async request then go async now rather
    // than risk blocking the app thread. This will be the typical scenario for
    // IE, and we care about little else
    //
    // BUGBUG - RLF 05/20/97
    //
    // We should really lock & test the cache first, but let's do that after
    // Beta2 (its perf work)
    //

    // It cannot happen that this condition be true.
    // WinHttpSendRequest would have queued an async fsm if it was async to begin with.
    INET_ASSERT(lpThreadInfo->IsAsyncWorkerThread
                || !pHandle->IsAsyncHandle());
/*
    if (!lpThreadInfo->IsAsyncWorkerThread
        && pHandle->IsAsyncHandle()
        && (fsm.GetAppContext() != NULL)) 
    {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("async request on app thread - jumping to hyper-drive\n"
                    ));

        error = Fsm->QueueWorkItem();
        goto done;
    }
 */
    //
    // throw out current list (if any)
    //

    FreeList();

    //
    // let the app know we are resolving the name
    //

    if (dwFlags & SF_INDICATE) 
    {
        error = InternetIndicateStatusString(WINHTTP_CALLBACK_STATUS_RESOLVING_NAME,
                                        lpszHostName,
                                        TRUE/*bCopyBuffer*/
                                        );
                                        
        //bail out if aborted before network operation.
        if (error != ERROR_SUCCESS)
        {
            INET_ASSERT(error == ERROR_WINHTTP_OPERATION_CANCELLED);
            goto done;
        }
    }

    //
    // Figure out if we're being asked to resolve a name or an address literal.
    // If getaddrinfo with the AI_NUMERICHOST flag succeeds then we were
    // given a string representation of an IPv6 or IPv4 address.  Otherwise
    // we expect getaddrinfo to return EAI_NONAME.
    //

    memset(&Hints, 0, sizeof(struct addrinfo));
    Hints.ai_flags = AI_NUMERICHOST;  // Only check for address literals.
    Hints.ai_family = PF_UNSPEC;      // Accept any protocol family.
    Hints.ai_socktype = SOCK_STREAM;  // Constrain results to stream socket.
    Hints.ai_protocol = IPPROTO_TCP;  // Constrain results to TCP.

    error = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo);
    if (error != EAI_NONAME) {
        if (error != 0) {
            if (error == EAI_MEMORY)
                error = ERROR_NOT_ENOUGH_MEMORY;
            else
                error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
            goto quit;
        }

        // An IP address (either v4 or v6) was passed in.
        // Simply convert to address list representation and quit.
        //
        // NOTE: Previous versions of this code had a function here to
        // make sure the string didn't contain additional info that would
        // invalidate the string.  For example, "111.111.111.111 .msn.com"
        // would allow the navigation to succeed, but the cookies for
        // .msn.com would be retrievable, violating cross-domain security.
        // We no longer need this check because getaddrinfo is far pickier
        // than inetaddr was - getaddrinfo with the AI_NUMERICHOST flag set
        // will only accept a string that parses *exactly* as an IP address
        // literal.  No extra data is allowed.
        //

        error = SetList(lpAddrInfo);
        _I_freeaddrinfo(lpAddrInfo);
        goto quit;
    }
    else
    {
        INET_ASSERT (!lpAddrInfo);
    }

    //
    // 255.255.255.255 (or 65535.65535 or 16777215.255) would never work anyway
    //

    INET_ASSERT(lstrcmp(lpszHostName, "255.255.255.255"));

    //
    // now try to find the name or address in the cache. If it's not in the
    // cache then resolve it
    //

    LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry;

    if (!(dwFlags & SF_FORCE)
    && (NULL != (lpResolverCacheEntry=QueryResolverCache(pResolverCache->GetResolverCacheList(), lpszHostName, NULL, &lpAddrInfo, &ttl))))
    {
        error = SetList(lpAddrInfo);
        ReleaseResolverCacheEntry(pResolverCache->GetResolverCacheList(), lpResolverCacheEntry);
        ++m_ResolutionId;
        goto quit;
    }
    
    //
    // if we call winsock getaddrinfo() then we don't get to find out the
    // time-to-live as returned by DNS, so we have to use the default value
    // (LIVE_DEFAULT)
    //
    
    dwWaitTime = GetTimeoutValue(WINHTTP_OPTION_RESOLVE_TIMEOUT);

    // if a resolve timeout is specified by the application, then honor it.
    // If anything fails in the async pathway, DON'T default to sync GHBN.
    if (dwWaitTime != INFINITE)
    {
        if (pHandle->IsAsyncHandle())
        {
            LPSTR lpszCopyHostName = NewString(lpszHostName);

            if (lpszCopyHostName)
            {
                CGetHostItem* pGetHostItem = New CGetHostItem(lpszCopyHostName, pResolverCache, pRoot, (VOID *)Fsm, 0);

                if (!pGetHostItem)
                {
                    FREE_FIXED_MEMORY(lpszCopyHostName);
                    error = ERROR_NOT_ENOUGH_MEMORY;
                    goto quit;
                }
                fsm.SetState(FSM_STATE_CONTINUE);

                //additional reference for timeout queue
                Fsm->SetTimeout(dwWaitTime);
                Fsm->Reference();
                Fsm->SetPop(FALSE);
                pRoot->Reference();
                
                Release();
                
                if (Fsm->GetMappedHandleObject())
                {
                    Fsm->GetMappedHandleObject()->Reference();
                }

                error = QueueTimeoutFsm(Fsm, NULL, TRUE);

                if (error != ERROR_IO_PENDING)
                {
                    //didn't succeed queueing fsm to the timeout queue

                    //delete the pGetHostItem to cleanup resources and release the session reference
                    delete pGetHostItem;

                    if (Fsm->GetMappedHandleObject())
                    {
                        Fsm->GetMappedHandleObject()->Dereference();
                    }

                    //remove timeout reference
                    DWORD dwDummy;
                    Fsm->Dereference(&dwDummy);
                    goto exit;
                }

                {
                    HANDLE hThread = 0;
                    DWORD dwThreadId;

                    HMODULE hMod;
                    if (NULL != (hMod = LoadLibrary(VER_ORIGINALFILENAME_STR)))
                    {
                        pGetHostItem->SetModuleHandle(hMod);

                        // create a new thread for name resolution, it will run AsyncGetHostByNameWorker
                        WRAP_REVERT_USER(CreateThread, FALSE, (NULL, 0, &AsyncGetHostByNameWorker,
                                        pGetHostItem, 0, &dwThreadId), hThread);
                        if (!hThread)
                        {
                            FreeLibrary(hMod);
                        }
                    }

                    if (!hThread)
                    {
                        //didn't succeed queueing to resolver but fsm is in timeout queue

                        //delete the pGetHostItem to cleanup resources and release the session reference
                        delete pGetHostItem;

                        if (Fsm->TestAndSetScheduled())
                        {
                            //timeout thread got to it first, so fall out and wait for scheduling from there.
                            error = ERROR_IO_PENDING;
                        }
                        else
                        {
                            error = ERROR_NOT_ENOUGH_MEMORY;
                            //nothing more to do: get cleaned up on this thread with whatever error we have.
                        }

                        goto exit;
                    }
                    else
                    {
                        CloseHandle(hThread);
                        hThread = NULL;
                    }

                    // we've started the DNS resolve thread, so return IO-pending to app
                    error = ERROR_IO_PENDING;
                }

                //error = Fsm->QueueWorkItem(COMPLETION_BYTES_RESOLVER, pGetHostItem);

                //if (error != ERROR_IO_PENDING)
                //{
                //    //didn't succeed queueing to resolver but fsm is in timeout queue

                //    //delete the pGetHostItem to cleanup resources and release the session reference
                //    delete pGetHostItem;

                //    if (Fsm->TestAndSetScheduled())
                //    {
                //        //timeout thread got to it first, so fall out and wait for scheduling from there.
                //        error = ERROR_IO_PENDING;
                //    }
                //    else
                //    {
                //        //nothing more to do: get cleaned up on this thread with whatever error we have.
                //        INET_ASSERT (error != ERROR_SUCCESS);
                //    }
                //}
                goto exit;
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
        }
        
        DWORD dwThreadId;
        LPSTR lpszCopyHostName = NewString(lpszHostName);
        
        if (lpszCopyHostName)
        {
#define SZ_AVG_RESOLVER_ENTRY_BYTES 512
            VOID* pAlloc = ALLOCATE_MEMORY(SZ_AVG_RESOLVER_ENTRY_BYTES);
            CGetHostItem* pGetHostItem = New CGetHostItem(lpszCopyHostName, pResolverCache, NULL, pAlloc, pAlloc?SZ_AVG_RESOLVER_ENTRY_BYTES:0);

            if (!pGetHostItem)
            {
                FREE_FIXED_MEMORY(lpszCopyHostName);
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
            
            HANDLE hThread = 0;

            WRAP_REVERT_USER(CreateThread, FALSE, (NULL, 0, &AsyncGetHostByName,
                            pGetHostItem, 0, &dwThreadId), hThread);

            // HANDLE hThread = CreateThread(NULL, 0, &AsyncGetHostByName,
            //                  pGetHostItem, 0, &dwThreadId);

            if (!hThread)
            {
                delete pGetHostItem;
                goto failed;
            }
            
            DWORD dwWaitResponse = WaitForSingleObject(hThread, dwWaitTime);

            if (dwWaitResponse == WAIT_OBJECT_0)
            {
                DWORD dwError;
                BOOL fRet = GetExitCodeThread(hThread, &dwError); //want to use this error?

                INET_ASSERT(dwError != STILL_ACTIVE);

                LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry2;
                if (fRet && !dwError
                    && (NULL != (lpResolverCacheEntry2 = QueryResolverCache(pResolverCache->GetResolverCacheList(), lpszCopyHostName, NULL, &lpAddrInfo, &ttl))))
                {
                    error = SetList(lpAddrInfo);
                    ReleaseResolverCacheEntry(pResolverCache->GetResolverCacheList(), lpResolverCacheEntry2);
                    ++m_ResolutionId;
                }

                CloseHandle(hThread);
                delete pGetHostItem;

                DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("%q %sresolved\n",
                    lpszHostName,
                    error ? "NOT " : ""
                    ));

                TRACE_PRINT_API(SOCKETS,
                    INFO,
                    ("%q %sresolved\n",
                    lpszHostName,
                    error ? "NOT " : ""
                    ));
            }
            else //(dwWaitResponse == WAIT_TIMEOUT)
            {
                //let thread die and if it successfully resolved host, it can add to cache.
                pResolverCache->AddToHandlesList(hThread, pGetHostItem);

                if (dwWaitResponse == WAIT_TIMEOUT)
                    error = ERROR_WINHTTP_TIMEOUT;
                else
                    error = ERROR_WINHTTP_NAME_NOT_RESOLVED;

                goto quit;
            }
        } //lpszCopyHostName
    }// dwWaitTime (specified on this handle)
    else
    {
        //synchronous getaddrinfo
        Hints.ai_flags = AI_CANONNAME;  // No special treatment this time.
        error = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo);

        DEBUG_PRINT(SOCKETS,
            INFO,
            ("%q %sresolved\n",
            lpszHostName,
            error ? "NOT " : ""
            ));

        TRACE_PRINT_API(SOCKETS,
            INFO,
            ("%q %sresolved\n",
            lpszHostName,
            error ? "NOT " : ""
            ));

        if (error == 0) 
        {
            error = SetList(lpAddrInfo);
            AddResolverCacheEntry(pResolverCache->GetResolverCacheList(), lpszHostName, lpAddrInfo, LIVE_DEFAULT);
            ++m_ResolutionId;
        }
        else 
        {
            INET_ASSERT (!lpAddrInfo);

            if (error == EAI_MEMORY)
                error = ERROR_NOT_ENOUGH_MEMORY;
            else
                error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
        }

    }
    
failed:

    if (!lpAddrInfo)
    {
        error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
    }

quit:

    if ((error == ERROR_SUCCESS) && (dwFlags & SF_INDICATE)) {

        //
        // inform the app that we have resolved the name
        //

        InternetIndicateStatusAddress(WINHTTP_CALLBACK_STATUS_NAME_RESOLVED,
                                      RemoteSockaddr(),
                                      RemoteSockaddrLength()
                                      );
    }
    *lpdwResolutionId = m_ResolutionId;

done:

    Release();

exit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
        //PERF_LEAVE(ResolveHost);
    }

    PERF_LEAVE(ResolveHost);

    DEBUG_LEAVE(error);

    return error;
}

//
// private methods
//


PRIVATE
DWORD
CAddressList::AddrInfoToAddressList(
    IN struct addrinfo FAR *lpAddrInfo
    )

/*++

Routine Description:

    Converts an addrinfo structure(s) to an array of RESOLVED_ADDRESSes.

Arguments:

    lpAddrInfo  - pointer to AddrInfo chain to convert.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    INET_ASSERT(lpAddrInfo != NULL);

    struct addrinfo *lpCurrentInfo = lpAddrInfo;

    //
    // First off, figure out how many addrinfo structs are on the chain.
    // And how much memory we'll need to hold them as RESOLVED_ADDRESSes.
    // Note we also need space to hold the actual local and remote sockaddrs,
    // the RESOLVED_ADDRESS struct only contains the pointers to them.
    //

    int SpaceNeeded = 0;
    int nAddrs = 0;

    for (; lpCurrentInfo != NULL; lpCurrentInfo = lpCurrentInfo->ai_next) {

        if ((lpCurrentInfo->ai_family != PF_INET) &&
            (lpCurrentInfo->ai_family != PF_INET6)) {

            //
            // Ignore any non-internet addrsses.
            // We won't get any with the current getaddrinfo,
            // but maybe someday.
            //
            continue;
        }

        SpaceNeeded += sizeof(RESOLVED_ADDRESS) + 
            2 * lpCurrentInfo->ai_addrlen;

        nAddrs++;

        if (fDontUseDNSLoadBalancing)
            break;  // Leave after one.
    }

    //
    // Allocate enough memory to hold these as RESOLVED_ADDRESSes.
    //
    LPRESOLVED_ADDRESS addresses = (LPRESOLVED_ADDRESS)
        ALLOCATE_FIXED_MEMORY(SpaceNeeded);
    if (addresses == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // For each IP address in the chain, build a RESOLVED_ADDRESS structure:
    // create a local SOCKADDR containing only the address family,
    // everything else is zeroed; create a remote SOCKADDR containing all
    // the values from the addrinfo structure.
    //

    LPBYTE lpVariable = (LPBYTE)addresses + (nAddrs * sizeof(RESOLVED_ADDRESS));

    lpCurrentInfo = lpAddrInfo;
    for (int i = 0; i < nAddrs; lpCurrentInfo = lpCurrentInfo->ai_next) {

        if ((lpCurrentInfo->ai_family != PF_INET) &&
            (lpCurrentInfo->ai_family != PF_INET6)) {

            //
            // Ignore any non-internet addrsses.
            // We won't get any with the current getaddrinfo,
            // but maybe someday.
            //
            continue;
        }

        addresses[i].AddrInfo.LocalAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
        addresses[i].AddrInfo.LocalAddr.iSockaddrLength =
            lpCurrentInfo->ai_addrlen;
        memset(lpVariable, 0, lpCurrentInfo->ai_addrlen);
        addresses[i].AddrInfo.LocalAddr.lpSockaddr->sa_family = 
            (unsigned short)lpCurrentInfo->ai_family;

        lpVariable += lpCurrentInfo->ai_addrlen;

        addresses[i].AddrInfo.RemoteAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
        addresses[i].AddrInfo.RemoteAddr.iSockaddrLength =
            lpCurrentInfo->ai_addrlen;
        memcpy(lpVariable, lpCurrentInfo->ai_addr, lpCurrentInfo->ai_addrlen);

        lpVariable += lpCurrentInfo->ai_addrlen;

        addresses[i].AddrInfo.iSocketType = lpCurrentInfo->ai_socktype;
        addresses[i].AddrInfo.iProtocol = lpCurrentInfo->ai_protocol;
        addresses[i].IsValid = TRUE;

        i++;
    }

    //
    // update the object
    //

    INET_ASSERT(m_AddressCount == 0);
    INET_ASSERT(m_Addresses == NULL);

    m_AddressCount = nAddrs;
    m_BadAddressCount = 0;
    m_Addresses = addresses;
    m_CurrentAddress = 0;
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\handle.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    handle.cxx

Abstract:

    Contains functions to allocate and deallocate handle values

    Contents:
        HandleInitialize
        HandleTerminate
        AllocateHandle
        FreeHandle
        MapHandleToAddress
        DereferenceObject

Author:

    Richard L Firth (rfirth) 31-Oct-1994

Revision History:

    12-Mar-2001 rajeevd
        Gutted

    11-Jan-1996 rfirth
        Use fixed memory instead of moveable (Win95 has a bug w/ LocalUnlock)

    31-Oct-1994 rfirth
        Created
--*/

#include <wininetp.h>


//
// private prototypes
//

DEBUG_ONLY (PRIVATE void LogHandleClassSizes(); )

//
// functions
//

DWORD HandleInitialize (VOID)
{
    DEBUG_ONLY (LogHandleClassSizes(); )
    return ERROR_SUCCESS;
}


VOID HandleTerminate(VOID)
{
    // nothing to do
}


DWORD AllocateHandle (IN LPVOID Address,OUT LPHINTERNET lpHandle)
{
    HINTERNET Handle = (HINTERNET) Address;
    *lpHandle = Handle;
    return ERROR_SUCCESS;
}


DWORD FreeHandle(IN HINTERNET Handle)
{
    UNREFERENCED_PARAMETER(Handle);    
    return ERROR_SUCCESS;
}


DWORD
MapHandleToAddress(
    IN HINTERNET Handle,
    OUT LPVOID * lpAddress,
    IN BOOL Invalidate
    )

/*++

Routine Description:

    The handle object represented by Handle is referenced

    Assumes:    1. only HINTERNETs visible at the API are presented to this
                   function.
                   
Arguments:

    Handle      - handle value generated by AllocateHandle()

    lpAddress   - place to store mapped address. If the handle has been closed
                  and unmapped, NULL is returned. If the handle is still
                  mapped, even though it has been invalidated, its address will
                  be returned, and its reference count incremented

    Invalidate  - TRUE if we are invalidating this handle

Return Value:

    LPVOID
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    if *lpAddress == NULL then the handle has been closed and
                    unmapped, else it is still mapped, but invalidated. In
                    this case, we incremented the reference count

--*/

{
    DEBUG_ENTER((DBG_HANDLE,
                Dword,
                "MapHandleToAddress",
                "%#x, %#x, %B",
                Handle,
                lpAddress,
                Invalidate
                ));

    DWORD error;

    // Cast the handle to an address and validate
    LPVOID address = (LPVOID) Handle;
    if (address)
    {
        error = ((HANDLE_OBJECT *)address)->IsValid(TypeWildHandle);
    }
    else
    {
        error = ERROR_INVALID_HANDLE;
    }
    
    if (error != ERROR_SUCCESS)
    {
        DEBUG_PRINT(HANDLE,
                    ERROR,
                    ("invalid handle object: %#x [%#x]\n",
                    Handle,
                    address
                    ));
        error = ERROR_INVALID_HANDLE;
        address = NULL;
        goto quit;
    }

    // Attempt to increment the reference count on the handle.
    
    error = ((HANDLE_OBJECT *)address)->Reference();
    DEBUG_PRINT(HANDLE, ERROR, ("Reference() returns %d\n", error));
    switch (error)
    {
        case ERROR_SUCCESS: // handle was refcounted but is not tombstoned

            if (Invalidate)
            {
                // we were called from a handle close API.
                // Subsequent API calls will discover that the
                // handle is already invalidated and will quit
                ((HANDLE_OBJECT *)address)->Invalidate();
            }
            break;

        case ERROR_INVALID_HANDLE: // handle was refcounted but was tombstoned.
        
            break;

        default:
            INET_ASSERT (false);

        // intentional fall through
            
        case ERROR_ACCESS_DENIED: // handle is being destroyed
            
            DEBUG_PRINT(HANDLE,
                        ERROR,
                        ("Reference() failed - handle %#x [%#x] about to be deleted\n",
                        Handle,
                        address
                        ));
                        
            error = ERROR_INVALID_HANDLE;
            address = NULL;
            break;
    }

 quit:
    *lpAddress = address;
    DEBUG_LEAVE(error);
    return error;
}


DWORD
DereferenceObject(
    IN LPVOID lpObject
    )

/*++

Routine Description:

    Undoes the reference added to the handle object by MapHandleToAddress(). May
    result in the handle object being deleted

Arguments:

    lpObject    - address of object to dereference. This MUST be the mapped
                  object address as returned by MapHandleToAddress()

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    The handle object was destroyed

        Failure - ERROR_INVALID_HANDLE
                    The object was not a valid handle

--*/

{
    DEBUG_ENTER((DBG_HANDLE,
                Dword,
                "DereferenceObject",
                "%#x",
                lpObject
                ));

    INET_ASSERT(lpObject != NULL);

    HANDLE_OBJECT * object = (HANDLE_OBJECT *)lpObject;
    DWORD error = object->IsValid(TypeWildHandle);

    // Serialize with MapHandleToAddress
    
    if (error == ERROR_SUCCESS)
    {
        object->Dereference();
    }
    else
    {
        //
        // IsValid() should never return an error if the reference counts
        // are correct
        //
        INET_ASSERT(FALSE);
    }

    DEBUG_LEAVE(error);

    return error;
}


#if INET_DEBUG
PRIVATE
void
LogHandleClassSizes()
{
    DEBUG_PRINT(HANDLE,
                INFO,
                ("sizeof(HANDLE_OBJECT)                  = %d bytes\n",
                 sizeof(HANDLE_OBJECT)
                ));
    DEBUG_PRINT(HANDLE,
                INFO,
                ("sizeof(INTERNET_HANDLE_OBJECT)         = %d bytes\n",
                 sizeof(INTERNET_HANDLE_OBJECT)
                ));
    DEBUG_PRINT(HANDLE,
                INFO,
                ("sizeof(INTERNET_CONNECT_HANDLE_OBJECT) = %d bytes\n",
                 sizeof(INTERNET_CONNECT_HANDLE_OBJECT)
                ));
    DEBUG_PRINT(HANDLE,
                INFO,
                ("sizeof(HTTP_REQUEST_HANDLE_OBJECT)     = %d bytes\n",
                 sizeof(HTTP_REQUEST_HANDLE_OBJECT)
                ));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\icasync.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    icasync.cxx

Abstract:

    Contains async socket (select) thread and support functions. Work items now
    processed by SHLWAPI/KERNEL32 thread pool

    Contents:
        InitializeAsyncSupport
        TerminateAsyncSupport
        QueueSocketWorkItem
        BlockWorkItem
        UnblockWorkItems
        CheckForBlockedWorkItems
        ICAsyncThread::~ICAsyncThread
        ICAsyncThread::QueueSocketWorkItem
        ICAsyncThread::BlockWorkItem
        ICAsyncThread::UnblockWorkItems
        ICAsyncThread::CheckForBlockedWorkItems
        ICAsyncThread::SelectThreadWrapper
        ICAsyncThread::SelectThread
        (ICAsyncThread::CreateSelectSocket)
        (ICAsyncThread::DestroySelectSocket)
        (ICAsyncThread::RecreateSelectSocket)
        (ICAsyncThread::InterruptSelect)
        (ICAsyncThread::DrainSelectSocket)

Author:

    Richard L Firth (rfirth) 04-Mar-1998

Environment:

    Win32 user-mode

Revision History:

    04-Mar-1998 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

#if defined (INCLUDE_CACHE)
#include "..\urlcache\cache.hxx"
#include "..\httpcache\cachelogic.hxx"
#endif

DWORD AsyncGetHostByNameWorker(LPVOID pGetHostItem);
DWORD AsyncGetHostByNameCleanup(LPVOID pGetHostItem);

struct LIST_ELEMENT
{
    LIST_ENTRY m_ListEntry;
    CFsm* m_pFsm;
    LONG m_lCookie;
    BOOL m_fTimeoutWraps;
    DWORD m_dwTimeout;

    PLIST_ENTRY List(VOID)
    {
        return &m_ListEntry;
    }

    LIST_ELEMENT(CFsm* pFsm, LONG lCookie, BOOL fTimeoutWraps, DWORD dwTimeout)
    {
        m_pFsm = pFsm;
        m_lCookie = lCookie;
        m_fTimeoutWraps = fTimeoutWraps;
        m_dwTimeout = dwTimeout;
        m_ListEntry.Flink = NULL;
        m_ListEntry.Blink = NULL;
    }
    
    BOOL IsTimedOut(DWORD dwTime) 
    {
        if (m_fTimeoutWraps)
        {
            m_fTimeoutWraps = ((LONG)dwTime < 0);
        }
        return ((m_dwTimeout == INFINITE) || m_fTimeoutWraps)
            ? FALSE
            : (dwTime > m_dwTimeout);
    }
};

typedef LIST_ELEMENT* PLIST_ELEMENT;

PLIST_ELEMENT
ContainingListElement(
    IN LPVOID lpAddress
    )
{
    return CONTAINING_RECORD(lpAddress, LIST_ELEMENT, m_ListEntry);
}

DWORD CAsyncCount::AddRef()
{
    DWORD error = ERROR_SUCCESS;
    
    if (!GeneralInitCritSec.Lock())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    InterlockedIncrement(&lRef);
    DEBUG_PRINT(ASYNC, INFO, ("CAsyncCount::AddRef(): dwRef = %d\n", lRef));

    GeneralInitCritSec.Unlock();
quit:
    return error;       
}

VOID CAsyncCount::Release()
{
    BOOL bUnlock = GeneralInitCritSec.Lock();

    //Decrement the refcount always, but only Terminate if we obtained the critsec.
    if (!InterlockedDecrement(&lRef) && bUnlock)
    {
        DEBUG_PRINT(ASYNC, INFO, ("CAsyncCount::Release(): lRef = %d\n", lRef));
        TerminateAsyncSupport(TRUE);
    }
    else
    {
        DEBUG_PRINT(ASYNC, INFO, ("CAsyncCount::Release(): lRef = %d\n", lRef));
    }

    if (bUnlock)
    {
        GeneralInitCritSec.Unlock();
    }
}

BOOL CAsyncCount::Purge(BOOL bFinal)
{
    BOOL bRet = TRUE;
    PLIST_ENTRY pEntry;
    PLIST_ENTRY pPrev;

    pPrev = &List;
    
    for (pEntry = List.Flink;
         pEntry != &List;
         pEntry = pPrev->Flink) 
    {
        INFO_THREAD* pInfoThread = ContainingInfoThread((LPVOID)pEntry);

        if ((WaitForSingleObject(pInfoThread->m_hThread, 0) == WAIT_OBJECT_0)
            || bFinal) 
        {
            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("Done with THREAD %#x %#x\n",
                        pInfoThread->m_hThread,
                        pInfoThread->m_dwThreadId
                        ));

            RemoveEntryList(&pInfoThread->m_ListEntry);

            CloseHandle(pInfoThread->m_hThread);

            delete pInfoThread;

            continue;
        }

        bRet = FALSE;
        pPrev = pEntry;
    }

    return bRet;
}
    
//
// private classes
//


class ICAsyncThread {

private:

    CPriorityList m_BlockedQueue;
    //overloading the critical section on this to use for termination.
    CPriorityList m_ResolveTimeoutQueue;
    CPriorityList m_SendRecvQueue;
    
    SOCKET m_SelectSocket;
    CCritSec m_SocketCritSec;
    
    LONG m_lSelectInterrupts;
    BOOL m_bTerminating;
    DWORD m_dwError;
    HANDLE m_hThread;
    BOOL m_bCleanUp;
    HMODULE m_hMod;

    struct fd_set read_fds;
    struct fd_set write_fds;
    struct fd_set except_fds;

public:

    ICAsyncThread(HMODULE hMod) {

        DEBUG_ENTER((DBG_ASYNC,
                     None,
                     "ICAsyncThread::ICAsyncThread",
                     NULL
                     ));

        m_hMod = hMod;
        m_SelectSocket = INVALID_SOCKET;
        m_lSelectInterrupts = -1;
        m_bTerminating = FALSE;
        m_dwError = ERROR_SUCCESS;
        m_hThread = NULL;

        memset(&read_fds, 0, sizeof(read_fds));
        memset(&write_fds, 0, sizeof(write_fds));
        memset(&except_fds, 0, sizeof(except_fds));

        if (m_SocketCritSec.Init() == FALSE)
        {
            m_dwError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            m_dwError = CreateSelectSocket();
        }

        if (m_dwError == ERROR_SUCCESS) {
        
            DWORD dwThreadId;
            m_hThread = CreateThread(
                        NULL,
                        0,
                        (LPTHREAD_START_ROUTINE)ICAsyncThread::SelectThreadWrapper,
                        (LPVOID)this,
                        0,
                        &dwThreadId
                        );
        }
        
        if (m_hThread == NULL) {
            if (m_dwError == ERROR_SUCCESS) {
                SetError();
            }
            FreeLibrary(m_hMod);
            m_hMod = NULL;
        }

        m_bCleanUp = FALSE;
        DEBUG_LEAVE(0);
    }

    ~ICAsyncThread();

    HMODULE
    GetHMod()
    {
        return m_hMod;
    }

    VOID
    PrepareForTermination();
    
    VOID SetCleanUp()
    {
        m_bCleanUp = TRUE;
    }
    
    DWORD GetError(VOID) const {
        return m_dwError;
    }

    VOID SetError(DWORD dwError = GetLastError()) {
        m_dwError = dwError;
    }

    BOOL IsTerminating(VOID) const {
        return m_bTerminating;
    }

    VOID SetTerminating(VOID) {
        m_bTerminating = TRUE;
    }

    DWORD
    QueueSocketWorkItem(
        IN CFsm * pFsm
        );

    DWORD
    QueueTimeoutFsm(
        IN CFsm * pFsm,
        IN SOCKET Socket,
        IN BOOL bResolveTimeoutQueue
        );

    DWORD
    BlockWorkItem(
        IN CFsm * WorkItem,
        IN DWORD_PTR dwBlockId,
        IN DWORD dwTimeout = TP_NO_TIMEOUT
        );

    DWORD
    UnblockWorkItems(
        IN DWORD dwCount,
        IN DWORD_PTR dwBlockId,
        IN DWORD dwError,
        IN LONG lPriority = TP_NO_PRIORITY_CHANGE
        );

    DWORD
    CheckForBlockedWorkItems(
        IN DWORD dwCount,
        IN DWORD_PTR dwBlockId
        );

    static
    DWORD
    SelectThreadWrapper(
        IN ICAsyncThread * pThread
        );

    DWORD
    SelectThread(
        VOID
        );

    DWORD
    ProcessResolveTimeouts(
        DWORD* pTimeout
        );

    DWORD
    ProcessSendRecvTimeouts(
        DWORD* pTimeout
        );

    DWORD
    CreateSelectSocket(
        VOID
        );

    PRIVATE
    VOID
    DestroySelectSocket(
        VOID
        );

    VOID
    RecreateSelectSocket(
        VOID
        );

    VOID
    InterruptSelect(
        VOID
        );

    BOOL
    DrainSelectSocket(
        VOID
        );
};

//
// private data
//

PRIVATE ICAsyncThread * p_AsyncThread = NULL;
PRIVATE INFO_THREAD** p_ThreadArray = NULL;
PRIVATE int p_iNumIOCPThreads = 0;



//
// functions
//


DWORD
IOCompletionThreadFunc(
    IN ULONG_PTR pContext
    )
{
    LPOVERLAPPED lpOverlapped;
    DWORD dwBytes;
    ULONG_PTR lpCompletionKey;
    DWORD dwError = 0;
    BOOL bDeleteOverlapped = FALSE;
    LPINTERNET_THREAD_INFO lpThreadInfo;

    BOOL fExitThread = FALSE;
    HMODULE hMod = (HMODULE)pContext;

    INTERNET_THREAD_INFO LocalThreadInfoOnStack;

    lpThreadInfo = InternetGetThreadInfo();

    // 629872: if allocation of the thread info object failed, then
    //         use a threadinfo object preallocated on our stack.
    if (!lpThreadInfo)
    {
        lpThreadInfo = InternetCreateThreadInfo(TRUE, &LocalThreadInfoOnStack);
        INET_ASSERT(lpThreadInfo->fStaticAllocation);
    }

    while (TRUE)
    {
                         
        BOOL bRet = GetQueuedCompletionStatus(g_hCompletionPort,
                                            &dwBytes,
                                            &lpCompletionKey,
                                            &lpOverlapped,
                                            INFINITE);

        DEBUG_ENTER((DBG_API,
                         Dword,
                         "***GetQueuedCompletionStatus",
                         "(hcomp)%#x, (dwBytes)%#x, (completionkey)%#x, (overlapped)%#x",
                         g_hCompletionPort,
                         dwBytes,
                         lpCompletionKey,
                         lpOverlapped
                         ));

        if (!bRet && !lpOverlapped)
        {
            DEBUG_LEAVE(NULL);
            
            // other errors currently not possible since we only have custom completion packets.
            INET_ASSERT (FALSE);

            continue;
        }

        ICSocket* pObject;
        CFsm* pFsm = NULL;
        CWrapOverlapped* lpWrapOverlapped = NULL;

#if defined (INCLUDE_CACHE)
        BOOL fCacheRequest = FALSE;
        if(lpOverlapped == g_lpCustomUserOverlapped)
        {
            DEBUG_LEAVE(lpCompletionKey);

#if INET_DEBUG
            InterlockedDecrement(&g_cCustomUserCompletions);
            DEBUG_PRINT(CACHE, INFO, ("!!!!!!!!!!!---g_cCustomUserCompletions=%d\n", g_cCustomUserCompletions));
#endif

            LPWINHTTP_USER_WORK_ITEM lpWorkItem = (LPWINHTTP_USER_WORK_ITEM) lpCompletionKey;
            if(lpWorkItem)
            {
                if(lpWorkItem->lpStartAddress)
                {
                    lpWorkItem->lpStartAddress(lpWorkItem->lpParameter);
                }
                FREE_MEMORY(lpWorkItem);
            }

            bDeleteOverlapped = FALSE;
        }
        else
#endif
        if(lpOverlapped == g_lpCustomOverlapped)
        {
            DEBUG_LEAVE(lpCompletionKey);
            INET_ASSERT( (dwBytes == COMPLETION_BYTES_CUSTOM)
                        || (dwBytes == COMPLETION_BYTES_EXITIOCP)
                        || (dwBytes == COMPLETION_BYTES_RESOLVER));
            
#if INET_DEBUG
            InterlockedDecrement(&g_cCustomCompletions);
    
            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("!!!g_cCustomCompletions = 0x%x\n",
                        g_cCustomCompletions
                        ));
#endif

            if (dwBytes == COMPLETION_BYTES_EXITIOCP)
            {
                INET_ASSERT (lpCompletionKey == NULL);
                break;
            }   
            else if (dwBytes == COMPLETION_BYTES_RESOLVER)
            {
                if (!lpThreadInfo)
                {
                    lpThreadInfo = InternetGetThreadInfo();
                }

                if (lpThreadInfo)
                {
                    lpThreadInfo->IsAsyncWorkerThread = TRUE;
                }
                if (!fExitThread)
                    AsyncGetHostByNameWorker((LPVOID)lpCompletionKey);
                else
                    AsyncGetHostByNameCleanup((LPVOID)lpCompletionKey);

                if (lpThreadInfo)
                {
                    lpThreadInfo->IsAsyncWorkerThread = FALSE;
                }
                continue;
            }
            else
            {
                bDeleteOverlapped = FALSE;
                pFsm = (CFsm*) lpCompletionKey;
            }
        }

#if defined (INCLUDE_CACHE)
        else if(HTTPCACHE_REQUEST::IsValidObject((HTTPCACHE_REQUEST*) lpCompletionKey))
        {
            DEBUG_LEAVE(lpCompletionKey);
            INET_ASSERT(lpCompletionKey);
            fCacheRequest = TRUE;

#if INET_DEBUG
            InterlockedDecrement(&g_cCacheFileCompletions);
            DEBUG_PRINT(CACHE, INFO, ("!!!!!!!!!!!---g_cCacheFileCompletions=%d\n", g_cCacheFileCompletions));
#endif

            HTTPCACHE_REQUEST::FileIoCompletionFunction((HTTPCACHE_REQUEST*) lpCompletionKey, dwBytes);

            bDeleteOverlapped = FALSE;
        }
#endif

        else
        {
            pObject = (ICSocket *) lpCompletionKey;
            pFsm = pObject->GetAndSetCurrentFsm(NULL);
            DEBUG_LEAVE(pFsm);
            
#if INET_DEBUG
            InterlockedDecrement(&g_cWSACompletions);
#endif

            INET_ASSERT(pFsm
                        && ((pFsm->GetType() == FSM_TYPE_SOCKET_SEND)
                            || (pFsm->GetType() == FSM_TYPE_SOCKET_RECEIVE)));

            CFsm_SocketIOCP* pFsm_SocketIOCP = (CFsm_SocketIOCP *)pFsm;
            bDeleteOverlapped = TRUE;
            lpWrapOverlapped = GetWrapOverlappedObject(lpOverlapped);

            if (pFsm_SocketIOCP->HasTimeout())
            {

                if (!pFsm_SocketIOCP->TestAndSetValidForIOCPProcessing())
                {
                    //failure! the select thread already enforced timeout and updated state
                    goto runworkitem;
                }
            }
            
            pFsm_SocketIOCP->dwBytesTransferred = dwBytes;
            pFsm_SocketIOCP->bIOCPSuccess = bRet;
            
            pFsm_SocketIOCP->ResetSocket();
            pFsm_SocketIOCP->SetPriority(TP_NO_PRIORITY_CHANGE);
            
            if (bRet)
            {
                pFsm_SocketIOCP->SetError(ERROR_SUCCESS);
                pFsm_SocketIOCP->SetState(pFsm_SocketIOCP->GetNextState());
            }
            else
            {
                //DWORD dwErrorDebug = GetLastError();
                ////informational INET_ASSERT (FALSE && "IoCompletionError");
                
                pFsm_SocketIOCP->dwIOCPError = GetLastError();

                if (pFsm_SocketIOCP->dwIOCPError == WSA_OPERATION_ABORTED)
                    pFsm_SocketIOCP->SetErrorState(ERROR_WINHTTP_OPERATION_CANCELLED);
                else
                    pFsm_SocketIOCP->SetErrorState(ERROR_WINHTTP_CONNECTION_ERROR);
            }
        }

runworkitem:
        if (pFsm)
        {
            dwError = CFsm::RunWorkItem(pFsm);
        }
        else
        {
#if defined (INCLUDE_CACHE)
            INET_ASSERT(pFsm ||(lpOverlapped == g_lpCustomUserOverlapped) || fCacheRequest);
#else
            INET_ASSERT(pFsm);
#endif
        }

        if (!lpThreadInfo)
        {
            lpThreadInfo = InternetGetThreadInfo();
        }

        if (lpThreadInfo && lpThreadInfo->fExitThread)
        {
            //exit this thread after dequeuing as many available completions as possible.
            fExitThread = TRUE;
        }

        if (bDeleteOverlapped)
        {
            lpWrapOverlapped->Dereference();
        }

        if (fExitThread)
        {
            break;
        }
    }

    //
    // If the local stack threadinfo object is in use,
    // then clear out the pointer from TLS here. So when this thread
    // detaches, the InternetDestroyThreadInfo called
    // from DLLMain(DLL_THREAD_DETACH) will have no effect--it will
    // not find a threadinfo object in TLS on this thread.
    //
    if (lpThreadInfo == &LocalThreadInfoOnStack)
    {
        InternetSetThreadInfo(NULL);
    }

    if (hMod)
    {
        FreeLibraryAndExitThread(hMod, dwError);
    }

    return dwError;
}

/*
 * called from InitalizeAsyncSupport and synchronized there using GeneralInitCritSec
 *  ditto for Terminate**
 *
 * cleanup here unless you move cleaning to TerminateIOCPSupport.
 */

typedef INFO_THREAD* LPINFO_THREAD;


DWORD
InitializeIOCPSupport(
    VOID
    )
{
    int dwNumIOCPThreads = g_cNumIOCPThreads;

    if (!dwNumIOCPThreads)
    {
        SYSTEM_INFO sSysInfo;
        memset(&sSysInfo, 0, sizeof(SYSTEM_INFO));
        GetSystemInfo(&sSysInfo);
        if (sSysInfo.dwNumberOfProcessors)
            dwNumIOCPThreads = sSysInfo.dwNumberOfProcessors;

        if (!dwNumIOCPThreads)
        {
            dwNumIOCPThreads = WINHTTP_GLOBAL_IOCP_THREADS_BACKUP;
        }
    }
    g_cNumIOCPThreads = dwNumIOCPThreads;

    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "InitializeIOCPSupport",
                 "g_cNumIOCPThreads = %d",
                 g_cNumIOCPThreads
                 ));

#if INET_DEBUG
    g_cWSACompletions = 0;
    g_cCustomCompletions = 0;
#if defined (INCLUDE_CACHE)
    g_cCustomUserCompletions = 0;
    g_cCacheFileCompletions = 0;
#endif
#endif

    DWORD dwError = ERROR_SUCCESS;

    if (!g_hCompletionPort)
    {
        g_hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, dwNumIOCPThreads);
        if (!g_hCompletionPort)
        {
            dwError = GetLastError();
            goto quit;
        }
    }

    if (!g_lpCustomOverlapped)
    {
        g_lpCustomOverlapped = New OVERLAPPED();
        if (!g_lpCustomOverlapped)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        memset(g_lpCustomOverlapped, 0, sizeof(OVERLAPPED));
    }

#if defined (INCLUDE_CACHE)
    if (!g_lpCustomUserOverlapped)
    {
        g_lpCustomUserOverlapped = New OVERLAPPED();
        if (!g_lpCustomUserOverlapped)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        memset(g_lpCustomUserOverlapped, 0, sizeof(OVERLAPPED));
    }
#endif

    p_ThreadArray = new LPINFO_THREAD[dwNumIOCPThreads];

    if (!p_ThreadArray)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    memset(p_ThreadArray,0, sizeof(INFO_THREAD*)*dwNumIOCPThreads);

    for (int i=0; i<dwNumIOCPThreads; i++)
    {
        p_ThreadArray[i] = new INFO_THREAD();
        if (!p_ThreadArray[i])
        {
            for (int j=0; j<i; j++)
            {
                delete p_ThreadArray[j];
            }

            delete [] p_ThreadArray;
            p_ThreadArray = NULL;

            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        else
        {
            memset(p_ThreadArray[i], 0, sizeof(INFO_THREAD));
        }
    }

    for (int i=0; i<dwNumIOCPThreads; i++)
    {
        DWORD dwThreadId = 0;
        HANDLE hThread;
        HMODULE hMod;
        hThread = NULL;

        if ((hMod = LoadLibrary(VER_ORIGINALFILENAME_STR)) != NULL)
        {
            hThread = CreateThread(
                            NULL,
                            0,
                            (LPTHREAD_START_ROUTINE)IOCompletionThreadFunc,
                            hMod,
                            0,
                            &dwThreadId
                            );
            if (!hThread)
            {
                FreeLibrary(hMod);
            }
        }

        if (hThread)
        {   
            p_ThreadArray[p_iNumIOCPThreads++]->m_hThread = hThread;
            p_ThreadArray[i]->m_dwThreadId = dwThreadId;
        }
        else
        {
            //successfully queued functions terminated in TerminateIOCPSupport   
            dwError = GetLastError();
            break;
        }
        
    }

quit:
    DEBUG_LEAVE (dwError);
    return dwError;
}


VOID
TerminateIOCPSupport(
    VOID
    )
{
    DEBUG_ENTER((DBG_ASYNC,
                 Bool,
                 "TerminateIOCPSupport",
                 "g_cNumIOCPThreads = %d, g_cWSACompletions = %d, g_cCustomCompletions = %d",
                 g_cNumIOCPThreads,
                 g_cWSACompletions,
                 g_cCustomCompletions
                 ));

    int iNumThreadsToEnd = p_iNumIOCPThreads;
    BOOL fTerminatingOnWorker = FALSE;
    
    if (!p_ThreadArray)
        goto quit;

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();

    if (!lpThreadInfo)
    {
        goto quit;
    }

    DWORD dwThreadId = GetCurrentThreadId();
    for (int i=0; i<p_iNumIOCPThreads; i++)
    {
        if (p_ThreadArray[i]->m_dwThreadId == dwThreadId)
        {
            fTerminatingOnWorker = TRUE;
        }

        g_pAsyncCount->Add(p_ThreadArray[i]);
    }

    if (fTerminatingOnWorker
        || lpThreadInfo->IsAsyncWorkerThread)
    {
        //can't terminate the worker thread we're on.
        --iNumThreadsToEnd;
        fTerminatingOnWorker = TRUE;
        INET_ASSERT (lpThreadInfo->IsAsyncWorkerThread);
        INET_ASSERT (fTerminatingOnWorker);

        lpThreadInfo->fExitThread = TRUE;
    }
    
    for (int i=0; i<iNumThreadsToEnd; i++)
    {
        DEBUG_ENTER((DBG_API,
                         Bool,
                         "***PostQueuedCompletionStatus",
                         "(hComp)%#x, (# bytes)%#x, (completionkey)%#x, (overlapped)%#x",
                         g_hCompletionPort,
                         COMPLETION_BYTES_EXITIOCP,
                         NULL,
                         g_lpCustomOverlapped
                         ));
        BOOL bSuccess =  PostQueuedCompletionStatus(g_hCompletionPort,
                                            COMPLETION_BYTES_EXITIOCP,
                                            NULL,
                                            g_lpCustomOverlapped
                                            );
        UNREFERENCED_PARAMETER(bSuccess); 
#if INET_DEBUG
        InterlockedIncrement(&g_cCustomCompletions);
    
        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("!!!g_cCustomCompletions = 0x%x\n",
                    g_cCustomCompletions
                    ));
#endif

        DEBUG_LEAVE (bSuccess);
        //informational INET_ASSERT (bSuccess);
    }

quit:
    g_pAsyncCount->Purge();

    DEBUG_PRINT(ASYNC,
                INFO,
                ("!!! TerminateIOCPSupport g_cWSACompletions: %d\tg_cCustomCompletions: %d\n",
                g_cWSACompletions, g_cCustomCompletions
                ));

#if defined (INCLUDE_CACHE)
    INET_ASSERT ((g_cCustomUserCompletions == 0) &&
                 (g_cCacheFileCompletions == 0));
#endif

    if (p_ThreadArray)
    {
        delete [] p_ThreadArray;
        p_ThreadArray = NULL;
    }
    p_iNumIOCPThreads = 0;

    DEBUG_LEAVE (fTerminatingOnWorker);
    return;
}


DWORD
InitializeAsyncSupport(
    VOID
    )

/*++

Routine Description:

    Create async select thread object

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS


        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "InitializeAsyncSupport",
                 NULL
                 ));

    DWORD error;

    if (InDllCleanup)
    {
        error = ERROR_WINHTTP_SHUTDOWN;
    }
    else if (p_AsyncThread != NULL)
    {
        error = ERROR_SUCCESS;
    }
    else
    {
        error = ERROR_WINHTTP_SHUTDOWN;

        if (!GeneralInitCritSec.Lock())
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        if (!InDllCleanup) {
            if (p_AsyncThread == NULL) {

                HANDLE  hThreadToken = NULL;
                //
                // If the current thread is impersonating, then grab its access token
                // and revert the current thread (so it is nolonger impersonating).
                // After creating the worker thread, we will make the main thread
                // impersonate again. Apparently you should not call CreateThread
                // while impersonating.
                //
                if (OpenThreadToken(GetCurrentThread(), (TOKEN_IMPERSONATE | TOKEN_READ),
                        FALSE,
                        &hThreadToken))
                {
                    INET_ASSERT(hThreadToken != 0);

                    RevertToSelf();
                }

                HMODULE hMod = LoadLibrary(VER_ORIGINALFILENAME_STR);
                if (hMod)
                {
                    p_AsyncThread = New ICAsyncThread(hMod);

                    if (!p_AsyncThread)
                    {
                        FreeLibrary(hMod);
                    }
                }
                if (p_AsyncThread == NULL) {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                } else {
                    error = p_AsyncThread->GetError();
                    if (error == ERROR_SUCCESS)
                        error = InitializeIOCPSupport();
                    if (error != ERROR_SUCCESS) {
                        TerminateAsyncSupport(TRUE);
                    }
                }

                if (hThreadToken)
                {
                    (void)SetThreadToken(NULL, hThreadToken);

                    CloseHandle(hThreadToken);
                }


            } else {
                error = ERROR_SUCCESS;
            }
        }
        GeneralInitCritSec.Unlock();
    }

quit:
    DEBUG_LEAVE(error);

    return error;
}


VOID
TerminateAsyncSupport(
    BOOL bCleanUp
    )

/*++

Routine Description:

    Terminates async support

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "TerminateAsyncSupport",
                 NULL
                 ));

    ICAsyncThread * pThread;
    
    if (GeneralInitCritSec.Lock())
    {
        TerminateIOCPSupport();
        
        pThread = (ICAsyncThread *)InterlockedExchangePointer((PVOID*)&p_AsyncThread,
                                                       (PVOID)NULL
                              );
        
        if (pThread != NULL) 
        {
            if (bCleanUp)
                pThread->SetCleanUp();
            pThread->PrepareForTermination();
        }

        GeneralInitCritSec.Unlock();
    }
    
    DEBUG_LEAVE(0);
}


DWORD
QueueTimeoutFsm(
    IN CFsm * pFsm,
    IN SOCKET Socket,
    IN BOOL bResolveTimeoutQueue
    )

/*++

Routine Description:

    Adds a blocked socket operation/work item to the blocked queue

Arguments:

    pFsm    - in-progress socket operation (FSM)

    Socket  - socket handle to wait on

Return Value:

    DWORD
        Success - ERROR_IO_PENDING

        Failure - ERROR_WINHTTP_INTERNAL_ERROR

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "QueueTimeoutFsm",
                 "%#x, %#x, %B",
                 pFsm,
                 Socket,
                 bResolveTimeoutQueue
                 ));

    DWORD error = ERROR_WINHTTP_INTERNAL_ERROR;

    if (p_AsyncThread != NULL) 
    {
        error = p_AsyncThread->QueueTimeoutFsm(pFsm, Socket, bResolveTimeoutQueue);
        if (error == ERROR_SUCCESS)
        {
            error = ERROR_IO_PENDING;
        }
    }

    //informational INET_ASSERT(error != ERROR_WINHTTP_INTERNAL_ERROR);

    DEBUG_LEAVE(error);
    return error;
}


DWORD
QueueSocketWorkItem(
    IN CFsm * pFsm,
    IN SOCKET Socket
    )

/*++

Routine Description:

    Adds a blocked socket operation/work item to the blocked queue

Arguments:

    pFsm    - in-progress socket operation (FSM)

    Socket  - socket handle to wait on

Return Value:

    DWORD
        Success - ERROR_IO_PENDING

        Failure - ERROR_WINHTTP_INTERNAL_ERROR

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "QueueSocketWorkItem",
                 "%#x, %#x",
                 pFsm,
                 Socket
                 ));

    DWORD error = ERROR_WINHTTP_INTERNAL_ERROR;

    if (p_AsyncThread != NULL) {
        pFsm->SetSocket(Socket);
        error = p_AsyncThread->QueueSocketWorkItem(pFsm);
        if (error == ERROR_SUCCESS) {
            error = ERROR_IO_PENDING;
        }
    }

    //informational INET_ASSERT(error != ERROR_WINHTTP_INTERNAL_ERROR);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
BlockWorkItem(
    IN CFsm * pFsm,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwTimeout
    )

/*++

Routine Description:

    Blocks a work item

Arguments:

    pFsm        - work item to block

    dwBlockId   - block on this id

    dwTimeout   - for this number of milliseconds

Return Value:

    DWORD
        Error   - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "BlockWorkItem",
                 "%#x, %#x, %d",
                 pFsm,
                 dwBlockId,
                 dwTimeout
                 ));

    DWORD error = ERROR_WINHTTP_INTERNAL_ERROR;

    if (p_AsyncThread != NULL) {
        error = p_AsyncThread->BlockWorkItem(pFsm, dwBlockId, dwTimeout);
    }

    //informational INET_ASSERT(error != ERROR_WINHTTP_INTERNAL_ERROR);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
UnblockWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwError,
    IN LONG lPriority
    )

/*++

Routine Description:

    Unblocks 1 or more work items

Arguments:

    dwCount     - unblock this many work items

    dwBlockId   - that are blocked on this id

    dwError     - with this error

    lPriority   - new priority unless default value of TP_NO_PRIORITY_CHANGE

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "UnblockWorkItems",
                 "%d, %#x, %d (%s), %d",
                 dwCount,
                 dwBlockId,
                 dwError,
                 InternetMapError(dwError),
                 lPriority
                 ));

    DWORD dwUnblocked = 0;

    if (p_AsyncThread != NULL) {
        dwUnblocked = p_AsyncThread->UnblockWorkItems(dwCount,
                                                      dwBlockId,
                                                      dwError,
                                                      lPriority
                                                      );
    }

    DEBUG_LEAVE(dwUnblocked);

    return dwUnblocked;
}


DWORD
CheckForBlockedWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId
    )

/*++

Routine Description:

    Checks if there are any items blocked on dwBlockId

Arguments:

    dwCount     - number of items to look for

    dwBlockId   - blocked on this id

Return Value:

    DWORD
        Number of blocked items found

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "CheckForBlockedWorkItems",
                 "%d, %#x",
                 dwCount,
                 dwBlockId
                 ));

    DWORD dwFound = 0;

    if (p_AsyncThread != NULL) {
        dwFound = p_AsyncThread->CheckForBlockedWorkItems(dwCount, dwBlockId);
    }

    DEBUG_LEAVE(dwFound);

    return dwFound;
}

//
// private functions
//

//
// ICAsyncThread methods
//

VOID
ICAsyncThread::PrepareForTermination(
    VOID
    )
{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::PrepareForTermination",
                 NULL
                 ));

    HANDLE hThread = m_hThread;

    SetTerminating();

    if (GlobalDynaUnload || m_bCleanUp)
    {
        InterruptSelect();
        //
        // LEGACYWAIT: 5 secs: Assuming the async thread was successfully created, the above clean-up
        // will have put it in a state where it's going to exit.  Need to wait
        // for it to exit before returning from here so it doesn't get scheduled
        // after winhttp5 has been unloaded.
        //

        // VENKATK: Now that this thread addrefs and frees winhttp5, the issue doesn't arise
        // still wait for half a second to allow the thread to detect exit and exit.??
        if(hThread)
        {
            //informational no point waiting since the thread needs to synchronize against a lock we hold. DWORD dwRes = WaitForSingleObject(hThread, 500);
            //informational INET_ASSERT(dwRes == WAIT_OBJECT_0);

            CloseHandle(hThread);
        }
    }
}


ICAsyncThread::~ICAsyncThread(
    VOID
    )

/*++

Routine Description:

    ICAsyncThread destructor. If we are being dynamically unloaded, signal the
    selecter thread and allow it to cleanup. Else the thread is already dead and
    we just need to reclaim the resources

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::~ICAsyncThread",
                 NULL
                 ));

    // Should be okay to simply empty the resolve timeout list by dereferencing the refcounted elements.
    // If they are still on the list, it means they haven't timed out: by dereferencing, we will
    // either delete them or allow the worker thread to finish scheduling them.
    
    PLIST_ENTRY pEntry;
    PLIST_ENTRY pPrev;
    
    CPriorityList ExpiredFSMs;

    if (m_ResolveTimeoutQueue.Acquire())
    {
        CFsm_ResolveHost * pResolveFsm;
        pPrev = m_ResolveTimeoutQueue.Self();
        
        for (pEntry = m_ResolveTimeoutQueue.Head();
             pEntry != m_ResolveTimeoutQueue.Self();
             pEntry = ((CPriorityListEntry *)pPrev)->Next()) 
         {
            pResolveFsm = (CFsm_ResolveHost *)ContainingFsm((LPVOID)pEntry);
            
            //remove from list since this has already been scheduled by resolver.
            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("%s FSM %#x %B - %s\n",
                        pResolveFsm->MapType(),
                        pResolveFsm,
                        pResolveFsm->IsScheduled(),
                        "!!!being emptied from queue"
                        ));

            m_ResolveTimeoutQueue.Remove((CPriorityListEntry *)pEntry);

            ExpiredFSMs.Insert((CPriorityListEntry*)pResolveFsm->List());
        }

        m_ResolveTimeoutQueue.Release();
    }

    // Should be okay to simply empty the send-recv timeout list by dereferencing the refcounted elements.
    // If they are still on the list, it means they haven't timed out: by dereferencing, we will
    // either delete them or allow the worker thread to finish scheduling them.

    if (m_SendRecvQueue.Acquire())
    {
        CFsm_SocketIOCP * pFsm;
        pPrev = m_SendRecvQueue.Self();
        
        for (pEntry = m_SendRecvQueue.Head();
             pEntry != m_SendRecvQueue.Self();
             pEntry = ((CPriorityListEntry *)pPrev)->Next()) 
         {
            PLIST_ELEMENT pElement = ContainingListElement((LPVOID)pEntry);
            pFsm = (CFsm_SocketIOCP*) pElement->m_pFsm;

            //remove from list since this has already been scheduled.
            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("%s FSM %#x [%d != %d] - %s\n",
                        pFsm->MapType(),
                        pFsm,
                        pFsm->GetCookie(),
                        pElement->m_lCookie,
                        "!!!being emptied from queue"
                        ));

            m_SendRecvQueue.Remove((CPriorityListEntry *)pEntry);

            delete pEntry;
            //release reference

            ExpiredFSMs.InsertIfNew((CPriorityListEntry*)pFsm->List());
        }

        m_SendRecvQueue.Release();
    }

    // we've accumulated all expired FSMs and will deref them (and the embedded request objects) outside 
    // the critsec of queues. Otherwise the app can easily deadlock themselves.
    
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    pPrev = ExpiredFSMs.Self();    
    for (pEntry = ExpiredFSMs.Head();
         pEntry != ExpiredFSMs.Self();
         pEntry = ((CPriorityListEntry *)pPrev)->Next()) 
    {
        CFsm* pFsm = (CFsm*)ContainingFsm((LPVOID)pEntry);

        ExpiredFSMs.Remove((CPriorityListEntry *)pEntry);

        if (pFsm->GetMappedHandleObject())
        {
            if (lpThreadInfo)
            {
                _InternetSetObjectHandle(lpThreadInfo, 
                                            pFsm->GetMappedHandleObject(), 
                                            pFsm->GetMappedHandleObject());
                
                pFsm->GetMappedHandleObject()->Dereference();
            }
        }

        DWORD dwDummy = 0;
        pFsm->Dereference(&dwDummy);
    }

    DEBUG_LEAVE(0);
}


DWORD
ICAsyncThread::QueueTimeoutFsm(
    IN CFsm * pFsm,
    IN SOCKET Socket,
    IN BOOL bResolveTimeoutQueue
    )

/*++

Routine Description:

    Add the work-item waiting on a blocked socket to the blocked queue.
    Interrupt the SelectThread to alert it to new work

Arguments:

    pFsm    - blocked work-item to queue

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INTERNAL_ERROR
--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::QueueTimeoutFsm",
                 "%#x, %#x, %B",
                 pFsm,
                 Socket,
                 bResolveTimeoutQueue
                 ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error = ERROR_WINHTTP_INTERNAL_ERROR;

    //informational INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo != NULL)
    {
        pFsm->StartTimer();
        if (bResolveTimeoutQueue)
        {
            error = m_ResolveTimeoutQueue.Insert((CPriorityListEntry *)pFsm->List());

            if (error != ERROR_SUCCESS)
            {
                goto quit;
            }
        }
        else
        {
            pFsm->SetSocket(Socket);

            PLIST_ELEMENT pListElement = New LIST_ELEMENT(pFsm,
                                            ((CFsm_SocketIOCP *)pFsm)->GetCookie(),
                                            ((CFsm_SocketIOCP *)pFsm)->GetTimeoutWraps(),
                                            ((CFsm_SocketIOCP *)pFsm)->GetTimeout());
            if (!pListElement)
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
            error = m_SendRecvQueue.Insert((CPriorityListEntry *)pListElement->List());

            if (error != ERROR_SUCCESS)
            {
                delete pListElement;
                goto quit;
            }
        }
        lpThreadInfo->Fsm = NULL;
        InterruptSelect();
    }

quit:
    DEBUG_LEAVE(error);
    return error;
}


DWORD
ICAsyncThread::QueueSocketWorkItem(
    IN CFsm * pFsm
    )

/*++

Routine Description:

    Add the work-item waiting on a blocked socket to the blocked queue.
    Interrupt the SelectThread to alert it to new work

Arguments:

    pFsm    - blocked work-item to queue

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INTERNAL_ERROR

Async Issues: VENKATK_BUG
    1. Reduce contention for m_BlockedQueue by:
        maintaining sorted queue for timeout-only fsms.
    2. Don't call InterruptSelect() for timeout queueing
    3. check if content can be moved to per-fsm instead of
        global queue..
--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::QueueSocketWorkItem",
                 "%#x",
                 pFsm
                 ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error = ERROR_WINHTTP_INTERNAL_ERROR;

    //informational INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo != NULL) {
        pFsm->StartTimer();
        error = m_BlockedQueue.Insert((CPriorityListEntry *)pFsm->List());
        if (error == ERROR_SUCCESS)
        {
            lpThreadInfo->Fsm = NULL;
            InterruptSelect();
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICAsyncThread::BlockWorkItem(
    IN CFsm * pFsm,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwTimeout
    )

/*++

Routine Description:

    Blocks a work item (FSM)

Arguments:

    pFsm        - work item (FSM) to block

    dwBlockId   - block on this

    dwTimeout   - for this amount of time (mSec)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::BlockWorkItem",
                 "%#x [%d], %#x, %d",
                 pFsm,
                 pFsm->GetPriority(),
                 dwBlockId,
                 dwTimeout
                 ));

    DWORD error = error = ERROR_WINHTTP_INTERNAL_ERROR;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    //informational INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo != NULL) {
        pFsm->SetBlockId(dwBlockId);
        pFsm->SetTimeout(dwTimeout);

        RESET_FSM_OWNED(pFsm);

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("!!! FSM %#x unowned\n",
                    pFsm
                    ));

        error = m_BlockedQueue.Insert((CPriorityListEntry *)pFsm->List());
        lpThreadInfo->Fsm = NULL;
    }

    DEBUG_LEAVE(error);
    return error;
}


DWORD
ICAsyncThread::UnblockWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwError,
    IN LONG lPriority
    )

/*++

Routine Description:

    Unblock a nunber of work items waiting on a block id

Arguments:

    dwCount     - unblock this many work items

    dwBlockId   - unblock work items waiting on this id

    dwError     - unblock work items with this error code

    lPriority   - if not TP_NO_PRIORITY_CHANGE, change priority to this value

Return Value:

    DWORD
        Number of work items unblocked

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "ICAsyncThread::UnblockWorkItems",
                 "%d, %#x, %d (%s), %d",
                 dwCount,
                 dwBlockId,
                 dwError,
                 InternetMapError(dwError),
                 lPriority
                 ));

    DWORD dwUnblocked = 0;

    if (!m_BlockedQueue.Acquire())
        goto quit;

    CPriorityListEntry * pCur = (CPriorityListEntry *)m_BlockedQueue.Head();
    CPriorityListEntry * pPrev = (CPriorityListEntry *)m_BlockedQueue.Self();

    while ((dwCount != 0) && (pCur != (CPriorityListEntry *)m_BlockedQueue.Self())) {

        CFsm * pFsm = ContainingFsm((LPVOID)pCur);

        //CHECK_FSM_UNOWNED(pFsm);

        if (pFsm->IsBlockedOn(dwBlockId)) {
            m_BlockedQueue.Remove((CPriorityListEntry *)pFsm);
            pFsm->SetError(dwError);
            if (lPriority != TP_NO_PRIORITY_CHANGE) {
                pFsm->SetPriority(lPriority);
            }
//dprintf("UNBLOCKED %s FSM %#x state %s socket %#x\n", pFsm->MapType(), pFsm, pFsm->MapState(), pFsm->GetSocket());
            pFsm->QueueWorkItem();
            ++dwUnblocked;
            --dwCount;
        } else {
            pPrev = pCur;
        }
        pCur = (CPriorityListEntry *)pPrev->Next();
    }
    m_BlockedQueue.Release();

quit:
    DEBUG_LEAVE(dwUnblocked);

    return dwUnblocked;
}


DWORD
ICAsyncThread::CheckForBlockedWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId
    )

/*++

Routine Description:

    Examines to see if a blocked FSM is still blocked in order to prevent
        wasted processing if it isn't.

Arguments:

    dwCount     - unblock this many work items

    dwBlockId   - unblock work items waiting on this id

Return Value:

    DWORD
        Number of work items that are currently blocked

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "ICAsyncThread::CheckForBlockedWorkItems",
                 "%d, %#x",
                 dwCount,
                 dwBlockId
                 ));

    DWORD dwFound = 0;

    if (!m_BlockedQueue.Acquire())
        goto quit;

    CPriorityListEntry * pCur = (CPriorityListEntry *)m_BlockedQueue.Head();

    while ((dwCount != 0) && (pCur != (CPriorityListEntry *)m_BlockedQueue.Self())) {

        CFsm * pFsm = ContainingFsm((LPVOID)pCur);

        if (pFsm->IsBlockedOn(dwBlockId)) {
            ++dwFound;
            --dwCount;
        }
        pCur = (CPriorityListEntry *)pCur->Next();
    }
    m_BlockedQueue.Release();

quit:
    DEBUG_LEAVE(dwFound);

    return dwFound;
}


DWORD
ICAsyncThread::SelectThreadWrapper(
    IN ICAsyncThread * pThread
    )

/*++

Routine Description:

    Kicks off select thread as member function of pThread object

Arguments:

    pThread - pointer to thread object

Return Value:

    DWORD
        return code from SelectThread (not used)

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::SelectThreadWrapper",
                 "%#x",
                 pThread
                 ));

    HMODULE hMod = pThread->GetHMod();

    DWORD error = pThread->SelectThread();

    DEBUG_LEAVE(error);

    if (GeneralInitCritSec.Lock())
    {
        delete pThread;
        GeneralInitCritSec.Unlock();
    }
    
    if (hMod)
        FreeLibraryAndExitThread(hMod, error);

    return error;
}


DWORD
ICAsyncThread::ProcessSendRecvTimeouts(
    DWORD* pTimeout
    )
{
    PLIST_ENTRY pEntry;
    PLIST_ENTRY pPrev;
    int nTimeouts = 0;

    CPriorityList ExpiredFSMs;

    if (m_SendRecvQueue.Acquire())
    {
        CFsm_SocketIOCP* pFsm;
        LONG lCookie;
        DWORD timeNow = GetTickCountWrap();
        pPrev = m_SendRecvQueue.Self();
        
        for (pEntry = m_SendRecvQueue.Head();
             pEntry != m_SendRecvQueue.Self();
             pEntry = ((CPriorityListEntry *)pPrev)->Next()) 
         {
            PLIST_ELEMENT pElement = ContainingListElement((LPVOID)pEntry);
            pFsm = (CFsm_SocketIOCP*) pElement->m_pFsm;
            lCookie = pElement->m_lCookie;

            INET_ASSERT( (pFsm->GetAction() == FSM_ACTION_SEND) ||
                            (pFsm->GetAction() == FSM_ACTION_RECEIVE) );

            if (!pFsm->IsValidForTimeoutCheck(lCookie))
            {
                DEBUG_PRINT(ASYNC,
                            INFO,
                            ("%s FSM %#x [%d != %d] %s\n",
                            pFsm->MapType(),
                            pFsm,
                            pFsm->GetCookie(),
                            lCookie,
                            "scheduled: removing from timeout queue"
                            ));

                //not valid anymore: dereference.
                m_SendRecvQueue.Remove((CPriorityListEntry *)pEntry);

                delete pEntry;

                ExpiredFSMs.InsertIfNew((CPriorityListEntry*)pFsm->List());

                continue;
            }   
            else if (pFsm->IsInvalid() || pElement->IsTimedOut(timeNow)) 
            {
                DEBUG_PRINT(ASYNC,
                            INFO,
                            ("%s FSM %#x %s\n",
                            pFsm->MapType(),
                            pFsm,
                            pFsm->IsInvalid() ? "invalid" : "timed out"
                            ));

                m_SendRecvQueue.Remove((CPriorityListEntry *)pEntry);

                if (pFsm->TestAndSetValidForTimeoutEnforce(lCookie))
                {
                    ((INTERNET_HANDLE_BASE *)pFsm->GetMappedHandleObject())->AbortSocket();
                    
                    pFsm->SetErrorState(pFsm->IsInvalid()
                                        ? ERROR_WINHTTP_OPERATION_CANCELLED
                                        : ERROR_WINHTTP_TIMEOUT
                                        );
                }
                else
                {
                    // nothing to do here.
                }

                delete pEntry;

                ExpiredFSMs.InsertIfNew((CPriorityListEntry*)pFsm->List());
                
                continue;
            }
            else
            {
                INET_ASSERT (pFsm->IsActive()
                            || !pFsm->IsValidForTimeoutCheck(lCookie));
                ++nTimeouts;
            }
            
            DWORD interval = pFsm->GetTimeout() - timeNow;

            if (interval < *pTimeout)
            {
                *pTimeout = interval;
            }
            
            pPrev = pEntry;
        }

        m_SendRecvQueue.Release();
    }

    // we've accumulated all expired FSMs and will deref them (and the embedded request objects) outside 
    // the critsec of queues. Otherwise the app can easily deadlock themselves.
    
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    pPrev = ExpiredFSMs.Self();
    for (pEntry = ExpiredFSMs.Head();
         pEntry != ExpiredFSMs.Self();
         pEntry = ((CPriorityListEntry *)pPrev)->Next()) 
    {
        CFsm* pFsm = (CFsm*)ContainingFsm((LPVOID)pEntry);

        ExpiredFSMs.Remove((CPriorityListEntry *)pEntry);

        if (pFsm->GetMappedHandleObject())
        {
            if (lpThreadInfo)
            {
                _InternetSetObjectHandle(lpThreadInfo, 
                                            pFsm->GetMappedHandleObject(), 
                                            pFsm->GetMappedHandleObject());
                
                pFsm->GetMappedHandleObject()->Dereference();
            }
        }

        DWORD dwDummy = 0;
        pFsm->Dereference(&dwDummy);
    }

    return nTimeouts;
}


DWORD
ICAsyncThread::ProcessResolveTimeouts(
    DWORD* pTimeout
    )
{
    PLIST_ENTRY pEntry;
    PLIST_ENTRY pPrev;
    int nTimeouts = 0;
    
    CPriorityList ExpiredFSMs;

    if (m_ResolveTimeoutQueue.Acquire())
    {
        CFsm_ResolveHost * pResolveFsm;
        DWORD timeNow = GetTickCountWrap();
        pPrev = m_ResolveTimeoutQueue.Self();
        
        for (pEntry = m_ResolveTimeoutQueue.Head();
             pEntry != m_ResolveTimeoutQueue.Self();
             pEntry = ((CPriorityListEntry *)pPrev)->Next()) 
         {
            pResolveFsm = (CFsm_ResolveHost *)ContainingFsm((LPVOID)pEntry);
            
            if (pResolveFsm->IsScheduled())
            {
                //remove from list since this has already been scheduled by resolver.
                DEBUG_PRINT(ASYNC,
                            INFO,
                            ("%s FSM %#x %s\n",
                            pResolveFsm->MapType(),
                            pResolveFsm,
                            "resolved: removing from timeout queue"
                            ));

                m_ResolveTimeoutQueue.Remove((CPriorityListEntry *)pEntry);

                //release reference

                ExpiredFSMs.Insert((CPriorityListEntry*)pResolveFsm->List());
                continue;
            }
            else if (pResolveFsm->IsInvalid() || pResolveFsm->IsTimedOut(timeNow))
            {
                DEBUG_PRINT(ASYNC,
                            INFO,
                            ("%s FSM %#x %s\n",
                            pResolveFsm->MapType(),
                            pResolveFsm,
                            pResolveFsm->IsInvalid() ? "invalid" : "timed out"
                            ));

                m_ResolveTimeoutQueue.Remove((CPriorityListEntry *)pEntry);

                if (!pResolveFsm->TestAndSetScheduled())
                {
                    pResolveFsm->SetErrorState(pResolveFsm->IsInvalid()
                                            ? ERROR_WINHTTP_OPERATION_CANCELLED
                                            : ERROR_WINHTTP_TIMEOUT
                                            );
                    pResolveFsm->QueueWorkItem();
                }
                else
                {
                    //was already scheduled by resolver.
                    //so only release reference.

                    ExpiredFSMs.Insert((CPriorityListEntry*)pResolveFsm->List());
                }
                continue;
            }
            else
            {
                ++nTimeouts;
            }
            
            DWORD interval = pResolveFsm->GetTimeout() - timeNow;

            if (interval < *pTimeout)
            {
                *pTimeout = interval;
            }
            
            pPrev = pEntry;
        }

        m_ResolveTimeoutQueue.Release();
    }

    // we've accumulated all expired FSMs and will deref them (and the embedded request objects) outside 
    // the critsec of queues. Otherwise the app can easily deadlock themselves.
    
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    pPrev = ExpiredFSMs.Self();
    for (pEntry = ExpiredFSMs.Head();
         pEntry != ExpiredFSMs.Self();
         pEntry = ((CPriorityListEntry *)pPrev)->Next()) 
    {
        CFsm* pFsm = (CFsm*)ContainingFsm((LPVOID)pEntry);

        ExpiredFSMs.Remove((CPriorityListEntry *)pEntry);

        if (pFsm->GetMappedHandleObject())
        {
            if (lpThreadInfo)
            {
                _InternetSetObjectHandle(lpThreadInfo, 
                                            pFsm->GetMappedHandleObject(), 
                                            pFsm->GetMappedHandleObject());
                
                pFsm->GetMappedHandleObject()->Dereference();
            }
        }

        DWORD dwDummy = 0;
        pFsm->Dereference(&dwDummy);
    }

    return nTimeouts;
}


DWORD
ICAsyncThread::SelectThread(
    VOID
    )

/*++

Routine Description:

    Waits for completed items on blocked queue to finish, either due to timeout,
    invalidated request handle or successful or error completion of the socket
    operation.

    Completed items are put on the work queue and a worker signalled to process
    it

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::SelectThread",
                 NULL
                 ));

    //
    // ensure we have a threadinfo object on this thread
    //
    LPINTERNET_THREAD_INFO  lpThreadInfo;
    INTERNET_THREAD_INFO    LocalThreadInfoOnStack;

    lpThreadInfo = InternetGetThreadInfo();

    // If allocation of the thread info object failed, then
    // use a threadinfo object preallocated on our stack.
    if (!lpThreadInfo)
    {
        lpThreadInfo = InternetCreateThreadInfo(TRUE, &LocalThreadInfoOnStack);
        INET_ASSERT(lpThreadInfo->fStaticAllocation);
    }

    DWORD error = ERROR_SUCCESS;

    while (!IsTerminating()) 
    {
        PLIST_ENTRY pEntry;
        PLIST_ENTRY pPrev;
        int nTimeouts = 0;
        int n = 0;
        DWORD timeout = 0xffffffff;
        CFsm * pFsm;

        nTimeouts += ProcessResolveTimeouts(&timeout);
        nTimeouts += ProcessSendRecvTimeouts(&timeout);
        
        //
        // run through the blocked items finding sockets to wait on and minimum
        // time to wait. If we find any items already timed out or invalidated
        // then remove them and put on the work queue
        //
            
        if (!m_BlockedQueue.Acquire())
        {
            // wait and try again when more memory might be available
            goto wait_again;
        }
        DWORD timeNow = GetTickCountWrap();
        
        pPrev = m_BlockedQueue.Self();

        //
        // BUGBUG - queue limited by size of FD_SET
        //
        FD_ZERO(&read_fds);
        FD_ZERO(&write_fds);
        FD_ZERO(&except_fds);

        FD_SET(m_SelectSocket, &read_fds);
        ++n;

        for (pEntry = m_BlockedQueue.Head();
             pEntry != m_BlockedQueue.Self();
             pEntry = ((CPriorityListEntry *)pPrev)->Next()) {

            pFsm = ContainingFsm((LPVOID)pEntry);
            if (pFsm->IsInvalid() || pFsm->IsTimedOut(timeNow)) {

                DEBUG_PRINT(ASYNC,
                            INFO,
                            ("%s FSM %#x %s\n",
                            pFsm->MapType(),
                            pFsm,
                            pFsm->IsInvalid() ? "invalid" : "timed out"
                            ));

                m_BlockedQueue.Remove((CPriorityListEntry *)pEntry);
                pFsm->SetErrorState(pFsm->IsInvalid()
                                        ? ERROR_WINHTTP_OPERATION_CANCELLED
                                        : ERROR_WINHTTP_TIMEOUT
                                        );
                pFsm->ResetSocket();
                pFsm->QueueWorkItem();
                continue;
            }
            else if (pFsm->IsActive()) 
            {
                SOCKET sock = pFsm->GetSocket();

                INET_ASSERT (pFsm->GetAction() != FSM_ACTION_RECEIVE);
                //
                // connect() only
                //
                DEBUG_PRINT(ASYNC,
                            INFO,
                            ("%s FSM %#x WRITE waiting on socket %#x\n",
                            pFsm->MapType(),
                            pFsm,
                            sock
                            ));

                FD_SET(sock, &write_fds);

                //
                // all sockets are checked for exception
                //
                FD_SET(sock, &except_fds);
                ++n;
                
            }// if pFsm->IsActive()

            DWORD interval = pFsm->GetTimeout() - timeNow;

            if (interval < timeout) {
                timeout = interval;
//dprintf("min timeout = %d\n", timeout);
            }
            pPrev = pEntry;
        }

        m_BlockedQueue.Release();

wait_again:
        //
        // wait for default (5 secs) timeout if nothing currently on list
        //
        if ((n == 1) && (nTimeouts == 0))
        {
            timeout = DEFAULT_ASYNC_SELECT_THREAD_TIMEOUT;
        }

        //avoid a tight loop on a tiny timeout.
        if (timeout < 100)
        {
            timeout = 100;
        }

        struct timeval to;

        to.tv_sec = timeout / 1000;
        to.tv_usec = (timeout % 1000) * 1000;

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("waiting %d mSec (%d.%06d) for select(). %d sockets\n",
                    timeout,
                    to.tv_sec,
                    to.tv_usec,
                    n
                    ));

        //SuspendCAP();

        if (IsTerminating()) {
            break;
        }
        n = PERF_Select(n, &read_fds, &write_fds, &except_fds, &to);
        if (IsTerminating()) {
            break;
        }

        //ResumeCAP();

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("select() returns %d\n",
                    n
                    ));

        //
        // if the only thing that's happened is that a new request has been
        // added to the list then rebuild the list and re-select
        //

        if ((n == 1) && FD_ISSET(m_SelectSocket, &read_fds)) {
            if (!DrainSelectSocket() && !IsTerminating()) {
                RecreateSelectSocket();
            }
            continue;
        }

        //
        // if any items are completed (either successfully or with an error)
        // or timed out or invalidated then put them on the work queue
        //


        if ((n>=0) || (nTimeouts >= 0))
        {
            if (m_BlockedQueue.Acquire())
            {

                pPrev = m_BlockedQueue.Self();
                timeNow = GetTickCountWrap();

                for (pEntry = m_BlockedQueue.Head();
                     pEntry != m_BlockedQueue.Self();
                     pEntry = ((CPriorityListEntry *)pPrev)->Next()) 
                {
                    DWORD dwEntryError = 0;
                    BOOL bComplete = FALSE;
                    LONG lPriority = TP_NO_PRIORITY_CHANGE;

                    pFsm = ContainingFsm((LPVOID)pEntry);
                    if (pFsm->IsInvalid()) {

                        DEBUG_PRINT(ASYNC,
                                    INFO,
                                    ("%s FSM %#x invalid\n",
                                    pFsm->MapType(),
                                    pFsm
                                    ));

                        dwEntryError = ERROR_WINHTTP_OPERATION_CANCELLED;
                        bComplete = TRUE;
                    } else if (pFsm->IsTimedOut(timeNow)) {

                        DEBUG_PRINT(ASYNC,
                                    INFO,
                                    ("%s FSM %#x timed out\n",
                                    pFsm->MapType(),
                                    pFsm
                                    ));

                        dwEntryError = ERROR_WINHTTP_TIMEOUT;
                        bComplete = TRUE;
                    } else if (pFsm->IsActive()) {

                        SOCKET sock = pFsm->GetSocket();

                        if (FD_ISSET(sock, &except_fds)) {

                            DEBUG_PRINT(ASYNC,
                                        INFO,
                                        ("%s FSM %#x socket %#x exception\n",
                                        pFsm->MapType(),
                                        pFsm,
                                        sock
                                        ));

                            switch (pFsm->GetAction()) {
                            case FSM_ACTION_CONNECT:
                                dwEntryError = ERROR_WINHTTP_CANNOT_CONNECT;
                                break;

                            case FSM_ACTION_SEND:
                            case FSM_ACTION_RECEIVE:
                                dwEntryError = ERROR_WINHTTP_CONNECTION_ERROR;
                                break;

                            default:

                                INET_ASSERT(FALSE);

                                break;
                            }
                            bComplete = TRUE;
                        } else if (FD_ISSET(sock, &read_fds)
                        || FD_ISSET(sock, &write_fds)) {

                            DEBUG_PRINT(ASYNC,
                                        INFO,
                                        ("%s FSM %#x socket %#x completed\n",
                                        pFsm->MapType(),
                                        pFsm,
                                        sock
                                        ));

                            dwEntryError = ERROR_SUCCESS;
                            bComplete = TRUE;

                            //
                            // BUGBUG - the priority needs to be boosted
                            //

                        }
                    }
                    if (bComplete) 
                    {
                        m_BlockedQueue.Remove((CPriorityListEntry *)pFsm);
                        if (dwEntryError != ERROR_SUCCESS) 
                        {
                            pFsm->SetErrorState(dwEntryError);
                        } 
                        else 
                        {
                            pFsm->SetError(ERROR_SUCCESS);
                            pFsm->SetState(pFsm->GetNextState());
                        }
                        pFsm->SetPriority(lPriority);

//dprintf("%s FSM %#x socket %#x signalled, time on queue = %d\n", pFsm->MapType(), pFsm, pFsm->GetSocket(), pFsm->StopTimer());
                        //
                        // no longer waiting on this socket handle
                        //

                        pFsm->ResetSocket();

                        //
                        // BUGBUG - if the next operation will complete quickly
                        //          (FSM_HINT_QUICK) then we should run it here
                        //          instead of queuing to another thread
                        //

                        pFsm->QueueWorkItem();
                    } 
                    else 
                    {
                        pPrev = pEntry;
                    }
                }//loop: for (pEntry = m_BlockedQueue.Head();pEntry != m_BlockedQueue.Self();pEntry = ((CPriorityListEntry *)pPrev)->Next()) 
                m_BlockedQueue.Release();
            }// if (m_BlockedQueue.Acquire())
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        } 
        else // if! n >= 0
        {
            error = _I_WSAGetLastError();

            DEBUG_PRINT(ASYNC,
                        ERROR,
                        ("select() returns %d (%s)\n",
                        error,
                        InternetMapError(error)
                        ));

            //
            // WSAENOTSOCK can happen if the socket was cancelled just
            // before we waited on it. We can also get WSAEINTR if
            // select() is terminated early (by APC)
            //

            INET_ASSERT((error == WSAENOTSOCK) || (error == WSAEINTR) || (error == WSAEBADF));

            if (error == WSAEINTR) {
                continue;
            }

            //
            // when running on a portable (& probably desktops also), if we
            // suspend & resume, the select socket can be invalidated. We
            // need to recognize this situation and handle it
            //
            // #616660: Also, if a layered service provider is activated,
            // we need to recreate the UDP socket.
            //
            if (error == WSAENOTSOCK)
            {
                //
                // the select socket may be dead. Throw it away & create a new
                // one. We should pick up any blocked requests that tried
                // unsuccessfully to interrupt the old select socket
                //
                RecreateSelectSocket();
            }
        } // if! n >= 0
    }

    DestroySelectSocket();

    DEBUG_LEAVE(error);

    //
    // If the local stack threadinfo object is in use,
    // then clear out the pointer from TLS here. So when this thread
    // detaches, the InternetDestroyThreadInfo called
    // from DLLMain(DLL_THREAD_DETACH) will have no effect--it will
    // not find a threadinfo object in TLS on this thread.
    //
    if (lpThreadInfo == &LocalThreadInfoOnStack)
    {
        InternetSetThreadInfo(NULL);
    }

    return error;
}


DWORD
ICAsyncThread::CreateSelectSocket(
    VOID
    )

/*++

Routine Description:

    In order to not have to keep inefficiently polling select() with a short
    time-out, we create a 'trick' datagram socket that we can use to interrupt
    select() with: this is a local socket, and if we send something to ourself
    then select() will complete (assuming one of the sockets we are waiting on
    is the one we create here)

    N.B. Sockets support must be initialized by the time we get here

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - mapped socket error

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::CreateSelectSocket",
                 NULL
                 ));

    DWORD error;
    SOCKET sock;

    if (m_SelectSocket != INVALID_SOCKET)
    {
        // this can only happen when DestroySelectSocket() failed to close the socket due
        // to a critSec can not be acquired.

        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    sock = _I_socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (sock == INVALID_SOCKET) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("socket() failed\n"
                    ));

        goto socket_error;
    }

    SOCKADDR_IN sockAddr;

    sockAddr.sin_family = AF_INET;
    sockAddr.sin_port = 0;
    *(LPDWORD)&sockAddr.sin_addr = _I_htonl(INADDR_LOOPBACK);
    memset(&sockAddr.sin_zero, 0, sizeof(sockAddr.sin_zero));

    int rc;

    DEBUG_PRINT(ASYNC,
                INFO,
                ("binding socket %#x to address %A\n",
                sock,
                &sockAddr));

    rc = _I_bind(sock, (LPSOCKADDR)&sockAddr, sizeof(sockAddr));
    if (rc == SOCKET_ERROR) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("bind() failed\n"
                    ));

        goto socket_error;
    }

    int namelen;
    SOCKADDR sockname;
    namelen = sizeof(sockname);

    rc = _I_getsockname(sock, &sockname, &namelen);
    if (rc == SOCKET_ERROR) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("getsockname() failed\n"
                    ));

        goto socket_error;
    }

    DEBUG_PRINT(ASYNC,
                INFO,
                ("connecting to address %A\n",
                &sockname));

    rc = _I_connect(sock, &sockname, namelen);
    if (rc == SOCKET_ERROR) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("connect() failed\n"
                    ));

        goto socket_error;
    }

    m_SelectSocket = sock;
    error = ERROR_SUCCESS;

quit:

    DEBUG_LEAVE(error);

    return error;

socket_error:

    error = MapInternetError(_I_WSAGetLastError());
    DestroySelectSocket();
    goto quit;
}


VOID
ICAsyncThread::DestroySelectSocket(
    VOID
    )

/*++

Routine Description:

    Just closes SelectSocket (if we think its open)

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::DestroySelectSocket",
                 NULL
                 ));

    if (m_SelectSocket != INVALID_SOCKET) {
        if (m_SocketCritSec.Lock())
        {
            _I_closesocket(m_SelectSocket);
            m_SelectSocket = INVALID_SOCKET;

            m_SocketCritSec.Unlock();
        }
    }

    DEBUG_LEAVE(0);
}


VOID
ICAsyncThread::RecreateSelectSocket(
    VOID
    )

/*++

Routine Description:

    Attempt to destroy & recreate select socket. Required when socket is killed
    due to suspend, e.g.

    Since the underlying net components may take a while to restart, we loop up
    to 12 times, waiting up to ~16 secs (~32 secs cumulative)

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::RecreateSelectSocket",
                 NULL
                 ));

    DestroySelectSocket();

    DEBUG_PRINT(ASYNC,
                INFO,
                ("current interrupt count = %d\n",
                m_lSelectInterrupts
                ));

    m_lSelectInterrupts = -1;

    int iterations = 12;
    DWORD time = 8;
    DWORD error;

    do {
        error = CreateSelectSocket();
        if (error != ERROR_SUCCESS) {
            PERF_Sleep(time);
            time <<= 1;
            
            DestroySelectSocket();  // if error is ERROR_NOT_ENOUGH_MEMORY, then the socket didn't get closed in the 
                                    // previous DestroySelectSocket() call, we try again here
        }
    } while ((error != ERROR_SUCCESS) && --iterations);

    if (error == ERROR_NOT_ENOUGH_MEMORY)
    {
        INET_ASSERT(m_SelectSocket != INVALID_SOCKET);
        m_SelectSocket = INVALID_SOCKET; // we leak a socket if we can't acquire a lock a close it after 12 tries.
    }

    DEBUG_LEAVE(0);
}


VOID
ICAsyncThread::InterruptSelect(
    VOID
    )

/*++

Routine Description:

    We interrupt a waiting select() by sending a small amount of data to ourself
    on the 'trick datagram socket'

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::InterruptSelect",
                 NULL
                 ));

    //
    // if the async select socket is already created then interrupt it. If it is
    // not yet created then it probably means that the async scheduler thread
    // hasn't gotten around to it yet, ipso facto the async scheduler can't be
    // stuck in a select(), hence its okay to skip
    //

    if (m_SelectSocket == INVALID_SOCKET)
    {
        return;
    }

    if (!m_SocketCritSec.Lock())
    {
        return;
    }

    if (m_SelectSocket != INVALID_SOCKET) {
        if (InterlockedIncrement(&m_lSelectInterrupts) == 0) {
            if (_I_send != NULL) {
                int nSent;

                nSent = _I_send(m_SelectSocket, gszBang, 1, 0);

                if (nSent < 0) {

#if INET_DEBUG
                    DWORD error = _I_WSAGetLastError();
                    UNREFERENCED_PARAMETER(error); // avoid C4189 on checked build 
                    DEBUG_PRINT(ASYNC,
                                INFO,
                                ("send(%#x) returns %s (%d)\n",
                                m_SelectSocket,
                                InternetMapError(error),
                                error
                                ));
#endif
                    //
                    // We failed to queue the interrupt; clean up.
                    //
                    InterlockedDecrement(&m_lSelectInterrupts);
                }
            }
        } else {
            InterlockedDecrement(&m_lSelectInterrupts);

            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("select() already interrupted, count = %d\n",
                        m_lSelectInterrupts
                        ));

        }
    } else {

        DEBUG_PRINT(ASYNC,
                    WARNING,
                    ("select socket not yet created\n"
                    ));

    }

    m_SocketCritSec.Unlock();

    DEBUG_LEAVE(0);
}


BOOL
ICAsyncThread::DrainSelectSocket(
    VOID
    )

/*++

Routine Description:

    Just reads the data written to the async select socket in order to wake up
    select()

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - successfully drained

        FALSE   - error occurred

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Bool,
                 "ICAsyncThread::DrainSelectSocket",
                 NULL
                 ));

    BOOL bSuccess = TRUE;

    if (m_SelectSocket != INVALID_SOCKET) {

        //
        // reduce the interrupt count. Threads making async requests will cause
        // the select() to be interrupted again
        //

        InterlockedDecrement(&m_lSelectInterrupts);

        char buf[32];
        int nReceived;

        nReceived = _I_recv(m_SelectSocket, buf, sizeof(buf), 0);

#ifdef unix
        if(nReceived > -1)
        {
#endif /* unix */

        //INET_ASSERT(nReceived == 1);
        //INET_ASSERT(buf[0] == '!');

#ifdef unix
        }
#endif /* unix */

        if (nReceived < 0) {
#if INET_DEBUG
            DWORD error = _I_WSAGetLastError();
#endif

            INET_ASSERT(error != ERROR_SUCCESS);

            DEBUG_PRINT(ASYNC,
                        ERROR,
                        ("recv() returns %s [%d]\n",
                        InternetMapError(error),
                        error
                        ));

            bSuccess = FALSE;
        }
    } else {

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("m_SelectSocket == INVALID_SOCKET\n"
                    ));

        bSuccess = FALSE;
    }

    DEBUG_LEAVE(bSuccess);

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\dlole.cxx ===
#include <wininetp.h>
#include <windows.h>
#include <winbase.h>
#include "DLOle.h"

#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))

//
//  An array of modules is kept so they can be unloaded at shutdown.
//
DL_MODULE *const g_apModules[] = {
    &g_moduleOle32,
    &g_moduleOleAut32,
};


//
//  DLOleInitialize()/DLOleTermintate() are needed to manage a critical section.
//  The critical section is to prevent multiple threads from trying to load a library at the same time.
//  DLOleTerminate() will also unload loaded modules.
//

CCritSec InitializationLock;

BOOL DLOleInitialize()
{
    return InitializationLock.Init();
}

void DLOleTerminate()
{
    for (int i = 0; i < ARRAY_SIZE(g_apModules); i++)
    {
        DelayUnload(g_apModules[i]);
    }
    
    InitializationLock.FreeLock();
}


DL_MODULE::DL_MODULE(const LPCSTR szDllName, const DL_FUNCTIONMAP *const pFunctionMap, const int iFunctionMapSize)
    : _szDllName( szDllName), _pFunctionMap( pFunctionMap), _iFunctionMapSize( iFunctionMapSize)
{
    _hDllHandle = NULL;
}


#if INET_DEBUG
DL_MODULE::~DL_MODULE()
{
    INET_ASSERT(!GlobalDynaUnload || _hDllHandle == NULL); //  was this module not unloaded?
}
#endif


//
//
//  This delay load mechanism is used by calling DelayLoad(&DL_MODULE), 
//where DL_MODULE describes the library module.
//
//

/***********  From DLOle.h:
typedef struct
{
    LPCSTR szFunctionName;
    FARPROC * ppfuncAddress;
} DL_FUNCTIONMAP;

struct DL_MODULE
{
    HMODULE _hDllHandle;
    const LPCSTR _szDllName;
    const DL_FUNCTIONMAP *const _pFunctionMap;
    const int _iFunctionMapSize;

    DL_MODULE( const LPCSTR szDllName, const DL_FUNCTIONMAP *const pFunctionMap, const int iFunctionMapSize);
    ~DL_MODULE();
};
************   End from DLOle.h */

BOOL DelayLoad( DL_MODULE* pModule)
{
    BOOL retVal = FALSE;
    HMODULE hModule = NULL;
    int i;

    //  
    //  Because pModule->_hDllHandle is not set non-NULL until the module
    //has safely loaded the function values, we can check that it is loaded without
    //requiring the lock.
    //
    if (pModule->_hDllHandle != NULL)
    {
        retVal = TRUE;
        goto doneWithoutLock;
    }

    //  If we can't get the DL lock, fail without any cleanup necessary.
    if (!InitializationLock.Lock())
    {
        retVal = FALSE;
        goto doneWithoutLock;
    }

    //  Verify that the module wasn't loaded while we waited for the lock
    if (pModule->_hDllHandle != NULL)
    {
        retVal = TRUE;
        goto doneWithLock;
    }

    //  Attemp to load the necessary DLL.
    hModule = LoadLibrary (pModule->_szDllName);
    if (hModule == NULL)
        goto doneWithLock;

    //  With the loaded module, extract the necessary functions.
    for ( i = 0; i < pModule->_iFunctionMapSize; ++i)
    {
        FARPROC farProc = GetProcAddress( hModule,
                                          pModule->_pFunctionMap[i].szFunctionName);
        if (farProc == NULL)
            goto doneWithLock;
        
        *(pModule->_pFunctionMap[i].ppfuncAddress) = farProc;
    }

    //  On success, pass ownership of handle to DL_MODULE.
    pModule->_hDllHandle = hModule;
    hModule = NULL;
    retVal = TRUE;

doneWithLock:
    //  If we failed prematurely, close the module and remove references to it.
    if (!retVal)
    {
        if (NULL != hModule)
            FreeLibrary(hModule);

        for (i = 0; i < pModule->_iFunctionMapSize; i++)
            *(pModule->_pFunctionMap[i].ppfuncAddress) = NULL;
    }

    InitializationLock.Unlock();
    
doneWithoutLock:    
    return retVal;
}


//
//  It is unsafe to call DelayLoad before all threads are done
//using the module.
//
BOOL DelayUnload(DL_MODULE* pModule)
{
    BOOL retVal = FALSE;
    BOOL fHaveLock = FALSE;
    int i;

    if (InitializationLock.Lock())
        fHaveLock = TRUE;
    else
        goto done;

    if (pModule->_hDllHandle == NULL)
    {
        retVal = TRUE;
        goto done;
    }

    for (i = 0; i < pModule->_iFunctionMapSize; i++)
        *(pModule->_pFunctionMap[i].ppfuncAddress) = NULL;
    
    if (NULL != pModule->_hDllHandle)
    {
        FreeLibrary(pModule->_hDllHandle);
        pModule->_hDllHandle = NULL;
    }

    retVal = TRUE;

done:
    if (fHaveLock)
        InitializationLock.Unlock();
    
    return retVal;    
}



//
//
//   Ole32.dll import information
//
//

//  From Ole32.dll, the following function pointers are loaded:
LPVOID (__stdcall *g_pfnCoTaskMemAlloc)(IN SIZE_T cb) = NULL;
HRESULT (__stdcall *g_pfnCLSIDFromString)(IN LPOLESTR lpsz, OUT LPCLSID pclsid) = NULL;
HRESULT (__stdcall *g_pfnCoCreateInstance)(IN REFCLSID rclsid, IN LPUNKNOWN pUnkOuter, IN DWORD dwClsContext, IN REFIID riid, OUT LPVOID FAR* ppv) = NULL;
HRESULT (__stdcall *g_pfnGetHGlobalFromStream)(IStream *pstm,HGLOBAL *phglobal) = NULL;
HRESULT (__stdcall *g_pfnCreateStreamOnHGlobal)(HGLOBAL hGlobal,BOOL fDeleteOnRelease,LPSTREAM *ppstm) = NULL;
HRESULT (__stdcall *g_pfnCoInitializeEx)(IN LPVOID pvReserved, IN DWORD dwCoInit) = NULL;
void (__stdcall *g_pfnCoUninitialize)(void) = NULL;

DL_FUNCTIONMAP Ole32Functions[] =
{
    {"CLSIDFromString", (FARPROC*)&g_pfnCLSIDFromString},
    {"CoCreateInstance", (FARPROC*)&g_pfnCoCreateInstance},
    {"CoTaskMemAlloc", (FARPROC*)&g_pfnCoTaskMemAlloc},
    {"GetHGlobalFromStream", (FARPROC*)&g_pfnGetHGlobalFromStream},
    {"CreateStreamOnHGlobal", (FARPROC*)&g_pfnCreateStreamOnHGlobal},
    {"CoInitializeEx", (FARPROC*)&g_pfnCoInitializeEx},
    {"CoUninitialize", (FARPROC*)&g_pfnCoUninitialize},
};

DL_MODULE g_moduleOle32( "ole32.dll", Ole32Functions, ARRAY_SIZE(Ole32Functions));



//
//
//   OleAut32.dll import information
//
//

//  From OleAut32.dll, the following function pointers are loaded:
HRESULT (__stdcall *g_pfnRegisterTypeLib)(ITypeLib * ptlib, OLECHAR  *szFullPath, OLECHAR  *szHelpDir);
HRESULT (__stdcall *g_pfnLoadTypeLib)(const OLECHAR *szFile, ITypeLib ** pptlib);
HRESULT (__stdcall *g_pfnUnRegisterTypeLib)(REFGUID libID, WORD wVerMajor, WORD wVerMinor, LCID lcid, SYSKIND syskind);
HRESULT (__stdcall *g_pfnDispGetParam)(DISPPARAMS * pdispparams, UINT position, VARTYPE vtTarg, VARIANT * pvarResult, UINT * puArgErr);
void (__stdcall *g_pfnVariantInit)(VARIANTARG * pvarg);
HRESULT (__stdcall *g_pfnVariantClear)(VARIANTARG * pvarg);
HRESULT (__stdcall *g_pfnCreateErrorInfo)(ICreateErrorInfo ** pperrinfo);
HRESULT (__stdcall *g_pfnSetErrorInfo)(ULONG dwReserved, IErrorInfo * perrinfo);
HRESULT (__stdcall *g_pfnGetErrorInfo)(ULONG dwReserved, IErrorInfo ** pperrinfo);
BSTR (__stdcall *g_pfnSysAllocString)(const OLECHAR *);
BSTR (__stdcall *g_pfnSysAllocStringLen)(const OLECHAR *, UINT);
void (__stdcall *g_pfnSysFreeString)(BSTR);
HRESULT (__stdcall *g_pfnVariantChangeType)(VARIANTARG * pvargDest, VARIANTARG * pvarSrc, USHORT wFlags, VARTYPE vt);
HRESULT (__stdcall *g_pfnSafeArrayDestroy)(SAFEARRAY * psa);
SAFEARRAY* (__stdcall *g_pfnSafeArrayCreateVector)(VARTYPE vt, LONG lLbound, ULONG cElements);
HRESULT (__stdcall *g_pfnSafeArrayCopy)(SAFEARRAY * psa, SAFEARRAY ** ppsaOut);
HRESULT (__stdcall *g_pfnSafeArrayUnaccessData)(SAFEARRAY * psa);
HRESULT (__stdcall *g_pfnSafeArrayGetUBound)(SAFEARRAY * psa, UINT nDim, LONG * plUbound);
HRESULT (__stdcall *g_pfnSafeArrayGetLBound)(SAFEARRAY * psa, UINT nDim, LONG * plLbound);
UINT (__stdcall *g_pfnSafeArrayGetDim)(SAFEARRAY * psa);
HRESULT (__stdcall *g_pfnSafeArrayAccessData)(SAFEARRAY * psa, void HUGEP** ppvData);
HRESULT (__stdcall *g_pfnSafeArrayDestroyDescriptor)(SAFEARRAY * psa);
HRESULT (__stdcall *g_pfnSafeArrayCopyData)(SAFEARRAY *psaSource, SAFEARRAY *psaTarget);



//  These ordinals were taken from inetcore\mshtml\src\f3\oleaut32.c
DL_FUNCTIONMAP OleAut32Functions[] =
{
    {"RegisterTypeLib", (FARPROC*)&g_pfnRegisterTypeLib},
    {"LoadTypeLib", (FARPROC*)&g_pfnLoadTypeLib},
    {"UnRegisterTypeLib", (FARPROC*)&g_pfnUnRegisterTypeLib},
    {"DispGetParam", (FARPROC*)&g_pfnDispGetParam},
    {"VariantInit", (FARPROC*)&g_pfnVariantInit},
    {"VariantClear", (FARPROC*)&g_pfnVariantClear},
    {"CreateErrorInfo", (FARPROC*)&g_pfnCreateErrorInfo},
    {"SetErrorInfo", (FARPROC*)&g_pfnSetErrorInfo},
    {"GetErrorInfo", (FARPROC*)&g_pfnGetErrorInfo},
    {"SysAllocString", (FARPROC*)&g_pfnSysAllocString},
    {"SysAllocStringLen", (FARPROC*)&g_pfnSysAllocStringLen},
    {"SysFreeString", (FARPROC*)&g_pfnSysFreeString},
    {"VariantChangeType", (FARPROC*)&g_pfnVariantChangeType},
    {"SafeArrayDestroy", (FARPROC*)&g_pfnSafeArrayDestroy},
    {"SafeArrayCreateVector", (FARPROC*)&g_pfnSafeArrayCreateVector},
    {"SafeArrayCopy", (FARPROC*)&g_pfnSafeArrayCopy},
    {"SafeArrayUnaccessData", (FARPROC*)&g_pfnSafeArrayUnaccessData},
    {"SafeArrayGetUBound", (FARPROC*)&g_pfnSafeArrayGetUBound},
    {"SafeArrayGetLBound", (FARPROC*)&g_pfnSafeArrayGetLBound},
    {"SafeArrayGetDim", (FARPROC*)&g_pfnSafeArrayGetDim},
    {"SafeArrayAccessData", (FARPROC*)&g_pfnSafeArrayAccessData},
    {"SafeArrayDestroyDescriptor", (FARPROC*)&g_pfnSafeArrayDestroyDescriptor},
    {"SafeArrayCopyData", (FARPROC*)&g_pfnSafeArrayCopyData},
};

DL_MODULE g_moduleOleAut32( "oleaut32.dll", OleAut32Functions, ARRAY_SIZE(OleAut32Functions));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\priolist.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    priolist.cxx

Abstract:

    Contains prioritized, serialized list class implementation

    Contents:
        CPriorityList::Insert
        CPriorityList::Remove

Author:

    Richard L Firth (rfirth) 03-May-1997

Notes:

    Properly, the CPriorityList class should extend a CSerializedList class, but
    we don't currently have one, just a serialized list type (common\serialst.cxx).

    WARNING: Code in this module makes assumptions about the contents of a
    SERIALIZED_LIST

Revision History:

    03-May-1997 rfirth
        Created

--*/

#include <wininetp.h>

//
// class methods
//


DWORD
CPriorityList::Insert(
    IN CPriorityListEntry * pEntry
    )

/*++

Routine Description:

    Insert prioritized list entry into prioritized, serialized list

Arguments:

    pEntry  - pointer to prioritized list entry to add

Return Value:

    ERROR_SUCCESS

    ERROR_NOT_ENOUGH_MEMORY - returned when lock can't be acquired.

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                 None,
                 "CPriorityList::Insert",
                 "{%#x} %#x",
                 this,
                 pEntry
                 ));

    DWORD error = ERROR_SUCCESS;

    if (!Acquire())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    INET_ASSERT(!IsOnSerializedList(&m_List, pEntry->List()));
    INET_ASSERT(pEntry->Next() == NULL);
    INET_ASSERT(pEntry->Prev() == NULL);

    CPriorityListEntry * pCur;

    for (pCur = (CPriorityListEntry *)m_List.List.Flink;
         pCur != (CPriorityListEntry *)&m_List.List.Flink;
         pCur = (CPriorityListEntry *)pCur->Next()) {

        if (pCur->GetPriority() < pEntry->GetPriority()) {
            break;
        }
    }
    InsertHeadList(pCur->Prev(), pEntry->List());
    ++m_List.ElementCount;
    Release();

quit:
    DEBUG_LEAVE(error);

    return error;
}


DWORD
CPriorityList::Remove(
    IN CPriorityListEntry * pEntry
    )

/*++

Routine Description:

    Remove entry from prioritized serialized list

Arguments:

    pEntry  - address of entry to remove

Return Value:

    ERROR_SUCCESS

    ERROR_NOT_ENOUGH_MEMORY - returned when lock can't be acquired.
                              Note:  All current cases have already acquired the lock

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                 None,
                 "CPriorityList::Remove",
                 "{%#x} %#x",
                 this,
                 pEntry
                 ));

    DWORD dwError = ERROR_SUCCESS;

    if (Acquire())
    {

        INET_ASSERT(IsOnSerializedList(&m_List, pEntry->List()));

        pEntry->Remove();
        --m_List.ElementCount;
        Release();
    }
    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
    }

    DEBUG_LEAVE(dwError);
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\reslock.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    reslock.cxx

Abstract:

    Contains methods for RESOURCE_LOCK class

    Contents:
        RESOURCE_LOCK::Acquire()
        RESOURCE_LOCK::Release()

Author:

    Richard L Firth (rfirth) 18-Jun-1996

Revision History:

    18-Jun-1996 rfirth
        Created

--*/

#include <wininetp.h>

//
// class members
//

#ifdef OLD_VERSION


BOOL
RESOURCE_LOCK::Acquire(
    IN BOOL bExclusiveMode
    )

/*++

Routine Description:

    Acquires the resource protected by this lock. Acquires for non-exclusive
    (read) or exclusive (write) ownership

Arguments:

    bExclusiveMode  - TRUE if we are acquiring the resource for exclusive
                      (write) ownership

Return Value:

    BOOL
        TRUE    - resource is acquired

        FALSE   - failed to acquire resource (timeout?)

--*/

{
    DEBUG_ENTER((DBG_RESLOCK,
                Bool,
                "RESOURCE_LOCK::Acquire",
                "%B",
                bExclusiveMode
                ));

    INET_ASSERT(this != NULL);
    //INET_ASSERT(IsInitialized());
    //INET_ASSERT(IsValid());

    if (!IsInitialized()) {

        DEBUG_LEAVE(FALSE);

        return FALSE;
    }

    BOOL acquired = TRUE;

    //_CritSect.Lock();
    if (bExclusiveMode) {

        //
        // acquired for exclusive ownership (write access). Set the owning
        // thread id and wait for the last current reader to release. Note
        // that if we're being re-entered, the Lock() has already
        // done the work of checking the thread id and updating re-entrancy
        // counts, so if its already not zero, we know it must be us
        //

        ++_WriteCount;
        if (_ThreadId == 0) {
            _ThreadId = GetCurrentThreadId();
#if INET_DEBUG
            INET_ASSERT(_ThreadId != _ThreadIdReader);
#endif
            acquired = Wait(_hWriteEvent);
            _CritSect.Lock();
        } else {

            INET_ASSERT(_ThreadId == GetCurrentThreadId());

        }
    } else {

        //
        // don't allow re-entry if already held for exclusive access
        //

        INET_ASSERT(_ThreadId == 0);

        //
        // acquired for non-exclusive ownership (read access). Just increase
        // the number of active readers. If this is the first then inhibit the
        // writer
        //

        if (InterlockedIncrement(&_Readers) == 0) {
#if INET_DEBUG
            if (_ThreadIdReader == 0) {
                _ThreadIdReader = GetCurrentThreadId();
            }
#endif
            ResetEvent(_hWriteEvent);
        }

        //
        // reader doesn't need to keep hold of critical section
        //

        //_CritSect.Unlock();
    }

    DEBUG_LEAVE(acquired);

    return acquired;
}


VOID
RESOURCE_LOCK::Release(
    VOID
    )

/*++

Routine Description:

    Releases a resource previously acquired by RESOURCE_LOCK::Acquire()

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_RESLOCK,
                None,
                "RESOURCE_LOCK::Release",
                NULL
                ));

    INET_ASSERT(this != NULL);
    //INET_ASSERT(IsInitialized());
    //INET_ASSERT(IsValid());

    if (!IsInitialized()) {

        DEBUG_LEAVE(0);

        return;
    }

    if ((_ThreadId != 0) && (_ThreadId == GetCurrentThreadId())) {

        INET_ASSERT(_WriteCount > 0);

        if (--_WriteCount == 0) {

            //
            // we acquired _hWriteEvent; signal it to allow next writer to continue
            //

            SetEvent(_hWriteEvent);

            //
            // this resource no longer owned for exclusive access
            //

            _ThreadId = 0;
        }
        _CritSect.Unlock();
    } else if (InterlockedDecrement(&_Readers) < 0) {

        INET_ASSERT(_Readers >= -1);

        //
        // we are last currently active reader; allow waiting writer to continue
        //

#if INET_DEBUG
        if (_ThreadIdReader == GetCurrentThreadId()) {
            _ThreadIdReader = 0;
        }
#endif
        SetEvent(_hWriteEvent);
    }

    DEBUG_LEAVE(0);
}

#else

BOOL
RESOURCE_LOCK::Acquire(
    IN BOOL bExclusiveMode
    )
{
    DEBUG_ENTER((DBG_RESLOCK,
                Bool,
                "RESOURCE_LOCK::Acquire",
                "%B",
                bExclusiveMode
                ));

    BOOL fReturn = TRUE;

    if (!IsInitialized()) {

        fReturn = FALSE;
        goto quit;
    }

    if (bExclusiveMode) {
        do {

            DEBUG_PRINT(RESLOCK,
                        INFO,
                        ("Waiting on WriteEvent\n")
                        );

            if (_ThreadId != GetCurrentThreadId()) {
                Wait(_hWriteEvent);
            }
            
            if (!_CritSect.Lock())
            {
                DEBUG_PRINT(RESLOCK,
                            ERROR,
                            ("Failed to obtain critsec lock after waiting on WriteEvent\n")
                            );
                fReturn = FALSE;
                break;
            }

            INET_ASSERT((_ThreadId == 0) || (_ThreadId == GetCurrentThreadId()));

            if ((_Readers == -1)
                && ((_ThreadId == 0) || (_ThreadId == GetCurrentThreadId()))) {
                _ThreadId = GetCurrentThreadId();
                if (++_WriteCount == 1) {
                    ResetEvent(_hWriteEvent);
                }
                break;
            }

            DEBUG_PRINT(RESLOCK,
                        INFO,
                        ("trying again\n")
                        );

            _CritSect.Unlock();
        } while ( 1 );
    } else {
        if (_CritSect.Lock()) {
            if (++_Readers == 0) {

                DEBUG_PRINT(RESLOCK,
                            INFO,
                            ("Resetting WriteEvent\n")
                            );

                ResetEvent(_hWriteEvent);
            }
            _CritSect.Unlock();
        }
        else {
            DEBUG_PRINT(RESLOCK,
                        ERROR,
                        ("Failed to obtain critsec lock after waiting on WriteEvent\n")
                        );
            fReturn = FALSE;
        }
    }

quit:
    DEBUG_LEAVE(fReturn);

    return fReturn;
}

VOID
RESOURCE_LOCK::Release(
    VOID
    )
{
    DEBUG_ENTER((DBG_RESLOCK,
                None,
                "RESOURCE_LOCK::Release",
                NULL
                ));

    if (IsInitialized()) {
        if (_ThreadId == GetCurrentThreadId()) {

            DEBUG_PRINT(RESLOCK,
                        INFO,
                        ("Clearing writer\n")
                        );

            if (--_WriteCount == 0) {
                _ThreadId = 0;
                SetEvent(_hWriteEvent);
            }
            _CritSect.Unlock();
        } else {
            if (_CritSect.Lock()) {
                if (--_Readers == -1) {

                    DEBUG_PRINT(RESLOCK,
                                INFO,
                                ("Setting WriteEvent\n")
                                );

                    SetEvent(_hWriteEvent);
                }
                _CritSect.Unlock();
            }
            else {
                DEBUG_PRINT(RESLOCK,
                            INFO,
                            ("Couldn't set WriteEvent due to not enough memory\n")
                            );
            }
        }
    }

    DEBUG_LEAVE(0);
}

#endif // OLD_VERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\iwinsock.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    iwinsock.cxx

Abstract:

    Contains functions to load sockets DLL and entry points. Functions and data
    in this module take care of indirecting sockets calls, hence _I_ in front
    of the function name

    Contents:
        IwinsockInitialize
        IwinsockTerminate
        LoadWinsock
        UnloadWinsock
        SafeCloseSocket

Author:

    Richard L Firth (rfirth) 12-Apr-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    12-Apr-1995 rfirth
        Created

    08-May-1996 arthurbi
        Added support for Socks Firewalls.

    05-Mar-1998 rfirth
        Moved SOCKS support into ICSocket class. Removed SOCKS library
        loading/unloading from this module (revert to pre-SOCKS)

--*/

#include <wininetp.h>

#if defined(__cplusplus)
extern "C" {
#endif

#if INET_DEBUG

#if defined(RETAIL_LOGGING)
#define DPRINTF (void)
#else
#define DPRINTF dprintf
#endif

BOOL
InitDebugSock(
    VOID
    );

VOID
TerminateDebugSock(
    VOID
    );

#else
#define DPRINTF (void)
#endif

//
// private types
//

typedef struct {
    LPSTR FunctionOrdinal;
    FARPROC * FunctionAddress;
} SOCKETS_FUNCTION;


//
// global data
//

GLOBAL
SOCKET
(PASCAL FAR * _I_accept)(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_bind)(
    SOCKET s,
    const struct sockaddr FAR *addr,
    int namelen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_closesocket)(
    SOCKET s
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_connect)(
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_gethostname)(
    char FAR * name,
    int namelen
    ) = NULL;

GLOBAL
LPHOSTENT
(PASCAL FAR * _I_gethostbyname)(
    const char FAR * lpHostName
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_getsockname)(
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_getsockopt)(
    SOCKET s,
    int level,
    int optname,
    char FAR * optval,
    int FAR *optlen
    );

GLOBAL
u_long
(PASCAL FAR * _I_htonl)(
    u_long hostlong
    ) = NULL;

GLOBAL
u_short
(PASCAL FAR * _I_htons)(
    u_short hostshort
    ) = NULL;

GLOBAL
unsigned long
(PASCAL FAR * _I_inet_addr)(
    const char FAR * cp
    ) = NULL;

GLOBAL
char FAR *
(PASCAL FAR * _I_inet_ntoa)(
    struct in_addr in
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_ioctlsocket)(
    SOCKET s,
    long cmd,
    u_long FAR *argp
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_listen)(
    SOCKET s,
    int backlog
    ) = NULL;

GLOBAL
u_short
(PASCAL FAR * _I_ntohs)(
    u_short netshort
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_recv)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags
    ) = NULL;

GLOBAL
int 
(PASCAL FAR * _I_WSARecv)(
    SOCKET s,                                               
    LPWSABUF lpBuffers,                                     
    DWORD dwBufferCount,                                    
    LPDWORD lpNumberOfBytesRecvd,                           
    LPDWORD lpFlags,                                        
    LPWSAOVERLAPPED lpOverlapped,                           
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine  
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_recvfrom)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags,
    struct sockaddr FAR *from, 
    int FAR * fromlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_select)(
    int nfds,
    fd_set FAR *readfds,
    fd_set FAR *writefds,
    fd_set FAR *exceptfds,
    const struct timeval FAR *timeout
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_send)(
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_WSASend)(
    SOCKET s,                                                  
    LPWSABUF lpBuffers,                                     
    DWORD dwBufferCount,                                    
    LPDWORD lpNumberOfBytesSent,                            
    DWORD dwFlags,                                          
    LPWSAOVERLAPPED lpOverlapped,                           
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine  
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_sendto)(
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags,
    const struct sockaddr FAR *to, 
    int tolen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_setsockopt)(
    SOCKET s,
    int level,
    int optname,
    const char FAR * optval,
    int optlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_shutdown)(
    SOCKET s,
    int how
    ) = NULL;

GLOBAL
SOCKET
(PASCAL FAR * _I_socket)(
    int af,
    int type,
    int protocol
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_WSAStartup)(
    WORD wVersionRequired,
    LPWSADATA lpWSAData
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_WSACleanup)(
    void
    ) = NULL;

//VENKATKBUG-remove later - for now trap any errors 
GLOBAL
int
(PASCAL FAR * __I_WSAGetLastError)(
    void
    ) = NULL;


int
___I_WSAGetLastError(
    VOID
    )
{
    int nError = __I_WSAGetLastError();
/*
    VENKATK_BUG - OK to have WSAENOTSOCK - could happen for timeout situations.
    INET_ASSERT (nError != WSAENOTSOCK);
 */
    return nError;
}


GLOBAL
int
(PASCAL FAR * _I_WSAGetLastError)(
    void
    ) = ___I_WSAGetLastError;
    
GLOBAL
void
(PASCAL FAR * _I_WSASetLastError)(
    int iError
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I___WSAFDIsSet)(
    SOCKET,
    fd_set FAR *
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_getaddrinfo)(
    IN const char FAR * nodename,
    IN const char FAR * servname,
    IN const struct addrinfo FAR * hints,
    OUT struct addrinfo FAR * FAR * res
    ) = NULL;

GLOBAL
void
(PASCAL FAR * _I_freeaddrinfo)(
    IN struct addrinfo *ai
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_getnameinfo)(
    IN const struct sockaddr FAR * sa,
    IN socklen_t salen,
    OUT char FAR * host,
    IN size_t hostlen,
    OUT char FAR * serv,
    IN size_t servlen,
    IN int flags
    ) = NULL;

GLOBAL
INT
(PASCAL FAR * _I_WSAStringToAddressA)(
    IN     LPSTR               AddressString,
    IN     INT                 AddressFamily,
    IN     LPWSAPROTOCOL_INFOA lpProtocolInfo,
    OUT    LPSOCKADDR          lpAddress,
    IN OUT LPINT               lpAddressLength
    );

GLOBAL
INT
(PASCAL FAR * _I_WSAStringToAddressW)(
    IN     LPWSTR              AddressString,
    IN     INT                 AddressFamily,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    OUT    LPSOCKADDR          lpAddress,
    IN OUT LPINT               lpAddressLength
    );

GLOBAL
INT
(PASCAL FAR * _I_WSAAddressToStringA)(
    IN     LPSOCKADDR          lpsaAddress,
    IN     DWORD               dwAddressLength,
    IN     LPWSAPROTOCOL_INFOA lpProtocolInfo,
    IN OUT LPSTR               lpszAddressString,
    IN OUT LPDWORD             lpdwAddressStringLength
    );

#if INET_DEBUG

void SetupSocketsTracing(void);

#endif

//
// private data
//

//
// InitializationLock - protects against multiple threads loading WSOCK32.DLL
// and entry points
//

PRIVATE CCritSec InitializationLock;

//
// hWinsock - NULL when WSOCK32.DLL is not loaded
// hAddrResLib - NULL when WS2_32.DLL/WSHIPV6.DLL is not loaded
//

PRIVATE HINSTANCE hWinsock = NULL;
PRIVATE HINSTANCE hAddrResLib = NULL;

//
// WinsockLoadCount - the number of times we have made calls to LoadWinsock()
// and UnloadWinsock(). When this reaches 0 (again), we can unload the Winsock
// DLL for real
//

PRIVATE DWORD WinsockLoadCount = 0;

//
// SocketsFunctions - this is the list of entry points in WSOCK32.DLL that we
// need to load for WinHttp.DLL
//

PRIVATE
SOCKETS_FUNCTION
SocketsFunctions[] = {
    "accept",           (FARPROC*)&_I_accept,
    "bind",             (FARPROC*)&_I_bind,
    "closesocket",      (FARPROC*)&_I_closesocket,
    "connect",          (FARPROC*)&_I_connect,
    "getsockname",      (FARPROC*)&_I_getsockname,
    "getsockopt",       (FARPROC*)&_I_getsockopt,
    "htonl",            (FARPROC*)&_I_htonl,
    "htons",            (FARPROC*)&_I_htons,

    "inet_addr",        (FARPROC*)&_I_inet_addr,
    "inet_ntoa",        (FARPROC*)&_I_inet_ntoa,
    "ioctlsocket",      (FARPROC*)&_I_ioctlsocket,

    "listen",           (FARPROC*)&_I_listen,
    "ntohs",            (FARPROC*)&_I_ntohs,
    "recv",             (FARPROC*)&_I_recv,
    "recvfrom",         (FARPROC*)&_I_recvfrom,
    "select",           (FARPROC*)&_I_select,
    "send",             (FARPROC*)&_I_send,
    "sendto",           (FARPROC*)&_I_sendto,
    "setsockopt",       (FARPROC*)&_I_setsockopt,
    "shutdown",         (FARPROC*)&_I_shutdown,
    "socket",           (FARPROC*)&_I_socket,
    "gethostbyname",    (FARPROC*)&_I_gethostbyname,
    "gethostname",      (FARPROC*)&_I_gethostname,
    "WSAGetLastError",  (FARPROC*)&__I_WSAGetLastError,
    "WSASetLastError",  (FARPROC*)&_I_WSASetLastError,
    "WSAStartup",       (FARPROC*)&_I_WSAStartup,
    "WSACleanup",       (FARPROC*)&_I_WSACleanup,
    "__WSAFDIsSet",     (FARPROC*)&_I___WSAFDIsSet,
    "WSARecv",          (FARPROC*)&_I_WSARecv,
    "WSASend",          (FARPROC*)&_I_WSASend,
    "WSAStringToAddressA",  (FARPROC*)&_I_WSAStringToAddressA,
    "WSAStringToAddressW",  (FARPROC*)&_I_WSAStringToAddressW,
    "WSAAddressToStringA",  (FARPROC*)&_I_WSAAddressToStringA,
};


//
// private prototypes
//

#if INET_DEBUG

void SetupSocketsTracing(void);

#endif

int
PASCAL FAR
LimitedGetAddrInfo(
    IN const char FAR * nodename,
    IN const char FAR * servname,
    IN const struct addrinfo FAR * hints,
    OUT struct addrinfo FAR * FAR * res
    );

void
PASCAL FAR
LimitedFreeAddrInfo(
    IN struct addrinfo *ai
    );

int
PASCAL FAR
LimitedGetNameInfo(
    IN const struct sockaddr FAR * sa,
    IN socklen_t salen,
    OUT char FAR * host,
    IN size_t hostlen,
    OUT char FAR * serv,
    IN size_t servlen,
    IN int flags
    );

//
// functions
//


BOOL
IwinsockInitialize(
    VOID
    )

/*++

Routine Description:

    Performs initialization/resource allocation for this module

Arguments:

    None.

Return Value:

    None.

--*/

{
    BOOL fResult;
    //
    // initialize the critical section that protects against multiple threads
    // trying to initialize Winsock
    //

    fResult = InitializationLock.Init();

#if INET_DEBUG
    if (fResult)
        fResult = InitDebugSock();
#endif

    return fResult;
}


VOID
IwinsockTerminate(
    VOID
    )

/*++

Routine Description:

    Performs termination & resource cleanup for this module

Arguments:

    None.

Return Value:

    None.

--*/

{
    InitializationLock.FreeLock();

#if INET_DEBUG
    TerminateDebugSock();
#endif
}


DWORD
LoadWinsock(
    VOID
    )

/*++

Routine Description:

    Dynamically loads Windows sockets library

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error
                    e.g. LoadLibrary() failure

                  WSA error
                    e.g. WSAStartup() failure

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Dword,
                "LoadWinsock",
                NULL
                ));

    DWORD error = ERROR_SUCCESS;

    //
    // ensure no 2 threads are trying to modify the loaded state of winsock at
    // the same time
    //

    if (!InitializationLock.Lock())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if (hWinsock == NULL) {

        BOOL failed = FALSE;

        //
        // BUGBUG - read this value from registry
        //

        hWinsock = LoadLibrary("ws2_32");
        
        if (hWinsock == NULL) {
            
            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("failed to load ws2_32.dll"));
            
            hWinsock = LoadLibrary("wsock32");
        }
        
        if (hWinsock != NULL) {

            //
            // load the entry points
            //

            FARPROC farProc = NULL;

            for (int i = 0; i < ARRAY_ELEMENTS(SocketsFunctions); ++i) {

                farProc = GetProcAddress(
                                hWinsock,
                                (LPCSTR)SocketsFunctions[i].FunctionOrdinal
                                );
                if (farProc == NULL) {
                    failed = TRUE;
                    break;
                }
                *SocketsFunctions[i].FunctionAddress = farProc;
            }
            if (!failed) {

                //
                // although we need a WSADATA for WSAStartup(), it is an
                // expendible structure (not required for any other sockets
                // calls)
                //

                WSADATA wsaData;

                error = _I_WSAStartup(0x0101, &wsaData);
                if (error == ERROR_SUCCESS) {

                    DEBUG_PRINT(SOCKETS,
                                INFO,
                                ("winsock description: %q\n",
                                wsaData.szDescription
                                ));

                    int stringLen;

                    stringLen = lstrlen(wsaData.szDescription);
                    if (strnistr(wsaData.szDescription, "novell", stringLen)
                    && strnistr(wsaData.szDescription, "wsock32", stringLen)) {

                        DEBUG_PRINT(SOCKETS,
                                    INFO,
                                    ("running on Novell Client32 stack\n"
                                    ));

                        GlobalRunningNovellClient32 = TRUE;
                    }
#if INET_DEBUG
                    SetupSocketsTracing();
#endif
                    //
                    // Try to locate the address family independent name
                    // resolution routines (i.e. getaddrinfo, getnameinfo).
                    // In Whistler and beyond, these will be present in
                    // the WinSock 2 library (ws2_32.dll).
                    //
                    DPRINTF("Looking in ws2_32 for getaddrinfo\n");
                    hAddrResLib = LoadLibrary("ws2_32");
                    if (hAddrResLib != NULL) {
                        farProc = GetProcAddress(hAddrResLib, "getaddrinfo");
                        if (farProc == NULL) {
                            FreeLibrary(hAddrResLib);
                            hAddrResLib = NULL;
                        }
                    }

                    if (hAddrResLib == NULL) {
                        //
                        // In the IPv6 Technology Preview, the address family
                        // independent name resolution calls are snuck in via
                        // the IPv6 WinSock helper library (wship6.dll).
                        // So look there next.
                        //
                        DPRINTF("Looking in wship6 for getaddrinfo\n");
                        hAddrResLib = LoadLibrary("wship6");
                        if (hAddrResLib != NULL) {
                            farProc = GetProcAddress(hAddrResLib,
                                                     "getaddrinfo");
                            if (farProc == NULL) {
                                FreeLibrary(hAddrResLib);
                                hAddrResLib = NULL;

                            } else {
                                //
                                // The Tech Preview version of the address
                                // family independent APIs doesn't check that
                                // an IPv6 stack is present before returning
                                // IPv6 addresses.  So we need to check for it.
                                //
                                SOCKET Test;
                                struct sockaddr_in6 TestSA;

                                DPRINTF("Checking for active IPv6 stack\n");
                                error = (DWORD)SOCKET_ERROR;
                                Test = _I_socket(PF_INET6, 0, 0);
                                if (Test != INVALID_SOCKET) {
                                    memset(&TestSA, 0, sizeof(TestSA));
                                    TestSA.sin6_family = AF_INET6;
                                    TestSA.sin6_addr.s6_addr[15] = 1;
                                    error = _I_bind(Test, (LPSOCKADDR)&TestSA,
                                                    sizeof(TestSA));
                                    _I_closesocket(Test);
                                }
                                if (error != 0) {
                                    DPRINTF("IPv6 stack is not active\n");
                                    FreeLibrary(hAddrResLib);
                                    hAddrResLib = NULL;
                                    error = 0;
                                }
                            }
                        }
                    }

                    if (hAddrResLib != NULL) {
                        //
                        // Use routines from this library.  Since getaddrinfo
                        // is here, we expect the others to be also, but will
                        // fall back to IPv4-only if any of them is missing.
                        //
                        *(FARPROC *)&_I_getaddrinfo = farProc;
                        farProc = GetProcAddress(hAddrResLib, "freeaddrinfo");
                        if (farProc != NULL) {
                            *(FARPROC *)&_I_freeaddrinfo = farProc;
                            farProc = GetProcAddress(hAddrResLib,
                                                     "getnameinfo");
                            if (farProc != NULL)
                                *(FARPROC *)&_I_getnameinfo = farProc;
                        }
                        if (farProc == NULL) {
                            FreeLibrary(hAddrResLib);
                            hAddrResLib = NULL;
                        }
                    }

                    if (hAddrResLib == NULL) {
                        //
                        // If we can't find getaddrinfo lying around on the
                        // system somewhere, assume we're still in the
                        // IPv4-only dark ages.
                        //
                        DPRINTF("Using IPv4-only name res functions\n");
                        _I_getaddrinfo = LimitedGetAddrInfo;
                        _I_freeaddrinfo = LimitedFreeAddrInfo;
                        _I_getnameinfo = LimitedGetNameInfo;
                    }
                } else {
                    failed = TRUE;
                }
            }
        } else {
            failed = TRUE;
        }

        //
        // if we failed to find an entry point or WSAStartup() returned an error
        // then unload the library
        //

        if (failed) {

            //
            // important: there should be no API calls between determining the
            // failure and coming here to get the error code
            //
            // if error == ERROR_SUCCESS then we have to get the last error, else
            // it is the error returned by WSAStartup()
            //

            if (error == ERROR_SUCCESS) {
                error = GetLastError();

                INET_ASSERT(error != ERROR_SUCCESS);

            }
            UnloadWinsock();
        }
    } else {

        //
        // just increment the number of times we have called LoadWinsock()
        // without a corresponding call to UnloadWinsock();
        //

        ++WinsockLoadCount;
    }

    InitializationLock.Unlock();

    //
    // if we failed for any reason, need to report that TCP/IP not available
    //

    if (error != ERROR_SUCCESS) {
        error = ERROR_NOT_SUPPORTED;
    }

quit:
    DEBUG_LEAVE(error);

    return error;
}


VOID
UnloadWinsock(
    BOOL fOverrideRefCount  //  mark TRUE to override the internal ref count on Winsock and always blow it away.
    )

/*++

Routine Description:

    Unloads winsock DLL and prepares hWinsock and SocketsFunctions[] for reload

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "UnloadWinsock",
                 NULL
                 ));

    //
    // ensure no 2 threads are trying to modify the loaded state of winsock at
    // the same time
    //

    if (!InitializationLock.Lock())
    {
        goto quit;
    }

        //
        // and only if this is the last load instance or we're overriding the ref count
        //

    if (WinsockLoadCount == 0
        || fOverrideRefCount == TRUE) {

        //
        // and only if this is the last load instance
        //

        if (WinsockLoadCount == 0) {

            if (_I_WSACleanup != NULL) {

                //
                // need to terminate async support too - it is reliant on
                // Winsock
                //

                //called only from LoadWinsock which is called only from INTERNET_HANDLE_OBJECT()
                //so not in dynamic unload, so alrite to cleanup.
                TerminateAsyncSupport(TRUE);

                int serr = _I_WSACleanup();

                if (serr != 0) {

                    DEBUG_PRINT(SOCKETS,
                                ERROR,
                                ("WSACleanup() returns %d; WSA error = %d\n",
                                serr,
                                (_I_WSAGetLastError != NULL)
                                    ? _I_WSAGetLastError()
                                    : -1
                                ));

                }
            }
            for (int i = 0; i < ARRAY_ELEMENTS(SocketsFunctions); ++i) {
                *SocketsFunctions[i].FunctionAddress = (FARPROC)NULL;
            }
            FreeLibrary(hWinsock);
            hWinsock = NULL;
            if (hAddrResLib != NULL) {
                *(FARPROC *)&_I_getaddrinfo = (FARPROC)NULL;
                *(FARPROC *)&_I_freeaddrinfo = (FARPROC)NULL;
                *(FARPROC *)&_I_getnameinfo = (FARPROC)NULL;
                FreeLibrary(hAddrResLib);
                hAddrResLib = NULL;
            }
        } else {

            //
            // if there have been multiple virtual loads, then just reduce the
            // load count
            //

            --WinsockLoadCount;
        }
    }

    InitializationLock.Unlock();

quit:
    DEBUG_LEAVE(0);
}

//
// Following is v4-only version of getaddrinfo and friends.
//
// Note that we use LocalAlloc/LocalFree instead of malloc/free
// to avoid introducing a dependency on msvcrt.dll.
//


//* LimitedFreeAddrInfo - Free an addrinfo structure (or chain of structures).
//
//  As specified in RFC 2553, Section 6.4.
//
void WSAAPI
LimitedFreeAddrInfo(
    struct addrinfo *Free)  // Structure (chain) to free.
{
    struct addrinfo *Next;

    for (Next = Free; Next != NULL; Free = Next) {
        if (Free->ai_canonname != NULL)
            FREE_MEMORY(Free->ai_canonname);
        if (Free->ai_addr != NULL)
            FREE_MEMORY(Free->ai_addr);
        Next = Free->ai_next;
        FREE_MEMORY(Free);
    }
}


//* NewAddrInfo - Allocate an addrinfo structure and populate some fields.
//
//  Internal function, not exported.  Expects to be called with valid
//  arguments, does no checking.
//
//  Returns a partially filled-in addrinfo struct, or NULL if out of memory.
//
static struct addrinfo *
NewAddrInfo(
    int SocketType,           // SOCK_*.  Can be wildcarded (zero).
    int Protocol,             // IPPROTO_*.  Can be wildcarded (zero).
    struct addrinfo ***Prev)  // In/out param for accessing previous ai_next.
{
    struct addrinfo *pNew;

    //
    // Allocate a new addrinfo structure.
    //
    pNew = (struct addrinfo *)ALLOCATE_FIXED_MEMORY(sizeof(struct addrinfo));
    if (pNew == NULL)
        return NULL;

    //
    // Fill in the easy stuff.
    //
    pNew->ai_flags = 0;
    pNew->ai_family = PF_INET;
    pNew->ai_socktype = SocketType;
    pNew->ai_protocol = Protocol;
    pNew->ai_addrlen = sizeof(struct sockaddr_in);
    pNew->ai_canonname = NULL;
    pNew->ai_addr = (LPSOCKADDR)ALLOCATE_FIXED_MEMORY(pNew->ai_addrlen);
    if (pNew->ai_addr == NULL) {
        FREE_MEMORY(pNew);
        return NULL;
    }
    pNew->ai_next = NULL;

    //
    // Link this one onto the end of the chain.
    //
    **Prev = pNew;
    *Prev = &pNew->ai_next;

    return pNew;
}


//* LookupNode - Resolve a nodename and add any addresses found to the list.
//
//  Internal function, not exported.  Expects to be called with valid
//  arguments, does no checking.
//
//  Returns 0 on success, an EAI_* style error value otherwise.
//
static int
LookupNode(
    const char *NodeName,     // Name of node to resolve.
    int SocketType,           // SOCK_*.  Can be wildcarded (zero).
    int Protocol,             // IPPROTO_*.  Can be wildcarded (zero).
    int Flags,                // Flags.
    struct addrinfo ***Prev)  // In/out param for accessing previous ai_next.
{
    struct addrinfo *CurrentInfo;
    struct sockaddr_in *sin;
    struct hostent *hA;
    char **addrs;
    int Error = 0;

    hA = _I_gethostbyname(NodeName);
    if (hA != NULL) {
        if ((hA->h_addrtype == AF_INET) &&
            (hA->h_length == sizeof(struct in_addr))) {

            //
            // Loop through all the addresses returned by gethostbyname,
            // allocating an addrinfo structure and filling in the address
            // field for each.
            //
            for (addrs = hA->h_addr_list; *addrs != NULL; addrs++) {

                CurrentInfo = NewAddrInfo(SocketType, Protocol, Prev);
                if (CurrentInfo == NULL) {
                    Error = EAI_MEMORY;
                    break;
                }

                //
                // We fill in the ai_canonname field in the first addrinfo
                // structure that we return if we've been asked to do so.
                //
                if (Flags & AI_CANONNAME) {
                    if (hA->h_name != NULL) {
                        int NameLength;

                        NameLength = strlen(hA->h_name) + 1;
                        CurrentInfo->ai_canonname = (char *)ALLOCATE_FIXED_MEMORY(NameLength);
                        if (CurrentInfo->ai_canonname == NULL) {
                            Error = EAI_MEMORY;
                            break;
                        }
                        memcpy(CurrentInfo->ai_canonname, hA->h_name, NameLength);
                    }

                    // Turn off flag so we only do this once.
                    Flags &= ~AI_CANONNAME;
                }

                //
                // We're returning IPv4 addresses.
                //
                sin = (struct sockaddr_in *)CurrentInfo->ai_addr;
                sin->sin_family = AF_INET;
                sin->sin_port = 0;
                memcpy(&sin->sin_addr, (struct in_addr *)*addrs, sizeof(sin->sin_addr));
                memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
            }
        }
    } else {

        Error = _I_WSAGetLastError();
        if (Error == WSANO_DATA) {
            Error = EAI_NODATA;
        } else if (Error == WSAHOST_NOT_FOUND) {
            Error = EAI_NONAME;
        } else {
            Error = EAI_FAIL;
        }
    }

    return Error;
}


//* ParseV4Address
//
//  Helper function for parsing a literal v4 address, because
//  WSAStringToAddress is too liberal in what it accepts.
//  Returns FALSE if there is an error, TRUE for success.
//
//  The syntax is a.b.c.d, where each number is between 0 - 255.
//
static int
ParseV4Address(const char *String, struct in_addr *Addr)
{
    u_int Number;
    int NumChars;
    char Char;
    int i;

    for (i = 0; i < 4; i++) {
        Number = 0;
        NumChars = 0;
        for (;;) {
            Char = *String++;
            if (Char == '\0') {
                if ((NumChars > 0) && (i == 3))
                    break;
                else
                    return FALSE;
            }
            else if (Char == '.') {
                if ((NumChars > 0) && (i < 3))
                    break;
                else
                    return FALSE;
            }
            else if (('0' <= Char) && (Char <= '9')) {
                if ((NumChars != 0) && (Number == 0))
                    return FALSE;
                else if (++NumChars <= 3)
                    Number = 10 * Number + (Char - '0');
                else
                    return FALSE;
            } else
                return FALSE;
        }
        if (Number > 255)
            return FALSE;
        ((u_char *)Addr)[i] = (u_char)Number;
    }

    return TRUE;
}


//* LimitedGetAddrInfo - Protocol-independent name-to-address translation.
//
//  As specified in RFC 2553, Section 6.4.
//
//  This is the hacked version that only supports IPv4.
//
//  Returns zero if successful, an EAI_* error code if not.
//
int WSAAPI
LimitedGetAddrInfo(
    const char *NodeName,          // Node name to lookup.
    const char *ServiceName,       // Service name to lookup.
    const struct addrinfo *Hints,  // Hints about how to process request.
    struct addrinfo **Result)      // Where to return result.
{
    struct addrinfo *CurrentInfo, **Next;
    int ProtocolId = 0;
    u_short ProtocolFamily = PF_UNSPEC;
    int SocketType = 0;
    int Flags = 0;
    int Error;
    struct sockaddr_in *sin;
    struct in_addr TempAddr;

    UNREFERENCED_PARAMETER(ServiceName);

    //
    // This special cut-down version for WinHttp doesn't do service lookup.
    // So the request must be for nodename lookup.
    //
    INET_ASSERT(ServiceName == NULL);
    INET_ASSERT(NodeName != NULL);

    //
    // In case we have to bail early, make it clear to our caller
    // that we haven't allocated an addrinfo structure.
    //
    *Result = NULL;
    Next = Result;

    //
    // Validate hints argument.
    //
    if (Hints != NULL) {
        //
        // WinHttp can be trusted to call us correctly.
        //
        INET_ASSERT((Hints->ai_addrlen == 0) &&
                    (Hints->ai_canonname == NULL) &&
                    (Hints->ai_addr == NULL) &&
                    (Hints->ai_next == NULL));

        Flags = Hints->ai_flags;
        INET_ASSERT(!((Flags & AI_CANONNAME) && (Flags & AI_NUMERICHOST)));

        ProtocolFamily = (u_short)Hints->ai_family;
        INET_ASSERT((ProtocolFamily == PF_UNSPEC) ||
                    (ProtocolFamily == PF_INET));

        SocketType = Hints->ai_socktype;
        INET_ASSERT((SocketType == 0) ||
                    (SocketType == SOCK_STREAM) ||
                    (SocketType == SOCK_DGRAM));

        ProtocolId = Hints->ai_protocol;
    }

    //
    // We have a node name (either alpha or numeric) we need to look up.
    //

    //
    // First, see if this is a numeric string address that we can
    // just convert to a binary address.
    //
    if (ParseV4Address(NodeName, &TempAddr)) {
        //
        // Conversion from IPv4 numeric string to binary address
        // was sucessfull.  Create an addrinfo structure to hold it,
        // and return it to the user.
        //
        CurrentInfo = NewAddrInfo(SocketType, ProtocolId, &Next);
        if (CurrentInfo == NULL) {
            Error = EAI_MEMORY;
            goto Bail;
        }
        sin = (struct sockaddr_in *)CurrentInfo->ai_addr;
        sin->sin_family = AF_INET;
        sin->sin_port = 0;
        sin->sin_addr = TempAddr;
        memset(sin->sin_zero, 0, sizeof sin->sin_zero);

        return 0;  // Success!
    }

    //
    // It's not a numeric string address.  If our caller only wants us
    // to convert numeric addresses, give up now.
    //
    if (Flags & AI_NUMERICHOST) {
        Error = EAI_NONAME;
        goto Bail;
    }

    //
    // Since it's non-numeric, we have to do a regular node name lookup.
    //
    Error = LookupNode(NodeName, SocketType, ProtocolId, Flags, &Next);
    if (Error != 0)
        goto Bail;

    return 0;  // Success!

  Bail:
    if (*Result != NULL) {
        LimitedFreeAddrInfo(*Result);
        *Result = NULL;
    }
    return Error;
}


//* LimitedGetNameInfo - Protocol-independent address-to-name translation.
//
//  As specified in RFC 2553, Section 6.5.
//
//  This is a special version for WinHttp that only supports IPv4.
//  All extraneous checks have been removed, only the specific calls
//  that WinHttp makes are supported.
//
//  Note that unless the IE team decides to attempt the FTP EPRT command
//  for IPv4 as well as IPv6 (see comments in ftp\protocol.cxx), this
//  routine will never be called.
//
int WSAAPI
LimitedGetNameInfo(
    const struct sockaddr *SocketAddress,  // Socket address to translate.
    socklen_t SocketAddressLength,         // Length of above socket address.
    char *NodeName,                        // Where to return the node name.
    size_t NodeBufferSize,                 // Size of above buffer.
    char *ServiceName,                     // Where to return the service name.
    size_t ServiceBufferSize,              // Size of above buffer.
    int Flags)                             // Flags of type NI_*.
{
    UNREFERENCED_PARAMETER(SocketAddressLength);
    UNREFERENCED_PARAMETER(NodeBufferSize);
    UNREFERENCED_PARAMETER(ServiceName);
    UNREFERENCED_PARAMETER(ServiceBufferSize);
    UNREFERENCED_PARAMETER(Flags);
    //
    // WinHttp doesn't do service lookup.
    //
    INET_ASSERT((ServiceName == NULL) && (ServiceBufferSize == 0));

    //
    // WinHttp can be trusted to call us correctly.
    //
    INET_ASSERT((NodeName != NULL) && (SocketAddress != NULL) &&
                (SocketAddressLength == sizeof(struct sockaddr_in)));

    //
    // This version is IPv4 only.
    //
    INET_ASSERT(SocketAddress->sa_family == AF_INET);

    //
    // WinHttp will only call this routine to translate the given address
    // to an IPv4 address literal.
    //
    INET_ASSERT(Flags & NI_NUMERICHOST);
    INET_ASSERT(NodeBufferSize >= sizeof("255.255.255.255"));
    strcpy(NodeName, _I_inet_ntoa(((struct sockaddr_in *)SocketAddress)->sin_addr));

    return 0;
}

#define INADDR_IS_LOOPBACK(s) \
    (((s)->sin_family == AF_INET) && ((s)->sin_addr.S_un.S_addr == 0x0100007f))


BOOL
ParseHostName(
    IN LPSTR lpHostName,
    IN DWORD cchHostName,
    OUT LPBOOL lpbIsLiteral,
    OUT LPBOOL lpbIsLocalHost,
    IN OUT LPSOCKADDR_IN6 lpSockAddr OPTIONAL
    )
{
    SOCKADDR_IN6 Addr;
    int Error;
    int AddrLen;
    char HostName[NI_MAXHOST+1]; // +1 for null char
    
    // if hostname is too long we can't deal with it

    if (cchHostName > NI_MAXHOST) {
        return FALSE;
    }

    // start with not-a-literal and not-a-localhost

    *lpbIsLiteral = FALSE;
    *lpbIsLocalHost = FALSE;

    // construct null terminated hostname

    memcpy(HostName, lpHostName, cchHostName);
    HostName[cchHostName] = '\0';
    
    // first check for well-known names

    if ( !_stricmp(HostName, "localhost") || !_stricmp(HostName, "loopback")) {
        *lpbIsLiteral = FALSE;
        *lpbIsLocalHost = TRUE;
        return TRUE;
    }

    // try to convert as an IPv4 literal (AF_INET) 

    AddrLen = sizeof(Addr);
    Error = _I_WSAStringToAddressA(
                (LPSTR)HostName, 
                AF_INET, 
                NULL, 
                (LPSOCKADDR)(lpSockAddr ? lpSockAddr : &Addr),
                &AddrLen);

    if (Error != 0) {

        // not v4 literal - try to convert as an IPv6 literal (AF_INET6)

        AddrLen = sizeof(Addr);
        Error = _I_WSAStringToAddressA(
                    (LPSTR)HostName, 
                    AF_INET6, 
                    NULL, 
                    (LPSOCKADDR)(lpSockAddr ? lpSockAddr : &Addr),
                    &AddrLen);
    }

    if (!Error) {

        // successful conversion means it is a literal address
        
        *lpbIsLiteral = TRUE;  

        // check if loopback 127.0.0.1 or ::1
        
        if (INADDR_IS_LOOPBACK((LPSOCKADDR_IN)(lpSockAddr ? lpSockAddr : &Addr)) 
            || IN6ADDR_ISLOOPBACK((lpSockAddr ? lpSockAddr : &Addr))) {
            *lpbIsLocalHost = TRUE; // 127.0.0.1 or ::1
        }
    }

    return TRUE;
}


DWORD
SafeCloseSocket(
    IN SOCKET Socket
    )

/*++

Routine Description:

    closesocket() call protected by exception handler in case winsock DLL has
    been unloaded by system before WinHttp DLL unloaded

Arguments:

    Socket  - socket handle to close

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - socket error mapped to ERROR_WINHTTP_ error

--*/

{
    int serr;

    __try {
        serr = _I_closesocket(Socket);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        serr = 0;
    }
    ENDEXCEPT
    return (serr == SOCKET_ERROR)
        ? MapInternetError(_I_WSAGetLastError())
        : ERROR_SUCCESS;
}

CWrapOverlapped* GetWrapOverlappedObject(LPVOID lpAddress)
{
    return CONTAINING_RECORD(lpAddress, CWrapOverlapped, m_Overlapped);
}

#if INET_DEBUG

//
// debug data types
//

SOCKET
PASCAL FAR
_II_socket(
    int af,
    int type,
    int protocol
    );

int
PASCAL FAR
_II_closesocket(
    SOCKET s
    );

SOCKET
PASCAL FAR
_II_accept(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    );

GLOBAL
SOCKET
(PASCAL FAR * _P_accept)(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _P_closesocket)(
    SOCKET s
    ) = NULL;

GLOBAL
SOCKET
(PASCAL FAR * _P_socket)(
    int af,
    int type,
    int protocol
    ) = NULL;

#define MAX_STACK_TRACE     5
#define MAX_SOCK_ENTRIES    1000

typedef struct _DEBUG_SOCK_ENTRY {
    SOCKET Socket;
    DWORD StackTraceLength;
    PVOID StackTrace[ MAX_STACK_TRACE ];
} DEBUG_SOCK_ENTRY, *LPDEBUG_SOCK_ENTRY;

CCritSec DebugSockLock;
DEBUG_SOCK_ENTRY GlobalSockEntry[MAX_SOCK_ENTRIES];

DWORD GlobalSocketsCount = 0;


#define LOCK_DEBUG_SOCK()   (DebugSockLock.Lock())
#define UNLOCK_DEBUG_SOCK() (DebugSockLock.Unlock())

HINSTANCE NtDllHandle;

typedef USHORT (*RTL_CAPTURE_STACK_BACK_TRACE)(
   IN ULONG FramesToSkip,
   IN ULONG FramesToCapture,
   OUT PVOID *BackTrace,
   OUT PULONG BackTraceHash
   );

RTL_CAPTURE_STACK_BACK_TRACE pRtlCaptureStackBackTrace;

BOOL
InitDebugSock(
    VOID
    )
{
    memset( GlobalSockEntry, 0x0, sizeof(GlobalSockEntry) );
    GlobalSocketsCount = 0;

    if (!DebugSockLock.Init())
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

VOID
TerminateDebugSock(
    VOID
    )
{
    DebugSockLock.FreeLock();
}

VOID
SetupSocketsTracing(
    VOID
    )
{
    if (!(InternetDebugCategoryFlags & DBG_TRACE_SOCKETS)) {
        return ;
    }
    if (!IsPlatformWinNT()) {
        return ;
    }
    if ((NtDllHandle = LoadLibrary("ntdll.dll")) == NULL) {
        return ;
    }
    if ((pRtlCaptureStackBackTrace =
        (RTL_CAPTURE_STACK_BACK_TRACE)
            GetProcAddress(NtDllHandle, "RtlCaptureStackBackTrace")) == NULL) {
        FreeLibrary(NtDllHandle);
        return ;
    }

//#ifdef DONT_DO_FOR_NOW
    _P_accept = _I_accept;
    _I_accept = _II_accept;
    _P_closesocket = _I_closesocket;
    _I_closesocket = _II_closesocket;
    _P_socket = _I_socket;
    _I_socket = _II_socket;
//#endif
}

VOID
AddSockEntry(
    SOCKET S
    )
{
    DWORD i;

    if (!(InternetDebugCategoryFlags & DBG_TRACE_SOCKETS)) {
        return ;
    }

    LOCK_DEBUG_SOCK();

    //
    // search for a free entry.
    //

    for( i = 0; i < MAX_SOCK_ENTRIES; i++ ) {

        if( GlobalSockEntry[i].Socket == 0 ) {

            //
            // found a free entry.
            //

            GlobalSockEntry[i].Socket = S;

            //
            // get caller stack.
            //

#if i386
            DWORD Hash = 0;

            GlobalSockEntry[i].StackTraceLength =
                pRtlCaptureStackBackTrace(
                    2,
                    MAX_STACK_TRACE,
                    GlobalSockEntry[i].StackTrace,
                    &Hash );
#else // i386
            GlobalSockEntry[i].StackTraceLength = 0;
#endif // i386


            GlobalSocketsCount++;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("socket count = %ld\n",
                        GlobalSocketsCount
                        ));

            DPRINTF("%d sockets\n", GlobalSocketsCount);

            UNLOCK_DEBUG_SOCK();
            return;
        }
    }

    //
    // we have reached a high handle limit, which is unusal, needs to be
    // debugged.
    //

    INET_ASSERT( FALSE );
    UNLOCK_DEBUG_SOCK();

    return;
}

VOID
RemoveSockEntry(
    SOCKET S
    )
{
    DWORD i;

    if (!(InternetDebugCategoryFlags & DBG_TRACE_SOCKETS)) {
        return ;
    }

    LOCK_DEBUG_SOCK();

    for( i = 0; i < MAX_SOCK_ENTRIES; i++ ) {

        if( GlobalSockEntry[i].Socket == S ) {

            //
            // found the entry. Free it now.
            //

            memset( &GlobalSockEntry[i], 0x0, sizeof(DEBUG_SOCK_ENTRY) );

            GlobalSocketsCount--;

#ifdef IWINSOCK_DEBUG_PRINT

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("count(%ld), RemoveSock(%lx)\n",
                        GlobalSocketsCount,
                        S
                        ));

#endif // IWINSOCK_DEBUG_PRINT

            DPRINTF("%d sockets\n", GlobalSocketsCount);

            UNLOCK_DEBUG_SOCK();
            return;
        }
    }

#ifdef IWINSOCK_DEBUG_PRINT

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("count(%ld), UnknownSock(%lx)\n",
                GlobalSocketsCount,
                S
                ));

#endif // IWINSOCK_DEBUG_PRINT

    //
    // socket entry is not found.
    //

    // INET_ASSERT( FALSE );

    UNLOCK_DEBUG_SOCK();
    return;
}

SOCKET
PASCAL FAR
_II_socket(
    int af,
    int type,
    int protocol
    )
{
    SOCKET S;

    S = _P_socket( af, type, protocol );
    AddSockEntry( S );
    return( S );
}

int
PASCAL FAR
_II_closesocket(
    SOCKET s
    )
{
    int Ret;

    RemoveSockEntry( s );
    Ret = _P_closesocket( s );
    return( Ret );
}

SOCKET
PASCAL FAR
_II_accept(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    )
{
    SOCKET S;

    S = _P_accept( s, addr, addrlen );
    AddSockEntry( S );
    return( S );

}

VOID
IWinsockCheckSockets(
    VOID
    )
{
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("GlobalSocketsCount = %d\n",
                GlobalSocketsCount
                ));

    for (DWORD i = 0; i < MAX_SOCK_ENTRIES; ++i) {

        SOCKET sock;

        if ((sock = GlobalSockEntry[i].Socket) != 0) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("Socket %#x\n",
                        sock
                        ));

        }
    }
}

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\icsocket.cxx ===
/*++

Copyright (c) 1995-1997 Microsoft Corporation

Module Name:

    icsocket.cxx

Abstract:

    Contains sockets functions and ICSocket methods

    Contents:
        ContainingICSocket
        MapNetAddressToName
        ICSocket::ICSocket
        ICSocket::~ICSocket
        ICSocket::Destroy
        ICSocket::Reference
        ICSocket::Dereference
        ICSocket::EnableSocks
        ICSocket::Connect
        CFsm_SocketConnect::RunSM
        ICSocket::Connect_Start
        ICSocket::Connect_Continue
        ICSocket::Connect_Error
        ICSocket::Connect_Finish
        ICSocket::SocksConnect
        ICSocket::Disconnect
        ICSocket::Close
        ICSocket::Abort
        ICSocket::Shutdown
        ICSocket::IsReset
        ICSocket::SetTimeout
        ICSocket::SetLinger
        ICSocket::SetNonBlockingMode
        ICSocket::GetBufferLength(SOCKET_BUFFER_ID)
        ICSocket::GetBufferLength(SOCKET_BUFFER_ID, LPDWORD)
        ICSocket::SetBufferLength
        ICSocket::SetSendCoalescing
        SetSourcePort
        ICSocket::Send
        CFsm_SocketSend::RunSM
        ICSocket::Send_Start
        ICSocket::SendTo
        ICSocket::Receive
        CFsm_SocketReceive::RunSM
        ICSocket::Receive_Start
        ICSocket::Receive_Continue
        ICSocket::AllocateQueryBuffer
        //ICSocket::FreeQueryBuffer
        //ICSocket::ReceiveFrom
        ICSocket::DataAvailable
        //ICSocket::DataAvailable2
        ICSocket::WaitForReceive
        //ICSocket::GetBytesAvailable
        //ICSocket::CreateSocket
        ICSocket::GetSockName
        ICSocket::Listen
        ICSocket::DirectConnect
        ICSocket::SelectAccept

Author:

    Richard L Firth (rfirth) 08-Apr-1997

Environment:

    Win32 user mode

Revision History:

    08-Apr-1997 rfirth
        Created from ixport.cxx

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// private prototypes
//

//
// functions
//

#if INET_DEBUG

PRIVATE LPSTR MapFamily(int family) {
    switch (family) {
    case AF_UNSPEC:     return "AF_UNSPEC";
    case AF_UNIX:       return "AF_UNIX";
    case AF_INET:       return "AF_INET";
    case AF_IMPLINK:    return "AF_IMPLINK";
    case AF_PUP:        return "AF_PUP";
    case AF_CHAOS:      return "AF_CHAOS";
    case AF_IPX:        return "AF_IPX";
    case AF_OSI:        return "AF_OSI";
    case AF_ECMA:       return "AF_ECMA";
    case AF_DATAKIT:    return "AF_DATAKIT";
    case AF_CCITT:      return "AF_CCITT";
    case AF_SNA:        return "AF_SNA";
    case AF_DECnet:     return "AF_DECnet";
    case AF_DLI:        return "AF_DLI";
    case AF_LAT:        return "AF_LAT";
    case AF_HYLINK:     return "AF_HYLINK";
    case AF_APPLETALK:  return "AF_APPLETALK";
    case AF_NETBIOS:    return "AF_NETBIOS";
#if defined(AF_VOICEVIEW)
    case AF_VOICEVIEW:  return "AF_VOICEVIEW";
#endif /* AF_VOICEVIEW */
#if defined(AF_FIREFOX)
    case AF_FIREFOX:    return "AF_FIREFOX";
#endif /* AF_FIREFOX */
#if defined(AF_UNKNOWN1)
    case AF_UNKNOWN1:   return "AF_UNKNOWN1";
#endif /* AF_UNKNOWN1 */
#if defined(AF_BAN)
    case AF_BAN:        return "AF_BAN";
#endif /* AF_BAN */
#if defined(AF_INET6)
    case AF_INET6:      return "AF_INET6";
#endif /* AF_INET6 */
    }
    return "?";
}

PRIVATE LPSTR MapSock(int sock) {
    switch (sock) {
    case SOCK_STREAM:       return "SOCK_STREAM";
    case SOCK_DGRAM:        return "SOCK_DGRAM";
    case SOCK_RAW:          return "SOCK_RAW";
    case SOCK_RDM:          return "SOCK_RDM";
    case SOCK_SEQPACKET:    return "SOCK_SEQPACKET";
    }
    return "?";
}

PRIVATE LPSTR MapProto(int proto) {
    switch (proto) {
    case IPPROTO_IP:    return "IPPROTO_IP";
    case IPPROTO_ICMP:  return "IPPROTO_ICMP";
    case IPPROTO_IGMP:  return "IPPROTO_IGMP";
    case IPPROTO_GGP:   return "IPPROTO_GGP";
    case IPPROTO_TCP:   return "IPPROTO_TCP";
    case IPPROTO_PUP:   return "IPPROTO_PUP";
    case IPPROTO_UDP:   return "IPPROTO_UDP";
    case IPPROTO_IDP:   return "IPPROTO_IDP";
    case IPPROTO_ND:    return "IPPROTO_ND";
    }
    return "?";
}

#endif // INET_DEBUG



ICSocket *
ContainingICSocket(
    LPVOID lpAddress
    )

/*++

Routine Description:

    Returns address of start of ICSocket (i.e. vtable) given address of list

Arguments:

    lpAddress   - address of m_List part of ICSocket

Return Value:

    ICSocket *  - address of start of ICSocket object (also ICSecureSocket)

--*/

{
    return CONTAINING_RECORD(lpAddress, ICSocket, m_List);
}

//
// ICSocket methods
//


ICSocket::ICSocket(
    VOID
    )

/*++

Routine Description:

    ICSocket constructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSocket::ICSocket",
                 "{%#x}",
                 this
                 ));

    SIGN_ICSOCKET();

    m_List.Flink = NULL;
    m_List.Blink = NULL;
    m_dwTimeout = 0;
    m_fTimeoutWraps = 0;
    m_Socket = INVALID_SOCKET;
    m_dwFlags = 0;
    m_bAborted = FALSE;
    m_SocksAddress = 0;
    m_SocksPort = 0;
    m_ReferenceCount = 1;
    _pCurrentFsm = NULL;

    _lpWrapOverlappedSend = NULL;
    _lpWrapOverlappedRecv = NULL;

    m_fIsSecureSocket = FALSE; // ICSecureSocket will set this to TRUE

    DEBUG_LEAVE(0);
}


ICSocket::~ICSocket()

/*++

Routine Description:

    ICSocket destructor. Virtual function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSocket::~ICSocket",
                 "{%#x [sock=%#x, port=%d, ref=%d]}",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 ReferenceCount()
                 ));

    CHECK_ICSOCKET();

    INET_ASSERT(!IsOnList());
    INET_ASSERT(m_ReferenceCount == 0);

    if (IsOpen()) {
        Close();
    }

    if (_lpWrapOverlappedSend)
        _lpWrapOverlappedSend->Dereference();

    if (_lpWrapOverlappedRecv)
        _lpWrapOverlappedRecv->Dereference();
        
    DEBUG_LEAVE(0);
}


VOID
ICSocket::Destroy(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSocket::Destroy",
                 "{%#x [%#x/%d]}",
                 this,
                 GetSocket(),
                 GetSourcePort()
                 ));

    INET_ASSERT(ReferenceCount() == 1);

    m_ReferenceCount = 0;
    delete this;

    DEBUG_LEAVE(0);
}


VOID
ICSocket::Reference(
    VOID
    )

/*++

Routine Description:

    Just increases the reference count

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHECK_ICSOCKET();

    InterlockedIncrement(&m_ReferenceCount);
}


BOOL
ICSocket::Dereference(
    VOID
    )

/*++

Routine Description:

    Reduces the reference count. If it goes to zero, the object is deleted

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - object deleted

        FALSE   - object still alive

--*/

{
    CHECK_ICSOCKET();

    if (InterlockedDecrement(&m_ReferenceCount) == 0) {

        INET_ASSERT(m_ReferenceCount == 0);

        delete this;
        return TRUE;
    }
    return FALSE;
}


PRIVATE
DWORD
ICSocket::EnableSocks(
    IN LPSTR lpSocksHost,
    IN INTERNET_PORT ipSocksPort
    )

/*++

Routine Description:

    Set SOCKS gateway IP address and port in this socket object

Arguments:

    lpSocksHost - IP address or host name of SOCKS host

    ipSocksPort - port address of SOCKS host

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_NAME_NOT_RESOLVED
                    failed to resolve SOCKS host name

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::EnableSocks",
                 "{%#x/%d} %q, %d",
                 GetSocket(),
                 GetSourcePort(),
                 lpSocksHost,
                 ipSocksPort
                 ));

    DWORD error = ERROR_SUCCESS;

    m_SocksPort = ipSocksPort;
    m_SocksAddress = _I_inet_addr(lpSocksHost);
    if (m_SocksAddress == INADDR_NONE) {    // 0xffffffff

        LPHOSTENT lpHostent = _I_gethostbyname(lpSocksHost);

        if (lpHostent != NULL) {
            m_SocksAddress = **(LPDWORD*)&lpHostent->h_addr_list[0];
        } else {
            m_SocksAddress = 0;
            error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
        }
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("SOCKS address = %d.%d.%d.%d:%d\n",
                ((BYTE*)&m_SocksAddress)[0] & 0xff,
                ((BYTE*)&m_SocksAddress)[1] & 0xff,
                ((BYTE*)&m_SocksAddress)[2] & 0xff,
                ((BYTE*)&m_SocksAddress)[3] & 0xff,
                m_SocksPort
                ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::AssociateWithCompletionPort(
    VOID
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::AssociateWithCompletionPort",
                 "{%#x [%#x]} socketflags=%#x, completionport=%d",
                 this,
                 m_Socket,
                 m_dwFlags,
                 g_hCompletionPort
                 ));

    DWORD dwError;
    
    SOCKET sock = m_Socket;

    if (sock != INVALID_SOCKET)
    {
        HANDLE hCompPort = CreateIoCompletionPort(  (HANDLE)sock,
                                                    g_hCompletionPort,
                                                    (ULONG_PTR)this,
                                                    g_cNumIOCPThreads );
        
        INET_ASSERT ((hCompPort == g_hCompletionPort)
                    || !hCompPort);

        if (hCompPort)
        {
            dwError = ERROR_SUCCESS;
            m_dwFlags |= SF_OVERLAPPED;
        }
        else
        {
            dwError = GetLastError();
            //informational INET_ASSERT (FALSE);
        }
    }
    else
    {
        dwError = ERROR_WINHTTP_OPERATION_CANCELLED;
    }

    DEBUG_LEAVE (dwError);
    return dwError;
}


BOOL
ICSocket::MatchOverlappedSemantics(
    IN DWORD dwSocketFlags
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "ICSocket::MatchOverlappedSemantics",
                 "{%#x [%#x]} socketflags=%#x, desiredflags=%#x, completionport=%d",
                 this,
                 m_Socket,
                 m_dwFlags,
                 dwSocketFlags,
                 g_hCompletionPort
                 ));

    BOOL bRet = TRUE;

    if  (((dwSocketFlags^m_dwFlags) & SF_OVERLAPPED)
        && (dwSocketFlags & SF_OVERLAPPED))
    {
        DWORD error;
        if (g_hCompletionPort
            && ((error = AssociateWithCompletionPort()) == ERROR_SUCCESS))
        {
            bRet = TRUE;
        }
        else
        {
            bRet = FALSE;
            //informational INET_ASSERT (FALSE);
        }
    }

    DEBUG_LEAVE (bRet);
    return bRet;
}


DWORD
ICSocket::SocketConnect(
    IN LONG Timeout,
    IN INT Retries,
    IN DWORD dwFlags,
    IN CServerInfo *pServerInfo
    )

/*++

Routine Description:

    Initiate connection with server

Arguments:

    Timeout - maximum amount of time (mSec) to wait for connection

    Retries - maximum number of attempts to connect

    dwFlags - flags controlling request

    pServerInfo - Server Info to connect with

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SocketConnect",
                 "{%#x [%#x]} %d, %d, %#x, %x",
                 this,
                 m_Socket,
                 Timeout,
                 Retries,
                 dwFlags,
                 pServerInfo
                 ));


    DWORD error;

    CFsm_SocketConnect * pFsm;

    pFsm = New CFsm_SocketConnect(Timeout, Retries, dwFlags, this);

    if ( pFsm )
    {
        pFsm->SetServerInfo(pServerInfo);
    }

    error = DoFsm(pFsm);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
ICSocket::Connect(
    IN LONG Timeout,
    IN INT Retries,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Initiate connection with server

Arguments:

    Timeout - maximum amount of time (mSec) to wait for connection

    Retries - maximum number of attempts to connect

    dwFlags - flags controlling request

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect",
                 "{%#x [%#x]} %d, %d, %#x",
                 this,
                 m_Socket,
                 Timeout,
                 Retries,
                 dwFlags
                 ));

#ifdef TEST_CODE
    Timeout *= 20;
    Retries *= 20;
#endif

    DWORD error;

    error = DoFsm(New CFsm_SocketConnect(Timeout, Retries, dwFlags, this));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SocketConnect::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_SocketConnect state

Arguments:

    Fsm - FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SocketConnect::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSocket * pSocket = (ICSocket *)Fsm->GetContext();
    CFsm_SocketConnect * stateMachine = (CFsm_SocketConnect *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
        error = pSocket->Connect_Start(stateMachine);
        break;

    case FSM_STATE_CONTINUE:
        error = pSocket->Connect_Continue(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = pSocket->Connect_Error(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Start(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Starts a socket connect operation - creates a socket and connects it to a
    server using the address information returned by GetServiceAddress(). There
    may be several addresses to try. We return as soon as we successfully
    generate a connection, or after we have tried <Retries> attempts, or until
    <Timeout> milliseconds have elapsed

Arguments:

    Fsm - socket connect FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Start",
                 "{%#x [%#x]}, %#x(%d, %d, %#x)",
                 this,
                 m_Socket,
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Start);

    CFsm_SocketConnect & fsm = *Fsm;

    //informational INET_ASSERT(lpThreadInfo != NULL);

    DWORD error = ERROR_SUCCESS;
    int serr = SOCKET_ERROR;

    BOOL fSynchronous = FALSE;

    INET_ASSERT(IsClosed());

    //
    // ensure the next state is CONTINUE. It may be INIT because we could have
    // been looping through bad addresses (if sufficient timeout & retries)
    //

    fsm.SetNextState(FSM_STATE_CONTINUE);

    //
    // get address to use. If exhausted, re-resolve
    //

    if (fsm.GetFunctionState() == FSM_STATE_2) 
    {
        fsm.SetFunctionState(FSM_STATE_1);
        error = fsm.GetError();
        goto resolve_continue;
    }
    if (!fsm.m_pServerInfo->GetNextAddress(&fsm.m_dwResolutionId,
                                           &fsm.m_dwAddressIndex,
                                           GetPort(),
                                           fsm.m_pAddress
                                           )) {
        if (fsm.m_bResolved) {
            error = ERROR_WINHTTP_CANNOT_CONNECT;
        } else {
            fsm.SetFunctionState(FSM_STATE_2);
            fsm.SetNextState(FSM_STATE_INIT);
            fsm.m_dwAddressIndex = (DWORD)-1;
            error = fsm.m_pServerInfo->ResolveHost(&fsm.m_dwResolutionId,
                                                   fsm.m_dwFlags
                                                   );
            if (error == ERROR_IO_PENDING) {
                goto quit;
            }

resolve_continue:

            fsm.m_bResolved = TRUE;
            if (error == ERROR_SUCCESS) {
                if (!fsm.m_pServerInfo->GetNextAddress(&fsm.m_dwResolutionId,
                                                       &fsm.m_dwAddressIndex,
                                                       GetPort(),
                                                       fsm.m_pAddress
                                                       )) {
                    error = ERROR_WINHTTP_CANNOT_CONNECT;
                }
            }
            else if (error == ERROR_WINHTTP_NAME_NOT_RESOLVED)
            {
                fsm.SetNextState(FSM_STATE_CONTINUE);
                goto quit; // exit out NOW with ERROR_WINHTTP_NAME_NOT_RESOLVED, instead of CANNOT_CONNECT
            }
        }
    }
    if (error != ERROR_SUCCESS) {

        //
        // name resolution failed - done
        //

        goto quit;
    }

    //
    // update port for keep-alive info
    //
    // The port number field is in the same location in both a
    // sockaddr_in and a sockaddr_in6, so it is safe to cast the
    // sockaddr to sockaddr_in here - this works for IPv4 or IPv6.
    //
    INET_ASSERT(offsetof(SOCKADDR_IN, sin_port) == offsetof(SOCKADDR_IN6, sin6_port));

    SetPort(_I_ntohs(((LPSOCKADDR_IN)fsm.m_pAddress->RemoteAddr.lpSockaddr)->sin_port));

    //
    // BUGBUG - this code was supplying AF_UNSPEC to socket(), which should
    //          be okay, but because of a bug in the Win95 wsipx driver
    //          which manifests itself when we call bind(), we must send in
    //          the address family supplied in the local socket address by
    //          GetAddressByName()
    //

    int protocol;

    protocol = fsm.m_pAddress->iProtocol;

    m_Socket = _I_socket(fsm.m_pAddress->LocalAddr.lpSockaddr->sa_family,
                         fsm.m_pAddress->iSocketType,
                         protocol
                         );
    if (m_Socket == INVALID_SOCKET) {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to create socket\n"
                    ));

        goto check_socket_error;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("created socket %#x\n",
                m_Socket
                ));

    //
    // inform the app that we are connecting to the server (but only on the
    // first attempt)
    //

    //if ((fsm.m_dwFlags & SF_INDICATE) && (error == ERROR_SUCCESS)) {
    if (fsm.m_dwFlags & SF_INDICATE) {
        error = InternetIndicateStatusAddress(WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER,
                                      fsm.m_pAddress->RemoteAddr.lpSockaddr,
                                      fsm.m_pAddress->RemoteAddr.iSockaddrLength
                                      );
        if (error != ERROR_SUCCESS)
        {
            INET_ASSERT(error == ERROR_WINHTTP_OPERATION_CANCELLED);
            fsm.SetNextState(FSM_STATE_DONE);
            goto quit;
        }   
    }

    //
    // if requested to, put the socket in non-blocking mode
    //

    if (fsm.m_dwFlags & SF_NON_BLOCKING
    && (GlobalRunningNovellClient32 ? GlobalNonBlockingClient32 : TRUE)) {
        error = SetNonBlockingMode(TRUE);
        if (error != ERROR_SUCCESS) {
            fsm.SetErrorState(error);
            goto quit;
        }
    }

    //
    // bind the socket to the local address
    //

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("binding to local address %A, port %d, index %d\n",
                fsm.m_pAddress->LocalAddr.lpSockaddr,
                _I_ntohs(((LPSOCKADDR_IN)fsm.m_pAddress->LocalAddr.lpSockaddr)->sin_port),
                fsm.m_dwAddressIndex
                ));

    serr = _I_bind(m_Socket,
                   fsm.m_pAddress->LocalAddr.lpSockaddr,
                   fsm.m_pAddress->LocalAddr.iSockaddrLength
                   );
    if (serr == SOCKET_ERROR) {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to bind socket %#x\n",
                    m_Socket
                    ));

        goto check_socket_error;
    }

    //
    // record source port (useful for matching with net sniff)
    //

    SetSourcePort();

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("socket %#x bound to port %d (%#x)\n",
                m_Socket,
                m_SourcePort,
                m_SourcePort
                ));

    //
    // let another thread know the socket to cancel if it wants to kill
    // this operation
    //

    INET_ASSERT(fsm.GetMappedHandleObject() != NULL);

    if (fsm.GetMappedHandleObject() != NULL) {
        fsm.GetMappedHandleObject()->SetAbortHandle(this);
    }

    //
    // try to connect to the next address
    //

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connecting %#x/%d to remote address %A, port %d, index %d\n",
                m_Socket,
                m_SourcePort,
                fsm.m_pAddress->RemoteAddr.lpSockaddr,
                _I_ntohs(((LPSOCKADDR_IN)fsm.m_pAddress->RemoteAddr.lpSockaddr)->sin_port),
                fsm.m_dwAddressIndex
                ));
#if 0   
#define SIN4 ((LPSOCKADDR_IN)fsm.m_pAddress->RemoteAddr.lpSockaddr)
#define SIN6 ((LPSOCKADDR_IN6)fsm.m_pAddress->RemoteAddr.lpSockaddr)
    if (SIN4->sin_family == AF_INET) {
        DEBUG_PRINT(SOCKETS, INFO, (" sin_family = AF_INET\n"));
        DEBUG_PRINT(SOCKETS, INFO, (" sin_port = %u\n", _I_ntohs(SIN4->sin_port)));
        DEBUG_PRINT(SOCKETS, INFO, (" sin_addr.S_un.S_addr = 0x%x\n", SIN4->sin_addr.S_un.S_addr));
        DEBUG_PRINT(SOCKETS, INFO, (" sin_addr = %d.%d.%d.%d\n", 
            SIN4->sin_addr.S_un.S_un_b.s_b1,
            SIN4->sin_addr.S_un.S_un_b.s_b2,
            SIN4->sin_addr.S_un.S_un_b.s_b3,
            SIN4->sin_addr.S_un.S_un_b.s_b4));
    } else {
        DEBUG_PRINT(SOCKETS, INFO, (" sin_family = AF_INET6\n"));
        DEBUG_PRINT(SOCKETS, INFO, (" sin6_port = %u\n", _I_ntohs(SIN6->sin6_port)));
        DEBUG_PRINT(SOCKETS, INFO, (" sin6_flowinfo = %u\n", SIN6->sin6_flowinfo));
        DEBUG_PRINT(SOCKETS, INFO, (" sin6_addr = %.04x:%.04x:%.04x:%.04x:%.04x:%.04x:%.04x:%.04x\n",
            _I_ntohs(SIN6->sin6_addr.s6_words[0]),
            _I_ntohs(SIN6->sin6_addr.s6_words[1]),
            _I_ntohs(SIN6->sin6_addr.s6_words[2]),
            _I_ntohs(SIN6->sin6_addr.s6_words[3]),
            _I_ntohs(SIN6->sin6_addr.s6_words[4]),
            _I_ntohs(SIN6->sin6_addr.s6_words[5]),
            _I_ntohs(SIN6->sin6_addr.s6_words[6]),
            _I_ntohs(SIN6->sin6_addr.s6_words[7])));
        DEBUG_PRINT(SOCKETS, INFO, (" ai_addr->sin6_scope_id = %u\n", SIN6->sin6_scope_id));
    }
#endif

    fsm.SetNextState(FSM_STATE_CONTINUE);
    fsm.StartTimer();

#ifdef TEST_CODE
    SetLastError(-1);
    serr = -1;
#else
    //if we are running in blocking mode (ie synchronous case) w/ timeout, unblock for 
    //the connect so we can enforce the timeout.
    if (!(fsm.m_dwFlags & SF_NON_BLOCKING) 
        && (fsm.GetTimeout() != INFINITE)) 
    {
        fSynchronous = TRUE;
        error = SetNonBlockingMode(TRUE);
        if (error != ERROR_SUCCESS) 
        {
            fsm.SetErrorState(error);
            goto quit;
        }
    }
    
    if (IsSocks()) {
        serr = SocksConnect((LPSOCKADDR_IN)fsm.m_pAddress->RemoteAddr.lpSockaddr,
                            fsm.m_pAddress->RemoteAddr.iSockaddrLength
                            );
    } else {
        serr = _I_connect(m_Socket,
                          fsm.m_pAddress->RemoteAddr.lpSockaddr,
                          fsm.m_pAddress->RemoteAddr.iSockaddrLength
                          );
    }
#endif

    //
    // here if a socket operation failed, in which case serr will be SOCKET_ERROR
    //

check_socket_error:

    if (serr == 0) {

        //
        // successful (probably synchronous) connect completion
        //

        //
        // in the sync case, we just call the continue handler. No need to
        // return to the state handler
        //
        
        if (fSynchronous) // we must have marked the socket non-blocking ealier
        {
            DWORD dwError;
            if ((dwError = SetNonBlockingMode(FALSE)) != ERROR_SUCCESS)
            {
                error = MapInternetError(dwError);
                fsm.SetErrorState(error);
                goto quit; // no connect re-try if we failed to restore the socket mode
            }
        }

        Connect_Continue(Fsm);
        goto quit;
    }

    //
    // here if a socket operation failed. We have to read the socket error in
    // this thread before doing anything else or we'll lose the error. We handle
    // it in Connect_Error()
    //

    error = _I_WSAGetLastError();

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connect(%#x) returns %d\n",
                m_Socket,
                error
                ));

    if (fSynchronous && (error == WSAEWOULDBLOCK))
    {
        int n = 1;
        
        struct fd_set write_fds;
        struct fd_set except_fds;
        
        FD_ZERO(&write_fds);
        FD_ZERO(&except_fds);
        
        SOCKET sock = m_Socket;

        // connect() & send()

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("%s FSM %#x WRITE waiting on socket %#x\n",
                    fsm.MapType(),
                    &fsm,
                    sock
                    ));

        FD_SET(sock, &write_fds);
        
        // all sockets are checked for exception
        FD_SET(sock, &except_fds);
        
        LONG timeout = fsm.GetTimeout();
        struct timeval to = {0,0};
        struct timeval* pto;

        if (timeout != INFINITE)
        {
            to.tv_sec = timeout / 1000;
            to.tv_usec = (timeout % 1000) * 1000;
            pto = &to;
        }
        else
        {
            pto = NULL;
        }
        
        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("waiting %d mSec (%d.%06d) for select(). %d sockets\n",
                    timeout,
                    pto ? to.tv_sec : -1,
                    pto ? to.tv_usec : -1,
                    n
                    ));
                    
        n = PERF_Select(n, NULL, &write_fds, &except_fds, pto);

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("select() returns %d\n",
                    n
                    ));

        error = ERROR_WINHTTP_CANNOT_CONNECT;

        if (n == 0)
        {
            INET_ASSERT (pto != NULL);
            
            error = ERROR_WINHTTP_TIMEOUT;
        }
        else if (n > 0) 
        {
            if (FD_ISSET(sock, &except_fds)) 
            {
                DEBUG_PRINT(ASYNC,
                            INFO,
                            ("%s FSM %#x socket %#x exception\n",
                            fsm.MapType(),
                            fsm,
                            sock
                            ));                
            } 
            else if (FD_ISSET(sock, &write_fds)) 
            {
                DEBUG_PRINT(ASYNC,
                            INFO,
                            ("%s FSM %#x socket %#x completed\n",
                            fsm.MapType(),
                            fsm,
                            sock
                            ));

                error = ERROR_SUCCESS;
            }
            else
            {
                INET_ASSERT (FALSE);
            }
        } //n >= 0
        else
        {
            error = MapInternetError(_I_WSAGetLastError());
        }
        
        //Now set the socket back to blocking mode.
        //  If we run into an error doing that, then fall out of the connect loop 
        //  Else we'll fall into the Connect_Continue->Connect_Error codepath, which
        //  will also account for count-outs and timeouts.
        DWORD dwError;
        if ((dwError = SetNonBlockingMode(FALSE)) != ERROR_SUCCESS)
        {
            error = MapInternetError(dwError);
            fsm.SetErrorState(error);
            goto quit;
        }

    } //fSynchronous

    //
    // if we are using non-blocking sockets then we need to wait until the
    // connect has completed, or an error occurs.
    // If we got any status other than WSAEWOULDBLOCK then we have to handle
    // the error
    //

    if (IsNonBlocking() && (error == WSAEWOULDBLOCK)) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("connect() blocked, socket %#x, port %d\n",
                    m_Socket,
                    m_SourcePort
                    ));

        fsm.SetAction(FSM_ACTION_CONNECT);

        DWORD timeout = GetTimeoutValue(WINHTTP_OPTION_CONNECT_TIMEOUT);
        
#ifndef WININET_SERVER_CORE //no cache
        if (pObject != NULL) {
            if (pObject->IsFromCacheTimeoutSet()
            && (pObject->GetObjectType() == TypeHttpRequestHandle)
            && ((HTTP_REQUEST_HANDLE_OBJECT *)pObject)->CanRetrieveFromCache()) {
                timeout = GetTimeoutValue(WINHTTP_OPTION_FROM_CACHE_TIMEOUT);

                DWORD connectTime = fsm.m_pServerInfo->GetConnectTime();

                if (connectTime == 0) {
                    connectTime = timeout;
                }
                timeout += connectTime;
            }
        }
#endif //no cache

        fsm.SetTimeout(timeout);
        fsm.SetNextState(FSM_STATE_CONTINUE);

        //
        // after we set the state to waiting, and get ERROR_IO_PENDING from
        // QueueSocketWorkItem() then we can no longer touch this FSM until
        // it completes asynchronously
        //

        //
        // perf - test the socket. If this completes quickly we don't take a
        // context switch
        //

        //error = WaitForReceive(0);
        //if (error == ERROR_WINHTTP_TIMEOUT) {
            error = QueueSocketWorkItem(Fsm, m_Socket);
        //}
        if (error == ERROR_SUCCESS) {

            //
            // in the unlikely event the request completed quickly and
            // successfully
            //

            serr = 0;
            goto check_socket_error;
        } else if (error == ERROR_IO_PENDING) {

            //
            // the request is pending. We already set waiting state
            //

            goto quit;
        }

        //
        // if here then QueueSocketWorkItem() returned some other error
        //

    } 
    else
    {

        //
        // some other socket error occurred. Convert to INTERNET error
        //

        //
        // Also okay to be here for successful synchronous connect with timeout.
        //
        if (error)
            fsm.SetErrorState(MapInternetError(error));
        error = Connect_Continue(Fsm);
    }

    if (error)
        fsm.SetErrorState(error);

quit:

    //
    // we are done if not pending AND we will not re-enter this state in order
    // to re-do the name resolution/find another address
    //

    if ((error != ERROR_IO_PENDING) && (fsm.GetNextState() != FSM_STATE_INIT)) 
    {
        fsm.SetDone();

        PERF_LEAVE(Connect_Start);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Continue(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Performs common processing after connect completion or failure

Arguments:

    Fsm - reference to socket connect finite state machine

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Continue",
                 "{%#x [%#x/%d]}, %#x(%d, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Continue);

    CFsm_SocketConnect & fsm = *Fsm;
    fsm.StopTimer();

//    INET_ASSERT((fsm.GetMappedHandleObject() != NULL)
//        ? (fsm.GetMappedHandleObject()->GetAbortHandle() != NULL)
//        : TRUE);

    DWORD error = fsm.GetError();

    //INET_ASSERT(error != SOCKET_ERROR);

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connect() resumed, socket %#x, port %d\n",
                m_Socket,
                m_SourcePort
                ));

    //
    // check for aborted request
    //

    if (IsAborted()) 
    {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
    }
    
    if (error == ERROR_SUCCESS)
    {
        //
        // Socket successfully created and bound and connected - now, if async,
        // associate IOCP with this socket.
        //
        if (fsm.m_dwFlags & SF_NON_BLOCKING)
        {
            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("***CreateIoCompletionPort: (m_Socket)%#x, (hcomp)%#x, (icsocket-compkey)%#x, %#x, (app handle)%#x, (fsm)%#x, (mapped handle obj)%#x",
                         m_Socket,
                         g_hCompletionPort,
                         this,
                         0,
                         fsm.GetAppHandle(),
                         fsm,
                         fsm.GetMappedHandleObject()
                        ));

            if ((error = AssociateWithCompletionPort()) != ERROR_SUCCESS)
            {
                fsm.SetErrorState(error);
            }
        }
    }

    if (error == ERROR_SUCCESS) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("socket %#x/port %d connected; time = %d mSec\n",
                    m_Socket,
                    m_SourcePort,
                    fsm.ReadTimer()
                    ));
        
        error = Connect_Finish(Fsm);
    } 
    
    if  (error != ERROR_SUCCESS) {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to connect socket %#x/port %d: error %s\n",
                    m_Socket,
                    m_SourcePort,
                    InternetMapError(error)
                    ));

        fsm.SetError(error);
        error = Connect_Error(Fsm);
    }

    PERF_LEAVE(Connect_Continue);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Error(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Called to handle a connect error. Either causes the FSM to terminate or
    prepares the FSM to try another connection

Arguments:

    Fsm - socket connect FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Error",
                 "{%#x [%#x/%d]}, %#x(%d, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Error);

    CFsm_SocketConnect & fsm = *Fsm;

    fsm.StopTimer();

    INTERNET_HANDLE_OBJECT * pObject = fsm.GetMappedHandleObject();

    //
    // no longer performing socket operation - clear abort handle
    //

    INET_ASSERT(pObject != NULL);

    if (pObject != NULL) {
        pObject->ResetAbortHandle();
    }

    DWORD error = fsm.GetError();
    BOOL bRestartable = FALSE;

    //INET_ASSERT(error != SOCKET_ERROR);
    INET_ASSERT(error != ERROR_SUCCESS);

    //
    // check for aborted request - this overrides any socket error
    //

    if (IsAborted() || error == ERROR_WINHTTP_OPERATION_CANCELLED) 
    {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
    }
    else if (fsm.IsCountedOut()
               || fsm.IsTimedOut()  // entire request timeout
               || (error == ERROR_WINHTTP_TIMEOUT)) 
    {  // just this request t/o

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("counted out or timed out\n"
                    ));
                    
        // VENKATK_BUG verify this:
        // CANNOT_CONNECT takes precedence over TIMEOUT
        //
        if (fsm.IsTimedOut()) 
        {
            error = ERROR_WINHTTP_TIMEOUT;
        } 
        else if (fsm.IsCountedOut()) 
        {
            error = ERROR_WINHTTP_CANNOT_CONNECT;
        }
    } 
    else if (error != ERROR_NOT_ENOUGH_MEMORY)
    {

        //
        // not aborted, timed-out, counted-out, or offline. We can try again
        //

        bRestartable = TRUE;
    }

    //
    // if the socket is open, close it and try the next connection. Invalidate
    // the address we tried
    //

    if (IsOpen()) 
    {
        Close();
    }

    DWORD mappedError = fsm.GetMappedError();

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("mapped error = %d [%s]\n",
                mappedError,
                InternetMapError(mappedError)
                ));

    //
    // don't invalidate address if from-cache-if-net-fail timeout
    //

    BOOL bInvalidate = TRUE;

    if ((pObject != NULL) && pObject->IsFromCacheTimeoutSet()) 
    {
        bInvalidate = FALSE;
    }
    
    if ((mappedError == WSAENETUNREACH)
        || (mappedError == WSAETIMEDOUT)
        || ((error == ERROR_WINHTTP_TIMEOUT) && bInvalidate)
        || (error == ERROR_WINHTTP_CANNOT_CONNECT)
#ifdef TEST_CODE
        || (error == (DWORD)-1)
#endif
        ) 
    {
        fsm.m_pServerInfo->InvalidateAddress(fsm.m_dwResolutionId,
                                             fsm.m_dwAddressIndex
                                             );
    }

    //
    // if the operation was cancelled or we lost connectivity then quit
    //

    if (bRestartable) 
    {
        fsm.SetNextState(FSM_STATE_INIT);

        //bug 37206
        fsm.SetError(ERROR_SUCCESS);
        error = ERROR_SUCCESS;
    } 
    else 
    {
        fsm.SetDone(error);

        PERF_LEAVE(Connect_Error);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Finish(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Called when the connection has been successfully established

Arguments:

    Fsm - socket connect FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Finish",
                 "{%#x [%#x/%d]}, %#x(%d, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Finish);

    CFsm_SocketConnect & fsm = *Fsm;

    // INET_ASSERT(IsOpen());
    
    if (IsAborted())
    {
        return ERROR_WINHTTP_OPERATION_CANCELLED;
    }

    //
    // store the average connect time to this server in our CServerInfo
    //

    if (fsm.m_pServerInfo != NULL) {
        fsm.m_pServerInfo->UpdateConnectTime(fsm.ReadTimer());
    }
    if (fsm.m_pOriginServer != NULL) {
        fsm.m_pOriginServer->UpdateConnectTime(fsm.ReadTimer());
    }

#ifdef TEST_CODE
    BOOL optval;
    int optlen = sizeof(optval);
    int serr = _I_getsockopt(GetSocket(),
                             IPPROTO_TCP,
                             TCP_NODELAY,
                             (char FAR *)&optval,
                             &optlen
                             );

    if (serr != 0) {
        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("getsockopt(TCP_NODELAY) returns %s (%d)\n",
                    InternetMapError(_I_WSAGetLastError()),
                    _I_WSAGetLastError()
                    ));
    }
#endif

    //
    // no longer performing socket operation - clear abort handle
    //

    INET_ASSERT(fsm.GetMappedHandleObject() != NULL);

    if (fsm.GetMappedHandleObject() != NULL) {
        fsm.GetMappedHandleObject()->ResetAbortHandle();
    }

    //
    // set the send & receive buffer sizes if not -1 (meaning don't change)
    //

    DWORD bufferLength;

    bufferLength = GetBufferLength(ReceiveBuffer);
    if (bufferLength != (DWORD)-1) {
        SetBufferLength(ReceiveBuffer, bufferLength);
    }
    bufferLength = GetBufferLength(SendBuffer);
    if (bufferLength != (DWORD)-1) {
        SetBufferLength(SendBuffer, bufferLength);
    }

    //
    // disable send coalescing
    //

    SetSendCoalescing(FALSE);

    //
    // let the app know we connected to the server successfully
    //

    if (fsm.m_dwFlags & SF_INDICATE) {
        InternetIndicateStatusAddress(WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER,
                                      fsm.m_pAddress->RemoteAddr.lpSockaddr,
                                      fsm.m_pAddress->RemoteAddr.iSockaddrLength
                                      );
    }

    fsm.SetDone();

    PERF_LEAVE(Connect_Finish);

    DEBUG_LEAVE(ERROR_SUCCESS);

    return ERROR_SUCCESS;
}


int
ICSocket::SocksConnect(
    IN LPSOCKADDR_IN pSockaddr,
    IN INT nLen
    )

/*++

Routine Description:

    Connect to remote host via SOCKS proxy. Modified from original. If we are
    here then we are going specifically via a known SOCKS proxy. There is now
    only one Hosts object, containing a single SOCKD socks proxy address and
    user name

    N.B. Irrespective of whether we are non-blocking, this function executes
    in blocking mode (we expect that we are on an intranet and complete quickly)

Arguments:

    pSockaddr   - address of remote host (on other side of SOCKS firewall)

    nLen        - length of *pSockaddr

Return Value:

    int
        Success - 0

        Failure - -1

--*/

{
    UNREFERENCED_PARAMETER(nLen);
    DEBUG_ENTER((DBG_SOCKETS,
                 Int,
                 "ICSocket::SocksConnect",
                 "{%#x} %#x, %d",
                 GetSocket(),
                 pSockaddr,
                 nLen
                 ));

    //
    // BUGBUG - should check if the socket type is SOCK_STREAM or if we have
    //          already connected this socket. This code was part of original
    //          general purpose solution. We don't need it
    //

    //
    // initialize sockaddr for connecting to SOCKS firewall
    //

    struct sockaddr_in sin;

    sin.sin_family = AF_INET;
    sin.sin_port = _I_htons(m_SocksPort);
    sin.sin_addr.s_addr = m_SocksAddress;
    memset(&sin.sin_zero, 0, sizeof(sin.sin_zero));

    //
    // initialize SOCKS request packet
    //

    struct {
        unsigned char VN;
        unsigned char CD;
        unsigned short DSTPORT;
        unsigned long  DSTIP;
        char UserId[255];
    } request;

    request.VN = 4;
    request.CD = 1;
    request.DSTPORT = pSockaddr->sin_port;
    request.DSTIP = pSockaddr->sin_addr.s_addr;

    DWORD length = sizeof(request.UserId);

    length += 8 + 1; // 8 == sizeof fixed portion of request;
                     // +1 for additional '\0'

    //
    // put socket into blocking mode
    //

    BOOL non_blocking = IsNonBlocking();

    if (non_blocking) {
        SetNonBlockingMode(FALSE);
    }

    //
    // communicate with SOCKS firewall: send SOCKS request & receive response
    //

    int serr = _I_connect(m_Socket, (LPSOCKADDR)&sin, sizeof(sin));

    if (serr != SOCKET_ERROR) {
        serr = _I_send(m_Socket, (char *)&request, length, 0);
        if (serr == (int)length) {

            char response[256];


            serr = _I_recv(m_Socket, (char *)response, sizeof(response), 0);
            if( serr == 1 ) {
                // need to read at least 2 bytes
                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("need to read one more byte\n"));
                serr = _I_recv(  
                    m_Socket, (char *)(&response[1]), sizeof(response) - 1, 0);
            }

            if (serr != SOCKET_ERROR) {
                if (response[1] != 90) {
                    serr = SOCKET_ERROR;
                }

            } else {

                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("recv(%#x) returns %d\n",
                            m_Socket,
                            _I_WSAGetLastError()
                            ));

            }
        } else {

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("send(%#x) returns %d\n",
                        m_Socket,
                        _I_WSAGetLastError()
                        ));

            serr = SOCKET_ERROR;
        }
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("connect(%#x) returns %d\n",
                    m_Socket,
                    _I_WSAGetLastError()
                    ));

    }

    //
    // if originally non-blocking, make socket non-blocking again
    //

    if (non_blocking) {
        SetNonBlockingMode(TRUE);
    }

    //
    // if success, mark the socket as being connected through firewall
    //

    if (serr == SOCKET_ERROR) {
        _I_WSASetLastError(WSAECONNREFUSED);
    }

    DEBUG_LEAVE(serr);

    return serr;
}


DWORD
ICSocket::Disconnect(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Undoes the work of ConnectSocket - i.e. closes a connected socket. We make
    callbacks to inform the app that this socket is being closed

Arguments:

    dwFlags - controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Disconnect",
                 "{%#x/%d} %#x",
                 GetSocket(),
                 GetSourcePort(),
                 dwFlags
                 ));

    //
    // let the app know we are closing the connection
    //

    if (dwFlags & SF_INDICATE) {
        InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION, NULL, 0);
    }

    DWORD error = Close();

    if ((error == ERROR_SUCCESS) && (dwFlags & SF_INDICATE)) {

        //
        // let the app know the connection is closed
        //

        InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED, NULL, 0);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Close(
    VOID
    )

/*++

Routine Description:

    Closes a connected socket. Assumes that any linger or shutdown etc.
    requirements have already been applied to the socket

Arguments:

    none.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Close",
                 "{%#x/%d}",
                 GetSocket(),
                 GetSourcePort()
                 ));

    DWORD error = ERROR_SUCCESS;

    if (IsOpen()) {
//dprintf("**** closing %#x\n", m_Socket);

        int serr;
        SOCKET hSocket;
        
        // remove socket handle from ICSocket before closesocket()

        hSocket= m_Socket;
        m_Socket = INVALID_SOCKET;

        __try {
            serr = _I_closesocket(hSocket);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            serr = 0;
        }
        ENDEXCEPT
        error = (serr == SOCKET_ERROR)
            ? MapInternetError(_I_WSAGetLastError())
            : ERROR_SUCCESS;
    }

    //
    // the socket is now closed
    //

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Abort(
    VOID
    )

/*++

Routine Description:

    Aborts a socket by simply closing it

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Abort",
                 "{%#x/%d}",
                 GetSocket(),
                 GetSourcePort()
                 ));

    // set aborted flag before close

    SetAborted();

    DWORD error = Close();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Shutdown(
    IN DWORD dwControl
    )

/*++

Routine Description:

    Stops any more send/receives from the socket

Arguments:

    dwControl   - 0 to stop receives, 1 to stop sends, 2 to stop both

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Shutdown",
                 "{%#x/%d}",
                 GetSocket(),
                 GetSourcePort()
                 ));

    DWORD error = ERROR_SUCCESS;

    if (IsOpen()) {

        int serr = _I_shutdown(m_Socket, dwControl);

        if (serr == SOCKET_ERROR) {

            //
            // map any sockets error to WinHttp error
            //

            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
ICSocket::IsReset(
    VOID
    )

/*++

Routine Description:

    Determines if the socket has been closed. We peek the socket for 1 byte. If
    the socket is in blocking mode, we temporarily switch to non-blocking to
    perform the test - we don't want to block, nor remove any data from the
    socket

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - socket reset (closed by server)

        FALSE   - socket alive

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "ICSocket::IsReset",
                 "{%#x [%#x/%d]}",
                 this,
                 GetSocket(),
                 GetSourcePort()
                 ));

    CHECK_ICSOCKET();

    BOOL bReset = FALSE;
    BOOL bSetBlocking = FALSE;

    if (IsOpen()) {
        if (!IsNonBlocking()) {
            SetNonBlockingMode(TRUE);
            bSetBlocking = TRUE;
        }

        char ch;
#ifndef unix
        int n = _I_recv(m_Socket, &ch, 1, MSG_PEEK);
        if (n < 0) {

            DWORD error = _I_WSAGetLastError();

            if (error != WSAEWOULDBLOCK) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("recv() returns %s (%d)\n",
                            InternetMapError(error),
                            error
                            ));

                n = 0;
            }
        }
        if (n == 0) {
#else
        DWORD dwAvail = 0;
        int n = _I_ioctlsocket(m_Socket,FIONREAD,&dwAvail);
        if (n != 0) {
#endif /* unix */
            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("socket %#x/port %d is reset\n",
                        m_Socket,
                        m_SourcePort
                        ));

            bReset = TRUE;
        }
        if (bSetBlocking) {
            SetNonBlockingMode(FALSE);
        }
    } else {
        bReset = TRUE;
    }

    DEBUG_LEAVE(bReset);

    return bReset;
}


DWORD
ICSocket::SetTimeout(
    IN DWORD Type,
    IN int Timeout
    )

/*++

Routine Description:

    Sets a timeout value for a connected socket

Arguments:

    Type            - type of timeout to set - send, or receive

    Timeout         - timeout value to set

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetTimeout",
                 "{%#x/%d} %s (%d), %d",
                 GetSocket(),
                 GetSourcePort(),
                 (Type == SEND_TIMEOUT) ? "SEND_TIMEOUT"
                    : (Type == RECEIVE_TIMEOUT) ? "RECEIVE_TIMEOUT"
                    : "?",
                 Type,
                 Timeout
                 ));

    INET_ASSERT((Type == SEND_TIMEOUT) || (Type == RECEIVE_TIMEOUT));

    if (Timeout == INFINITE)
    {
        Timeout = 0;
    }
    
    int serr = _I_setsockopt(m_Socket,
                             SOL_SOCKET,
                             (Type == SEND_TIMEOUT)
                                ? SO_SNDTIMEO
                                : SO_RCVTIMEO,
                             (const char FAR *)&Timeout,
                             sizeof(Timeout)
                             );

    DWORD error = ERROR_SUCCESS;

    if (serr == SOCKET_ERROR) {
        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetLinger(
    IN BOOL Linger,
    IN int Timeout
    )

/*++

Routine Description:

    Sets the linger option for a connected socket

Arguments:

    Linger  - FALSE if the caller wants immediate shutdown of the socket
              when closed, or TRUE if we are to wait around until
              queued data has been sent

    Timeout - timeout value to use if Linger is TRUE

Return Value:

    DWORD
        Success - ERROR_SUCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetLinger",
                 "{%#x/%d} %B, %d",
                 GetSocket(),
                 GetSourcePort(),
                 Linger,
                 Timeout
                 ));

    DWORD error = ERROR_SUCCESS;

    if (IsAborted()) {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
    } else if (IsOpen()) {

        LINGER linger;

        INET_ASSERT(Timeout <= USHRT_MAX);

        linger.l_onoff = (u_short)(Linger ? 1 : 0);
        linger.l_linger = (u_short)Timeout;


        //
        // in some shutdown situations, we are hitting exception in winsock
        // on win95 (!). Handle exception
        //

        __try {
            if (_I_setsockopt(m_Socket,
                              SOL_SOCKET,
                              SO_LINGER,
                              (const char FAR *)&linger,
                              sizeof(linger)
                              ) == SOCKET_ERROR) {
                error = MapInternetError(_I_WSAGetLastError());
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // do nothing except catch exception in retail
            //

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("exception closing socket %#x/%d\n",
                        GetSocket(),
                        GetSourcePort()
                        ));

            INET_ASSERT(IsOpen());

        }
        ENDEXCEPT
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetNonBlockingMode(
    IN BOOL bNonBlocking
    )

/*++

Routine Description:

    Sets socket non-blocking/blocking mode

Arguments:

    bNonBlocking    - TRUE if non-blocking, FALSE if blocking

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetNonBlockingMode",
                 "{%#x/%d} %B",
                 GetSocket(),
                 GetSourcePort(),
                 bNonBlocking
                 ));

    u_long on = (bNonBlocking) ? 1 : 0;
    DWORD error = ERROR_SUCCESS;

    if (_I_ioctlsocket(m_Socket, FIONBIO, &on) == 0) {
        if (on) {
            m_dwFlags |= SF_NON_BLOCKING;
        } else {
            m_dwFlags &= ~SF_NON_BLOCKING;
        }
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to put socket %#x/port %d into %sblocking mode\n",
                    m_Socket,
                    m_SourcePort,
                    on ? "non-" : ""
                    ));

        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::GetBufferLength(
    IN SOCKET_BUFFER_ID SocketBufferId
    )

/*++

Routine Description:

    Returns the send or receive buffer length for this socket object

Arguments:

    SocketBufferId  - which buffer length to return

Return Value:

    DWORD

--*/

{
    //
    // BUGBUG - RLF 04/29/96
    //
    // This function should access first the current object, then the parent
    // object, then the globals for this data
    //

    switch (SocketBufferId) {
    case ReceiveBuffer:
        return GlobalSocketReceiveBufferLength;

    case SendBuffer:
        return GlobalSocketSendBufferLength;
    }
    return (DWORD)-1;
}


DWORD
ICSocket::GetBufferLength(
    IN SOCKET_BUFFER_ID SocketBufferId,
    OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Gets the socket send or receive buffer length (if supported)

Arguments:

    SocketBufferId      - which buffer to set

    lpdwBufferLength    - where to write length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Int,
                 "ICSocket::GetBufferLength",
                 "{%#x/%d} %s, %#x",
                 GetSocket(),
                 GetSourcePort(),
                 (SocketBufferId == ReceiveBuffer)
                    ? "ReceiveBuffer"
                    : ((SocketBufferId == SendBuffer)
                        ? "SendBuffer"
                        : "?")
                 ));

    DWORD size = sizeof(*lpdwBufferLength);

    int serr = _I_getsockopt(m_Socket,
                             SOL_SOCKET,
                             SocketBufferId,
                             (char FAR *)lpdwBufferLength,
                             (int FAR *)&size
                             );

    DWORD error;

    if (serr != SOCKET_ERROR) {
        error = ERROR_SUCCESS;
    } else {
        error = MapInternetError(_I_WSAGetLastError());
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetBufferLength(
    IN SOCKET_BUFFER_ID SocketBufferId,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Sets the socket send or receive buffer length

Arguments:

    SocketBufferId  - which buffer to set

    dwBufferLength  - length to set it to

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetBufferLength",
                 "{%#x/%d} %s, %d",
                 GetSocket(),
                 GetSourcePort(),
                 (SocketBufferId == ReceiveBuffer)
                    ? "ReceiveBuffer"
                    : (SocketBufferId == SendBuffer)
                        ? "SendBuffer"
                        : "?",
                 dwBufferLength
                 ));

    INET_ASSERT((int)dwBufferLength >= 0);

    DWORD size = sizeof(dwBufferLength);

    int serr = _I_setsockopt(m_Socket,
                             SOL_SOCKET,
                             SocketBufferId,
                             (const char FAR *)&dwBufferLength,
                             (int)size
                             );

    DWORD error = ERROR_SUCCESS;

    if (serr == SOCKET_ERROR) {
        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetSendCoalescing(
    IN BOOL bOnOff
    )

/*++

Routine Description:

    Enables or disables Nagle algorithm

Arguments:

    bOnOff  - FALSE to disable, TRUE to enable

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetSendCoalescing",
                 "{%#x/%d} %B",
                 GetSocket(),
                 GetSourcePort(),
                 bOnOff
                 ));

    int optval = bOnOff ? 0 : 1;
    int serr = _I_setsockopt(m_Socket,
                             IPPROTO_TCP,
                             TCP_NODELAY,
                             (const char FAR *)&optval,
                             sizeof(optval)
                             );

    DWORD error = ERROR_SUCCESS;

    if (serr == SOCKET_ERROR) {
        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


VOID
ICSocket::SetSourcePort(
    VOID
    )

/*++

Routine Description:

    Record the port we are connected to locally. Useful for debugging & matching
    up socket with net sniff

Arguments:

    None.

Return Value:

    None.

--*/

{
    sockaddr_storage address;  // Large enough for any address family.

    int namelen = sizeof(address);

    if (_I_getsockname(GetSocket(), (LPSOCKADDR)&address, &namelen) == 0) {
        //
        // The port number field is in the same location in both a
        // sockaddr_in and a sockaddr_in6, so it is safe to cast the
        // sockaddr to sockaddr_in here - this works for IPv4 or IPv6.
        //
        INET_ASSERT(offsetof(SOCKADDR_IN, sin_port) == offsetof(SOCKADDR_IN6, sin6_port));
        m_SourcePort = (INTERNET_PORT)_I_ntohs(((LPSOCKADDR_IN)&address)->sin_port);
    } else {
        m_SourcePort = 0;
    }
}


DWORD
ICSocket::Send(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Sends data over connected socket

Arguments:

    lpBuffer        - pointer to buffer containing data to send

    dwBufferLength  - length of lpBuffer in bytes

    dwFlags         - flags controlling send:

                        SF_INDICATE     - make status callbacks to the app when
                                          we are starting to send data and when
                                          we finish

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Send",
                 "{%#x [%#x/%d]} %#x, %d, %#x",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 lpBuffer,
                 dwBufferLength,
                 dwFlags
                 ));

    INET_ASSERT(lpBuffer != NULL);
    INET_ASSERT((int)dwBufferLength > 0);

    DWORD error = DoFsm(New CFsm_SocketSend(lpBuffer,
                                            dwBufferLength,
                                            dwFlags,
                                            this
                                            ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SocketSend::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_SocketSend state

Arguments:

    Fsm - socket send FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SocketSend::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSocket * pSocket = (ICSocket *)Fsm->GetContext();
    CFsm_SocketSend * stateMachine = (CFsm_SocketSend *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
    case FSM_STATE_ERROR:
        error = pSocket->Send_Start(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Send_Start(
    IN CFsm_SocketSend * Fsm
    )

/*++

Routine Description:

    Continues send request - sends the data

Arguments:

    Fsm - socket send FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Send_Start",
                 "{%#x [%#x/%d]} %#x(%#x, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_lpBuffer,
                 Fsm->m_dwBufferLength,
                 Fsm->m_dwFlags
                 ));

    CFsm_SocketSend & fsm = *Fsm;
    DWORD error = fsm.GetError();
    FSM_STATE state = fsm.GetState();
    INTERNET_HANDLE_OBJECT * pObject = fsm.GetMappedHandleObject();

    if (error != ERROR_SUCCESS) 
    {
        goto quit;
    }
    if (state == FSM_STATE_INIT) {
        if (!(m_dwFlags & (SF_ENCRYPT | SF_DECRYPT))) {

            DEBUG_DUMP_API(SOCKETS,
                           "sending data:\n",
                           fsm.m_lpBuffer,
                           fsm.m_dwBufferLength
                           );

            TRACE_DUMP_API_IF_REQUEST(SOCKETS,
                           "sending data:\n",
                           fsm.m_lpBuffer,
                           fsm.m_dwBufferLength,
                            (HANDLE_OBJECT *)(fsm.GetMappedHandle())
                           );
        }

        if (pObject != NULL) {
            pObject->SetAbortHandle(this);
        }
        
        if (fsm.m_dwFlags & SF_INDICATE) {
            error = InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_SENDING_REQUEST, NULL, 0);

            if (error != ERROR_SUCCESS)
            {
                INET_ASSERT(error == ERROR_WINHTTP_OPERATION_CANCELLED);
                goto quit;
            }
        }

        fsm.StartTimer();
    }
    
    while (fsm.m_dwBufferLength != 0) 
    {
        //
        // the socket may have already been aborted
        //

        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
            break;
        }

        if (fsm.m_pServerInfo != NULL) {
            fsm.m_pServerInfo->SetLastActiveTime();
        }

        DWORD dwSendSize;
#define GLOBAL_MAX_SEND_LENGTH_DEFAULT (4*1024*1024)
        if (fsm.m_dwBufferLength > GLOBAL_MAX_SEND_LENGTH_DEFAULT)
        {
            dwSendSize = GLOBAL_MAX_SEND_LENGTH_DEFAULT;
        }
        else
        {
            dwSendSize = fsm.m_dwBufferLength;
        }
        
        int nSent;
        
        if (IsNonBlocking()) 
        {
            if (fsm.bIOCPInited)
            {
                fsm.bIOCPInited = FALSE;

                if (fsm.bIOCPSuccess)
                {
                    //send completed successfully
                    DEBUG_PRINT(SOCKETS,
                                INFO,
                                ("WSASend sent %d bytes @ %#x to socket %#x/port %d\n",
                                fsm.dwBytesTransferred,
                                fsm.m_lpBuffer,
                                m_Socket,
                                m_SourcePort
                                ));
                                
                    error = ERROR_SUCCESS;

                    nSent = (int)fsm.dwBytesTransferred;
                    fsm.m_iTotalSent = nSent;
                    fsm.m_lpBuffer = (LPBYTE)fsm.m_lpBuffer + nSent;
                    fsm.m_dwBufferLength -= nSent;
                    continue;
                }
                else
                {
                    //
                    // map any sockets error to WinHttp error and terminate this
                    // request
                    //

                    //VENKATKBUG - handle retrieable errors such as WSAWOULDBLOCK
                    
                    DEBUG_PRINT(SOCKETS,
                                ERROR,
                                ("send() returns %d (%s)\n",
                                error,
                                InternetMapError(error)
                                ));

                    error = MapInternetError(error);
                    break;
                }
            }// if fsm.bIOCPInited()
    
                
            WSABUF wsabuf;
            wsabuf.len = dwSendSize; //fsm.m_dwBufferLength;
            wsabuf.buf = (char FAR *)fsm.m_lpBuffer;
            int nError;

            //
            // First try Winsock Fast I/O: see if Winsock can
            // satisfy the send call immediately. If it fails,
            // we assume the error is WSAWOULDBLOCK and then
            // try WSASend again with the lpOverlapped parameter.
            //
            nError = _I_WSASend(m_Socket,
                            &wsabuf,
                            1,
                            (LPDWORD)&nSent,
                            0,
                            NULL,
                            NULL);

            if (nError == 0)
            {
                fsm.m_iTotalSent = nSent;
                fsm.m_lpBuffer = (LPBYTE)fsm.m_lpBuffer + nSent;
                fsm.m_dwBufferLength -= nSent;
                continue;
            }
            else
            {
                INET_ASSERT (nError == SOCKET_ERROR);

                error = _I_WSAGetLastError();
            }

            //
            // Slow path: issue an async recv call, with the results
            // to be posted to our I/O completion port.
            //
            if (!_lpWrapOverlappedSend)
            {
                _lpWrapOverlappedSend = New CWrapOverlapped();

                if (!_lpWrapOverlappedSend)
                {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                    goto quit;
                }
            }

            CWrapOverlapped* lpWrapOverlapped = _lpWrapOverlappedSend;
            LPWSAOVERLAPPED lpOverlapped = _lpWrapOverlappedSend->GetOverlapped();
            memset(lpOverlapped, 0, sizeof(WSAOVERLAPPED));
            
            CFsm* pFsmOld = GetAndSetCurrentFsm(&fsm);
            UNREFERENCED_PARAMETER(pFsmOld); // eliminate C4701 in free builds
            INET_ASSERT (pFsmOld == NULL);

            fsm.bIOCPInited = TRUE;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("calling WSASend() blocked, socket %#x, port %d\n",
                        m_Socket,
                        m_SourcePort
                        ));

            fsm.SetAction(FSM_ACTION_SEND);

            DWORD timeout = GetTimeoutValue(WINHTTP_OPTION_SEND_TIMEOUT);

            if (timeout != INFINITE)
            {
                fsm.SetTimeout(timeout);
                
#ifdef USE_OLD_SENDRECV_SYNC

                fsm.SetOnAsyncList(TRUE);
#else
                //additional reference for timeout queue
                fsm.Reference();
                fsm.SetPop(FALSE);
#endif

                if (Fsm->GetMappedHandleObject())
                {
                    Fsm->GetMappedHandleObject()->Reference();
                }

                error = QueueTimeoutFsm(Fsm, m_Socket);
                
                if (error != ERROR_IO_PENDING)
                {
                    // 2 causes - both irrecoverable
                    // 1. no global pointer to ICAsyncThread (impossible)
                    // OR 2. no threadinfo or SelectThread or out of memory.
                    // so bail!
                    GetAndSetCurrentFsm(NULL);
                    fsm.bIOCPInited = FALSE;

#ifdef USE_OLD_SENDRECV_SYNC

                    fsm.SetOnAsyncList(FALSE);
#else
                    if (Fsm->GetMappedHandleObject())
                    {
                        Fsm->GetMappedHandleObject()->Dereference();
                    }

                    DWORD dwDummy = 0;
                    fsm.Dereference(&dwDummy);
#endif

                    fsm.SetErrorState(error);
                    goto quit;
                }
            }

            _lpWrapOverlappedSend->Reference(); // to keep this ICSocket=>the Overlapped struct valid beyong the WSASend() call.
            _lpWrapOverlappedSend->Reference(); // to make sure it stays alive for the IOCP to get the fsm off it.
            
            DEBUG_ENTER((DBG_API,
                             Dword,
                             "***WSASend",
                             "(m_Socket)%#x, (wsabuf.buf)%#x, (wsabuf.len)%#x, (this)%#x, (overlapped)%#x, (fsm)%#x",
                             m_Socket,
                             wsabuf.buf,
                             wsabuf.len,
                             this,
                             lpOverlapped,
                             &fsm
                             ));
                             
            nError = _I_WSASend(m_Socket,
                            &wsabuf,
                            1,
                            (LPDWORD)&nSent,
                            0,
                            lpOverlapped,
                            NULL);


            DEBUG_LEAVE(nError);                        

            lpWrapOverlapped->Dereference(); // release the WSASend reference.
            
            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("WSASend() returns %d (%s) with nSent=%d bytes\n",
                        nError,
                        InternetMapError(nError),
                        nSent
                        ));

            if (nError == 0)
            {
#if INET_DEBUG
                InterlockedIncrement(&g_cWSACompletions);
#endif
                 error = ERROR_IO_PENDING;
                 break;
            }
            else
            {
                INET_ASSERT (nError == SOCKET_ERROR);

                error = _I_WSAGetLastError();

                if (error == WSA_IO_PENDING) 
                {
#if INET_DEBUG
                    InterlockedIncrement(&g_cWSACompletions);
#endif
                    error = ERROR_IO_PENDING;
                    break;
                } 
                else
                {
                    // no IOCompletion here.
                    if (fsm.HasTimeout())
                    {

#ifdef USE_OLD_SENDRECV_SYNC

                        if (!RemoveFsmFromAsyncList(&fsm))
                        {
                            //the select thread already enforced timeout and updated state
                        }
#else
                        if (!fsm.TestAndSetValidForIOCPProcessing())
                        {
                            //the select thread already enforced timeout and updated state
                        }
#endif

                    }

                    GetAndSetCurrentFsm(NULL);
                    lpWrapOverlapped->Dereference(); // release the IOCP-based reference.
                    
                    //
                    // check first to see if the error was due to the socket being
                    // closed as a result of the request being cancelled
                    //
                    if (IsAborted()) 
                    {
                        error = ERROR_WINHTTP_OPERATION_CANCELLED;
                        break;
                    }
                    
                    //
                    // map any sockets error to WinHttp error and terminate this
                    // request
                    //

                    error = MapInternetError(error);
                    break;
                }
            }//if! nError == 0
        }
        else// if IsNonBlocking()
        {
            nSent = _I_send(m_Socket,
                                (char FAR *)fsm.m_lpBuffer,
                                dwSendSize, //fsm.m_dwBufferLength,
                                0
                                );

            if (nSent != SOCKET_ERROR) 
            {
                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("sent %d bytes @ %#x to socket %#x/port %d\n",
                            nSent,
                            fsm.m_lpBuffer,
                            m_Socket,
                            m_SourcePort
                            ));

                fsm.m_iTotalSent += nSent;
                fsm.m_lpBuffer = (LPBYTE)fsm.m_lpBuffer + nSent;
                fsm.m_dwBufferLength -= nSent;
            } 
            else 
            {
                //
                // check first to see if the error was due to the socket being
                // closed as a result of the request being cancelled
                //

                if (IsAborted()) 
                {
                    error = ERROR_WINHTTP_OPERATION_CANCELLED;
                    break;
                } 
                else 
                {
                    error = _I_WSAGetLastError();
                    //
                    // map any sockets error to WinHttp error and terminate this
                    // request
                    //

                    DEBUG_PRINT(SOCKETS,
                                ERROR,
                                ("send() returns %d (%s)\n",
                                error,
                                InternetMapError(error)
                                ));

                    error = MapInternetError(error);
                    break;
                }
            }// if! nSent!=SOCKET_ERROR
        }// if! IsNonBlocking()
    }// while fsm.m_dwBufferLength != 0

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.StopTimer();
        if (fsm.GetMappedHandleObject() != NULL) {
            fsm.GetMappedHandleObject()->ResetAbortHandle();
        }
        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        } else if (error == ERROR_SUCCESS) {
            if (fsm.m_dwFlags & SF_INDICATE) 
            {
                INT iTotalSent = fsm.m_iTotalSent;
                InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_REQUEST_SENT,
                                       &iTotalSent,
                                       sizeof(iTotalSent)
                                       );
            }
            if (fsm.m_pServerInfo != NULL) {
                //fsm.m_pServerInfo->UpdateSendTime(fsm.ReadTimer());
            }
        }
        fsm.SetDone(error);
    }

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//ICSocket::SendTo(
//    IN LPSOCKADDR lpDestination,
//    IN DWORD dwDestinationLength,
//    IN LPVOID lpBuffer,
//    IN DWORD dwBufferLength,
//    OUT LPDWORD lpdwBytesSent,
//    IN DWORD dwWinsockFlags,
//    IN DWORD dwFlags
//    )
//
///*++
//
//Routine Description:
//
//    Wrapper for sendto()
//
//Arguments:
//
//    lpDestination       - pointer to remote address to send to
//
//    dwDestinationLength - length of *lpDestination
//
//    lpBuffer            - pointer to buffer containing data to send
//
//    dwBufferLength      - number of bytes to send from lpBuffer
//
//    lpdwBytesSent       - number of bytes sent to destination
//
//    dwWinsockFlags      - flags to pass through to sendto()
//
//    dwFlags             - ICSocket flags
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
//                    The operation was cancelled by the caller
//
//                  ERROR_WINHTTP_TIMEOUT
//                    The operation timed out
//
//                  ERROR_WINHTTP_CONNECTION_ERROR
//                    An error occurred. We approximate to connection reset
//
//                  WSA error
//                    Some other sockets error occurred
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::SendTo",
//                 "{%#x} %#x, %d, %#x, %d, %#x, %#x, %#x",
//                 m_Socket,
//                 lpDestination,
//                 dwDestinationLength,
//                 lpBuffer,
//                 dwBufferLength,
//                 lpdwBytesSent,
//                 dwWinsockFlags,
//                 dwFlags
//                 ));
//
//    INET_ASSERT(IsSocketValid());
//    INET_ASSERT(lpdwBytesSent != NULL);
//
//    int totalSent = 0;
//    DWORD error = ERROR_SUCCESS;
//    INTERNET_HANDLE_OBJECT * pObject = NULL;
//    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
//    BOOL fNonBlocking;
//
//    if (IsAborted()) {
//        error = ERROR_WINHTTP_OPERATION_CANCELLED;
//        goto quit;
//    }
//
//    if (lpThreadInfo == NULL) {
//
//        INET_ASSERT(FALSE);
//
//        error = ERROR_WINHTTP_INTERNAL_ERROR;
//        goto quit;
//    }
//
//    fNonBlocking = lpThreadInfo->IsAsyncWorkerThread;
//
//    //
//    // set the cancel socket in the object
//    //
//
//    pObject = (INTERNET_HANDLE_OBJECT * )lpThreadInfo->hObjectMapped;
//    if (pObject != NULL) {
//        pObject->SetAbortHandle(this);
//    }
//
//    //
//    // if we are in async (== non-blocking) mode, let the async request
//    // scheduler know what operation we will be waiting on
//    //
//
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION(lpThreadInfo->lpArb, m_Socket, SEND);
//    }
//
//    if (dwFlags & SF_INDICATE) {
//
//        //
//        // let the app know we are starting to send data
//        //
//
//        InternetIndicateStatus(INTERNET_STATUS_SENDING_REQUEST,
//                               NULL,
//                               0
//                               );
//    }
//
//    DEBUG_DUMP(SOCKETS,
//               "sending data:\n",
//               lpBuffer,
//               dwBufferLength
//               );
//
//    int nSent;
//
//    //
//    // loop until all data sent
//    //
//
//    do {
//
//        nSent = _I_sendto(m_Socket,
//                          (char FAR *)lpBuffer + totalSent,
//                          dwBufferLength,
//                          dwWinsockFlags,
//                          lpDestination,
//                          dwDestinationLength
//                          );
//        if (nSent != SOCKET_ERROR) {
//
//            DEBUG_PRINT(SOCKETS,
//                        INFO,
//                        ("sent %d bytes @ %#x on socket %#x\n",
//                        nSent,
//                        (LPBYTE)lpBuffer + totalSent,
//                        m_Socket
//                        ));
//
//            INET_ASSERT(nSent > 0);
//
//            totalSent += nSent;
//            dwBufferLength -= nSent;
//        } else {
//            error = _I_WSAGetLastError();
//            if ((error == WSAEWOULDBLOCK) && fNonBlocking) {
//
//                INET_ASSERT(_dwFlags & SF_NON_BLOCKING);
//
//                DEBUG_PRINT(SOCKETS,
//                            INFO,
//                            ("sendto(%#x) would block\n",
//                            m_Socket
//                            ));
//
//                lpThreadInfo->lpArb->Header.dwResultCode = ERROR_SUCCESS;
//
//                SwitchToAsyncScheduler(m_Socket);
//
//                error = lpThreadInfo->lpArb->Header.dwResultCode;
//
//                DEBUG_PRINT(SOCKETS,
//                            INFO,
//                            ("sendto(%#x) resumed, returns %s\n",
//                            m_Socket,
//                            InternetMapError(error)
//                            ));
//
//                if (error != ERROR_SUCCESS) {
//                }
//            } else {
//
//                //
//                // some other error
//                //
//
//                error = MapInternetError(error);
//            }
//        }
//
//        INET_ASSERT((int)dwBufferLength >= 0);
//
//    } while ((dwBufferLength != 0) && (error == ERROR_SUCCESS));
//
//    if ((dwFlags & SF_INDICATE) && (error == ERROR_SUCCESS)) {
//
//        //
//        // let the app know we have finished sending
//        //
//
//        InternetIndicateStatus(INTERNET_STATUS_REQUEST_SENT,
//                               &totalSent,
//                               sizeof(totalSent)
//                               );
//    }
//
//    //
//    // if we are in async (== non-blocking) mode, let the async request
//    // scheduler know that we no longer require this socket
//    //
//
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION(lpThreadInfo->lpArb, INVALID_SOCKET, SEND);
//    }
//
//quit:
//
//    *lpdwBytesSent = totalSent;
//
//    //
//    // no longer performing operation on this socket
//    //
//
//    if (pObject != NULL) {
//        pObject->ResetAbortHandle();
//
//        //
//        // if the operation has been cancelled, then this error overrides any
//        // other
//        //
//
//        //if (pObject->IsInvalidated()) {
//        //    error = pObject->GetError();
//        //    if (error == ERROR_SUCCESS) {
//        //        error = ERROR_WINHTTP_OPERATION_CANCELLED;
//        //    }
//        //}
//        if (IsAborted()) {
//            error = ERROR_WINHTTP_OPERATION_CANCELLED;
//        }
//    }
//
//    INET_ASSERT((pObject != NULL) ? (pObject->GetAbortHandle() == NULL) : TRUE);
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}


DWORD
ICSocket::Receive(
    IN OUT LPVOID * lplpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwBufferRemaining,
    IN OUT LPDWORD lpdwBytesReceived,
    IN DWORD dwExtraSpace,
    IN DWORD dwFlags,
    OUT LPBOOL lpbEof
    )

/*++

Routine Description:

    Receives data from connected socket. Depending on flags settings, we will
    perform a single receive, loop until we have filled the buffer and/or loop
    until we have received all the data.

    This function returns user data, so if the stream we are receiving from is
    encrypted, we must decrypt the data before returning. This may require
    receiving more data than the user expects because we have to decrypt at
    message boundaries

    This function is intended to be called in a loop. The buffer pointer and
    buffer sizes are intended to be updated by each successive call to this
    function, and should therefore have the same values the next time this
    function is called

Arguments:

    lplpBuffer          - pointer to pointer to users buffer. If supplied, the
                          buffer should be LMEM_FIXED

    lpdwBufferLength    - size of buffer

    lpdwBufferRemaining - number of bytes left in the buffer

    lpdwBytesReceived   - number of bytes received

    dwExtraSpace        - number of additional bytes caller wants at end of
                          buffer (only useful if resizing AND only applied at
                          end of receive)

    dwFlags             - flags controlling receive:

                            SF_EXPAND       - lpBuffer can be expanded to fit
                                              data

                            SF_COMPRESS     - if set, we will shrink the buffer
                                              to compress out any unused space

                            SF_RECEIVE_ALL  - if set, this function will loop
                                              until all data received, or the
                                              supplied buffer is filled

                            SF_INDICATE     - if set, we will make status
                                              callbacks to the app when we are
                                              starting to receive data, and when
                                              we finish

                            SF_WAIT         - (used with SF_NON_BLOCKING). Even
                                              though the socket is non-blocking,
                                              the caller wants us to not
                                              relinquish control under the
                                              request has been satisfied

    lpbEof              - TRUE if we got end-of-connection indication
                          (recv() returns 0)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't allocate/grow buffer

                  ERROR_INSUFFICIENT_BUFFER
                    The initial buffer was insufficient (i.e. caller supplied
                    buffer pointer was NULL, or we ran out of buffer space and
                    are not allowed to resize it)

                  WSA error
                    Sockets error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Receive",
                 "%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B]",
                 lplpBuffer,
                 *lplpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 lpdwBufferRemaining,
                 *lpdwBufferRemaining,
                 lpdwBytesReceived,
                 *lpdwBytesReceived,
                 dwExtraSpace,
                 dwFlags,
                 lpbEof,
                 *lpbEof
                 ));

    INET_ASSERT((int)*lpdwBufferLength >= 0);
    INET_ASSERT((int)*lpdwBufferRemaining >= 0);
    INET_ASSERT((int)*lpdwBytesReceived >= 0);

#define SF_MUTEX_FLAGS  (SF_RECEIVE_ALL | SF_NO_WAIT)

    INET_ASSERT((dwFlags & SF_MUTEX_FLAGS) != SF_MUTEX_FLAGS);

    DWORD error = DoFsm(New CFsm_SocketReceive(lplpBuffer,
                                               lpdwBufferLength,
                                               lpdwBufferRemaining,
                                               lpdwBytesReceived,
                                               dwExtraSpace,
                                               dwFlags,
                                               lpbEof,
                                               this
                                               ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SocketReceive::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_SocketReceive state

Arguments:

    Fsm - socket receive FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SocketReceive::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSocket * pSocket = (ICSocket *)Fsm->GetContext();
    CFsm_SocketReceive * stateMachine = (CFsm_SocketReceive *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
        error = pSocket->Receive_Start(stateMachine);
        break;

    case FSM_STATE_CONTINUE:
    case FSM_STATE_ERROR:
        error = pSocket->Receive_Continue(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Receive_Start(
    IN CFsm_SocketReceive * Fsm
    )

/*++

Routine Description:

    Initiates a receive request - grows the buffer if required and kicks off the
    first receive operation

Arguments:

    Fsm - reference to FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Receive_Start",
                 "{%#x [%#x/%d]} %#x(%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B])",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_lplpBuffer,
                 *Fsm->m_lplpBuffer,
                 Fsm->m_lpdwBufferLength,
                 *Fsm->m_lpdwBufferLength,
                 Fsm->m_lpdwBufferRemaining,
                 *Fsm->m_lpdwBufferRemaining,
                 Fsm->m_lpdwBytesReceived,
                 *Fsm->m_lpdwBytesReceived,
                 Fsm->m_dwExtraSpace,
                 Fsm->m_dwFlags,
                 Fsm->m_lpbEof,
                 *Fsm->m_lpbEof
                 ));

    CFsm_SocketReceive & fsm = *Fsm;
    DWORD error = ERROR_SUCCESS;

    //
    // if we weren't given a buffer, but the caller told us its okay to resize
    // then we allocate the initial buffer
    //

    if ((fsm.m_dwBufferLength == 0) || (fsm.m_dwBufferLeft == 0)) {

        INET_ASSERT((fsm.m_dwBufferLength == 0) ? (fsm.m_dwBufferLeft == 0) : TRUE);

        if (fsm.m_dwFlags & SF_EXPAND) {

            //
            // allocate a fixed memory buffer
            //

            //
            // BUGBUG - the initial buffer size should come from the handle
            //          object
            //

            fsm.m_dwBufferLeft = DEFAULT_RECEIVE_BUFFER_INCREMENT;
            if (fsm.m_dwBufferLength == 0) {
                fsm.m_bAllocated = TRUE;
            }
            fsm.m_dwBufferLength += fsm.m_dwBufferLeft;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("resizing %#x to %d\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer, fsm.m_dwBufferLength, FALSE);
            if (fsm.m_hBuffer == (HLOCAL)NULL) {
                error = GetLastError();

                INET_ASSERT(error != ERROR_SUCCESS);

                fsm.m_bAllocated = FALSE;
            }
        } else {

            //
            // the caller didn't say its okay to resize
            //

            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else if (fsm.m_hBuffer == (HLOCAL)NULL) {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    if (error == ERROR_SUCCESS) {
        if (fsm.GetMappedHandleObject() != NULL) {
            fsm.GetMappedHandleObject()->SetAbortHandle(this);
        }

        //
        // keep the app informed (if requested to do so)
        //

        if (fsm.m_dwFlags & SF_INDICATE) {
            error = InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE, NULL, 0);

            if (error != ERROR_SUCCESS)
            {
                INET_ASSERT(error == ERROR_WINHTTP_OPERATION_CANCELLED);
                fsm.SetError(error);
            }
        }

        //
        // kick off the receive request. If we complete synchronously (with
        // an error or successfully), then call the finish handler here
        //

        error = Receive_Continue(Fsm);
    } else {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Receive_Continue(
    IN CFsm_SocketReceive * Fsm
    )

/*++

Routine Description:

    Receives data from connected socket. Depending on flags settings, we will
    perform a single receive, loop until we have filled the buffer and/or loop
    until we have received all the data.

Arguments:

    Fsm - reference to FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Receive_Continue",
                 "{%#x [%#x/%d]} %#x(%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B])",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_lplpBuffer,
                 *Fsm->m_lplpBuffer,
                 Fsm->m_lpdwBufferLength,
                 *Fsm->m_lpdwBufferLength,
                 Fsm->m_lpdwBufferRemaining,
                 *Fsm->m_lpdwBufferRemaining,
                 Fsm->m_lpdwBytesReceived,
                 *Fsm->m_lpdwBytesReceived,
                 Fsm->m_dwExtraSpace,
                 Fsm->m_dwFlags,
                 Fsm->m_lpbEof,
                 *Fsm->m_lpbEof
                 ));

    CFsm_SocketReceive & fsm = *Fsm;
    DWORD error = fsm.GetError();
    INTERNET_HANDLE_OBJECT * pObject = fsm.GetMappedHandleObject();

    if (error != ERROR_SUCCESS) {
        goto error_exit;
    }

    fsm.m_lpBuffer = (LPBYTE)fsm.m_hBuffer + fsm.m_dwBytesReceived;

    //
    // receive some data
    //

    do 
    {
        if (fsm.m_pServerInfo != NULL) 
        {
            fsm.m_pServerInfo->SetLastActiveTime();
        }

        INET_ASSERT((int)fsm.m_dwBufferLeft > 0);

        int nRead;

        if (IsNonBlocking()) 
        {
            if (fsm.bIOCPInited)
            {
                fsm.bIOCPInited = FALSE;
                nRead = fsm.dwBytesTransferred;
                
                if (fsm.bIOCPSuccess)
                {
RecvSucceeded:
                    if (nRead == 0) 
                    {
                        //
                        // done
                        //
                        DEBUG_PRINT(SOCKETS,
                                    INFO,
                                    ("EOF connection %#x/port %d\n",
                                    m_Socket,
                                    m_SourcePort
                                    ));

                        fsm.m_bEof = TRUE;
                        break;
                    } 
                    else if (nRead > 0) 
                    {

                        DEBUG_PRINT(SOCKETS,
                                    INFO,
                                    ("received %d bytes from socket %#x/port %d\n",
                                    nRead,
                                    m_Socket,
                                    m_SourcePort
                                    ));

                        fsm.m_dwBytesReceived += nRead;
                        fsm.m_dwBytesRead += nRead;
                        fsm.m_lpBuffer += nRead;
                        fsm.m_dwBufferLeft -= nRead;

                        //
                        // if SF_RECEIVE_ALL is not set then the caller just wants us to
                        // perform a single receive. We're done
                        //

                        if (!(fsm.m_dwFlags & SF_RECEIVE_ALL) ) 
                        {
                            break;
                        }
                        //
                        // if we've filled the current buffer, then either we're done, or
                        // the caller wants us to receive the entire response, in which
                        // case we attempt to grow the buffer and receive the next part
                        // of the message. Note that we may have already received the
                        // entire response if it just happened to be the same size as our
                        // buffer
                        //

                        // BUGBUG [arthurbi] we're broken for SSL/PCT case !!!
                        //  We need to handle expanding the buffer.
                        //

                        if (fsm.m_dwBufferLeft == 0) 
                        {
                            //
                            // BUGBUG - RLF - why are we testing for SF_DECRYPT here?
                            //

                            if (!(fsm.m_dwFlags & SF_EXPAND) || (m_dwFlags & SF_DECRYPT)) 
                            {
                                break;
                            } 
                            else 
                            {
                                //
                                // BUGBUG - the buffer increment should come from the handle
                                //          object
                                //

                                fsm.m_dwBufferLeft = DEFAULT_RECEIVE_BUFFER_INCREMENT;
                                fsm.m_dwBufferLength += DEFAULT_RECEIVE_BUFFER_INCREMENT;

                                DEBUG_PRINT(SOCKETS,
                                            INFO,
                                            ("resizing %#x to %d\n",
                                            fsm.m_hBuffer,
                                            fsm.m_dwBufferLength
                                            ));

                                fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                                             fsm.m_dwBufferLength,
                                                             FALSE
                                                             );
                                if (fsm.m_hBuffer != NULL) 
                                {
                                    fsm.m_lpBuffer = (LPBYTE)fsm.m_hBuffer + fsm.m_dwBytesReceived;
                                }
                                else 
                                {
                                    error = GetLastError();
                                    INET_ASSERT(error != ERROR_SUCCESS);

                                    fsm.m_dwBytesReceived = 0;
                                    fsm.m_dwBufferLength = 0;
                                    fsm.m_dwBufferLeft = 0;
                                }
                            }
                        }// if fsm.m_dwBufferLeft == 0
                    }// if nRead >= 0
                }// if fsm.bIOCPSuccess
                else 
                {
                    error = fsm.dwIOCPError;
                    // a real error occurred. We need to get out
                    //

                    error = MapInternetError(error);

                    //VENKATKBUG_ remove this assert later - only informational
                    //informational INET_ASSERT (FALSE && "IOCPError");
                    break;
                }// if! fsm.bSuccess

                continue; //for any fall-thrus.
            } // if fsm.bIOCPInited
            
            int nError;
            WSABUF wsabuf;
            wsabuf.len = fsm.m_dwBufferLeft;
            wsabuf.buf = (char FAR *)fsm.m_lpBuffer;
            DWORD dwFlags = 0;

            //
            // First try Winsock Fast I/O: see if Winsock can
            // satisfy the recv call immediately. If it fails,
            // we assume the error is WSAWOULDBLOCK and then
            // try WSARecv again with the lpOverlapped parameter.
            //
            nError = _I_WSARecv(m_Socket,
                                &wsabuf,
                                1,
                                (LPDWORD)&nRead,
                                &dwFlags,
                                NULL,
                                NULL);  
            if (nError == 0)
            {
                goto RecvSucceeded;
            }

            //
            // Slow path: issue an async recv call, with the results
            // to be posted to our I/O completion port.
            //
            if (!_lpWrapOverlappedRecv)
            {
                _lpWrapOverlappedRecv = New CWrapOverlapped();

                if (!_lpWrapOverlappedRecv)
                {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                    fsm.SetErrorState(error);
                    goto error_exit;
                }
            }
            
            CWrapOverlapped* lpWrapOverlapped = _lpWrapOverlappedRecv;
            LPWSAOVERLAPPED lpOverlapped = _lpWrapOverlappedRecv->GetOverlapped();
            memset(lpOverlapped, 0, sizeof(WSAOVERLAPPED));

            CFsm* pFsmOld = GetAndSetCurrentFsm(&fsm);
            UNREFERENCED_PARAMETER(pFsmOld); // eliminate C4701 in free builds 
            INET_ASSERT (pFsmOld == NULL);
            
            fsm.bIOCPInited = TRUE;

            fsm.SetAction(FSM_ACTION_RECEIVE);

            DWORD timeout = GetTimeoutValue(WINHTTP_OPTION_RECEIVE_TIMEOUT);

            if (timeout != INFINITE)
            {
                fsm.SetTimeout(timeout);

#ifdef USE_OLD_SENDRECV_SYNC

                fsm.SetOnAsyncList(TRUE);
#else
                //additional reference for timeout queue
                fsm.Reference();
                fsm.SetPop(FALSE);
#endif

                if (Fsm->GetMappedHandleObject())
                {
                    Fsm->GetMappedHandleObject()->Reference();
                }

                error = QueueTimeoutFsm(Fsm, m_Socket);

                if (error != ERROR_IO_PENDING)
                {
                    // 2 causes - both irrecoverable
                    // 1. no global pointer to ICAsyncThread (impossible)
                    // OR 2. no threadinfo or SelectThread or out of memory.
                    // so bail!
                    fsm.bIOCPInited = FALSE;
                    GetAndSetCurrentFsm(NULL);

#ifdef USE_OLD_SENDRECV_SYNC

                    fsm.SetOnAsyncList(FALSE);
#else
                    if (Fsm->GetMappedHandleObject())
                    {
                        Fsm->GetMappedHandleObject()->Dereference();
                    }

                    DWORD dwDummy = 0;
                    fsm.Dereference(&dwDummy);
#endif

                    fsm.SetErrorState(error);
                    goto error_exit;
                }
            }

            _lpWrapOverlappedRecv->Reference(); // to keep this ICSocket=>the Overlapped struct valid beyong the WSARecv() call.
            _lpWrapOverlappedRecv->Reference(); // to make sure it stays alive for the IOCP to get the fsm off it.
            
            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("calling WSARecv() blocked, socket %#x/port %d\n",
                        m_Socket,
                        m_SourcePort
                        ));

            DEBUG_ENTER((DBG_API,
                             Dword,
                             "***WSARecv",
                             "(m_Socket)%#x, (wsabuf.buf)%#x, (wsabuf.len)%#x, (this)%#x, (overlapped)%#x, (fsm)%#x",
                             m_Socket,
                             wsabuf.buf,
                             wsabuf.len,
                             this,
                             lpOverlapped,
                             &fsm
                             ));

            nError = _I_WSARecv(m_Socket,
                                &wsabuf,
                                1,
                                (LPDWORD)&nRead,
                                &dwFlags,
                                lpOverlapped,
                                NULL);     
        
            DEBUG_LEAVE(nError);

            lpWrapOverlapped->Dereference(); // release the first reference.
            
            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("WSARecv() returns %d (%s) with nRead=%d bytes\n",
                        nError,
                        InternetMapError(nError),
                        nRead
                        ));

            //VENKATKBUG - omitting Win95 hackorama (see below sync case.), but may need to put it in just the same.

            if (nError == 0)
            {
#if INET_DEBUG
                InterlockedIncrement(&g_cWSACompletions);
#endif
                 error = ERROR_IO_PENDING;
                 break;
            }
            else // if! nError == 0
            {
                INET_ASSERT (nError == SOCKET_ERROR);
                
                error = _I_WSAGetLastError();
                if (error == WSA_IO_PENDING)
                {
#if INET_DEBUG
                    InterlockedIncrement(&g_cWSACompletions);
#endif
                    error = ERROR_IO_PENDING;
                    break;
                }
                else
                {
                    // no IOCompletion here.
                    if (fsm.HasTimeout())
                    {

#ifdef USE_OLD_SENDRECV_SYNC

                        if (!RemoveFsmFromAsyncList(&fsm))
                        {
                            //the timeout thread already enforced timeout and updated state
                        }
#else
                        if (!fsm.TestAndSetValidForIOCPProcessing())
                        {
                            //the timeout thread already enforced timeout and updated state
                        }
#endif

                    }

                    lpWrapOverlapped->Dereference(); // release the IOCP-based reference.
                    GetAndSetCurrentFsm(NULL);
                    
                    //cannot handle SF_NO_WAIT and SF_WAIT
                    error = MapInternetError(error);

                    break;
                }
            } // if! nError == 0
        }
        else //if IsNonBlocking()
        {
            nRead = _I_recv(m_Socket,
                            (char FAR *)fsm.m_lpBuffer,
                            (int)fsm.m_dwBufferLeft,
                            0
                            );
                            
            //
            // hackorama # 95, subparagraph 13
            //
            // RLF 07/15/96
            //
            // On Win95 (wouldn't you know it?) in low-memory conditions, we can get
            // into a situation where one or more pages of our receive buffer is
            // filled with zeroes.
            //
            // The reason this happens is that the winsock VxD creates an alias to
            // our buffer, locks the buffer & writes into it, then marks the alias
            // dirty, but not the original buffer. If the buffer is paged out then
            // back in, one or more pages are zeroed because the O/S didn't know
            // they had been written to; it decides to initialize the pages with
            // zeroes.
            //
            // We try to circumvent this by immediately probing each page (we read
            // a byte then write it back).
            //
            // This doesn't fix the problem, just makes the window a lot smaller.
            // However, apart from writing a device driver or modifying the VxD,
            // there's not much else we can do
            //

            ProbeWriteBuffer(fsm.m_lpBuffer, fsm.m_dwBufferLeft);

            if (nRead == 0) 
            {
                //
                // done
                //

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("EOF connection %#x/port %d\n",
                            m_Socket,
                            m_SourcePort
                            ));

                fsm.m_bEof = TRUE;
                break;
            } 
            else if (nRead > 0) 
            {
                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("received %d bytes from socket %#x/port %d\n",
                            nRead,
                            m_Socket,
                            m_SourcePort
                            ));

                fsm.m_dwBytesReceived += nRead;
                fsm.m_dwBytesRead += nRead;
                fsm.m_lpBuffer += nRead;
                fsm.m_dwBufferLeft -= nRead;

                //
                // if SF_RECEIVE_ALL is not set then the caller just wants us to
                // perform a single receive. We're done
                //

                if (!(fsm.m_dwFlags & SF_RECEIVE_ALL) ) 
                {
                    break;
                }

                //
                // if we've filled the current buffer, then either we're done, or
                // the caller wants us to receive the entire response, in which
                // case we attempt to grow the buffer and receive the next part
                // of the message. Note that we may have already received the
                // entire response if it just happened to be the same size as our
                // buffer
                //

                // BUGBUG [arthurbi] we're broken for SSL/PCT case !!!
                //  We need to handle expanding the buffer.
                //

                if (fsm.m_dwBufferLeft == 0) 
                {
                    //
                    // BUGBUG - RLF - why are we testing for SF_DECRYPT here?
                    //

                    if (!(fsm.m_dwFlags & SF_EXPAND) || (m_dwFlags & SF_DECRYPT)) 
                    {
                        break;
                    } 
                    else 
                    {
                        //
                        // BUGBUG - the buffer increment should come from the handle
                        //          object
                        //

                        fsm.m_dwBufferLeft = DEFAULT_RECEIVE_BUFFER_INCREMENT;
                        fsm.m_dwBufferLength += DEFAULT_RECEIVE_BUFFER_INCREMENT;

                        DEBUG_PRINT(SOCKETS,
                                    INFO,
                                    ("resizing %#x to %d\n",
                                    fsm.m_hBuffer,
                                    fsm.m_dwBufferLength
                                    ));

                        fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                                     fsm.m_dwBufferLength,
                                                     FALSE
                                                     );
                        if (fsm.m_hBuffer != NULL) 
                        {
                            fsm.m_lpBuffer = (LPBYTE)fsm.m_hBuffer + fsm.m_dwBytesReceived;
                        } 
                        else 
                        {
                            error = GetLastError();

                            INET_ASSERT(error != ERROR_SUCCESS);

                            fsm.m_dwBytesReceived = 0;
                            fsm.m_dwBufferLength = 0;
                            fsm.m_dwBufferLeft = 0;
                        }
                    }
                }//if fsm.m_dwBufferLeft == 0
            } 
            else //if nRead >= 0
            {
                if (IsAborted()) 
                {
                    error = ERROR_WINHTTP_OPERATION_CANCELLED;
                    break;
                } 
                else 
                {
                    error = _I_WSAGetLastError();
                    //
                    // a real error occurred. We need to get out
                    //

                    DEBUG_PRINT(SOCKETS,
                                ERROR,
                                ("recv() on socket %#x/port %d returns %d\n",
                                m_Socket,
                                m_SourcePort,
                                error
                                ));

                    error = MapInternetError(error);
                    break;
                }
            }//if! nRead >= 0
        }// if! IsNonBlocking()
    } 
    while (error == ERROR_SUCCESS);

error_exit:

    //
    // get correct error based on settings
    //

    if (error == ERROR_IO_PENDING) 
    {
        goto done;
    } 
    else if (IsAborted()) 
    {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
    }

    if (pObject != NULL) {
        pObject->ResetAbortHandle();
    }

    if (error == ERROR_SUCCESS) {

        //
        // inform the app that we finished, and tell it how much we received
        // this time
        //

        if (fsm.m_dwFlags & SF_INDICATE) {
            DWORD dwBytesRead = fsm.m_dwBytesRead;
            InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED,
                                   &dwBytesRead,
                                   sizeof(dwBytesRead)
                                   );
        }

        //
        // if we received the entire response and the caller specified
        // SF_COMPRESS then we shrink the buffer to fit. We may end up growing
        // the buffer to contain dwExtraSpace if it is not zero and we just
        // happened to fill the current buffer
        //

        if (fsm.m_bEof && (fsm.m_dwFlags & SF_COMPRESS)) {

            fsm.m_dwBufferLeft = fsm.m_dwExtraSpace;

            //
            // include any extra that the caller required
            //

            fsm.m_dwBufferLength = fsm.m_dwBytesReceived + fsm.m_dwExtraSpace;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("shrinking buffer %#x to %d (%#x) bytes (includes %d extra)\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength,
                        fsm.m_dwBufferLength,
                        fsm.m_dwExtraSpace
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                         fsm.m_dwBufferLength,
                                         FALSE
                                         );

            INET_ASSERT((fsm.m_hBuffer == NULL)
                        ? ((fsm.m_dwBytesReceived + fsm.m_dwExtraSpace) == 0)
                        : TRUE
                        );

        }

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("read %d bytes @ %#x from socket %#x/port %d\n",
                    fsm.m_dwBytesRead,
                    (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                    m_Socket,
                    m_SourcePort
                    ));

        DEBUG_DUMP_API(SOCKETS,
                       "received data:\n",
                       (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                       fsm.m_dwBytesRead
                       );
        TRACE_DUMP_API_IF_REQUEST(SOCKETS,
                       "received data:\n",
                       (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                       fsm.m_dwBytesRead,
                        (HANDLE_OBJECT *)(fsm.GetMappedHandle())
                       );

    } else if (fsm.m_bAllocated && (fsm.m_hBuffer != NULL)) {

        //
        // if we failed but allocated a buffer then we need to free it (we were
        // leaking this buffer if the request was cancelled)
        //

        fsm.m_hBuffer = FREE_MEMORY(fsm.m_hBuffer);

        INET_ASSERT(fsm.m_hBuffer == NULL);

        fsm.m_dwBufferLength = 0;
        fsm.m_dwBufferLeft = 0;
        fsm.m_dwBytesReceived = 0;
        fsm.m_bEof = TRUE;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("returning: lpBuffer=%#x, bufferLength=%d, bufferLeft=%d, bytesReceived=%d\n",
                fsm.m_hBuffer,
                fsm.m_dwBufferLength,
                fsm.m_dwBufferLeft,
                fsm.m_dwBytesReceived
                ));

    //
    // update output parameters
    //

    *fsm.m_lplpBuffer = (LPVOID)fsm.m_hBuffer;
    *fsm.m_lpdwBufferLength = fsm.m_dwBufferLength;
    *fsm.m_lpdwBufferRemaining = fsm.m_dwBufferLeft;
    *fsm.m_lpdwBytesReceived = fsm.m_dwBytesReceived;
    *fsm.m_lpbEof = fsm.m_bEof;

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone(error);
    }

done:

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//ICSocket::ReceiveFrom(
//    IN LPVOID lpBuffer,
//    IN DWORD dwBufferLength,
//    OUT LPDWORD lpdwBytesReceived,
//    OUT LPSOCKADDR lpDestination OPTIONAL,
//    IN OUT LPDWORD lpdwDestinationLength OPTIONAL,
//    IN DWORD dwTimeout,
//    IN DWORD dwWinsockFlags,
//    IN DWORD dwFlags
//    )
//
///*++
//
//Routine Description:
//
//    Wrapper for recvfrom()
//
//Arguments:
//
//    lpBuffer                - pointer to buffer where data returned
//
//    dwBufferLength          - size of lpBuffer in bytes
//
//    lpdwBytesReceived       - pointer to returned number of bytes received
//
//    lpDestination           - pointer to returned destination address
//
//    lpdwDestinationLength   - IN: size of lpDestination buffer
//                              OUT: length of returned destination address info
//
//    dwTimeout               - number of milliseconds to wait for response
//
//    dwWinsockFlags          - flags to pass through to recvfrom()
//
//    dwFlags                 - ICSocket flags
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
//                    The operation was cancelled by the caller
//
//                  ERROR_WINHTTP_TIMEOUT
//                    The operation timed out
//
//                  ERROR_WINHTTP_CONNECTION_ERROR
//                    An error occurred. We approximate to connection reset
//
//                  WSA error
//                    Some other sockets error occurred
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::ReceiveFrom",
//                 "{%#x} %#x, %d, %#x, %#x, %#x [%d], %d, %#x, %#x",
//                 m_Socket,
//                 lpBuffer,
//                 dwBufferLength,
//                 lpdwBytesReceived,
//                 lpDestination,
//                 lpdwDestinationLength,
//                 lpdwDestinationLength ? *lpdwDestinationLength : 0,
//                 dwTimeout,
//                 dwWinsockFlags,
//                 dwFlags
//                 ));
//
//    //INET_ASSERT(IsSocketValid());
//    INET_ASSERT(lpdwBytesReceived != NULL);
//
//    //
//    // most ICSocket flags not allowed for this operation
//    //
//
//    INET_ASSERT(!(dwFlags
//                  & (SF_ENCRYPT
//                     | SF_DECRYPT
//                     | SF_EXPAND
//                     | SF_COMPRESS
//                     | SF_SENDING_DATA
//                     | SF_SCH_REDO
//                     )
//                  )
//                );
//
//    DWORD error = ERROR_SUCCESS;
//    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
//    BOOL bStopOfflineTimer = FALSE;
//    BOOL fNonBlocking;
//    DWORD bytesReceived;
//    INTERNET_HANDLE_OBJECT * pObject = NULL;
//
//    if (lpThreadInfo == NULL) {
//
//        INET_ASSERT(FALSE);
//
//        error = ERROR_WINHTTP_INTERNAL_ERROR;
//        goto quit;
//    }
//
//    //
//    // the socket may have already been aborted
//    //
//
//    if (IsAborted()) {
//        error = ERROR_WINHTTP_OPERATION_CANCELLED;
//        goto quit;
//    }
//
//    //
//    // let another thread know the socket to cancel if it wants to kill this
//    // operation
//    //
//
//    pObject = (INTERNET_HANDLE_OBJECT * )lpThreadInfo->hObjectMapped;
//    if (pObject != NULL) {
//        pObject->SetAbortHandle(this);
//    }
//
//    //
//    // keep the app informed (if requested to do so)
//    //
//
//    if (dwFlags & SF_INDICATE) {
//        InternetIndicateStatus(INTERNET_STATUS_RECEIVING_RESPONSE,
//                               NULL,
//                               0
//                               );
//    }
//
//    //
//    // if we are in async (== non-blocking) mode, let the async request
//    // scheduler know what operation we will be waiting on
//    //
//
//    fNonBlocking = lpThreadInfo->IsAsyncWorkerThread;
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION_TIMEOUT(lpThreadInfo->lpArb,
//                                         m_Socket,
//                                         RECEIVE,
//                                         dwTimeout
//                                         );
//
//        DWORD timerError = StartOfflineTimerForArb(lpThreadInfo->lpArb);
//
//        INET_ASSERT(timerError == ERROR_SUCCESS);
//
//        bStopOfflineTimer = (timerError == ERROR_SUCCESS) ? TRUE : FALSE;
//    }
//
//    int nBytes;
//
//    bytesReceived = 0;
//
//    do {
//
//        nBytes = _I_recvfrom(m_Socket,
//                             (char FAR *)lpBuffer + bytesReceived,
//                             dwBufferLength,
//                             dwWinsockFlags,
//                             lpDestination,
//                             (int FAR *)lpdwDestinationLength
//                             );
//        if (nBytes != SOCKET_ERROR) {
//
//            DEBUG_PRINT(SOCKETS,
//                        INFO,
//                        ("received %d bytes from socket %#x\n",
//                        nBytes,
//                        m_Socket
//                        ));
//
//            INET_ASSERT(nBytes > 0);
//
//            bytesReceived += nBytes;
//            dwBufferLength -= nBytes;
//
//            //
//            // for recvfrom(), we quit as soon as we get some data
//            //
//
//            error = ERROR_SUCCESS;
//            break;
//        } else {
//            error = _I_WSAGetLastError();
//            if ((error == WSAEWOULDBLOCK) && fNonBlocking) {
//
//                INET_ASSERT(_dwFlags & SF_NON_BLOCKING);
//
//                //
//                // if this function is called expedited (we expect the request
//                // to complete quickly) then we test to see if it already
//                // completed before switching to the async scheduler
//                //
//
//                BOOL switchFiber = TRUE;
//
//                if (dwFlags & SF_EXPEDITED) {
//                    error = WaitForReceive(1);
//
//                    //
//                    // if the socket is already readable then we don't switch
//                    // fibers (only to virtually immediately come back here,
//                    // incurring a couple of thread switches
//                    //
//
//                    if (error == ERROR_SUCCESS) {
//                        switchFiber = FALSE;
//
//                        //
//                        // use this error to go round loop once again
//                        //
//
//                        error = WSAEWOULDBLOCK;
//                    }
//                }
//                if (switchFiber) {
//
//                    DEBUG_PRINT(SOCKETS,
//                                INFO,
//                                ("recvfrom(%#x) blocked\n",
//                                m_Socket
//                                ));
//
//                    lpThreadInfo->lpArb->Header.dwResultCode = ERROR_SUCCESS;
//
//                    SwitchToAsyncScheduler(m_Socket);
//
//                    error = lpThreadInfo->lpArb->Header.dwResultCode;
//
//                    DEBUG_PRINT(SOCKETS,
//                                INFO,
//                                ("recvfrom(%#x) resumed, returns %s\n",
//                                m_Socket,
//                                InternetMapError(error)
//                                ));
//
//                    if (error != ERROR_SUCCESS) {
//                    } else {
//
//                        //
//                        // use this error to force another loop now we believe
//                        // we have the data
//                        //
//
//                        error = WSAEWOULDBLOCK;
//                    }
//                }
//            } else {
//
//                //
//                // real error
//                //
//
//                error = MapInternetError(error);
//            }
//        }
//    } while (error == WSAEWOULDBLOCK);
//
//    if (error == ERROR_SUCCESS) {
//
//        DEBUG_DUMP(SOCKETS,
//                   "received data:\n",
//                   lpBuffer,
//                   bytesReceived
//                   );
//
//    }
//
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION(lpThreadInfo->lpArb, INVALID_SOCKET, RECEIVE);
//
//        if (bStopOfflineTimer) {
//            StopOfflineTimerForArb(lpThreadInfo->lpArb);
//        }
//    }
//
//    //
//    // inform the app that we finished, and tell it how much we received this
//    // time
//    //
//
//    if ((dwFlags & SF_INDICATE) && (error == ERROR_SUCCESS)) {
//        InternetIndicateStatus(INTERNET_STATUS_RESPONSE_RECEIVED,
//                               &bytesReceived,
//                               sizeof(bytesReceived)
//                               );
//    }
//
//    *lpdwBytesReceived = bytesReceived;
//
//    if (pObject != NULL) {
//        pObject->ResetAbortHandle();
//
//        //
//        // if the operation has been cancelled, then this error overrides any
//        // other
//        //
//
//        //if (pObject->IsInvalidated()) {
//        //    error = pObject->GetError();
//        //    if (error == ERROR_SUCCESS) {
//        //        error = ERROR_WINHTTP_OPERATION_CANCELLED;
//        //    }
//        //}
//        if (IsAborted()) {
//            error = ERROR_WINHTTP_OPERATION_CANCELLED;
//        }
//    }
//
//quit:
//
//    INET_ASSERT((pObject != NULL) ? (pObject->GetAbortHandle() == NULL) : TRUE);
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//

DWORD
ICSocket::DataAvailable(
    OUT LPDWORD lpdwBytesAvailable
    )

/*++

Routine Description:

    Determines the amount of data available to be read on the socket

Arguments:

    lpdwBytesAvailable  - pointer to returned data available


Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::DataAvailable",
                 "%#x",
                 lpdwBytesAvailable
                 ));

    //
    // sanity check parameters
    //

    INET_ASSERT(m_Socket != INVALID_SOCKET);
    INET_ASSERT(lpdwBytesAvailable != NULL);

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;

    if (lpThreadInfo == NULL) {

        //informational INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //
    // the socket may already be aborted
    //

    if (IsAborted()) {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
        goto quit;
    }

    //
    // if we're in async mode, we have to perform a zero-length receive in order
    // to get the information from the socket
    //

    int nRead;

    //
    // we actually have to peek a non-zero number of bytes because on Win95,
    // attempting to perform a receive of 0 bytes (to put the socket in blocked
    // read mode) results in zero bytes being returned, and the socket never
    // blocks
    //

    nRead = _I_recv(m_Socket, NULL, 0, 0);

    //
    // N.B. buf[] will only ever be used if there is data to peek right now
    //

    char buf[1];

    PERF_LOG(PE_PEEK_RECEIVE_START,
             m_Socket,
             lpThreadInfo->ThreadId,
             lpThreadInfo->hObject
             );

    nRead = _I_recv(m_Socket, buf, sizeof(buf), MSG_PEEK);
    if (nRead == SOCKET_ERROR) {
        error = _I_WSAGetLastError();
        if ((error == WSAEWOULDBLOCK) && (m_dwFlags & SF_NON_BLOCKING)) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("peek(1) blocked, socket %#x\n",
                        m_Socket
                        ));

            PERF_LOG(PE_PEEK_RECEIVE_END,
                     m_Socket,
                     lpThreadInfo->ThreadId,
                     lpThreadInfo->hObject
                     );

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("peek(1) resumed, socket %#x, returns %s\n",
                        m_Socket,
                        InternetMapError(error)
                        ));
        }
    /*} else if ((nRead == 0) && !(m_dwFlags & SF_NON_BLOCKING)) {

        PERF_LOG(PE_PEEK_RECEIVE_END,
                 m_Socket,
                 lpThreadInfo->ThreadId,
                 lpThreadInfo->hObject
                 );

        //
        // nothing to peek right now. If the socket is in blocking mode then
        // we wait here until there is something to receive
        //

        error = WaitForReceive(INFINITE);*/
    } else {

        PERF_LOG(PE_PEEK_RECEIVE_END,
                 m_Socket,
                 lpThreadInfo->ThreadId,
                 lpThreadInfo->hObject
                 );

        //
        // nRead == 0 but non-blocking, or nRead > 0
        //

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("peek(1) returns %d\n",
                    nRead
                    ));

        error = ERROR_SUCCESS;
    }

    if (error == ERROR_SUCCESS) {

        //
        // now we can get the amount from the socket
        //

        error = (DWORD)_I_ioctlsocket(m_Socket,
                                      FIONREAD,
                                      (u_long FAR *)lpdwBytesAvailable
                                      );

        //
        // N.B. assumes ioctlsocket() returns 0 on success == ERROR_SUCCESS
        //

        if (error == SOCKET_ERROR) {
            error = _I_WSAGetLastError();
        } else {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("ioctlsocket(FIONREAD) returns %d\n",
                        *lpdwBytesAvailable
                        ));

        }
    }

    //
    // map any sockets error to WinHttp error
    //

    if (error != ERROR_SUCCESS) {
        error = MapInternetError(error);
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//ICSocket::DataAvailable2(
//    OUT LPVOID lpBuffer,
//    IN DWORD dwBufferLength,
//    OUT LPDWORD lpdwBytesAvailable
//    )
//
///*++
//
//Routine Description:
//
//    Determines the amount of data available to be read on the socket
//
//Arguments:
//
//    lplpBuffer          - pointer to pointer to buffer where data read
//
//    dwBufferLength      - size of the buffer
//
//    lpdwBytesAvailable  - pointer to returned data available
//
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - WSA error
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::DataAvailable2",
//                 "%#x, %d, %#x",
//                 lpBuffer,
//                 dwBufferLength,
//                 lpdwBytesAvailable
//                 ));
//
//    //
//    // sanity check parameters
//    //
//
//    INET_ASSERT(lpdwBytesAvailable != NULL);
//
//    //
//    // we're about to receive data from the socket. The amount of data currently
//    // on hand must be 0
//    //
//
//    INET_ASSERT(*lpdwBytesAvailable == 0);
//    INET_ASSERT(lpBuffer != NULL);
//
//    DWORD error;
//
//    //
//    // new scheme: actually read the data from sockets into our buffer. This is
//    // the only way on Win95 to determine the correct number of bytes available.
//    // We only perform a single receive
//    //
//
//    DWORD bufferLeft = dwBufferLength;
//    BOOL eof;
//
//    error = Receive(&lpBuffer,
//                    &dwBufferLength,
//                    &bufferLeft,  // don't care about this
//                    lpdwBytesAvailable,
//                    0,
//                    0,
//                    &eof          // don't care about this either
//                    );
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}


DWORD
ICSocket::WaitForReceive(
    IN DWORD Timeout
    )

/*++

Routine Description:

    Waits until a receive socket becomes unblocked (readable)

Arguments:

    Timeout - milliseconds to wait, or INFINITE

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error
                    sockets error

                  ERROR_WINHTTP_TIMEOUT
                    Receive timed out

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::WaitForReceive",
                 "{%#x} %d",
                 m_Socket,
                 Timeout
                 ));

    struct fd_set read_fds;
    struct fd_set except_fds;

    FD_ZERO(&read_fds);
    FD_ZERO(&except_fds);

    FD_SET(m_Socket, &read_fds);
    FD_SET(m_Socket, &except_fds);

    int n;

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("waiting on socket %#x\n",
                m_Socket
                ));

    TIMEVAL timeout;
    LPTIMEVAL lpTimeout;

    if (Timeout != INFINITE) {
        timeout.tv_sec  = Timeout / 1000;
        timeout.tv_usec = (Timeout % 1000) * 1000;
        lpTimeout = &timeout;
    } else {
        lpTimeout = NULL;
    }

    n = _I_select(0, &read_fds, NULL, &except_fds, lpTimeout);

    DWORD error;

    if (n == SOCKET_ERROR) {

        //
        // real error?
        //

        error = _I_WSAGetLastError();

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("select() returns %d\n",
                    error
                    ));

        //informational INET_ASSERT(FALSE);

        error = MapInternetError(error);
    } else if (n != 0) {
        if (FD_ISSET(m_Socket, &except_fds)) {

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("socket %#x exception\n",
                        m_Socket
                        ));

            error = ERROR_WINHTTP_CONNECTION_ERROR;
        } else {

            //
            // it *must* be unblocked (i.e. readable)
            //

            INET_ASSERT(FD_ISSET(m_Socket, &read_fds));

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("socket %#x unblocked\n",
                        m_Socket
                        ));

            error = ERROR_SUCCESS;
        }
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("timed out\n"
                    ));

        error = ERROR_WINHTTP_TIMEOUT;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::AllocateQueryBuffer(
    OUT LPVOID * lplpBuffer,
    OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Allocates a query buffer for the socket

Arguments:

    lplpBuffer          - returned pointer to allocated query buffer

    lpdwBufferLength    - returned length of allocated query buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::AllocateQueryBuffer",
                 "{%#x/%d} %#x, %#x",
                 GetSocket(),
                 GetSourcePort(),
                 lplpBuffer,
                 lpdwBufferLength
                 ));

    DWORD error;
    DWORD bufferLength;
    DWORD size = sizeof(bufferLength);

    int serr = _I_getsockopt(m_Socket,
                             SOL_SOCKET,
                             SO_RCVBUF,
                             (char FAR *)&bufferLength,
                             (int FAR *)&size
                             );
    if (serr != SOCKET_ERROR) {
        bufferLength = min(bufferLength, DEFAULT_SOCKET_QUERY_BUFFER_LENGTH);
        if (bufferLength == 0) {
            bufferLength = DEFAULT_SOCKET_QUERY_BUFFER_LENGTH;
        }
        *lplpBuffer = (LPVOID)ALLOCATE_MEMORY(bufferLength);
        if (*lplpBuffer != NULL) {
            *lpdwBufferLength = bufferLength;
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        error = MapInternetError(_I_WSAGetLastError());
    }

    DEBUG_LEAVE(error);

    return error;
}

//
//VOID
//ICSocket::FreeQueryBuffer(
//    IN LPVOID lpBuffer
//    )
//
///*++
//
//Routine Description:
//
//    description-of-function.
//
//Arguments:
//
//    lpBuffer    -
//
//Return Value:
//
//    None.
//
//--*/
//
//{
//    lpBuffer = (LPVOID)FREE_MEMORY((HLOCAL)lpBuffer);
//
//    INET_ASSERT(lpBuffer == NULL);
//}

//
//DWORD
//ICSocket::GetBytesAvailable(
//    OUT LPDWORD lpdwBytesAvailable
//    )
//
///*++
//
//Routine Description:
//
//    Determines amount of data available to be read from socket
//
//Arguments:
//
//    lpdwBytesAvailable  - pointer to returned available length
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::GetBytesAvailable",
//                 "{%#x} %#x",
//                 m_Socket,
//                 lpdwBytesAvailable
//                 ));
//
//    //INET_ASSERT(m_Socket != INVALID_SOCKET);
//    INET_ASSERT(lpdwBytesAvailable != NULL);
//
//    //
//    // get the amount from the socket. If the socket has been reset or shutdown
//    // by the server then we expect to get an error, else 0 (== ERROR_SUCCESS)
//    //
//
//    DWORD error = (DWORD)_I_ioctlsocket(m_Socket,
//                                        FIONREAD,
//                                        (u_long FAR *)lpdwBytesAvailable
//                                        );
//    if (error == SOCKET_ERROR) {
//        error = _I_WSAGetLastError();
//    } else {
//
//        DEBUG_PRINT(SOCKETS,
//                    INFO,
//                    ("ioctlsocket(FIONREAD) returns %d\n",
//                    *lpdwBytesAvailable
//                    ));
//
//    }
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//
#if 0
//not used- remove!

DWORD
ICSocket::CreateSocket(
    IN DWORD dwFlags,
    IN int nAddressFamily,
    IN int nType,
    IN int nProtocol
    )

/*++

Routine Description:

    Opens a socket handle for this ICSocket object

Arguments:

    dwFlags         - flags to use for new socket

    nAddressFamily  - parameter to socket()

    nType           - parameter to socket()

    nProtocol       - parameter to socket()

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::CreateSocket",
                 "%#x, %s (%d), %s (%d), %s (%d)",
                 dwFlags,
                 MapFamily(nAddressFamily),
                 nAddressFamily,
                 MapSock(nType),
                 nType,
                 MapProto(nProtocol),
                 nProtocol
                 ));

    INET_ASSERT(m_Socket == INVALID_SOCKET);

    int serr;
    DWORD error;
    DWORD dwConnFlags;

    m_Socket = _I_socket(nAddressFamily, nType, nProtocol);
    if (m_Socket == INVALID_SOCKET) {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to create socket\n"
                    ));

        goto socket_error;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("created socket %#x\n",
                m_Socket
                ));

    if (dwFlags & SF_NON_BLOCKING) {
        INET_ASSERT(FALSE);

        error = SetNonBlockingMode(TRUE);
        if (error == ERROR_SUCCESS) {

            //
            //  ICSocket is non-blocking socket object
            //

            m_dwFlags |= SF_NON_BLOCKING;
        } else {
            goto close_socket;
        }
    }

    //
    // bind our data socket to an endpoint, so that we know an address to
    // tell the FTP server
    //

    struct sockaddr_storage ourDataAddr;

    ourDataAddr.ss_family = (short)nAddressFamily;

    if (nAddressFamily == AF_INET6) {
        struct in_addr6 in6addr_any = IN6ADDR_ANY_INIT;

        ((LPSOCKADDR_IN6)&ourDataAddr)->sin6_port = 0;
        ((LPSOCKADDR_IN6)&ourDataAddr)->sin6_flowinfo = 0;
        ((LPSOCKADDR_IN6)&ourDataAddr)->sin6_addr = in6addr_any;
        ((LPSOCKADDR_IN6)&ourDataAddr)->sin6_scope_id = 0;
    } else {
        ((LPSOCKADDR_IN)&ourDataAddr)->sin_port = 0;
        ((LPSOCKADDR_IN)&ourDataAddr)->sin_addr.s_addr = INADDR_ANY;
    }

    serr = _I_bind(m_Socket,
                   (PSOCKADDR)&ourDataAddr,
                   sizeof(ourDataAddr)
                   );

    if (serr == SOCKET_ERROR) {
        goto socket_error;
    }

    error = ERROR_SUCCESS;

quit:

    DEBUG_LEAVE(error);

    return error;

socket_error:

    error = MapInternetError(_I_WSAGetLastError());

close_socket:

    Close();
    m_dwFlags &= ~SF_NON_BLOCKING;
    goto quit;
}
#endif

DWORD
ICSocket::GetSockName(
    IN PSOCKADDR psaSockName,
    IN int SockNameSize
    )
/*++

Routine Description:

    Returns the socket address for this socket.

Arguments:

    psaSocketName    - pointer to sockaddr buffer to fill in.

    SockNameSize - size of sockaddr buffer;

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/
{
    INET_ASSERT(m_Socket != INVALID_SOCKET);
    INET_ASSERT(psaSockName);
    INET_ASSERT(SockNameSize >= sizeof(SOCKADDR));

    int serr;
    DWORD error;

    serr = ERROR_SUCCESS;
    error = ERROR_SUCCESS;

    //
    // get the address info .
    //

    serr = _I_getsockname(m_Socket,
                          psaSockName,
                          &SockNameSize
                          );


    if ( serr == SOCKET_ERROR )
    {
        error = _I_WSAGetLastError();
    }

    return error;
}


DWORD
ICSocket::Listen(
    VOID
    )
{
    INET_ASSERT(m_Socket != INVALID_SOCKET);

    DWORD error = ERROR_SUCCESS;

    //
    // Listen on the socket.
    //

    if (_I_listen(m_Socket, 1) == SOCKET_ERROR) {
        error = _I_WSAGetLastError();
    }
    return error;
}


DWORD
ICSocket::DirectConnect(
    PSOCKADDR psaRemoteSock
    )

/*++

Routine Description:

    Connects a ICSocket to the remote address

Arguments:

    psaRemoteSock   - pointer to remote socket address (TCP/IP!)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::DirectConnectSocket",
                 "{%#x} %#x",
                 m_Socket,
                 psaRemoteSock
                 ));

    INET_ASSERT(m_Socket != INVALID_SOCKET);

    DWORD error;
    INTERNET_HANDLE_OBJECT * pObject = NULL;
    
    //
    // we need the thread info for async processing
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        //informational INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    BOOL isAsync;

    isAsync = lpThreadInfo->IsAsyncWorkerThread;

    //
    // BUGBUG - this is essentially common to ConnectSocket()
    //

    //
    // let another thread know the socket to cancel if it wants to kill
    // this operation
    //

    pObject = (INTERNET_HANDLE_OBJECT * )lpThreadInfo->hObjectMapped;
    if (pObject != NULL) {
        pObject->SetAbortHandle(this);
    }

#if defined(UNIX) && defined(ux10)
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connecting to remote address %d.%d.%d.%d, port %d\n",
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[0],
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[1],
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[2],
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[3],
                _I_ntohs(((LPSOCKADDR_IN)psaRemoteSock)->sin_port)
                ));
#else
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connecting to remote address %A, port %d\n",
                psaRemoteSock,
                _I_ntohs(((LPSOCKADDR_IN)psaRemoteSock)->sin_port)
                ));
#endif

    DWORD connectTime;

    connectTime = GetTickCountWrap();

    int serr;

    PERF_LOG(PE_CONNECT_START,
             m_Socket,
             lpThreadInfo->ThreadId,
             lpThreadInfo->hObject
             );

    if (IsSocks()) {
        // BUGBUG: We only support IPv4 Socks.
        serr = SocksConnect((LPSOCKADDR_IN)psaRemoteSock, sizeof(SOCKADDR_IN));
    } else {
        int RemoteSockSize;

        if (psaRemoteSock->sa_family == AF_INET6) {
            RemoteSockSize = sizeof(SOCKADDR_IN6);
        } else {
            RemoteSockSize = sizeof(SOCKADDR_IN);
        }
        serr = _I_connect(m_Socket, psaRemoteSock, RemoteSockSize);
    }
    if (serr != 0) {
        error = _I_WSAGetLastError();

        //
        // if we are using non-blocking sockets then we need to wait until
        // the connect has completed, or an error occurs
        //

        if (isAsync) {
            if (error == WSAEWOULDBLOCK) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("connect() blocked, socket %#x\n",
                            m_Socket
                            ));

                PERF_LOG(PE_CONNECT_END,
                         m_Socket,
                         lpThreadInfo->ThreadId,
                         lpThreadInfo->hObject
                         );

                connectTime = (GetTickCountWrap() - connectTime);

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("connect() resumed, socket %#x, returns %s\n",
                            m_Socket,
                            InternetMapError(error)
                            ));
            } else {

                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("failed to connect non-blocking socket %#x, error %d\n",
                            m_Socket,
                            error
                            ));

            }
        } else {

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("failed to connect blocking socket %#x, error %d\n",
                        m_Socket,
                        error
                        ));

        }
    } else {

        PERF_LOG(PE_CONNECT_END,
                 m_Socket,
                 lpThreadInfo->ThreadId,
                 lpThreadInfo->hObject
                 );

        connectTime = (GetTickCountWrap() - connectTime);

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("socket %#x connected, time = %d mSec\n",
                    m_Socket,
                    connectTime
                    ));

        error = ERROR_SUCCESS;
    }

    if (error != ERROR_SUCCESS) {
        error = MapInternetError(error);
    }

    if (pObject != NULL) {
        pObject->ResetAbortHandle();

        //
        // if the operation has been cancelled, then this error overrides any
        // other
        //

        if (pObject->IsInvalidated()) {
            error = pObject->GetError();
            if (error == ERROR_SUCCESS) {
                error = ERROR_WINHTTP_OPERATION_CANCELLED;
            }
        }
        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        }
    }

quit:

    INET_ASSERT((pObject != NULL) ? (pObject->GetAbortHandle() == NULL) : TRUE);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SelectAccept(
    IN ICSocket & acceptSocket,
    IN DWORD dwTimeout
    )

/*++

Routine Description:

    Wait until listening socket has connection to accept. We use the socket
    handle in this ICSocket object to accept a connection & create a socket
    handle in another ICSocket object (in acceptSocket)

Arguments:

    acceptSocket    - socket object to wait on

    dwTimeout       - number of milliseconds to wait

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SelectAccept",
                 "%#x, %d",
                 &acceptSocket,
                 dwTimeout
                 ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        //informational INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    fd_set read_fds;
    fd_set except_fds;

    FD_ZERO(&read_fds);
    FD_ZERO(&except_fds);
    FD_SET(m_Socket, &read_fds);
    FD_SET(m_Socket, &except_fds);

    TIMEVAL timeout;

    timeout.tv_sec  = dwTimeout / 1000;
    timeout.tv_usec = dwTimeout % 1000;

    int n;

    n = _I_select(0, &read_fds, NULL, &except_fds, &timeout);
    if (n == 1) {
        if (FD_ISSET(m_Socket, &read_fds)) {
            error = ERROR_SUCCESS;
        } else if (FD_ISSET(m_Socket, &except_fds)) {
            error = ERROR_WINHTTP_CANNOT_CONNECT;

            DEBUG_PRINT(FTP,
                        ERROR,
                        ("select(): listening socket %#x in error (%d)\n",
                        m_Socket,
                        error
                        ));

            INET_ASSERT(acceptSocket.m_Socket == INVALID_SOCKET);
        } else {
            // Fix PREFIX warning (uninitialized error variable); this case should not happen.
            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
    } else if (n == 0) {

        //
        // timeout
        //

        error = ERROR_WINHTTP_TIMEOUT;

        DEBUG_PRINT(FTP,
                    WARNING,
                    ("select() timed out (%d.%d)\n",
                    timeout.tv_sec,
                    timeout.tv_usec
                    ));

        INET_ASSERT(acceptSocket.m_Socket == INVALID_SOCKET);

    } else {

        //
        // socket error
        //

        DEBUG_PRINT(FTP,
                    ERROR,
                    ("select() returns %d\n",
                    _I_WSAGetLastError()
                    ));

        INET_ASSERT(acceptSocket.m_Socket == INVALID_SOCKET);

        goto socket_error;
    }

    //
    // if we have a success indication then accept the connection; it may still
    // fail
    //

    if (error == ERROR_SUCCESS) {
        acceptSocket.m_Socket = _I_accept(m_Socket, NULL, NULL);
        if (acceptSocket.m_Socket != INVALID_SOCKET) {

            //
            // copy non-blocking indication to new socket
            //

            INET_ASSERT(!(m_dwFlags & SF_NON_BLOCKING));
            //acceptSocket.m_dwFlags |= (m_dwFlags & SF_NON_BLOCKING);
        } else {

            DEBUG_PRINT(FTP,
                        ERROR,
                        ("accept() returns %d\n",
                        error
                        ));

            goto socket_error;
        }
    }

quit:

    DEBUG_LEAVE(error);

    return error;

socket_error:

    error = MapInternetError(_I_WSAGetLastError());
    goto quit;
}


LPSTR
MapNetAddressToName(
    IN INTERNET_HANDLE_OBJECT* pSessionObject,
    IN LPSOCKADDR lpSockAddr
    )

/*++

Routine Description:

    Given a network address, tries to map it to the corresponding host name. We
    consult the name resolution cache to determine this

Arguments:

    pSessionObject      - pointer session object for access to resolver cache

    lpSockAddr          - pointer to SockAddr of address to map

Return Value:

    LPSTR
        Success - pointer to mapped name, Caller must free

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Pointer,
                "MapNetAddressToName",
                "%A",
                lpSockAddr
                ));

    INET_ASSERT(lpSockAddr != NULL);

    LPSTR lpszMappedName = NULL;

    //
    // now try to find the address in the cache. If it's not in the cache then
    // we don't resolve it, simply return the address
    //

    // We were passed the sockaddr for which to look

    DWORD ttl;
    LPADDRINFO CachedAddrInfo;
    LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry;

    if (pSessionObject && pSessionObject->GetResolverCache()->GetResolverCacheList() &&
        ((lpResolverCacheEntry=QueryResolverCache(pSessionObject->GetResolverCache()->GetResolverCacheList(), NULL, lpSockAddr, &CachedAddrInfo, &ttl))!= NULL)) {

            INET_ASSERT(CachedAddrInfo != NULL);

            if (CachedAddrInfo->ai_canonname != NULL)
                lpszMappedName = NewString(CachedAddrInfo->ai_canonname);

            ReleaseResolverCacheEntry(pSessionObject->GetResolverCache()->GetResolverCacheList(), lpResolverCacheEntry);
        }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("mapped name is %q\n",
                lpszMappedName
                ));

    DEBUG_LEAVE(lpszMappedName);

    return lpszMappedName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\fsm.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    fsm.cxx

Abstract:

    Contains CFsm class implementation

    Contents:
        ContainingFsm
        DoFsm
        StartFsmChain
        CFsm::CFsm
        CFsm::~CFsm
        CFsm::Push
        CFsm::Pop
        CFsm::QueueWorkItem
        CFsm::RunWorkItem
        CFsm::Run
        [CFsm::MapType]
        [CFsm::StateName]

Author:

     Richard L Firth (rfirth) 11-Apr-1997

Environment:

    Win32 user-mode DLL

Revision History:

    11-Apr-1997 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

#ifdef USE_DINARES_FSM_ALLOC_CACHE

CCritSec                FsmAllocCritSec;
void *                  FsmAllocList;
size_t                  FsmAllocSize;

#endif

#if INET_DEBUG

struct { int size; char* name; } class_sizes[] = {
    sizeof(CFsm), "CFsm",
    sizeof(CFsm_ResolveHost), "CFsm_ResolveHost",
    sizeof(CFsm_InternetParseUrl), "CFsm_InternetParseUrl",
    sizeof(CFsm_InternetQueryDataAvailable), "CFsm_InternetQueryDataAvailable",
    sizeof(CFsm_InternetWriteFile), "CFsm_InternetWriteFile",
    sizeof(CFsm_InternetReadFile), "CFsm_InternetReadFile",
    sizeof(CFsm_SocketConnect), "CFsm_SocketConnect",
    sizeof(CFsm_SocketSend), "CFsm_SocketSend",
    sizeof(CFsm_SocketReceive), "CFsm_SocketReceive",
    //sizeof(CFsm_SocketDataAvailable), "CFsm_SocketDataAvailable",
    sizeof(CFsm_SecureConnect), "CFsm_SecureConnect",
    sizeof(CFsm_SecureHandshake), "CFsm_SecureHandshake",
    sizeof(CFsm_SecureNegotiate), "CFsm_SecureNegotiate",
    sizeof(CFsm_NegotiateLoop), "CFsm_NegotiateLoop",
    sizeof(CFsm_SecureSend), "CFsm_SecureSend",
    sizeof(CFsm_SecureReceive), "CFsm_SecureReceive",
    sizeof(CFsm_GetConnection), "CFsm_GetConnection",
    sizeof(CFsm_HttpSendRequest), "CFsm_HttpSendRequest",
    sizeof(CFsm_MakeConnection), "CFsm_MakeConnection",
    sizeof(CFsm_OpenConnection), "CFsm_OpenConnection",
    sizeof(CFsm_OpenProxyTunnel), "CFsm_OpenProxyTunnel",
    sizeof(CFsm_SendRequest), "CFsm_SendRequest",
    sizeof(CFsm_ReceiveResponse), "CFsm_ReceiveResponse",
    sizeof(CFsm_HttpReadData), "CFsm_HttpReadData",
    sizeof(CFsm_HttpWriteData), "CFsm_HttpWriteData",
    sizeof(CFsm_ReadData), "CFsm_ReadData",
    sizeof(CFsm_HttpQueryAvailable), "CFsm_HttpQueryAvailable",
    sizeof(CFsm_DrainResponse), "CFsm_DrainResponse",
    sizeof(CFsm_Redirect), "CFsm_Redirect",
    sizeof(CFsm_ReadLoop), "CFsm_ReadLoop",
    sizeof(CFsm_ParseHttpUrl), "CFsm_ParseHttpUrl",
    sizeof(CFsm_OpenUrl), "CFsm_OpenUrl",
    sizeof(CFsm_ParseUrlForHttp), "CFsm_ParseUrlForHttp",
    sizeof(CFsm_ReadFile), "CFsm_ReadFile",
    sizeof(CFsm_ReadFileEx), "CFsm_ReadFileEx",
    //sizeof(CFsm_WriteFile), "CFsm_WriteFile",
    sizeof(CFsm_BackgroundTask), "CFsm_BackgroundTask",
    sizeof(CFsm_QueryAvailable), "CFsm_QueryAvailable"
};

void dump_class_sizes() {
    for (int i = 0; i < ARRAY_ELEMENTS(class_sizes); ++i) {
        DEBUG_PRINT(ASYNC,INFO,("%s = %d\n", class_sizes[i].name, class_sizes[i].size));
    }
}

#endif

//
// functions
//

//
// This is Dinarte's experiement for reducing Mem alloc on
//  creating FSMs.
//

#ifdef USE_DINARES_FSM_ALLOC_CACHE


VOID
FsmInitialize(
    VOID
    )

/*++

Routine Description:

    Performs initialization required by functions in this module

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - return code from LocalAlloc

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                None,
                "FsmInitialize",
                NULL
                ));

    FsmAllocCritSec.Init();

    FsmAllocSize = sizeof(CFsm);
    if (FsmAllocSize < sizeof(CFsm_ResolveHost))
        FsmAllocSize = sizeof(CFsm_ResolveHost);
    if (FsmAllocSize < sizeof(CFsm_SocketConnect))
        FsmAllocSize = sizeof(CFsm_SocketConnect);
    if (FsmAllocSize < sizeof(CFsm_SocketSend))
        FsmAllocSize = sizeof(CFsm_SocketSend);
    if (FsmAllocSize < sizeof(CFsm_SocketReceive))
        FsmAllocSize = sizeof(CFsm_SocketReceive);
    if (FsmAllocSize < sizeof(CFsm_SecureConnect))
        FsmAllocSize = sizeof(CFsm_SecureConnect);
    if (FsmAllocSize < sizeof(CFsm_SecureHandshake))
        FsmAllocSize = sizeof(CFsm_SecureHandshake);
    if (FsmAllocSize < sizeof(CFsm_SecureNegotiate))
        FsmAllocSize = sizeof(CFsm_SecureNegotiate);
    if (FsmAllocSize < sizeof(CFsm_NegotiateLoop))
        FsmAllocSize = sizeof(CFsm_NegotiateLoop);
    if (FsmAllocSize < sizeof(CFsm_SecureSend))
        FsmAllocSize = sizeof(CFsm_SecureSend);
    if (FsmAllocSize < sizeof(CFsm_SecureReceive))
        FsmAllocSize = sizeof(CFsm_SecureReceive);
    if (FsmAllocSize < sizeof(CFsm_GetConnection))
        FsmAllocSize = sizeof(CFsm_GetConnection);
    if (FsmAllocSize < sizeof(CFsm_HttpSendRequest))
        FsmAllocSize = sizeof(CFsm_HttpSendRequest);
    if (FsmAllocSize < sizeof(CFsm_MakeConnection))
        FsmAllocSize = sizeof(CFsm_MakeConnection);
    if (FsmAllocSize < sizeof(CFsm_OpenConnection))
        FsmAllocSize = sizeof(CFsm_OpenConnection);
    if (FsmAllocSize < sizeof(CFsm_OpenProxyTunnel))
        FsmAllocSize = sizeof(CFsm_OpenProxyTunnel);
    if (FsmAllocSize < sizeof(CFsm_SendRequest))
        FsmAllocSize = sizeof(CFsm_SendRequest);
    if (FsmAllocSize < sizeof(CFsm_ReceiveResponse))
        FsmAllocSize = sizeof(CFsm_ReceiveResponse);
    if (FsmAllocSize < sizeof(CFsm_HttpReadData))
        FsmAllocSize = sizeof(CFsm_HttpReadData);
    if (FsmAllocSize < sizeof(CFsm_HttpWriteData))
        FsmAllocSize = sizeof(CFsm_HttpWriteData);
    if (FsmAllocSize < sizeof(CFsm_ReadData))
        FsmAllocSize = sizeof(CFsm_ReadData);
    if (FsmAllocSize < sizeof(CFsm_HttpQueryAvailable))
        FsmAllocSize = sizeof(CFsm_HttpQueryAvailable);
    if (FsmAllocSize < sizeof(CFsm_DrainResponse))
        FsmAllocSize = sizeof(CFsm_DrainResponse);
    if (FsmAllocSize < sizeof(CFsm_Redirect))
        FsmAllocSize = sizeof(CFsm_Redirect);
    if (FsmAllocSize < sizeof(CFsm_ReadLoop))
        FsmAllocSize = sizeof(CFsm_ReadLoop);
    if (FsmAllocSize < sizeof(CFsm_ParseHttpUrl))
        FsmAllocSize = sizeof(CFsm_ParseHttpUrl);
    if (FsmAllocSize < sizeof(CFsm_OpenUrl))
        FsmAllocSize = sizeof(CFsm_OpenUrl);
    if (FsmAllocSize < sizeof(CFsm_ParseUrlForHttp))
        FsmAllocSize = sizeof(CFsm_ParseUrlForHttp);
    if (FsmAllocSize < sizeof(CFsm_ReadFile))
        FsmAllocSize = sizeof(CFsm_ReadFile);
    if (FsmAllocSize < sizeof(CFsm_ReadFileEx))
        FsmAllocSize = sizeof(CFsm_ReadFileEx);
    if (FsmAllocSize < sizeof(CFsm_QueryAvailable))
        FsmAllocSize = sizeof(CFsm_QueryAvailable);

    //
    // Pre-allocate a pool of state-machines for locality of reference
    //

    for (int cPreAlloc = 8192 / FsmAllocSize; cPreAlloc > 0; --cPreAlloc)
    {
        void * pFsm = (void *)ALLOCATE_FIXED_MEMORY(FsmAllocSize);

        if (pFsm == NULL)
            break;

        *(void **)pFsm = FsmAllocList;
        FsmAllocList = pFsm;
    }
}


VOID
FsmTerminate(
    VOID
    )

/*++

Routine Description:

    Obverse of FsmInitialize - frees any system resources allocated by
    FsmInitialize

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                None,
                "FsmTerminate",
                NULL
                ));

    //
    // there shouldn't be any other threads active when this function is called
    // but we'll grab the critical section anyway, just to make sure
    //

    if (FsmAllocCritSec.Lock())
    {

        while (FsmAllocList)
        {
            void * pFsm = FsmAllocList;
            FsmAllocList = *(void **)pFsm;
            FREE_MEMORY((HLOCAL)pFsm);
        }

        FsmAllocCritSec.Unlock();
    }

    //
    // delete the critical section
    //

    FsmAllocCritSec.FreeLock();

    DEBUG_LEAVE(0);
}

#endif


CFsm *
ContainingFsm(
    IN LPVOID lpAddress
    )

/*++

Routine Description:

    Returns address of start of CFsm object, including vtable

Arguments:

    lpAddress   - pointer to list inside CFsm object

Return Value:

    CFsm *  - pointer to start of object

--*/

{
    return CONTAINING_RECORD(lpAddress, CFsm, m_ListEntry);
}


//DWORD
//RunAll(
//    VOID
//    )
//{
//    DWORD error;
//    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
//
//    if (lpThreadInfo != NULL) {
//        while (lpThreadInfo->Fsm != NULL) {
//            lpThreadInfo->Fsm->Run();
//        }
//    } else {
//        error = ERROR_WINHTTP_INTERNAL_ERROR;
//    }
//    return error;
//}


DWORD
DoFsm(
    IN CFsm * pFsm
    )

/*++

Routine Description:

    Common FSM run processing

Arguments:

    pFsm    - FSM to run (maybe NULL if new failed)

Return Value:

    DWORD   - return code from running FSM

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "DoFsm",
                 "%#x (%s)",
                 pFsm,
                 pFsm->MapType()
                 ));

    DWORD error;
    BOOL bDeleteFsm = TRUE;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    //informational INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo != NULL)
    {
        if (pFsm != NULL)
        {
            error = pFsm->GetError();
            if (error == ERROR_SUCCESS) 
            {
                bDeleteFsm = FALSE;
                error = pFsm->Run(lpThreadInfo);
            }
            else 
            {
                INET_ASSERT(FALSE);
            }
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
    }

    if (bDeleteFsm && pFsm)
    {
        delete pFsm;
    }
    
    DEBUG_LEAVE(error);
    return error;
}


DWORD
StartFsmChain(
    IN CFsm * pFsm,
    IN HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    IN BOOL bQueue, /* = FALSE */
    IN BOOL bAsync  /* = TRUE  */
    )

/*++

Routine Description:

    Common FSM run processing for requests which
    are starting new fsm chains.  This pathway also ensures
    that no other FSM chain has already been initiated on
    the request handle.

Arguments:

    pFsm     - FSM to run (maybe NULL if new failed)

    pRequest - When not NULL, the FSM will be checked and placed
               into a blocked queue if an async work item on the
               request item is already in progress.  It's assumed
               this is only called for async request objects.

    bQueue   - When TRUE and bAsync is also TRUE, the FSM is
               queued to run in a worker thread.  If either are
               FALSE, the FSM chain is started on this thread.

    bAsync   - Indicates whether API that initiated this FSM
               chain is asynchronous.

Return Value:

    DWORD   - return code from running FSM

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "StartFsmChain",
                 "%#x (%s) %B",
                 pFsm,
                 pFsm->MapType(),
                 bQueue,
                 bAsync
                 ));

    DWORD error;
    BOOL bDeleteFsm = TRUE;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    //informational INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo != NULL)
    {
        if (pFsm != NULL)
        {
            error = pFsm->GetError();
            if (error == ERROR_SUCCESS)
            {
                DWORD dwStatus = 0;
                LPVOID lpvStatusInformation = NULL;
                DWORD dwStatusInformationLength = 0; 
                WINHTTP_ASYNC_RESULT asyncResult;
                DWORD dwFailureAPI = (DWORD)-1;

                if (pRequest)
                {
                    if (pRequest->SetWorkItemInProgressAtomic(TRUE))
                    {
                        //bad time to call async api, 
                        //wait for completion.
                        error = ERROR_INVALID_OPERATION;
                    }
                    else
                    {
                        if (bAsync)
                        {
                            if ((lpThreadInfo->NestedRequests > NESTED_CALL_THRESHOLD) && (!bQueue))
                            {
                                // we are asked to run the workitem on the current thread (!bQueue) but
                                // we've reach the nested call threshold, so we must queue the workitem

                                bQueue = TRUE;
                            }

                            if (bQueue)
                            {
                                error = pFsm->QueueWorkItem();
                                if (error == ERROR_IO_PENDING)
                                {
                                    //this is the ONLY success case from QWI.
                                    bDeleteFsm = FALSE;
                                }
                            }
                            else
                            {
                                bDeleteFsm = FALSE;
                                error = pFsm->Run(lpThreadInfo, &dwStatus, &lpvStatusInformation, 
                                                &dwStatusInformationLength, &asyncResult, &dwFailureAPI);

                                // We are running the fsm on app's thread and it returns sync'ly or async'ly, 
                                // in either case this thread has finished working on this fsm, and we now need
                                // to reset the fsm to null from the thread info, so that the app can use
                                // this thread to call other WinHttp APIs (e.g. WinHttpSendRequest)
                                lpThreadInfo->Fsm = NULL;
                            }

                            if (error != ERROR_IO_PENDING)
                            {
                                pRequest->SetWorkItemInProgressAtomic(FALSE);
                            }
                        }
                        else
                        {
                            bDeleteFsm = FALSE;
                            error = pFsm->Run(lpThreadInfo);
                            pRequest->SetWorkItemInProgressAtomic(FALSE);
                        }
                    }
                }
                else
                {
                    if (bAsync)
                    {
                        INET_ASSERT (FALSE);

                        error = pFsm->Run(lpThreadInfo, &dwStatus, &lpvStatusInformation, 
                                        &dwStatusInformationLength, &asyncResult, &dwFailureAPI);
                    }
                    else
                    {
                        error = pFsm->Run(lpThreadInfo);
                    }
                    bDeleteFsm = FALSE;
                }
            }
            else
            {
                INET_ASSERT(FALSE);
            }
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
    }

    if (bDeleteFsm && pFsm)
    {
        delete pFsm;
    }
    
    DEBUG_LEAVE(error);

    return error;
}


//
// methods
//


//
// This is Dinarte's experiement for reducing Mem alloc on
//  creating FSMs. Not used right now.
//

#ifdef USE_DINARES_FSM_ALLOC_CACHE


void *
CFsm::operator new(
    IN size_t Size
    )

/*++

Routine Description:

    Allocates memory for the new state-machine from a special memory pool.

Arguments:

    Size        - size of the state-machine

Return Value:

    None.

--*/

{
    VOID * pFsm = NULL;

    if (FsmAllocCritSec.Lock())
    {
        // Only alloc from the list if we can synchronize access to it.

        pFsm = FsmAllocList;

        if (pFsm)
        {
            FsmAllocList = *(void **)pFsm;
        }

        FsmAllocCritSec.Unlock();
    }

    if (pFsm == NULL)
    {
        INET_ASSERT(Size <= FsmAllocSize);

        pFsm = (void *)ALLOCATE_FIXED_MEMORY(FsmAllocSize);
    }

    return(pFsm);
}


VOID
CFsm::operator delete(
    IN VOID * pFsm
    )

/*++

Routine Description:

    Deallocates memory for the state-machine by adding it to a special
    memory pool.

Arguments:

    pFsm        - pointer to the state-machine

Return Value:

    None.

--*/

{
    if (pFsm)
    {
        if (FsmAllocCritSec.Lock())
        {
            *(void **)pFsm = FsmAllocList;
            FsmAllocList = pFsm;

            FsmAllocCritSec.Unlock();
        }
        // else leak?
    }
}
#endif


CFsm::CFsm(
    IN DWORD (* lpfnHandler)(CFsm *),
    IN LPVOID lpvContext
    ) : CPriorityListEntry(0)

/*++

Routine Description:

    CFsm constructor. This gets called many times since its the base of all the
    derived FSMs

Arguments:

    lpfnHandler - state-machine handler

    lpvContext  - callee context

Return Value:

    None.

--*/

{
#if INET_DEBUG
    static bool b = TRUE;
    if (b) {
        dump_class_sizes();
        b=FALSE;
    }
#endif

    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CFsm::CFsm",
                 "{%#x}",
                 this
                 ));

    INIT_FSM();

    m_lpThreadInfo = InternetGetThreadInfo();
    if (m_lpThreadInfo == NULL) {

        //informational INET_ASSERT(m_lpThreadInfo != NULL);

        SetError(ERROR_WINHTTP_INTERNAL_ERROR);

        DEBUG_LEAVE(0);

        return;
    }
    m_hObject = m_lpThreadInfo->hObject;
    m_hObjectMapped = (INTERNET_HANDLE_OBJECT *)m_lpThreadInfo->hObjectMapped;
    m_dwContext = m_hObjectMapped->GetContext();
    m_dwMappedErrorCode = m_lpThreadInfo->dwMappedErrorCode;
    m_State = FSM_STATE_INIT;
    m_NextState = FSM_STATE_CONTINUE;
    m_FunctionState = FSM_STATE_BAD;
    m_lpfnHandler = lpfnHandler;
    m_lpvContext = lpvContext;
    SetError(ERROR_SUCCESS);
    m_bPop = TRUE;
    Push();
    m_Hint = FSM_HINT_SLOW;
    m_Socket = INVALID_SOCKET;
    m_Action = FSM_ACTION_NONE;
    m_dwBlockId = 0;
    m_dwTimeout = INFINITE;
    m_fTimeoutWraps = FALSE;
    m_dwTimer = 0;
    m_bTimerStarted = FALSE;
    m_bIsBlockingFsm = FALSE;
    m_bIsApi = FALSE;
    m_ApiType = ApiType_None;
    m_dwApiData = 0;
    m_ApiResult.Handle = NULL;
    m_bHasTimeout = FALSE;
#ifdef USE_OLD_SENDRECV_SYNC
    m_bOnAsyncList = FALSE;
#endif
    DEBUG_LEAVE(0);
}


CFsm::~CFsm()

/*++

Routine Description:

    CFsm desctructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CFsm::~CFsm",
                 "{%#x}",
                 this
                 ));

    CHECK_FSM();

    if (m_bPop)
    {
        CHECK_OWNED();
        Pop();    
    }
    
#ifdef STRESS_BUG_DEBUG
    m_Link = (CFsm *) (DWORD_PTR) 0xFEFEFEFE;
    m_dwError = 0xFEFEFEFE;
    m_lpThreadInfo = (LPINTERNET_THREAD_INFO) (DWORD_PTR) 0xFEFEFEFE;
    m_dwContext = 0xFEFEFEFE;
    m_hObject = (HINTERNET)(DWORD_PTR) 0xFEFEFEFE;
#endif

    DEBUG_LEAVE(0);
}


VOID
CFsm::Push(
    VOID
    )

/*++

Routine Description:

    Adds this FSM to the head of the queue

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "CFsm::Push",
                 "{%#x (%s:%s)}",
                 this,
                 MapState(),
                 MapFunctionState()
                 ));

    CHECK_FSM();
    CHECK_UNOWNED();
    INET_ASSERT(m_lpThreadInfo != NULL);
    CHECK_INTERNET_THREAD_INFO(m_lpThreadInfo);

    m_Link = m_lpThreadInfo->Fsm;
    m_lpThreadInfo->Fsm = this;

    CHECK_FSM_OWNED(m_Link);
    RESET_FSM_OWNED(m_Link);

    DEBUG_PRINT(ASYNC,
                INFO,
                ("!!! FSM %#x unowned\n", m_Link
                ));

    SET_OWNED();

    DEBUG_PRINT(ASYNC,
                INFO,
                ("!!! FSM %#x owned by %#x\n",
                this,
                GetCurrentThreadId()
                ));

    DEBUG_LEAVE(0);
}


VOID
Pop(
    CFsm * pNextFsm,
    INTERNET_THREAD_INFO * lpThreadInfo,
    DWORD dwError
    )

/*++

Routine Description:

    Puts the next FSM (if any) at the head of the queue

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "Pop",
                 "%#x",
                 pNextFsm
                 ));

    INET_ASSERT(lpThreadInfo != NULL);
    
    CHECK_INTERNET_THREAD_INFO(lpThreadInfo);
    CHECK_FSM_UNOWNED(pNextFsm);

    lpThreadInfo->Fsm = pNextFsm;

    SET_FSM_OWNED(pNextFsm);

    DEBUG_PRINT(ASYNC,
                INFO,
                ("!!! FSM %#x owned by %#x\n",
                pNextFsm,
                GetCurrentThreadId()
                ));

    if (pNextFsm != NULL) 
    {
        pNextFsm->SetState(pNextFsm->GetNextState());
        pNextFsm->SetError(dwError);

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("next FSM %#x (%s), state %s, function-state %s\n",
                    pNextFsm,
                    pNextFsm->MapType(),
                    pNextFsm->MapState(),
                    pNextFsm->MapFunctionState()
                    ));
    }
    else
    {
        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("last FSM\n"
                    ));
    }

    DEBUG_LEAVE(0);
}


VOID
CFsm::Pop(
    VOID
    )

/*++

Routine Description:

    Puts the next FSM (if any) at the head of the queue

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "CFsm::Pop",
                 "{%#x (%s:%s)}",
                 this,
                 MapState(),
                 MapFunctionState()
                 ));

    INET_ASSERT(m_lpThreadInfo != NULL);
    CHECK_FSM();
    CHECK_OWNED();

    ::Pop(m_Link, m_lpThreadInfo, GetError());

    DEBUG_LEAVE(0);
}


DWORD
CFsm::QueueWorkItem(
    DWORD dwCompletionBytes,
    LPVOID lpCompletionKey 
    )

/*++

Routine Description:

    Queues this FSM to worker thread for processing. Worker thread callback is
    CFsm::RunWorkItem

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - return code from SHQueueUserWorkItem

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "CFsm::QueueWorkItem",
                 "{%#x [%s, socket %#x, block id %#x, timeout %#x, error %d, state %s:%s]}",
                 this,
                 MapType(),
                 GetSocket(),
                 GetBlockId(),
                 GetTimeout(),
                 GetError(),
                 MapState(),
                 MapFunctionState()
                 ));

    DWORD error = ERROR_IO_PENDING;

    RESET_OWNED();
    
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("Posting IO completion with 0x%x\n",
                this
                ));

    DEBUG_PRINT(SOCKETS,
                     INFO,
                     ("***PostQueuedCompletionStatus: "
                     "(hComp)%#x, (# bytes)%#x, (completionkey)%#x, (overlapped)%#x",
                     g_hCompletionPort,
                     dwCompletionBytes ? dwCompletionBytes : COMPLETION_BYTES_CUSTOM,
                     lpCompletionKey ? ULONG_PTR (lpCompletionKey) : ULONG_PTR (this),
                     g_lpCustomOverlapped
                     ));

    if (PostQueuedCompletionStatus(g_hCompletionPort,
                                    dwCompletionBytes ? dwCompletionBytes : COMPLETION_BYTES_CUSTOM,
                                    lpCompletionKey ? ULONG_PTR (lpCompletionKey) : ULONG_PTR (this),
                                    g_lpCustomOverlapped
                                    ))
    {
        DEBUG_PRINT(SOCKETS,
                         INFO,
                         ("***PostQueuedCompletionStatus: "
                         "returned TRUE"
                         ));
#if INET_DEBUG
        InterlockedIncrement(&g_cCustomCompletions);
    
        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("!!!g_cCustomCompletions = 0x%x\n",
                    g_cCustomCompletions
                    ));
#endif
        LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

        //informational INET_ASSERT(lpThreadInfo != NULL);

        if (lpThreadInfo != NULL)
            lpThreadInfo->Fsm = NULL;
    }
    else
    {
        DEBUG_PRINT(SOCKETS,
                         INFO,
                         ("***PostQueuedCompletionStatus: "
                         "returned FALSE"
                         ));
        
        error = GetLastError();
        INET_ASSERT (error != ERROR_SUCCESS);
    }

    //informational INET_ASSERT(error == ERROR_IO_PENDING);

    DEBUG_LEAVE(error);
    return error;
}


DWORD
CFsm::RunWorkItem(
    IN CFsm * pFsm
    )

/*++

Routine Description:

    Run the current work item to the next block state or completion. This
    (class static) function is called in the context of a system thread pool
    callback function

Arguments:

    pFsm    - pointer to FSM to run

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INTERNAL_ERROR

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    //informational INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo == NULL) {

        //informational INET_ASSERT(FALSE);

        return ERROR_WINHTTP_INTERNAL_ERROR;
    }

    lpThreadInfo->IsAsyncWorkerThread = TRUE;

    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "RunWorkItem",
                 "%#x",
                 pFsm
                 ));

    PERF_ENTER(Worker);

    DWORD error;

    DEBUG_PRINT(ASYNC,
                INFO,
                ("%s Fsm %#x: socket %#x, block id %#x, timeout %#x, error %d\n",
                pFsm->MapType(),
                pFsm,
                pFsm->GetSocket(),
                pFsm->GetBlockId(),
                pFsm->GetTimeout(),
                pFsm->GetError()
                ));

    INTERNET_HANDLE_BASE *pSession = (INTERNET_HANDLE_BASE *)(pFsm->GetMappedHandleObject());
    HANDLE ThreadToken = pSession->GetThreadToken();
    HANDLE ThreadHandle = GetCurrentThread();
    
    if (ThreadToken)
    {
        if (::SetThreadToken(&ThreadHandle,
                             ThreadToken) == FALSE)
        {
            ThreadToken = 0;
        }

    }

    while (TRUE)
    {
        INET_ASSERT(pFsm != NULL);

        BOOL bIsApi = pFsm->IsApi();
        API_TYPE apiType = pFsm->GetApiType();

        lpThreadInfo->Fsm = pFsm;

        SET_FSM_OWNED(pFsm);

        DWORD dwStatus = 0;
        LPVOID lpvStatusInformation = NULL;
        DWORD dwStatusInformationLength = 0; 
        WINHTTP_ASYNC_RESULT asyncResult;
        DWORD dwFailureAPI = (DWORD)-1;
        DWORD dwResultValue;

        if (pFsm->IsInvalid())
        {
            pFsm->SetErrorState(ERROR_WINHTTP_OPERATION_CANCELLED);
            pFsm->Run(lpThreadInfo, &dwStatus, &lpvStatusInformation, 
                    &dwStatusInformationLength, &asyncResult, &dwFailureAPI);
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        }
        else
        {
            error = pFsm->Run(lpThreadInfo, &dwStatus, &lpvStatusInformation, 
                    &dwStatusInformationLength, &asyncResult, &dwFailureAPI);
        }
        
        if (error == ERROR_IO_PENDING) 
        {
            break;
        }
        
        pFsm = lpThreadInfo->Fsm;
        
        if (pFsm == NULL) 
        {
            if (bIsApi
            && ((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->IsAsyncHandle()) 
            {
                DEBUG_PRINT(ASYNC,
                            INFO,
                            ("dwStatus = %d [%#x], lpvStatusInformation=%#x, dwStatusInformationLength = %d [%#x],"
                            "apiType = %s, error = %d\n",
                            dwStatus, dwStatus,
                            lpvStatusInformation, 
                            dwStatusInformationLength, dwStatusInformationLength,
                            (apiType==ApiType_Handle)?"HANDLE":"BOOL",
                            error));

                UNREFERENCED_PARAMETER(apiType);
                INET_ASSERT((apiType == ApiType_Handle)
                            || (apiType == ApiType_Bool));

                SetLastError(error);

                if(error != ERROR_SUCCESS)
                {
                    dwStatus = WINHTTP_CALLBACK_STATUS_REQUEST_ERROR;
                    asyncResult.dwResult = dwFailureAPI;
                    // asyncResult.dwError contains the error code as appropriate.
                    DEBUG_PRINT(ASYNC,
                                INFO,
                                ("WINHTTP_CALLBACK_STATUS_REQUEST_ERROR: Error Function=%s\n",
                                InternetMapRequestError(dwFailureAPI)
                                ));
                }
                else if (lpvStatusInformation)
                {
                    if ((dwStatus == WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE)
                        // || (dwStatus == WINHTTP_CALLBACK_STATUS_READ_COMPLETE)   // bug 505983
                        || (dwStatus == WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE))    // bug 496469
                    {
                        dwResultValue = asyncResult.dwError;
                        lpvStatusInformation = (LPVOID)&dwResultValue;
                        dwStatusInformationLength = sizeof (DWORD);
                    }
                }
                
                if (((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->GetHandleType() == TypeHttpRequestHandle)
                {
                    ((HTTP_REQUEST_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->SetWorkItemInProgressAtomic(FALSE);
                }

                InternetIndicateStatus(dwStatus,
                                       lpvStatusInformation,
                                       dwStatusInformationLength
                                       );

                //INET_ASSERT(((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)
                //            ->GetObjectType() == TypeHttpRequestHandle);

                DereferenceObject((LPVOID)lpThreadInfo->hObjectMapped);
            }
            break;
        }
        else if (bIsApi)
        {
            //
            // completing an async API that is not the last in the chain.
            // Typically, HttpSendRequest() within InternetOpenUrl()
            //

            DereferenceObject((LPVOID)lpThreadInfo->hObjectMapped);
        }
    }

    if (ThreadToken)
    {
        RevertToSelf();
    }
    
    // Must stay marked as being on an async worker thread until after
    // releasing the reference in order to prevent confusion in the async count.
    lpThreadInfo->IsAsyncWorkerThread = FALSE;

    PERF_LEAVE(Worker);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm::Run(
    IN LPINTERNET_THREAD_INFO lpThreadInfo,
    OUT DWORD *pdwStatus OPTIONAL, 
    OUT LPVOID *ppvStatusInformation OPTIONAL, 
    OUT DWORD *pdwStatusInformationLength OPTIONAL, 
    OUT WINHTTP_ASYNC_RESULT *pAsyncResult OPTIONAL, 
    OUT DWORD *pdwFailureAPI OPTIONAL
    )

/*++

Routine Description:

    Runs the state handler for this FSM

Arguments:

    lpThreadInfo    - INTERNET_THREAD_INFO for this thread

    lpdwApiResult   - where optional API result is written

    lpdwApiData     - where optional API data iswritten

Return Value:

    DWORD   - return code from state handler

--*/

{

    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "CFsm::Run",
                 "%#x, %#x [%#x], %#x [%#x], %#x [%#x], %#x, %#x [%#x]",
                 lpThreadInfo,
                 pdwStatus,
                 (pdwStatus?*pdwStatus:NULL),
                 ppvStatusInformation,
                 (ppvStatusInformation?*ppvStatusInformation:NULL),
                 pdwStatusInformationLength,
                 (pdwStatusInformationLength?*pdwStatusInformationLength:NULL),
                 pAsyncResult,
                 pdwFailureAPI,
                 (pdwFailureAPI?*pdwFailureAPI:NULL)
                 ));

    CHECK_FSM();
    CHECK_OWNED();
    INET_ASSERT(lpThreadInfo != NULL);
    INET_ASSERT(lpThreadInfo->Fsm != NULL);

    DWORD error = ERROR_SUCCESS;

    _InternetSetObjectHandle(lpThreadInfo, m_hObject, m_hObjectMapped);

    m_lpThreadInfo = lpThreadInfo;

    while (TRUE) {

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("%s Fsm %#x state %s (%d) function-state %s (%d) error %s (%d)\n",
                    MapType(),
                    this,
                    MapState(),
                    GetState(),
                    MapFunctionState(),
                    GetFunctionState(),
                    InternetMapError(GetError()),
                    GetError()
                    ));

        error = (*m_lpfnHandler)(this);

        if (error == ERROR_IO_PENDING) {
            break;
        }
        
        SetError(error);
        SetMappedError(lpThreadInfo->dwMappedErrorCode);
        if (IsDone()) {

            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("%s Fsm %#x done, next is %s %#x\n",
                        MapType(),
                        this,
                        m_Link ? m_Link->MapType() : "",
                        m_Link
                        ));

            if (pdwStatus)
            {
                // Populate these values in preparation for InternetIndicateStatus if needed:
                if (GetStatusValues(pdwStatus, ppvStatusInformation, 
                    pdwStatusInformationLength, pAsyncResult, pdwFailureAPI))
                {
                    INET_ASSERT(*pdwStatus);
                }
            }

            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("Fsm %#x finished with GetApiResult() = %#x, GetApiData() = %#x\n",
                        this,
                        GetApiResult(),
                        GetApiData()
                        ));

#ifdef USE_OLD_SENDRECV_SYNC
            INET_ASSERT (!IsOnAsyncList());
#endif
            CFsm* pNext;
            DWORD dwError;
            
            if ((pNext = Dereference(&dwError)) != NULL)
                ::Pop(pNext, lpThreadInfo, dwError);

            break;
        }
        SetState(GetNextState());
    }

    DEBUG_LEAVE(error);

    return error;
}

#if INET_DEBUG

#if !defined(CASE_OF)
#define CASE_OF(x) case x: return #x
#endif

DEBUG_FUNCTION
LPSTR
CFsm::MapType(
    VOID
    ) {
    switch (m_Type) {
    case FSM_TYPE_NONE:                     return "NONE";
    case FSM_TYPE_WAIT_FOR_COMPLETION:      return "WAIT_FOR_COMPLETION";
    case FSM_TYPE_RESOLVE_HOST:             return "RESOLVE_HOST";
    case FSM_TYPE_SOCKET_CONNECT:           return "SOCKET_CONNECT";
    case FSM_TYPE_SOCKET_SEND:              return "SOCKET_SEND";
    case FSM_TYPE_SOCKET_RECEIVE:           return "SOCKET_RECEIVE";
    case FSM_TYPE_SOCKET_QUERY_AVAILABLE:   return "SOCKET_QUERY_AVAILABLE";
    case FSM_TYPE_SECURE_CONNECT:           return "SECURE_CONNECT";
    case FSM_TYPE_SECURE_HANDSHAKE:         return "SECURE_HANDSHAKE";
    case FSM_TYPE_SECURE_NEGOTIATE:         return "SECURE_NEGOTIATE";
    case FSM_TYPE_NEGOTIATE_LOOP:           return "NEGOTIATE_LOOP";
    case FSM_TYPE_SECURE_SEND:              return "SECURE_SEND";
    case FSM_TYPE_SECURE_RECEIVE:           return "SECURE_RECEIVE";
    case FSM_TYPE_GET_CONNECTION:           return "GET_CONNECTION";
    case FSM_TYPE_HTTP_SEND_REQUEST:        return "HTTP_SEND_REQUEST";
    case FSM_TYPE_MAKE_CONNECTION:          return "MAKE_CONNECTION";
    case FSM_TYPE_OPEN_CONNECTION:          return "OPEN_CONNECTION";
    case FSM_TYPE_OPEN_PROXY_TUNNEL:        return "OPEN_PROXY_TUNNEL";
    case FSM_TYPE_SEND_REQUEST:             return "SEND_REQUEST";
    case FSM_TYPE_RECEIVE_RESPONSE:         return "RECEIVE_RESPONSE";
    case FSM_TYPE_HTTP_READ:                return "HTTP_READ";
    case FSM_TYPE_HTTP_WRITE:               return "HTTP_WRITE";
    case FSM_TYPE_READ_DATA:                return "READ_DATA";
    case FSM_TYPE_HTTP_QUERY_AVAILABLE:     return "HTTP_QUERY_AVAILABLE";
    case FSM_TYPE_DRAIN_RESPONSE:           return "DRAIN_RESPONSE";
    case FSM_TYPE_REDIRECT:                 return "REDIRECT";
    case FSM_TYPE_READ_LOOP:                return "READ_LOOP";
    case FSM_TYPE_PARSE_HTTP_URL:           return "PARSE_HTTP_URL";
    case FSM_TYPE_PARSE_URL_FOR_HTTP:       return "PARSE_URL_FOR_HTTP";
    case FSM_TYPE_READ_FILE:                return "READ_FILE";
    case FSM_TYPE_READ_FILE_EX:             return "READ_FILE_EX";
    case FSM_TYPE_WRITE_FILE:               return "WRITE_FILE";
    case FSM_TYPE_QUERY_DATA_AVAILABLE:     return "QUERY_DATA_AVAILABLE";
    case FSM_TYPE_FTP_CONNECT:              return "FTP_CONNECT";
    case FSM_TYPE_FTP_FIND_FIRST_FILE:      return "FTP_FIND_FIRST_FILE";
    case FSM_TYPE_FTP_GET_FILE:             return "FTP_GET_FILE";
    case FSM_TYPE_FTP_PUT_FILE:             return "FTP_PUT_FILE";
    case FSM_TYPE_FTP_DELETE_FILE:          return "FTP_DELETE_FILE";
    case FSM_TYPE_FTP_RENAME_FILE:          return "FTP_RENAME_FILE";
    case FSM_TYPE_FTP_OPEN_FILE:            return "FTP_OPEN_FILE";
    case FSM_TYPE_FTP_CREATE_DIRECTORY:     return "FTP_CREATE_DIRECTORY";
    case FSM_TYPE_FTP_REMOVE_DIRECTORY:     return "FTP_REMOVE_DIRECTORY";
    case FSM_TYPE_FTP_SET_CURRENT_DIRECTORY:    return "FTP_SET_CURRENT_DIRECTORY";
    case FSM_TYPE_FTP_GET_CURRENT_DIRECTORY:    return "FTP_GET_CURRENT_DIRECTORY";
    case FSM_TYPE_GOPHER_FIND_FIRST_FILE:   return "GOPHER_FIND_FIRST_FILE";
    case FSM_TYPE_GOPHER_OPEN_FILE:         return "GOPHER_OPEN_FILE";
    case FSM_TYPE_GOPHER_GET_ATTRIBUTE:     return "GOPHER_GET_ATTRIBUTE";
    case FSM_TYPE_INTERNET_PARSE_URL:       return "INTERNET_PARSE_URL";
    case FSM_TYPE_INTERNET_FIND_NEXT_FILE:  return "INTERNET_FIND_NEXT_FILE";
    case FSM_TYPE_INTERNET_QUERY_DATA_AVAILABLE:    return "INTERNET_QUERY_DATA_AVAILABLE";
    case FSM_TYPE_INTERNET_WRITE_FILE:      return "INTERNET_WRITE_FILE";
    case FSM_TYPE_INTERNET_READ_FILE:       return "INTERNET_READ_FILE";
    }
    return "?";
}

DEBUG_FUNCTION
LPSTR
CFsm::StateName(
    IN DWORD State
    ) {
    switch (State) {
    CASE_OF(FSM_STATE_BAD);
    CASE_OF(FSM_STATE_INIT);
    CASE_OF(FSM_STATE_WAIT);
    CASE_OF(FSM_STATE_DONE);
    CASE_OF(FSM_STATE_ERROR);
    CASE_OF(FSM_STATE_CONTINUE);
    CASE_OF(FSM_STATE_FINISH);
    CASE_OF(FSM_STATE_1);
    CASE_OF(FSM_STATE_2);
    CASE_OF(FSM_STATE_3);
    CASE_OF(FSM_STATE_4);
    CASE_OF(FSM_STATE_5);
    CASE_OF(FSM_STATE_6);
    CASE_OF(FSM_STATE_7);
    CASE_OF(FSM_STATE_8);
    CASE_OF(FSM_STATE_9);
    CASE_OF(FSM_STATE_10);
    }
    return "?";
}

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\multilang.cxx ===
/*
 *  multilang.cxx
 *
 *  most of the contents of this file are modified functions from mshtml...intlcore
 */

/*
 *  MultiByteToWideCharGeneric
 *
 *  Purpose:
 *      Convert an ascii string to a BSTR with a given codepage
 *
 *  Fail if:
 *      out of memory
 *      codepage not available
 *      invalid character encountered
 *
 *  Make sure:
 *      parameters are valid for this function
 *
 *  Only returns:
 *      ERROR_SUCCESS
 *      E_OUTOFMEMORY
 *      HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION) - other error in MB2WC.
 */
#include <wininetp.h>
#include "multilang.hxx"

HRESULT 
MultiByteToWideCharGeneric(BSTR * pbstr, char * sz, int cch, UINT cp)
{
    DEBUG_ENTER((DBG_UTIL,
                 Dword,
                 "MultiByteToWideCharGeneric",
                 "sz=%#x, cch=%d, cp=%d(%#x)",
                 sz, cch, cp, cp
                 ));

    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION);
    int cwch;

    if( !DelayLoad(&g_moduleOleAut32))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Determine how big the ascii string will be
    cwch = MultiByteToWideChar(cp, MB_ERR_INVALID_CHARS, sz, cch,
                                NULL, 0);

    if (!cwch)
    {
        goto exit;
    }
    
    *pbstr = DL(SysAllocStringLen)(NULL, cwch);

    if (!*pbstr)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    cwch = MultiByteToWideChar(cp, MB_ERR_INVALID_CHARS, sz, cch,
                                *pbstr, cwch);

    if (!cwch)
    {
        DL(SysFreeString)(*pbstr);
        *pbstr = NULL;
        goto exit;
    }

    hr = NOERROR;

    DEBUG_DUMP(UTIL,
               "multibyte data:\n",
               (LPBYTE)sz,
               cch
               );

    DEBUG_DUMP(UTIL,
               "widechar data:\n",
               (LPBYTE)*pbstr,
               cwch*2
               );

exit:
    DEBUG_LEAVE(hr);
    return hr;
}

/*
 *  MultiByteToWideCharWithMlang
 *
 *  Purpose:
 *      Convert an ascii string to a BSTR with a given codepage
 *      if *pMultiLanguage2 == NULL, this will co-create it, and it's
 *      caller's responsibility to free the interface, if filled in **regardless of error**
 *
 *  Fail if:
 *      out of memory
 *      codepage not available
 *      invalid character encountered
 *
 *
 *  Make sure:
 *      parameters are valid for this function
 *
 *  Only returns:
 *      ERROR_SUCCESS
 *      E_OUTOFMEMORY
 *      HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION) - CLSID_CMultiLanguage not available, or other error in conversion.
 */

HRESULT 
MultiByteToWideCharWithMlang(BSTR * pbstr, char * sz, int cch, UINT cp, IMultiLanguage2** pMultiLanguage2)
{
    DEBUG_ENTER((DBG_UTIL,
                 Dword,
                 "MultiByteToWideCharWithMlang",
                 "sz=%#x, cch=%d, cp=%d(%#x), IMultiLanguage2=%#x",
                 sz, cch, cp, cp, *pMultiLanguage2
                 ));

    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION);
    UINT cwch;
    DWORD dwMode = 0;
    IMultiLanguage* pMultiLanguage;

    if (!DelayLoad(&g_moduleOle32)
        || !DelayLoad(&g_moduleOleAut32))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (!*pMultiLanguage2)
    {
        if (FAILED(DL(CoCreateInstance)(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, 
                    IID_IMultiLanguage, (void**)&pMultiLanguage)))
        {
            goto exit;
        }

        INET_ASSERT (pMultiLanguage);
        
        pMultiLanguage->QueryInterface(IID_IMultiLanguage2, (void **)pMultiLanguage2);
        pMultiLanguage->Release();
        
        if (!*pMultiLanguage2)
        {
            goto exit;
        }
    }
    
    // Determine how big the ascii string will be
   
    if (S_OK != (*pMultiLanguage2)->ConvertStringToUnicode (&dwMode, cp, (char*)sz, (UINT*)&cch, NULL, &cwch))
    {
        // S_FALSE for conversion not supported (no such language pack), E_FAIL for internal error.
        goto exit;
    }
    
    *pbstr = DL(SysAllocStringLen)(NULL, cwch);

    if (!*pbstr)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    if (S_OK != (*pMultiLanguage2)->ConvertStringToUnicode (&dwMode, cp, (char*)sz, (UINT*)&cch, *pbstr, &cwch))
    {
        // S_FALSE for conversion not supported (no such language pack), E_FAIL for internal error.
        DL(SysFreeString)(*pbstr);  // This will be reallocated.
        *pbstr = NULL;
        goto exit;  // Use default ANSI code page
    }
    
    hr = NOERROR;

    DEBUG_DUMP(UTIL,
               "multibyte data:\n",
               (LPBYTE)sz,
               cch
               );

    DEBUG_DUMP(UTIL,
               "widechar data:\n",
               (LPBYTE)*pbstr,
               cwch*2
               );

exit:
    DEBUG_LEAVE(hr);
    return hr;
}

static const int aiByteCountForLeadNibble[16] =
{
    1,  // 0000
    1,  // 0001
    1,  // 0010
    1,  // 0011
    1,  // 0100
    1,  // 0101
    1,  // 0110
    1,  // 0111
    1,  // 1000
    1,  // 1001
    1,  // 1010
    1,  // 1011
    2,  // 1100
    2,  // 1101
    3,  // 1110
    4   // 1111
};

/*
 *  Utf8ToWideChar
 *
 *  Purpose:
 *      Convert an ascii string to a BSTR for CP_UTF8
 *
 *  Fail if:
 *      out of memory
 *      invalid character encountered
 *
 *
 *  Make sure:
 *      parameters are valid for this function
 *
 *  Only returns:
 *      ERROR_SUCCESS
 *      E_OUTOFMEMORY
 *      HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION) - error in conversion/invalid character.
 */

HRESULT
Utf8ToWideChar(BSTR * pbstr, char * sz, int cch)
{
    DEBUG_ENTER((DBG_UTIL,
                 Dword,
                 "Utf8ToWideChar",
                 "sz=%#x, cch=%d",
                 sz, cch
                 ));

    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION);
    unsigned char * pb;
    unsigned char * pbStop;
    WCHAR * pchDst;
    int cwch;
    
    // First determine the destination size (cwch).
    // Note that pbStop is adjust to the last character boundary.

    for (pb = (unsigned char *)sz, pbStop = (unsigned char *)sz + cch, cwch = 0; pb < pbStop;)
    {
        unsigned char t = *pb;
        size_t bytes = aiByteCountForLeadNibble[t>>4];

        if (pb + bytes > pbStop)
        {
            pbStop = pb;
            break;
        }
        else
        {
            pb += bytes;
        }

        cwch += 1 + (bytes>>2); // surrogates need an extra wchar
    }
    
    *pbstr = DL(SysAllocStringLen)(NULL, cwch);

    if (!*pbstr)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Now decode

    for (pchDst  = *pbstr, pb = (unsigned char *)sz; pb < pbStop;)
    {
        unsigned char t = *pb;
        size_t bytes = aiByteCountForLeadNibble[t>>4];
        WCHAR ch = 0;

        switch (bytes)
        {
            case 1:
                *pchDst++ = WCHAR(*pb++);           // 0x0000 - 0x007f
                break;

            case 3:
                ch  = WCHAR(*pb++ & 0x0f) << 12;    // 0x0800 - 0xffff
                // fall through

            case 2:
                ch |= WCHAR(*pb++ & 0x3f) << 6;     // 0x0080 - 0x07ff
                ch |= WCHAR(*pb++ & 0x3f);

                if (IsValidWideChar(ch))
                {
                    *pchDst++ = ch;
                }
                else
                {
                    goto ConvertError;
                }
                break;
                    
            case 4:                                 // 0xd800 - 0xdfff (Surrogates)
                ch  = WCHAR(*pb++ & 0x07) << 2;
                ch |= WCHAR(*pb & 0x30) >> 4;
                ch  = (ch - 1) << 6;                // ch == 0000 00ww ww00 0000
                ch |= WCHAR(*pb++ & 0x0f) << 2;     // ch == 0000 00ww wwzz zz00
                ch |= WCHAR(*pb & 0x30) >> 4;       // ch == 0000 00ww wwzz zzyy
                *pchDst++ = 0xD800 + ch;
                
                INET_ASSERT(IsHighSurrogateChar(pchDst[-1]));

                ch  = WCHAR(*pb++ & 0x0f) << 6;     // ch == 0000 00yy yy00 0000
                ch |= WCHAR(*pb++ & 0x3f);          // ch == 0000 00yy yyxx xxxx
                *pchDst++ = 0xDC00 + ch;
                
                INET_ASSERT(IsLowSurrogateChar(pchDst[-1]));

                break;
        }
    }

    hr = NOERROR;

    DEBUG_DUMP(UTIL,
               "multibyte data:\n",
               (LPBYTE)sz,
               cch
               );

    DEBUG_DUMP(UTIL,
               "widechar data:\n",
               (LPBYTE)*pbstr,
               cwch*2
               );

Cleanup:
    DEBUG_LEAVE(hr);
    return hr;

ConvertError:
    DL(SysFreeString)(*pbstr);
    *pbstr = NULL;
    goto Cleanup;
}

/*
 *  Ucs2ToWideChar
 *
 *  Purpose:
 *      Convert an ascii string to a BSTR for CP_UCS_2
 *
 *  Fail if:
 *      out of memory
 *
 *  Make sure:
 *      parameters are valid for this function
 *
 *  Only returns:
 *      ERROR_SUCCESS
 *      E_OUTOFMEMORY
 */
 
HRESULT
Ucs2ToWideChar(BSTR * pbstr, char * sz, int cch)
{
    DEBUG_ENTER((DBG_UTIL,
                 Dword,
                 "Utf8ToWideChar",
                 "sz=%#x, cch=%d",
                 sz, cch
                 ));

    HRESULT hr;
    
    INET_ASSERT(!(cch%2));
    
    int cwch = cch / sizeof(WCHAR);
    
    *pbstr = DL(SysAllocStringLen)(NULL, cwch); 

    if (!*pbstr)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    memcpy(*pbstr, sz, cwch*sizeof(WCHAR)); // 596411 don't copy potential odd trailing byte

    hr = NOERROR;

    DEBUG_DUMP(UTIL,
               "multibyte data:\n",
               (LPBYTE)sz,
               cch
               );

    DEBUG_DUMP(UTIL,
               "widechar data:\n",
               (LPBYTE)*pbstr,
               cwch*2
               );

Cleanup:
    DEBUG_LEAVE(hr);
    return hr;
}


/*
 *  MultiByteToWideCharInternal
 *
 *  Purpose:
 *      Convert an ascii string to a BSTR with a given codepage
 *      if *pMultiLanguage2 == NULL, this *might* cause to co-create it, and it's
 *      caller's responsibility to free the interface, if filled in, **regardless of error**
 *
 *  Fail if:
 *      out of memory
 *      codepage not available
 *      invalid character encountered
 *
 *
 *  Make sure:
 *      parameters are valid for this function
 *
 *  Only returns:
 *      ERROR_SUCCESS
 *      E_OUTOFMEMORY
 *      HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION) - CLSID_CMultiLanguage not available, or other error in conversion.
 */
 
HRESULT 
MultiByteToWideCharInternal(BSTR * pbstr, char * sz, int cch, UINT cp, IMultiLanguage2** pMultiLanguage2)
{
    DEBUG_ENTER((DBG_UTIL,
                 Dword,
                 "MultiByteToWideCharInternal",
                 "sz=%#x, cch=%d, cp=%d(%#x), IMultiLanguage2=%#x",
                 sz, cch, cp, cp, *pMultiLanguage2
                 ));

    HRESULT hr;
    
    if (!DelayLoad(&g_moduleOle32)
        || !DelayLoad(&g_moduleOleAut32))
    {
        return E_OUTOFMEMORY;
    }

    if (!cch || !sz)
    {
        *pbstr = DL(SysAllocStringLen)(NULL, 0);

        if (!*pbstr)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = ERROR_SUCCESS;
        }
    }
    else
    {
        switch (cp)
        {
            case CP_1252:
            case CP_ISO_8859_1:
            case CP_1250:
            case CP_1251:
            case CP_1253:
            case CP_1254:
            case CP_1257:
            {
                hr = MultiByteToWideCharGeneric(pbstr, sz, cch, cp);
            }
            break;
            case CP_UTF_8:
            {
                //call internal utf8 converter
                hr = Utf8ToWideChar(pbstr, sz, cch);
            }
            break;
            case CP_UCS_2:
            {
                //call internal UCS2 converter
                hr = Ucs2ToWideChar(pbstr, sz, cch);
            }
            break;
            default:
            {
                hr = MultiByteToWideCharWithMlang(pbstr, sz, cch, cp, pMultiLanguage2);
            }
        }
    }
    
    DEBUG_LEAVE(hr);
    return hr;
}

CMimeInfoCache::CMimeInfoCache(DWORD* pdwStatus)
{
    DEBUG_ENTER((DBG_UTIL,
                 Dword,
                 "CMimeInfoCache::CMimeInfoCache",
                 "this=%#x",
                 this
                 ));

    if (!InitializeSerializedList(&_MimeSetInfoCache))
    {
        *pdwStatus = ERROR_NOT_ENOUGH_MEMORY;
    }

    DEBUG_LEAVE(*pdwStatus);
}

CMimeInfoCache::~CMimeInfoCache()
{
    DEBUG_ENTER((DBG_UTIL,
                 None,
                 "CMimeInfoCache::~CMimeInfoCache",
                 "this=%#x, #elem=%d",
                 this, _MimeSetInfoCache.ElementCount
                 ));

    LPMIMEINFO_CACHE_ENTRY cacheEntry;
    LPMIMEINFO_CACHE_ENTRY previousEntry;
    
    if (LockSerializedList(&_MimeSetInfoCache))
    {
        previousEntry = (LPMIMEINFO_CACHE_ENTRY)SlSelf(&_MimeSetInfoCache);
        cacheEntry = (LPMIMEINFO_CACHE_ENTRY)HeadOfSerializedList(&_MimeSetInfoCache);
        
        while (cacheEntry != (LPMIMEINFO_CACHE_ENTRY)SlSelf(&_MimeSetInfoCache))
        {
            if (RemoveFromSerializedList(&_MimeSetInfoCache, &cacheEntry->ListEntry))
            {
                delete cacheEntry;
            }
            
            cacheEntry = (LPMIMEINFO_CACHE_ENTRY)previousEntry->ListEntry.Flink;
        }
        
        UnlockSerializedList(&_MimeSetInfoCache);
    }
    
    TerminateSerializedList(&_MimeSetInfoCache);

    DEBUG_LEAVE(0);
}

HRESULT
CMimeInfoCache::GetCharsetInfo(LPWSTR lpwszCharset, PMIMECSETINFO pMimeCSetInfo)
{
    DEBUG_ENTER((DBG_UTIL,
                 Dword,
                 "CMimeInfoCache::GetCharsetInfo",
                 "this=%#x, lpwszCharset=%.50wq",
                 this, lpwszCharset
                 ));

    HRESULT hr = E_FAIL;
    LPMIMEINFO_CACHE_ENTRY cacheEntry;
    
    if (!LockSerializedList(&_MimeSetInfoCache))
    {
        goto quit;
    }

    cacheEntry = (LPMIMEINFO_CACHE_ENTRY)HeadOfSerializedList(&_MimeSetInfoCache);

    while (cacheEntry != (LPMIMEINFO_CACHE_ENTRY)SlSelf(&_MimeSetInfoCache))
    {
        if (!StrCmpNIW(lpwszCharset, cacheEntry->MimeSetInfo.wszCharset, MAX_MIMECSET_NAME))
        {
            *pMimeCSetInfo = cacheEntry->MimeSetInfo;
            hr = NOERROR;
            break;
        }
        cacheEntry = (LPMIMEINFO_CACHE_ENTRY)cacheEntry->ListEntry.Flink;
    }

    UnlockSerializedList(&_MimeSetInfoCache);
    
quit:
    DEBUG_LEAVE(hr);
    return hr;
}

void
CMimeInfoCache::AddCharsetInfo(PMIMECSETINFO pMimeCSetInfo)
{
    DEBUG_ENTER((DBG_UTIL,
                 None,
                 "CMimeInfoCache::AddCharsetInfo",
                 "this=%#x, uiCodePage=%d(%#x), uiInternetEncoding=%d(%#x), lpwszCharset=%.50wq",
                 this, pMimeCSetInfo->uiCodePage, pMimeCSetInfo->uiCodePage, pMimeCSetInfo->uiInternetEncoding, pMimeCSetInfo->uiInternetEncoding, pMimeCSetInfo->wszCharset
                 ));

    LPMIMEINFO_CACHE_ENTRY cacheEntry;

    if (!LockSerializedList(&_MimeSetInfoCache))
    {
        goto quit;
    }
    
    cacheEntry = (LPMIMEINFO_CACHE_ENTRY)HeadOfSerializedList(&_MimeSetInfoCache);

    while (cacheEntry != (LPMIMEINFO_CACHE_ENTRY)SlSelf(&_MimeSetInfoCache))
    {
        if ((pMimeCSetInfo->uiCodePage == cacheEntry->MimeSetInfo.uiCodePage)
            &&  (pMimeCSetInfo->uiInternetEncoding == cacheEntry->MimeSetInfo.uiInternetEncoding)
            &&  !StrCmpNIW(pMimeCSetInfo->wszCharset, cacheEntry->MimeSetInfo.wszCharset, MAX_MIMECSET_NAME))
        {
            goto unlock;
        }
        cacheEntry = (LPMIMEINFO_CACHE_ENTRY)cacheEntry->ListEntry.Flink;
    }
    
    LPMIMEINFO_CACHE_ENTRY pCacheEntry = new MIMEINFO_CACHE_ENTRY;

    if (pCacheEntry)
    {
        memcpy(&(pCacheEntry->MimeSetInfo), pMimeCSetInfo, sizeof(MIMECSETINFO));

        if (!InsertAtHeadOfSerializedList(&_MimeSetInfoCache, &pCacheEntry->ListEntry))
        {
            delete pCacheEntry;
        }
    }

unlock:
    UnlockSerializedList(&_MimeSetInfoCache);
    
quit:
    DEBUG_LEAVE(0);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\parsers.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    parsers.cxx

Abstract:

    Common text parsing functions (generally moved here from other protocols)

    Contents:
        ExtractWord
        ExtractDword
        ExtractInt
        SkipWhitespace
        SkipSpaces
        SkipLine
        FindToken
        NiceNum

Author:

    Richard L Firth (rfirth) 03-Jul-1996

Revision History:

    03-Jul-1996 rfirth
        Created

--*/

#include <wininetp.h>

//
// functions
//


BOOL
ExtractWord(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPWORD pConvertedNumber
    )

/*++

Routine Description:

    pulls a <NumberLength> character number out of a string.

    Assumes:    1. The number to be converted is an unsigned short
                2. A whole number is contained within *pString

Arguments:

    pString             - pointer to pointer to string from which to get number

    NumberLength        - number of characters that comprise number string, if
                          not equal to 0, else if 0, we don't know the length
                          of the number string a priori

    pConvertedNumber    - pointer to variable where converted number written

Return Value:

    BOOL
        TRUE    - number converted OK

        FALSE   - one of the characters in the number is not a digit

--*/

{
    WORD number;
    BOOL exact;
    LPSTR string;

    //
    // if the caller doesn't know how many characters comprise the number, then
    // we will convert until the next non-digit character, or until we have
    // converted the maximum number of digits that can comprise an unsigned
    // short value
    //

    if (NumberLength == 0) {
        NumberLength = sizeof("65535") - 1;
        exact = FALSE;
    } else {
        exact = TRUE;
    }
    number = 0;
    string = *pString;
    while (NumberLength && isdigit(*string)) {
        number = number * 10 + (WORD)((BYTE)(*string++) - (BYTE)'0');
        --NumberLength;
    }
    *pConvertedNumber = number;
    *pString = string;

    //
    // if we were asked to convert a certain number of characters but failed
    // because we hit a non-digit character, then return FALSE. Anything else
    // (we converted required number of characters, or the caller didn't know
    // how many characters comprised the number) is TRUE
    //

    return (exact && (NumberLength != 0)) ? FALSE : TRUE;
}


BOOL
ExtractDword(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPDWORD pConvertedNumber
    )

/*++

Routine Description:

    pulls a <NumberLength> character number out of a string.

    Assumes:    1. The number to be converted is an unsigned long
                2. A whole number is contained within *pString

Arguments:

    pString             - pointer to pointer to string from which to get number

    NumberLength        - number of characters that comprise number string, if
                          not equal to 0, else if 0, we don't know the length
                          of the number string a priori

    pConvertedNumber    - pointer to variable where converted number written

Return Value:

    BOOL
        TRUE    - number converted OK

        FALSE   - one of the characters in the number is not a digit

--*/

{
    DWORD number;
    BOOL exact;

    //
    // if the caller doesn't know how many characters comprise the number, then
    // we will convert until the next non-digit character, or until we have
    // converted the maximum number of digits that can comprise an unsigned
    // short value
    //

    if (NumberLength == 0) {
        NumberLength = sizeof("4294967295") - 1;
        exact = FALSE;
    } else {
        exact = TRUE;
    }
    for (number = 0; isdigit(**pString) && NumberLength--; ) {
        number = number * 10 + (DWORD)((BYTE)*((*pString)++) - (BYTE)'0');
    }
    *pConvertedNumber = number;

    //
    // if we were asked to convert a certain number of characters but failed
    // because we hit a non-digit character, then return FALSE. Anything else
    // (we converted required number of characters, or the caller didn't know
    // how many characters comprised the number) is TRUE
    //

    return (exact && (NumberLength != 0)) ? FALSE : TRUE;
}


BOOL
ExtractInt(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPINT pConvertedNumber
    )

/*++

Routine Description:

    pulls a <NumberLength> character number out of a string.

    Assumes:    1. The number to be converted is an signed integer (32-bits)

Arguments:

    pString             - pointer to pointer to string from which to get number

    NumberLength        - number of characters that comprise number string, if
                          not equal to 0, else if 0, we don't know the length
                          of the number string a priori

    pConvertedNumber    - pointer to variable where converted number written

Return Value:

    BOOL
        TRUE    - number converted OK

        FALSE   - one of the characters in the number is not a digit

--*/

{
    int number;
    int sign;
    BOOL exact;

    if ((**pString == '-') || (**pString == '+')) {
        sign = (**pString == '-') ? -1 : +1;
        if (NumberLength) {
            --NumberLength;
        }
        ++*pString;
    } else {
        sign = 1;
    }

    //
    // if the caller doesn't know how many characters comprise the number, then
    // we will convert until the next non-digit character, or until we have
    // converted the maximum number of digits that can comprise an unsigned
    // short value
    //

    if (NumberLength == 0) {
        NumberLength = sizeof("2147483647") - 1;
        exact = FALSE;
    } else {
        exact = TRUE;
    }
    for (number = 0; isdigit(**pString) && NumberLength; ) {
        number = number * 10 + (INT)(((BYTE)**pString) - (BYTE)'0');
        ++*pString;
        --NumberLength;
    }
    *pConvertedNumber = number * sign;

    //
    // if we were asked to convert a certain number of characters but failed
    // because we hit a non-digit character, then return FALSE. Anything else
    // (we converted required number of characters, or the caller didn't know
    // how many characters comprised the number) is TRUE
    //

    return (exact && (NumberLength != 0)) ? FALSE : TRUE;
}


BOOL
SkipWhitespace(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Skips any whitespace characters

Arguments:

    lpBuffer        - pointer to pointer to buffer

    lpBufferLength  - pointer to remaining buffer length

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. No more data left in buffer

--*/

{
    while ((*lpBufferLength != 0) && isspace(**lpBuffer)) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


BOOL
SkipSpaces(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Skips any space characters. We only look for the actual space character

Arguments:

    lpBuffer        - pointer to pointer to buffer

    lpBufferLength  - pointer to remaining buffer length

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. No more data left in buffer

--*/

{
    while ((*lpBufferLength != 0) && (**lpBuffer == ' ')) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


BOOL
SkipLine(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Positions text pointer at start of next non-empty line

Arguments:

    lpBuffer        - pointer to string. Updated on output

    lpBufferLength  - pointer to remaining length of string. Updated on output

Return Value:

    BOOL
        TRUE    - found start of next non-empty line

        FALSE   - ran out of buffer

--*/

{
    while ((*lpBufferLength != 0) && (**lpBuffer != '\r') && (**lpBuffer != '\n')) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    while ((*lpBufferLength != 0) && ((**lpBuffer == '\r') || (**lpBuffer == '\n'))) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


#undef  isspace
#define isspace(ch) ((ch==0x20) || ((ch >= 0x09) && (ch <= 0x0d)))

BOOL
FindToken(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Moves over the current token, past any spaces, and to the start of the next
    token

Arguments:

    lpBuffer        - pointer to pointer to buffer

    lpBufferLength  - pointer to remaining buffer length

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. No more data left in buffer

--*/

{
    while ((*lpBufferLength != 0) && !isspace(**lpBuffer)) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    while ((*lpBufferLength != 0) && isspace(**lpBuffer)) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


LPSTR
NiceNum(
    OUT LPSTR Buffer,
    IN SIZE_T Number,
    IN int FieldWidth
    )

/*++

Routine Description:

    Converts a number to a string. The string is very human-sensible (i.e.
    1,234,567 instead of 1234567. Sometimes its hard to make out these numbers
    when your salary is so large)

Arguments:

    Buffer      - place to put resultant string

    Number      - to convert

    FieldWidth  - maximum width of the field, or 0 for "don't care"

Return Value:

    LPSTR
        pointer to Buffer

--*/

{
    int i;

    if (Number == 0) {
        if (FieldWidth == 0) {
            Buffer[0] = '0';
            Buffer[1] = '\0';
        } else {
            memset(Buffer, ' ', FieldWidth);
            Buffer[FieldWidth - 1] = '0';
            Buffer[FieldWidth] = '\0';
        }
    } else {

        //
        // if the caller specified zero for the field width then work out how
        // many characters the string will occupy
        //

        if (FieldWidth == 0) {

            SIZE_T n;

            n = Number;
            ++FieldWidth;
            while (n >= 10) {
                n /= 10;
                ++FieldWidth;
            }

            FieldWidth += (FieldWidth / 3) - (((FieldWidth % 3) == 0) ? 1 : 0);
        }

        //
        // now create the representation
        //

        Buffer[FieldWidth] = '\0';
        Buffer += FieldWidth;
        i = 0;
        while (Number && FieldWidth) {
            *--Buffer = (char)((Number % 10) + '0');
            --FieldWidth;
            Number /= 10;
            if ((++i == 3) && FieldWidth) {
                if (Number) {
                    *--Buffer = ',';
                    --FieldWidth;
                    i = 0;
                }
            }
        }
        while (FieldWidth--) {
            *--Buffer = ' ';
        }
    }
    return Buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\icstring.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    icstring.hxx

Abstract:

    Contains ICSTRING class methods. Split from ICSTRING.HXX (inline methods)

    Contents:
        ICSTRING::ICSTRING(ICSTRING&)
        ICSTRING::~ICSTRING()
        ICSTRING::operator=(LPSTR)
        ICSTRING::operator=(ICSTRING&)
        ICSTRING::operator+=(LPSTR)
        ICSTRING::operator+=(char)
        ICSTRING::strncat(LPVOID, DWORD)
        ICSTRING::CreateStringBuffer(LPVOID, DWORD, DWORD)
        ICSTRING::CreateOffsetString(DWORD, DWORD)
        ICSTRING::CopyTo(LPSTR)
        ICSTRING::CopyTo(LPSTR, LPSTR)
        ICSTRING::CopyTo(LPSTR, DWORD)
        ICSTRING::CopyTo(LPSTR, LPDWORD)

Author:

    Richard L Firth (rfirth) 18-Dec-1995

Revision History:

    18-Dec-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include <crypt.h>

//
// methods
//

//
//ICSTRING::ICSTRING(
//    IN ICSTRING& String
//    )
//
///*++
//
//Routine Description:
//
//    copy constructor. We now create an entirely new string (used to be just a
//    reference of the rvalue)
//
//Arguments:
//
//    String  - to copy
//
//Return Value:
//
//    None.
//
//--*/
//
//{
//    //
//    // can't already have string in lvalue, & rvalue mustn't be an offset string
//    //
//
//    INET_ASSERT(!HaveString());
//    INET_ASSERT(!String.IsOffset());
//    INET_ASSERT(!String.IsError());
//
//    *this = String.StringAddress();
//}


ICSTRING::~ICSTRING(
    VOID
    )

/*++

Routine Description:

    destructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // can only free the string if it is not a reference. Offset type
    // implies reference
    //

    if (!IsReference() && (_String != NULL)) {

        INET_ASSERT(!IsOffset());

        (VOID)ResizeBuffer((HLOCAL)_String, 0, FALSE);
    }
}


ICSTRING&
ICSTRING::operator=(
    IN LPSTR String
    )

/*++

Routine Description:

    Copy/assigment. Copies a string to this object. If NULL, frees up the
    current buffer

Arguments:

    String  - to be assigned

Return Value:

    ICSTRING&

--*/

{
    //
    // if this is an offset string then there's not much to do
    //

    if (IsOffset()) {
        Initialize();
        return *this;
    }

    //
    // string MUST NOT be a copy (we'll free the real string pointer, owned
    // by another object) and SHOULD NOT be copied itself (the objects with
    // copies of the string will potentially have a bad pointer)
    //

    INET_ASSERT((String == NULL) ? TRUE : !IsReference());
    INET_ASSERT(!IsReferenced());

    //
    // if the pointer is NULL or the string is empty then we are freeing the
    // string pointer
    //

    DWORD len;

    if (String == NULL) {
        len = 0;
    } else {
        len = ::strlen(String);
        if (len != 0) {
            INET_ASSERT(len < 0xffffffff);
            ++len;
        }
    }

    //
    // free or grow the buffer, depending on requirements
    //

    if ((len > _BufferLength) || ((len == 0) && (_String != NULL))) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, len, FALSE);
        _BufferLength = (_String != NULL) ? len : 0;
    }
    if (_String != NULL && String != NULL) {

        INET_ASSERT(len != 0);

        memcpy((LPVOID)_String, (LPVOID)String, len);
        _StringLength = len - 1;
        SetHaveString(TRUE);
        SetError(FALSE);
    } else {
        _StringLength = 0;
        SetHaveString(FALSE);
        SetError(len != 0); // an error might have occurred
    }
    return *this;
}


ICSTRING&
ICSTRING::operator=(
    IN ICSTRING& String
    )

/*++

Routine Description:

    Copy/assignment. Makes new copy of object (used to just make a reference)

Arguments:

    String  - ICSTRING object to be assigned

Return Value:

    ICSTRING&

--*/

{
    INET_ASSERT(!IsReferenced());
    INET_ASSERT(!String.IsReferenced());
    INET_ASSERT(!String.IsError());

    //
    // if we're copying an offset, make sure that any string we may already
    // have is freed
    //

    if (String.IsOffset()) {
        if (_String != NULL) {
            ResizeBuffer(_String, 0, FALSE);
        }
        _String = String._String;
        _StringLength = String._StringLength;
        _BufferLength = String._BufferLength;
        _Union.Dword = String._Union.Dword;
    } else {

        INET_ASSERT(!IsOffset() && !String.IsOffset());

        //
        // use string assignment to correctly setup this object
        //

        *this = String.StringAddress();
    }
    return *this;
}


VOID
ICSTRING::operator+=(
    IN LPSTR String
    )

/*++

Routine Description:

    Concatenates a string to the buffer. Reallocates it if necessary. String
    CANNOT be NULL

Arguments:

    String  - to concatenate

Return Value:

    None.

--*/

{
    INET_ASSERT(!IsReference());
    INET_ASSERT(!IsReferenced());
    INET_ASSERT(!IsOffset());
    INET_ASSERT(String != NULL);

    if (IsError()) {
        return;
    }

    if (*String == '\0') {
        return;
    }

    DWORD len = ::strlen(String);
    DWORD newlen = _StringLength + len + 1;

    INET_ASSERT ((newlen > _StringLength) && (newlen > len));

    if (_BufferLength < newlen) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, newlen, FALSE);

        INET_ASSERT((_String == NULL) ? (newlen == 0) : TRUE);

        _BufferLength = newlen;
    }
    if (_String != NULL) {
        memcpy((LPVOID)((LPBYTE)_String + _StringLength),
               (LPVOID)String,
               len + 1
               );
        _StringLength += len;
    } else {
        _StringLength = 0;
        _BufferLength = 0;
        SetError(TRUE);
    }
}


VOID
ICSTRING::operator+=(
    IN char Ch
    )

/*++

Routine Description:

    Concatenates a character to the buffer. Reallocates it if necessary. Ch
    CAN be '\0'

Arguments:

    Ch  - to concatenate

Return Value:

    None.

--*/

{
    INET_ASSERT(!IsReference());
    INET_ASSERT(!IsReferenced());
    INET_ASSERT(!IsOffset());

    if (IsError()) {
        return;
    }

    DWORD newlen = _StringLength + 2;

    INET_ASSERT (newlen > _StringLength);
    
    if (_BufferLength < newlen) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, newlen, FALSE);

        INET_ASSERT((_String == NULL) ? (newlen == 0) : TRUE);

        _BufferLength = newlen;
    }
    if (_String != NULL) {
        _String[_StringLength] = Ch;
        ++_StringLength;
        _String[_StringLength] = '\0';
    } else {
        _StringLength = 0;
        _BufferLength = 0;
        SetError(TRUE);
    }
}


VOID
ICSTRING::Strncat(
    IN LPVOID Pointer,
    IN DWORD Length
    )

/*++

Routine Description:

    Copies Length characters from Pointer to the end of _String

Arguments:

    Pointer - place to copy from

    Length  - number of characters to copy

Return Value:

    None.

--*/

{
    if (IsError()) {
        return;
    }

    INET_ASSERT(Pointer != NULL);
    INET_ASSERT(Length != 0);
    INET_ASSERT(_String != NULL);
    INET_ASSERT(!IsReference());
    INET_ASSERT(!IsReferenced());

    DWORD newLength;

    newLength = _StringLength + Length + 1;

    INET_ASSERT ((newLength > _StringLength) && (newLength > Length));
    
    if (_BufferLength < newLength) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, newLength, FALSE);
        _BufferLength = newLength;
    }
    if (_String != NULL) {
        memcpy((LPVOID)&_String[_StringLength], Pointer, Length);
        _StringLength += Length;

        INET_ASSERT(_StringLength < _BufferLength);

        _String[_StringLength] = '\0';
    } else {
        _StringLength = 0;
        _BufferLength = 0;
        SetError(TRUE);
    }
}


VOID
ICSTRING::CreateStringBuffer(
    IN LPVOID Pointer,
    IN DWORD StringLength,
    IN DWORD BufferLength
    )

/*++

Routine Description:

    In order to avoid reallocations, if we know the size of the buffer we
    want for several strcat()'s, e.g., we can allocate it once, copy the
    initial string here, then perform multiple concatenate operations (+=)

Arguments:

    Pointer         - place to start copying from

    StringLength    - length of string

    BufferLength    - length of buffer required

Return Value:

    None.

--*/

{
    INET_ASSERT(Pointer != NULL);
    INET_ASSERT(BufferLength > StringLength);
    INET_ASSERT(BufferLength != 0);

    //
    // if we currently have an offset string then initialize to a non-offset
    //

    if (IsOffset()) {
        Initialize();
    }
    _String = (LPSTR)ResizeBuffer(_String, BufferLength, FALSE);
    if (_String != NULL) {
        _StringLength = StringLength;
        _BufferLength = BufferLength;
        memcpy((LPVOID)_String, Pointer, _StringLength);
        _String[_StringLength] = '\0';
        SetHaveString(TRUE);
        SetReference(FALSE);
        SetReferenced(FALSE);
        SetOffset(FALSE);
        SetError(FALSE);
    } else {
        SetError(TRUE);
    }
}


VOID
ICSTRING::CreateOffsetString(
    IN DWORD Offset,
    IN DWORD Length
    )

/*++

Routine Description:

    Create a reference ICSTRING that is an offset within another buffer

Arguments:

    Offset  - offset into buffer

    Length  - of string

Return Value:

    None.

--*/

{
    _String = (LPSTR)(DWORD_PTR)Offset;
    _StringLength = Length;
    _BufferLength = Length;
    ZapFlags();
    SetHaveString(TRUE);    // ICSTRING initialized with non-NULL
    SetReference(TRUE);     // reference to another string buffer
    SetOffset(TRUE);        // offset from base
    SetError(FALSE);
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Buffer
    )

/*++

Routine Description:

    Copies source _String to destination Buffer

Arguments:

    Buffer  - place to copy to

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    INET_ASSERT(!IsOffset());

    memcpy((LPVOID)Buffer, (LPVOID)_String, _StringLength);
    Buffer[_StringLength] = '\0';
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Base,
    IN LPSTR Buffer
    )

/*++

Routine Description:

    Copies a based (offset) string from source Base + _String to destination
    Buffer

Arguments:

    Base    - value for base

    Buffer  - place to write string

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    //INET_ASSERT(IsOffset() ? (Base != NULL) : (Base == NULL));

    memcpy((LPVOID)Buffer,
           IsOffset() ? (Base + (DWORD_PTR)_String) : _String,
           _StringLength
           );
    Buffer[_StringLength] = '\0';
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Buffer,
    IN DWORD Length
    )

/*++

Routine Description:

    Copies at most Length characters from source _String to destination
    Buffer

Arguments:

    Buffer  - place to write string

    Length  - number of characters to copy

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    INET_ASSERT(!IsOffset());

    DWORD length = min(Length - 1, _StringLength);

    memcpy((LPVOID)Buffer, (LPVOID)_String, length);
    Buffer[length] = '\0';
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Buffer,
    IN OUT LPDWORD Length
    )

/*++

Routine Description:

    Copies at most *Length characters from source _String to destination
    Buffer. Updates *Length to be number of characters copied, not including
    terminating NUL

Arguments:

    Buffer  - place to write string

    Length  - IN: length of buffer
              OUT: number of characters copied

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    INET_ASSERT(!IsOffset());

    DWORD length = min(*Length - 1, _StringLength);

    memcpy((LPVOID)Buffer, (LPVOID)_String, length);
    Buffer[length] = '\0';
    *Length = length;
}



NTSTATUS
(WINAPI * _I_EncryptMemory)(
    IN OUT  PVOID Memory,
    IN      ULONG MemoryLength,
    IN      ULONG OptionFlags
    );

NTSTATUS
(WINAPI * _I_DecryptMemory)(
    IN OUT  PVOID Memory,
    IN      ULONG MemoryLength,
    IN      ULONG OptionFlags
    );


PRIVATE DLL_ENTRY_POINT AdvApi32EntryPoints[] = {
    {"SystemFunction040", (FARPROC *)&_I_EncryptMemory},
    {"SystemFunction041", (FARPROC *)&_I_DecryptMemory}
};

PRIVATE DLL_INFO AdvApi32DllInfo = DLL_INFO_INIT("ADVAPI32.DLL", AdvApi32EntryPoints);


void XStringInitialize()
{
    LoadDllEntryPoints(&AdvApi32DllInfo, 0);

    INET_ASSERT((_I_EncryptMemory && _I_DecryptMemory) || (NULL==_I_EncryptMemory && NULL==_I_DecryptMemory));
}

void XStringUninitialize()
{
    UnloadDllEntryPoints(&AdvApi32DllInfo, FALSE);
}


LPSTR XSTRING::GetUnencryptedString()
{
    if (NULL == _lpsz)
        return NULL;

    LPSTR lpszUnencryptedString = (LPSTR)ALLOCATE_FIXED_MEMORY(_stringLength);
    
    if (lpszUnencryptedString != NULL)
    {
        memcpy(lpszUnencryptedString, _lpsz, _stringLength);

        if (_fEncryptString)
        {
            INET_ASSERT(_stringLength % 8 == 0);
            INET_ASSERT(_I_DecryptMemory != NULL);

            _I_DecryptMemory(lpszUnencryptedString, _stringLength, 0);
        }
    }

    return lpszUnencryptedString;
}


BOOL XSTRING::SetData(LPCSTR lpszIn)
{
    INET_ASSERT(lpszIn != NULL);

    if (_fEncryptString && _I_EncryptMemory)
    {
        DWORD dwLen = 0;
        DWORD dwStrLen = (strlen(lpszIn) + 1);
        LPSTR lpszTemp;

        dwLen = dwStrLen + (RTL_ENCRYPT_MEMORY_SIZE - dwStrLen % RTL_ENCRYPT_MEMORY_SIZE);

        lpszTemp = (LPSTR) ALLOCATE_FIXED_MEMORY(dwLen + 1);

        if (!lpszTemp)
            return FALSE;

        memcpy(lpszTemp, lpszIn, dwStrLen);

        NTSTATUS status = _I_EncryptMemory(lpszTemp, dwLen, 0);
        
        if (! NT_SUCCESS(status))
        {
            _fEncryptString = FALSE;
            memcpy(lpszTemp, lpszIn, dwStrLen);
            dwLen = dwStrLen;
        }

        Free();  // release current buffer if it exists

        _lpsz         = lpszTemp;
        _stringLength = dwLen;
        return TRUE;
    }
    else
    {
        // Make a copy of the data passed in.

        LPSTR lpszTemp = NewString(lpszIn);
        if (!lpszTemp)
            return FALSE;

        Free();  // release current buffer if it exists

        _lpsz           = lpszTemp;
        _stringLength   = strlen(_lpsz) + 1;
        _fEncryptString = FALSE;
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\rescache.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rescache.cxx

Abstract:

    Contains functions which manipulate resolver cache for winsock
    name resolution calls

    Contents:
        QueryResolverCache
        AddResolverCacheEntry
        FlushResolverCache
        ReleaseResolverCacheEntry
        (RemoveCacheEntry)
        (ResolverCacheHit)
        (AddrInfoMatch)
        (CreateCacheEntry)

Author:

    Richard L Firth (rfirth) 10-Jul-1994

Environment:

    Win-16/32 user level

Revision History:

    rfirth 10-Jul-1994
        Created

--*/

//
// includes
//

#include "wininetp.h"

//
// private manifests
//

//
// private macros
//

#define SET_EXPIRATION_TIME(cacheEntry)

//
// private data
//

PRIVATE BOOL ResolverCacheInitialized = FALSE;

//
// DnsCachingEnabled - caching is enabled by default
//

PRIVATE BOOL DnsCachingEnabled = TRUE;

//
// DnsCacheTimeout - number of seconds before a cache entry expires. This value
// is added to the current time (in seconds) to get the expiry time
//

PRIVATE DWORD DnsCacheTimeout = DEFAULT_DNS_CACHE_TIMEOUT;

//
// MaximumDnsCacheEntries - the maximum number of RESOLVER_CACHE_ENTRYs in the
// cache before we start throwing out the LRU
//

PRIVATE LONG MaximumDnsCacheEntries = DEFAULT_DNS_CACHE_ENTRIES;

//
// ResolverCache - serialized list of RESOLVER_CACHE_ENTRYs, kept in MRU order.
// We only need to remove the tail of the list to remove the LRU entry
//

//
// private prototypes
//

PRIVATE
VOID
RemoveCacheEntry(
    IN SERIALIZED_LIST* pResolverCache,
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry
    );

PRIVATE
BOOL
ResolverCacheHit(
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry,
    IN LPSTR Name OPTIONAL,
    IN LPSOCKADDR Address OPTIONAL
    );

PRIVATE
BOOL
AddrInfoMatch(
    IN LPADDRINFO AddrInfo,
    IN LPSTR Name OPTIONAL,
    IN LPSOCKADDR Address OPTIONAL
    );

PRIVATE
LPRESOLVER_CACHE_ENTRY
CreateCacheEntry(
    IN LPSTR lpszHostName,
    IN LPADDRINFO AddrInfo,
    IN DWORD TimeToLive,
    IN VOID** pAlloc=NULL,
    IN DWORD dwAllocSize=0
    );

#if INET_DEBUG

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheTimestr(
    IN DWORD Time
    );

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheAddrInfoStr(
    IN LPADDRINFO AddrInfo
    );

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheMapSockAddress(
    IN LPSOCKADDR Address
    );

#endif

//
// functions
//


LPRESOLVER_CACHE_ENTRY
QueryResolverCache(
    SERIALIZED_LIST* pResolverCache,
    IN LPSTR Name OPTIONAL,
    IN LPSOCKADDR Address OPTIONAL,
    OUT LPADDRINFO * AddrInfo,
    OUT LPDWORD TimeToLive
    )

/*++

Routine Description:

    Checks if Name is stored in the last resolved name cache. If the entry is
    found, but has expired then it is removed from the cache

Arguments:

    Name        - pointer to name string

    Address     - pointer to IP address (in sockaddr format)

    AddrInfo    - pointer to returned pointer to addrinfo

    TimeToLive  - pointer to returned time to live

Return Value:

    BOOL

--*/

{
    UNREFERENCED_PARAMETER(TimeToLive);
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "QueryResolverCache",
                 "%q, %A, %#x, %#x",
                 Name,
                 Address,
                 AddrInfo,
                 TimeToLive
                 ));

    LPRESOLVER_CACHE_ENTRY lpEntry = NULL;

    if (!DnsCachingEnabled || !LockSerializedList(pResolverCache))
    {
        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("DNS caching disabled or unable to serialize access\n"
                    ));

        *AddrInfo = NULL;
        lpEntry = NULL;
        goto quit;
    }

    LPRESOLVER_CACHE_ENTRY cacheEntry;
    LPRESOLVER_CACHE_ENTRY previousEntry;
    DWORD timeNow;

    cacheEntry = (LPRESOLVER_CACHE_ENTRY)HeadOfSerializedList(pResolverCache);
    timeNow = (DWORD)time(NULL);

    while (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(pResolverCache)) {

        //
        // on every cache lookup, purge any stale entries. LIVE_FOREVER means
        // that we don't expect the entry's net address to expire, but it
        // DOESN'T mean that we can't throw out the entry if its the LRU and
        // we're at maximum cache capacity. We can't do this if the item is
        // still in-use. In this case, we mark it stale
        //

        if ((cacheEntry->ExpirationTime != LIVE_FOREVER)
        && (cacheEntry->ExpirationTime <= timeNow)) {

            //
            // if reference count not zero then another thread is using
            // this entry - mark as stale else delete it
            //

            if (cacheEntry->ReferenceCount != 0) {

                INET_ASSERT(cacheEntry->State == ENTRY_IN_USE);

                cacheEntry->State = ENTRY_DELETE;
            } else {

                //
                // this entry is stale; throw it out
                // "my hovercraft is full of eels"
                //

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("throwing out stale DNS entry %q, expiry = %s\n",
                            cacheEntry->AddrInfo->ai_canonname,
                            CacheTimestr(cacheEntry->ExpirationTime)
                            ));

                //
                // BUGBUG - what happens if ExpirationTime == timeNow?
                //

                previousEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Blink;
                RemoveCacheEntry(pResolverCache, cacheEntry);
                cacheEntry = previousEntry;
            }
        } 
        else if (ResolverCacheHit(cacheEntry, Name, Address)
        && ((cacheEntry->State == ENTRY_UNUSED)
        || (cacheEntry->State == ENTRY_IN_USE))) {

            //
            // we found the entry, and it still has time to live. Make it the
            // head of the list (MRU first), set the state to in-use and increase
            // the reference count
            //

            if (RemoveFromSerializedList(pResolverCache, &cacheEntry->ListEntry))
            {
                if (InsertAtHeadOfSerializedList(pResolverCache, &cacheEntry->ListEntry))
                {
                    cacheEntry->State = ENTRY_IN_USE;
                    ++cacheEntry->ReferenceCount;
                    *AddrInfo = cacheEntry->AddrInfo;
                    lpEntry = cacheEntry;


                    DEBUG_PRINT(SOCKETS,
                                INFO,
                                ("entry found in DNS cache\n"
                                ));
                }
                else
                {
                    DEBUG_PRINT(SOCKETS,
                                INFO,
                                ("entry found in DNS cache, but removed due to not enough memory\n"
                                ));
                }
            }

            goto done;
        }
        cacheEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Flink;
    }

    *AddrInfo = NULL;
    lpEntry = NULL;

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("didn't find entry in DNS cache\n"
                ));

done:

    UnlockSerializedList(pResolverCache);

quit:

    DEBUG_LEAVE(lpEntry);
    return lpEntry;
}


VOID
AddResolverCacheEntry(
    SERIALIZED_LIST* pResolverCache,
    IN LPSTR lpszHostName,
    IN LPADDRINFO AddrInfo,
    IN DWORD TimeToLive,
    IN VOID** pAlloc,
    IN DWORD dwAllocSize
    )

/*++

Routine Description:

    Adds an addrinfo pointer to the cache. Creates a new entry to hold it
    and links it into the cache list, displacing the LRU entry if required.
    If we cannot create the entry, the addrinfo is freed, no errors returned

    N.B.: Calling this routine gives the resolver cache "ownership" of the
    addrinfo chain. Caller should not use AddrInfo pointer afterwards.

Arguments:

    lpszHostName    - the name we originally requested be resolved. May be
                      different than the names returned by the resolver, e.g.
                      "proxy" => "proxy1.microsoft.com, proxy2.microsoft.com"

    AddrInfo        - pointer to addrinfo chain to add to the cache

    TimeToLive      - amount of time this information has to live. Can be:

                        LIVE_FOREVER    - don't timeout (but can be discarded)

                        LIVE_DEFAULT    - use the default value

                        anything else   - number of seconds to live

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "AddResolverCacheEntry",
                 "%q, %#x, %d",
                 lpszHostName,
                 AddrInfo,
                 TimeToLive
                 ));

    BOOL bAdded = FALSE;

    if (!DnsCachingEnabled || !LockSerializedList(pResolverCache))
    {
        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("DNS caching disabled or unable to serialize access\n"
                    ));

        goto quit;
    }

    //
    // check that the entry is not already in the cache - 2 or more threads may
    // have been simultaneously resolving the same name
    //

    LPADDRINFO lpAddrInfo;
    DWORD ttl;
    LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry;

    INET_ASSERT(lpszHostName != NULL);

    if (NULL == (lpResolverCacheEntry=QueryResolverCache(pResolverCache, lpszHostName, NULL, &lpAddrInfo, &ttl))) {

        LPRESOLVER_CACHE_ENTRY cacheEntry;

        //
        // remove as many entries as we can beginning at the tail of the list.
        // We try to remove enough to get the cache size back below the limit.
        // This may consist of removing expired entries or entries marked as
        // DELETE. If there are expired, in-use entries then we mark them as
        // DELETE. This may result in the cache list growing until those threads
        // which have referenced cache entries release them
        //

        cacheEntry = (LPRESOLVER_CACHE_ENTRY)TailOfSerializedList(pResolverCache);

        while ((pResolverCache->ElementCount >= MaximumDnsCacheEntries)
        && (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(pResolverCache))) {

            //
            // cache has maximum entries: throw out the Least Recently Used (its
            // the one at the back of the queue, ma'am) but only if no-one else
            // is currently accessing it
            //

            if ((cacheEntry->State != ENTRY_IN_USE)
            && (cacheEntry->ReferenceCount == 0)) {

                INET_ASSERT((cacheEntry->State == ENTRY_UNUSED)
                            || (cacheEntry->State == ENTRY_DELETE));

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("throwing out LRU %q\n",
                            cacheEntry->AddrInfo->ai_canonname
                            ));

                LPRESOLVER_CACHE_ENTRY nextEntry;

                nextEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Flink;
                RemoveCacheEntry(pResolverCache, cacheEntry);
                cacheEntry = nextEntry;
            } else if (cacheEntry->State == ENTRY_IN_USE) {

                //
                // this entry needs to be freed when it is released
                //

                cacheEntry->State = ENTRY_DELETE;
            }
            cacheEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Blink;
        }

        //
        // add the entry at the head of the queue - it is the Most Recently Used
        // after all. If we fail to allocate memory, its no problem: it'll just
        // take a little longer if this entry would have been hit before we needed
        // to throw out another entry
        //

        if (NULL != (cacheEntry = CreateCacheEntry(lpszHostName, AddrInfo, TimeToLive, pAlloc, dwAllocSize))) {

#if INET_DEBUG
            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("caching %s, expiry = %s\n",
                        cacheEntry->HostName,
                        CacheTimestr(cacheEntry->ExpirationTime)
                        ));
            LPADDRINFO TmpAddrInfo = AddrInfo;
            while (TmpAddrInfo) {
                DEBUG_PRINT(SOCKETS,
                            INFO,
                           ("  address %A\n", 
                           TmpAddrInfo->ai_addr
                           ));
                TmpAddrInfo = TmpAddrInfo->ai_next;
            }
#endif

            if (!InsertAtHeadOfSerializedList(pResolverCache, &cacheEntry->ListEntry))
            {
                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("Unable to cache new entry due to not enough memory\n"
                            ));
                cacheEntry = (LPRESOLVER_CACHE_ENTRY)FREE_MEMORY((HLOCAL)cacheEntry);

                INET_ASSERT(cacheEntry == NULL);

            }
            else
            {
                bAdded = TRUE;
            }
        }
    } else {

        //
        // this entry is already in the cache. 2 or more threads must have been
        // resolving the same name simultaneously. We just bump the expiration
        // time to the more recent value
        //

        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("found %q already in the cache!?\n",
                    lpszHostName
                    ));

        ReleaseResolverCacheEntry(pResolverCache, lpResolverCacheEntry);

    }

    UnlockSerializedList(pResolverCache);

quit:

    if (!bAdded) {
        //
        // failed to add this entry to the cache, so free it
        //
        _I_freeaddrinfo(AddrInfo);
    }

    DEBUG_LEAVE(0);
}


VOID
FlushResolverCache(
    SERIALIZED_LIST* pResolverCache
    )

/*++

Routine Description:

    Removes all entries in DNS resolver cache

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "FlushResolverCache",
                 NULL
                 ));

    LPRESOLVER_CACHE_ENTRY cacheEntry;
    LPRESOLVER_CACHE_ENTRY previousEntry;

    if (LockSerializedList(pResolverCache))
    {
        previousEntry = (LPRESOLVER_CACHE_ENTRY)SlSelf(pResolverCache);
        cacheEntry = (LPRESOLVER_CACHE_ENTRY)HeadOfSerializedList(pResolverCache);
        while (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(pResolverCache)) {
            if (cacheEntry->State == ENTRY_UNUSED) {
                RemoveCacheEntry(pResolverCache, cacheEntry);
            } else {

                DEBUG_PRINT(SOCKETS,
                            WARNING,
                            ("cache entry %#x (%q) still in-use\n",
                            cacheEntry,
                            cacheEntry->HostName
                            ));

                cacheEntry->State = ENTRY_DELETE;
                previousEntry = cacheEntry;
            }
            cacheEntry = (LPRESOLVER_CACHE_ENTRY)previousEntry->ListEntry.Flink;
        }

        UnlockSerializedList(pResolverCache);
    }

    DEBUG_LEAVE(0);
}


VOID
ReleaseResolverCacheEntry(
    SERIALIZED_LIST* pResolverCache,
    IN LPRESOLVER_CACHE_ENTRY cacheEntry
    )

/*++

Routine Description:

    Either mark a entry unused or if it is stale, delete it

Arguments:

    lpAddrInfo   - pointer to AddrInfo field of entry to free

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "ReleaseResolverCacheEntry",
                 "%#x, %#x",
                 cacheEntry, (cacheEntry ? cacheEntry->AddrInfo : NULL)
                 ));

    if (LockSerializedList(pResolverCache))
    {
        //
        // reference count should never go below zero!
        //

        INET_ASSERT(cacheEntry->ReferenceCount > 0);

        if (--cacheEntry->ReferenceCount <= 0) {

            //
            // last releaser gets to decide what to do - mark unused or delete
            //

            if (cacheEntry->State == ENTRY_IN_USE) {
                cacheEntry->State = ENTRY_UNUSED;
            } else if (cacheEntry->State == ENTRY_DELETE) {

                //
                // entry is already stale - throw it out
                //

                RemoveCacheEntry(pResolverCache, cacheEntry);
            } else {

                //
                // unused? or bogus value? Someone changed state while refcount
                // not zero?
                //

                INET_ASSERT((cacheEntry->State == ENTRY_IN_USE)
                            || (cacheEntry->State == ENTRY_DELETE));

            }
        }

        UnlockSerializedList(pResolverCache);
    }

    DEBUG_LEAVE(0);
}

#ifdef NOT_USED

VOID
ThrowOutResolverCacheEntry(
    SERIALIZED_LIST* pResolverCache,
    IN LPADDRINFO lpAddrInfo
    )

/*++

Routine Description:

    Removes this entry from the DNS cache, based on the host name. We assume
    that the entry came from the cache, so unless it has been already purged,
    we should be able to throw it out

Arguments:

    lpAddrInfo  - pointer to addrinfo field with name of entry to throw out

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "ThrowOutResolverCacheEntry",
                 "%#x [%q]",
                 lpAddrInfo,
                 lpAddrInfo->ai_canonname
                 ));

    if (DnsCachingEnabled && LockSerializedList(pResolverCache)) {

        LPRESOLVER_CACHE_ENTRY cacheEntry;

        cacheEntry = (LPRESOLVER_CACHE_ENTRY)HeadOfSerializedList(pResolverCache);
        while (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(pResolverCache)) {
            if (AddrInfoMatch(cacheEntry->AddrInfo, lpAddrInfo->ai_canonname, NULL)) {

                //
                // if the entry is unused then we can delete it, else we have
                // to leave it to the thread with the last reference
                //

                if (cacheEntry->State == ENTRY_UNUSED) {
                    RemoveCacheEntry(pResolverCache, cacheEntry);
                } else {
                    cacheEntry->State = ENTRY_DELETE;
                }
                break;
            }
        }

        UnlockSerializedList(pResolverCache);
    } else {

        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("DNS caching disabled or unable to serialize access\n"
                    ));

    }

    DEBUG_LEAVE(0);
}
#endif //NOT_USED


PRIVATE
VOID
RemoveCacheEntry(
    SERIALIZED_LIST* pResolverCache,
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry
    )

/*++

Routine Description:

    Takes a cache entry off the list and frees it

    N.B.: This function must be called with the resolver cache serialized list
    already locked

Arguments:

    lpCacheEntry    - currently queued entry to remove

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "RemoveCacheEntry",
                 "%#x",
                 lpCacheEntry
                 ));

    if (RemoveFromSerializedList(pResolverCache, &lpCacheEntry->ListEntry))
    {

        INET_ASSERT(lpCacheEntry->ReferenceCount == 0);
        INET_ASSERT((lpCacheEntry->State == ENTRY_UNUSED)
                    || (lpCacheEntry->State == ENTRY_DELETE));

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("throwing out %q, expiry = %s\n",
                    lpCacheEntry->HostName,
                    CacheTimestr(lpCacheEntry->ExpirationTime)
                    ));

        _I_freeaddrinfo(lpCacheEntry->AddrInfo);
        lpCacheEntry = (LPRESOLVER_CACHE_ENTRY)FREE_MEMORY((HLOCAL)lpCacheEntry);

        INET_ASSERT(lpCacheEntry == NULL);

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("CurrentDnsCacheEntries = %d\n",
                    pResolverCache->ElementCount
                    ));

        INET_ASSERT((pResolverCache->ElementCount >= 0)
                    && (pResolverCache->ElementCount <= MaximumDnsCacheEntries));
    }
    else
    {
        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("unable to throw out %q due to insufficient resources, expiry = %s\n",
                    lpCacheEntry->HostName,
                    CacheTimestr(lpCacheEntry->ExpirationTime)
                    ));
    }

    DEBUG_LEAVE(0);
}


PRIVATE
BOOL
ResolverCacheHit(
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry,
    IN LPSTR Name OPTIONAL,
    IN LPSOCKADDR Address OPTIONAL
    )

/*++

Routine Description:

    Checks this RESOLVER_CACHE_ENTRY for a match with Name or Address. If Name,
    can match with ai_canonname in addrinfo, or with originally resolved name

Arguments:

    lpCacheEntry    - pointer to RESOLVER_CACHE_ENTRY to check

    Name            - optional name to check

    Address         - optional server address to check

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "ResolverCacheHit",
                 "%#x, %q, %A",
                 lpCacheEntry,
                 Name,
                 Address
                 ));

    BOOL found;

    if ((Name != NULL)
    && (lpCacheEntry->HostName != NULL)
    && (lstrcmpi(lpCacheEntry->HostName, Name) == 0)) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("matched name %q\n",
                    lpCacheEntry->HostName
                    ));

        found = TRUE;
    } else {
        found = FALSE;
    }
    if (!found) {
        found = AddrInfoMatch(lpCacheEntry->AddrInfo, Name, Address);
    }

    DEBUG_LEAVE(found);

    return found;
}


PRIVATE
BOOL
AddrInfoMatch(
    IN LPADDRINFO AddrInfo,
    IN LPSTR Name OPTIONAL,
    IN LPSOCKADDR Address OPTIONAL
    )

/*++

Routine Description:

    Compares a getaddrinfo result for a match with a host name or address

Arguments:

    AddrInfo - pointer to addrinfo chain to compare

    Name     - pointer to name string

    Address  - pointer to IP address (as a sockaddr)

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "AddrInfoMatch",
                 "%#x, %q, %A",
                 AddrInfo,
                 Name,
                 Address
                 ));

    BOOL found = FALSE;

    if (Name) {
        if ((AddrInfo->ai_canonname != NULL) &&
        (lstrcmpi(AddrInfo->ai_canonname, Name) == 0))
            found = TRUE;
    } else {

        INET_ASSERT(Address != NULL);

        do {
            if ((AddrInfo->ai_addr->sa_family == Address->sa_family)
            && (memcmp(AddrInfo->ai_addr, Address, AddrInfo->ai_addrlen) == 0)) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("matched %A\n",
                            Address
                            ));

                found = TRUE;
                break;
            }

        } while ((AddrInfo = AddrInfo->ai_next) != NULL);
    }

    if (found) {
        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("addrinfo = %A\n",
                    AddrInfo->ai_addr
                    ));
    }

    DEBUG_LEAVE(found);

    return found;
}


PRIVATE
LPRESOLVER_CACHE_ENTRY
CreateCacheEntry(
    IN LPSTR lpszHostName,
    IN LPADDRINFO AddrInfo,
    IN DWORD TimeToLive,
    IN VOID** pAlloc,
    IN DWORD dwAllocSize
    )

/*++

Routine Description:

    Allocates a RESOLVER_CACHE_ENTRY and packs it with the addrinfo information
    and sets the ExpirationTime

Arguments:

    lpszHostName    - name we resolved

    AddrInfo        - pointer to addrinfo chain to store in new entry

    TimeToLive      - amount of time before this entry expires

Return Value:

    LPRESOLVER_CACHE_ENTRY

--*/

{
    LPRESOLVER_CACHE_ENTRY cacheEntry;

    INET_ASSERT(lpszHostName != NULL);

    //
    // only copy lpszHostName if it is different from the name in addrinfo
    //

    UINT hostNameSize;

    if ((AddrInfo->ai_canonname != NULL)
    && lstrcmpi(AddrInfo->ai_canonname, lpszHostName) != 0) {
        hostNameSize = lstrlen(lpszHostName) + 1;
    }
    else if (AddrInfo->ai_canonname == NULL)
    {
        // if ap_canonname is null, we have to save the lpszHoatName
        hostNameSize = lstrlen(lpszHostName) + 1;
    }
    else 
    {
        hostNameSize = 0;
    }

    //
    // allocate space for the cache entry
    //

    DWORD dwSize = sizeof(RESOLVER_CACHE_ENTRY)
                 + hostNameSize;

    if (dwSize <= dwAllocSize)
    {
        cacheEntry = (LPRESOLVER_CACHE_ENTRY)(*pAlloc);
        *pAlloc = NULL;
    }
    else
    {
        cacheEntry = (LPRESOLVER_CACHE_ENTRY)ALLOCATE_MEMORY(dwSize);
    }
    
    if (cacheEntry != NULL) {

        //
        // cache the getaddrinfo result
        //

        cacheEntry->AddrInfo = AddrInfo;

        //
        // copy the host name to the end of the buffer if required
        //

        if (hostNameSize != 0) {
            cacheEntry->HostName = (LPSTR)(cacheEntry + 1);
            RtlCopyMemory(cacheEntry->HostName, lpszHostName, hostNameSize);
        } else {
            cacheEntry->HostName = NULL;
        }

        //
        // calculate the expiration time as the current time (in seconds since
        // 1/1/70) + number of seconds to live OR indefinite if TimeToLive is
        // specified as LIVE_FOREVER, which is what we use if the host
        // information didn't originate from DNS
        //

        cacheEntry->ExpirationTime = (DWORD)((TimeToLive == LIVE_FOREVER)
                                        ? LIVE_FOREVER
                                        : time(NULL)
                                            + ((TimeToLive == LIVE_DEFAULT)
                                                ? DnsCacheTimeout
                                                : TimeToLive));

        //
        // the entry state is initially unused
        //

        cacheEntry->State = ENTRY_UNUSED;

        //
        // and reference is zero
        //

        cacheEntry->ReferenceCount = 0;
    }

    return cacheEntry;
}

#if INET_DEBUG

//
// CAVEAT - can only call these functions once per printf() etc. because of
//          static buffers (but still thread-safe)
//

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheTimestr(IN DWORD Time) {

    //
    // previous code - writes formatted human-sensible date/time to buffer
    //

    //LPSTR p;
    //
    ////
    //// remove the LF from the time string returned by ctime()
    ////
    //
    //p = ctime((const time_t *)&Time);
    //p[strlen(p) - 1] = '\0';
    //return p;

    //
    // abbreviated CRT version - just write # seconds since 1970 to buffer
    //

    static char buf[16];

    wsprintf(buf, "%d", Time);
    return (LPSTR)buf;
}
#endif

#if defined(RNR_SUPPORTED)

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rescache.c

Abstract:

    Contains name resolution cache

    Contents:

Author:

    Shishir Pardikar    2-14-96

Environment:

    Win32 user mode

Revision History:

        2-14-96 shishirp
        Created

--*/

//
//BUGBUG: This include should be removed, duplicate of above
//
#ifndef SPX_SUPPORT
#include <wininetp.h>
#endif


//
// private manifests
//

#define NAMERES_CACHE_USED            0x00000001
#define NAMERES_CACHE_USES_GUID       0x00000002

#define ENTERCRIT_NAMERESCACHE()  (vcritNameresCache.Lock())
#define LEAVECRIT_NAMERESCACHE()  (vcritNameresCache.Unlock())
#define IS_EMPTY(indx)            ((vlpNameresCache[(indx)].dwFlags & NAMERES_CACHE_USED) == 0)
#define USES_GUID(indx)           ((vlpNameresCache[(indx)].dwFlags & NAMERES_CACHE_USES_GUID))

// number of cache entries
#define DEFAULT_NAMERES_CACHE_ENTRIES   10

// expiry time for an addresslist
#define DEFAULT_EXPIRY_DELTA            (24 * 60 * 60 * (LONGLONG)10000000)


//
//  structure definition
//

typedef struct tagNAMERES_CACHE {
    DWORD               dwFlags;       // general flags to be used as needed
    DWORD               dwNameSpace;   // namespace ??
    GUID                sGuid;         // GUID describing service type
    LPSTR               lpszName;      // ptr to name that needs resolution
    FILETIME            ftLastUsedTime;    // last accesstime, mainly for purging
    FILETIME            ftCreationTime;// When it was created
    ADDRESS_INFO_LIST   sAddrList;     // List of address (defined in ixport.h)
} NAMERES_CACHE, far *LPNAMERES_CACHE;





//
// private variables for name resolution cache
//


// Name cache size allocated in init
LPNAMERES_CACHE vlpNameresCache = NULL;

// Number of elements allowed in the nameres cache
int vcntNameresCacheEntries = DEFAULT_NAMERES_CACHE_ENTRIES;


// time in 100ns after which an address is expired
LONGLONG vftExpiryDelta = DEFAULT_EXPIRY_DELTA;

BOOL vfNameresCacheInited = FALSE;

// serialization
CCritSec vcritNameresCache;

//
// private function prototypes
//


PRIVATE
DWORD
CreateNameresCacheEntry(
    int     indx,
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName,
    INT     cntAddresses,
    LPCSADDR_INFO  lpCsaddrInfo
);


PRIVATE
DWORD
DeleteNameresCacheEntry(
    int indx
);


PRIVATE
int
FindNameresCacheEntry(
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName
);


PRIVATE
int
FindNameresCacheEntryByAddr(
    int cntAddr,
    LPCSADDR_INFO lpCsaddrInfo
);

PRIVATE
int
PurgeEntries(
    BOOL    fForce  // purge atleast one entry
);


PRIVATE
DWORD
CopyCsaddr(
    LPCSADDR_INFO   lpSrc,
    int             cntAddr,
    LPCSADDR_INFO   *lplpDst
);

//
// functions
//


DWORD
InitNameresCache(
    VOID
)
/*++

Routine Description:

    Init name resolution cache. This routine a) allocates a table of
    name cache entries b)

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.

--*/
{


    if (vfNameresCacheInited)
    {
        return (ERROR_SUCCESS);
    }

    // first try to alloc the memory, if it fails just quit
    vlpNameresCache = (LPNAMERES_CACHE)ALLOCATE_ZERO_MEMORY(vcntNameresCacheEntries * sizeof(NAMERES_CACHE));

    if (!vlpNameresCache)
    {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    if (!vcritNameresCache.Init() || !ENTERCRIT_NAMERESCACHE())
    {
        FREE_MEMORY(vlpNameresCache);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    vfNameresCacheInited = TRUE;

    LEAVECRIT_NAMERESCACHE();

    return (ERROR_SUCCESS);

}


DWORD
AddNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpName,
    int      cntAddresses,
    LPCSADDR_INFO  lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD dwError = ERROR_SUCCESS;

    if (!vfNameresCacheInited) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (!ENTERCRIT_NAMERESCACHE())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    indx = FindNameresCacheEntry(dwNameSpace, lpGuid, lpName);

    // if indx is valid, delete the entry, do some purging too
    if (indx != -1) {
        DeleteNameresCacheEntry(indx);
        PurgeEntries(FALSE);
    }
    else {
        // create atleast one hole
        indx = PurgeEntries(TRUE);
    }

    INET_ASSERT((indx >=0 && (indx < vcntNameresCacheEntries)));

    dwError = CreateNameresCacheEntry(indx,
                            dwNameSpace,
                            lpGuid,
                            lpName,
                            cntAddresses,
                            lpCsaddrInfo);

    LEAVECRIT_NAMERESCACHE();

    return (dwError);
}




DWORD
RemoveNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpszName
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (vfNameresCacheInited) {

        if (!ENTERCRIT_NAMERESCACHE())
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        indx = FindNameresCacheEntry(dwNameSpace, lpGuid, lpszName);

        if (indx != -1) {

            DeleteNameresCacheEntry(indx);

            dwError = ERROR_SUCCESS;
        }
        else {
            dwError = ERROR_FILE_NOT_FOUND; //yuk
        }

        LEAVECRIT_NAMERESCACHE();
    }
quit:
    return (dwError);
}


#ifdef MAYBE

DWORD
RemoveNameresCacheEntryByAddr(
    int cntAddresses,
    LPCSADDR_INFO lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (vfNameresCacheInited) {
        if (!ENTERCRIT_NAMERESCACHE())
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }


        indx = FindNameresCacheEntryByAddr(cntAddresses, lpCsaddrInfo);

        if (indx != -1) {

            DeleteNameresCacheEntry(indx);

            dwError = ERROR_SUCCESS;
        }
        else {
            dwError = ERROR_FILE_NOT_FOUND;
        }

        LEAVECRIT_NAMERESCACHE();
    }
quit:
    return (dwError);

}
#endif //MAYBE

DWORD
GetNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpName,
    INT      *lpcntAddresses,
    LPCSADDR_INFO  *lplpCsaddrInfo
)
/*++

Routine Description:

    This routine looks up the cache and returns the list of addresses
    corresponding to lpGuid/lpName.

Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD   dwError = ERROR_FILE_NOT_FOUND; // poor error

    if (!vfNameresCacheInited) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (!ENTERCRIT_NAMERESCACHE())
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    // is this entry already cached?
    indx = FindNameresCacheEntry(dwNameSpace, lpGuid, lpName);


    if (indx != -1) {
        // yes, let use give back the info

        *lpcntAddresses = vlpNameresCache[indx].sAddrList.AddressCount;

        if ((dwError = CopyCsaddr(vlpNameresCache[indx].sAddrList.Addresses, *lpcntAddresses, lplpCsaddrInfo))
            != ERROR_SUCCESS) {

            goto bailout;
        }
        // update the last used time, we will use this to
        // age out the entries

        GetCurrentGmtTime(&(vlpNameresCache[indx].ftLastUsedTime));
        dwError = ERROR_SUCCESS;
    }

bailout:

    LEAVECRIT_NAMERESCACHE();

quit:
    return (dwError);
}


DWORD
DeinitNameresCache(
    VOID
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int i;

    if (vfNameresCacheInited) {
        if (!ENTERCRIT_NAMERESCACHE())
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        for (i = 0; i < vcntNameresCacheEntries; ++i) {
            if (!IS_EMPTY(i)) {
                DeleteNameresCacheEntry(i);
            }
        }

        FREE_MEMORY(vlpNameresCache);

        vlpNameresCache = NULL;

        vfNameresCacheInited = FALSE;

        LEAVECRIT_NAMERESCACHE();
        vcritNameresCache.FreeLock();
    }
    return (ERROR_SUCCESS);
}


PRIVATE
DWORD
CreateNameresCacheEntry(
    int     indx,
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName,
    int     cntAddresses,
    LPCSADDR_INFO  lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    DWORD dwError = ERROR_NOT_ENOUGH_MEMORY;

    INET_ASSERT((indx >=0 && (indx < vcntNameresCacheEntries)));

    INET_ASSERT(IS_EMPTY(indx));


    memset(&vlpNameresCache[indx], 0, sizeof(vlpNameresCache[indx]));

    // we could get a name or a guid
    // do it for name first before doing it for GUID

    // BUGBUG in future we should consider name+GUID+port
    if (lpszName) {
       vlpNameresCache[indx].lpszName = (LPSTR)ALLOCATE_ZERO_MEMORY(lstrlen(lpszName)+1);
       if (!vlpNameresCache[indx].lpszName) {
           goto bailout;
       }
       strcpy(vlpNameresCache[indx].lpszName, lpszName);
    }
    else if (lpGuid) {
        INET_ASSERT(FALSE); // rigth now. In future this should go away
        memcpy(&(vlpNameresCache[indx].sGuid), lpGuid, sizeof(GUID));
        vlpNameresCache[indx].dwFlags |= NAMERES_CACHE_USES_GUID;
    }
    else {
        dwError = ERROR_INVALID_PARAMETER;
        goto bailout;
    }

    INET_ASSERT(cntAddresses > 0);

    if (CopyCsaddr(lpCsaddrInfo, cntAddresses, &(vlpNameresCache[indx].sAddrList.Addresses))
        != ERROR_SUCCESS) {
        goto bailout;
    }

    vlpNameresCache[indx].sAddrList.AddressCount = cntAddresses;

    // mark this as being non-empty
    vlpNameresCache[indx].dwFlags |= NAMERES_CACHE_USED;

    // set the creation and last-used times as now

    GetCurrentGmtTime(&(vlpNameresCache[indx].ftCreationTime));
    vlpNameresCache[indx].ftLastUsedTime = vlpNameresCache[indx].ftCreationTime ;

    dwError = ERROR_SUCCESS;

bailout:

    if (dwError != ERROR_SUCCESS) {
        if (vlpNameresCache[indx].sAddrList.Addresses) {
            FREE_MEMORY(vlpNameresCache[indx].sAddrList.Addresses);
            vlpNameresCache[indx].sAddrList.Addresses = NULL;
        }
        if (vlpNameresCache[indx].lpszName) {
            FREE_MEMORY(vlpNameresCache[indx].lpszName);
            vlpNameresCache[indx].lpszName = NULL;
        }
        memset(&vlpNameresCache[indx], 0, sizeof(vlpNameresCache[indx]));
    }

    return (dwError);
}


PRIVATE
DWORD
DeleteNameresCacheEntry(
    int indx
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    INET_ASSERT((indx >=0) && (indx < vcntNameresCacheEntries));

    if (vlpNameresCache[indx].lpszName) {
        FREE_MEMORY(vlpNameresCache[indx].lpszName);
    }

    INET_ASSERT(vlpNameresCache[indx].sAddrList.Addresses);

    FREE_MEMORY(vlpNameresCache[indx].sAddrList.Addresses);

    memset(&vlpNameresCache[indx], 0, sizeof(NAMERES_CACHE));

    return (ERROR_SUCCESS);
}

#ifdef MAYBE

PRIVATE
int
FindNameresCacheEntryByAddr(
    int cntAddr,
    LPCSADDR_INFO lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int i;

    for (i = 0; i < vcntNameresCacheEntries; ++i) {
        if (!IS_EMPTY(i) && // not empty
            (vlpNameresCache[i].sAddrList.AddressCount == cntAddr) && // count is the same
            (!memcmp(vlpNameresCache[i].sAddrList.Addresses,    // list matches
                     lpCsaddrInfo,
                     cntAddr * sizeof(CSADDR_INFO)))) {
            return (i);
        }
    }
    return (-1);
}
#endif //MAYBE


PRIVATE
int
FindNameresCacheEntry(
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int i;

    for (i = 0; i < vcntNameresCacheEntries; ++i) {
        if (!IS_EMPTY(i)) {
            if (vlpNameresCache[i].dwNameSpace == dwNameSpace) {
                if (!USES_GUID(i)) {

                    INET_ASSERT(vlpNameresCache[i].lpszName);

                    if (lpszName &&
                        !lstrcmpi(lpszName, vlpNameresCache[i].lpszName)) {
                        return (i);
                    }
                }
                else{

                    if (lpGuid && !memcmp(lpGuid, &vlpNameresCache[i].sGuid, sizeof(GUID))) {
                        return (i);
                    }
                }
            }
        }
    }
    return (-1);
}


PRIVATE
int
PurgeEntries(
    BOOL    fForce  // purge atleast one entry
)
/*++

Routine Description:


Arguments:


Return Value:

    index of a free entry

--*/
{
    int i, indxlru = -1, indxHole=-1;
    FILETIME ft;
    BOOL fFoundHole = FALSE;

    GetCurrentGmtTime(&ft);

    for (i = 0; i < vcntNameresCacheEntries; ++i) {
        if (!IS_EMPTY(i)) {

            // purge stale entries
            if ( (FT2LL(ft) - FT2LL(vlpNameresCache[i].ftCreationTime))
                    > FT2LL(vftExpiryDelta)) {
                DeleteNameresCacheEntry(i);
                indxHole = i;
            }
            else if (FT2LL(vlpNameresCache[i].ftLastUsedTime) <= FT2LL(ft)) {
                ft = vlpNameresCache[i].ftLastUsedTime;
                indxlru = i; // LRU entry if we need to purge it
            }
        }
        else {
            indxHole = i;
        }
    }

    // if there is no hole, purge the LRU entry if forced
    if (indxHole == -1) {

        INET_ASSERT(indxlru != -1);

        if (fForce) {
            DeleteNameresCacheEntry(indxlru);
            indxHole = indxlru;
        }
    }
    return (indxHole);
}

PRIVATE
DWORD
CopyCsaddr(
    LPCSADDR_INFO   lpSrc,
    int             cntAddr,
    LPCSADDR_INFO   *lplpDst
)
{
    int i;
    LPCSADDR_INFO lpDst;
    UINT uSize;


    // BUGBUG assumes the way Compressaddress (ixport.cxx) allocates memory
    uSize = LocalSize(lpSrc);
    if (!uSize) {
        return (GetLastError());
    }

    *lplpDst = (LPCSADDR_INFO)ALLOCATE_ZERO_MEMORY(uSize);

    if (!*lplpDst) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    lpDst = *lplpDst;


    memcpy(lpDst, lpSrc, uSize);

    // now start doing fixups
    for (i=0; i<cntAddr; ++i) {
        lpDst[i].LocalAddr.lpSockaddr = (LPSOCKADDR)((LPBYTE)lpDst+((DWORD)(lpSrc[i].LocalAddr.lpSockaddr) - (DWORD)lpSrc));
        lpDst[i].RemoteAddr.lpSockaddr = (LPSOCKADDR)((LPBYTE)lpDst+((DWORD)(lpSrc[i].RemoteAddr.lpSockaddr) - (DWORD)lpSrc));
    }
    return (ERROR_SUCCESS);
}

#endif // defined(RNR_SUPPORTED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\debug\dbghandle.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    handle.cxx

Abstract:

    Contains function to return number of open handles owned by this process

    Contents:
        InternetHandleCount

Author:

    Richard L Firth (rfirth) 02-May-1995

Environment:

    Win32 user-mode DLL

Revision History:

    02-May-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

#if INET_DEBUG

//
// private types
//

typedef (*NT_QUERY_SYSTEM_INFORMATION)(ULONG, PVOID, ULONG, PULONG);

//
// functions
//


DWORD
InternetHandleCount(
    VOID
    )

/*++

Routine Description:

    Gets the number of system handles owned by this process. We LoadLibrary()
    NTDLL.DLL so that the debug version of this DLL still works on Win95

Arguments:

    None.

Return Value:

    DWORD

--*/

{
    static HINSTANCE hNtdll = NULL;
    static NT_QUERY_SYSTEM_INFORMATION _NtQuerySystemInformation;

    if (IsPlatformWin95()) {
        return 0;
    }

    if (hNtdll == NULL) {
        hNtdll = LoadLibrary("ntdll");
        if (hNtdll == NULL) {
            return 0;
        }
        _NtQuerySystemInformation = (NT_QUERY_SYSTEM_INFORMATION)GetProcAddress(hNtdll, "NtQuerySystemInformation");
        if (_NtQuerySystemInformation == 0) {
            FreeLibrary(hNtdll);
            hNtdll = NULL;
        }
    }

    if (_NtQuerySystemInformation) {

        DWORD idProcess;
        NTSTATUS status;
        ULONG outputLength;
        BYTE buffer[32768];
        PSYSTEM_PROCESS_INFORMATION info;

        status = _NtQuerySystemInformation(SystemProcessInformation,
                                           (PVOID)buffer,
                                           sizeof(buffer),
                                           &outputLength
                                           );
        if (!NT_SUCCESS(status)) {
            return 0;
        }
        info = (PSYSTEM_PROCESS_INFORMATION)buffer;
        idProcess = GetCurrentProcessId();
        while (TRUE) {
            if ((DWORD_PTR)info->UniqueProcessId == idProcess) {
                return info->HandleCount;
            }
            if (info->NextEntryOffset == 0) {
                return 0;
            }
            info = (PSYSTEM_PROCESS_INFORMATION)((PCHAR)info + info->NextEntryOffset);
        }
    }
    return 0;
}

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\tracer.cxx ===
/*
 * ++ Copyright (c) 2001 Microsoft Corporation Module Name: tracer.cxx 
 * Retail tracing for WinHttp DLL 
 * Author: S. Ganesh 
 * Environment: Win32 user-mode
 */
#include <wininetp.h>
#include <ntverp.h>

#include <imagehlp.h>

/* Constants: */
#define TRACE_ENABLED_VARIABLE_NAME         "Enabled"
#define LOG_FILE_PREFIX_VARIABLE_NAME       "LogFilePrefix"
#define TO_FILE_OR_DEBUGGER_VARIABLE_NAME   "ToFileOrDebugger"
#define SHOWBYTES_VARIABLE_NAME             "ShowBytes"
#define SHOWAPITRACE_VARIABLE_NAME          "ShowApiTrace"
#define MAXFILESIZE_VARIABLE_NAME           "MaxFileSize"
#define MINFILESIZE                         65535
#define FILE_TRUNCATED_MESSAGE \
        "=== Warning: Trace file truncated to zero because it exceeded MaxFileSize = %ld bytes\r\n"

#define INTERNET_TRACE_SETTINGS_KEY "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\WinHttp\\Tracing"
#define BASE_TRACE_KEY                  HKEY_LOCAL_MACHINE

/* Just reusing an unused ID here: */
#define DBG_NO_SHOWBYTES                DBG_NO_ASSERT_BREAK

#define PRINTF_STACK_BUFFER_LENGTH      (1 K)
#if !defined(max)
#define max(a, b)    ((a) < (b)) ? (b) : (a)
#endif

/* exports: */
int cdecl            _sprintf(char *buffer, size_t buf_size, char *format, va_list args);

/* Static initializations: */
CTracer *CTracer::    s_pTracer = NULL;
BOOL CTracer::        s_bTraceInitialized = FALSE;
BOOL CTracer::        s_bTraceEnabled = FALSE;
BOOL CTracer::        s_bApiTraceEnabled = FALSE;
DWORD CTracer::        s_dwMaxFileSize = MINFILESIZE;
CCritSec CTracer::s_CritSectionTraceInit;

/* Member functions: */

/*
 =======================================================================================================================
    static
 =======================================================================================================================
 */
DWORD CTracer::ReadTraceSettingsDwordKey(IN LPCSTR ParameterName, OUT LPDWORD ParameterValue)
{
    return InternetReadRegistryDwordKey(BASE_TRACE_KEY, ParameterName, ParameterValue, INTERNET_TRACE_SETTINGS_KEY);
}

/*
 =======================================================================================================================
    static
 =======================================================================================================================
 */
DWORD CTracer::ReadTraceSettingsStringKey
(
    IN LPCSTR        ParameterName,
    OUT LPSTR        ParameterValue,
    IN OUT LPDWORD    ParameterLength
)
{
    return InternetReadRegistryStringKey
        (
            BASE_TRACE_KEY,
            ParameterName,
            ParameterValue,
            ParameterLength,
            INTERNET_TRACE_SETTINGS_KEY
        );
}

/*
 =======================================================================================================================
    static
 =======================================================================================================================
 */

BOOL CTracer::GlobalTraceInit(BOOL fOverrideRegistryToEnableTracing)
{
    BOOL returnValue;
    
    if( s_bTraceInitialized != FALSE)
        return TRUE;

    if( !s_CritSectionTraceInit.Lock())
        return FALSE;

    returnValue = unlockedGlobalTraceInit( fOverrideRegistryToEnableTracing);

    s_CritSectionTraceInit.Unlock();
    return returnValue;
}

BOOL CTracer::unlockedGlobalTraceInit(BOOL fOverrideRegistryToEnableTracing)
{
    /*~~~~~~~~~~~~~~~~~*/
    DWORD    traceEnabled;
    /*~~~~~~~~~~~~~~~~~*/

    if( s_bTraceInitialized != FALSE)
        return TRUE;

    if(ReadTraceSettingsDwordKey(TRACE_ENABLED_VARIABLE_NAME, &traceEnabled) == ERROR_SUCCESS 
       && (traceEnabled
           || fOverrideRegistryToEnableTracing != FALSE))
    {
        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
        DWORD    traceControlFlags = 0;
        char    lpszFilename[MAX_PATH + 1];
        DWORD    dwDummy = sizeof(lpszFilename) - 1;
        DWORD    toFileOrDebugger;
        DWORD    showApiTrace;
        DWORD    showBytes;
        DWORD    dwMaxFileSize;
        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

        /* Create tracer instance: */
        s_pTracer = new CTracer(DBG_TO_FILE);
        if(s_pTracer == NULL)
        {
            GlobalTraceTerm();
            return false;
        }
            
        if(ReadTraceSettingsDwordKey(TO_FILE_OR_DEBUGGER_VARIABLE_NAME, &toFileOrDebugger) == ERROR_SUCCESS)
        {
            switch(toFileOrDebugger)
            {
                case 0:
                    traceControlFlags |= DBG_TO_FILE;
                    break;
                case 1:
                    traceControlFlags |= DBG_TO_DEBUGGER;
                    break;
                case 2:
                    traceControlFlags |= DBG_TO_DEBUGGER | DBG_TO_FILE;
                    break;
                default:
                    INET_ASSERT(FALSE);
            }
        }
        else
        {
                traceControlFlags |= DBG_TO_FILE;
        }
            

        if( (traceControlFlags & DBG_TO_FILE) )
        {
            /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
            char        szFullPathName[MAX_PATH + 1];
            LPSTR        szExecutableName;
            SYSTEMTIME    currentTime;
            /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

            lpszFilename[0] = '\0';
            ReadTraceSettingsStringKey(LOG_FILE_PREFIX_VARIABLE_NAME, lpszFilename, &dwDummy);
            
            if(GetModuleFileName(NULL, szFullPathName, sizeof(szFullPathName)))
            {
                szExecutableName = StrRChr(szFullPathName, NULL, '\\');
                if(szExecutableName != NULL)
                    ++szExecutableName;
                else
                    szExecutableName = szFullPathName;
            }
            else
                szExecutableName = "";

            ::GetLocalTime(&currentTime);

            wsprintf
            (
                lpszFilename + strlen(lpszFilename),
                "%s%s-%u.%02d.%02d.%02d.%03d-%02d.%02d.%d.LOG",
                !lpszFilename[0]? "": "-",
                szExecutableName,
                currentTime.wHour,
                currentTime.wMinute,
                currentTime.wSecond,
                currentTime.wMilliseconds,
                currentTime.wMonth,
                currentTime.wDay,
                currentTime.wYear,
                GetCurrentProcessId()
            );

            if(!s_pTracer->OpenTraceFile(lpszFilename))
            {
                // Disable:
                traceControlFlags &= ~DBG_TO_FILE;
            }
        }

        /*
         * If traceControlFlags is 0, 
         * disable tracing:
         */
        if(!traceControlFlags)
        {
            GlobalTraceTerm();
            return false;
        }

        /* Tracing enabled, go forward: */
        
        if(ReadTraceSettingsDwordKey(SHOWAPITRACE_VARIABLE_NAME, &showApiTrace) == ERROR_SUCCESS && showApiTrace)
        {
            EnableApiTracing();
        }

        /* showBytes: 0 - No packets; 1 - noShowBytes; 2 - showBytes */
        if(ReadTraceSettingsDwordKey(SHOWBYTES_VARIABLE_NAME, &showBytes) == ERROR_SUCCESS)
        {
            if(showBytes == 0)
                traceControlFlags |= DBG_NO_DATA_DUMP;
            else
            if(showBytes == 1)
            {
                /* Don't show bytes in HTTP packets: */
                traceControlFlags |= DBG_NO_SHOWBYTES;
            }
        }
        else
        {
            traceControlFlags |= DBG_NO_SHOWBYTES;
        }

        if(ReadTraceSettingsDwordKey(MAXFILESIZE_VARIABLE_NAME, &dwMaxFileSize) == ERROR_SUCCESS && dwMaxFileSize)
        {
            s_dwMaxFileSize = max(MINFILESIZE, dwMaxFileSize);    /* Keep it at a minimum size of MINFILESIZE */
        }

        s_pTracer->_traceControlFlags = traceControlFlags;
        EnableTracing();
        s_bTraceInitialized = TRUE;

        return true;
    }

    return false;
}

/*
 =======================================================================================================================
    static
 =======================================================================================================================
 */
void CTracer::GlobalTraceTerm(void)
{
    DisableTracing();
    if(s_pTracer)
    {
        delete s_pTracer;
        s_pTracer = NULL;
    }
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
CTracer::CTracer(DWORD traceControlFlags) :
    _traceFileHandle(INVALID_HANDLE_VALUE),
    _dwWritten(0)
{
    _traceControlFlags = traceControlFlags;
    ::InitializeCriticalSection(&_CriticalSection); 
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
CTracer::~CTracer(void)
{
    if(_traceControlFlags & DBG_TO_FILE)
    {
        CloseTraceFile();
    }
    
    ::DeleteCriticalSection(&_CriticalSection);
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
BOOL CTracer::OpenTraceFile(IN LPSTR Filename)
{
    if(Filename && *Filename)
    {
        CAdminOnlySecurityDescriptor cSD;
        SECURITY_ATTRIBUTES securityAttributes;
        memset( &securityAttributes, 0, sizeof(securityAttributes));

        if (ERROR_SUCCESS != cSD.Initialize())
            return false;
        
        securityAttributes.nLength = sizeof(securityAttributes);
        securityAttributes.bInheritHandle = FALSE;
        securityAttributes.lpSecurityDescriptor = cSD.GetSecurityDecriptor();
     
        _traceFileHandle = CreateFile
            (
                Filename,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                &securityAttributes,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
            );

        /* put start info in the log file if open successful: */
        if(_traceFileHandle != INVALID_HANDLE_VALUE)
        {
            /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
            SYSTEMTIME    currentTime;
            char        filespec[MAX_PATH + 1];
            LPSTR        filename;
            /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

            if(GetModuleFileName(NULL, filespec, sizeof(filespec)-1)) // leave room for null char
            {
                filespec[sizeof(filespec)-1] = '\0'; // guarantee null-termination
                filename = strrchr(filespec, '\\');
                if(filename != NULL)
                {
                    ++filename;
                }
                else
                {
                    filename = filespec;
                }
            }
            else
            {
                filename = "";
            }

            ::GetLocalTime(&currentTime);

            TracePrint
            (
                (DWORD)-1,
                ">>>> WinHttp Version %d.%d Build %s.%d "__DATE__ " "__TIME__ ">>>>"
                "Process %s [%d (%#x)] started at %02d:%02d:%02d.%03d %02d/%02d/%d\r\n",
                InternetVersionInfo.dwMajorVersion,
                InternetVersionInfo.dwMinorVersion,
                VER_PRODUCTVERSION_STRING,
                InternetBuildNumber,
                filename,
                GetCurrentProcessId(),
                GetCurrentProcessId(),
                currentTime.wHour,
                currentTime.wMinute,
                currentTime.wSecond,
                currentTime.wMilliseconds,
                currentTime.wMonth,
                currentTime.wDay,
                currentTime.wYear
            );

            return TRUE;
        }
    }

    return FALSE;
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
VOID CTracer::CloseTraceFile(VOID)
{
    if(_traceFileHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_traceFileHandle);
        _traceFileHandle = INVALID_HANDLE_VALUE;
    }
}

#define TRACE_FN_ENTER_COMMON_CODE() \
    if(CTracer::IsApiTracingEnabled()) \
    { \
        char    buf[PRINTF_STACK_BUFFER_LENGTH]; \
        LPSTR    bufptr; \
        bufptr = buf; \
        bufptr += wsprintf(bufptr, "%s(", Function); \
        if(ARGUMENT_PRESENT(ParameterList)) \
        { \
            va_list parms; \
            va_start(parms, ParameterList); \
            bufptr += _sprintf(bufptr, PRINTF_STACK_BUFFER_LENGTH - 1 - (bufptr - buf), (char *) ParameterList, parms); \
            va_end(parms); \
        } \
        wsprintf(bufptr, ")\r\n"); \
        TracePrintString(buf, a_traceValues._dwPrefix); \
    }

/*
 =======================================================================================================================
 =======================================================================================================================
 */

TraceValues CTracer::TraceFnEnter
(
    IN DWORD Category,
    IN TRACE_FUNCTION_RETURN_TYPE ReturnType,
    IN LPCSTR Function,
    IN LPCSTR ParameterList OPTIONAL,
    IN...
)
{
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    LPINTERNET_THREAD_INFO    lpThreadInfo = InternetGetThreadInfo();
    TraceValues                a_traceValues(-1, Function, ReturnType);
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    UNREFERENCED_PARAMETER(Category);
    if(lpThreadInfo)
    {
        BOOL    a_isLocal; 
        BOOL    a_isAsync; 
        if((lpThreadInfo->hObjectMapped) && RIsHandleLocal((lpThreadInfo->hObjectMapped), &a_isLocal, &a_isAsync, TypeHttpRequestHandle) == ERROR_SUCCESS) 
        { 
            a_traceValues._dwPrefix = ((HTTP_REQUEST_HANDLE_OBJECT *) ((lpThreadInfo->hObjectMapped)))->GetRequestId(); 
        } 
    }

    TRACE_FN_ENTER_COMMON_CODE();

    return a_traceValues;
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
TraceValues CTracer::TraceFnEnter2
(
    IN DWORD Category,
    IN TRACE_FUNCTION_RETURN_TYPE ReturnType,
    IN LPCSTR Function,
    IN HINTERNET hInternet,
    IN LPCSTR ParameterList OPTIONAL,
    IN...
)
{
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    TraceValues a_traceValues(-1, Function, ReturnType);
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    UNREFERENCED_PARAMETER(Category);

    TRACE_SET_ID_FROM_HANDLE(hInternet);

    TRACE_FN_ENTER_COMMON_CODE();

    return a_traceValues;
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
VOID CTracer::TraceFnLeave(IN DWORD_PTR Variable, IN TraceValues *pTraceValues)
{
    /*~~~~~~~~~~~~~~~~~~~*/
    LPSTR    format = "";
    LPSTR    errstr;
    BOOL    noVar;
    char    formatBuf[128];
    DWORD    lastError;
    char    hexnumBuf[15];
    /*~~~~~~~~~~~~~~~~~~~*/

    /*
     * in case, something in this path nukes the last error, save and refresh it
     * towards the end of the fn:  
     */
    lastError = ::GetLastError();

    /*
     * we are about to output a diagnostic message to the debug log, debugger,  
     * or console.
     */
    errstr = NULL;
    noVar = FALSE;
    switch(pTraceValues->_ReturnType)
    {
    case None:
        format = "%s() returning VOID";
        noVar = TRUE;
        break;

    case Bool:
        Variable = (DWORD_PTR) (Variable ? "TRUE" : "FALSE");

    /*
     *  
     * *** FALL THROUGH ***  
     */
    case String:
        format = "%s() returning %s";
        break;

    case Int:
        format = "%s() returning %d";
        break;

    case Dword:
        format = "%s() returning %u";
        errstr = InternetMapError((DWORD) Variable);
        if(errstr != NULL)
        {
            if(*errstr == '?')
            {
                wsprintf(hexnumBuf, "%#x", Variable);
                errstr = hexnumBuf;
                format = "%s() returning %u [?] (%s)";
            }
            else
            {
                format = "%s() returning %u [%s]";
            }
        }
        break;

    case Handle:
    case Pointer:
        if(Variable == 0)
        {
            format = "%s() returning NULL";
            noVar = TRUE;
        }
        else
        {
            if(pTraceValues->_ReturnType == Handle)
            {
                format = "%s() returning handle %#x";
            }
            else
            {
                format = "%s() returning %#x";
            }
        }
        break;

    default:
        INET_ASSERT(FALSE);
        break;
    }

    strcpy(formatBuf, format);
    strcat(formatBuf, "\r\n");

    if(noVar)
    {
        TracePrint(pTraceValues->_dwPrefix, formatBuf, pTraceValues->_lpszFnName);
    }
    else if(errstr != NULL)
    {
        TracePrint(pTraceValues->_dwPrefix, formatBuf, pTraceValues->_lpszFnName, Variable, errstr);
    }
    else
    {
        TracePrint(pTraceValues->_dwPrefix, formatBuf, pTraceValues->_lpszFnName, Variable);
    }

    /*
     * refresh the last error, in case it was nuked  
     */
    ::SetLastError(lastError);
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
VOID CTracer::TracePrintError(IN DWORD Error, IN TraceValues *pTraceValues)
/* ++ Displays a string of the form: {pTraceValues->_lpszFnName}: error 87 [ERROR_INVALID_PARAMETER] */
{
    /*~~~~~~~~~~~~~~~~~~*/
    LPSTR    errstr;
    char    hexnumBuf[15];
    DWORD lastError;
    /*~~~~~~~~~~~~~~~~~~*/

    // Preserve error code:
    lastError = ::GetLastError();
    
    errstr = InternetMapError(Error);
    if((errstr == NULL) || (*errstr == '?'))
    {
        wsprintf(hexnumBuf, "%#x", Error);
        errstr = hexnumBuf;
    }

    TracePrint(pTraceValues->_dwPrefix, "%s: error %d [%s]\r\n", pTraceValues->_lpszFnName, Error, errstr);

    // Preserve error code:
    ::SetLastError(lastError);
}

#define TRACE_PRINT_COMMON_CODE() \
    char  buf[PRINTF_STACK_BUFFER_LENGTH]; \
    LPSTR                                bufptr; \
    bufptr = TraceSetPrefix(buf, dwPrefix); \
    if(bufptr == NULL) \
    { \
        return; \
    } \
 \
    /* now append the string that the TRACE_PRINT originally gave us */ \
    va_list list; \
    va_start(list, Format); \
    _sprintf(bufptr, PRINTF_STACK_BUFFER_LENGTH - 1 - (bufptr - buf), Format, list); \
    va_end(list); \
    TraceOut(buf)

/*
 =======================================================================================================================
 =======================================================================================================================
 */
VOID CTracer::TracePrint(IN DWORD dwPrefix, IN LPSTR Format, ...)
{
    TRACE_PRINT_COMMON_CODE();
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
VOID CTracer::TracePrint2(IN LPSTR Format, ...)
{
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    LPINTERNET_THREAD_INFO    lpThreadInfo = InternetGetThreadInfo();
    long                    dwPrefix = -1;
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    if(lpThreadInfo)
    {
        BOOL    a_isLocal; 
        BOOL    a_isAsync; 
        if((lpThreadInfo->hObjectMapped) && RIsHandleLocal((lpThreadInfo->hObjectMapped), &a_isLocal, &a_isAsync, TypeHttpRequestHandle) == ERROR_SUCCESS) 
        { 
            dwPrefix = ((HTTP_REQUEST_HANDLE_OBJECT *) ((lpThreadInfo->hObjectMapped)))->GetRequestId(); 
        } 
    }

    TRACE_PRINT_COMMON_CODE();
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
VOID CTracer::TracePrintString(IN LPSTR String, IN long dwPrefix /* = -1 */ )
/* ++ Same as TracePrint(), except we perform no expansion on the string String - already formatted string */
{
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    char    buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR    bufptr;
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    bufptr = TraceSetPrefix(buf, dwPrefix);
    if(bufptr == NULL)
    {
        return;
    }

    // truncate string if needed:
    int copyLen = min((int) strlen(String) + 1, (int)(PRINTF_STACK_BUFFER_LENGTH - 1 - (bufptr - buf) + 1));
    /*
     *  
     * now append the string:
     */
    strncpy(bufptr, String, copyLen);

    TraceOut(buf);
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
VOID CTracer::TraceOut(IN LPSTR Buffer)
/* ++ Writes a string somewhere - to the trace log file, to the debugger, or any combination Buffer - pointer to formatted buffer to write */
{
    /*~~~~~~~~~~~~*/
    int        buflen;
    DWORD    written;
    /*~~~~~~~~~~~~*/

    buflen = strlen(Buffer);

    __try
    {
        ::EnterCriticalSection(&_CriticalSection);     
        if((_traceControlFlags & DBG_TO_FILE) && (_traceFileHandle != INVALID_HANDLE_VALUE))
        {
            if(_dwWritten + buflen >= s_dwMaxFileSize)
            {
                /* Truncate to beginning: */
                _dwWritten = 0;
                SetFilePointer
                (
                    _traceFileHandle,    /* handle to file */
                    0,                    /* bytes to move pointer */
                    0,                    /* bytes to move pointer */
                    FILE_BEGIN            /* starting point */
                );
                SetEndOfFile(_traceFileHandle); /* Truncate file */

                /* Recursive call to print a FILE_TRUNCATED_MESSAGE: */
                TracePrint2(FILE_TRUNCATED_MESSAGE, s_dwMaxFileSize);
            }

            WriteFile(_traceFileHandle, Buffer, buflen, &written, NULL);
            _dwWritten += written;
        }

        if(_traceControlFlags & DBG_TO_DEBUGGER)
        {
            OutputDebugString(Buffer);
        }
    }
    __finally
    {
        ::LeaveCriticalSection(&_CriticalSection);
    }
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
VOID CTracer::TraceDump(IN LPSTR Text, IN LPBYTE Address, IN DWORD Size, IN long dwPrefix /* = -1 */ )
/* ++ Dumps Size bytes at Address Arguments: Text - to display before dumping data Address - start of buffer Size - number of bytes */
{
    /*~~~~*/
    int len;
    char buf[256];
    /*~~~~*/


    if(_traceControlFlags & DBG_NO_DATA_DUMP)
    {
        // A real _crude_ test for header data:
        if(Text && !strcmp(Text, "received data:\n"))
        {
            if(Address && !strncmp((LPCSTR)Address, "HTTP/", 5))
                ;
            else
            {
                return;
            }
        }
        else if(Text && !strcmp(Text, "sending data:\n"))
        {
            // TODO: Add other verbs:
            if(Address && (!strncmp((LPCSTR)Address, "GET ", 4) || !strncmp((LPCSTR)Address, "POST ", 5) 
                || !strncmp((LPCSTR)Address, "PUT ", 4) || !strncmp((LPCSTR)Address, "PROPFIND ", 9)))
                ;
            else
            {
                return;
            }
        }

    }
    
    /*
     *  
     * display the introduction text, if any  
     */
    if(Text)
    {
        TracePrint(dwPrefix, Text);
    }

    /*
     *  
     * display a line telling us how much data there is  
     */
    wsprintf(buf, "%d (%#x) bytes\r\n", Size, Size);
    TracePrintString(buf, dwPrefix);

    if(_traceControlFlags & DBG_NO_SHOWBYTES)
    {
        TracePrintString
        (
            "<<<<-------- HTTP stream follows below ----------------------------------------------->>>>\r\n",
            dwPrefix
        );
    }
    else if(_traceControlFlags & DBG_NO_DATA_DUMP)
    {
        TracePrintString
        (
            "<<<<-------- HTTP headers follow below ----------------------------------------------->>>>\r\n",
            dwPrefix
        );
    }

    if(_traceControlFlags & DBG_NO_DATA_DUMP)
    {
        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
        /* Find the header demarkation, which is two CR-LF pairs: */
        LPBYTE    pLineBrk = (LPBYTE) (strnstr((LPSTR) (Address), Size, "\r\n\r\n"));
        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

        if(pLineBrk)
        {
            /*
             * Only headers, so reduce Size:  
             * Note: Pointer arithmetic returns a __int64 for IA64,  
             * don't think we're going to try to dump more than 2^32  
             * worth of data, so explicit-casting:
             */
            Size = (DWORD) (pLineBrk - Address);
        }
    }

    __try
    {
        ::EnterCriticalSection(&_CriticalSection);     

        if(_traceControlFlags & DBG_NO_SHOWBYTES || _traceControlFlags & DBG_NO_DATA_DUMP)
        {
            /* First line's prefix printing: */
            TracePrintString("", dwPrefix);
        }

        /*
         *  
         * dump out the data  
         */
        while(Size)
        {
            if(_traceControlFlags & DBG_NO_SHOWBYTES || _traceControlFlags & DBG_NO_DATA_DUMP)
            {
                len = TraceDumpText(Address, Size, buf, sizeof(buf) - 1, dwPrefix);
                TraceOut(buf);
            }
            else
            {
                len = TraceDumpFormat(Address, Size, sizeof(BYTE), buf);

                /* add std prefixes: */
                TracePrintString(buf, dwPrefix);
            }

            Address += len;
            Size -= len;
        }

        if(_traceControlFlags & DBG_NO_SHOWBYTES || _traceControlFlags & DBG_NO_DATA_DUMP)
        {
            TraceOut("\r\n");
            TracePrintString("<<<<-------- End ----------------------------------------------->>>>\r\n", dwPrefix);
        }
    }
    __finally
    {
        ::LeaveCriticalSection(&_CriticalSection);
    }
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
DWORD CTracer::TraceDumpFormat(IN LPBYTE Address, IN DWORD Size, IN DWORD ElementSize, OUT LPSTR Buffer)
/* ++ Formats Size bytes at Address, in the time-honoured debug tradition, for data dump purposes Arguments: Address - start of buffer Size - number of bytes ElementSize - size of each word element in bytes Buffer - pointer to output buffer, assumed to be large enough Return Value: DWORD - number of bytes formatted */
{
    /*~~~~~~~~~~~~~~~~*/
    DWORD    offset;
    static char spaces[] = "                                               ";    /* 15 * 3 + 2 */
    int i, len;
    /*~~~~~~~~~~~~~~~~*/

    /*
     *  
     * we (currently) only understand DWORD, WORD and BYTE dumps  
     */
    if((ElementSize != sizeof(DWORD)) && (ElementSize != sizeof(WORD)))
    {
        ElementSize = sizeof(BYTE);
    }

    len = min(Size, 16);
    if (sizeof(Address) > 4)
    {
        wsprintf(Buffer, "%016x  ", (UINT_PTR)Address);
        offset = 18;
    } 
    else
    {
        wsprintf(Buffer, "%08x  ", (UINT_PTR)Address);
        offset = 10;
    }
    

    /*
     *  
     * dump the hex representation of each character or word - up to 16 per line  
     */
    for(i = 0; i < len; i += ElementSize)
    {
        /*~~~~~~~~~~~~~~~~~*/
        DWORD    value;
        LPSTR    formatString;
        /*~~~~~~~~~~~~~~~~~*/

        switch(ElementSize)
        {
        case 4:        formatString = "%08x "; value = *(LPDWORD) & Address[i]; break;

        case 2:        formatString = "%04x "; value = *(LPWORD) & Address[i] & 0xffff; break;

        default:    formatString = ((i & 15) == 7) ? "%02.2x-" : "%02.2x "; value = Address[i] & 0xff; break;
        }

        wsprintf(&Buffer[offset], formatString, value);
        offset += ElementSize * 2 + 1;
    }

    /*
     *  
     * write as many spaces as required to tab to ASCII field  
     */
    memcpy(&Buffer[offset], spaces, (16 - len) * 3 + 2);
    offset += (16 - len) * 3 + 2;

    /*
     *  
     * dump ASCII representation of each character  
     */
    for(i = 0; i < len; ++i)
    {
        /*~~~~~~~*/
        char    ch;
        /*~~~~~~~*/

        ch = Address[i];
        Buffer[offset + i] = ((ch < 32) || (ch > 127)) ? '.' : ch;
    }

    Buffer[offset + i++] = '\r';
    Buffer[offset + i++] = '\n';
    Buffer[offset + i] = '\0';

    return len;
}

#define PREFIX_MAX_SIZE 36

/*
 =======================================================================================================================
 =======================================================================================================================
 */

DWORD CTracer::TraceDumpText
(
    IN LPBYTE    Address,
    IN DWORD    Size,
    OUT LPSTR    Buffer,
    IN DWORD    BufferSize,
    IN long        dwPrefix    /* = -1 */
)
{
    /*~~~~~~~~~~~~~~*/
    int        i, j, len;
    char    ch;
    /*~~~~~~~~~~~~~~*/

    len = min(Size, BufferSize - PREFIX_MAX_SIZE);

    /*
     *  
     * dump ASCII representation, while converting non-printable characters into '.'  
     */
    for(i = 0, j = 0; j < len; i++, j++)
    {
        ch = Address[i];
        if(ch == '\n')
        {
            /*
             * Add in a prefix to each line:  
             * The body portion may not necessarily contain \r\n combinations.  
             * File I/O requires a \r\n to work correctly,  
             * so add it in (extra \r's should be ignored, but some editors treat them as \n, 
             * so we're trying to add less of those in. Notepad works correctly with extra \r's):
             */

            if(i && Address[i-1] != '\r')
                Buffer[j++] = '\r';
            Buffer[j++] = '\n';
            /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
            LPSTR    bufptr = TraceSetPrefix(&Buffer[j], dwPrefix);
            /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
            j += (int) (bufptr - &Buffer[j]) - 1;
        }
        else
            Buffer[j] = ((ch < 32 && ch != '\r') || (ch > 127)) ? '.' : ch;
    }

    Buffer[j] = '\0';

    return i;
}

/*
 =======================================================================================================================
    static
 =======================================================================================================================
 */
LPSTR CTracer::TraceSetPrefix(IN LPSTR Buffer, IN long dwPrefix /* = -1 */ )
{
    /*~~~~~~~~~~~~~~~~*/
    SYSTEMTIME    timeNow;
    /*~~~~~~~~~~~~~~~~*/

    ::GetLocalTime(&timeNow);

    Buffer += wsprintf
        (
            Buffer,
            "%02d:%02d:%02d.%03d ::",
            timeNow.wHour,
            timeNow.wMinute,
            timeNow.wSecond,
            timeNow.wMilliseconds
        );

    /*
     *  
     * Prefix Tag ID, can be used to filter via grep or some such:  
     */
    if(dwPrefix != -1)
        Buffer += wsprintf(Buffer, "*%07x* ::", dwPrefix);
    else
        Buffer += wsprintf(Buffer, "*Session* ::");

    *Buffer++ = ' ';
    return Buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\ssocket.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ssocket.cxx

Abstract:

    Contains secure sockets functions and ICSecureSocket methods

    Contents:
        SecurityPkgInitialize
        ReadCertificateIntoCertInfoStruct
        ChkCertificateCommonNameIsValid
        ChkCertificateExpired
        ICSecureSocket::ICSecureSocket
        ICSecureSocket::~ICSecureSocket
        ICSecureSocket::Connect
        CFsm_SecureConnect::RunSM
        ICSecureSocket::Connect_Fsm
        ICSecureSocket::SecureHandshakeWithServer
        CFsm_SecureHandshake::RunSM
        ICSecureSocket::SecureHandshake_Fsm
        ICSecureSocket::NegotiateSecConnection
        CFsm_SecureNegotiate::RunSM
        ICSecureSocket::SecureNegotiate_Fsm
        ICSecureSocket::SSPINegotiateLoop
        CFsm_NegotiateLoop::RunSM
        ICSecureSocket::NegotiateLoop_Fsm
        ICSecureSocket::Disconnect
        ICSecureSocket::Send
        CFsm_SecureSend::RunSM
        ICSecureSocket::Send_Fsm
        ICSecureSocket::Receive
        CFsm_SecureReceive::RunSM
        ICSecureSocket::Receive_Fsm
        ICSecureSocket::SetHostName
        (ICSecureSocket::EncryptData)
        (ICSecureSocket::DecryptData)
        (ICSecureSocket::TerminateSecConnection)
        ICSecureSocket::GetCertInfo

Author:

    Richard L Firth (rfirth) 08-Apr-1997

Environment:

    Win32 user mode

Revision History:

    08-Apr-1997 rfirth
        Created from ixport.cxx

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include <ierrui.hxx>

extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsecapi.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <softpub.h>

}


#ifdef SECPKG_ATTR_PROTO_INFO
PRIVATE
LPTSTR
ProtoInfoToString(
    IN const PSecPkgContext_ProtoInfo pProtoInfo);
#endif

//
// general security package functions
//
BOOL
SecurityPkgInitialize(
    SECURITY_CACHE_LIST *pSessionCache,
    BOOL fForce
    )
/*++

Routine Description:

    This function finds a list of security packages that are supported
    on the client's machine, check if ssl is supported, and
    create a credential handle for each supported pkg.

Arguments:

    None

Return Value:

    TRUE if at least one security pkg is found; otherwise FALSE

--*/
{
    TimeStamp         tsExpiry;
    SECURITY_STATUS   scRet;
    PSecPkgInfo       pPackageInfo = NULL;
    ULONG             cPackages;
    ULONG             fCapabilities;
    ULONG             i;
    ULONG             j;
    DWORD             cProviders = 0;
    PSEC_PROVIDER     pSecProviders = NULL;

    if (!pSessionCache)
        return FALSE;

    pSecProviders = pSessionCache->GetSecProviders();

    SCHANNEL_CRED DefaultCredData = {SCHANNEL_CRED_VERSION,
                                     0,
                                     NULL,
                                     0,
                                     0,
                                     NULL,
                                     0,
                                     NULL,
                                     SP_PROT_CLIENTS,
                                     0,
                                     0,
                                     0,
                                     SCH_CRED_MANUAL_CRED_VALIDATION |
                                     SCH_CRED_NO_DEFAULT_CREDS
                                    };

    //
    //  check if this routine has been called.  if yes, return TRUE
    //  if we've found a supported pkg; otherwise FALSE
    //

    if ( pSessionCache->GetEncFlags() == ENC_CAPS_NOT_INSTALLED )
       return FALSE;
    else if ((pSessionCache->GetEncFlags() & ENC_CAPS_TYPE_MASK) && !fForce)
       return TRUE;

    //
    //  Initialize EncFlags
    //

    pSessionCache->SetEncFlags(ENC_CAPS_NOT_INSTALLED);

    //
    //  Check if at least one security package is supported
    //


    scRet = g_EnumerateSecurityPackages( &cPackages,
                                         &pPackageInfo );

    if ( scRet != STATUS_SUCCESS )
    {
        DEBUG_PRINT(API,
                    ERROR,
                    ("EnumerateSecurityPackages failed, error %lx\n",
                    scRet
                    ));

        SetLastError( scRet );
        return FALSE;
    }

    for ( i = 0; i < cPackages ; i++ )
    {
        //
        //  Use only if the package name is the PCT/SSL package
        //

        fCapabilities = pPackageInfo[i].fCapabilities;

        if ( fCapabilities & SECPKG_FLAG_STREAM )
        {
            //
            //  Check if the package supports server side authentication
            //  and all recv/sent messages are tamper proof
            //

            if ( fCapabilities & SECPKG_FLAG_CLIENT_ONLY ||
                 !(fCapabilities & SECPKG_FLAG_PRIVACY ))
            {
                continue;
            }

            //
            //  Check if the pkg matches one of our known packages
            //

            for ( j = 0; pSecProviders[j].pszName != NULL; j++ )
            {
                if ( !stricmp( pPackageInfo[i].Name, pSecProviders[j].pszName ) )
                {
                    CredHandle OldCred;
                    PVOID pCredData = NULL;

                    //
                    //  Create a credential handle for each supported pkg
                    //

                    INET_ASSERT((pSecProviders[j].dwFlags & ENC_CAPS_SCHANNEL_CREDS));

                    pCredData = &DefaultCredData;

                    if (pSecProviders[j].pCertCtxt != NULL) {
                        DefaultCredData.cCreds = 1;
                        DefaultCredData.paCred = &pSecProviders[j].pCertCtxt;
                    }

                    //
                    // Enable Supported protocols in the Default Cred Data, then acquire the Credential
                    //

                    DefaultCredData.grbitEnabledProtocols = (pSessionCache->GetSecureProtocols() &
                                                             pSecProviders[j].dwProtocolFlags);

                    OldCred.dwUpper = pSecProviders[j].hCreds.dwUpper;
                    OldCred.dwLower = pSecProviders[j].hCreds.dwLower;

                    // Zero out previous credentials
                    pSecProviders[j].hCreds.dwUpper = pSecProviders[j].hCreds.dwLower = 0;

                    WRAP_REVERT_USER(g_AcquireCredentialsHandle,
                                     pSessionCache->IsImpersonationEnabled(),
                                     (NULL,
                                      pSecProviders[j].pszName, // Package
                                      SECPKG_CRED_OUTBOUND,
                                      NULL,
                                      pCredData,
                                      NULL,
                                      NULL,
                                      &(pSecProviders[j].hCreds), // Handle
                                      &tsExpiry),
                                     scRet);

                    if(!IS_CRED_INVALID(&OldCred))
                    {
                        WRAP_REVERT_USER_VOID(g_FreeCredentialsHandle,
                                              pSessionCache->IsImpersonationEnabled(),
                                              (&OldCred));
                    }

                    DefaultCredData.cCreds = 0;
                    DefaultCredData.paCred = NULL;

                    if ( scRet != STATUS_SUCCESS )
                    {
                        DEBUG_PRINT(API,
                                    WARNING,
                                    ("AcquireCredentialHandle failed, error %lx\n",
                                    scRet
                                    ));

                        pSecProviders[j].fEnabled = FALSE;

                        pSecProviders[j].hCreds.dwUpper = 0xffffffff;
                        pSecProviders[j].hCreds.dwLower = 0xffffffff;


                    }
                    else
                    {
                        DEBUG_PRINT(
                             API,
                             INFO,
                             ("AcquireCredentialHandle() supports %s, acquires %x:%x\n",
                             pSecProviders[j].pszName,
                             pSecProviders[j].hCreds.dwUpper,
                             pSecProviders[j].hCreds.dwLower
                             ));

                        pSecProviders[j].fEnabled = TRUE;
                        cProviders++;
                        pSessionCache->SetEncFlags(pSessionCache->GetEncFlags() |
                                                   pSecProviders[j].dwFlags);
                    }
                }
            }
        }
    }

    if (pPackageInfo)
    {
        g_FreeContextBuffer( (LPVOID) pPackageInfo );
    }

    if ( !cProviders )
    {
        //
        //  No security packages were found, return FALSE to caller
        //

        DEBUG_PRINT(API,
                    ERROR,
                    ("No security packages were found, error %lx\n",
                    SEC_E_SECPKG_NOT_FOUND
                    ));

        SetLastError( (DWORD) SEC_E_SECPKG_NOT_FOUND );

        return FALSE;
    }

    //
    //  Successfully found a security package(s)
    //

    return TRUE;
}


DWORD
QuerySecurityInfo(
                  IN CtxtHandle *hContext,
                  OUT LPINTERNET_SECURITY_INFO pInfo,
                  IN LPDWORD lpdwStatusFlag)
{
    SECURITY_STATUS      scRet;

    scRet = g_QueryContextAttributes(hContext,
                                     SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                     &pInfo->pCertificate );

    if (scRet == ERROR_SUCCESS)
    {
        scRet = g_QueryContextAttributes(hContext,
                                     SECPKG_ATTR_CONNECTION_INFO,
                                     &pInfo->dwProtocol );

        if (scRet == ERROR_SUCCESS)
        {
            pInfo->dwSize = sizeof(INTERNET_SECURITY_INFO);
        }
    }
    
    if (scRet != ERROR_SUCCESS)
    {
        //
        // Map the SSPI error.
        //
        return MapInternetError((DWORD) scRet, lpdwStatusFlag);
    }
    return ERROR_SUCCESS;
}


LONG WinVerifySecureChannel(HWND hwnd, WINTRUST_DATA *pWTD, BOOL fNoRevert)
/*++

Routine Description:

    Wininet's wrapper for secure channel WinVerifyTrust calls.

Arguments:

    hWnd - in case WinVerifyTrust needs to do UI.
    pWTD - pointer to WINTRUST_DATA containing details about the
           secure channel. Passed to WinVerifyTrust.
Return Value:

    WIN32 error code.

--*/
{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    BOOL async = FALSE;
    LONG  lResult;
    GUID  gHTTPS = HTTPSPROV_ACTION;

    if (lpThreadInfo != NULL) {
        async = _InternetGetAsync(lpThreadInfo);
        _InternetSetAsync(lpThreadInfo, FALSE);
    }

    WRAP_REVERT_USER(g_WinVerifyTrust, fNoRevert, (hwnd, &gHTTPS, pWTD), lResult);

    DEBUG_PUT(("WinVerifyTrust returned: %x\n", lResult));

    if (lpThreadInfo != NULL) {
        _InternetSetAsync(lpThreadInfo, async);
    }
    return lResult;
}


//
// ICSecureSocket methods
//


ICSecureSocket::ICSecureSocket(void)

/*++

Routine Description:

    ICSecureSocket constructor

Arguments:


Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSecureSocket::ICSecureSocket",
                 "{%#x}",
                 this
                 ));

    SIGN_SECURE_SOCKET();

    m_hContext.dwLower = m_hContext.dwUpper = 0;
    m_dwProviderIndex = 0;
    m_dwFlags |= SF_SECURE;
    m_lpszHostName = NULL;
    m_pdblbufBuffer = NULL;
    m_pSecurityInfo = NULL;
    m_pCertCache    = NULL;

    m_fIsSecureSocket = TRUE;

    DEBUG_LEAVE(0);
}


ICSecureSocket::~ICSecureSocket()

/*++

Routine Description:

    ICSecureSocket destructor. Virtual function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSecureSocket::~ICSecureSocket",
                 "{%#x [%q, sock=%#x, port=%d]}",
                 this,
                 GetHostName(),
                 GetSocket(),
                 GetSourcePort()
                 ));

    CHECK_SECURE_SOCKET();

    if (IsSecure())
    {
        if (m_pdblbufBuffer != NULL) {
            delete m_pdblbufBuffer;
        }

        // Free security context associated with this object if it's
        // still allocated.
        TerminateSecConnection();


        /* SCLE ref */
        SetSecurityEntry(NULL);
        if (m_lpszHostName != NULL) {
            m_lpszHostName = (LPSTR)FREE_MEMORY(m_lpszHostName);
            INET_ASSERT(m_lpszHostName == NULL);
        }
        //if ( _pCertChainList )
        //    delete _pCertChainList;
    }

    if (m_pCertCache)
        m_pCertCache->Release();

    DEBUG_LEAVE(0);
}


DWORD
ICSecureSocket::Connect(
    IN LONG ConnectTimeout,
    IN INT Retries,
    IN LONG SendTimeout,
    IN LONG RecvTimeout,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Initiate secure connection with server

Arguments:

    Timeout - maximum amount of time (mSec) to wait for connection

    Retries - maximum number of attempts to connect

    dwFlags - flags controlling request

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Connect",
                 "{%#x [%#x]} %d, %d, %#x",
                 this,
                 m_Socket,
                 ConnectTimeout,
                 Retries,
                 dwFlags
                 ));

    DWORD error;

    // might be http CONNECT that will morph into an established tunnel
    if (IsSecure())
    {
        error = DoFsm(New CFsm_SecureConnect(ConnectTimeout,
                                               Retries,
                                               SendTimeout,
                                               RecvTimeout,
                                               dwFlags,
                                               this
                                               ));
    }
    else
    {
        // thunk to non-secure connect
        error = ICSocket::Connect(ConnectTimeout,
                                  Retries,
                                  dwFlags
                                  );
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureConnect::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureConnect::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureConnect * stateMachine = (CFsm_SecureConnect *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->Connect_Fsm(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = Fsm->GetError();
        INET_ASSERT (error == ERROR_WINHTTP_OPERATION_CANCELLED);
        Fsm->SetDone();
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Connect_Fsm(
    IN CFsm_SecureConnect * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Connect_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureConnect & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto connect_continue;

        case FSM_STATE_3:
            goto negotiate_continue;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    m_dwProviderIndex = 0;

    //
    // Hack for SSL2 Client Hello, set to FALSE,
    //  but if we fail on the first recv, fReOpenSocket
    //  is set to TRUE.
    //

    do {

        //
        // Attempt to do the connect
        //

        fsm.SetFunctionState(FSM_STATE_2);
        error = ICSocket::Connect(fsm.m_ConnectTimeout, fsm.m_Retries, fsm.m_dwFlags);

connect_continue:

        if (error != ERROR_SUCCESS) {
            break;
        }

        // enable send and receive timeout - ignore any errors
        // these timeouts need to be set before the SecureHandshakeWithServer
        // call. If not, then a hang can occur if the app attempts to open
        // an SSL connection on the wrong port (bug 503467).
        SetTimeout(SEND_TIMEOUT, fsm.m_SendTimeout);
        SetTimeout(RECEIVE_TIMEOUT, fsm.m_RecvTimeout);

        if (m_dwFlags & SF_ENCRYPT) {
            fsm.SetFunctionState(FSM_STATE_3);
            error = SecureHandshakeWithServer(fsm.m_dwFlags, &fsm.m_bAttemptReconnect);
            if (error == ERROR_IO_PENDING) {
                break;
            }

negotiate_continue:

            //
            // SSL2 hack for old IIS servers.
            //  We re-open the socket, and call again.
            //

            if ((error != ERROR_SUCCESS) && fsm.m_bAttemptReconnect) {
                Disconnect(fsm.m_dwFlags);
            }
        }
    } while (fsm.m_bAttemptReconnect);

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
        if ((error != ERROR_SUCCESS) && IsOpen()) {
            Disconnect(fsm.m_dwFlags);
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SecureHandshakeWithServer(
    IN DWORD dwFlags,
    OUT LPBOOL lpbAttemptReconnect
    )

/*++

Routine Description:

    For SSL/PCT or some secure channel this function attempts to use
    an arbitrary Socket for handshaking with a server. The assumption
    is made that caller can recall this function on failure

Arguments:

    dwFlags             -

    lpbAttemptReconnect -

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Dword,
                "ICSecureSocket::SecureHandshakeWithServer",
                "%#x, %#x [%B]",
                dwFlags,
                lpbAttemptReconnect,
                *lpbAttemptReconnect
                ));

    INET_ASSERT(IsSecure());

    DWORD error = DoFsm(New CFsm_SecureHandshake(dwFlags,
                                                 lpbAttemptReconnect,
                                                 this
                                                 ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureHandshake::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureHandshake::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureHandshake * stateMachine = (CFsm_SecureHandshake *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->SecureHandshake_Fsm(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = Fsm->GetError();
        INET_ASSERT (error == ERROR_WINHTTP_OPERATION_CANCELLED);
        Fsm->SetDone();
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}

// LARGE_INTEGER l_freq;


DWORD
ICSecureSocket::SecureHandshake_Fsm(
    IN CFsm_SecureHandshake * Fsm
    )
{


    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SecureHandshake_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureHandshake & fsm = *Fsm;
    DWORD error = fsm.GetError();
    DWORD dwSecureFlags;

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto negotiate_continue;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    //INET_ASSERT(fsm.m_dwFlags & SF_ENCRYPT);
    INET_ASSERT(m_Socket != INVALID_SOCKET);

    *fsm.m_lpbAttemptReconnect = FALSE;

    error = ERROR_SUCCESS;

    //
    // Save Off Flags in our Internal Object.
    //   Treat SF_ENCRYPT just like SF_DECRYPT
    //

    m_dwFlags |= SF_DECRYPT;
    m_dwFlags |= fsm.m_dwFlags;

    INET_ASSERT(!(m_dwFlags
                & ~(SF_NON_BLOCKING
                    | SF_SECURE
                    | SF_ENCRYPT
                    | SF_DECRYPT
                    | SF_INDICATE
                    | SF_SENDING_DATA
                    | SF_OVERLAPPED
                    | SF_AUTHORIZED // In the SSL tunnel case, after proxy auth the socket would have been
                                    // marked "Authorized"; we carry this flag while doing handshake since
                                    // it won't interfere with the handshake at all.
                    )));

    //
    // Allocate Internal Buffer for SSL/PCT data.
    //

    if (m_pdblbufBuffer == NULL) {

        BOOL fInitSuccess;

        m_pdblbufBuffer = New DBLBUFFER();
        if (m_pdblbufBuffer == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        fInitSuccess = m_pdblbufBuffer->InitBuffer(TRUE);
        if (!fInitSuccess) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
    }

    //
    //  EncFlags is a global flag set to the
    //  supported security pkg mask
    //

    if (!LOCK_SECURITY())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if (m_pCertCache->GetEncFlags() == ENC_CAPS_NOT_INSTALLED) {
         error = (DWORD)SEC_E_SECPKG_NOT_FOUND;
    } else if (m_pCertCache->GetEncFlags() == 0 ||
               m_dwSecureProtocols != m_pCertCache->GetSecureProtocols()) {


         //
         //  first time thru, do the load.
         //

         DEBUG_PRINT(SOCKETS,
                     INFO,
                     ("Loading security dll\n"
                     ));

        if ( !SecurityPkgInitialize(m_pCertCache) ) {
             error = GetLastError();
             UNLOCK_SECURITY();
             goto quit;
        }
    }

    UNLOCK_SECURITY();

    if ( error != ERROR_SUCCESS )
    {
        goto quit;
    }


    //
    // If we succeed in loading or and initalizing the Security DLLs, we
    //      attempt to negotiate the connection
    //

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("Negotiate secure channel\n"
                ));

    //
    // Turn of Encryption/Decryption before the handshake,
    // since the NegotiateSecConnection does its own Send and Recvs
    // of specialized data.
    //

    m_dwFlags &= ~(SF_ENCRYPT | SF_DECRYPT);
    fsm.SetFunctionState(FSM_STATE_2);
    error = NegotiateSecConnection(fsm.m_dwFlags,
                                   fsm.m_lpbAttemptReconnect
                                   );
    if (error == ERROR_IO_PENDING) {
        goto quit;
    }

negotiate_continue:

    m_dwFlags |= (SF_ENCRYPT | SF_DECRYPT);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    //  Find out what size Key we're using, and set the flags
    //   acordingly.
    //

    dwSecureFlags = 0;
    
    BOOL fVerifyCert;
    
    if (m_pSecurityInfo == NULL || !m_pSecurityInfo->InCache())
    {
        fVerifyCert = TRUE;
    }
    else // m_pSecurityInfo->InCache()
    {
        fVerifyCert = !IsSameFingerPrint(m_pSecurityInfo->GetSecInfo().pCertificate);
    }

    if (fVerifyCert) {
        error = VerifyTrust();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }
    else
    {
        // RAID 596321: Here we are sure we are talking to the same server whose certificate
        // we've verified before. However it's possible that the certificate has expired or
        // been revoked since last time we checked. Therefore if the application cares about 
        // certifciate expiration or revocation checking, we need to re-verify the trust.
        
        INET_ASSERT(m_pSecurityInfo);

        // BOOL fQ = QueryPerformanceFrequency(&l_freq);
        // INET_ASSERT(fQ);

        if (m_pSecurityInfo->GetSecureFlags() & SECURITY_FLAG_CHECK_REVOCATION)
        {
            error = ReVerifyTrust(SECURITY_FLAG_CHECK_REVOCATION);
            if (error != ERROR_SUCCESS) 
            {
                goto quit;
            }
        }
        if (!(m_pSecurityInfo->GetSecureFlags() & SECURITY_FLAG_IGNORE_CERT_DATE_INVALID))
        {

#define SECURITY_FLAG_CHECK_EXPIRATION 0x00040000

            error = ReVerifyTrust(SECURITY_FLAG_CHECK_EXPIRATION);
            if (error != ERROR_SUCCESS) 
            {
                goto quit;
            }
        }
    }

    //
    // we've got a secure connection, set the flags.
    //

    SetSecure();

    if(m_pSecurityInfo)
    {
        INTERNET_SECURITY_INFO ciInfo;
        m_pSecurityInfo->CopyOut(ciInfo);

        if(ciInfo.dwCipherStrength < 56)
        {
            SetSecureFlags(SECURITY_FLAG_STRENGTH_WEAK);
        }
        else if(ciInfo.dwCipherStrength < 96)
        {
             SetSecureFlags(SECURITY_FLAG_STRENGTH_MEDIUM);
        }
        else
        {
             SetSecureFlags(SECURITY_FLAG_STRENGTH_STRONG);
        }
        if(ciInfo.pCertificate)
        {
            WRAP_REVERT_USER_VOID((*g_pfnCertFreeCertificateContext),
                                  m_pSecurityInfo->IsImpersonationEnabled(),
                                  (ciInfo.pCertificate));
            ciInfo.pCertificate = NULL;
        }
    }

quit:

    if (error != ERROR_IO_PENDING)
    {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}

BOOL ICSecureSocket::IsSameFingerPrint(PCCERT_CONTEXT pCachedCert)
{
    if (pCachedCert == NULL)
    {
        return FALSE;
    }

    BOOL fRet = FALSE;

    SECURITY_STATUS scRet;
    PCERT_CONTEXT pCert = NULL;

    BYTE Sig[32];
    DWORD dwSigLen = sizeof(Sig);

    BYTE CachedSig[32];
    DWORD dwCachedSig = sizeof(CachedSig);

    scRet = g_QueryContextAttributes(&m_hContext,
                                     SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                     &pCert);

    if (scRet != ERROR_SUCCESS)
    {
        goto exit;
    }

    if (g_pfnCertGetCertProperty(pCert,
                                 CERT_SIGNATURE_HASH_PROP_ID,
                                 Sig,
                                 &dwSigLen) == FALSE)
    {
        goto exit;
    }

    if (g_pfnCertGetCertProperty(pCachedCert,
                                 CERT_SIGNATURE_HASH_PROP_ID,
                                 CachedSig,
                                 &dwCachedSig) == FALSE)
    {
        goto exit;
    }

    if (dwSigLen != dwCachedSig)
    {
        goto exit;
    }

    if (::memcmp(Sig, CachedSig, dwSigLen) == 0)
    {
        fRet = TRUE;
    }

exit:
    if (pCert)
    {
        WRAP_REVERT_USER_VOID((*g_pfnCertFreeCertificateContext),
                              m_pSecurityInfo->IsImpersonationEnabled(),
                              (pCert));
    }
    return fRet;
}

DWORD ICSecureSocket::ReVerifyTrust(
    DWORD dwRecheckFlag // either SECURITY_FLAG_CHECK_EXPIRATION or 
                        //        SECURITY_FLAG_CHECK_REVOCATION
    )
{
    WINTRUST_DATA           sWTD;
    WINTRUST_CERT_INFO      sWTCI;
    HTTPSPolicyCallbackData polHttps;
    DWORD dwStatusFlags = 0;
    DWORD error = ERROR_SUCCESS;

    HINTERNET  hInternet = NULL;
    HINTERNET  hInternetMapped = NULL;
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;

    memset(&sWTCI, 0x00, sizeof(WINTRUST_CERT_INFO));
    sWTCI.cbStruct      = sizeof(WINTRUST_CERT_INFO);
    sWTCI.psCertContext = (CERT_CONTEXT *)m_pSecurityInfo->GetSecInfo().pCertificate;
    sWTCI.chStores      = 1;
    sWTCI.pahStores     = (HCERTSTORE *)&m_pSecurityInfo->GetSecInfo().pCertificate->hCertStore;

    memset(&polHttps, 0x00, sizeof(HTTPSPolicyCallbackData));
    polHttps.cbStruct   =  sizeof(HTTPSPolicyCallbackData);
    polHttps.dwAuthType = AUTHTYPE_SERVER;
    
    // this function only re-validate two cert properties (exipiry & revocation), so we ask CryptNet
    // to ignore irrelavant errors here.
    polHttps.fdwChecks  = SECURITY_FLAG_IGNORE_UNKNOWN_CA |
                          SECURITY_FLAG_IGNORE_CERT_CN_INVALID |
                          ((dwRecheckFlag == SECURITY_FLAG_CHECK_EXPIRATION) ? 
                          0 : 
                          SECURITY_FLAG_IGNORE_CERT_DATE_INVALID) |
                          SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE;

    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
    sWTD.cbStruct            = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice          = WTD_UI_NONE;
    sWTD.pPolicyCallbackData = (LPVOID)&polHttps;
    sWTD.dwUnionChoice       = WTD_CHOICE_CERT;
    sWTD.pCert               = &sWTCI;
    sWTD.pwszURLReference    = NULL;
    
    if (dwRecheckFlag == SECURITY_FLAG_CHECK_REVOCATION)
    {
        sWTD.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
        sWTD.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN;
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo != NULL)
    {
        hInternet = lpThreadInfo->hObject;
        hInternetMapped = lpThreadInfo->hObjectMapped;
    }

    // LARGE_INTEGER l_begin;
    // QueryPerformanceCounter(&l_begin);

    error = WinVerifySecureChannel(NULL, &sWTD, m_pSecurityInfo->IsImpersonationEnabled());
    
    // LARGE_INTEGER l_end;
    // QueryPerformanceCounter(&l_end);

    // LONGLONG llElapsedTime;
    // llElapsedTime = (*(LONGLONG *)&l_end) - (*(LONGLONG *)&l_begin);

    // DWORD dwFreq = (DWORD)(*(LONGLONG *)&l_freq);
    // DWORD dwDelta = (DWORD)llElapsedTime;

     //char output[64];
     //sprintf(output, "->delta->: %f (%x)\n", ((float)dwDelta/dwFreq)*1000, dwRecheckFlag);
     //OutputDebugStringA(output);
 
    error = MapInternetError(error, &dwStatusFlags);

    if (lpThreadInfo != NULL) 
    {
        _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
    }

    if (error != ERROR_SUCCESS)
    {
        if (dwStatusFlags & WINHTTP_CALLBACK_STATUS_FLAG_SECURITY_CHANNEL_ERROR)
        {
            m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_SECURITY_CHANNEL_ERROR);
        }
        else
        {
            if (!(polHttps.fdwChecks & SECURITY_FLAG_IGNORE_CERT_DATE_INVALID))
            {
                if (dwStatusFlags & WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID)
                {
                    m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID);
                }
                else
                {
                    // we are checking cert expiration; therefore we only expect the CERT_DATE_INVALID
                    // error if WinVerifyTrust fails.
                    INET_ASSERT(FALSE);
                }
            }
            else if (sWTD.fdwRevocationChecks == WTD_REVOKE_WHOLECHAIN)
            {
                if (dwStatusFlags & WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED)
                {
                    m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED);
                }
                else if (dwStatusFlags & WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED)
                {
                    m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED);
                }
                else
                {
                    // we are checking cert revocation; therefore we only expect the CERT_REV_FAILED
                    // or CERT_REVOKED error if WinVerifyTrust fails.
                    INET_ASSERT(FALSE);
                }
            }
            else
            {
                // this function only re-validate two cert properties (exipiry & revocation)
                INET_ASSERT(FALSE);
            }
        }

        if (m_pSecurityInfo->GetStatusFlags())
        {
            if (lpThreadInfo)
            {
                WINHTTP_STATUS_CALLBACK appCallback = NULL;
                RGetStatusCallback(hInternetMapped, &appCallback);
                if (appCallback)
                {
                    DWORD dwCertErrors = m_pSecurityInfo->GetStatusFlags();
                    // Report SSL status of all errors found
                    InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_SECURE_FAILURE,
                                            &dwCertErrors,
                                            sizeof(dwCertErrors)
                                            );

                }
            }
        }
    }

    return error;
}

DWORD
ICSecureSocket::VerifyTrust(
    )

/*++

Routine Description:

    This function establishes a secure channel with the server by
    performing the security handshake protocol.  It will walk
    the list of installed security packages until it finds a package
    that succeeds in the security handshake.  If one package fails
    it is up to the caller to re-call NegotiateSecConnection with
    a re-opened socket so another socket can attempt the connection.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/
{

    // We've done our handshake, now update the security info
    INTERNET_SECURITY_INFO ciCert;
    DWORD dwCertFlags = 0;
    WINTRUST_DATA           sWTD;
    WINTRUST_CERT_INFO      sWTCI;
    HTTPSPolicyCallbackData polHttps;
    DWORD                   cbServerName;
    DWORD error;
    DWORD dwStatusFlag = 0;
    HINTERNET  hInternet = NULL;
    HINTERNET  hInternetMapped = NULL;
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;

    DWORD dwFlags = 0;    // HTTPS policy flags to ignore errors

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::VerifyTrust",
                 "{%#x",
                 this
                 ));

    // HACK HACK: 67640
    // WinVerifyTrust can do a nested HttpSendRequest which causes the hObject's on the 
    // thread to get messed up. This happens only when the ceritificate has a URL for 
    // a CRL in it. We save and restore these values to workaround the problem.
    // Need to work out a better solution to handle this but it is too close to ship to 
    // try anything with greater code impact. 
    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo != NULL)
    {
        hInternet = lpThreadInfo->hObject;
        hInternetMapped = lpThreadInfo->hObjectMapped;
    }

    error = QuerySecurityInfo(&m_hContext, &ciCert, &dwStatusFlag);
    if (error != ERROR_SUCCESS)
    {
        if (m_pSecurityInfo)
            m_pSecurityInfo->SetStatusFlags(dwStatusFlag);
        goto quit;
    }

    if(m_pSecurityInfo)
    {
        *m_pSecurityInfo = &ciCert;
        // Other flags have been filtered already, but make sure revocation
        // flag is removed, so it isn't passed to WVT.
        dwCertFlags = m_pSecurityInfo->GetSecureFlags() & ~SECURITY_FLAG_CHECK_REVOCATION;
    }
    if (ciCert.pCertificate == NULL)
    {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
    sWTD.cbStruct               = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice             = WTD_UI_NONE;
    sWTD.pPolicyCallbackData    = (LPVOID)&polHttps;
    sWTD.dwUnionChoice          = WTD_CHOICE_CERT;
    sWTD.pCert                  = &sWTCI;
    sWTD.pwszURLReference       = NULL;
    if (m_pSecurityInfo &&
        (m_pSecurityInfo->GetSecureFlags() & SECURITY_FLAG_CHECK_REVOCATION))
    {
        sWTD.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
    }
    else
    {
        sWTD.fdwRevocationChecks = 0;
    }

    memset(&sWTCI, 0x00, sizeof(WINTRUST_CERT_INFO));
    sWTCI.cbStruct              = sizeof(WINTRUST_CERT_INFO);
    sWTCI.psCertContext         = (CERT_CONTEXT *)ciCert.pCertificate;
    sWTCI.chStores              = 1;
    sWTCI.pahStores  = (HCERTSTORE *)&ciCert.pCertificate->hCertStore;


    memset(&polHttps, 0x00, sizeof(HTTPSPolicyCallbackData));
    polHttps.cbStruct =  sizeof(HTTPSPolicyCallbackData);
    polHttps.dwAuthType = AUTHTYPE_SERVER;
    polHttps.fdwChecks = dwCertFlags;
    
    cbServerName = MultiByteToWideChar(CP_ACP, 0, m_lpszHostName, -1, NULL, 0);

    polHttps.pwszServerName = New WCHAR[cbServerName+1];

    if(polHttps.pwszServerName == 0)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    sWTCI.pcwszDisplayName      = polHttps.pwszServerName;

    cbServerName = MultiByteToWideChar(CP_ACP, 0, m_lpszHostName, -1, polHttps.pwszServerName, cbServerName);

    error = LoadWinTrust();
    if(ERROR_SUCCESS == error)
    {
        error = WinVerifySecureChannel(NULL, &sWTD, m_pSecurityInfo->IsImpersonationEnabled());
    }

    error = MapInternetError(error, &dwStatusFlag);


    //
    // If there was problem with the certificate and the caller requested
    // combined SSL errors cycle through all possible certificate errors.
    //

    //  NOTENOTE:  windows RAID item 735826
    //  WinVerifyTrust's revocation checking was modified so that the core 
    //chain building code always checks if the end certificate is in the 
    //Untrusted store. Revocation checking doesn't need to be abled. If in 
    //the untrusted store, it sets the revoked bit regardless of if revocation
    //checking is disabled.  So in this case we will see the same error twice.
    //In this case we stop querying for errors to report to the WinHttp
    //client because the enumeration cannot continue.

    BOOL fNotifiedRevocation;
    fNotifiedRevocation = FALSE;

    if (ERROR_SUCCESS != error && m_pSecurityInfo)
    {
        BOOL  fCertError = FALSE;
        BOOL  fUseFQDN = FALSE;

        do
        {
            if (dwStatusFlag & WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA)
            {
                polHttps.fdwChecks |=  DLG_FLAGS_IGNORE_INVALID_CA;
                dwFlags |= DLG_FLAGS_INVALID_CA;
                m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA);
                if (!(dwCertFlags & SECURITY_FLAG_IGNORE_UNKNOWN_CA))
                    fCertError = TRUE;
            }
            else if (dwStatusFlag & WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID)
            {
                if (!fUseFQDN)
                {
                    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
                    if (lpThreadInfo)
                    {
                        INET_ASSERT(lpThreadInfo->hObjectMapped);
                        
                        SERIALIZED_LIST* pResolverCache = 
                            GetRootHandle((HANDLE_OBJECT*)lpThreadInfo->hObjectMapped)->GetResolverCache()->GetResolverCacheList();
                        
                        LPADDRINFO lpAddrInfo;
                        DWORD TTL;
                        LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry;
                        
                        if ((lpResolverCacheEntry=QueryResolverCache(pResolverCache,
                                                                     (LPSTR)m_lpszHostName, 
                                                                     NULL, 
                                                                     &lpAddrInfo, 
                                                                     &TTL)) != NULL) 
                        {
                            if (lpAddrInfo->ai_canonname)
                            {
                                cbServerName = MultiByteToWideChar(CP_ACP, 0, lpAddrInfo->ai_canonname, -1, NULL, 0);
                                LPWSTR lpwszFQDN = New WCHAR[cbServerName+1];
                                if (lpwszFQDN)
                                {
                                    delete [] polHttps.pwszServerName;
                                    polHttps.pwszServerName = lpwszFQDN;
                                    lpwszFQDN = NULL;

                                    sWTCI.pcwszDisplayName = polHttps.pwszServerName;
                                    cbServerName = MultiByteToWideChar(CP_ACP, 0, lpAddrInfo->ai_canonname, -1, polHttps.pwszServerName, cbServerName);

                                    fUseFQDN = TRUE;
                                }
                            }
                            ReleaseResolverCacheEntry(pResolverCache, lpResolverCacheEntry);
                        }
                    }
                
                    if (fUseFQDN)
                    {
                        goto win_verify_trust;
                    }
                }

                polHttps.fdwChecks |= DLG_FLAGS_IGNORE_CERT_CN_INVALID;
                dwFlags |= DLG_FLAGS_SEC_CERT_CN_INVALID;
                m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID);
                if (!(dwCertFlags & SECURITY_FLAG_IGNORE_CERT_CN_INVALID))
                    fCertError = TRUE;
            }
            else if (dwStatusFlag & WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID)
            {
                polHttps.fdwChecks |= DLG_FLAGS_IGNORE_CERT_DATE_INVALID;
                dwFlags |= DLG_FLAGS_SEC_CERT_DATE_INVALID;
                m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID);
                if (!(dwCertFlags & SECURITY_FLAG_IGNORE_CERT_DATE_INVALID))
                    fCertError = TRUE;
            }
            else if (dwStatusFlag & WINHTTP_CALLBACK_STATUS_FLAG_CERT_WRONG_USAGE)
            {
                polHttps.fdwChecks |= SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE;
                m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_CERT_WRONG_USAGE);
                if (!(dwCertFlags & SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE))
                    fCertError = TRUE;
            }
            else if (dwStatusFlag & WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CERT)
            {
                m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CERT);
                fCertError = TRUE;
                break;
            }
            else if (dwStatusFlag & WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED)
            {
                // In wininet, we break out on revoked and only pass it back.
                // This is because the UI is broken into only 2 buckets, and
                // revoked takes precedence.
                if (!fNotifiedRevocation)
                {
                    sWTD.fdwRevocationChecks = 0;
                    m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED);
                    fCertError = TRUE;
                    fNotifiedRevocation = TRUE;
                }
                else
                {
                    fCertError = TRUE;
                    break;
                }
            }
            else if (dwStatusFlag & WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED)
            {
                // In wininet, this was handled outside the loop as a special
                // case.  There's no need for that now, so OR the error in and
                // continue.
                sWTD.fdwRevocationChecks = 0;
                dwFlags |= DLG_FLAGS_SEC_CERT_REV_FAILED;
                m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED);
                fCertError = TRUE;
            }
            else
            {
                //
                // Pass all other errors through.
                //

                m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_SECURITY_CHANNEL_ERROR);
                fCertError = TRUE;

                break;
            }

win_verify_trust:

            error = WinVerifySecureChannel(NULL, &sWTD, m_pSecurityInfo->IsImpersonationEnabled());

            error = MapInternetError(error, &dwStatusFlag);

        } while (ERROR_SUCCESS != error);

        //
        // Change the error only if one of the known certifciate errors was
        // encountered.
        //

        if (m_pSecurityInfo->GetStatusFlags())
        {
            // Just send a status notification if there's an error,
            // and let the app decide if this should be closed as a failure.
            if (lpThreadInfo)
            {
                WINHTTP_STATUS_CALLBACK appCallback = NULL;
                RGetStatusCallback(hInternetMapped, &appCallback);
                if (appCallback)
                {
                    DWORD dwStatusFlags = m_pSecurityInfo->GetStatusFlags();
                    // Report SSL status of all errors found
                    InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_SECURE_FAILURE,
                                           &dwStatusFlags,
                                           sizeof(dwStatusFlags)
                                           );

                }
            }
            // ...except if the client told us upfront to fail.
            if (fCertError)
            {
                error = ERROR_WINHTTP_SECURE_FAILURE;
            }
            else
            {
                error = SUCCESS;
            }
            m_pSecurityInfo->SetSecureFlags(dwFlags);
        }
    }

    delete [] polHttps.pwszServerName;

    if(ciCert.pCertificate)
    {
        WRAP_REVERT_USER_VOID((*g_pfnCertFreeCertificateContext),
                              m_pSecurityInfo->IsImpersonationEnabled(),
                              (ciCert.pCertificate));
    }

    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    if(m_pSecurityInfo && (!m_pSecurityInfo->InCache()))
    {
        // Add it to the cache if it's not already there.
        /* SCLE ref */

        // This was mapped when initializing the socket with SetHostName
        if (m_pCertCache)
            m_pCertCache->Add(m_pSecurityInfo);
    }

quit:                                 
    if (lpThreadInfo != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::NegotiateSecConnection(
    IN DWORD dwFlags,
    OUT LPBOOL lpbAttemptReconnect
    )

/*++

Routine Description:

    This function establishes a secure channel with the server by
    performing the security handshake protocol.  It will walk
    the list of installed security packages until it finds a package
    that succeeds in the security handshake.  If one package fails
    it is up to the caller to re-call NegotiateSecConnection with
    a re-opened socket so another socket can attempt the connection.

Arguments:

    dwFlags    - Socket Flags that may need to be passed on to Socket Calls
                (needed to support Async I/O)

    lpbAttemptReconnect - on return, if this value is TRUE, the caller should call
                          this function again, and it will try another protocol.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::NegotiateSecConnection",
                 "{%#x [%#x]} %#x, %#x [%B]",
                 this,
                 m_Socket,
                 dwFlags,
                 lpbAttemptReconnect,
                 *lpbAttemptReconnect
                 ));

    INET_ASSERT(IsSecure());

    DWORD error = DoFsm(New CFsm_SecureNegotiate(dwFlags,
                                                 lpbAttemptReconnect,
                                                 this
                                                 ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureNegotiate::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureNegotiate::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureNegotiate * stateMachine = (CFsm_SecureNegotiate *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->SecureNegotiate_Fsm(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = Fsm->GetError();
        INET_ASSERT (error == ERROR_WINHTTP_OPERATION_CANCELLED);
        Fsm->SetDone();
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SecureNegotiate_Fsm(
    IN CFsm_SecureNegotiate * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SecureNegotiate_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureNegotiate & fsm = *Fsm;
    DWORD error = fsm.GetError();
    DWORD dwSSPIFlags = 0;
    DWORD dwStatusFlag = 0;
    PSEC_PROVIDER pSecProviders = m_pCertCache->GetSecProviders();

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto send_continue;

        case FSM_STATE_3:
            goto negotiate_loop_continue;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    INET_ASSERT(IsOpen());

    *fsm.m_lpbAttemptReconnect = FALSE;

    //
    // set OutBuffer for InitializeSecurityContext call
    //

    fsm.m_OutBuffer.cBuffers = 1;
    fsm.m_OutBuffer.pBuffers = fsm.m_OutBuffers;
    fsm.m_OutBuffer.ulVersion = SECBUFFER_VERSION;

    if(m_dwSecureProtocols != m_pCertCache->GetSecureProtocols())
    {
        if (LOCK_SECURITY())
        {
            //ReInit the credentials if our settings have changed.
            SecurityPkgInitialize(m_pCertCache, TRUE);
            m_dwSecureProtocols = m_pCertCache->GetSecureProtocols();
            UNLOCK_SECURITY();
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }
    }

    while ((pSecProviders[GetProviderIndex()].pszName != NULL)
           && ( !pSecProviders[GetProviderIndex()].fEnabled
             || !(pSecProviders[GetProviderIndex()].dwProtocolFlags & m_pCertCache->GetSecureProtocols()) ) ) {

        //
        // Next provider
        //

        SetProviderIndex(GetProviderIndex() + 1);
    }

    if (pSecProviders[GetProviderIndex()].pszName == NULL) {

        //
        // BUGBUG shouldn't we error out here?
        //

        SetProviderIndex(0);
        goto error_exit;
    }

    DWORD i;

    i = GetProviderIndex();

    DEBUG_PRINT(API,
                INFO,
                ("Starting handshake protocol with pkg %d - %s\n",
                i,
                pSecProviders[i].pszName
                ));


    //
    // 1. initiate a client HELLO message and generate a token
    //

    fsm.m_OutBuffers[0].pvBuffer = NULL;
    fsm.m_OutBuffers[0].BufferType = SECBUFFER_TOKEN;

    SECURITY_STATUS scRet;
    DWORD ContextAttr;
    TimeStamp tsExpiry;

    fsm.m_bDoingClientAuth = FALSE;

    //
    // We need a credential handle,
    //  if we're doing client do the magic to get a specialized
    //  one otherwise use the standard global one.
    //

    if ( IsCredClear(fsm.m_hCreds) )
    {
        fsm.m_hCreds = pSecProviders[i].hCreds;

        if (GetCertContextArray())
        {
            if (GetCertContextArray()->GetSelectedCertContext())
            {
                error = CliAuthSelectCredential(
                            &m_hContext,
                            pSecProviders[i].pszName,
                            GetCertContextArray(),
                            &fsm.m_hCreds,
                            &dwStatusFlag,
                            m_dwSecureProtocols,
                            m_pSecurityInfo->IsImpersonationEnabled());

                if (error != ERROR_SUCCESS) {
                    goto quit;
                }

                fsm.m_bDoingClientAuth = TRUE;
            }

            dwSSPIFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
        }
    }

    // Force a full handshake when per session and entry isn't in the cache.
    if (!m_pSecurityInfo->InCache())
        dwSSPIFlags |= ISC_REQ_USE_SESSION_KEY;

    WRAP_REVERT_USER(g_InitializeSecurityContext,
                     m_pSecurityInfo->IsImpersonationEnabled(),
                     (&fsm.m_hCreds,
                     NULL,
                     (LPSTR)GetHostName(),
                     ISC_REQ_SEQUENCE_DETECT
                     | ISC_REQ_REPLAY_DETECT
                     | ISC_REQ_CONFIDENTIALITY
                     | ISC_REQ_ALLOCATE_MEMORY
                     | dwSSPIFlags,
                     0,
                     SECURITY_NATIVE_DREP,
                     NULL,       // default, don't do hack.
                     0,
                     &m_hContext,
                     &fsm.m_OutBuffer, // address where output data go
                     &ContextAttr,
                     &tsExpiry),
                     scRet);

    DEBUG_PRINT(API,
                INFO,
                ("1. InitializeSecurityContext returned %s [%x]. hContext = %#x:%#x\n",
                InternetMapSSPIError((DWORD)scRet),
                scRet,
                m_hContext.dwUpper,
                m_hContext.dwLower
                ));

    if (scRet == SEC_E_INVALID_HANDLE) {
         pSecProviders[i].fEnabled = FALSE;
    }
    if (scRet == SEC_E_INVALID_TOKEN) {
        error = ERROR_WINHTTP_CANNOT_CONNECT;
    } else {

        //
        // Turn the error in to one we understand */
        //

        error = MapInternetError((DWORD)scRet, &dwStatusFlag);
    }
    if (scRet != SEC_I_CONTINUE_NEEDED) {
        goto error_exit;
    }

    DEBUG_PRINT(API,
                INFO,
                ("1. OutBuffer is <%x, %d, %x>\n",
                fsm.m_OutBuffers[0].pvBuffer,
                fsm.m_OutBuffers[0].cbBuffer,
                fsm.m_OutBuffers[0].BufferType
                ));

    if ((fsm.m_OutBuffers[0].cbBuffer != 0)
    && (fsm.m_OutBuffers[0].pvBuffer != NULL)) {

        //
        // Send response to server if there is one
        //

        fsm.SetFunctionState(FSM_STATE_2);
        error = ICSocket::Send(fsm.m_OutBuffers[0].pvBuffer,
                               fsm.m_OutBuffers[0].cbBuffer,
                               0
                               );
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }

send_continue:

        g_FreeContextBuffer(fsm.m_OutBuffers[0].pvBuffer);
        fsm.m_OutBuffers[0].pvBuffer = NULL;
        if (error != ERROR_SUCCESS) {

            //
            // We should deal with this better
            //

            goto error_exit;
        }
    }

    fsm.SetFunctionState(FSM_STATE_3);
    error = SSPINegotiateLoop(NULL, fsm.m_dwFlags, fsm.m_hCreds, TRUE, fsm.m_bDoingClientAuth);

    //
    // We're not actually deleting the handle, rather we're no longer keeping
    //  a reference to the Credential handle in our fsm after we hand it off
    //

    if ( fsm.m_bDoingClientAuth )
    {
        ClearCreds(fsm.m_hCreds);
        fsm.m_bDoingClientAuth = FALSE;
    }
    if (error == ERROR_IO_PENDING) {
        goto quit;
    }

negotiate_loop_continue:
error_exit:

    if (error == ERROR_WINHTTP_SECURE_FAILURE && m_pSecurityInfo)
        m_pSecurityInfo->SetStatusFlags(dwStatusFlag);
    
    if (error == ERROR_WINHTTP_CANNOT_CONNECT) {

        //
        // error was a CANNOT_CONNECT, so try the next protocol.
        //

        SetProviderIndex(GetProviderIndex() + 1);

        if (pSecProviders[GetProviderIndex()].pszName == NULL) {
            SetProviderIndex(0);
            *fsm.m_lpbAttemptReconnect = FALSE;
        } else {
            *fsm.m_lpbAttemptReconnect = TRUE;
        }
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SSPINegotiateLoop(
    OUT DBLBUFFER * pdblbufBuffer,
    IN DWORD dwFlags,
    CredHandle hCreds,
    IN BOOL bDoInitialRead,
    IN BOOL bDoingClientAuth
    )

/*++

Routine Description:

    This function completes the handshakes needed to establish a
    security protocol.  The initial handshakes are either generated
    by NegotiateSecureConnection, when generating a new connection, or
    during a receive when a REDO request is received.

Arguments:

    pdblbufBuffer - an input buffer into which to put any Extra data left over
                    after the handshake.  This data is assumed to be application
                    data, and will be decrypted later.

    dwFlags    - Socket Flags that may need to be passed on to Socket Calls
                (needed to support Async I/O)

    bDoInitialRead - if TRUE, this function will do a read before calling
                     InitializeSecurityContext, otherwise, it passes in 0 bytes of data.

Return Value:

    ERROR_SUCCESS - we successfully completed our connection.
    ERROR_WINHTTP_CANNOT_CONNECT - The connection was dropped on us, possibly because we used a bad
                                    protocol.  Try the next protocol.

    ERROR_*                       - Other internet error, disconnect.


Comments:

    BUGBUG (hack alert) [arthurbi]
    Do to a bug in IIS 1.0 Servers we cannot connect because
    we send a "Client SSL 3 Message".  This message confuses the
    server and causes it to close the socket.  The fix is to
    reopen the socket and send a "Client SSL 2 Message."  Newer
    versions of the server will be fixed.


--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SSPINegotiateLoop",
                 "{%#x [%#x]} %#x, %#x, %B",
                 this,
                 m_Socket,
                 pdblbufBuffer,
                 dwFlags,
                 bDoInitialRead
                 ));

    INET_ASSERT(IsSecure());

    DWORD error = DoFsm(New CFsm_NegotiateLoop(pdblbufBuffer,
                                               dwFlags,
                                               bDoInitialRead,
                                               bDoingClientAuth,
                                               hCreds,
                                               this
                                               ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_NegotiateLoop::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_NegotiateLoop::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_NegotiateLoop * stateMachine = (CFsm_NegotiateLoop *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->NegotiateLoop_Fsm(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = Fsm->GetError();
        INET_ASSERT (error == ERROR_WINHTTP_OPERATION_CANCELLED);
        Fsm->SetDone();
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::NegotiateLoop_Fsm(
    IN CFsm_NegotiateLoop * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::NegotiateLoop_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_NegotiateLoop & fsm = *Fsm;
    DWORD error = fsm.GetError();
    DWORD dwStatus = 0;

    //
    // If we have a selected cert chain, then try to
    // generate a credential from that list.
    //
    PSEC_PROVIDER pSecProviders = m_pCertCache->GetSecProviders();

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto receive_continue;

        case FSM_STATE_3:
            goto send_continue;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    INET_ASSERT(IsOpen());

    fsm.m_dwProviderIndex = GetProviderIndex();

    fsm.m_dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT
                      | ISC_REQ_REPLAY_DETECT
                      | ISC_REQ_CONFIDENTIALITY
                      | ISC_REQ_ALLOCATE_MEMORY
                      | ISC_RET_EXTENDED_ERROR;

    //
    // set OutBuffer for InitializeSecurityContext call
    //

    fsm.m_OutBuffer.cBuffers = 1;
    fsm.m_OutBuffer.pBuffers = fsm.m_OutBuffers;
    fsm.m_OutBuffer.ulVersion = SECBUFFER_VERSION;

    if (IsCredClear(fsm.m_hCreds))
    {
        fsm.m_hCreds = pSecProviders[fsm.m_dwProviderIndex].hCreds;

        if ( GetCertContextArray() &&
             GetCertContextArray()->GetSelectedCertContext() )
        {
            error = CliAuthSelectCredential(
                        &m_hContext,
                        pSecProviders[fsm.m_dwProviderIndex].pszName,
                        GetCertContextArray(),
                        &fsm.m_hCreds,
                        &dwStatus,
                        m_dwSecureProtocols,
                        m_pSecurityInfo->IsImpersonationEnabled());

            if (error != ERROR_SUCCESS) {
                goto quit;
            }

            fsm.m_bDoingClientAuth = TRUE;
        }
    }

    if (fsm.m_bDoingClientAuth ||
        GetCertContextArray() )
    {
        fsm.m_dwSSPIFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
    }

    // Force a full handshake when per session and entry isn't in the cache.
    if (!m_pSecurityInfo->InCache())
        fsm.m_dwSSPIFlags |= ISC_REQ_USE_SESSION_KEY;

    fsm.m_scRet = SEC_I_CONTINUE_NEEDED;

    while (fsm.m_scRet == SEC_I_CONTINUE_NEEDED ||
           fsm.m_scRet == SEC_E_INCOMPLETE_MESSAGE ||
           fsm.m_scRet == SEC_I_INCOMPLETE_CREDENTIALS) {

        //
        //  send to target server
        //  if we've got a SEC_E_INCOMPLETE_MESSAGE we need to do a read
        //  again because we didn't get the entire message we expected from
        //  the server.
        //


        //
        //  receive response from server and pass token into security pkg
        //    BUT only if we haven't already received extra data
        //    from SSPI which we need to process in lu of actual data
        //    data from WinSock, and if the package has not returned
        //    one of the defined warnings that indicates that we should
        //    pass the previous buffer again.
        //


        // Make sure fsm.m_lpszBuffer holds the input data to be passed
        // to initialize security context.  There are 4 cases:
        // 1) We have Extra Data, so we don't need to do a socket receive
        // 2) We were called during a re-negotiate, so if this is the first
        //    time through the loop, we have 0 bytes.
        // 3) We are recovering from a SEC_I_INCOMPLETE_CREDENTIALS, so
        //    use the same buffer again.
        // 4) We do a SocketReceive
        // We'll indicate 1 and 3 by having the fsm.m_dwBytesReceived count being the number of bytes
        // left in the buffer to be re-sent or sent to the sspi call.
        // If bytes-received is zero, then either we are doing a Redo, or we need to receive
        // data.  fsm.m_bDoRead let's us know if for some reason we should do or not do this read



        if ((0 == fsm.m_dwBytesReceived) || (fsm.m_scRet == SEC_E_INCOMPLETE_MESSAGE)) {
            if (fsm.m_bDoRead) {
                fsm.SetFunctionState(FSM_STATE_2);
                error = ICSocket::Receive((LPVOID *)&fsm.m_lpszBuffer,
                                          &fsm.m_dwBufferLength,
                                          &fsm.m_dwBufferLeft,
                                          &fsm.m_dwBytesReceived,
                                          0,
                                          SF_EXPAND,
                                          &fsm.m_bEofReceive
                                          );
                if (error == ERROR_IO_PENDING) {
                    goto done;
                }

receive_continue:

                if ((error != ERROR_SUCCESS) || fsm.m_bEofReceive) {

                    DEBUG_PRINT(API,
                                ERROR,
                                ("SocketReceive failed\n"
                                ));

                    if (error == ERROR_SUCCESS) {
                        error = ERROR_WINHTTP_CANNOT_CONNECT;
                    }
                    break;
                }
            } else {
                fsm.m_bDoRead = TRUE;
            }
        }

        if (fsm.m_scRet == SEC_I_INCOMPLETE_CREDENTIALS) {

            //
            // If've already done Client Auth, and it fails again
            //  then we fail.
            //

            if (fsm.m_bDoingClientAuth) {
                error = ERROR_CANCELLED;
                goto quit;
            }
            else
            {
                // Fall out with error indicating the client needs to set
                // client auth credentials.
                error = ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED;
            }

            fsm.m_scRet = error;
            break;
        }

        //
        // InBuffers[1] is for getting extra data that
        //  SSPI/SCHANNEL doesn't proccess on this
        //  run around the loop.
        //

        fsm.m_InBuffers[0].pvBuffer   = fsm.m_lpszBuffer;
        fsm.m_InBuffers[0].cbBuffer   = fsm.m_dwBytesReceived;
        fsm.m_InBuffers[0].BufferType = SECBUFFER_TOKEN;

        fsm.m_InBuffers[1].pvBuffer   = NULL;
        fsm.m_InBuffers[1].cbBuffer   = 0;
        fsm.m_InBuffers[1].BufferType = SECBUFFER_EMPTY;

        //
        // Initialize these so if we fail, pvBuffer contains NULL,
        // so we don't try to free random garbage at the quit
        //

        fsm.m_OutBuffers[0].pvBuffer   = NULL;
        fsm.m_OutBuffers[0].BufferType = SECBUFFER_TOKEN;
        fsm.m_OutBuffers[0].cbBuffer   = 0;

        SecBufferDesc InBuffer;

        InBuffer.cBuffers        = 2;
        InBuffer.pBuffers        = fsm.m_InBuffers;
        InBuffer.ulVersion       = SECBUFFER_VERSION;

        DWORD ContextAttr;
        TimeStamp tsExpiry;

        WRAP_REVERT_USER(g_InitializeSecurityContext,
                         m_pSecurityInfo->IsImpersonationEnabled(),
                         (&fsm.m_hCreds,
                          &m_hContext,
                          NULL,
                          fsm.m_dwSSPIFlags,
                          0,
                          SECURITY_NATIVE_DREP,
                          &InBuffer,
                          0,
                          NULL,
                          &fsm.m_OutBuffer,
                          &ContextAttr,
                          &tsExpiry),
                         fsm.m_scRet);

        DEBUG_PRINT(API,
                    INFO,
                    ("3. InitializeSecurityContext returned %s [%x]\n",
                    InternetMapSSPIError((DWORD)fsm.m_scRet),
                    fsm.m_scRet
                    ));

        if (fsm.m_scRet == STATUS_SUCCESS ||
             fsm.m_scRet == SEC_I_CONTINUE_NEEDED ||
             (FAILED(fsm.m_scRet) && (0 != (ContextAttr & ISC_RET_EXTENDED_ERROR))))
        {
            if  (fsm.m_OutBuffers[0].cbBuffer != 0    &&
                 fsm.m_OutBuffers[0].pvBuffer != NULL )
            {

                //
                // Send response to server if there is one
                //

                fsm.SetFunctionState(FSM_STATE_3);
                error = ICSocket::Send(fsm.m_OutBuffers[0].pvBuffer,
                                       fsm.m_OutBuffers[0].cbBuffer,
                                       0
                                       );
                if (error == ERROR_IO_PENDING) {
                    goto done;
                }

send_continue:

                g_FreeContextBuffer(fsm.m_OutBuffers[0].pvBuffer);
                fsm.m_OutBuffers[0].pvBuffer = NULL;
            }
        }


        if ( fsm.m_scRet == STATUS_SUCCESS )
        {
            DEBUG_PRINT(API,
                     INFO,
                    ("NegotiateSecConnection succeeded.\n"));


            if (fsm.m_pdblbufBuffer)
            {
                if ( fsm.m_InBuffers[1].BufferType == SECBUFFER_EXTRA )
                {

                    if (fsm.m_pdblbufBuffer->CopyIn(
                            (LPBYTE) (fsm.m_lpszBuffer + (fsm.m_dwBytesReceived - fsm.m_InBuffers[1].cbBuffer)),
                            fsm.m_InBuffers[1].cbBuffer) == FALSE)
                    {
                        error = ERROR_NOT_ENOUGH_MEMORY;
                        goto quit;
                    }
                }
                else
                {
                    fsm.m_pdblbufBuffer->SetInputBufferSize(0);
                }
            }



            //
            // Bail out to quit
            //

            break;
        }
        else if (FAILED(fsm.m_scRet) && (fsm.m_scRet != SEC_E_INCOMPLETE_MESSAGE))
        {

             //
             //  free security context handle and delete the local
             //  data structures associated with the handle and
             //  try another pkg if available
             //

             DEBUG_PRINT(API,
                         INFO,
                         ("3. InitializeSecurityContext failed, %lx\n",
                         fsm.m_scRet
                         ));


             // Turn the error in to one we understand */
             error = MapInternetError((DWORD)fsm.m_scRet, &dwStatus);

             TerminateSecConnection();
             /* Break out to try next protocol */
             break;
        }

        if ((fsm.m_scRet != SEC_E_INCOMPLETE_MESSAGE)
        && (fsm.m_scRet != SEC_I_INCOMPLETE_CREDENTIALS)) {

            DEBUG_PRINT(API,
                        INFO,
                        ("3. OutBuffer is <%x, %d, %x>\n",
                        fsm.m_OutBuffers[0].pvBuffer,
                        fsm.m_OutBuffers[0].cbBuffer,
                        fsm.m_OutBuffers[0].BufferType
                        ));

            if (fsm.m_InBuffers[1].BufferType == SECBUFFER_EXTRA) {

                //
                // skip next recv and set up buffers
                //  so InitalizeSecurityContext pulls its
                //  info from the Extra it returned previously.
                //

                DEBUG_PRINT(API,
                         INFO,
                         ("Got SECBUFFER_EXTRA, moving %d bytes to front of buffer\n",
                         fsm.m_InBuffers[1].cbBuffer
                         ));

                INET_ASSERT(fsm.m_InBuffers[1].cbBuffer > 0);

                MoveMemory(
                        fsm.m_lpszBuffer,             // dest
                        fsm.m_lpszBuffer + (fsm.m_dwBytesReceived - fsm.m_InBuffers[1].cbBuffer),
                        fsm.m_InBuffers[1].cbBuffer   // size
                        );

                fsm.m_dwBytesReceived = fsm.m_InBuffers[1].cbBuffer;
                fsm.m_dwBufferLeft   = fsm.m_dwBufferLength - fsm.m_dwBytesReceived;
            } else {

                //
                // prepare for next receive
                //

                fsm.m_dwBufferLeft = fsm.m_dwBufferLength;
                fsm.m_dwBytesReceived = 0;
            }
        }
    }

quit:

    if (fsm.m_lpszBuffer != NULL)
    {
         fsm.m_lpszBuffer = (LPSTR)FREE_MEMORY(fsm.m_lpszBuffer);
         INET_ASSERT(fsm.m_lpszBuffer == NULL);
    }

done:

    if (error != ERROR_IO_PENDING)
    {
        DWORD dwStatus2;
        if (m_pSecurityInfo && ((dwStatus2 = m_pSecurityInfo->GetStatusFlags())!=0))
        {
            // Report SSL status of all errors found
            dwStatus2 = m_pSecurityInfo->GetStatusFlags();
            InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_SECURE_FAILURE,
                                   &dwStatus2,
                                   sizeof(dwStatus2)
                                   );
        }
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Disconnect(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Undoes the work of ConnectSocket - i.e. closes a connected socket. We make
    callbacks to inform the app that this socket is being closed

Arguments:

    dwFlags - controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Disconnect",
                 "{%#x} %#x",
                 m_Socket,
                 dwFlags
                 ));

    DWORD error = ICSocket::Disconnect(dwFlags);

    //
    // delete security context handle for the connection
    //

    if ((m_dwFlags & (SF_ENCRYPT | SF_DECRYPT))
    && m_pCertCache->GetEncFlags() != ENC_CAPS_NOT_INSTALLED) {
        TerminateSecConnection();
    }

    //
    // Zero out the pending input buffer
    //

    if (m_pdblbufBuffer != NULL) {
        m_pdblbufBuffer->SetInputBufferSize(0);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Send(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Sends data over a secure connection

Arguments:

    lpBuffer        - pointer to user data to send

    dwBufferLength  - length of user data

    dwFlags         - flags controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Send",
                 "{%#x [%#x]} %#x, %d, %#x",
                 this,
                 m_Socket,
                 lpBuffer,
                 dwBufferLength,
                 dwFlags
                 ));

    INET_ASSERT(lpBuffer != NULL);
    INET_ASSERT((int)dwBufferLength > 0);

    DWORD error;

    if (IsSecure())  // might be attempting http CONNECT
    {
        error = DoFsm(New CFsm_SecureSend(lpBuffer,
                                          dwBufferLength,
                                          dwFlags,
                                          this
                                          ));
    }
    else
    {
        // thunk to non-secure send
        error = ICSocket::Send(lpBuffer,
                               dwBufferLength,
                               dwFlags
                               );
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureSend::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureSend::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureSend * stateMachine = (CFsm_SecureSend *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->Send_Fsm(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = Fsm->GetError();
        INET_ASSERT (error == ERROR_WINHTTP_OPERATION_CANCELLED);
        Fsm->SetDone();
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Send_Fsm(
    IN CFsm_SecureSend * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Send_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureSend & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() == FSM_STATE_INIT) {

        //
        // Log The Data BEFORE we Encrypt It ( if we do )
        //

        DEBUG_DUMP_API(SOCKETS,
                       "sending data:\n",
                       fsm.m_lpBuffer,
                       fsm.m_dwBufferLength
                       );
        TRACE_DUMP_API_IF_REQUEST(SOCKETS,
                       "sending data:\n",
                       fsm.m_lpBuffer,
                       fsm.m_dwBufferLength,
                        (HANDLE_OBJECT *)(fsm.GetMappedHandle())
                       );

    }

    while (((int)fsm.m_dwBufferLength > 0) && (error == ERROR_SUCCESS)) {

        LPVOID lpBuffer;
        DWORD dwLength;
        DWORD dwBytes;

        if (m_dwFlags & SF_ENCRYPT) {

            DWORD dwBytesEncrypted;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("Encrypting data..\n"
                        ));

            error = EncryptData(fsm.m_lpBuffer,
                                fsm.m_dwBufferLength,
                                &fsm.m_lpCryptBuffer,
                                &fsm.m_dwCryptBufferLength,
                                &dwBytesEncrypted
                                );
            if (error != ERROR_SUCCESS) {
                break;
            }

            INET_ASSERT(fsm.m_lpCryptBuffer != NULL);
            INET_ASSERT((int)fsm.m_dwCryptBufferLength > 0);
            INET_ASSERT(dwBytesEncrypted <= fsm.m_dwBufferLength);

            lpBuffer = fsm.m_lpCryptBuffer;
            dwLength = fsm.m_dwCryptBufferLength;
            dwBytes = dwBytesEncrypted;
        } else {
            lpBuffer = fsm.m_lpBuffer;
            dwLength = fsm.m_dwBufferLength;
            dwBytes = dwLength;
        }

        fsm.m_lpBuffer = (LPVOID)((LPBYTE)fsm.m_lpBuffer + dwBytes);
        fsm.m_dwBufferLength -= dwBytes;

        error = ICSocket::Send(lpBuffer, dwLength, fsm.m_dwFlags);
        if (error != ERROR_SUCCESS) {
            break;
        }
    }

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();

        //
        // Free Encryption Buffer if doing SSL/PCT
        //

        if (fsm.m_lpCryptBuffer != NULL ) {
            fsm.m_lpCryptBuffer = (LPVOID)FREE_MEMORY(fsm.m_lpCryptBuffer);
            INET_ASSERT(fsm.m_lpCryptBuffer == NULL);
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Receive(
    IN OUT LPVOID* lplpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwBufferRemaining,
    IN OUT LPDWORD lpdwBytesReceived,
    IN DWORD dwExtraSpace,
    IN DWORD dwFlags,
    OUT LPBOOL lpbEof
    )

/*++

Routine Description:

    Receives and decrypts data from a secure connection

Arguments:

    lplpBuffer          - see ICSocket::Receive
    lpdwBufferLength    -
    lpdwBufferRemaining -
    lpdwBytesReceived   -
    dwExtraSpace        -
    dwFlags             -
    lpbEof              -

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    INET_ASSERT(lplpBuffer != NULL);
    INET_ASSERT(lpdwBufferLength != NULL);
    INET_ASSERT((*lpdwBufferLength == 0) ? (dwFlags & SF_EXPAND) : TRUE);

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Receive",
                 "%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B]",
                 lplpBuffer,
                 *lplpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 lpdwBufferRemaining,
                 *lpdwBufferRemaining,
                 lpdwBytesReceived,
                 *lpdwBytesReceived,
                 dwExtraSpace,
                 dwFlags,
                 lpbEof,
                 *lpbEof
                 ));

    DWORD error;

    // Thunk to non-secure if establishing via a CONNECT
    if (IsSecure())
    {
        error = DoFsm(New CFsm_SecureReceive(lplpBuffer,
                                             lpdwBufferLength,
                                             lpdwBufferRemaining,
                                             lpdwBytesReceived,
                                             dwExtraSpace,
                                             dwFlags,
                                             lpbEof,
                                             this
                                             ));
    }
    else
    {
        error = ICSocket::Receive(lplpBuffer,
                                  lpdwBufferLength,
                                  lpdwBufferRemaining,
                                  lpdwBytesReceived,
                                  dwExtraSpace,
                                  dwFlags,
                                  lpbEof
                                  );
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureReceive::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureReceive::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureReceive * stateMachine = (CFsm_SecureReceive *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->Receive_Fsm(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = Fsm->GetError();
        INET_ASSERT (error == ERROR_WINHTTP_OPERATION_CANCELLED);
        Fsm->SetDone();
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Receive_Fsm(
    IN CFsm_SecureReceive * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Receive_Fsm",
                 "%#x",
                 Fsm
                 ));

    //INET_ASSERT(m_dwFlags & SF_DECRYPT);

    CFsm_SecureReceive & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto negotiate_continue;

        case FSM_STATE_3:
            goto receive_continue;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    //
    // if we weren't given a buffer, but the caller told us its okay to resize
    // then we allocate the initial buffer
    //

    if ((fsm.m_dwBufferLength == 0) || (fsm.m_dwBufferLeft == 0)) {

        INET_ASSERT((fsm.m_dwBufferLength == 0) ? (fsm.m_dwBufferLeft == 0) : TRUE);

        if (fsm.m_dwFlags & SF_EXPAND) {

            //
            // allocate a fixed memory buffer
            //

            //
            // BUGBUG - the initial buffer size should come from the handle
            //          object
            //

            fsm.m_dwBufferLeft = DEFAULT_RECEIVE_BUFFER_INCREMENT;
            if (fsm.m_dwBufferLength == 0) {
                fsm.m_bAllocated = TRUE;
            }
            fsm.m_dwBufferLength += fsm.m_dwBufferLeft;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("resizing %#x to %d\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                         fsm.m_dwBufferLength,
                                         FALSE);
            if (fsm.m_hBuffer == (HLOCAL)NULL) {
                error = GetLastError();

                INET_ASSERT(error != ERROR_SUCCESS);

                fsm.m_bAllocated = FALSE;
            }
        } else {

            //
            // the caller didn't say its okay to resize
            //

            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else if (fsm.m_hBuffer == (HLOCAL)NULL) {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // keep the app informed (if requested to do so)
    //

    if (fsm.m_dwFlags & SF_INDICATE) {
        InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE,
                               NULL,
                               0
                               );
    }

    fsm.m_dwReadFlags = fsm.m_dwFlags;

    //
    // Loop Through our Reads, assembling enough unencrypted bytes
    //  to return back to the client.  In the non-SSL/PCT case, we should
    //  be able to quit after one iteration.
    //

    do {

        LPVOID * lplpReadBuffer;
        LPDWORD lpdwReadBufferLength;
        LPDWORD lpdwReadBufferLeft;
        LPDWORD lpdwReadBufferReceived;

        //
        // If we're attempting to read SSL/PCT data, we need examine, whether
        // we have all the bytes decrypted and read already in our scratch buffer.
        //

        if (m_dwFlags & SF_DECRYPT) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("Decrypting data..\n"
                        ));

            if (m_pdblbufBuffer != NULL) {

                DEBUG_DUMP_API(SOCKETS,
                               "About to decrypt this data:\n",
                               (LPBYTE)m_pdblbufBuffer->GetInputBufferPointer(),
                               m_pdblbufBuffer->GetInputBufferSize()
                               );
                /* We can add this in later if reqd, for now, not very helpful:
                TRACE_PRINT_API(SOCKETS,
                    INFO,
                    ("About to decrypt %d (%#x) bytes\n",
                    m_pdblbufBuffer->GetInputBufferSize(),
                    m_pdblbufBuffer->GetInputBufferSize()
                    ));
                */
            }

            fsm.m_dwDecryptError = DecryptData(&fsm.m_dwInputBytesLeft,
                                               (LPBYTE)fsm.m_hBuffer,
                                               &fsm.m_dwBufferLeft,
                                               &fsm.m_dwBytesReceived,
                                               &fsm.m_dwBytesRead
                                               );

            if (fsm.m_dwDecryptError == SEC_E_INCOMPLETE_MESSAGE &&
                fsm.m_bEof &&
                m_pdblbufBuffer->GetInputBufferSize() > 0) {

                error = ERROR_HTTP_INVALID_SERVER_RESPONSE;
                goto error_exit;

            }
            else if (fsm.m_dwDecryptError == SEC_I_RENEGOTIATE) {

                CredHandle hDummyCreds;

                //
                // BUGBUG - don't have to do this - Receive() called from
                //          SSPINegotiateLoop() won't come back through here
                //

                m_dwFlags &= ~(SF_ENCRYPT | SF_DECRYPT);
                ClearCreds(hDummyCreds);

                fsm.SetFunctionState(FSM_STATE_2);
                error = SSPINegotiateLoop(m_pdblbufBuffer,
                                          fsm.m_dwFlags,
                                          hDummyCreds,
                                          FALSE,
                                          FALSE);
                if (error == ERROR_IO_PENDING) {
                    goto error_exit;
                }

negotiate_continue:

                m_dwFlags |= (SF_ENCRYPT | SF_DECRYPT);

                if (error != ERROR_SUCCESS) {
                    break;
                }

                fsm.m_dwDecryptError = (ULONG)SEC_E_INCOMPLETE_MESSAGE;

                //
                // If there was extra data, and it was shoved back into
                // dblbuffer, then we should redo the decryption, since
                // it now has extra input data to process.
                //

                if (m_pdblbufBuffer->GetInputBufferSize() > 0) {
                    continue;
                }

                //
                // Okay, here we've received 0 bytes, so so we have to
                // receive more data, and process it.  Do this by zero-ing
                // out the input buffer, and setting the decrypt_error to be
                // Incomplete.
                //

            }
            else if (fsm.m_dwDecryptError == ERROR_NOT_ENOUGH_MEMORY)
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto error_exit;
            }

            //
            // If we have no buffer left to fill, or the caller ask for a single recv
            // and we've managed to read something into the buffer, then return by breaking.
            //

            if ((fsm.m_dwBufferLeft == 0)
            || (!(fsm.m_dwFlags & SF_RECEIVE_ALL) && (fsm.m_dwBytesRead > 0))) {
                break;  // we're done.
            }

            INET_ASSERT(error == ERROR_SUCCESS);

            //
            // BUGBUG [arthurbi] GetInputBufferSize needs to be called before getting
            //   the pointer, because the pointer may be moved around while generating
            //   the size.
            //

            DWORD remaining;
            DWORD inputSize;

            inputSize = m_pdblbufBuffer->GetInputBufferSize();
            remaining = m_pdblbufBuffer->GetInputBufferRemaining();
            fsm.m_dwBufferLengthDummy = inputSize + remaining;
            fsm.m_dwBufferLeftDummy = remaining;
            fsm.m_dwBufferReceivedDummy = inputSize;
            fsm.m_lpBufferDummy = m_pdblbufBuffer->GetInputBufferPointer();

            //
            // We need to be careful, and only recv one block of data at a time
            // if we're not we break keep-alive by doing too many reads.
            //
            // So unless we know ( by the non-0 return ) exactly how many bytes
            // to read, we shut off SF_RECEIVE_ALL.
            //

            fsm.m_dwReadFlags &= ~(SF_RECEIVE_ALL
                                   | SF_INDICATE
                                   | SF_EXPAND
                                   | SF_COMPRESS
                                   );

            if (fsm.m_dwInputBytesLeft != 0) {

                //
                // don't add RECEIVE_ALL if NO_WAIT already set by caller - they
                // are mutually exclusive
                //

                if (!(fsm.m_dwReadFlags & SF_NO_WAIT)) {
                    fsm.m_dwReadFlags |= SF_RECEIVE_ALL;
                }
                fsm.m_dwBufferLeftDummy = min(fsm.m_dwInputBytesLeft,
                                              fsm.m_dwBufferLeftDummy);
            }
            lplpReadBuffer = (LPVOID *)&fsm.m_lpBufferDummy;
            lpdwReadBufferLength = &fsm.m_dwBufferLengthDummy;
            lpdwReadBufferLeft = &fsm.m_dwBufferLeftDummy;
            lpdwReadBufferReceived = &fsm.m_dwBufferReceivedDummy;
        } else {
            lplpReadBuffer = &fsm.m_hBuffer;
            lpdwReadBufferLength = &fsm.m_dwBufferLength;
            lpdwReadBufferLeft = &fsm.m_dwBufferLeft;
            lpdwReadBufferReceived = &fsm.m_dwBytesReceived;
        }

        //
        // receive some data, assuming the socket is not closed.
        //

        if (!fsm.m_bEof) {
            //fsm.m_dwBytesReceivedPre = *lpdwReadBufferReceived;
            fsm.SetFunctionState(FSM_STATE_3);
            error = ICSocket::Receive(lplpReadBuffer,
                                      lpdwReadBufferLength,
                                      lpdwReadBufferLeft,
                                      lpdwReadBufferReceived,
                                      fsm.m_dwExtraSpace,
                                      fsm.m_dwReadFlags,
                                      &fsm.m_bEof
                                      );
            if (error == ERROR_IO_PENDING) {
                goto error_exit;
            }

receive_continue:

            //fsm.m_dwBytesRead += fsm.m_dwByReceived - fsm.m_dwDCBufferRecvPre;
            if (error != ERROR_SUCCESS) {
                goto quit;
            }

            //
            // Once again, for SSL/PCT we need to update our input buffer after the read.
            //

            if (m_dwFlags & SF_DECRYPT) {
                m_pdblbufBuffer->SetInputBufferSize(fsm.m_dwBufferReceivedDummy);
            }
        }
    } while ((m_dwFlags & SF_DECRYPT)
             && (error == ERROR_SUCCESS)
             && (fsm.m_dwDecryptError == SEC_E_INCOMPLETE_MESSAGE)
             && (!fsm.m_bEof || (m_pdblbufBuffer->GetInputBufferSize() > 0)));

    if (error == ERROR_SUCCESS) {

        //
        // inform the app that we finished, and tell it how much we received
        // this time
        //

        if (fsm.m_dwFlags & SF_INDICATE) 
        {
            DWORD dwBytesRead = fsm.m_dwBytesRead;
            InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED,
                                   &dwBytesRead,
                                   sizeof(dwBytesRead)
                                   );
        }

        //
        // if we received the entire response and the caller specified
        // SF_COMPRESS then we shrink the buffer to fit. We may end up growing
        // the buffer to contain dwExtraSpace if it is not zero and we just
        // happened to fill the current buffer
        //

        if (fsm.m_bEof && (fsm.m_dwFlags & SF_COMPRESS)) {

            fsm.m_dwBufferLeft = fsm.m_dwExtraSpace;

            //
            // include any extra that the caller required
            //

            fsm.m_dwBufferLength = fsm.m_dwBytesReceived + fsm.m_dwExtraSpace;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("shrinking buffer %#x to %d (%#x) bytes (includes %d extra)\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength,
                        fsm.m_dwBufferLength,
                        fsm.m_dwExtraSpace
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                         fsm.m_dwBufferLength,
                                         FALSE);

            INET_ASSERT((fsm.m_hBuffer == NULL)
                        ? ((fsm.m_dwBytesReceived + fsm.m_dwExtraSpace) == 0)
                        : TRUE
                        );

        }

        DEBUG_PRINT_API(SOCKETS,
                        INFO,
                        ("read %d bytes @ %#x from socket %#x\n",
                        fsm.m_dwBytesRead,
                        (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                        m_Socket
                        ));

        DEBUG_DUMP_API(SOCKETS,
                       "received data:\n",
                       (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                       fsm.m_dwBytesRead
                       );

        TRACE_DUMP_API_IF_REQUEST(SOCKETS,
                       "received data:\n",
                       (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                       fsm.m_dwBytesRead,
                        (HANDLE_OBJECT *)(fsm.GetMappedHandle())
                       );
    }

quit:

    //
    // if we failed but allocated a buffer then we need to free it (we were
    // leaking this buffer if the request was cancelled)
    //

    if ((error != ERROR_SUCCESS) && fsm.m_bAllocated && (fsm.m_hBuffer != NULL)) {
//dprintf("SocketReceive() freeing allocated buffer %#x\n", hBuffer);
        fsm.m_hBuffer = (HLOCAL)FREE_MEMORY(fsm.m_hBuffer);

        INET_ASSERT(fsm.m_hBuffer == NULL);

        fsm.m_dwBufferLength = 0;
        fsm.m_dwBufferLeft = 0;
        fsm.m_dwBytesReceived = 0;
        fsm.m_bEof = TRUE;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("returning: lpBuffer=%#x, bufferLength=%d, bufferLeft=%d, bytesReceived=%d\n",
                fsm.m_hBuffer,
                fsm.m_dwBufferLength,
                fsm.m_dwBufferLeft,
                fsm.m_dwBytesReceived
                ));

    //
    // update output parameters
    //

    *fsm.m_lplpBuffer = (LPVOID)fsm.m_hBuffer;
    *fsm.m_lpdwBufferLength = fsm.m_dwBufferLength;
    *fsm.m_lpdwBufferRemaining = fsm.m_dwBufferLeft;
    *fsm.m_lpdwBytesReceived = fsm.m_dwBytesReceived;

    //
    // Hack, we hide eof's from caller, since we may have buffered data sitting around
    //

    if ((m_dwFlags & SF_DECRYPT) && (fsm.m_dwBytesRead != 0)) {
        fsm.m_bEof = FALSE;
    }

    *fsm.m_lpbEof = fsm.m_bEof;

    //
    // map any sockets error to WinInet error
    //

    if (error != ERROR_SUCCESS) {
        error = MapInternetError(error);
    }

error_exit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SetHostName(
    IN LPSTR lpszHostName,
    IN INTERNET_PORT HostPort,
    IN SECURITY_CACHE_LIST *pCertCache
    )

/*++

Routine Description:

    Set name of server we are connected to. Find or create a security cache
    entry for this name

Arguments:

    lpszHostName    - name to set

    pCertCache      - SSL cert cache reference (global vs. session), it's
                      ALWAYS copied, even if there's not enough memory to alloc
                      the copied hostname.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SetHostName",
                 "{%#x [%q %#x/%d]} %q, %#x",
                 this,
                 m_lpszHostName,
                 GetSocket(),
                 GetSourcePort(),
                 lpszHostName,
                 pCertCache
                 ));

    INET_ASSERT(IsSecure());
    INET_ASSERT((lpszHostName != NULL) || (m_lpszHostName == NULL));

    DWORD error = ERROR_SUCCESS;

    if (lpszHostName != NULL) {
        if (m_lpszHostName != NULL) {
            m_lpszHostName = (LPSTR)FREE_MEMORY(m_lpszHostName);

            INET_ASSERT(m_lpszHostName == NULL);

        }

        // Addref the new SSL session cache reference and release the old,
        // if there is one.
        if (m_pCertCache)
        {
            m_pCertCache->Release();
            m_pCertCache = NULL;
        }
        pCertCache->AddRef();
        m_pCertCache = pCertCache;

        m_dwSecureProtocols = m_pCertCache->GetSecureProtocols();
        m_lpszHostName = NewString(lpszHostName);
        if (m_lpszHostName == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
        } else if (m_pSecurityInfo == NULL) {
            /* SCLE ref */
            if (pCertCache)
                m_pSecurityInfo = pCertCache->Find(lpszHostName, HostPort);
            if (m_pSecurityInfo == NULL) {
                /* SCLE ref */
                m_pSecurityInfo = New SECURITY_CACHE_LIST_ENTRY(
                        pCertCache->IsImpersonationEnabled(),
                        lpszHostName, HostPort);
            }
        }
    }

    DEBUG_LEAVE(error);

    return error;
}

//
// private ICSecureSocket methods
//


DWORD
ICSecureSocket::EncryptData(
    IN LPVOID lpBuffer,
    IN DWORD dwInBufferLen,
    OUT LPVOID * lplpBuffer,
    OUT LPDWORD lpdwOutBufferLen,
    OUT LPDWORD lpdwInBufferBytesEncrypted
    )

/*++

Routine Description:

    This function encrypts data in the lplpbuffer.

Arguments:

    lpBuffer         - pointer to buffer containing unencrypted user data

    dwInBufferLen    - length of input buffer

    lplpBuffer       - pointer to pointer to encrypted user buffer

    lpdwOutBufferLen - pointer to length of output lplpbuffer

    lpdwInBufferBytesEncrypted - pointer to length of bytes read and encrypted in output buffer

Return Value:

    Error Code

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::EncryptData",
                 "%#x, %d, %#x, %#x, %#x",
                 lpBuffer,
                 dwInBufferLen,
                 lplpBuffer,
                 lpdwOutBufferLen,
                 lpdwInBufferBytesEncrypted
                 ));

    SECURITY_STATUS scRet = STATUS_SUCCESS;
    SecBufferDesc Buffer;
    SecBuffer Buffers[3];
    HLOCAL hBuffer;
    DWORD error;
    DWORD dwMaxDataBufferSize;
    DWORD dwExtraInputBufferLen;
    SecPkgContext_StreamSizes Sizes;

    INET_ASSERT(IsSecure());
    INET_ASSERT(lpBuffer != NULL);
    INET_ASSERT(dwInBufferLen != 0);
    INET_ASSERT(lplpBuffer != NULL);
    INET_ASSERT(lpdwOutBufferLen != NULL);
    INET_ASSERT(lpdwInBufferBytesEncrypted != NULL);

    hBuffer = (HLOCAL) *lplpBuffer;
    *lpdwOutBufferLen = 0;
    *lpdwInBufferBytesEncrypted = 0;

    //INET_ASSERT(hBuffer == NULL );

    //
    //  find the header and trailer sizes
    //

    scRet = g_QueryContextAttributes(&m_hContext,
                                     SECPKG_ATTR_STREAM_SIZES,
                                     &Sizes );
    if (scRet != ERROR_SUCCESS) {

        //
        // Map the SSPI error.
        //

        DEBUG_PRINT(API,
                    INFO,
                    ("QueryContextAttributes returned, %s [%x] (%s)\n",
                    InternetMapSSPIError((DWORD)scRet),
                    scRet,
                    InternetMapError(scRet)
                    ));

        error = MapInternetError((DWORD) scRet);
        goto quit;
    } else {

        DEBUG_PRINT(API,
                    INFO,
                    ("QueryContextAttributes returned header=%d, trailer=%d, maxmessage=%d\n",
                    Sizes.cbHeader,
                    Sizes.cbTrailer,
                    Sizes.cbMaximumMessage
                    ));
    }

    INET_ASSERT(Sizes.cbMaximumMessage > (Sizes.cbHeader + Sizes.cbTrailer));

    //
    // Figure out the max SSL packet we can send over the wire.
    //  If the data is too big to send, then remeber how much
    //  we did send, and how much we didn't send.
    //

    dwMaxDataBufferSize = Sizes.cbMaximumMessage - (Sizes.cbHeader + Sizes.cbTrailer);

    dwExtraInputBufferLen =
            (dwMaxDataBufferSize < dwInBufferLen ) ?
                (dwInBufferLen - dwMaxDataBufferSize) : 0;

    dwInBufferLen =
            ( dwExtraInputBufferLen > 0 ) ?
            dwMaxDataBufferSize :
            dwInBufferLen;

    DEBUG_PRINT(API,
                INFO,
                ("resizing %#x to %d\n",
                hBuffer,
                dwInBufferLen + Sizes.cbHeader + Sizes.cbTrailer
                ));

    hBuffer = ResizeBuffer(hBuffer,
                           dwInBufferLen + Sizes.cbHeader + Sizes.cbTrailer,
                           FALSE );

    if (hBuffer == (HLOCAL)NULL) {
        *lplpBuffer = NULL; // ResizeBuffer will free the memory upon failure, here we need to prevent the caller from
                            // double-free'ing it.
        error = GetLastError();

        INET_ASSERT(error != ERROR_SUCCESS);

        goto quit;
    }

    //
    // prepare data for SecBuffer
    //

    Buffers[0].pvBuffer = hBuffer;
    Buffers[0].cbBuffer = Sizes.cbHeader;
    Buffers[0].BufferType = SECBUFFER_TOKEN;

    Buffers[1].pvBuffer = (LPBYTE)hBuffer + Sizes.cbHeader;
    memcpy(Buffers[1].pvBuffer,
           lpBuffer,
           dwInBufferLen);

    Buffers[1].cbBuffer = dwInBufferLen;
    Buffers[1].BufferType = SECBUFFER_DATA;

    //
    // check if security pkg supports trailer: PCT does
    //

    if ( Sizes.cbTrailer ) {
         Buffers[2].pvBuffer = (LPBYTE)hBuffer + Sizes.cbHeader + dwInBufferLen;
         Buffers[2].cbBuffer = Sizes.cbTrailer;
         Buffers[2].BufferType = SECBUFFER_TOKEN;
    } else {
         Buffers[2].pvBuffer = NULL;
         Buffers[2].cbBuffer = 0;
         Buffers[2].BufferType = SECBUFFER_EMPTY;
    }

    Buffer.cBuffers = 3;
    Buffer.pBuffers = Buffers;
    Buffer.ulVersion = SECBUFFER_VERSION;

    scRet = g_SealMessage(&m_hContext,
                          0,
                          &Buffer,
                          0);

    DEBUG_PRINT(API,
                INFO,
                ("SealMessage returned, %s [%x]\n",
                InternetMapSSPIError((DWORD)scRet),
                scRet
                ));


    if (scRet != ERROR_SUCCESS) {

        //
        // Map the SSPI error.
        //

        DEBUG_PRINT(API,
                    ERROR,
                    ("SealMessage returned, %s [%x]\n",
                    InternetMapSSPIError((DWORD)scRet),
                    scRet
                    ));

        error = MapInternetError((DWORD) scRet);

        if (hBuffer != NULL) {
            *lplpBuffer = NULL; // prevent the caller from double-free'ing this
            FREE_MEMORY(hBuffer);
        }
        goto quit;
    } else {
        error = ERROR_SUCCESS;
    }

    *lplpBuffer = Buffers[0].pvBuffer;
    *lpdwOutBufferLen = Sizes.cbHeader + Buffers[1].cbBuffer +
                        Buffers[2].cbBuffer;
    *lpdwInBufferBytesEncrypted = dwInBufferLen;

    DEBUG_PRINT(API,
                INFO,
                ("SealMessage returned Buffer = %x, EncryptBytes = %d, UnencryptBytes=%d\n",
                *lplpBuffer,
                *lpdwOutBufferLen,
                dwInBufferLen
                ));

quit:

    DEBUG_LEAVE(error);

    return error;
}


// Smallest chunk needs to be 5 bytes to avoid a problem in some
// schannel versions that misread the header if between 1 and 4 bytes.
#define SSLPCT_SMALLESTHEADERCHUNK      5


DWORD
ICSecureSocket::DecryptData(
    OUT DWORD * lpdwBytesNeeded,
    OUT LPBYTE lpOutBuffer,
    IN OUT LPDWORD lpdwOutBufferLeft,
    IN OUT LPDWORD lpdwOutBufferReceived,
    IN OUT LPDWORD lpdwOutBufferBytesRead
    )

/*++

Routine Description:

    This function decrypts data into the lpOutBuffer. It attempts to fill lpOutBuffer.
    If it fails, it may do so because more bytes are
    needed to fill lplpEncDecBuffer or lplpEndDecBuffer is not big enough to fully
    contain a complete server generated SSL/PCT message.


Return Value:

    Error Code

--*/

{
    INET_ASSERT(IsSecure());
    INET_ASSERT(lpOutBuffer);
    INET_ASSERT(lpdwOutBufferBytesRead);
    INET_ASSERT(lpdwBytesNeeded);

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::DecryptData",
                 "{%#x [%#x:%#x], %#x} %#x [%d], %#x, %#x [%d], %#x [%d], %#x [%d]",
                 &m_hContext,
                 m_hContext.dwUpper,
                 m_hContext.dwLower,
                 m_pdblbufBuffer,
                 lpdwBytesNeeded,
                 *lpdwBytesNeeded,
                 lpOutBuffer,
                 lpdwOutBufferLeft,
                 *lpdwOutBufferLeft,
                 lpdwOutBufferReceived,
                 *lpdwOutBufferReceived,
                 lpdwOutBufferBytesRead,
                 *lpdwOutBufferBytesRead
                 ));

    SecBufferDesc Buffer;
    SecBuffer Buffers[4];   // the 4 buffers are: header, data, trailer, extra
    DWORD scRet = ERROR_SUCCESS;

    *lpdwBytesNeeded = 0;

    //
    //  HOW THIS THING WORKS:
    //  We sit in a loop, attempting to fill our passed in buffer with
    //  decrypted data.  If there is no decrypted data we check to
    //  see if there is encrypted data sitting in our buffer.
    //
    //  Assuming there is enough we decrypt a chunk, and place it in the
    //  output buffer of our double buffer class. We reloop and try to
    //  copy it to our passed in byffer.
    //
    //  If there is more encrypted data, and more space to fill in
    //  the user buffer, we attempt to decrypt the next chunk of this.
    //
    //  If we do not have enough data, we return with an error, and
    //  expect a network read to be done.
    //

    do {

        //
        // Check to see if we can fill up User buffer.
        //

        m_pdblbufBuffer->CopyOut(
            lpOutBuffer,
            lpdwOutBufferLeft,
            lpdwOutBufferReceived,
            lpdwOutBufferBytesRead
        );

        //
        // If we've filled our output buffer, than exit with ERROR_SUCCESS
        //

        if ( *lpdwOutBufferLeft == 0)
        {
            break;
        }

        //
        // If we've got less than a minimum number of bytes needed,
        // return so we can read more data.
        //

        if (m_pdblbufBuffer->GetInputBufferSize() < SSLPCT_SMALLESTHEADERCHUNK) {
            scRet = (DWORD) SEC_E_INCOMPLETE_MESSAGE;
            break;
        }

        //
        // prepare data the SecBuffer for a call to SSL/PCT decryption code.
        //

        Buffers[0].pvBuffer = m_pdblbufBuffer->GetInputBufferPointer( );
        Buffers[0].cbBuffer = m_pdblbufBuffer->GetInputBufferSize(); // # of bytes to decrypt
        Buffers[0].BufferType = SECBUFFER_DATA;

        int i;

        for ( i = 1; i < 4; i++ )
        {
            //
            // clear other 3 buffers for receving result from SSPI package
            //

            Buffers[i].pvBuffer = NULL;
            Buffers[i].cbBuffer = 0;
            Buffers[i].BufferType = SECBUFFER_EMPTY;
        }

        Buffer.cBuffers = 4; // the 4 buffers are: header, data, trailer, extra
        Buffer.pBuffers = Buffers;
        Buffer.ulVersion = SECBUFFER_VERSION;

        //
        // Decrypt the DATA !!!
        //

        scRet = g_UnsealMessage(&m_hContext,
                                &Buffer,
                                0,
                                NULL );

        DEBUG_PRINT(API,
                    INFO,
                    ("UnsealMessage returned, %s [%x]\n",
                    InternetMapSSPIError((DWORD)scRet),
                    scRet
                    ));



        if ( scRet != ERROR_SUCCESS &&
             scRet != SEC_I_RENEGOTIATE)
        {
            DEBUG_PRINT(API,
                        ERROR,
                        ("UnsealMessage failed, error %lx\n",
                        scRet
                        ));

            INET_ASSERT( scRet != SEC_E_MESSAGE_ALTERED );

            if ( scRet == SEC_E_INCOMPLETE_MESSAGE )
            {
                DWORD dwAddlBufferNeeded = Buffers[1].cbBuffer;

                DEBUG_PRINT(API,
                             INFO,
                             ("UnsealMessage short of %d bytes\n",
                             dwAddlBufferNeeded
                             ));

                 //
                 // If we're missing data, return to get the missing data.
                 // But make sure we have enough room first!
                 //

                if (!m_pdblbufBuffer->ResizeBufferIfNeeded(dwAddlBufferNeeded)) {
                    scRet = ERROR_NOT_ENOUGH_MEMORY;
                }
                *lpdwBytesNeeded = dwAddlBufferNeeded;
                break;
            }
            else if ( scRet == 0x00090317 /*SEC_I_CONTEXT_EXPIRED*/)
            {
                //
                // Ignore this error and treat this like a simple terminator
                //  to end the connection.
                //

                scRet = ERROR_SUCCESS;
            }
            else
            {
                break;
            }
        }



        //
        // Success we decrypted a block
        //

        LPBYTE  lpExtraBuffer;
        DWORD   dwExtraBufferSize;
        LPBYTE  lpDecryptedBuffer;
        DWORD   dwDecryptedBufferSize;


        lpDecryptedBuffer       =   (LPBYTE) Buffers[1].pvBuffer;
        dwDecryptedBufferSize   =   Buffers[1].cbBuffer;

        //
        // BUGBUG [arthurbi] this is hack to work with the OLD SSLSSPI.DLL .
        //  They return extra on the second buffer instead of the third.
        //

        if ( Buffers[2].BufferType == SECBUFFER_EXTRA )
        {
            lpExtraBuffer   = (LPBYTE) Buffers[2].pvBuffer;
            dwExtraBufferSize = Buffers[2].cbBuffer;
        }
        else if ( Buffers[3].BufferType == SECBUFFER_EXTRA )
        {
            lpExtraBuffer   = (LPBYTE) Buffers[3].pvBuffer;
            dwExtraBufferSize = Buffers[3].cbBuffer;
        }
        else
        {
            lpExtraBuffer = NULL;
            dwExtraBufferSize = 0;
        }


        m_pdblbufBuffer->SetOutputInputBuffer(
            lpDecryptedBuffer,
            dwDecryptedBufferSize,
            lpExtraBuffer,
            dwExtraBufferSize,
            FALSE // don't combine.
        );

        if ( dwDecryptedBufferSize == 0 )
            break;  // No more data to process

        INET_ASSERT( *lpdwOutBufferLeft );  // don't expect to get here this way.

    } while ( *lpdwOutBufferLeft && scRet == ERROR_SUCCESS );



    DEBUG_PRINT(API,
         INFO,
         ("DecryptData returning, "
          "OutBuffer = %x, DecryptBytesRecv = %d\n",
         lpOutBuffer,
         *lpdwOutBufferBytesRead
         ));

    DEBUG_LEAVE((DWORD)scRet);

    return ( scRet );
}


VOID
ICSecureSocket::TerminateSecConnection(
    VOID
    )

/*++

Routine Description:

    This function deletes the security context handle which result
    in deleting the local data structures with which they are associated.

Arguments:

    None

Return Value:

    None

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "ICSecureSocket::TerminateSecConnection",
                 "{%#x [%#x:%#x]}",
                 this,
                 m_hContext.dwUpper,
                 m_hContext.dwLower
                 ));

    INET_ASSERT(IsSecure());

    //INET_ASSERT(m_hContext.dwLower != 0);
    //INET_ASSERT(m_hContext.dwUpper != 0);

    if (GlobalSecFuncTable)
    {
        if (!((m_hContext.dwLower == 0) && (m_hContext.dwUpper == 0)))
        {
            // There are cases where because of circular dependencies
            // schannel could get unloaded before wininet. In that case
            // this call could fault. This usually happens when the process 
            // is shutting down.
            SAFE_WRAP_REVERT_USER_VOID(g_DeleteSecurityContext,
                                       m_pSecurityInfo->IsImpersonationEnabled(),
                                       (&m_hContext));

            m_hContext.dwLower = m_hContext.dwUpper = 0;
        }
    }
    else
    {

        DEBUG_PRINT(API,
                    ERROR,
                    ("Attempting to Delete a security context, with a NULL SSPI func table!(missing SCHANNEL.DLL?)\n"
                    ));

    }

    DEBUG_LEAVE(0);
}

#ifdef SECPKG_ATTR_PROTO_INFO
/*++

ProtoInfoToString:

    This routine converts an SSPI SecPkgContext_ProtoInfo structure into a
    string.  The returned string must be released via LocalFree.

Arguments:

    pProtoInfo supplies the SecPkgContext_ProtoInfo structure to be converted to
    string representation.

Return Value:

    Non-NULL is the address of the returned string.  This must be freed via
        LocalFree once it is no longer needed.

    NULL implies no memory is available.

Author:

    Doug Barlow (dbarlow) 4/23/1996

--*/


PRIVATE
LPTSTR
ProtoInfoToString(
    IN const PSecPkgContext_ProtoInfo pProtoInfo)
{
    TCHAR
        szValue[32],
        szSep[8];
    LPTSTR
        szFinal
            = NULL;
    DWORD
        length;

    length = GetLocaleInfo(
                LOCALE_USER_DEFAULT,
                LOCALE_SDECIMAL,
                szSep,
                sizeof(szSep) / sizeof(TCHAR));
    if (0 >= length)
        lstrcpy(szSep, TEXT("."));

    length = wsprintf(
                szValue,
                TEXT("%d%s%d"),
                pProtoInfo->majorVersion,
                szSep,
                pProtoInfo->minorVersion);
    INET_ASSERT(sizeof(szValue) / sizeof(TCHAR) > length);

    length = lstrlen(pProtoInfo->sProtocolName);
    length += 2;                    // Space and Trailing NULL
    length += lstrlen(szValue);
    szFinal = (LPTSTR)ALLOCATE_MEMORY(length * sizeof(TCHAR));
    if (NULL != szFinal)
    {
        lstrcpy(szFinal, pProtoInfo->sProtocolName);
        lstrcat(szFinal, TEXT(" "));
        lstrcat(szFinal, szValue);
    }
    return szFinal;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\util.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    util.cxx

Abstract:

    Contains utility functions

    Contents:
        new
        delete
        NewString
        CatString
        ResizeBuffer
        _memrchr
        strnistr
        PrivateStrChr
        PlatformType
        PlatformSupport
        GetTimeoutValue
        ProbeReadBuffer
        ProbeWriteBuffer
        ProbeAndSetDword
        ProbeString
        LoadDllEntryPoints
        UnloadDllEntryPoints
        MapInternetError
        CalculateHashValue
        GetCurrentGmtTime
        GetFileExtensionFromUrl
        FTtoString
        PrintFileTimeInInternetFormat
        CertHashToStr
        ConvertSecurityInfoIntoCertInfoStruct
        UnicodeToUtf8
        CountUnicodeToUtf8
        ConvertUnicodeToUtf8
        StringContainsHighAnsi

Author:

    Richard L Firth (rfirth) 31-Oct-1994

Revision History:

    31-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include <aclapi.h>

#if !defined(PAGE_SIZE)
#define PAGE_SIZE   4096
#endif
#define DEFAULT_MAX_EXTENSION_LENGTH    8

//
// private prototypes
//


#ifndef WINHTTP_FOR_MSXML
//
// functions
//
void * __cdecl operator new(size_t Size) {
    return (void *)ALLOCATE_FIXED_MEMORY((UINT)Size);
}

void __cdecl operator delete(void * Pointer) {
    FREE_MEMORY((HLOCAL)Pointer);
}
#endif //!WINHTTP_FOR_MSXML



#if defined(USE_ROCKALL)


#ifdef New
#undef New
#endif

#define SIZE_DIFF 1

#if INET_DEBUG
#  if USE_ROCKALL_PAGE_HEAP
#    include <PageHeap.hpp>
#    define ROCKALL_HEAP    PAGE_HEAP
#  else
#    include <DebugHeap.hpp>
#    define ROCKALL_HEAP    DEBUG_HEAP
#  endif
#else
#  include <SmpHeap.hpp>
#  define ROCKALL_HEAP    SMP_HEAP
#endif

ROCKALL_HEAP * s_pRockAllHeap;

BYTE           s_RockAllHeapStaticBuffer[sizeof(ROCKALL_HEAP)];


void INITIALIZE_MEMORY_MANAGER()
{
    s_pRockAllHeap = (ROCKALL_HEAP *) s_RockAllHeapStaticBuffer;
    s_pRockAllHeap->ROCKALL_HEAP::ROCKALL_HEAP();
}

void TERMINATE_MEMORY_MANAGER(BOOL bReport)
{
    UNREFERENCED_PARAMETER(bReport);
    if (s_pRockAllHeap)
    {
#if INET_DEBUG
        if (bReport)
        {
            s_pRockAllHeap->HeapLeaks();
        }
#endif
        s_pRockAllHeap->ROCKALL_HEAP::~ROCKALL_HEAP();
        s_pRockAllHeap = NULL;
        ZeroMemory(s_RockAllHeapStaticBuffer, sizeof(s_RockAllHeapStaticBuffer));
    }
}

void MEMORY_MANAGER_ON_THREAD_DETACH()
{
#if !INET_DEBUG
    if (s_pRockAllHeap)
    {
        SMP_HEAP::ThreadDetach(s_pRockAllHeap, DLL_THREAD_DETACH);
    }
#endif
}


void *
ALLOCATOR(int Flags, int Size)
{
    INET_ASSERT(s_pRockAllHeap && "Heap not initialized!");
    return s_pRockAllHeap->New(Size, NULL, ((Flags & LMEM_ZEROINIT) ? true : false));
}

void *
DEALLOCATOR(void * hLocal)
{
    INET_ASSERT(s_pRockAllHeap && "Heap not initialized!");
    DWORD error = GetLastError();
    void * p = (s_pRockAllHeap->Delete(hLocal) ? NULL : hLocal);
    SetLastError(error);
    return p;
}

void *
REALLOCATOR(void * hLocal, int Size, int Flags)
{
    INET_ASSERT(s_pRockAllHeap && "Heap not initialized!");
    return s_pRockAllHeap->Resize(hLocal, 
                    Size, 
                    ((Flags & LMEM_MOVEABLE) ? SIZE_DIFF : 0), 
                    NULL, 
                    false, 
                    ((Flags & LMEM_ZEROINIT) ? true : false));
}

int
MEMORYSIZER(void * hLocal)
{
    int Size;
    INET_ASSERT(s_pRockAllHeap && "Heap not initialized!");
    s_pRockAllHeap->Details(hLocal, &Size);
    return Size;
}


#elif defined(USE_LOWFRAGHEAP) //defined(USE_ROCKALL)


HANDLE g_hLowFragHeap = NULL;

#define HEAP_FRONT_LOWFRAGHEAP  2 //see sdnt\base\ntos\rtl\heappriv.h and sdnt\base\ntos\rtl\heapdll.c for details

#if defined(LFH_DEBUG) && !INET_DEBUG
	#define LFH_ASSERT3(assert, file, line_num) \
		do { if (!(assert)) { OutputDebugString(file "(" #line_num ") : LFH_ASSERT : " #assert "\r\n"); \
		DebugBreak(); } } while(0)
	#define LFH_ASSERT2(assert, f, n) LFH_ASSERT3(assert, f, n)
	#define LFH_ASSERT(assert) LFH_ASSERT2((assert), __FILE__, __LINE__);
#else //defined(LFH_DEBUG) && !INET_DEBUG
	#define LFH_ASSERT INET_ASSERT
#endif //defined(LFH_DEBUG) && !INET_DEBUG

BOOL INITIALIZE_MEMORY_MANAGER()
{
    g_hLowFragHeap = HeapCreate(0, 0, 0);
	LFH_ASSERT(g_hLowFragHeap && "LFH HeapCreate");
	if (!g_hLowFragHeap)
		return FALSE;

#if !defined(LFH_NO_ACTIVATION)
    ULONG ulHeapMode = HEAP_FRONT_LOWFRAGHEAP;
    BOOL fRes = HeapSetInformation(g_hLowFragHeap, HeapCompatibilityInformation, &ulHeapMode, sizeof(ulHeapMode));
	LFH_ASSERT(fRes && "LFH HeapSetInformation");
	if (fRes)
		return TRUE;
	else
	{
		HeapDestroy(g_hLowFragHeap);
		g_hLowFragHeap = NULL;
		return FALSE;
	}
#else //!defined(LFH_NO_ACTIVATION)
	return TRUE;
#endif //!defined(LFH_NO_ACTIVATION)
}

void TERMINATE_MEMORY_MANAGER(BOOL)
{
	LFH_ASSERT(g_hLowFragHeap && "LFH Heap not initialized");
	if (g_hLowFragHeap)
	{
		HeapDestroy(g_hLowFragHeap);
		g_hLowFragHeap = NULL;
	}
}

#if INET_DEBUG || defined(LFH_DEBUG)

PVOID LFHDebugAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T stSize)
{
	LFH_ASSERT(hHeap && "LFH Heap not initialized");

	PVOID pRes = HeapAlloc(hHeap, dwFlags, stSize);

	return pRes;
}

BOOL LFHDebugFree(HANDLE hHeap, DWORD dwFlags, PVOID ptr)
{
	LFH_ASSERT(hHeap && "LFH Heap not initialized");

	BOOL bRes = HeapFree(hHeap, dwFlags, ptr);

	LFH_ASSERT(bRes && "LFH Free");

	return bRes;
}

PVOID LFHDebugReAlloc(HANDLE hHeap, DWORD dwFlags, PVOID ptr, SIZE_T stSize)
{
	LFH_ASSERT(hHeap && "LFH Heap not initialized");

	PVOID pRes = HeapReAlloc(hHeap, dwFlags, ptr, stSize);

	return pRes;
}

SIZE_T LFHDebugSize(HANDLE hHeap, DWORD dwFlags, PVOID ptr)
{
	LFH_ASSERT(hHeap && "LFH Heap not initialized");

	SIZE_T stRes = HeapSize(hHeap, dwFlags, ptr);

	LFH_ASSERT((stRes != (SIZE_T)-1) && "LFH Size");

	return stRes;
}

#endif //INET_DEBUG || defined(LFH_DEBUG)


#endif //defined(USE_LOWFRAGHEAP) //defined(USE_ROCKALL)

LPSTR
NewString(
    IN LPCSTR lpszIn,
    IN DWORD dwLen
    )

/*++

Routine Description:

    kind of version of strdup() but using LocalAlloc to allocate memory

Arguments:

    String  - pointer to string to make copy of

Return Value:

    LPSTR
        Success - pointer to duplicated string
        Failure - NULL

--*/

{
    int len = (dwLen ? dwLen : strlen(lpszIn));
    LPSTR lpszOut;

    if ((lpszOut = (LPSTR)ALLOCATE_FIXED_MEMORY(len+1)) != NULL) {
        if (lpszIn) {
            memcpy(lpszOut, lpszIn, len);
        }
        *(lpszOut + len) = '\0';
    }
    return lpszOut;
}


LPSTR
NewString(
    IN DWORD dwLen
    )
{
    LPSTR lpszOut;

    if ((lpszOut = (LPSTR)ALLOCATE_FIXED_MEMORY(dwLen+1)) != NULL) {
        *lpszOut = '\0';
    }
    return lpszOut;
}


LPWSTR
NewStringW(
    IN LPCWSTR lpszIn,
    IN DWORD dwLen
    )

/*++

Routine Description:

    kind of version of strdup() but using LocalAlloc to allocate memory

Arguments:

    String  - pointer to string to make copy of

Return Value:

    LPSTR
        Success - pointer to duplicated string
        Failure - NULL

--*/

{
    int len = (dwLen ? dwLen : lstrlenW(lpszIn));
    LPWSTR lpszOut;

    if ((lpszOut = (LPWSTR)ALLOCATE_FIXED_MEMORY((sizeof(WCHAR)*(len+1))))!= NULL) {
        memcpy(lpszOut, lpszIn, len*sizeof(WCHAR));
        *(lpszOut + len) = L'\0';
    }
    return lpszOut;
}

/*++

Routine Description:

    kind of version of strcat() but using LocalAlloc to allocate memory

Arguments:

    strings to concatenate

Return Value:

    LPSTR
        Success - pointer to duplicated string
        Failure - NULL

--*/

LPSTR
CatString (
    IN LPCSTR lpszLeft,
    IN LPCSTR lpszRight
    )
{
    int cbLeft  = strlen(lpszLeft);
    int cbRight = strlen(lpszRight) + 1; // include null termination
    LPSTR lpszOut;

    if ((lpszOut = (LPSTR) ALLOCATE_FIXED_MEMORY (cbLeft + cbRight)) != NULL) {
        memcpy (lpszOut, lpszLeft, cbLeft);
        memcpy (lpszOut + cbLeft, lpszRight, cbRight);
    }
    return lpszOut;
}



HLOCAL
ResizeBuffer(
    IN HLOCAL BufferHandle,
    IN DWORD Size,
    IN BOOL Moveable
    )

/*++

Routine Description:

    Allocate, reallocate or free a buffer. If the buffer is moveable memory
    then it must be unlocked. If reallocating, the buffer can be grown or
    shrunk, depending on the current and required sizes

    Caveat Programmer:

    Regardless of whether a pre-existing buffer is moveable or fixed memory,
    it will be reallocated with the LMEM_MOVEABLE flag, possibly causing the
    output pointer to be different from the pre-existing pointer

Arguments:

    BufferHandle    - current handle of memory buffer. If NULL, a buffer will
                      be allocated

    Size            - size of buffer to allocate (or shrink to). If 0, the
                      buffer will be freed

    Moveable        - if TRUE and allocating memory then allocates a moveable
                      memory buffer, else fixed

Return Value:

    HLOCAL
        Success - handle of moveable memory buffer

        Failure - NULL;

--*/

{
    UNREFERENCED_PARAMETER(Moveable);
    INET_ASSERT(!Moveable);

    if (BufferHandle == NULL) {

        //
        // don't allocate anything if no size - LocalAlloc() will return pointer
        // to memory object marked as discarded if we request a zero-length
        // moveable buffer. But I know that if Size is also 0, I don't want a
        // buffer at all, discarded or otherwise
        //

        if (Size != 0) {
            BufferHandle = ALLOCATE_MEMORY(Size);
        }
    } else if (Size == 0) {
        BufferHandle = FREE_MEMORY(BufferHandle);

        INET_ASSERT(BufferHandle == NULL);

    } else {
		LPVOID pNewBuf = REALLOCATE_MEMORY(BufferHandle, Size);
		if (!pNewBuf)
			FREE_MEMORY(BufferHandle);
		BufferHandle = pNewBuf;
    }
    return BufferHandle;
}


LPSTR
_memrchr(
    IN LPSTR lpString,
    IN CHAR cTarget,
    IN INT iLength
    )

/*++

Routine Description:

    Reverse find character in string

Arguments:

    lpString    - pointer to string in which to locate character

    cTarget     - target character to find

    iLength     - length of string

Return Value:

    LPSTR   - pointer to located character or NULL

--*/

{
    for (--iLength; (iLength >= 0) && (lpString[iLength] != cTarget); --iLength) {

        //
        // empty loop
        //

    }
    return (iLength < 0) ? NULL : &lpString[iLength];
}


LPSTR
strnistr(
    IN LPSTR str1,
    IN LPSTR str2,
    IN DWORD Length
    )

/*++

Routine Description:

    Case-insensitive search for substring

Arguments:

    str1    - string to search in

    str2    - substring to find

    Length  - of str1

Return Value:

    LPSTR   - pointer to located str2 in str1 or NULL

--*/

{
    if (!*str2) {
        return str1;
    }

    for (LPSTR cp = str1; *cp && Length; ++cp, --Length) {

        LPSTR s1 = cp;
        LPSTR s2 = str2;
        DWORD l2 = Length;

        while (*s1 && *s2 && l2 && (toupper(*s1) == toupper(*s2))) {
            ++s1;
            ++s2;
            --l2;
        }

        if (!*s2) {
            return cp;
        }

        if (!l2) {
            break;
        }
    }

    return NULL;
}

LPSTR
FASTCALL
PrivateStrChr(
    IN LPCSTR lpStart,
    IN WORD wMatch
    )
/*++

Routine Description:

    Find first occurrence of character in string

    Private implimentation of StrChrA, this code is based on
     a code snipet from ShlWapi, but by placing it here,
     we can remove the extra NLS support that was needed
     in SHLWAPI.   This piece of code is over twice as fast
     as the call into SHLWAPI.

Arguments:

    lpStart - points to start of null terminated string

    wMatch  - the character to match

Return Value:

    LPSTR   - ptr to the first occurrence of ch in str, NULL if not found.

--*/
{
    for ( ; *lpStart; lpStart++)
    {
        if ((BYTE)*lpStart == LOBYTE(wMatch)) {
            return((LPSTR)lpStart);
        }
    }

    return (NULL);
}


DWORD
GetTickCountWrap()
{
#ifdef DEBUG_GETTICKCOUNT
    static BOOL fInit = FALSE;
    static DWORD dwDelta = 0;
    static DWORD dwBasis = 0;

    if (!fInit)
    {
        HKEY clientKey;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"),
                                 0, // reserved
                                 KEY_QUERY_VALUE,
                                 &clientKey))
        {
            DWORD dwSize = sizeof(dwDelta);
            RegQueryValueEx(clientKey, "RollOverDelta", NULL, NULL, (LPBYTE)&dwDelta, &dwSize);
        }
        dwBasis = GetTickCount();
        fInit = TRUE;
    }
    DWORD dwResult = GetTickCount() - dwBasis + dwDelta;
    return dwResult;
#else
    return GetTickCount();
#endif
}


DWORD
PlatformType(
    IN OUT LPDWORD lpdwVersion5os
    )

/*++

Routine Description:

    Returns the platform type based on the operating system information. We use
    our own platform types

Arguments:

    lpdwVersion5os - optional pointer to value, set to TRUE if we on NT 5

Return Value:

    DWORD
        Failure - PLATFORM_TYPE_UNKNOWN
                    either GetVersionEx() failed, or we are running on an
                    unrecognized operating system

        Success - PLATFORM_TYPE_WIN95
                    The world's favourite desktop O/S

                  PLATFORM_TYPE_WINNT
                    The world's best O/S on top of anything

--*/

{
#ifndef UNIX
    OSVERSIONINFO versionInfo;

    *lpdwVersion5os = FALSE;

    versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);
    if (GetVersionEx(&versionInfo)) {
        switch (versionInfo.dwPlatformId) {
        case VER_PLATFORM_WIN32_WINDOWS:
            if(versionInfo.dwMinorVersion >= 90) {
                GlobalPlatformMillennium = TRUE;
            }
            return PLATFORM_TYPE_WIN95;

        case VER_PLATFORM_WIN32_NT:

            if ( lpdwVersion5os && 
                versionInfo.dwMajorVersion >= 5 ) {                
                *lpdwVersion5os = TRUE;

                if (versionInfo.dwMinorVersion >= 1) {
                    GlobalPlatformWhistler = TRUE;
                }

                if (versionInfo.dwMinorVersion >= 2) {
                    GlobalPlatformDotNet = TRUE;
                }
            }            
            return PLATFORM_TYPE_WINNT;

        }

    }
    return PLATFORM_TYPE_UNKNOWN;
#else
    return PLATFORM_TYPE_UNIX;
#endif /* UNIX */
}

//
//DWORD
//PlatformSupport(
//    VOID
//    )
//
///*++
//
//Routine Description:
//
//    Returns a bitmap of capabilities supported by this operating system
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    DWORD
//
//--*/
//
//{
//    switch (PlatformType()) {
//    case PLATFORM_TYPE_WINNT:
//        return PLATFORM_SUPPORTS_UNICODE;
//    }
//    return 0;
//}


DWORD
GetTimeoutValue(
    IN DWORD TimeoutOption
    )

/*++

Routine Description:

    Gets a timeout value. The timeout is retrieved from the current handle. If
    it is not available in the current handle then the parent handle is checked
    (actually the current handle is derived from the parent, so this doesn't
    really do anything). If the value is still not available, then the global
    default is used

Arguments:

    TimeoutOption   - WINHTTP_OPTION_ value used to specify the timeout value

Return Value:

    DWORD
        Requested timeout value

--*/

{
    HINTERNET hInternet;
    DWORD timeout = 0;
    DWORD error = ERROR_SUCCESS;
    HINTERNET_HANDLE_TYPE handleType;
    
    hInternet = InternetGetMappedObjectHandle();
    
    if (hInternet) 
    {
        error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
        
        if (error == ERROR_SUCCESS) 
        {
            error = RGetHandleType(hInternet, &handleType);

            if (error == ERROR_SUCCESS)
            {
                switch(handleType)
                {
                case TypeHttpRequestHandle:
                    //no error possible here
                    timeout = ((HTTP_REQUEST_HANDLE_OBJECT*)hInternet)->GetTimeout(TimeoutOption);
                    break;
                case TypeHttpConnectHandle:
                    //no timeouts on this handle
                    //go up to parent
                    hInternet = (HINTERNET)GetRootHandle((INTERNET_CONNECT_HANDLE_OBJECT *)hInternet);
                    //fall through
                case TypeInternetHandle:            
                    //either there was an error in allocing memory for OPTIONAL_PARAMS struct
                    //or the option may not have been set
                    //in either case, force the global timeout choice by setting an error (not propagated)
                    if (! ((INTERNET_HANDLE_OBJECT*)hInternet)->GetTimeout(TimeoutOption, &timeout) )
                        error = (DWORD)E_FAIL;
                    break;
                default:
                    error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
                    break;
                }
            }
        }
    }
    
    if ( !hInternet || (error != ERROR_SUCCESS)) 
    {
    //should this ever happen?
        INET_ASSERT(FALSE);
        switch (TimeoutOption) {
        case WINHTTP_OPTION_RESOLVE_TIMEOUT:
            timeout = GlobalResolveTimeout;
            break;

        case WINHTTP_OPTION_CONNECT_TIMEOUT:
            timeout = GlobalConnectTimeout;
            break;

        case WINHTTP_OPTION_CONNECT_RETRIES:
            timeout = GlobalConnectRetries;
            break;

        case WINHTTP_OPTION_SEND_TIMEOUT:
            timeout = GlobalSendTimeout;
            break;

        case WINHTTP_OPTION_RECEIVE_TIMEOUT:
            timeout = GlobalReceiveTimeout;
            break;

        case WINHTTP_OPTION_RECEIVE_RESPONSE_TIMEOUT:
            timeout = GlobalReceiveResponseTimeout;
            break;
            
        default:
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            timeout = 0;
            break;
        }
    }
    return timeout;
}


DWORD
ProbeReadBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Probes a buffer for readability. Used as part of API parameter validation,
    this function tests the first and last locations in a buffer. This is not
    as strict as the IsBadXPtr() Windows APIs, but it means we don't have to
    test every location in the buffer

Arguments:

    lpBuffer        - pointer to buffer to test

    dwBufferLength  - length of buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;

    //
    // the buffer can be NULL if the probe length is 0. Otherwise, its an error
    //

    if (lpBuffer == NULL) {
        error = (dwBufferLength == 0) ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;
    } else if (dwBufferLength != 0) {
        __try {

            LPBYTE p;
            LPBYTE end;
            volatile BYTE b;

            p = (LPBYTE)lpBuffer;
            end = p + dwBufferLength - 1;
            b = *end;

            //
            // visit every page in the buffer - it doesn't matter that we may
            // test a character in the middle of a page
            //

            for (; p < end; p += PAGE_SIZE) {
                b = *p;
            }
            error = ERROR_SUCCESS;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    } else {

        //
        // zero-length buffer
        //

        error = ERROR_INVALID_PARAMETER;
    }

    return error;
}


DWORD
ProbeWriteBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Probes a buffer for writeability. Used as part of API parameter validation,
    this function tests the first and last locations in a buffer. This is not
    as strict as the IsBadXPtr() Windows APIs, but it means we don't have to
    test every location in the buffer

Arguments:

    lpBuffer        - pointer to buffer to test

    dwBufferLength  - length of buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;

    //
    // the buffer can be NULL if the probe length is 0. Otherwise, its an error
    //

    if (lpBuffer == NULL) {
        error = (dwBufferLength == 0) ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;
    } else if (dwBufferLength != 0) {
        __try {

            LPBYTE p;
            LPBYTE end;
            volatile BYTE b;

            p = (LPBYTE)lpBuffer;
            end = p + dwBufferLength - 1;
            b = *end;
            *end = b;

            //
            // visit every page in the buffer - it doesn't matter that we may
            // test a character in the middle of a page
            //

            for (; p < end; p += PAGE_SIZE) {
                b = *p;
                *p = b;
            }
            error = ERROR_SUCCESS;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    } else {

        //
        // zero-length buffer
        //

        error = ERROR_SUCCESS;
    }

    return error;
}


DWORD
ProbeAndSetDword(
    IN LPDWORD lpDword,
    IN DWORD dwValue
    )

/*++

Routine Description:

    Probes a single DWORD buffer for writeability, and as a side-effect sets it
    to a default value. Used as part of API parameter validation

Arguments:

    lpDword - pointer to DWORD buffer to test

    dwValue - default value to set

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;

    __try {
        *lpDword = dwValue;
        error = ERROR_SUCCESS;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_PARAMETER;
    }
    ENDEXCEPT
    return error;
}


DWORD
ProbeString(
    IN LPSTR lpString,
    OUT LPDWORD lpdwStringLength
    )

/*++

Routine Description:

    Probes a string buffer for readability, and returns the length of the string

Arguments:

    lpString            - pointer to string to check

    lpdwStringLength    - returned length of string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;
    DWORD length;

    //
    // initialize string length and return code
    //

    length = 0;
    error = ERROR_SUCCESS;

    //
    // the buffer can be NULL
    //

    if (lpString != NULL) {
        __try {

            //
            // unfortunately, for a string, we have to visit every location in
            // the buffer to find the terminator
            //

            while (*lpString != '\0') {
                ++length;
                ++lpString;
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    }

    *lpdwStringLength = length;

    return error;
}

DWORD
ProbeStringW(
    IN LPWSTR lpString,
    OUT LPDWORD lpdwStringLength
    )

/*++

Routine Description:

    Probes a wide string buffer for readability, and returns the length of the string

Arguments:

    lpString            - pointer to string to check

    lpdwStringLength    - returned length of string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;
    DWORD length;

    //
    // initialize string length and return code
    //

    length = 0;
    error = ERROR_SUCCESS;

    //
    // the buffer can be NULL
    //

    if (lpString != NULL) {
        __try {

            //
            // unfortunately, for a string, we have to visit every location in
            // the buffer to find the terminator
            //

            while (*lpString != '\0') {
                ++length;
                ++lpString;
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    }

    *lpdwStringLength = length;

    return error;
}


DWORD
LoadDllEntryPoints(
    IN OUT LPDLL_INFO lpDllInfo,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Dynamically loads a DLL and the entry points described in lpDllEntryPoints

    Assumes:    1. Any thread serialization taken care of by caller

                2. Module handle, entry point addresses and reference count
                   already set to 0 if this is first time the DLL_INFO is
                   being used to load the DLL

Arguments:

    lpDllInfo   - pointer to DLL_INFO structure containing all info about DLL
                  and entry points to load

    dwFlags     - flags controlling how this function operates:

                    LDEP_PARTIAL_LOAD_OK
                        - not fatal if we can't load all entry points

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                 Dword,
                 "LoadDllEntryPoints",
                 "%x [%q, %d], %#x",
                 lpDllInfo,
                 lpDllInfo->lpszDllName,
                 lpDllInfo->dwNumberOfEntryPoints,
                 dwFlags
                 ));

    DWORD error = ERROR_SUCCESS;

    if (lpDllInfo->hModule == NULL) {

        DWORD dwMode = SetErrorMode(SEM_FAILCRITICALERRORS);
        HMODULE hDll = LoadLibrary(lpDllInfo->lpszDllName);

        if (hDll != NULL) {
            lpDllInfo->hModule = hDll;
            lpDllInfo->LoadCount = 1;

            for (DWORD i = 0; i < lpDllInfo->dwNumberOfEntryPoints; ++i) {

                FARPROC proc = GetProcAddress(
                                    hDll,
                                    lpDllInfo->lpEntryPoints[i].lpszProcedureName
                                    );

                *lpDllInfo->lpEntryPoints[i].lplpfnProcedure = proc;
                if ((proc == NULL) && !(dwFlags & LDEP_PARTIAL_LOAD_OK)) {
                    error = GetLastError();
                    UnloadDllEntryPoints(lpDllInfo, TRUE);
                    break;
                }
            }
        } else {
            error = GetLastError();
        }
        SetErrorMode(dwMode);
    } else {

        DEBUG_PRINT(UTIL,
                    INFO,
                    ("info for %q already loaded\n",
                    lpDllInfo->lpszDllName
                    ));

        InterlockedIncrement(&lpDllInfo->LoadCount);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
UnloadDllEntryPoints(
    IN OUT LPDLL_INFO lpDllInfo,
    IN BOOL bForce
    )

/*++

Routine Description:

    Undoes the work of LoadDllEntryPoints()

    Assumes:    1. Any thread serialization taken care of by caller

Arguments:

    lpDllInfo   - pointer to DLL_INFO structure containing all info about DLL
                  and (loaded) entry points

    bForce      - TRUE if the DLL will be unloaded irrespective of the usage
                  count

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                Dword,
                "UnloadDllEntryPoints",
                "%x [%q, %d], %B",
                lpDllInfo,
                lpDllInfo->lpszDllName,
                lpDllInfo->dwNumberOfEntryPoints,
                bForce
                ));

    DWORD error = ERROR_SUCCESS;

    if (bForce) {
        lpDllInfo->LoadCount = 0;
    } else if (InterlockedDecrement(&lpDllInfo->LoadCount) == 0) {
        bForce = TRUE;
    }
    if (bForce && (lpDllInfo->hModule != NULL)) {
        if (!FreeLibrary(lpDllInfo->hModule)) {
            error = GetLastError();
        }

        //
        // even if FreeLibrary() failed we clear out the load info
        //

        lpDllInfo->hModule = NULL;
        for (DWORD i = 0; i < lpDllInfo->dwNumberOfEntryPoints; ++i) {
            *lpDllInfo->lpEntryPoints[i].lplpfnProcedure = NULL;
        }
    }

    DEBUG_LEAVE(error);

    return error;
}

#ifndef CERT_E_WRONG_USAGE
#   define CERT_E_WRONG_USAGE              _HRESULT_TYPEDEF_(0x800B0110)
#endif


DWORD
MapInternetError(
    IN DWORD dwErrorCode,
    IN LPDWORD lpdwStatus /* = NULL */
    )

/*++

Routine Description:

    Maps a winsock/RPC/transport error into a more user-friendly WinInet error,
    and stores the original error in the per-thread context so that the app can
    retrieve it if it really cares

    N.B. We should no longer be receiving winsock errors directly at the WinInet
    interface. They are available via InternetGetLastResponseInfo()

Arguments:

    dwErrorCode - original (winsock) error code to map

Return Value:

    DWORD
        Mapped error code, or the orignal error if its not one that we handle

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD dwStatus = 0;

    DEBUG_ENTER((DBG_UTIL,
                Dword,
                "MapInternetError",
                "%#x [%s]",
                dwErrorCode,
                InternetMapError(dwErrorCode)
                ));

    if(dwErrorCode != ERROR_SUCCESS)
    {
        TRACE_PRINT_API(THRDINFO,
            INFO,
            ("Winsock/RPC/SSL/Transport error: "
            "%#x [%s]\n",
            dwErrorCode,
            InternetMapError(dwErrorCode)
            ));
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo) {
        lpThreadInfo->dwMappedErrorCode = dwErrorCode;
    }

    switch (dwErrorCode) {

    case SEC_E_INSUFFICIENT_MEMORY        :
        dwErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case SEC_E_INVALID_HANDLE             :
    case SEC_E_UNSUPPORTED_FUNCTION       :
    case SEC_E_TARGET_UNKNOWN             :
    case SEC_E_INTERNAL_ERROR             :
    case SEC_E_SECPKG_NOT_FOUND           :
    case SEC_E_NOT_OWNER                  :
    case SEC_E_CANNOT_INSTALL             :
    case SEC_E_INVALID_TOKEN              :
    case SEC_E_CANNOT_PACK                :
    case SEC_E_QOP_NOT_SUPPORTED          :
    case SEC_E_NO_IMPERSONATION           :
    case SEC_E_LOGON_DENIED               :
    case SEC_E_UNKNOWN_CREDENTIALS        :
    case SEC_E_NO_CREDENTIALS             :
    case SEC_E_MESSAGE_ALTERED            :
    case SEC_E_OUT_OF_SEQUENCE            :
    case SEC_E_NO_AUTHENTICATING_AUTHORITY:
    case SEC_I_CONTINUE_NEEDED            :
    case SEC_I_COMPLETE_NEEDED            :
    case SEC_I_COMPLETE_AND_CONTINUE      :
    case SEC_I_LOCAL_LOGON                :
    case SEC_E_BAD_PKGID                  :
    case SEC_E_CONTEXT_EXPIRED            :
    case SEC_E_INCOMPLETE_MESSAGE         :
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_SECURITY_CHANNEL_ERROR;
        break;

    // Cert and Encryption errors

    case CERT_E_EXPIRED:
    case CERT_E_VALIDITYPERIODNESTING:
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID;
        break;

    case CERT_E_UNTRUSTEDROOT:
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA;
        break;

    case CERT_E_CN_NO_MATCH:
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID;
        break;

    case CRYPT_E_REVOKED:
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED;
        break;

    // ignore revocation if the certificate does not have a CDP
    case CRYPT_E_NO_REVOCATION_CHECK:
        dwErrorCode = ERROR_SUCCESS;
        break;

    case CRYPT_E_REVOCATION_OFFLINE:
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED;
        break;

    case CERT_E_ROLE:
    case CERT_E_PATHLENCONST:
    case CERT_E_CRITICAL:
    case CERT_E_PURPOSE:
    case CERT_E_ISSUERCHAINING:
    case CERT_E_MALFORMED:
    case CERT_E_CHAINING:
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CERT;
        break;

    case CERT_E_WRONG_USAGE:
        // We can't allow connection if server doesn't have a server auth certificate.
        // To force CERT_E_WRONG_USAGE to error out we map it to the error below.
        // In the future we need to map it to it's own non-recoverable error, so we can 
        // give the user a specific error message.
        dwErrorCode = ERROR_WINHTTP_SECURE_FAILURE;
        dwStatus    = WINHTTP_CALLBACK_STATUS_FLAG_CERT_WRONG_USAGE;
        break;

    case WSAEINTR:
    case WSAEBADF:
    case WSAEACCES:
    case WSAEFAULT:
    case WSAEINVAL:
    case WSAEMFILE:
    case WSAEADDRINUSE:
    case WSAEADDRNOTAVAIL:
        dwErrorCode = ERROR_WINHTTP_INTERNAL_ERROR;
        break;

    case WSAENOTSOCK:

        //
        // typically, if we see this error its because we tried to use a closed
        // socket handle
        //
        dwErrorCode = ERROR_WINHTTP_OPERATION_CANCELLED;
        break;

    case WSAEWOULDBLOCK:
    case WSAEINPROGRESS:
    case WSAEALREADY:
    case WSAEDESTADDRREQ:
    case WSAEPROTOTYPE:
    case WSAENOPROTOOPT:
    case WSAEPROTONOSUPPORT:
    case WSAESOCKTNOSUPPORT:
    case WSAEOPNOTSUPP:
    case WSAEISCONN:
    case WSAETOOMANYREFS:
    case WSAELOOP:
    case WSAENAMETOOLONG:
    case WSAENOTEMPTY:
    case WSAEPROCLIM:
    case WSAEUSERS:
    case WSAEDQUOT:
    case WSAESTALE:
    case WSAEREMOTE:
    case WSAEDISCON:
    case WSASYSNOTREADY:
    case WSAVERNOTSUPPORTED:
    case WSANOTINITIALISED:

        //
        // currently unmapped errors
        //

        break;

    case WSAEMSGSIZE:
        dwErrorCode = ERROR_INSUFFICIENT_BUFFER;
        break;

    case WSAEPFNOSUPPORT:
    case WSAEAFNOSUPPORT:
        dwErrorCode = ERROR_NOT_SUPPORTED;
        break;

    case WSAECONNABORTED:
    case WSAESHUTDOWN:

    case WSAECONNRESET:
    case WSAENETRESET:
        dwErrorCode = ERROR_WINHTTP_CONNECTION_ERROR;
        break;

    case WSAENOBUFS:
        dwErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case WSAETIMEDOUT:
        dwErrorCode = ERROR_WINHTTP_TIMEOUT;
        break;

    case WSAENETDOWN:
    case WSAECONNREFUSED:
    case WSAENETUNREACH:
    case WSAENOTCONN:
        dwErrorCode = ERROR_WINHTTP_CANNOT_CONNECT;
        break;

    case WSAEHOSTDOWN:
    case WSAEHOSTUNREACH:
    case WSAHOST_NOT_FOUND:
    case WSATRY_AGAIN:
    case WSANO_RECOVERY:
    case WSANO_DATA:
        dwErrorCode = ERROR_WINHTTP_NAME_NOT_RESOLVED;
        break;

    default:

        DEBUG_PRINT(UTIL,
                    WARNING,
                    ("MapInternetError(): unmapped error code %d [%#x]\n",
                    dwErrorCode,
                    dwErrorCode
                    ));

        break;
    }

    if (lpdwStatus)
    {
        *lpdwStatus = dwStatus;
        DEBUG_PRINT(UTIL,
                    INFO,
                    ("MapInternetError(): mapped status flag %#x\n",
                    *lpdwStatus
                    ));
    }

    DEBUG_LEAVE(dwErrorCode);

    return dwErrorCode;
}


DWORD
CalculateHashValue(
    IN LPSTR lpszString
    )

/*++

Routine Description:

    Calculate a hash number given a string

Arguments:

    lpszString  - string to hash

Return Value:

    DWORD

--*/

{
    DWORD hashValue = 0;
    DWORD position = 1;

    while (*lpszString) {
        hashValue += *lpszString * position;
        ++lpszString;
        ++position;
    }
    return hashValue;
}



VOID GetCurrentGmtTime(
    LPFILETIME  lpFt
    )
/*++

Routine Description:
    This routine returns the current GMT time

Arguments:

    lpFt    FILETIME strucutre in which this is returned

Returns:

Comments:

--*/
{
    SYSTEMTIME sSysT;

    GetSystemTime(&sSysT);
    SystemTimeToFileTime(&sSysT, lpFt);
}



LPTSTR
FTtoString(
    IN FILETIME *pftTime)

/*++

FTtoString:

    This routine converts a given FILETIME structure to a string representing
    the given date and time in the local format.

Arguments:

    pftTime supplies the FILETIME structure to convert.

Return Value:

    NULL - Memory allocation failure.
    Otherwise, the address of the string, allocated via LocalAlloc.

Author:

    Doug Barlow (dbarlow) 4/12/1996

--*/

{
    LONG cchTotal, cchNeeded;
    SYSTEMTIME stTime, stLocal;
    LPTSTR szDateTime = NULL;


    //
    // Convert the FILETIME to a SYSTEMTIME.
    //

    if (!FileTimeToSystemTime(pftTime, &stTime))
        goto ErrorExit;

    //
    // For now, leave it in GMT time, function not implimented in Win'95.
    //

    //if ( IsPlatformWinNT() )
    //{
    //    if (!SystemTimeToTzSpecificLocalTime(NULL, &stTime, &stLocal))
    //        goto ErrorExit;
    //}
    //else
    {
        stLocal = stTime;
    }


    //
    // Calculate how long the date string will be.
    //

    cchTotal =
        GetDateFormat(
            LOCALE_SYSTEM_DEFAULT,
            DATE_SHORTDATE,
            &stLocal,
            NULL,
            NULL,
            0);
    if (0 >= cchTotal)
        goto ErrorExit;
    cchNeeded =
        GetTimeFormat(
            LOCALE_SYSTEM_DEFAULT,
            0,
            &stLocal,
            NULL,
            NULL,
            0);
    if (0 >= cchNeeded)
        goto ErrorExit;
    cchTotal += cchNeeded;
    cchTotal += 4 * sizeof(TCHAR);  // space, trailing NULL, and two extra.
    szDateTime = (LPTSTR)ALLOCATE_MEMORY(cchTotal);
    if (NULL == szDateTime)
        goto ErrorExit;


    //
    // Fill in the time string.
    //

    cchNeeded =
        GetDateFormat(
            LOCALE_SYSTEM_DEFAULT,
            DATE_SHORTDATE,
            &stLocal,
            NULL,
            szDateTime,
            cchTotal);
    if (0 >= cchNeeded)
        goto ErrorExit;
    lstrcat(szDateTime, TEXT(" "));
    cchNeeded = lstrlen(szDateTime);
    cchNeeded =
        GetTimeFormat(
            LOCALE_SYSTEM_DEFAULT,
            0,
            &stLocal,
            NULL,
            &szDateTime[cchNeeded],
            cchTotal - cchNeeded);
    if (0 >= cchNeeded)
        goto ErrorExit;
    return szDateTime;


ErrorExit:
    if (NULL != szDateTime)
        FREE_MEMORY(szDateTime);
    return NULL;
}


BOOL
CertHashToStr(
    IN LPSTR lpMD5Hash,
    IN DWORD dwMD5HashSize,
    IN OUT LPSTR *lplpszHashStr
    )
/*++

Routine Description:

    Converts a set of bytes into a neatly formated string of ':' (colon) seperated
      hex digits that can be shown to the user.

Arguments:

    lpMD5Hash - ptr to set of hash bytes

    dwMD5HashSize - size of lpMD5Hash

    lplpszHashStr - ptr to ptr where newly allocated return string will be stored.

Return Value:

    BOOL

--*/

{

    DWORD dwStrSize = (2*dwMD5HashSize) + dwMD5HashSize;
    LPSTR lpszHashStr;

    *lplpszHashStr = new CHAR[dwStrSize];

    if ( *lplpszHashStr == NULL )
    {
        return FALSE;
    }

    lpszHashStr = *lplpszHashStr;

    for ( DWORD i = 0 ; i < dwMD5HashSize; i++ )
    {
        unsigned char uHashByte;

        if ( i != 0 )
        {
            *lpszHashStr = ':';
            lpszHashStr++;
        }

        uHashByte = (unsigned char) * ( ((unsigned char * ) lpMD5Hash) + i);

        wsprintf( lpszHashStr, "%02X", uHashByte);

        lpszHashStr += 2;

    }

    INET_ASSERT( *lpszHashStr == '\0' );

    return TRUE;
}


//
// private functions
//

DWORD
ConvertSecurityInfoIntoCertInfoStruct(
    IN  LPINTERNET_SECURITY_INFO   pSecInfo,
    OUT INTERNET_CERTIFICATE_INFO *pCertificate,
    IN OUT DWORD *pcbCertificate
    )
/*++

Routine Description:

    Converts an X509 Certificate Structure into a WININET struct
    used for storing the same info.

Arguments:

    hContext        - Context handle of the active SSPI session.

    pCertInfo       - Pointer to Structure where info is returned in.

Return Value:

    DWORD
    ERROR_SUCCESS   - if cert cannot be converted

    ERROR_NOT_ENOUGH_MEMORY

--*/

{


    DWORD   error = ERROR_SUCCESS;
    PCERT_INFO pCertInfo = NULL;
    DWORD cbSubject = 0,
          cbIssuer = 0;

    BOOL fCanAlloc = FALSE;

    if(pSecInfo == NULL)
    {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    if(pCertificate == NULL || *pcbCertificate == 0)
    {
        *pcbCertificate = sizeof(INTERNET_CERTIFICATE_INFO);
        goto quit;
    }

    if(*pcbCertificate < sizeof(INTERNET_CERTIFICATE_INFO) )
    {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    ZeroMemory(pCertificate, sizeof(INTERNET_CERTIFICATE_INFO));
    fCanAlloc = TRUE;

    if(pSecInfo->pCertificate &&
       pSecInfo->pCertificate->pCertInfo )
    {
        pCertInfo = pSecInfo->pCertificate->pCertInfo;

        //
        // Now Convert Structures from SSPI format to WININET style.
        //  While in the process, we'll role them all into one
        //  big structure that we'll return to the user.
        //

        cbSubject = (*g_pfnCertNameToStr)(pSecInfo->pCertificate->dwCertEncodingType,
                                          &pCertInfo->Subject,
                                          CERT_SIMPLE_NAME_STR |
                                              CERT_NAME_STR_CRLF_FLAG |
                                              CERT_NAME_STR_NO_PLUS_FLAG,
                                          NULL,
                                          0);


        if ( cbSubject > 0 )
        {
            // freed by caller outside of wininet
            pCertificate->lpszSubjectInfo = (LPWSTR) LocalAlloc(LPTR, cbSubject * sizeof(WCHAR));

            if ( pCertificate->lpszSubjectInfo == NULL )
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }

            (*g_pfnCertNameToStr)(pSecInfo->pCertificate->dwCertEncodingType,
                                  &pCertInfo->Subject,
                                  CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG,
                                  pCertificate->lpszSubjectInfo,
                                  cbSubject);

        }

        cbIssuer = (*g_pfnCertNameToStr)(pSecInfo->pCertificate->dwCertEncodingType,
                                         &pCertInfo->Issuer,
                                         CERT_SIMPLE_NAME_STR |
                                             CERT_NAME_STR_CRLF_FLAG |
                                             CERT_NAME_STR_NO_PLUS_FLAG,
                                         NULL,
                                         0);

        if ( cbIssuer > 0 )
        {
            // freed by caller outside of wininet
            pCertificate->lpszIssuerInfo = (LPWSTR) LocalAlloc(LPTR, cbIssuer * sizeof(WCHAR));

            if ( pCertificate->lpszIssuerInfo == NULL )
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }

            (*g_pfnCertNameToStr)(pSecInfo->pCertificate->dwCertEncodingType,
                                  &pCertInfo->Issuer,
                                  CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG ,
                                  pCertificate->lpszIssuerInfo,
                                  cbIssuer);

        }

        CopyMemory(
                (PVOID) &pCertificate->ftStart,
                (PVOID) &pCertInfo->NotBefore,
                sizeof(FILETIME)
                );

        CopyMemory(
                (PVOID) &pCertificate->ftExpiry,
                (PVOID) &pCertInfo->NotAfter,
                sizeof(FILETIME)
                );

    }

    /*if(pSecInfo->dwProtocol)
    {
        DWORD dwProtocolID;
        TCHAR lpszProtocol[100];

        ATTR_MAP ProtocolAttrMap[] =
        {
            {SP_PROT_SSL2_CLIENT, IDS_PROTOCOL_SSL2},
            {SP_PROT_SSL3_CLIENT, IDS_PROTOCOL_SSL3},
            {SP_PROT_PCT1_CLIENT, IDS_PROTOCOL_PCT1},
            {SP_PROT_TLS1_CLIENT, IDS_PROTOCOL_TLS1}
        };


        for(j=0; j < sizeof(ProtocolAttrMap)/sizeof(ProtocolAttrMap[0]); j++)
        {
            if(ProtocolAttrMap[j].dwAttr == pSecInfo->dwProtocol)
            {
                dwProtocolID = ProtocolAttrMap[j].dwStringID;
                break;
            }
        }
        if(LoadString(GlobalDllHandle,
                   dwProtocolID,
                   lpszProtocol,
                   sizeof(lpszProtocol)/sizeof(lpszProtocol[0])))
        {
            pCertificate->lpszProtocolName  = NewString(lpszProtocol);
        }
    } */

    pCertificate->dwKeySize = pSecInfo->dwCipherStrength;

quit:

    if ( error != ERROR_SUCCESS &&
         fCanAlloc
        )
    {

        if ( pCertificate->lpszSubjectInfo )
        {
            LocalFree(pCertificate->lpszSubjectInfo);
            pCertificate->lpszSubjectInfo = NULL;
        }

        if ( pCertificate->lpszIssuerInfo )
        {
            LocalFree(pCertificate->lpszIssuerInfo);
            pCertificate->lpszIssuerInfo = NULL;
        }
    }

    return error;
}


/***
*char *StrTokEx(pstring, control) - tokenize string with delimiter in control
*
*Purpose:
*       StrTokEx considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into pstring immediately
*       following the returned token. when no tokens remain
*       in pstring a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*       char **pstring - ptr to ptr to string to tokenize
*       char *control - string of characters to use as delimiters
*
*Exit:
*       returns pointer to first token in string,
*       returns NULL when no more tokens remain.
*       pstring points to the beginning of the next token.
*
*WARNING!!!
*       upon exit, the first delimiter in the input string will be replaced with '\0'
*
*******************************************************************************/

char * StrTokEx (char ** pstring, const char * control)
{
        unsigned char *str;
        const unsigned char *ctrl = (const unsigned char *)control;
        unsigned char map[32];
        int count;

        char *tokenstr;

        if(*pstring == NULL)
            return NULL;
            
        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do
        {
            map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        } while (*ctrl++);

        /* Initialize str. */
        str = (unsigned char *)*pstring;
        
        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token if this loop sets str to point to the terminal
         * null (*str == '\0') */
        while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
            str++;

        tokenstr = (char *)str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
        {
            if ( map[*str >> 3] & (1 << (*str & 7)) ) 
            {
                *str++ = '\0';
                break;
            }
        }

        /* string now points to beginning of next token */
        *pstring = (char *)str;

        /* Determine if a token has been found. */
        if ( tokenstr == (char *)str )
            return NULL;
        else
            return tokenstr;
}

/***
* double StrToDbl(const char *str, char **strStop) - convert string to double
*
* Purpose:
*           To convert a string into a double.  This function supports
*           simple double representations like '1.234', '.5678'.  It also support
*           the a killobyte computaion by appending 'k' to the end of the string
*           as in '1.5k' or '.5k'.  The results would then become 1536 and 512.5.
*
* Return:
*           The double representation of the string.
*           strStop points to the character that caused the scan to stop.
*
*******************************************************************************/

double StrToDbl(const char *str, char **strStop)
{
    double dbl = 0;
    char *psz;
    int iMult = 1;
    int iKB = 1;
    int iVal = 0;
    BOOL bHaveDot = FALSE;

    psz = (char*)str;
    while(*psz)
    {
        if((*psz >= '0') && (*psz <= '9'))
        {
            iVal = (iVal * 10) + (*psz - '0');
            if(bHaveDot)
                iMult *= 10;
        }
        else if((*psz == '.') && !bHaveDot)
        {
            bHaveDot = TRUE;
        }
        else if((*psz == 'k') || (*psz == 'K'))
        {
            iKB = 1024;
            psz++;
            break;
        }
        else
        {
            break;
        }
        psz++;
    }
    *strStop = psz;

    dbl = (double) (iVal * iKB) / iMult;
    
    return(dbl);
}


/*
 *  WideCharToAscii
 *
 *  Purpose:
 *      Create an ascii string from a wide-char string.
 *      Output ascii string is allocated using New, so use delete[] to free.
 *
 */

DWORD
WideCharToAscii(PCWSTR pszW, char ** ppszA, DWORD cchW)
{
    DWORD cchA;

    *ppszA = NULL;

    if (!pszW)
        return ERROR_SUCCESS;

    if (cchW == (DWORD) -1)
    {
        cchW = lstrlenW(pszW);
    }

    // Determine how big the ascii string will be
    cchA = WideCharToMultiByte(CP_ACP, 0, pszW, cchW, NULL, 0, NULL, NULL);

    *ppszA = new char[cchA + 1];

    if (!*ppszA)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Determine how big the ascii string will be
    cchA = WideCharToMultiByte(CP_ACP, 0, pszW, cchW, *ppszA, cchA, NULL, NULL);

    (*ppszA)[cchA] = '\0';
    
    return ERROR_SUCCESS;
}


/*
 *  WideCharToAscii_UsingGlobalAlloc
 *
 *  Purpose:
 *      Create an ascii string from a wide-char string.
 *      Output ascii string is allocated using GlobalAlloc(), so use GlobalFree() to free.
 *
 */

DWORD
WideCharToAscii_UsingGlobalAlloc(PCWSTR pszW, char ** ppszA)
{
    DWORD cchA;
    DWORD cchW;

    *ppszA = NULL;

    if (!pszW)
        return ERROR_SUCCESS;

    cchW = lstrlenW(pszW);

    // Determine how big the ascii string will be
    cchA = WideCharToMultiByte(CP_ACP, 0, pszW, cchW, NULL, 0, NULL, NULL);

    *ppszA = (LPSTR) GlobalAlloc( GPTR, (cchA + 1) * sizeof( char));

    if (!*ppszA)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Determine how big the ascii string will be
    cchA = WideCharToMultiByte(CP_ACP, 0, pszW, cchW, *ppszA, cchA, NULL, NULL);

    (*ppszA)[cchA] = '\0';
    
    return ERROR_SUCCESS;
}


DWORD
AsciiToWideChar(const char * pszA, LPWSTR * ppszW)
{
    DWORD cchA;
    DWORD cchW;

    *ppszW = NULL;

    if (!pszA)
        return ERROR_SUCCESS;

    cchA = lstrlenA(pszA);

    // Determine how big the widechar string will be
    cchW = MultiByteToWideChar(CP_ACP, 0, pszA, cchA, NULL, 0);

    *ppszW = new WCHAR[cchW+1];

    if (!*ppszW)
        return ERROR_NOT_ENOUGH_MEMORY;

    cchW = MultiByteToWideChar(CP_ACP, 0, pszA, cchA, *ppszW, cchW);

    (*ppszW)[cchW] = 0;

    return ERROR_SUCCESS;
}


DWORD
AsciiToWideChar_UsingGlobalAlloc(const char * pszA, LPWSTR * ppszW)
{
    DWORD cchA;
    DWORD cchW;

    *ppszW = NULL;

    if (!pszA)
        return ERROR_SUCCESS;

    cchA = lstrlenA(pszA);

    // Determine how big the widechar string will be
    cchW = MultiByteToWideChar(CP_ACP, 0, pszA, cchA, NULL, 0);

    *ppszW = (PWSTR) GlobalAlloc(GPTR, (cchW + 1) * sizeof(WCHAR));

    if (!*ppszW)
        return ERROR_NOT_ENOUGH_MEMORY;

    cchW = MultiByteToWideChar(CP_ACP, 0, pszA, cchA, *ppszW, cchW);

    (*ppszW)[cchW] = 0;

    return ERROR_SUCCESS;
}


CAdminOnlySecurityDescriptor::CAdminOnlySecurityDescriptor()
{
    _pAdminSID = NULL;
    _pACL = NULL;
    _pSD = NULL;    
}


CAdminOnlySecurityDescriptor::~CAdminOnlySecurityDescriptor()
{
    if (_pSD) 
        LocalFree(_pSD);

    if (_pACL)
        LocalFree(_pACL);

    if (_pAdminSID) 
        FreeSid(_pAdminSID);
}


HRESULT CAdminOnlySecurityDescriptor::Initialize()
{
    HRESULT retVal = ERROR_WINHTTP_INTERNAL_ERROR;

    const int NUM_ACES = 1;   // leave the array in case we need additional ACEs later
    EXPLICIT_ACCESS ea[NUM_ACES];
    ZeroMemory(ea, sizeof(ea));

    // Create a SID for the BUILTIN\Administrators group.
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    if (!AllocateAndInitializeSid(&SIDAuthNT, 2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0,
                                  &_pAdminSID))
    {
        goto errorGetLastError;
    }

    ea[0].grfAccessPermissions = GENERIC_READ | GENERIC_WRITE;
    ea[0].grfAccessMode = SET_ACCESS;
    ea[0].grfInheritance= NO_INHERITANCE;
    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[0].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea[0].Trustee.ptstrName  = (LPTSTR)_pAdminSID;

    // Create a new ACL with the three ACEs.
    if (ERROR_SUCCESS != SetEntriesInAcl(NUM_ACES, ea, NULL, &_pACL)) 
    {
        goto errorGetLastError;
    }

    // Initialize a security descriptor.  
    _pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH); 
    if(_pSD == NULL) 
        goto errorGetLastError;

    if (!InitializeSecurityDescriptor(_pSD, SECURITY_DESCRIPTOR_REVISION))   
        goto errorGetLastError;

    // Add the ACL to the security descriptor. 
    if (!SetSecurityDescriptorDacl(_pSD, TRUE, _pACL, FALSE))
    {  
        goto errorGetLastError;
    } 

    retVal = ERROR_SUCCESS;

done:
    return retVal;

errorGetLastError:
    retVal = GetLastError();
    goto done;
}


PSECURITY_DESCRIPTOR CAdminOnlySecurityDescriptor::GetSecurityDecriptor()
{
    return _pSD;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\secinit.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    secinit.cxx

Abstract:

    Contains load function for security.dll on NT and secur32.dll on win95
    Also handles WinTrust.dll function loading.

Author:

    Sophia Chung (sophiac)  6-Feb-1996

Environment:

    User Mode - Win32

Revision History:

--*/
#include <wininetp.h>

//
// InitializationLock - protects against multiple threads loading security.dll
// (secur32.dll) and entry points
//

CCritSec InitializationSecLock;

//
// GlobalSecFuncTable - Pointer to Global Structure of Pointers that are used
//  for storing the entry points into the SCHANNEL.dll
//

PSecurityFunctionTable GlobalSecFuncTable = NULL;

//
// pWinVerifyTrust - Pointer to Entry Point in WINTRUST.DLL
//

WIN_VERIFY_TRUST_FN pWinVerifyTrust;
WT_HELPER_PROV_DATA_FROM_STATE_DATA_FN pWTHelperProvDataFromStateData;

//
// g_hSecurity - NULL when security.dll/secur32.dll  is not loaded
//

HINSTANCE g_hSecurity = NULL;

//
// g_hWinTrust - NULL when WinTrust DLL is not loaded.
//

HINSTANCE g_hWinTrust = NULL;

HINSTANCE g_hCrypt32 = NULL;

CERT_OPEN_STORE_FN                     g_pfnCertOpenStore = NULL;
CERT_FIND_CERTIFICATE_IN_STORE_FN      g_pfnCertFindCertificateInStore = NULL;
CERT_DUPLICATE_CERTIFICATE_CONTEXT_FN  g_pfnCertDuplicateCertificateContext = NULL;
CERT_NAME_TO_STR_W_FN                  g_pfnCertNameToStr = NULL;
CERT_CONTROL_STORE_FN                  g_pfnCertControlStore = NULL;
CRYPT_UNPROTECT_DATA_FN                g_pfnCryptUnprotectData = NULL;
CERT_CLOSE_STORE_FN                    g_pfnCertCloseStore = NULL;
CERT_GET_CERT_PROPERTY                 g_pfnCertGetCertProperty = NULL;
DWORD
LoadWinTrust(
    VOID
    )

/*++

Routine Description:

    This function loads the WinTrust.DLL and binds a pointer to a function
    that is needed in the WinTrust DLL.

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/

{
    DWORD error = ERROR_SUCCESS;

    if (!LOCK_SECURITY())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if( g_hWinTrust == NULL )
    {
        LPSTR lpszDllFileName = WINTRUST_DLLNAME;
        pWinVerifyTrust = NULL;

        //
        // Load the DLL
        //

        g_hWinTrust       = LoadLibrary(lpszDllFileName);

        if ( g_hWinTrust )
        {
            pWinVerifyTrust = (WIN_VERIFY_TRUST_FN)
                            GetProcAddress(g_hWinTrust, WIN_VERIFY_TRUST_NAME);
            pWTHelperProvDataFromStateData = (WT_HELPER_PROV_DATA_FROM_STATE_DATA_FN)
                            GetProcAddress(g_hWinTrust, WT_HELPER_PROV_DATA_FROM_STATE_DATA_NAME);
        }


        if ( !g_hWinTrust || !pWinVerifyTrust )
        {
            error = GetLastError();

            if ( error == ERROR_SUCCESS )
            {
                error = ERROR_WINHTTP_INTERNAL_ERROR;
            }
        }
    }

    INET_ASSERT(pWinVerifyTrust);


    if ( error != ERROR_SUCCESS )
    {
        if (g_hWinTrust)
        {
            FreeLibrary(g_hWinTrust);
            g_hWinTrust = NULL;
        }
    }

    UNLOCK_SECURITY();

    return error;
}



BOOL
SecurityInitialize(
    VOID
    )
/*++

Routine Description:

    This function initializes the global lock required for the security
    pkgs.

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/
{
    return InitializationSecLock.Init();
}

VOID
SecurityTerminate(
    VOID
    )
/*++

Routine Description:

    This function Deletes the global lock required for the security
    pkgs.

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/
{
    InitializationSecLock.FreeLock();
}


VOID
UnloadSecurity(
    VOID
    )

/*++

Routine Description:

    This function terminates the global data required for the security
    pkgs and dynamically unloads security APIs from security.dll (NT)
    or secur32.dll (WIN95).

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/

{
    if (!LOCK_SECURITY())
    {
        INET_ASSERT(FALSE);
        return;
    }

    //
    // unload dll
    //

    if (g_hSecurity != NULL)
    {
        FreeLibrary(g_hSecurity);
        g_hSecurity = NULL;
    }
    
    if (g_hCrypt32 != NULL)
    {
        FreeLibrary(g_hCrypt32);
        g_hCrypt32 = NULL;
    }
    
    if (g_hWinTrust)
    {
        FreeLibrary(g_hWinTrust);
        g_hWinTrust = NULL;
    }

    UNLOCK_SECURITY();

}


DWORD
LoadSecurity(
    VOID
    )
/*++

Routine Description:

    This function dynamically loads security APIs from security.dll (NT)
    or secur32.dll (WIN95).

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.
--*/
{
    DWORD Error = ERROR_SUCCESS;
    INITSECURITYINTERFACE pfInitSecurityInterface = NULL;

    if (!LOCK_SECURITY())
        return ERROR_NOT_ENOUGH_MEMORY;

    Error = LoadWinTrust();
    if ( Error != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    if( g_hSecurity != NULL && g_hCrypt32 != NULL)
    {
        goto quit;
    }

    //
    // load dll.
    //

    //
    // This is better for performance. Rather than call through
    //    SSPI, we go right to the DLL doing the work.
    //

    g_hSecurity = LoadLibrary( "schannel" );

    if ( g_hSecurity == NULL )
    {
        goto ErrorFail;
    }

    g_hCrypt32 = LoadLibrary( "crypt32" );

    if ( g_hCrypt32 == NULL )
    {
        goto ErrorFail;
    }
    else
    {
        g_pfnCertOpenStore = (CERT_OPEN_STORE_FN)
                             GetProcAddress(g_hCrypt32, "CertOpenStore");

        if (!g_pfnCertOpenStore)
        {
            goto ErrorFail;
        }

        g_pfnCertCloseStore      = (CERT_CLOSE_STORE_FN)
                                   GetProcAddress(g_hCrypt32, "CertCloseStore");

        if (!g_pfnCertCloseStore)
        {
            goto ErrorFail;
        }

        g_pfnCertGetCertProperty = (CERT_GET_CERT_PROPERTY)
                                   GetProcAddress(g_hCrypt32, "CertGetCertificateContextProperty");

        if (!g_pfnCertGetCertProperty)
        {
            goto ErrorFail;
        }

        g_pfnCertFindCertificateInStore = (CERT_FIND_CERTIFICATE_IN_STORE_FN)
                                          GetProcAddress(g_hCrypt32, "CertFindCertificateInStore");

        if (!g_pfnCertFindCertificateInStore)
        {
            goto ErrorFail;
        }

        g_pfnCertFreeCertificateContext = (CERT_FREE_CERTIFICATE_CONTEXT_FN)
                                          GetProcAddress(g_hCrypt32, "CertFreeCertificateContext");

        if (!g_pfnCertFreeCertificateContext)
        {
            goto ErrorFail;
        }

        g_pfnCertDuplicateCertificateContext = (CERT_DUPLICATE_CERTIFICATE_CONTEXT_FN)
                                               GetProcAddress(g_hCrypt32, "CertDuplicateCertificateContext");

        if (!g_pfnCertDuplicateCertificateContext)
        {
            goto ErrorFail;
        }

        g_pfnCertNameToStr = (CERT_NAME_TO_STR_W_FN)
                              GetProcAddress(g_hCrypt32, "CertNameToStrW");

        if (!g_pfnCertNameToStr)
        {
            goto ErrorFail;
        }

        g_pfnCertControlStore = (CERT_CONTROL_STORE_FN)
                                GetProcAddress(g_hCrypt32, "CertControlStore");

        if (!g_pfnCertControlStore)
        {
            goto ErrorFail;
        }

        g_pfnCryptUnprotectData = (CRYPT_UNPROTECT_DATA_FN)
                                  GetProcAddress(g_hCrypt32, "CryptUnprotectData");

        if (!g_pfnCryptUnprotectData)
        {
            goto ErrorFail;
        }
    }
        
       
        //
        // get function addresses.
        //

#ifdef UNICODE
        pfInitSecurityInterface =
            (INITSECURITYINTERFACE) GetProcAddress( g_hSecurity,
                                                     "InitSecurityInterfaceW" );
#else
        pfInitSecurityInterface =
            (INITSECURITYINTERFACE) GetProcAddress( g_hSecurity,
                                                     "InitSecurityInterfaceA" );
#endif


        if ( pfInitSecurityInterface == NULL )
        {
             goto ErrorFail;
        }


    GlobalSecFuncTable = (SecurityFunctionTable*) ((*pfInitSecurityInterface) ());

    if ( GlobalSecFuncTable == NULL ) {
         goto ErrorFail;
    }

Cleanup:

    if ( Error != ERROR_SUCCESS )
    {
        if (g_hSecurity)
        {
            FreeLibrary( g_hSecurity );
            g_hSecurity = NULL;
        }

        if (g_hCrypt32)
        {
            FreeLibrary( g_hCrypt32 );
            g_hCrypt32 = NULL;
        }
    }

quit:

    UNLOCK_SECURITY();

    return( Error );

ErrorFail:

    Error = GetLastError();

    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\servinfo.cxx ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    servinfo.cxx

Abstract:

    Class implementation for global server info list

    Contents:
        INTERNET_HANDLE_OBJECT::GetServerInfo
        INTERNET_HANDLE_OBJECT::FindServerInfo
        ReleaseServerInfo
        INTERNET_HANDLE_OBJECT::PurgeServerInfoList
        CServerInfo::CServerInfo
        CServerInfo::~CServerInfo
        CServerInfo::Reference
        CServerInfo::Dereference
        CServerInfo::UpdateConnectTime
        CServerInfo::UpdateRTT
        CServerInfo::GetConnection
        CFsm_GetConnection::RunSM
        CServerInfo::GetConnection_Fsm
        CServerInfo::ReleaseConnection
        CServerInfo::RemoveWaiter
        (CServerInfo::FindKeepAliveConnection)
        (CServerInfo::KeepAliveWaiters)
        (CServerInfo::UpdateConnectionLimit)
        CServerInfo::PurgeKeepAlives
        ContainingServerInfo

Author:

    Richard L Firth (rfirth) 07-Oct-1996

Revision History:

    07-Oct-1996 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// private macros
//

//#define CHECK_CONNECTION_COUNT() \
//    INET_ASSERT(!UnlimitedConnections() \
//        ? (TotalAvailableConnections() <= ConnectionLimit()) : TRUE)

#define CHECK_CONNECTION_COUNT()    /* NOTHING */

//#define RLF_DEBUG   1

#if INET_DEBUG
#ifdef RLF_DEBUG
#define DPRINTF dprintf
#else
#define DPRINTF (void)
#endif
#else
#define DPRINTF (void)
#endif


#define SOCK_FLAGS  (SF_ENCRYPT | SF_DECRYPT | SF_SECURE | SF_TUNNEL)


//
// functions
//


DWORD
INTERNET_HANDLE_OBJECT::GetServerInfo(
    IN LPSTR lpszHostName,
    IN DWORD dwServiceType,
    IN BOOL bDoResolution,
    OUT CServerInfo * * lplpServerInfo
    )

/*++

Routine Description:

    Finds or creates a CServerInfo entry

Arguments:

    lpszHostName    - pointer to server name to get info for

    dwServiceType   - type of service for which CServerInfo requested

    bDoResolution   - TRUE if we are to resolve host name

    lplpServerInfo  - pointer to created/found CServerInfo if successful

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create the CServerInfo

                  ERROR_WINHTTP_NAME_NOT_RESOLVED
                    We were asked to resolve the name, but failed

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "GetServerInfo",
                 "%q, %s (%d), %B, %#x",
                 lpszHostName,
                 InternetMapService(dwServiceType),
                 dwServiceType,
                 bDoResolution,
                 lplpServerInfo
                 ));

    ICSTRING hostName(lpszHostName);
    CServerInfo * lpServerInfo = NULL;
    BOOL bCreated = FALSE;
    DWORD error = ERROR_SUCCESS;

    if (hostName.HaveString()) {
        hostName.MakeLowerCase();

        LPSTR lpszHostNameLower = hostName.StringAddress();

        if (!LockSerializedList(&_ServerInfoList))
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        lpServerInfo = FindServerInfo(lpszHostNameLower);

        if (lpServerInfo == NULL) 
        {
            lpServerInfo = New CServerInfo(&_ServerInfoList,
                                           lpszHostNameLower,
                                           &error,
                                           dwServiceType,
                                           GetMaxConnectionsPerServer(WINHTTP_OPTION_MAX_CONNS_PER_SERVER)
                                           );
            if (lpServerInfo != NULL)
            {
                if (error != ERROR_SUCCESS)
                {
                    delete lpServerInfo;
                    lpServerInfo = NULL;
                }
                else
                {
                    bCreated = TRUE;
                    // Reference this to keep it alive beyond the unlock/
                    lpServerInfo->Reference();
                }
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        UnlockSerializedList(&_ServerInfoList);
    } else {

        //
        // failed to create ICSTRING
        //

        error = GetLastError();

        INET_ASSERT(error != ERROR_SUCCESS);

        lpServerInfo = NULL;
    }

    //
    // if we created a new CServerInfo and we are instructed to resolve the host
    // name then do it now, outside of the global server info list lock. This
    // operation may take some time
    //

    if (bDoResolution && (lpServerInfo != NULL)) {
        //error = lpServerInfo->ResolveHostName();
        if (error != ERROR_SUCCESS) {
            ReleaseServerInfo(lpServerInfo);
            lpServerInfo = NULL;
        }
    }

quit:
    *lplpServerInfo = lpServerInfo;

    DEBUG_LEAVE(error);

    return error;
}


CServerInfo *
INTERNET_HANDLE_OBJECT::FindServerInfo(
    IN LPSTR lpszHostName
    )

/*++

Routine Description:

    Walks the server info list looking for the requested server

Arguments:

    lpszHostName    - pointer to server name to find (IN LOWER CASE!)

Return Value:

    CServerInfo *
        Success - pointer to found list entry

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Pointer,
                 "FindServerInfo",
                 "%q",
                 lpszHostName
                 ));

    DWORD hashHostName = CalculateHashValue(lpszHostName);

    CServerInfo * lpServerInfo = NULL;
    BOOL found = FALSE;

    if (!LockSerializedList(&_ServerInfoList))
    {
        goto quit;
    }

    for (lpServerInfo = (CServerInfo *)HeadOfSerializedList(&_ServerInfoList);
        lpServerInfo != (CServerInfo *)SlSelf(&_ServerInfoList);
        lpServerInfo = lpServerInfo->Next()) {

        if (lpServerInfo->Match(hashHostName, lpszHostName)) {
            found = TRUE;
            break;
        }
    }

    if (!found) 
    {
        lpServerInfo = NULL;
    }

    // Need to keep this alive beyond the lock.
    if (lpServerInfo)
    {
        lpServerInfo->Reference();
    }
    UnlockSerializedList(&_ServerInfoList);

quit:
    DEBUG_LEAVE(lpServerInfo);
    return lpServerInfo;
}



VOID
ReleaseServerInfo(
    IN CServerInfo * lpServerInfo
    )

/*++

Routine Description:

    Release a CServerInfo by dereferencing it. If the reference count goes to
    zero, the CServerInfo will be destroyed

Arguments:

    lpServerInfo    - pointer to CServerInfo to release

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "ReleaseServerInfo",
                 "%#x [%q]",
                 lpServerInfo,
                 lpServerInfo->GetHostName()
                 ));

    lpServerInfo->Dereference();

    DEBUG_LEAVE(0);
}


VOID
INTERNET_HANDLE_OBJECT::PurgeServerInfoList(
    IN BOOL bForce
    )

/*++

Routine Description:

    Throw out any CServerInfo entries that have expired or any KEEP_ALIVE
    entries (for any CServerInfo) that have expired

Arguments:

    bForce  - TRUE if we forcibly remove entries which have not yet expired but
              which have a reference count of 1, else FALSE to remove only
              entries that have expired

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "PurgeServerInfoList",
                 "%B",
                 bForce
                 ));

    if (!LockSerializedList(&_ServerInfoList))
    {
        // Can't purge list if unable to obtain the lock.
        goto quit;
    }

    PLIST_ENTRY pEntry = HeadOfSerializedList(&_ServerInfoList);
    PLIST_ENTRY pPrevious = (PLIST_ENTRY)SlSelf(&_ServerInfoList);

    while (TRUE) {
        if (pEntry == (PLIST_ENTRY)SlSelf(&_ServerInfoList)) {
            break;
        }

        CServerInfo * pServerInfo;

        //pServerInfo = (CServerInfo *)pEntry;
        //pServerInfo = CONTAINING_RECORD(pEntry, CONNECTION_LIMIT, m_List);
        pServerInfo = ContainingServerInfo(pEntry);

        BOOL deleted = FALSE;

        if (pServerInfo->ReferenceCount() == 1) {
            if (bForce || pServerInfo->Expired()) {
//dprintf("purging server info entry for %q\n", pServerInfo->GetHostName());
                deleted = pServerInfo->Dereference();
            } else {
                pServerInfo->PurgeKeepAlives(PKA_NO_FORCE);
            }
        }
        if (!deleted) {
            pPrevious = pEntry;
        }
        pEntry = pPrevious->Flink;
    }

    UnlockSerializedList(&_ServerInfoList);

quit:
    DEBUG_LEAVE(0);
}


VOID
INTERNET_HANDLE_OBJECT::PurgeKeepAlives(
    IN DWORD dwForce
    )

/*++

Routine Description:

    Throw out any KEEP_ALIVE entries from any CServerInfo that have expired or
    which have failed authentication or which are unused, depending on dwForce

Arguments:

    dwForce - force to apply when purging. Value can be:

                PKA_NO_FORCE    - only purge timed-out sockets or sockets in
                                  close-wait state (default)

                PKA_NOW         - purge all sockets

                PKA_AUTH_FAILED - purge sockets that have been marked as failing
                                  authentication

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "PurgeKeepAlives",
                 "%s [%d]",
                 (dwForce == PKA_NO_FORCE) ? "NO_FORCE"
                 : (dwForce == PKA_NOW) ? "NOW"
                 : (dwForce == PKA_AUTH_FAILED) ? "AUTH_FAILED"
                 : "?",
                 dwForce
                 ));

    if (!LockSerializedList(&_ServerInfoList))
    {
        goto quit;
    }

    PLIST_ENTRY pEntry = HeadOfSerializedList(&_ServerInfoList);

    while (pEntry != (PLIST_ENTRY)SlSelf(&_ServerInfoList)) {

        CServerInfo * lpServerInfo = ContainingServerInfo(pEntry);

        lpServerInfo->PurgeKeepAlives(dwForce);
        pEntry = pEntry->Flink;
    }

    UnlockSerializedList(&_ServerInfoList);

quit:
    DEBUG_LEAVE(0);
}


//
// methods
//


CServerInfo::CServerInfo(
    IN SERIALIZED_LIST * ServerInfoList,
    IN LPSTR lpszHostName,
    OUT DWORD* pdwError,
    IN DWORD dwService,
    IN DWORD dwMaxConnections
    )

/*++

Routine Description:

    CServerInfo constructor

Arguments:

    lpszHostName        - server for which to create CServerInfo

    dwService           - which service to create CServerInfo for

    dwMaxConnections    - maximum number of simultaneous connections to this
                          server

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER(dwService);
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CServerInfo::CServerInfo",
                 "%q, %s (%d), %d",
                 lpszHostName,
                 InternetMapService(dwService),
                 dwService,
                 dwMaxConnections
                 ));

    INIT_SERVER_INFO();

    m_ServerInfoList = ServerInfoList;
    *pdwError = ERROR_SUCCESS;

    InitializeListHead(&m_List);
    m_Expires = 0;
    m_Wrap = 0;
    m_ReferenceCount = 1;
    m_HostName = lpszHostName;
    if (!m_HostName.StringAddress())
    {
        goto error;
    }
    
    m_HostName.MakeLowerCase();
    m_Hash = CalculateHashValue(m_HostName.StringAddress());
    m_Services.Word = 0;
    m_HttpSupport.Word = 0;
    m_Flags.Word = 0;
    m_ProxyLink = NULL;

    INET_ASSERT(dwService == INTERNET_SERVICE_HTTP);
    SetHTTP();

    //
    // only initialize the keep-alive and connection limit lists if we are
    // creating the server info entry for a HTTP server (or CERN proxy)
    //

    //
    // BUGBUG - we only want to do this on demand
    //

    //if (IsHTTP()) {
    InitializeSerializedList(&m_KeepAliveList);
    SetKeepAliveListInitialized();

    //
    // the maximum number of connections per server is initialized to the
    // default (registry) value unless overridden by the caller
    //

    if (dwMaxConnections == 0) 
    {
        dwMaxConnections = DEFAULT_MAX_CONNECTIONS_PER_SERVER;
    }
    
    m_ConnectionLimit = dwMaxConnections;
    //} else {
    //    m_ConnectionLimit = UNLIMITED_CONNECTIONS;
    //}
    //dprintf("*** %s: limit = %d\n", GetHostName(), m_ConnectionLimit);
    //
    // BUGBUG - only create event if limiting connections. Need method to manage
    //          connection limit count/event creation
    //

    m_NewLimit = m_ConnectionLimit;
    m_ConnectionsAvailable = m_ConnectionLimit;
    //m_ActiveConnections = 0;
    m_LastActiveTime = 0;
    m_ConnectTime = (DWORD)-1;
    m_RTT = 0;
    m_dwError = ERROR_SUCCESS;

    //
    // add to the global list. We are assuming here that the caller has already
    // checked for dupes
    //

    if (!InsertAtHeadOfSerializedList(m_ServerInfoList, &m_List))
        *pdwError = ERROR_NOT_ENOUGH_MEMORY;

quit:
    DEBUG_LEAVE(0);
    return;

error:
    *pdwError = ERROR_NOT_ENOUGH_MEMORY;
    goto quit;
    
}


CServerInfo::~CServerInfo()

/*++

Routine Description:

    CServerInfo destructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CServerInfo::~CServerInfo",
                 "{%q}",
                 GetHostName()
                 ));

    CHECK_SERVER_INFO();

    //GlobalServerInfoDeAllocCount++;

    // unlink if we have a nested obj
    if ( m_ProxyLink )
    {
        CServerInfo *pDerefObj = NULL;

        // will leak if unable to dereference
        if (LockSerializedList(m_ServerInfoList))
        {
            pDerefObj = m_ProxyLink;
            m_ProxyLink = NULL;
            UnlockSerializedList(m_ServerInfoList);
        }

        if (pDerefObj)
        {
            pDerefObj->Dereference();
        }
    }

    RemoveFromSerializedList(m_ServerInfoList, &m_List);

    INET_ASSERT(m_ReferenceCount == 0);

    if (IsKeepAliveListInitialized() && LockSerializedList(&m_KeepAliveList))
    {
        while (!IsSerializedListEmpty(&m_KeepAliveList))
        {
//dprintf("%#x ~S-I killing K-A %#x\n", GetCurrentThreadId(), HeadOfSerializedList(&m_KeepAliveList));

            LPVOID pEntry = SlDequeueHead(&m_KeepAliveList);

            INET_ASSERT(pEntry != NULL);

            if (pEntry != NULL) {

                ICSocket * pSocket = ContainingICSocket(pEntry);

//dprintf("~CServerInfo: destroying socket %#x\n", pSocket->GetSocket());
                pSocket->Destroy();
            }
        }
        UnlockSerializedList(&m_KeepAliveList);
        TerminateSerializedList(&m_KeepAliveList);
    }

    DEBUG_LEAVE(0);
}


VOID
CServerInfo::Reference(
    VOID
    )

/*++

Routine Description:

    Increments the reference count for the CServerInfo

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::Reference",
                 "{%q}",
                 GetHostName()
                 ));

    CHECK_SERVER_INFO();
    INET_ASSERT(m_ReferenceCount > 0);

    InterlockedIncrement(&m_ReferenceCount);
//dprintf("CServerInfo %s - %d\n", GetHostName(), m_ReferenceCount);

    DEBUG_PRINT(SESSION,
                INFO,
                ("Reference count = %d\n",
                ReferenceCount()
                ));

    DEBUG_LEAVE(0);
}


BOOL
CServerInfo::Dereference(
    VOID
    )

/*++

Routine Description:

    Dereferences the SESSION_INFO. If the reference count goes to zero then this
    entry is deleted. If the reference count goes to 1 then the expiry timer is
    started

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - entry was deleted

        FALSE   - entry was not deleted

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::Dereference",
                 "{%q}",
                 GetHostName()
                 ));

    CHECK_SERVER_INFO();
    INET_ASSERT(m_ReferenceCount > 0);

    //
    // we need to grab the list - we may be removing this entry or updating
    // the reference count and expiry fields which must be done atomically
    //

    SERIALIZED_LIST *   ServerInfoList = m_ServerInfoList;
    BOOL deleted = FALSE;

    if (!LockSerializedList(ServerInfoList))
        goto quit;

    LONG result = InterlockedDecrement(&m_ReferenceCount);
//dprintf("CServerInfo %s - %d\n", GetHostName(), m_ReferenceCount);

    DEBUG_PRINT(SESSION,
                INFO,
                ("Reference count = %d\n",
                ReferenceCount()
                ));

    if (result == 0) {
        delete this;
        deleted = TRUE;
    } else if (result == 1) {

        //
        // start expiration proceedings...
        //

        SetExpiryTime();
    }

    UnlockSerializedList(ServerInfoList);

quit:
    DEBUG_LEAVE(deleted);

    return deleted;
}


DWORD    
CServerInfo::SetCachedProxyServerInfo(
    IN CServerInfo * pProxyServer,
    IN DWORD dwProxyVersion,
    IN BOOL fUseProxy,
    IN INTERNET_SCHEME HostScheme,
    IN INTERNET_PORT HostPort,
    IN INTERNET_SCHEME ProxyScheme,
    IN INTERNET_PORT ProxyPort
    )
/*++

Routine Description:

    If the Version information match up, copies
     the proxy information and links this server object
     to the appopriate proxy server object

    Assumes that this is called on successful use of the proxy
      object.

Arguments:

    None.

Return Value:

    DWORD
        ERROR_SUCCESS

        ERROR_NOT_ENOUGH_MEMORY   - entry was not deleted because there
                                    wasn't available memory to obtain lock

--*/


{
    DWORD error=ERROR_SUCCESS;

    if (!LockSerializedList(m_ServerInfoList))
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if ( dwProxyVersion != GlobalProxyVersionCount ) 
    {
        SetProxyScriptCached(FALSE);
        goto cleanup; // bail, we don't accept out of date additions to the cache
    }

    if ( m_ProxyLink )
    {
        if ( IsProxyScriptCached() && 
             HostScheme == m_HostScheme &&
             HostPort == m_HostPort &&
             fUseProxy )
        {
            if ( pProxyServer == m_ProxyLink ) {            
                INET_ASSERT(dwProxyVersion == GlobalProxyVersionCount);
                m_dwProxyVersion = dwProxyVersion; // we're now up to date
                goto cleanup; // match, no version or host changes
            }

            INET_ASSERT(pProxyServer != m_ProxyLink );            
        }
        //
        // unlink, because we have a new entry to save,
        //  and the previous entry is bad
        //
        m_ProxyLink->Dereference();
        m_ProxyLink = NULL;
    }

    //
    // Add new cached entry
    //

    SetProxyScriptCached(TRUE);

    m_HostScheme     = HostScheme;
    m_HostPort       = HostPort;

    m_dwProxyVersion = dwProxyVersion; // we're now up to date

    if ( fUseProxy )
    {
        INET_ASSERT(this != pProxyServer);

        m_ProxyLink = pProxyServer;
        m_ProxyLink->Reference();

        m_ProxyLink->m_HostScheme = ProxyScheme;
        m_ProxyLink->m_HostPort   = ProxyPort;

        switch (ProxyScheme)
        {
            case INTERNET_SCHEME_HTTP:
                m_ProxyLink->SetCernProxy();
                break;
            case INTERNET_SCHEME_SOCKS: 
                m_ProxyLink->SetSocksGateway();
                break;
        }
    }

cleanup:

    UnlockSerializedList(m_ServerInfoList);        

quit:

    return error;
}

CServerInfo * 
CServerInfo::GetCachedProxyServerInfo(
    IN INTERNET_SCHEME HostScheme,
    IN INTERNET_PORT HostPort,
    OUT BOOL *pfCachedEntry
    )

/*++

Routine Description:

   Retrieves a cached server object, that indicates
    a probable proxy to use

   On Success, the return has an additional increment
    on its ref count, assumition that caller derefs

Arguments:

    None.

Return Value:

    CServerInfo *     
        NULL on failure

--*/

{
    CServerInfo *pProxyServer = NULL;

    if (!LockSerializedList(m_ServerInfoList))
        return NULL;

    *pfCachedEntry = FALSE; 

    if ( IsProxyScriptCached() )
    {        
        //
        // Examine Version Count
        //

        if ( GlobalProxyVersionCount == m_dwProxyVersion &&
             HostScheme == m_HostScheme &&
             HostPort == m_HostPort
             )
        {
            *pfCachedEntry = TRUE;

            if ( m_ProxyLink ) {
                // matched cached entry
                m_ProxyLink->Reference();
                pProxyServer = m_ProxyLink;                    
            }
        }
        else
        {
            // version is expired, remove reference
            SetProxyScriptCached(FALSE);
            if ( m_ProxyLink ) {                
                m_ProxyLink->Dereference();
                m_ProxyLink = NULL;
            }
        }            
    }
        
    UnlockSerializedList(m_ServerInfoList);        
    return pProxyServer;
}

BOOL    
CServerInfo::CopyCachedProxyInfoToProxyMsg(
    IN OUT AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo
    )

/*++

Routine Description:

   Retrieves Cached Proxy info from object

Arguments:

    None.

Return Value:

    BOOL
        TRUE - sucess

--*/

{
    BOOL fSuccess = FALSE;

    // really only need to lock to proctect m_HostPort && m_HostScheme
    if (!LockSerializedList(m_ServerInfoList))
        return FALSE;

    pQueryForProxyInfo->SetUseProxy(FALSE);
    pQueryForProxyInfo->_lpszProxyHostName =  
        m_HostName.StringAddress() ? 
        NewString(m_HostName.StringAddress()) :
        NULL;

    if ( pQueryForProxyInfo->_lpszProxyHostName != NULL ) {
        // copy out cached entry to proxy message structure
        pQueryForProxyInfo->_nProxyHostPort        = m_HostPort;
        pQueryForProxyInfo->_tProxyScheme          = m_HostScheme;
        pQueryForProxyInfo->_bFreeProxyHostName    = TRUE;
        pQueryForProxyInfo->_dwProxyHostNameLength = 
            strlen((pQueryForProxyInfo)->_lpszProxyHostName);
        pQueryForProxyInfo->SetUseProxy(TRUE);
        fSuccess = TRUE; // success
    }

    UnlockSerializedList(m_ServerInfoList);        
    return fSuccess;
}




VOID
CServerInfo::UpdateConnectTime(
    IN DWORD dwConnectTime
    )

/*++

Routine Description:

    Calculates average connect time

Arguments:

    dwConnectTime   - current connect time

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::UpdateConnectTime",
                 "{%q} %d",
                 GetHostName(),
                 dwConnectTime
                 ));

    DWORD connectTime = m_ConnectTime;

    if (connectTime == (DWORD)-1) {
        connectTime = dwConnectTime;
    } else {
        connectTime = (connectTime + dwConnectTime) / 2;
    }
//dprintf("%s: connect time = %d, ave = %d\n", GetHostName(), dwConnectTime, connectTime);

    DEBUG_PRINT(SESSION,
                INFO,
                ("average connect time = %d mSec\n",
                connectTime
                ));

    InterlockedExchange((LPLONG)&m_ConnectTime, connectTime);

    DEBUG_LEAVE(0);
}


VOID
CServerInfo::UpdateRTT(
    IN DWORD dwRTT
    )

/*++

Routine Description:

    Calculates rolling average round-trip time

Arguments:

    dwRTT   - current round-trip time

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::UpdateRTT",
                 "{%q} %d",
                 GetHostName(),
                 dwRTT
                 ));

    DWORD RTT = m_RTT;

    if (RTT == 0) {
        RTT = dwRTT;
    } else {
        RTT = (RTT + dwRTT) / 2;
    }
//dprintf("%s: RTT = %d, ave = %d\n", GetHostName(), dwRTT, RTT);

    DEBUG_PRINT(SESSION,
                INFO,
                ("average round trip time = %d mSec\n",
                RTT
                ));

    InterlockedExchange((LPLONG)&m_RTT, RTT);

    DEBUG_LEAVE(0);
}



DWORD
CFsm_GetConnection::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_GetConnection state

Arguments:

    Fsm - FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
//dprintf("%#x: %s FSM %#x state %s\n", GetCurrentThreadId(), Fsm->MapType(), Fsm, Fsm->MapState());
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CFsm_GetConnection::RunSM",
                 "%#x",
                 Fsm
                 ));

    CServerInfo * pServerInfo = (CServerInfo *)Fsm->GetContext();
    CFsm_GetConnection * stateMachine = (CFsm_GetConnection *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
        stateMachine->StartTimer();

        //
        // fall through
        //

    case FSM_STATE_CONTINUE:

#ifdef NEW_CONNECTION_SCHEME
    case FSM_STATE_ERROR:
#endif
        error = pServerInfo->GetConnection_Fsm(stateMachine);
        break;

#ifndef NEW_CONNECTION_SCHEME

    case FSM_STATE_ERROR:

        INET_ASSERT((Fsm->GetError() == ERROR_WINHTTP_TIMEOUT)
                    || (Fsm->GetError() == ERROR_WINHTTP_OPERATION_CANCELLED));

        pServerInfo->RemoveWaiter((DWORD_PTR)Fsm);
        error = Fsm->GetError();
        Fsm->SetDone();
//dprintf("%#x: FSM_STATE_ERROR - %d\n", GetCurrentThreadId(), error);
        break;

#endif

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}



DWORD
CServerInfo::GetConnection_Fsm(
    IN CFsm_GetConnection * Fsm
    )

/*++

Routine Description:

    Tries to get a connection of requested type for caller. If no connection is
    available then one of the following happens:

        * If there are available keep-alive connections of a different type then
          one is closed and the caller allowed to create a new connection

        * If this is an async request, the FSM is blocked and the thread returns
          to the pool if a worker, or back to the app if an app thread

        * If this is a sync request, we wait on an event for a connection to be
          made available, or the connect timeout to elapse

Arguments:

    Fsm - get connection FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Depending on *lplpSocket, we either returned the socket to
                    use, or its okay to create a new connection

                  ERROR_IO_PENDING
                    Request will complete asynchronously

        Failure - ERROR_WINHTTP_TIMEOUT
                    Failed to get connection in time allowed

                  ERROR_WINHTTP_INTERNAL_ERROR
                    Something unexpected happened

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CServerInfo::GetConnection_Fsm",
                 "{%q [%d+%d/%d]} %#x(%#x, %d, %d)",
                 GetHostName(),
                 m_ConnectionsAvailable,
                 ElementsOnSerializedList(&m_KeepAliveList),
                 m_ConnectionLimit,
                 Fsm,
                 Fsm->m_dwSocketFlags,
                 Fsm->m_nPort,
                 Fsm->m_dwTimeout
                 ));

    PERF_ENTER(GetConnection);

    DWORD error = ERROR_SUCCESS;
    CFsm_GetConnection & fsm = *Fsm;
    ICSocket * pSocket = NULL;
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();
    HANDLE hEvent = NULL;
    BOOL bUnlockList = TRUE;
    BOOL bKeepAliveWaiters;

    INET_ASSERT(lpThreadInfo != NULL);
    INET_ASSERT(lpThreadInfo->hObjectMapped != NULL);
    INET_ASSERT(((HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->
                GetHandleType() == TypeHttpRequestHandle);

    if ((lpThreadInfo == NULL) || (lpThreadInfo->hObjectMapped == NULL)) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    BOOL bAsyncRequest;

    bAsyncRequest = lpThreadInfo->IsAsyncWorkerThread
                    || ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->
                        IsAsyncHandle();

    DWORD dwSecureFlags = ((HTTP_REQUEST_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->GetSecureFlags();

    *fsm.m_lplpSocket = NULL;

try_again:

    bUnlockList = TRUE;

    //
    // use m_Waiters to serialize access. N.B. - we will acquire m_KeepAliveList
    // from within m_Waiters
    //

    if (!m_Waiters.Acquire()) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if (IsNewLimit()) {
        UpdateConnectionLimit();
    }
    bKeepAliveWaiters = KeepAliveWaiters();
    if (fsm.m_dwSocketFlags & SF_KEEP_ALIVE) {

        //
        // maintain requester order - if there are already waiters then queue
        // this request, else try to satisfy the requester. HOWEVER, only check
        // for existing requesters the FIRST time through. If we're here with
        // FSM_STATE_CONTINUE then we've been unblocked and we can ignore any
        // waiters that came after us
        //

        if ((fsm.GetState() == FSM_STATE_CONTINUE) || !bKeepAliveWaiters) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("no current waiters for K-A connections\n"
                        ));


            if (g_pGlobalServerInfoPool != NULL           &&
                UnlimitedConnections())
            {
                CServerInfo * pGlobalServerInfo = g_pGlobalServerInfoPool->FindServerInfo(GetHostName());

                if (pGlobalServerInfo)
                {
                    while ((pSocket = pGlobalServerInfo->FindKeepAliveConnection(
                                        fsm.m_dwSocketFlags,
                                        fsm.m_nPort,
                                        fsm.m_lpszSecureTunnelHost,
                                        fsm.m_dwSecureProtocols,
                                        dwSecureFlags)) != NULL)
                    {
                        INET_ASSERT(pSocket->IsInGlobalKeepAlivePool());

                        if (pSocket->HasExpired() || pSocket->IsReset())
                        {

                            DEBUG_PRINT(SESSION,
                                        INFO,
                                        ("Global K-A connection %#x [%#x/%d] is reset (%B) or expired (%B)\n",
                                        pSocket,
                                        pSocket->GetSocket(),
                                        pSocket->GetSourcePort(),
                                        pSocket->IsReset(),
                                        pSocket->HasExpired()
                                        ));
                            pSocket->SetLinger(TRUE, 0);
                            pSocket->Destroy();
                            pSocket = NULL;
                        }
                        else
                        {
                            DPRINTF("%#x: %#x: *** matched %#x, %#x\n",
                                    GetCurrentThreadId(),
                                    Fsm,
                                    pSocket->GetSocket(),
                                    pSocket->GetFlags()
                                    );
                            //
                            // Push out this global serverinfo's expiry time to
                            // current time + GlobalServerInfoTimeout.
                            //
                            pGlobalServerInfo->SetExpiryTime();

                            break;
                        }
                    }

                    ReleaseServerInfo(pGlobalServerInfo);
                }
            }
            
            if (pSocket == NULL)
            {
                while ((pSocket = FindKeepAliveConnection(fsm.m_dwSocketFlags,
                                                         fsm.m_nPort,
                                                         fsm.m_lpszSecureTunnelHost,
                                                         fsm.m_dwSecureProtocols,
                                                         dwSecureFlags))!= NULL)
                {
                    INET_ASSERT(!(pSocket->IsInGlobalKeepAlivePool()));

                    if (pSocket->IsReset() || pSocket->HasExpired()) {

                        DPRINTF("%#x: %#x: ********* socket %#x is closed already\n",
                                GetCurrentThreadId(),
                                Fsm,
                                pSocket->GetSocket()
                                );

                        DEBUG_PRINT(SESSION,
                                    INFO,
                                    ("K-A connection %#x [%#x/%d] is reset (%B) or expired (%B)\n",
                                    pSocket,
                                    pSocket->GetSocket(),
                                    pSocket->GetSourcePort(),
                                    pSocket->IsReset(),
                                    pSocket->HasExpired()
                                    ));
                        pSocket->SetLinger(TRUE, 0);
    //dprintf("GetConnection: destroying reset socket %#x\n", pSocket->GetSocket());
                        pSocket->Destroy();
                        pSocket = NULL;
                        if (!UnlimitedConnections()) {
                            ++m_ConnectionsAvailable;
                        }
                        CHECK_CONNECTION_COUNT();
                    } else {

                        DPRINTF("%#x: %#x: *** matched %#x, %#x\n",
                                GetCurrentThreadId(),
                                Fsm,
                                pSocket->GetSocket(),
                                pSocket->GetFlags()
                                );

                        break;
                    }
                }
            }
            if (pSocket == NULL) {

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("no available K-A connections\n"
                            ));

                /*
                //
                // if all connections are in use as keep-alive connections then
                // since we're here, we want a keep-alive connection that doesn't
                // match the currently available keep-alive connections. Terminate
                // the oldest keep-alive connection (at the head of the queue)
                // and generate a new connection
                //

                LockSerializedList(&m_KeepAliveList);
                if (ElementsOnSerializedList(&m_KeepAliveList) == m_ConnectionLimit) {
                    pSocket = ContainingICSocket(SlDequeueHead(&m_KeepAliveList));
                    pSocket->SetLinger(FALSE, 0);
                    pSocket->Shutdown(2);
                    pSocket->Destroy();
                    if (!UnlimitedConnections()) {
                        ++m_ConnectionsAvailable;
                    }
                    CHECK_CONNECTION_COUNT();
                }
                UnlockSerializedList(&m_KeepAliveList);
                */
            }
        } else {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("%d waiters for K-A connection to %q\n",
                        ElementsOnSerializedList(&m_KeepAliveList),
                        GetHostName()
                        ));

        }
    }

    //
    // if we found a matching keep-alive connection or we are not limiting
    // connections then we're done
    //

    if ((pSocket != NULL) || UnlimitedConnections()) {

        INET_ASSERT(error == ERROR_SUCCESS);

        goto exit;
    }

    //
    // no keep-alive connections matched, or there are already waiters for
    // keep-alive connections
    //

    INET_ASSERT(m_ConnectionsAvailable <= m_ConnectionLimit);

    if (m_ConnectionsAvailable > 0) {

        if (fsm.m_lpszSecureTunnelHost)
            goto exit;  // don't create a connection here for SSL tunneling

        //
        // can create a connection
        //

        DEBUG_PRINT(SESSION,
                    INFO,
                    ("OK to create new connection\n"
                    ));

        DPRINTF("%#x: %#x: *** %s OK to create connection %d/%d\n",
                GetCurrentThreadId(),
                Fsm,
                GetHostName(),
                m_ConnectionsAvailable,
                m_ConnectionLimit
                );

        --m_ConnectionsAvailable;
    } else if (fsm.GetElapsedTime() > fsm.m_dwTimeout) {
        error = ERROR_WINHTTP_TIMEOUT;
    } else {
        
        //
        // if there are keep-alive connections but no keep-alive waiters
        // then either we don't want a keep-alive connection, or the ones
        // available don't match our requirements.
        // If we need a connection of a different type - e.g. SSL when all
        // we have is non-SSL then close a connection & generate a new one.
        // If we need a non-keep-alive connection then its okay to return
        // a current keep-alive connection, the understanding being that the
        // caller will not add Connection: Keep-Alive header (HTTP 1.0) or
        // will add Connection: Close header (HTTP 1.1)
        //

        //
        // BUGBUG - what about waiters for non-keep-alive connections?
        //
        // scenario - limit of 1 connection:
        //
        //  A. request for k-a
        //      continue & create connection
        //  B. request non-k-a
        //      none available; wait
        //  C. release k-a connection; unblock sync waiter B
        //  D. request non-k-a
        //      k-a available; return it; caller converts to non-k-a
        //  E. unblocked waiter B request non-k-a
        //      none available; wait
        //
        // If this situation continues, eventually B will time-out, whereas it
        // could have had the connection taken by D. Request D is younger and
        // therefore can afford to wait while B continues with the connection
        //

        BOOL fHaveConnection = FALSE;

        if (!bKeepAliveWaiters || (fsm.GetState() == FSM_STATE_CONTINUE)) {
            if (!LockSerializedList(&m_KeepAliveList)) {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }
            if (ElementsOnSerializedList(&m_KeepAliveList) != 0) {
                pSocket = ContainingICSocket(SlDequeueHead(&m_KeepAliveList));
                fHaveConnection = TRUE;

                DWORD dwSocketTypeFlags = pSocket->GetFlags() & SOCK_FLAGS;
                DWORD dwRequestTypeFlags = fsm.m_dwSocketFlags & SOCK_FLAGS;

                if ((dwSocketTypeFlags ^ dwRequestTypeFlags)
                    || (fsm.m_nPort != pSocket->GetPort())) {

                    DEBUG_PRINT(SESSION,
                                INFO,
                                ("different socket types (%#x, %#x) or ports (%d, %d) requested\n",
                                fsm.m_dwSocketFlags,
                                pSocket->GetFlags(),
                                fsm.m_nPort,
                                pSocket->GetPort()
                                ));

                    DPRINTF("%#x: %#x: *** closing socket %#x: %#x vs. %#x\n",
                            GetCurrentThreadId(),
                            Fsm,
                            pSocket->GetSocket(),
                            pSocket->GetFlags(),
                            fsm.m_dwSocketFlags
                            );
                    pSocket->SetLinger(TRUE, 0);
//dprintf("GetConnection: destroying different type socket %#x\n", pSocket->GetSocket());
                    pSocket->Destroy();
                    pSocket = NULL;
                    // If we were trying to wait for established SSL tunnel,
                    // but one wasn't found, then this connection is open
                    // for anyone.
                    if (!UnlimitedConnections() && fsm.m_lpszSecureTunnelHost) {
                        ++m_ConnectionsAvailable;
                    }
                } else {

                    DPRINTF("%#x: %#x: *** returning k-a connection %#x as non-k-a\n",
                            GetCurrentThreadId(),
                            Fsm,
                            pSocket->GetSocket()
                            );

                }
                CHECK_CONNECTION_COUNT();
            }
            UnlockSerializedList(&m_KeepAliveList);
            if (fHaveConnection) {
                goto exit;
            }
        }

        DPRINTF("%#x: %#x: blocking %s FSM %#x state %s %d/%d\n",
                GetCurrentThreadId(),
                Fsm,
                Fsm->MapType(),
                Fsm,
                Fsm->MapState(),
                m_ConnectionsAvailable,
                m_ConnectionLimit
                );

        //
        // we have to wait for a connection to become available. If we are an
        // async request then we queue this FSM & return the thread to the pool
        // or, if app thread, return pending indication to the app. If this is
        // a sync request (in an app thread) then we block on an event waiting
        // for a connection to become available
        //

        if (!bAsyncRequest) {

            //
            // create unnamed, initially unsignalled, auto-reset event
            //

            hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (hEvent == NULL) {
                error = GetLastError();
                goto exit;
            }
        }

        CConnectionWaiter * pWaiter;
        DWORD dwStatus = ERROR_SUCCESS;

#if INET_DEBUG

        for (pWaiter = (CConnectionWaiter *)m_Waiters.Head();
             pWaiter != (CConnectionWaiter *)m_Waiters.Self();
             pWaiter = (CConnectionWaiter *)pWaiter->Next()) {

            INET_ASSERT(pWaiter->Id() != (DWORD_PTR)(bAsyncRequest ? (DWORD_PTR)Fsm : lpThreadInfo->ThreadId));
        }
#endif

        pWaiter = New CConnectionWaiter(&m_Waiters,
                                        !bAsyncRequest,
                                        (fsm.m_dwSocketFlags & SF_KEEP_ALIVE)
                                            ? TRUE
                                            : FALSE,
                                        bAsyncRequest
                                            ? (DWORD_PTR)Fsm
                                            : lpThreadInfo->ThreadId,
                                        hEvent,

                                        //
                                        // priority in request handle object
                                        // controls relative position in list
                                        // of waiters
                                        //

                                        ((HTTP_REQUEST_HANDLE_OBJECT *)
                                            lpThreadInfo->hObjectMapped)->
                                                GetPriority(),

                                        &dwStatus
                                        );

        DPRINTF("%#x: %#x: new waiter %#x: as=%B, K-A=%B, id=%#x, hE=%#x, pri=%d, status=%#x, sf=%#x, preq=%#x ssl=%s\n",
                GetCurrentThreadId(),
                Fsm,
                pWaiter,
                bAsyncRequest,
                (fsm.m_dwSocketFlags & SF_KEEP_ALIVE)
                    ? TRUE
                    : FALSE,
                bAsyncRequest
                    ? (DWORD_PTR)Fsm
                    : lpThreadInfo->ThreadId,
                hEvent,
                ((HTTP_REQUEST_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->
                    GetPriority(),
                dwStatus,
                fsm.m_dwSocketFlags,
                ((HTTP_REQUEST_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped),
                fsm.m_lpszSecureTunnelHost ? fsm.m_lpszSecureTunnelHost : ""
                );

        if (pWaiter == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        else if (dwStatus != ERROR_SUCCESS) {
            error = dwStatus;
            delete pWaiter;  // free since it wasn't inserted
            goto exit;
        }
        
        if (bAsyncRequest) {

            //
            // ensure that when the FSM is unblocked normally, the new state
            // is STATE_CONTINUE
            //

            Fsm->SetState(FSM_STATE_CONTINUE);
            error = BlockWorkItem(Fsm,
                                  (DWORD_PTR)pWaiter,
                                  fsm.m_dwTimeout
                                  );
            if (error == ERROR_SUCCESS) {
                error = ERROR_IO_PENDING;
            }
        } 
        else
        {
            m_Waiters.Release();
            bUnlockList = FALSE;

            DPRINTF("%#x: %#x: %s FSM %#x %s waiting %d msec\n",
                    GetCurrentThreadId(),
                    Fsm,
                    Fsm->MapType(),
                    Fsm,
                    Fsm->MapState(),
                    fsm.m_dwTimeout
                    );

            DWORD dwWaitTime = (fsm.m_dwTimeout != INFINITE) ? 
                                (fsm.m_dwTimeout - fsm.GetElapsedTime()) : 
                                  INFINITE;

            if (((int)dwWaitTime <= 0) && (dwWaitTime != INFINITE)) {

                DEBUG_PRINT(SESSION,
                            ERROR,
                            ("SYNC wait timed out (%d mSec)\n",
                            fsm.m_dwTimeout
                            ));

                error = ERROR_WINHTTP_TIMEOUT;
            } else {

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("waiting %d mSec for SYNC event %#x\n",
                            dwWaitTime,
                            hEvent
                            ));

                //
                // we'd better not be doing a sync wait if we are in the
                // context of an app thread making an async request
                //

                INET_ASSERT(lpThreadInfo->IsAsyncWorkerThread
                            || !((INTERNET_HANDLE_OBJECT *)lpThreadInfo->
                                hObjectMapped)->IsAsyncHandle());

                //INET_ASSERT(dwWaitTime <= 60000);

                error = WaitForSingleObject(hEvent, dwWaitTime);

                DPRINTF("%#x: %#x: sync waiter unblocked - error = %d\n",
                        GetCurrentThreadId(),
                        Fsm,
                        error
                        );

            }
            if (error == STATUS_TIMEOUT) {

                DPRINTF("%#x: %#x: %s: %d+%d/%d: timed out %#x (%s FSM %#x %s)\n",
                        GetCurrentThreadId(),
                        Fsm,
                        GetHostName(),
                        m_ConnectionsAvailable,
                        ElementsOnSerializedList(&m_KeepAliveList),
                        m_ConnectionLimit,
                        GetCurrentThreadId(),
                        Fsm->MapType(),
                        Fsm,
                        Fsm->MapState()
                        );

                RemoveWaiter(lpThreadInfo->ThreadId);
                error = ERROR_WINHTTP_TIMEOUT;
            }

            BOOL bOk;

            bOk = CloseHandle(hEvent);

            INET_ASSERT(bOk);

            if (error == WAIT_OBJECT_0) {

                DPRINTF("%#x: %#x: sync requester trying again\n",
                        GetCurrentThreadId(),
                        Fsm
                        );

                fsm.SetState(FSM_STATE_CONTINUE);
                goto try_again;
            }
        }
    }

exit:

    //
    // if we are returning a (keep-alive) socket that has a different blocking
    // mode from that requested, change it
    //

    if (pSocket != NULL) {
        if ((pSocket->GetFlags() & SF_NON_BLOCKING)
            ^ (fsm.m_dwSocketFlags & SF_NON_BLOCKING)) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("different blocking modes requested: %#x, %#x\n",
                        fsm.m_dwSocketFlags,
                        pSocket->GetFlags()
                        ));

            DPRINTF("%#x: %#x: *** changing socket %#x to %sBLOCKING\n",
                    GetCurrentThreadId(),
                    Fsm,
                    pSocket->GetSocket(),
                    fsm.m_dwSocketFlags & SF_NON_BLOCKING ? "NON-" : ""
                    );

            if (!(GlobalRunningNovellClient32 && !GlobalNonBlockingClient32)) {
                pSocket->SetNonBlockingMode(fsm.m_dwSocketFlags & SF_NON_BLOCKING);
            }
        }
        *fsm.m_lplpSocket = pSocket;
    }

    if (bUnlockList) {
        m_Waiters.Release();
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DPRINTF("%#x: %#x: %s: %d+%d/%d: get: %d, %#x, %d\n",
            GetCurrentThreadId(),
            Fsm,
            GetHostName(),
            m_ConnectionsAvailable,
            ElementsOnSerializedList(&m_KeepAliveList),
            m_ConnectionLimit,
            error,
            pSocket ? pSocket->GetSocket() : 0,
            m_Waiters.Count()
            );

    PERF_LEAVE(GetConnection);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CServerInfo::ReleaseConnection(
    IN ICSocket * lpSocket OPTIONAL
    )

/*++

Routine Description:

    Returns a keep-alive connection to the pool, or allows another requester to
    create a connection

Arguments:

    lpSocket    - pointer to ICSocket if we are returning a keep-alive connection

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CServerInfo::ReleaseConnection",
                 "{%q [%d+%d/%d]} %#x [%#x]",
                 GetHostName(),
                 AvailableConnections(),
                 KeepAliveConnections(),
                 ConnectionLimit(),
                 lpSocket,
                 lpSocket ? lpSocket->GetSocket() : 0
                 ));

    PERF_ENTER(ReleaseConnection);

    DWORD error = ERROR_SUCCESS;
    BOOL bRelease = FALSE;

    CServerInfo *   pGlobalServerInfo;
    BOOL            bInGlobalServerPool = InGlobalServerInfoPool();


    if (!bInGlobalServerPool)
    {
        if (!m_Waiters.Acquire())
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        //
        // quite often (at least with catapult proxy based on IIS) the server may
        // drop the connection even though it indicated it would keep it open. This
        // typically happens on 304 (frequent) and 302 (less so) responses. If we
        // determine the server has dropped the connection then throw it away and
        // allow the app to create a new one
        //

        if (lpSocket != NULL) {

            lpSocket->ResetInGlobalKeepAlivePool();

            if (lpSocket->IsClosed() || lpSocket->IsReset()) {

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("socket %#x already dead - throwing it out\n",
                            lpSocket->GetSocket()
                            ));

                DPRINTF("%#x: socket %#x: already reset\n",
                        GetCurrentThreadId(),
                        lpSocket->GetSocket()
                        );

    //dprintf("ReleaseConnection: destroying already closed socket %#x\n", lpSocket->GetSocket());
                BOOL bDestroyed = lpSocket->Dereference();
                UNREFERENCED_PARAMETER(bDestroyed); // avoid C4189 on free builds
                INET_ASSERT(bDestroyed);

                lpSocket = NULL;
            } else {

                //
                // if we are returning a keep-alive socket, put it in non-blocking
                // mode if not already. Typically, Internet Explorer uses non-blocking
                // sockets. In the infrequent cases where we want a blocking socket
                // - mainly when doing java downloads - we will convert the socket
                // to blocking mode when we get it from the pool
                //

                if (!lpSocket->IsNonBlocking()) {

                    DPRINTF("%#x: ***** WARNING: releasing BLOCKING k-a socket %#x\n",
                            GetCurrentThreadId(),
                            lpSocket->GetSocket()
                            );

                    lpSocket->SetNonBlockingMode(TRUE);
                }
            }
        }
    }


    if ((lpSocket != NULL)                          &&
        !bInGlobalServerPool                        &&
        ( (lpSocket->GetFlags() & SOCK_FLAGS) == 0    ||
          !(((ICSecureSocket *)lpSocket)->GetCertContextArray() &&
            ((ICSecureSocket *)lpSocket)->GetCertContextArray()->GetSelectedCertContext()) ) &&
        !lpSocket->IsAuthorized()                   &&
        UnlimitedConnections()                      &&
        (g_pGlobalServerInfoPool != NULL)           &&
        ((pGlobalServerInfo = g_pGlobalServerInfoPool->GetServerInfo(GetHostName()))!=NULL)
        )
    {
        INET_ASSERT(!lpSocket->IsAuthenticated());

        //
        // Release the socket connection into the global pool...
        //
        lpSocket->SetInGlobalKeepAlivePool();

        error = pGlobalServerInfo->ReleaseConnection(lpSocket);

        //
        // Push out this global serverinfo's expiry time to
        // current time + GlobalServerInfoTimeout.
        //
        pGlobalServerInfo->SetExpiryTime();

        ReleaseServerInfo(pGlobalServerInfo);
        pGlobalServerInfo = NULL;

    }
    else if (lpSocket != NULL) {

        DPRINTF("%#x: releasing K-A %#x (%d+%d/%d)\n",
                GetCurrentThreadId(),
                lpSocket ? lpSocket->GetSocket() : 0,
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                );

        INET_ASSERT(lpSocket->IsOpen());
        INET_ASSERT(!lpSocket->IsOnList());
        //INET_ASSERT(!lpSocket->IsReset());

        lpSocket->SetKeepAlive();

        DEBUG_PRINT(SESSION,
                    INFO,
                    ("releasing keep-alive socket %#x\n",
                    lpSocket->GetSocket()
                    ));

        lpSocket->SetExpiryTime(GlobalKeepAliveSocketTimeout);

        INET_ASSERT(!IsOnSerializedList(&m_KeepAliveList, lpSocket->List()));

        if (!InsertAtTailOfSerializedList(&m_KeepAliveList, lpSocket->List()))
        {
            DEBUG_PRINT(SESSION,
                        INFO,
                        ("not enough memory to release %#x to k-a pool\n",
                        lpSocket->GetSocket()
                        ));

            lpSocket->Dereference();

            if (!UnlimitedConnections())
            {
                ++m_ConnectionsAvailable;
            }
        }

        lpSocket = NULL;

        INET_ASSERT(UnlimitedConnections()
            ? TRUE
            : (KeepAliveConnections() <= ConnectionLimit()));

        bRelease = TRUE;
    } else {

        DPRINTF("%#x: releasing connection (%d+%d/%d)\n",
                GetCurrentThreadId(),
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                );

        if (!UnlimitedConnections()) {
            ++m_ConnectionsAvailable;
        }

        CHECK_CONNECTION_COUNT();

        bRelease = TRUE;
    }
    if (bRelease && !UnlimitedConnections()) {

        CHECK_CONNECTION_COUNT();

        CConnectionWaiter * pWaiter = (CConnectionWaiter *)m_Waiters.RemoveHead();

        if (pWaiter != NULL) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("unblocking %s waiter %#x, pri=%d\n",
                        pWaiter->IsSync() ? "SYNC" : "ASYNC",
                        pWaiter->Id(),
                        pWaiter->GetPriority()
                        ));

            DPRINTF("%#x: Unblocking %s connection waiter %#x, pri=%d\n",
                    GetCurrentThreadId(),
                    pWaiter->IsSync() ? "Sync" : "Async",
                    pWaiter->Id(),
                    pWaiter->GetPriority()
                    );

            if (pWaiter->IsSync()) {
                pWaiter->Signal();
            } else {

                DWORD n = UnblockWorkItems(1, (DWORD_PTR)pWaiter, ERROR_SUCCESS);
                UNREFERENCED_PARAMETER(n);
                //INET_ASSERT(n == 1);
            }
            delete pWaiter;
        } else {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("no waiters\n"
                        ));

            DPRINTF("%#x: !!! NOT unblocking connection waiter\n",
                    GetCurrentThreadId()
                    );

        }
    } else {

        DPRINTF("%#x: !!! NOT releasing or unlimited?\n",
                GetCurrentThreadId()
                );

        DEBUG_PRINT(SESSION,
                    INFO,
                    ("bRelease = %B, UnlimitedConnections() = %B\n",
                    bRelease,
                    UnlimitedConnections()
                    ));

    }

    DEBUG_PRINT(SESSION,
                INFO,
                ("avail+k-a/limit = %d+%d/%d\n",
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                ));

    if (IsNewLimit()) {
        UpdateConnectionLimit();
    }

    if (!bInGlobalServerPool)
    {
        m_Waiters.Release();
    }

quit:
    PERF_LEAVE(ReleaseConnection);

    DEBUG_LEAVE(error);

    DPRINTF("%#x: %s: %d+%d/%d: rls %#x: %d, %d\n",
            GetCurrentThreadId(),
            GetHostName(),
            AvailableConnections(),
            KeepAliveConnections(),
            ConnectionLimit(),
            lpSocket ? lpSocket->GetSocket() : 0,
            error,
            m_Waiters.Count()
            );

    return error;
}



VOID
CServerInfo::RemoveWaiter(
    IN DWORD_PTR dwId
    )

/*++

Routine Description:

    Removes a CConnectionWaiter corresponding to the FSM

Arguments:

    dwId    - waiter id to match

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::RemoveWaiter",
                 "%#x",
                 dwId
                 ));

    if (!m_Waiters.Acquire())
        goto quit;

    CConnectionWaiter * pWaiter;
    BOOL found = FALSE;

    for (pWaiter = (CConnectionWaiter *)m_Waiters.Head();
         pWaiter != (CConnectionWaiter *)m_Waiters.Self();
         pWaiter = (CConnectionWaiter *)pWaiter->Next()) {

        if (pWaiter->Id() == dwId) {
            m_Waiters.Remove((CPriorityListEntry *)pWaiter);
            delete pWaiter;
            found = TRUE;
            break;
        }
    }
    m_Waiters.Release();

quit:
    //INET_ASSERT(found);

    DEBUG_LEAVE(0);
}

//
// private CServerInfo methods
//


ICSocket *
CServerInfo::FindKeepAliveConnection(
    IN DWORD dwSocketFlags,
    IN INTERNET_PORT nPort,
    IN LPSTR pszTunnelServer,
    IN DWORD dwSecureProtocols,
    IN DWORD dwSecureFlags
    )

/*++

Routine Description:

    Find a keep-alive connection with the requested attributes and port number

Arguments:

    dwSocketFlags     - socket type flags (e.g. SF_SECURE)

    nPort             - port to server

    pszTunnelServer   - hostname of server through SSL tunnel, or
                        NULL if not checked.

    dwSecureProtocols - Enabled SSL protocols on keep-alive must match
                        the requested values.

Return Value:

    ICSocket *

--*/

{
    DPRINTF("%#x: *** looking for K-A connection\n", GetCurrentThreadId());

    DEBUG_ENTER((DBG_SESSION,
                 Pointer,
                 "CServerInfo::FindKeepAliveConnection",
                 "{%q} %#x, %d, %q, %#x",
                 GetHostName(),
                 dwSocketFlags,
                 nPort,
                 pszTunnelServer ? pszTunnelServer : "NULL",
                 dwSecureProtocols
                 ));

    ICSocket * pSocket = NULL;
    BOOL bFound = FALSE;

    //
    // don't check whether socket is non-blocking - we only really want to match
    // on secure/non-secure. Possible flags to check on are:
    //
    //  SF_ENCRYPT          - should be subsumed by SF_SECURE
    //  SF_DECRYPT          - should be subsumed by SF_SECURE
    //  SF_NON_BLOCKING     - this isn't criterion for match
    //  SF_CONNECTIONLESS   - not implemented?
    //  SF_AUTHORIZED       - must be set if authorized & in pool
    //  SF_SECURE           - opened for SSL/PCT if set
    //  SF_KEEP_ALIVE       - must be set
    //  SF_TUNNEL           - must be set if we're looking for a CONNECT tunnel to proxy
    //  SF_OVERLAPPED       - set if overlapped.

    dwSocketFlags &= ~SF_NON_BLOCKING;

    if (!LockSerializedList(&m_KeepAliveList))
        goto quit;

    PLIST_ENTRY pEntry;

    for (pEntry = HeadOfSerializedList(&m_KeepAliveList);
         pEntry != (PLIST_ENTRY)SlSelf(&m_KeepAliveList);
         pEntry = pEntry->Flink) {

        pSocket = ContainingICSocket(pEntry);

        INET_ASSERT(pSocket->IsKeepAlive());

        //
        // We make sure the socket we request is the correct socket,
        //  Match() is a bit confusing and needs a bit of explaining,
        //  Match IS NOT AN EXACT MATCH, it mearly checks to make sure 
        //  that the requesting flags (dwSocketFlags) are found in the 
        //  socket flags.  So this can lead to a secure socket being returned
        //  on a non-secure open request, now realistically this doesn't happen
        //  because of the port number.  But in the case of tunnelling this may be
        //  an issue, so we add an additional check to make sure that we only
        //  get a tunneled socket to a proxy if we specifically request one.
        //

        if (pSocket->Match(dwSocketFlags&~SF_OVERLAPPED)
        && (pSocket->GetPort() == nPort)
        &&  pSocket->MatchSecureProtocolSemantics(dwSocketFlags, pszTunnelServer, dwSecureProtocols, dwSecureFlags)
        &&  pSocket->MatchOverlappedSemantics(dwSocketFlags)
        &&  RemoveFromSerializedList(&m_KeepAliveList, pSocket->List())) {

            INET_ASSERT(!IsOnSerializedList(&m_KeepAliveList, pSocket->List()));

            bFound = TRUE;

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("returning keep-alive socket %#x\n",
                        pSocket->GetSocket()
                        ));

            DPRINTF("%#x: *** %s keep-alive connection %#x (%d/%d), wantf=%#x, gotf=%#x\n",
                    GetCurrentThreadId(),
                    GetHostName(),
                    pSocket->GetSocket(),
                    AvailableConnections(),
                    ConnectionLimit(),
                    dwSocketFlags,
                    pSocket->GetFlags()
                    );

            break;
        }
    }
    UnlockSerializedList(&m_KeepAliveList);
    if (!bFound) {
        pSocket = NULL;
    }

quit:
    DEBUG_LEAVE(pSocket);

    return pSocket;
}


BOOL
CServerInfo::KeepAliveWaiters(
    VOID
    )

/*++

Routine Description:

    Determine if any of the waiters on the list are for keep-alive connections

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Bool,
                 "CServerInfo::KeepAliveWaiters",
                 NULL
                 ));

    BOOL found = FALSE;
    CConnectionWaiter * pWaiter;

    if (!m_Waiters.Acquire())
        goto quit;

    for (pWaiter = (CConnectionWaiter *)m_Waiters.Head();
         pWaiter != (CConnectionWaiter *)m_Waiters.Self();
         pWaiter = (CConnectionWaiter *)pWaiter->Next()) {

        if (pWaiter->IsKeepAlive()) {
            found = TRUE;
            break;
        }
    }
    m_Waiters.Release();

quit:
    DEBUG_LEAVE(found);

    return found;
}



VOID
CServerInfo::UpdateConnectionLimit(
    VOID
    )

/*++

Routine Description:

    Change connection limit to new limit

    Assumes: 1. Caller has acquired this object before calling this function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::UpdateConnectionLimit",
                 "{%q: %d=>%d (%d+%d)}",
                 GetHostName(),
                 ConnectionLimit(),
                 GetNewLimit(),
                 AvailableConnections(),
                 KeepAliveConnections()
                 ));

    LONG difference = GetNewLimit() - ConnectionLimit();

    //
    // BUGBUG - only handling increases in limit for now
    //

    INET_ASSERT(difference > 0);

    if (difference > 0) {
        m_ConnectionsAvailable += difference;
    }
    m_ConnectionLimit = m_NewLimit;

    DEBUG_PRINT(SESSION,
                INFO,
                ("%q: new: %d+%d/%d\n",
                GetHostName(),
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                ));

    DEBUG_LEAVE(0);
}


VOID
CServerInfo::PurgeKeepAlives(
    IN DWORD dwForce
    )

/*++

Routine Description:

    Purges any timed-out keep-alive connections

Arguments:

    dwForce - force to apply when purging. Value can be:

                PKA_NO_FORCE    - only purge timed-out sockets or sockets in
                                  close-wait state (default)

                PKA_NOW         - purge all sockets

                PKA_AUTH_FAILED - purge sockets that have been marked as failing
                                  authentication

Return Value:

    None.

--*/

{
//dprintf("%#x PurgeKeepAlives(%d)\n", GetCurrentThreadId(), dwForce);
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::PurgeKeepAlives",
                 "{%q [ref=%d, k-a=%d]} %s [%d]",
                 GetHostName(),
                 ReferenceCount(),
                 KeepAliveConnections(),
                 (dwForce == PKA_NO_FORCE) ? "NO_FORCE"
                 : (dwForce == PKA_NOW) ? "NOW"
                 : (dwForce == PKA_AUTH_FAILED) ? "AUTH_FAILED"
                 : "?",
                 dwForce
                 ));

    if (IsKeepAliveListInitialized()) {

        INET_ASSERT(ReferenceCount() >= 1);

        if (!m_Waiters.Acquire())
            goto quit;

        if (!LockSerializedList(&m_KeepAliveList))
            goto Cleanup;

        PLIST_ENTRY last = (PLIST_ENTRY)SlSelf(&m_KeepAliveList);
        DWORD ticks = GetTickCountWrap();

        for (PLIST_ENTRY pEntry = HeadOfSerializedList(&m_KeepAliveList);
            pEntry != (PLIST_ENTRY)SlSelf(&m_KeepAliveList);
            pEntry = last->Flink) {

            ICSocket * pSocket = ContainingICSocket(pEntry);
            BOOL bDelete;

            if (pSocket->IsReset()) {
//dprintf("%q: socket %#x/%d CLOSE-WAIT\n", GetHostName(), pSocket->GetSocket(), pSocket->GetSourcePort());
                bDelete = TRUE;
            } else if (dwForce == PKA_NO_FORCE) {
                bDelete = pSocket->HasExpired(ticks);
            } else if (dwForce == PKA_NOW) {
                bDelete = TRUE;
            } else if (dwForce == PKA_AUTH_FAILED) {
                bDelete = pSocket->IsAuthorized();
            } else {
                INET_ASSERT(FALSE); // invalid value for dwForce!
                bDelete = TRUE;
            }
            if (bDelete) {
//dprintf("%q: socket %#x/%d. Close-Wait=%B, Expired=%B, Now=%B, Auth=%B\n",
//        GetHostName(),
//        pSocket->GetSocket(),
//        pSocket->GetSourcePort(),
//        pSocket->IsReset(),
//        pSocket->HasExpired(ticks),
//        (dwForce == PKA_NOW),
//        (dwForce == PKA_AUTH_FAILED) && pSocket->IsAuthorized()
//        );

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("purging keep-alive socket %#x/%d: Close-Wait=%B, Expired=%B, Now=%B, Auth=%B\n",
                            pSocket->GetSocket(),
                            pSocket->GetSourcePort(),
                            pSocket->IsReset(),
                            pSocket->HasExpired(ticks),
                            (dwForce == PKA_NOW),
                            (dwForce == PKA_AUTH_FAILED) && pSocket->IsAuthorized()
                            ));

                if (RemoveFromSerializedList(&m_KeepAliveList, pEntry))
                {
                    BOOL bDestroyed;

                    bDestroyed = pSocket->Dereference();

                    INET_ASSERT(bDestroyed);

                    if (!UnlimitedConnections()) {
                        ++m_ConnectionsAvailable;

                        INET_ASSERT(m_ConnectionsAvailable <= m_ConnectionLimit);

                    }
                }
                else
                {
                    DEBUG_PRINT(SESSION,
                                INFO,
                                ("k-a socket %#x couldn't be removed from the list\n",
                                pSocket->GetSocket()
                                ));
                }
            } else {

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("socket %#x/%d expires in %d mSec\n",
                            pSocket->GetSocket(),
                            pSocket->GetSourcePort(),
                            pSocket->GetExpiryTime() - ticks
                            ));

                last = pEntry;
            }
        }

        UnlockSerializedList(&m_KeepAliveList);
Cleanup:
        m_Waiters.Release();
    }

quit:
    DEBUG_LEAVE(0);
}

//
// friend functions
//


CServerInfo *
ContainingServerInfo(
    IN LPVOID lpAddress
    )

/*++

Routine Description:

    Returns address of CServerInfo given address of m_List

Arguments:

    lpAddress   - address of m_List

Return Value:

    CServerInfo *

--*/

{
    return CONTAINING_RECORD(lpAddress, CServerInfo, m_List);
}



CGlobalServerInfoPool *  g_pGlobalServerInfoPool;


BOOL
CGlobalServerInfoPool::Initialize()
{
    SetNextScavengeTime();
    
    _hGCThread = NULL;

    _fIsGCRunning = FALSE;

    return InitializeSerializedList(&_GlobalServerInfoList);
}

void
CGlobalServerInfoPool::Terminate()
{
    if (_hGCThread != NULL)
    {
        CloseHandle(_hGCThread);
        _hGCThread = NULL;
    }

    if (LockSerializedList(&_GlobalServerInfoList))
    {
        PLIST_ENTRY pEntry = HeadOfSerializedList(&_GlobalServerInfoList);
        PLIST_ENTRY pPrevious = (PLIST_ENTRY)SlSelf(&_GlobalServerInfoList);

        for (;;)
        {
            if (pEntry == (PLIST_ENTRY)SlSelf(&_GlobalServerInfoList))
            {
                break;
            }

            CServerInfo * pServerInfo;

            pServerInfo = ContainingServerInfo(pEntry);

            BOOL deleted = pServerInfo->Dereference();

            INET_ASSERT(deleted);

            if (!deleted)
            {
                pPrevious = pEntry;
            }
            pEntry = pPrevious->Flink;
        }

        UnlockSerializedList(&_GlobalServerInfoList);
    }

    TerminateSerializedList(&_GlobalServerInfoList);
}


CServerInfo *
CGlobalServerInfoPool::FindServerInfo(LPSTR lpszHostName)
{
    ICSTRING        hostName(lpszHostName);
    CServerInfo *   pServerInfo = NULL;

    if (hostName.HaveString())
    {
        hostName.MakeLowerCase();

        lpszHostName = hostName.StringAddress();

        DWORD hashHostName = CalculateHashValue(lpszHostName);

        if (LockSerializedList(&_GlobalServerInfoList))
        {
            BOOL    found = FALSE;

            for (pServerInfo = (CServerInfo *)HeadOfSerializedList(&_GlobalServerInfoList);
                pServerInfo != (CServerInfo *)SlSelf(&_GlobalServerInfoList);
                pServerInfo = pServerInfo->Next())
            {
                if (pServerInfo->Match(hashHostName, lpszHostName))
                {
                    found = TRUE;
                    pServerInfo->Reference();
                    break;
                }
            }

            if (!found)
            {
                pServerInfo = NULL;
            }

            UnlockSerializedList(&_GlobalServerInfoList);
        }
    }

    return pServerInfo;
}


CServerInfo *
CGlobalServerInfoPool::GetServerInfo(LPSTR lpszHostName)
{
    CServerInfo *   pServerInfo = NULL;
    
    if (LockSerializedList(&_GlobalServerInfoList))
    {
        pServerInfo = FindServerInfo(lpszHostName);

        if (!pServerInfo)
        {
            DWORD   dwError = ERROR_SUCCESS;

            pServerInfo = New CServerInfo(&_GlobalServerInfoList,
                                lpszHostName,
                                &dwError,
                                INTERNET_SERVICE_HTTP,
                                WINHTTP_CONNS_PER_SERVER_UNLIMITED);

            if (pServerInfo)
            {
                if (dwError == ERROR_SUCCESS)
                {
                    pServerInfo->SetInGlobalServerInfoPool();
                    pServerInfo->Reference();

                    //
                    // Make sure the global socket pool garbage collector
                    // thread is running.
                    //
                    StartGarbageCollectorIfNotRunning();
                }
                else
                {
                    BOOL bDeleted = pServerInfo->Dereference();
                    UNREFERENCED_PARAMETER(bDeleted);
                    INET_ASSERT(bDeleted);
                    pServerInfo = NULL;
                }
            }
        }

        UnlockSerializedList(&_GlobalServerInfoList);
    }

    return pServerInfo;
}

#define MAX_SCAVENGE_TIME       150                 // 150 milliseconds
#define SCAVENGE_DELTA         (30 * 1000)          // 30 seconds


BOOL CGlobalServerInfoPool::ScavengeList()
{
    BOOL    fListEmpty = FALSE;

    if (LockSerializedList(&_GlobalServerInfoList))
    {
        DWORD   StartTime = GetTickCount();
        DWORD   CurrentTime;
        DWORD   EndTime = StartTime + MAX_SCAVENGE_TIME; 
        BOOL    bWrap = (EndTime < StartTime);

        CurrentTime = StartTime;

        if (TimeToScavenge(CurrentTime))
        {
            PLIST_ENTRY pEntry = HeadOfSerializedList(&_GlobalServerInfoList);
            PLIST_ENTRY pPrevious = (PLIST_ENTRY)SlSelf(&_GlobalServerInfoList);

            for (;;)
            {
                if (pEntry == (PLIST_ENTRY)SlSelf(&_GlobalServerInfoList))
                {
                    break;
                }

                CServerInfo *   pServerInfo = ContainingServerInfo(pEntry);
                BOOL            deleted     = FALSE;

                if (pServerInfo->Expired())
                {
                    // Delete ServerInfo if ref count is 1
                    deleted = pServerInfo->Dereference();
                }
                else
                {
                    pServerInfo->PurgeKeepAlives(PKA_NO_FORCE);
                }

                if (!deleted)
                {
                    pPrevious = pEntry;
                }

                pEntry = pPrevious->Flink;

                CurrentTime = GetTickCount();

                if (!bWrap)
                {
                    if ((CurrentTime >= EndTime) || (CurrentTime < StartTime))
                        break;
                }
                else
                {
                    if ((CurrentTime >= EndTime) && (CurrentTime < StartTime))
                        break;
                }
                       
            }

            SetNextScavengeTime();
        }

        fListEmpty = IsSerializedListEmpty(&_GlobalServerInfoList);

        UnlockSerializedList(&_GlobalServerInfoList);
    }

    return fListEmpty;
}


BOOL CGlobalServerInfoPool::TimeToScavenge(DWORD CurrentTime) const
{
    if (!_bWrap)
    {
        if ((CurrentTime >= _NextScavengeTime) || (CurrentTime < _PreviousScavengeTime))
            return TRUE;
    }
    else
    {
        if ((CurrentTime >= _NextScavengeTime) && (CurrentTime < _PreviousScavengeTime))
            return TRUE;
    }
    
    return FALSE;
}


void CGlobalServerInfoPool::SetNextScavengeTime()
{
    _PreviousScavengeTime = GetTickCount();
    _NextScavengeTime    = _PreviousScavengeTime + SCAVENGE_DELTA;
    _bWrap = (_NextScavengeTime < _PreviousScavengeTime);
}


void CGlobalServerInfoPool::StartGarbageCollectorIfNotRunning()
{
    if (IsGarbageCollectorRunning())
        return;

    if (LockSerializedList(&_GlobalServerInfoList))
    {
        if (_hGCThread != NULL)
        {
            if (WaitForSingleObject(_hGCThread, 0) == WAIT_OBJECT_0)
            {
                CloseHandle(_hGCThread);
                _hGCThread = NULL;
            }
        }

        if (_hGCThread == NULL)
        {
            DWORD   dwThreadId;
            HMODULE hDll;
            char    szDllPath[MAX_PATH+1];

            GetModuleFileName(GlobalDllHandle, szDllPath, MAX_PATH);
            szDllPath[MAX_PATH] = '\0'; // ensure string is NULL terminated

            hDll = LoadLibrary(szDllPath);

            if (hDll != NULL)
            {
                // Temporarily revert impersonation if any and create the thread
                WRAP_REVERT_USER(CreateThread, FALSE,
                                    (NULL,
                                    0,
                                    &CGlobalServerInfoPool::GarbageCollectorThread,
                                    (void *) hDll,
                                    0,
                                    &dwThreadId),
                                _hGCThread);

                if (_hGCThread != NULL)
                {
                    SetGarbageCollectorRunning(TRUE);
                }
            }
        }

        UnlockSerializedList(&_GlobalServerInfoList);
    }
}


DWORD WINAPI CGlobalServerInfoPool::GarbageCollectorThread(LPVOID lpParameter)
{
    BOOL    fListEmpty    = FALSE;
    BOOL    fListWasEmpty = FALSE;
    HMODULE hDll          = (HMODULE) lpParameter;

    for (;;)
    {
        Sleep(SCAVENGE_DELTA);

        INET_ASSERT(g_pGlobalServerInfoPool != NULL);

        fListEmpty = g_pGlobalServerInfoPool->ScavengeList();

        if (fListEmpty && fListWasEmpty)
        {
            g_pGlobalServerInfoPool->SetGarbageCollectorRunning(FALSE);
            break;
        }

        fListWasEmpty = fListEmpty;
    }

    FreeLibraryAndExitThread(hDll, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\debug\debugmem.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    debugmem.cxx

Abstract:

    Debug memory allocator

    Contents:
        InternetDebugMemInitialize
        InternetDebugMemTerminate
        InternetDebugAllocMem
        InternetDebugFreeMem
        InternetDebugReAllocMem
        InternetDebugSizeMem
        InternetDebugCheckMemFreed
        InternetDebugMemReport
        (InternetDebugCheckMemBlock)
        (DebugFillMem)
        (InternetAlloc)
        (InternetFree)
        (InternetReAlloc)
        (InternetSize)
        (InternetHeapAlloc)
        (InternetHeapReAlloc)
        (InternetHeapFree)
        (InternetHeapSize)
        (InternetDebugMemTest)
        (ReportMemoryUsage)
        (ReportMemoryBlocks)
        (DumpDeferredFreeList)
        (DumpMemoryList)
        (FindAndDumpDeferredBlock)
        (DumpBlock)
        (DumpDebugMemoryHeader)
        (DumpDebugMemoryFooter)
        (DumpUserData)
        (MapLastAccessOperation)
        (MapMemoryFlags)
        (DbgMemGetDebugSymbol)

Author:

     Richard L Firth (rfirth) 02-Feb-1995

Environment:

    Win32 user mode

Revision History:

    02-Feb-1995
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

#if defined(USE_DEBUG_MEMORY)

//
// manifests
//

#define DEFAULT_INITIAL_HEAP_SIZE   (64 K)
#define DEFAULT_MAXIMUM_HEAP_SIZE   (1 M)
#define DEFAULT_HEADER_GUARD_SIZE   32
#define DEFAULT_FOOTER_GUARD_SIZE   32
#define DEFAULT_ALLOC_ALIGNMENT     4
#define HEADER_SIGNATURE            0x414d454d  // "MEMA"
#define FOOTER_SIGNATURE            0x434f4c4c  // "LLOC"
#define DWORD_ALLOC_FILL            0xc5c5c5c5
#define BYTE_ALLOC_FILL             0xc5
#define BYTE_ALLOC_FILL_EXTRA       0x88
#define GUARD_DWORD_FILL            0x44524147  // "GARD"
#define DWORD_FREE_FILL             0xb7b7b7b7
#define BYTE_FREE_FILL              0xb7
#define DEFAULT_MAX_BLOCKS_DUMPED   1024
#define DEFAULT_MAX_DATA_DUMPED     65536
#define DEFAULT_BACKTRACE_DEPTH     2

//
// only perform stack dump for x86 (or other stack-based processors)
//

#if defined(i386)
#define DUMP_STACK  1
#else
#define DUMP_STACK  0
#endif

//
// just using one stack these days
//

#define ONE_STACK   1

//
// private types
//

typedef enum {
    MemAllocate = 0x6f6c6c41,   // "Allo"
    MemReallocate = 0x6c416552, // "ReAl"
    MemLock = 0x6b636f4c,       // "Lock"
    MemUnlock = 0x6f6c6e55,     // "Unlo"
    MemFree = 0x65657246,       // "Free"
    MemSize = 0x657a6953        // "Size"
} MEMORY_ACTION;

typedef enum {
    HEAP_COMPACT_NEVER = 0,
    HEAP_COMPACT_ON_ALLOC_FAIL,
    HEAP_COMPACT_ON_FREE
} HEAP_COMPACT_TYPE;

typedef enum {
    HEAP_VALIDATE_NEVER = 0,
    HEAP_VALIDATE_ON_ALLOC,
    HEAP_VALIDATE_ON_FREE
} HEAP_VALIDATE_TYPE;

//
// DEBUG_MEMORY_HEADER - keeps debug memory on list
//

typedef struct {
    LIST_ENTRY List;
    DWORD ThreadId;
    LPSTR CreatedFile;
    DWORD CreatedLine;
    LPSTR AccessedFile;
    DWORD AccessedLine;
    SIZE_T RequestedLength;
    SIZE_T BlockLength;
    SIZE_T ActualLength;
    DWORD Signature;
    DWORD Flags;
    DWORD TimeDeferred;
    LONG ClashTest;
    MEMORY_ACTION LastAccessOperation;
#if DUMP_STACK
#if ONE_STACK
    LPVOID Stack[8];    // should be variable
#else
    LPVOID CreateStack[4];
    LPVOID LastAccessStack[4];
#endif // ONE_STACK
#endif // DUMP_STACK
    DWORD Guard[2];

    //
    // sizeof(MEMORY_SIGNATURE) currently 24 DWORDs in Win32
    //

} DEBUG_MEMORY_HEADER, *LPDEBUG_MEMORY_HEADER;

//
// DEBUG_MEMORY_FOOTER - used to check for overwrites
//

typedef struct {
    DWORD Guard[4];
    DWORD Signature;
    SIZE_T BlockLength;  // should be the same as the header
    DWORD Guard2[2];

    //
    // sizeof(DEBUG_MEMORY_FOOTER) currently 8 DWORDs in Win32
    //

} DEBUG_MEMORY_FOOTER, *LPDEBUG_MEMORY_FOOTER;

//
// private data
//

PRIVATE BOOL MemoryPackageInitialized = FALSE;

//
// InternetDebugMemFlags - bitfield of flags controlling debug memory usage.
// The default is no debug alloc (don't create header + footers) and to use
// LocalAlloc() etc.
//

//
// BUGBUG - I'm making an assumption that the compiler thinks the bits have the
//          same values as I think they have. If not, it could mess up the
//          registry/environment flags
//

PRIVATE struct {                                            // default value
    DWORD bNoDebugAlloc             : 1;    //  0x00000001          TRUE
    DWORD bUseLocalAlloc            : 1;    //  0x00000002          TRUE
    DWORD bUseSymbols               : 1;    //  0x00000004          FALSE
    DWORD bAssertOnMemoryErrors     : 1;    //  0x00000008          FALSE
    DWORD bFillMemoryOnAlloc        : 1;    //  0x00000010          FALSE
    DWORD bFillMemoryOnFree         : 1;    //  0x00000020          FALSE
    DWORD bReportMemoryUsage        : 1;    //  0x00000040          FALSE
    DWORD bReportUnfreedBlocks      : 1;    //  0x00000080          FALSE
    DWORD bReportMemoryFooters      : 1;    //  0x00000100          FALSE
    DWORD bReportUserData           : 1;    //  0x00000200          FALSE
    DWORD bStopDumpIfBadBlock       : 1;    //  0x00000400          FALSE
    DWORD bLimitUnfreedBlocks       : 1;    //  0x00000800          FALSE
    DWORD bLimitUserData            : 1;    //  0x00001000          FALSE
    DWORD bDumpAsDwords             : 1;    //  0x00002000          FALSE
    DWORD bHeapNoSerialize          : 1;    //  0x00004000          FALSE
    DWORD bHeapGenerateExceptions   : 1;    //  0x00008000          FALSE
    DWORD bHeapIsGrowable           : 1;    //  0x00010000          FALSE
    DWORD bDeferFree                : 1;    //  0x00020000          FALSE
    DWORD bDumpToFile               : 1;    //  0x00040000          FALSE
} InternetDebugMemFlags = {
    TRUE,   // no debug alloc
    TRUE,   // use LocalAlloc()
    FALSE,  // don't load debug symbols
    FALSE,  // don't assert on memory errors
    FALSE,  // don't fill memory on alloc
    FALSE,  // don't fill memory on free
    FALSE,  // don't report memory usage (stats)
    FALSE,  // don't report unfreed blocks
    FALSE,  // don't report memory footers (irrelevant)
    FALSE,  // don't report user data (irrelevant)
    FALSE,  // don't stop dump if bad block (irrelevant)
    FALSE,  // don't limit dump of unfreed blocks (irrelevant)
    FALSE,  // don't limit dump of user data (irrelevant)
    FALSE,  // don't dump user data as DWORDs (irrelevant)
    FALSE,  // serialize access to heap (irrelevant)
    FALSE,  // don't generate heap exceptions (irrelevant)
    TRUE,   // heap is growable (irrelevant)
    FALSE,  // don't defer frees
    FALSE   // don't dump to WinHttp log file
};

//
// defines to make using InternetDebugMemFlags easier
//

#define bNoDebugAlloc           InternetDebugMemFlags.bNoDebugAlloc
#define bUseLocalAlloc          InternetDebugMemFlags.bUseLocalAlloc
#define bUseSymbols             InternetDebugMemFlags.bUseSymbols
#define bAssertOnMemoryErrors   InternetDebugMemFlags.bAssertOnMemoryErrors
#define bFillMemoryOnAlloc      InternetDebugMemFlags.bFillMemoryOnAlloc
#define bFillMemoryOnFree       InternetDebugMemFlags.bFillMemoryOnFree
#define bReportMemoryUsage      InternetDebugMemFlags.bReportMemoryUsage
#define bReportUnfreedBlocks    InternetDebugMemFlags.bReportUnfreedBlocks
#define bReportMemoryFooters    InternetDebugMemFlags.bReportMemoryFooters
#define bReportUserData         InternetDebugMemFlags.bReportUserData
#define bStopDumpIfBadBlock     InternetDebugMemFlags.bStopDumpIfBadBlock
#define bLimitUnfreedBlocks     InternetDebugMemFlags.bLimitUnfreedBlocks
#define bLimitUserData          InternetDebugMemFlags.bLimitUserData
#define bDumpAsDwords           InternetDebugMemFlags.bDumpAsDwords
#define bHeapNoSerialize        InternetDebugMemFlags.bHeapNoSerialize
#define bHeapGenerateExceptions InternetDebugMemFlags.bHeapGenerateExceptions
#define bHeapIsGrowable         InternetDebugMemFlags.bHeapIsGrowable
#define bDeferFree              InternetDebugMemFlags.bDeferFree
#define bDumpToFile             InternetDebugMemFlags.bDumpToFile

PRIVATE DWORD MaxBlocksDumped = DEFAULT_MAX_BLOCKS_DUMPED;
PRIVATE DWORD MaxUserDataDumped = DEFAULT_MAX_DATA_DUMPED;
PRIVATE DWORD StackBacktraceDepth = DEFAULT_BACKTRACE_DEPTH;

//
// heap variables
//

PRIVATE HANDLE hDebugHeap = NULL;
PRIVATE DWORD InitialHeapSize = DEFAULT_INITIAL_HEAP_SIZE;
PRIVATE DWORD MaximumHeapSize = DEFAULT_MAXIMUM_HEAP_SIZE;
PRIVATE HEAP_COMPACT_TYPE HeapCompactControl = HEAP_COMPACT_NEVER;
PRIVATE HEAP_VALIDATE_TYPE HeapValidateControl = HEAP_VALIDATE_NEVER;

//
// debug mem signatures etc.
//

PRIVATE DWORD AllocAlignment = DEFAULT_ALLOC_ALIGNMENT;
PRIVATE DWORD HeaderGuardSize = DEFAULT_HEADER_GUARD_SIZE;
PRIVATE DWORD FooterGuardSize = DEFAULT_FOOTER_GUARD_SIZE;
PRIVATE DWORD AllocMemoryFiller = DWORD_ALLOC_FILL;
PRIVATE DWORD FreeMemoryFiller = DWORD_FREE_FILL;

//
// usage variables - access using some sort of lock (critsec/interlocked)
//

PRIVATE CRITICAL_SECTION MemoryVarsCritSec;
PRIVATE SIZE_T TotalActualMemoryAllocated = 0;  // cumulative
PRIVATE SIZE_T TotalBlockMemoryAllocated = 0;    //     "
PRIVATE SIZE_T TotalRealMemoryAllocated = 0;    //     "
PRIVATE SIZE_T TotalActualMemoryFreed = 0;      //     "
PRIVATE SIZE_T TotalBlockMemoryFreed = 0;        //     "
PRIVATE SIZE_T TotalRealMemoryFreed = 0;         //     "
PRIVATE SIZE_T ActualMemoryAllocated = 0;        // difference
PRIVATE SIZE_T BlockLengthAllocated = 0;         //     "
PRIVATE SIZE_T RealLengthAllocated = 0;          //     "
PRIVATE DWORD MemoryAllocations = 0;            // cumulative
PRIVATE DWORD GoodMemoryAllocations = 0;        //     "
PRIVATE DWORD MemoryReAllocations = 0;          //     "
PRIVATE DWORD GoodMemoryReAllocations = 0;      //     "
PRIVATE DWORD MemoryFrees = 0;                  //     "
PRIVATE DWORD GoodMemoryFrees = 0;              //     "
PRIVATE SIZE_T LargestBlockRequested = 0;
PRIVATE SIZE_T LargestBlockAllocated = 0;
PRIVATE LPSTR LargestBlockRequestedFile = NULL;
PRIVATE DWORD LargestBlockRequestedLine = 0;
PRIVATE SIZE_T SmallestBlockRequested = (SIZE_T)-1;
PRIVATE SIZE_T SmallestBlockAllocated = (SIZE_T)-1;
PRIVATE LPSTR SmallestBlockRequestedFile = NULL;
PRIVATE DWORD SmallestBlockRequestedLine = 0;
PRIVATE DWORD DeferFreeTime = 0;

//
// lists
//

PRIVATE SERIALIZED_LIST AllocatedBlockList;
PRIVATE SERIALIZED_LIST DeferredFreeList;

//
// macros
//

#define MEMORY_ASSERT(x) \
    if (bAssertOnMemoryErrors) { \
        INET_ASSERT(x); \
    } else { \
        /* NOTHING */ \
    }

//
// private prototypes
//

PRIVATE
VOID
DebugFillMem(
    IN LPVOID Pointer,
    IN SIZE_T Size,
    IN DWORD dwFiller
    );

PRIVATE
HLOCAL
InternetAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    );

PRIVATE
HLOCAL
InternetFree(
    IN HLOCAL hLocal
    );

PRIVATE
HLOCAL
InternetReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    );

PRIVATE
SIZE_T
InternetSize(
    IN HLOCAL hLocal
    );

PRIVATE
HLOCAL
InternetHeapAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    );

PRIVATE
HLOCAL
InternetHeapReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    );

PRIVATE
HLOCAL
InternetHeapFree(
    IN HLOCAL hLocal
    );

PRIVATE
SIZE_T
InternetHeapSize(
    IN HLOCAL hLocal
    );

PRIVATE
BOOL
InternetDebugCheckMemBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
VOID
InternetDebugMemTest(
    VOID
    );

PRIVATE
VOID
ReportMemoryUsage(
    VOID
    );

PRIVATE
VOID
ReportMemoryBlocks(
    VOID
    );

PRIVATE
VOID
DumpDeferredFreeList(
    VOID
    );

PRIVATE
VOID
DumpMemoryList(
    IN LPSERIALIZED_LIST lpList
    );

PRIVATE
VOID
FindAndDumpDeferredBlock(
    IN HLOCAL hLocal
    );

PRIVATE
BOOL
DumpBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
BOOL
DumpDebugMemoryHeader(
    LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
BOOL
DumpDebugMemoryFooter(
    LPDEBUG_MEMORY_FOOTER lpFooter
    );

PRIVATE
VOID
DumpUserData(
    LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
LPSTR
MapLastAccessOperation(
    MEMORY_ACTION Action
    );

PRIVATE
LPSTR
MapMemoryFlags(
    DWORD Flags,
    LPSTR Buffer
    );

PRIVATE
LPSTR
DbgMemGetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    );

//
// functions
//


VOID
InternetDebugMemInitialize(
    VOID
    )

/*++

Routine Description:

    Initializes debug memory allocator

Arguments:

    None.

Return Value:

    None.

--*/

{
    BOOL init;

    init = (BOOL)InterlockedExchange((LPLONG)&MemoryPackageInitialized, TRUE);
    if (init) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("Memory package already initialized\n"
                    ));

        DEBUG_BREAK(MEMALLOC);

        return;
    }

    InitializeSerializedList(&AllocatedBlockList);
    InitializeSerializedList(&DeferredFreeList);
    InitializeCriticalSection(&MemoryVarsCritSec);

    //
    // sleaze: disable any debug output until we finish this. Debug log
    // routines want to allocate memory(!). InternetReadRegistryDword()
    // (called from InternetGetDebugVariable()) wants to perform DEBUG_ENTER
    // etc.
    //

    DWORD debugControlFlags = InternetDebugControlFlags;

    InternetDebugControlFlags = DBG_NO_DEBUG;

    //
    // if "WinHttpMem" is set then we set up to use debug memory - we use our
    // own heap, full debugging & reporting etc. (basically max memory debugging
    // as defined by me)
    //

    DWORD useDefaultDebugMemoryFlags = FALSE;

    InternetGetDebugVariable("WinHttpMem",
                             &useDefaultDebugMemoryFlags
                             );
    if (useDefaultDebugMemoryFlags) {
        bNoDebugAlloc = FALSE;          // use full debug allocator (header + footers, etc.)
        bUseLocalAlloc = FALSE;         // use our own heap
        bUseSymbols = FALSE;            // don't load debug symbols
        bAssertOnMemoryErrors = TRUE;   // assert to debugger/log if memory errors
        bFillMemoryOnAlloc = TRUE;      // fill user data w/ signature if not zeroinit
        bFillMemoryOnFree = TRUE;       // fill freed memory (useful on Win95/non-debug on NT)
        bReportMemoryUsage = TRUE;      // dump memory usage stats
        bReportUnfreedBlocks = TRUE;    // dump unfreed blocks (headers)
        bReportMemoryFooters = TRUE;    // dump unfreed block footers
        bReportUserData = TRUE;         // dump unfreed block user data
        bStopDumpIfBadBlock = TRUE;     // stop dumping if error occurs
        bLimitUnfreedBlocks = TRUE;     // limit block dump in case of loop in list
        bLimitUserData = TRUE;          // limit user data dump in case of bad length
        bDumpAsDwords = TRUE;           // dump data in dc format vs. db
        bHeapNoSerialize = FALSE;       // heap functions are serialized
        bHeapGenerateExceptions = FALSE;// heap functions return errors
        bHeapIsGrowable = FALSE;        // limit heap to maximum size (1 Meg)
        if (useDefaultDebugMemoryFlags == 2) {
            bDumpToFile = TRUE;
        }
    } else {

        //
        // no use-debug-mem override, see if there are any specific flags set
        //

        InternetGetDebugVariable("WinHttpDebugMemFlags",
                                 (LPDWORD)&InternetDebugMemFlags
                                 );
    }

    //
    // we used to load IMAGEHLP.DLL here and not use its functions until we were
    // dumping still in-use memory during DLL shutdown. Problem is that the
    // system has probably already freed IMAGEHLP.DLL by the time we come to use
    // it, resulting in GPF, so now we only load it at the time we're about to
    // use it
    //

    //if (bUseSymbols) {
    //    InitSymLib();
    //}

    if (!bUseLocalAlloc) {

        //
        // not using LocalAlloc(), using HeapAlloc(). Create heap
        //

        InitialHeapSize = DEFAULT_INITIAL_HEAP_SIZE;
        InternetGetDebugVariable("WinHttpDebugHeapInitialSize",
                                 &InitialHeapSize
                                 );

        MaximumHeapSize = DEFAULT_MAXIMUM_HEAP_SIZE;
        InternetGetDebugVariable("WinHttpDebugHeapMaximumSize",
                                 &MaximumHeapSize
                                 );

        if (bHeapIsGrowable) {
            MaximumHeapSize = 0;
        }

        hDebugHeap = HeapCreate((bHeapGenerateExceptions
                                    ? HEAP_GENERATE_EXCEPTIONS
                                    : 0)
                                | (bHeapNoSerialize
                                    ? HEAP_NO_SERIALIZE
                                    : 0),
                                InitialHeapSize,
                                MaximumHeapSize
                                );
        if (hDebugHeap == NULL) {

            DEBUG_PUT(("HeapCreate() failed - %d\n",
                        GetLastError()
                        ));

            bUseLocalAlloc = TRUE;
        } else {
            HeapCompactControl = HEAP_COMPACT_NEVER;
            InternetGetDebugVariable("WinHttpDebugHeapCompactControl",
                                     (LPDWORD)&HeapCompactControl
                                     );

            HeapValidateControl = HEAP_VALIDATE_NEVER;
            InternetGetDebugVariable("WinHttpDebugHeapValidateControl",
                                     (LPDWORD)&HeapValidateControl
                                     );

            DEBUG_PUT(("WinHttp heap = %#x\n",
                        hDebugHeap
                        ));

        }
    }

    //
    // restore default debug flags
    //

    InternetDebugControlFlags = debugControlFlags;

    //InternetDebugMemTest();
}


VOID
InternetDebugMemTerminate(
    IN BOOL bReport
    )

/*++

Routine Description:

    Frees resources allocated in InternetDebugMemInitialize, after checking that
    all memory is freed

Arguments:

    bReport - TRUE if in-use blocks reported at termination

Return Value:

    None.

--*/

{
    BOOL bOpened = bReport ? InternetDebugMemReport(TRUE, FALSE) : FALSE;

    InternetDebugCheckMemFreed(FALSE);
    DeleteCriticalSection(&MemoryVarsCritSec);
    TerminateSerializedList(&AllocatedBlockList);
    TerminateSerializedList(&DeferredFreeList);

    if (hDebugHeap != NULL) {

        //
        // any future allocations(!) must use process heap
        //

        bUseLocalAlloc = TRUE;

        if (!HeapDestroy(hDebugHeap)) {

            DWORD error = GetLastError();

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("HeapDestroy(%#x) returns %s (%d)\n",
                        hDebugHeap,
                        InternetMapError(error),
                        error
                        ));

            MEMORY_ASSERT(FALSE);

        }
    }
    if (bOpened) {
        InternetCloseDebugFile();
    }
    MemoryPackageInitialized = FALSE;
}


HLOCAL
InternetDebugAllocMem(
    IN UINT Flags,
    IN UINT Size,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Debug memory allocator. If this succeeds, then the real block is put on our
    list and has its head & tail (& possibly contents) initialized. The caller
    gets an pointer which is an offset to the user area in the block

Arguments:

    Flags   - controlling flags (normally passed to LocalAlloc)

    Size    - of block to allocate

    File    - from where alloc called

    Line    - in File

Return Value:

    HLOCAL
        Success - pointer to caller's start of allocated block

        Failure - NULL

--*/

{
    if (!MemoryPackageInitialized) {
        return NULL;
    }

//dprintf("InternetDebugAllocMem(%#x, %d) = ", Flags, Size);
    InterlockedIncrement((LPLONG)&MemoryAllocations);

    //
    // keep these tests separate so we don't have to look up the flags #defines
    //

    INET_ASSERT(!(Flags & LMEM_MOVEABLE));
    INET_ASSERT(!(Flags & LMEM_DISCARDABLE));

    if (Size == 0) {

        DEBUG_PRINT(MEMALLOC,
                    WARNING,
                    ("InternetDebugAllocMem(%#x, %d)\n",
                    Flags,
                    Size
                    ));

        MEMORY_ASSERT(FALSE);

    }

    SIZE_T blockLength;

    if (bNoDebugAlloc) {
        blockLength = Size;
    } else {
        if (Size > LargestBlockRequested) {
            LargestBlockRequested = Size;
            LargestBlockRequestedFile = File;
            LargestBlockRequestedLine = Line;
        } else if (Size < SmallestBlockRequested) {
            SmallestBlockRequested = Size;
            SmallestBlockRequestedFile = File;
            SmallestBlockRequestedLine = Line;
        }
        blockLength = ROUND_UP_DWORD(Size)
                    + sizeof(DEBUG_MEMORY_HEADER)
                    + sizeof(DEBUG_MEMORY_FOOTER);
    }

    //
    // possible problem: if Size + signatures would overflow UINT. Only really
    // problematic on 16-bit platforms
    //

    if (blockLength < Size) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("can't allocate %lu bytes: would overflow\n",
                    (DWORD)Size
                    ));

        DEBUG_BREAK(MEMALLOC);

//dprintf("NULL\n");
        return NULL;
    }

    //
    // BUGBUG - allocating 0 bytes?
    //

    HLOCAL hLocal = InternetAlloc(Flags, blockLength);

    if (hLocal != NULL) {
        InterlockedIncrement((LPLONG)&GoodMemoryAllocations);
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to allocate %u bytes memory\n",
                    blockLength
                    ));

        DEBUG_BREAK(MEMALLOC);

//dprintf("NULL\n");
        return NULL;
    }

    SIZE_T actualLength = InternetSize(hLocal);
    SIZE_T requestedLength;

    if (bNoDebugAlloc) {
        blockLength = actualLength;
        requestedLength = actualLength;
    } else {
        requestedLength = Size;
        if (actualLength > LargestBlockAllocated) {
            LargestBlockAllocated = actualLength;
        } else if (actualLength < SmallestBlockAllocated) {
            SmallestBlockAllocated = actualLength;
        }
    }

    EnterCriticalSection(&MemoryVarsCritSec);
    TotalActualMemoryAllocated += actualLength;
    TotalBlockMemoryAllocated += blockLength;
    TotalRealMemoryAllocated += requestedLength;
    ActualMemoryAllocated += actualLength;
    BlockLengthAllocated += blockLength;
    RealLengthAllocated += requestedLength;
    LeaveCriticalSection(&MemoryVarsCritSec);

    if (bNoDebugAlloc || (hLocal == NULL)) {
        if ((hLocal != NULL) && !(Flags & LMEM_ZEROINIT) && bFillMemoryOnAlloc) {
            DebugFillMem(hLocal, Size, AllocMemoryFiller);
        }
//dprintf("%#x\n", hLocal);
        return hLocal;
    }

    LPDEBUG_MEMORY_HEADER lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;

    //InitializeListHead(&lpHeader->List);
    lpHeader->ThreadId = GetCurrentThreadId();
    lpHeader->CreatedFile = File;
    lpHeader->CreatedLine = Line;
    lpHeader->AccessedFile = File;
    lpHeader->AccessedLine = Line;
    lpHeader->RequestedLength = Size;
    lpHeader->BlockLength = blockLength;
    lpHeader->ActualLength = actualLength;
    lpHeader->Signature = HEADER_SIGNATURE;
    lpHeader->Flags = Flags;
    lpHeader->TimeDeferred = 0;
    lpHeader->ClashTest = -1;
    lpHeader->LastAccessOperation = MemAllocate;

#if DUMP_STACK
#if ONE_STACK

    memset(lpHeader->Stack, 0, sizeof(lpHeader->Stack));
    GET_CALL_STACK(lpHeader->Stack);

#else

    GET_CALLERS_ADDRESS(&lpHeader->CreateStack[0],
                        &lpHeader->CreateStack[1]
                        );

    memset(lpHeader->CreateStack, 0, sizeof(lpHeader->CreateStack));

    GET_CALL_STACK(lpHeader->CreateStack);

    memcpy(lpHeader->LastAccessStack,
           lpHeader->CreateStack,
           sizeof(lpHeader->LastAccessStack)
           );

#endif // ONE_STACK
#endif // DUMP_STACK

    UINT i;

    for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
        lpHeader->Guard[i] = GUARD_DWORD_FILL;
    }

    //
    // BUGBUG - should be using AllocAlignment - could be > sizeof(DWORD)
    //

    if (!(Flags & LMEM_ZEROINIT) && bFillMemoryOnAlloc) {
        DebugFillMem(lpHeader + 1, Size, AllocMemoryFiller);
    }

    UINT bFillLength2 = (Size % sizeof(DWORD)) ? (sizeof(DWORD) - (Size % sizeof(DWORD))) : 0;
    LPBYTE lpbUserPointer = (LPBYTE)(lpHeader + 1) + Size;

    for (i = 0; i < bFillLength2; ++i) {
        *lpbUserPointer++ = BYTE_ALLOC_FILL_EXTRA;
    }

    LPDEBUG_MEMORY_FOOTER lpFooter = (LPDEBUG_MEMORY_FOOTER)lpbUserPointer;

    for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
        lpFooter->Guard[i] = GUARD_DWORD_FILL;
    }

    lpFooter->BlockLength = blockLength;
    lpFooter->Signature = FOOTER_SIGNATURE;

    for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
        lpFooter->Guard2[i] = GUARD_DWORD_FILL;
    }

    if (!CheckEntryOnSerializedList(&AllocatedBlockList, &lpHeader->List, FALSE)) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugAllocMem(%d): %#x already on list?\n",
                    Size,
                    lpHeader
                    ));

        MEMORY_ASSERT(FALSE);

    }

    //
    // put at the tail of list so we can view unfreed blocks in chronological
    // order
    //

    if (!InsertAtTailOfSerializedList(&AllocatedBlockList, &lpHeader->List))
    {
        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugAllocMem(%d): %#x couldn't be appended to unfreed list\n",
                    Size,
                    lpHeader
                    ));

        MEMORY_ASSERT(FALSE);
    }

//dprintf("%#x\n", lpHeader + 1);
    return (HLOCAL)(lpHeader + 1);
}


HLOCAL
InternetDebugFreeMem(
    IN HLOCAL hLocal,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Frees a block of memory allocated by InternetDebugAllocMem(). Checks that
    the block is on our allocated block list, and that the header and footer
    areas are still intact

Arguments:

    hLocal  - handle (pointer) of block to free

    File    - from where alloc called

    Line    - in File

Return Value:

    HLOCAL
        Success - NULL

        Failure - hLocal

--*/

{
    UNREFERENCED_PARAMETER(File);
    UNREFERENCED_PARAMETER(Line);
    if (!MemoryPackageInitialized) {
        return NULL;
    }

//dprintf("InternetDebugFreeMem(%#x)\n", hLocal);
    InterlockedIncrement((LPLONG)&MemoryFrees);

    if (hLocal == NULL) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugFreeMem(NULL)\n"
                    ));

        MEMORY_ASSERT(FALSE);

        return InternetFree(hLocal);
    }

    HLOCAL hLocalOriginal = hLocal;
    SIZE_T actualLength;
    SIZE_T blockLength;
    SIZE_T realLength;

    if (bNoDebugAlloc) {
        actualLength = InternetSize(hLocal);
        blockLength = actualLength;
        realLength = actualLength;
    } else {
        hLocal = (HLOCAL)((LPDEBUG_MEMORY_HEADER)hLocal - 1);
        actualLength = InternetSize(hLocal);
        blockLength = actualLength;
        realLength = actualLength;

        LPDEBUG_MEMORY_HEADER lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;

        if (CheckEntryOnSerializedList(&AllocatedBlockList, &lpHeader->List, TRUE) &&
            RemoveFromSerializedList(&AllocatedBlockList, &lpHeader->List)) {

            if (!((lpHeader->ActualLength == actualLength)
            && (lpHeader->BlockLength <= actualLength)
            && !(lpHeader->BlockLength & (sizeof(DWORD) - 1))
            && (lpHeader->RequestedLength < lpHeader->BlockLength))) {

                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("InternetDebugFreeMem(%#x): block lengths mismatch\n",
                            hLocalOriginal
                            ));

                MEMORY_ASSERT(FALSE);
            }
            if (InternetDebugCheckMemBlock(lpHeader)) {
                blockLength = lpHeader->BlockLength;
                realLength = lpHeader->RequestedLength;
            } else {
                blockLength = 0;
                realLength = 0;
            }
            if (bDeferFree) {

#if DUMP_STACK
#if ONE_STACK

                memset(lpHeader->Stack, 0, sizeof(lpHeader->Stack));
                GET_CALL_STACK(lpHeader->Stack);

#else

                GET_CALLERS_ADDRESS(&lpHeader->CreateStack[0],
                                    &lpHeader->CreateStack[1]
                                    );

                memset(lpHeader->CreateStack, 0, sizeof(lpHeader->CreateStack));

                GET_CALL_STACK(lpHeader->CreateStack);

                memcpy(lpHeader->LastAccessStack,
                       lpHeader->CreateStack,
                       sizeof(lpHeader->LastAccessStack)
                       );

#endif // ONE_STACK
#endif // DUMP_STACK

                if (!InsertAtTailOfSerializedList(&DeferredFreeList, &lpHeader->List))
                {
                    DEBUG_PRINT(MEMALLOC,
                                ERROR,
                                ("InternetDebugFreeMem(%#x): couldn't add to deferred free list %#x\n",
                                hLocalOriginal,
                                &lpHeader->List
                                ));

                    MEMORY_ASSERT(FALSE);
                }
                hLocal = NULL;
            }
        } else {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("InternetDebugFreeMem(%#x): can't find %#x or couldn't free from list\n",
                        hLocalOriginal,
                        &lpHeader->List
                        ));

            MEMORY_ASSERT(FALSE);

            FindAndDumpDeferredBlock(hLocal);
        }
    }

    if (hLocal && bFillMemoryOnFree) {
        DebugFillMem(hLocal, actualLength, FreeMemoryFiller);
    }

    hLocal = InternetFree(hLocal);

    if (hLocal == NULL) {
        InterlockedIncrement((LPLONG)&GoodMemoryFrees);
        EnterCriticalSection(&MemoryVarsCritSec);
        TotalActualMemoryFreed += actualLength;
        TotalBlockMemoryFreed += blockLength;
        TotalRealMemoryFreed += realLength;
        ActualMemoryAllocated -= actualLength;
        BlockLengthAllocated -= blockLength;
        RealLengthAllocated -= realLength;
        LeaveCriticalSection(&MemoryVarsCritSec);
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugFreeMem(%#x) failed\n",
                    hLocalOriginal
                    ));

        MEMORY_ASSERT(FALSE);

        hLocal = hLocalOriginal;
    }

    return hLocal;
}


HLOCAL
InternetDebugReAllocMem(
    IN HLOCAL hLocal,
    IN UINT Size,
    IN UINT Flags,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Reallocates a debug memory block allocated by InternetDebugAllocMem()

Arguments:

    hLocal  - the handle (pointer) of the allocated block

    Size    - requested size of new block; can be larger or smaller than current
              size

    Flags   - controlling flags (normally passed to LocalReAlloc)

    File    - from where alloc called

    Line    - in File

Return Value:

    HLOCAL
        Success - pointer to new block. May be same or different than previous
                  pointer, depending on flags

        Failure - NULL

--*/

{
    if (!MemoryPackageInitialized) {
        return NULL;
    }

//dprintf("InternetDebugReAllocMem(%#x, %d, %#x)\n", hLocal, Size, Flags);
    InterlockedIncrement((LPLONG)&MemoryReAllocations);

    //
    // we can't handle the following flags
    //

    INET_ASSERT(!(Flags & LMEM_MODIFY));

    //
    // can't handle reallocating down to zero
    //

    if (Size == 0) {

        MEMORY_ASSERT(FALSE);

    }

    HLOCAL hLocalOriginal = hLocal;
    LPDEBUG_MEMORY_HEADER lpHeader;
    SIZE_T actualLength;
    SIZE_T blockLength;
    SIZE_T requestedLength;
    SIZE_T oldRequestedLength;

    if (bNoDebugAlloc) {
        actualLength = InternetSize(hLocal);
        blockLength = actualLength;
        requestedLength = actualLength;
        oldRequestedLength = requestedLength;
    } else {
        if (Size > LargestBlockRequested) {
            LargestBlockRequested = Size;
            LargestBlockRequestedFile = File;
            LargestBlockRequestedLine = Line;
        } else if (Size < SmallestBlockRequested) {
            SmallestBlockRequested = Size;
            SmallestBlockRequestedFile = File;
            SmallestBlockRequestedLine = Line;
        }
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;
        hLocal = (HLOCAL)lpHeader;
        if (!CheckEntryOnSerializedList(&AllocatedBlockList, &lpHeader->List, TRUE) ||
             RemoveFromSerializedList(&AllocatedBlockList, &lpHeader->List)) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("InternetDebugReAllocMem(%#x): can't find %#x or couldn't remove from list\n",
                        hLocalOriginal
                        ));

            MEMORY_ASSERT(FALSE);

            return hLocalOriginal;
        }
        InternetDebugCheckMemBlock(lpHeader);
        actualLength = InternetSize((HLOCAL)lpHeader);
        blockLength = lpHeader->BlockLength;
        requestedLength = lpHeader->RequestedLength;
        oldRequestedLength = requestedLength;
        if (!((lpHeader->ActualLength == actualLength)
        && (lpHeader->BlockLength <= actualLength)
        && !(lpHeader->BlockLength & (sizeof(DWORD) - 1))
        && (lpHeader->RequestedLength < lpHeader->BlockLength))) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("InternetDebugReAllocMem(%#x): block lengths mismatch\n",
                        hLocalOriginal
                        ));

            MEMORY_ASSERT(FALSE);
        }
    }
    EnterCriticalSection(&MemoryVarsCritSec);
    ActualMemoryAllocated -= actualLength;
    BlockLengthAllocated -= blockLength;
    RealLengthAllocated -= requestedLength;
    LeaveCriticalSection(&MemoryVarsCritSec);
    requestedLength = Size;
    if (bNoDebugAlloc) {
        blockLength = Size;
    } else {
        blockLength = ROUND_UP_DWORD(Size)
                    + sizeof(DEBUG_MEMORY_HEADER)
                    + sizeof(DEBUG_MEMORY_FOOTER);
    }
    hLocal = InternetReAlloc(hLocal, blockLength, Flags);
    if (hLocal != NULL) {
        InterlockedIncrement((LPLONG)&GoodMemoryReAllocations);
        actualLength = InternetSize(hLocal);
        if (bNoDebugAlloc) {
            blockLength = actualLength;
        } else {
            lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;
            //InitializeListHead(&lpHeader->List);
            lpHeader->ThreadId = GetCurrentThreadId();
            lpHeader->AccessedFile = File;
            lpHeader->AccessedLine = Line;
            lpHeader->RequestedLength = requestedLength;
            lpHeader->BlockLength = blockLength;
            lpHeader->ActualLength = actualLength;
            lpHeader->Flags = Flags;
            lpHeader->TimeDeferred = 0;
            lpHeader->ClashTest = -1;
            lpHeader->LastAccessOperation = MemReallocate;

#if DUMP_STACK
#if ONE_STACK
#else

            //GET_CALLERS_ADDRESS(&lpHeader->LastAccessStack[0],
            //                    &lpHeader->LastAccessStack[1]
            //                    );

            memset(lpHeader->LastAccessStack, 0, sizeof(lpHeader->LastAccessStack));

            GET_CALL_STACK(lpHeader->LastAccessStack);

#endif // ONE_STACK
#endif // DUMP_STACK

            LPBYTE extraPointer;
            UINT i;

            if ((requestedLength > oldRequestedLength)
            && bFillMemoryOnAlloc && !(Flags & LMEM_ZEROINIT)) {

                extraPointer = (LPBYTE)(lpHeader + 1) + oldRequestedLength;

                SIZE_T difference = requestedLength - oldRequestedLength;
                DWORD dwFiller = AllocMemoryFiller;
                SIZE_T syncLength = oldRequestedLength & (sizeof(DWORD) - 1);

                if (syncLength) {
                    syncLength = sizeof(DWORD) - syncLength;
                    syncLength = min(syncLength, difference);
                    difference -= syncLength;
                    for (i = 0; i < syncLength; ++i) {
                        *extraPointer++ = ((LPBYTE)&dwFiller)[i];
                    }
                }

                //dwFillLength = difference / sizeof(DWORD);
                //difference %= sizeof(DWORD);
                //while (dwFillLength--) {
                //    *(LPDWORD)extraPointer = 0;
                //    extraPointer += sizeof(DWORD);
                //}
                //while (difference--) {
                //    *extraPointer++ = 0;
                //}

                if (difference) {
                    DebugFillMem(extraPointer, difference, dwFiller);
                    extraPointer += difference;
                }
            } else {
                extraPointer = (LPBYTE)(lpHeader + 1) + requestedLength;
            }

            SIZE_T bFillLength = (sizeof(DWORD) - (requestedLength % sizeof(DWORD))) & (sizeof(DWORD) - 1);

            while (bFillLength--) {
                *extraPointer++ = BYTE_ALLOC_FILL_EXTRA;
            }

            LPDEBUG_MEMORY_FOOTER lpFooter = (LPDEBUG_MEMORY_FOOTER)extraPointer;

            INET_ASSERT(lpFooter == (LPDEBUG_MEMORY_FOOTER)
                ((LPBYTE)(lpHeader + 1) + ROUND_UP_DWORD(requestedLength)));

            for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
                lpFooter->Guard[i] = GUARD_DWORD_FILL;
            }
            lpFooter->Signature = FOOTER_SIGNATURE;
            lpFooter->BlockLength = blockLength;
            for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
                lpFooter->Guard2[i] = GUARD_DWORD_FILL;
            }
            if (!InsertAtTailOfSerializedList(&AllocatedBlockList, &lpHeader->List)) {
                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("failed to append to allocated block list.\n"
                            ));

                DEBUG_BREAK(MEMALLOC);
            }
            hLocal = (HLOCAL)(lpHeader + 1);
        }
        EnterCriticalSection(&MemoryVarsCritSec);
        ActualMemoryAllocated += actualLength;
        BlockLengthAllocated += blockLength;
        RealLengthAllocated += requestedLength;
        LeaveCriticalSection(&MemoryVarsCritSec);
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to reallocate %u bytes memory. Last error = %d\n",
                    Size,
                    GetLastError()
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
    return hLocal;
}


SIZE_T
InternetDebugSizeMem(
    IN HLOCAL hLocal,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Returns actual allocated block size

Arguments:

    hLocal  - pointer to allocated block

    File    - from where alloc called

    Line    - in File

Return Value:

    SIZE_T
        size of allocated block

--*/

{
    UNREFERENCED_PARAMETER(File);
    UNREFERENCED_PARAMETER(Line);
    if (!MemoryPackageInitialized) {
        return 0;
    }

//dprintf("InternetDebugSizeMem(%#x)\n", hLocal);
    SIZE_T size = InternetSize(hLocal);

    if (!bNoDebugAlloc) {

        LPDEBUG_MEMORY_HEADER lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;

        INET_ASSERT(lpHeader->Signature == HEADER_SIGNATURE);

        SIZE_T sizeInHeader = lpHeader->BlockLength
                          - (sizeof(DEBUG_MEMORY_HEADER) + sizeof(DEBUG_MEMORY_FOOTER));

        INET_ASSERT((sizeInHeader <= size)
                    && (size >= sizeof(DEBUG_MEMORY_HEADER) + sizeof(DEBUG_MEMORY_FOOTER))
                    && (lpHeader->ActualLength == size)
                    );

        size = sizeInHeader;
    }

    return size;
}


BOOL
InternetDebugCheckMemFreed(
    IN BOOL bReport
    )

/*++

Routine Description:

    Called when we're about to quit. Checks that all allocated memory has been
    cleaned up

Arguments:

    bReport - TRUE if in-use blocks reported

Return Value:

    BOOL
        TRUE    - all allocated memory freed

        FALSE   - we failed to clean up

--*/

{
    if (bReport) {
        if (bReportMemoryUsage) {
            ReportMemoryUsage();
        }
        if (bReportUnfreedBlocks) {
            ReportMemoryBlocks();
        }
    }
    if (ElementsOnSerializedList(&AllocatedBlockList) != 0) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugCheckMemFreed(): %d memory blocks still allocated\n",
                    MemoryAllocations - MemoryFrees
                    ));

        MEMORY_ASSERT(FALSE);

        return FALSE;
    }
    return TRUE;
}


BOOL
InternetDebugMemReport(
    IN BOOL bTerminateSymbols,
    IN BOOL bCloseFile
    )

/*++

Routine Description:

    Dumps in-use blocks to debugger and/or file

Arguments:

    bTerminateSymbols   - TRUE if we are to terminate symbols here

    bCloseFile          - TRUE if we are to close debug log file here

Return Value:

    BOOL    - TRUE if we opened debug log file

--*/

{
    BOOL bOpened = FALSE;

    if (bDumpToFile) {
        bOpened = InternetOpenDebugFile();
        if (bOpened) {
            InternetDebugResetControlFlags(DBG_NO_DEBUG);
            InternetDebugSetControlFlags(DBG_TO_FILE | DBG_NO_ASSERT_BREAK);
        }
    }
    ReportMemoryUsage();
    ReportMemoryBlocks();
    if (bUseSymbols && bTerminateSymbols) {
        TermSymLib();
    }
    if (bOpened && bCloseFile) {
        InternetCloseDebugFile();
    }
    return bOpened;
}

//
// private functions
//


PRIVATE
VOID
DebugFillMem(
    IN LPVOID Pointer,
    IN SIZE_T Size,
    IN DWORD dwFiller
    )

/*++

Routine Description:

    Fills memory with repeating debug pattern. Performs DWORD fill then finishes
    off any remaining bytes with character fill (rep movsd/rep movsb (ideally)
    (x86!))

Arguments:

    Pointer     - memory to fill

    Size        - of Pointer in bytes

    dwFiller    - DWORD value to use

Return Value:

    None.

--*/

{
    INET_ASSERT(((DWORD_PTR)Pointer & (sizeof(DWORD) - 1)) == 0);

    SIZE_T dwFillLength = Size / sizeof(DWORD);
    SIZE_T bFillLength = Size % sizeof(DWORD);

    //
    // assume > 0 DWORDs to fill
    //

    LPDWORD lpdwPointer = (LPDWORD)Pointer;
    SIZE_T i;

    for (i = 0; i < dwFillLength; ++i) {
        *lpdwPointer++ = dwFiller;
    }

    if (bFillLength) {

        LPBYTE lpbPointer = (LPBYTE)lpdwPointer;

        for (i = 0; i < bFillLength; ++i) {
            *lpbPointer++ = ((LPBYTE)&dwFiller)[i];
        }
    }
}


PRIVATE
HLOCAL
InternetAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    )

/*++

Routine Description:

    Allocator - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    Flags   - LocalAlloc flags

    Size    - of block to allocate

Return Value:

    HLOCAL
        Success - pointer to allocated block

        Failure - NULL

--*/

{
    if (bUseLocalAlloc) {
        return LocalAlloc(Flags, Size);
    } else {
        return InternetHeapAlloc(Flags, Size);
    }
}


PRIVATE
HLOCAL
InternetFree(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Deallocator - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    hLocal  - pointer to block to deallocate

Return Value:

    HLOCAL
        Success - NULL

        Failure - pointer to still allocated block

--*/

{
    if (bUseLocalAlloc) {
        return LocalFree(hLocal);
    } else {
        return InternetHeapFree(hLocal);
    }
}


PRIVATE
HLOCAL
InternetReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    )

/*++

Routine Description:

    Reallocator - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    hLocal  - pointer to block to reallocate

    Flags   - LocalAlloc flags

    Size    - of block to allocate

Return Value:

    HLOCAL
        Success - pointer to allocated block

        Failure - NULL

--*/

{
    if (bUseLocalAlloc) {
        return LocalReAlloc(hLocal, Size, Flags);
    } else {
        return InternetHeapReAlloc(hLocal, Size, Flags);
    }
}


PRIVATE
SIZE_T
InternetSize(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Block sizer - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    hLocal  - pointer to block to size

Return Value:

    SIZE_T
        Success - size of block

        Failure - 0

--*/

{
    if (bUseLocalAlloc) {
        return LocalSize(hLocal);
    } else {
        return InternetHeapSize(hLocal);
    }
}


PRIVATE
HLOCAL
InternetHeapAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    )

/*++

Routine Description:

    Allocate memory from debug heap

Arguments:

    Flags   - passed to LocalAlloc

    Size    - of block to allocate

Return Value:

    HLOCAL

--*/

{
    HLOCAL hLocal;

    if (hDebugHeap != NULL) {
        hLocal = (HLOCAL)HeapAlloc(hDebugHeap,
                                   (bHeapNoSerialize
                                        ? HEAP_NO_SERIALIZE
                                        : 0)
                                   | (bHeapGenerateExceptions
                                        ? HEAP_GENERATE_EXCEPTIONS
                                        : 0)
                                   | ((Flags & LMEM_ZEROINIT)
                                        ? HEAP_ZERO_MEMORY
                                        : 0),
                                   Size
                                   );
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapAlloc(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        hLocal = LocalAlloc(Flags, Size);
    }
    if (hLocal == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    return hLocal;
}


PRIVATE
HLOCAL
InternetHeapReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    )

/*++

Routine Description:

    Reallocate memory from debug heap

Arguments:

    hLocal  - pointer to block to reallocate

    Size    - new size

    Flags   - to LocalReAlloc

Return Value:

    HLOCAL
        Success - pointer to new block

        Failure - NULL

--*/

{
    if (hDebugHeap != NULL) {
        hLocal = (HLOCAL)HeapReAlloc(hDebugHeap,
                                     (bHeapNoSerialize
                                        ? HEAP_NO_SERIALIZE
                                        : 0)
                                     | (bHeapGenerateExceptions
                                        ? HEAP_GENERATE_EXCEPTIONS
                                        : 0)
                                     | ((Flags & LMEM_MOVEABLE)
                                        ? 0
                                        : HEAP_REALLOC_IN_PLACE_ONLY)
                                     | ((Flags & LMEM_ZEROINIT)
                                        ? HEAP_ZERO_MEMORY
                                        : 0),
                                     (LPVOID)hLocal,
                                     Size
                                     );
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapReAlloc(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        //
        // block still allocated
        //

        hLocal = NULL;
    }
    return hLocal;
}


PRIVATE
HLOCAL
InternetHeapFree(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Free memory to debug heap

Arguments:

    hLocal  - to free

Return Value:

    HLOCAL
        Success - NULL

        Failure - hLocal

--*/

{
    BOOL ok;

    if (hDebugHeap != NULL) {
        ok = HeapFree(hDebugHeap,
                      bHeapNoSerialize ? HEAP_NO_SERIALIZE : 0,
                      (LPVOID)hLocal
                      );
        if (!ok) {

            DWORD error = GetLastError();

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("HeapFree() returns %s (%d)\n",
                        InternetMapError(error),
                        error
                        ));

            MEMORY_ASSERT(FALSE);

        }
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapFree(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        ok = FALSE;
    }
    return ok ? NULL : hLocal;
}


PRIVATE
SIZE_T
InternetHeapSize(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Determines size of block allocated from debug heap

Arguments:

    hLocal  - handle (pointer) of block for which to get size

Return Value:

    SIZE_T
        Success - size of block

        Failure - 0

--*/

{
    SIZE_T size;

    if (hDebugHeap != NULL) {
        size = HeapSize(hDebugHeap,
                        bHeapNoSerialize ? HEAP_NO_SERIALIZE : 0,
                        (LPCVOID)hLocal
                        );
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapSize(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        size = (SIZE_T)-1;
    }
    if (size == (SIZE_T)-1) {
        SetLastError(ERROR_INVALID_HANDLE);
        return 0;
    } else {
        return size;
    }
}


PRIVATE
BOOL
InternetDebugCheckMemBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    )

/*++

Routine Description:

    Checks the consistency of a debug memory block

Arguments:

    lpHeader    - pointer to what we think is DEBUG_MEMORY_HEADER

Return Value:

    None.

--*/

{
    BOOL result;

    __try {
        LPDEBUG_MEMORY_FOOTER lpFooter = (LPDEBUG_MEMORY_FOOTER)
            ((LPBYTE)lpHeader
                + (lpHeader->BlockLength - sizeof(DEBUG_MEMORY_FOOTER)));

        BOOL headerGuardOverrun = FALSE;
        UINT i;

        for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
            if (lpHeader->Guard[i] != GUARD_DWORD_FILL) {
                headerGuardOverrun = TRUE;
                break;
            }
        }

        BOOL footerGuardOverrun = FALSE;

        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
            if (lpFooter->Guard[i] != GUARD_DWORD_FILL) {
                footerGuardOverrun = TRUE;
                break;
            }
        }

        BOOL footerGuard2Overrun = FALSE;

        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
            if (lpFooter->Guard2[i] != GUARD_DWORD_FILL) {
                footerGuard2Overrun = TRUE;
                break;
            }
        }

        LPBYTE lpExtraMemory = (LPBYTE)(lpHeader + 1) + lpHeader->RequestedLength;
        BOOL extraMemoryOverrun = FALSE;
        SIZE_T byteLength = ROUND_UP_DWORD(lpHeader->RequestedLength) - lpHeader->RequestedLength;

        for (i = 0; i < byteLength; ++i) {
            if (lpExtraMemory[i] != BYTE_ALLOC_FILL_EXTRA) {
                extraMemoryOverrun = TRUE;
                break;
            }
        }

        if (headerGuardOverrun
        || footerGuardOverrun
        || footerGuard2Overrun
        || extraMemoryOverrun
        || (lpHeader->Signature != HEADER_SIGNATURE)
        || (lpFooter->Signature != FOOTER_SIGNATURE)
        || (lpFooter->BlockLength != lpHeader->BlockLength)) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("Bad block: %#x\n",
                        lpHeader
                        ));

            MEMORY_ASSERT(FALSE);

            result = FALSE;
        } else {
            result = TRUE;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        DEBUG_PRINT(MEMALLOC,
                    FATAL,
                    ("Invalid block %#x - exception occurred\n",
                    lpHeader
                    ));

        MEMORY_ASSERT(FALSE);

        result = FALSE;
    }
    return result;
}


PRIVATE
VOID
InternetDebugMemTest(
    VOID
    )
{
    //
    // test
    //

    LPVOID p;

    p = (LPVOID)ALLOCATE_MEMORY(1);
    *((LPBYTE)p + 1) = 'X';
    p = (LPVOID)FREE_MEMORY((HLOCAL)p);

    INET_ASSERT(p == NULL);

    p = (LPVOID)ALLOCATE_MEMORY(1);
    p = (LPVOID)REALLOCATE_MEMORY_ZERO(p, 1111);
    p = (LPVOID)REALLOCATE_MEMORY(p, 439);
    p = (LPVOID)REALLOCATE_MEMORY(p, 720);
    p = (LPVOID)REALLOCATE_MEMORY_ZERO(p, 256);
    p = (LPVOID)REALLOCATE_MEMORY_ZERO(p, 16);
    p = (LPVOID)REALLOCATE_MEMORY(p, 128);
    p = (LPVOID)REALLOCATE_MEMORY_ZERO(p, 32);
    p = (LPVOID)REALLOCATE_MEMORY(p, 4);
    p = (LPVOID)REALLOCATE_MEMORY(p, 64);
    p = (LPVOID)REALLOCATE_MEMORY_ZERO(p, 63);
    p = (LPVOID)REALLOCATE_MEMORY_ZERO(p, 64);
    p = (LPVOID)REALLOCATE_MEMORY_ZERO(p, 65);
    p = (LPVOID)REALLOCATE_MEMORY(p, 65);
    p = (LPVOID)REALLOCATE_MEMORY(p, 64);
    p = (LPVOID)REALLOCATE_MEMORY(p, 64);
    p = (LPVOID)FREE_MEMORY((HLOCAL)p);

    INET_ASSERT(p == NULL);

    p = (LPVOID)ALLOCATE_MEMORY(8);
    p = (LPVOID)REALLOCATE_MEMORY(p, 8);
    p = (LPVOID)REALLOCATE_MEMORY(p, 100000);
    p = (LPVOID)FREE_MEMORY((HLOCAL)p);

    INET_ASSERT(p == NULL);

    InternetDebugCheckMemFreed(TRUE);
}


PRIVATE
VOID
ReportMemoryUsage(
    VOID
    )
{
    //
    // make copies of variables in case debug print functions want to allocate
    // debug memory (!)
    //

    SIZE_T totalActualMemoryAllocated;
    SIZE_T totalBlockMemoryAllocated;
    SIZE_T totalRealMemoryAllocated;
    SIZE_T totalActualMemoryFreed;
    SIZE_T totalBlockMemoryFreed;
    SIZE_T totalRealMemoryFreed;
    SIZE_T actualMemoryAllocated;
    SIZE_T blockLengthAllocated;
    SIZE_T realLengthAllocated;
    DWORD memoryAllocations;
    DWORD goodMemoryAllocations;
    DWORD memoryReAllocations;
    DWORD goodMemoryReAllocations;
    DWORD memoryFrees;
    DWORD goodMemoryFrees;
    SIZE_T largestBlockRequested;
    SIZE_T largestBlockAllocated;
    SIZE_T smallestBlockRequested;
    SIZE_T smallestBlockAllocated;

    EnterCriticalSection(&MemoryVarsCritSec);

    totalActualMemoryAllocated = TotalActualMemoryAllocated;
    totalBlockMemoryAllocated = TotalBlockMemoryAllocated;
    totalRealMemoryAllocated = TotalRealMemoryAllocated;
    totalActualMemoryFreed = TotalActualMemoryFreed;
    totalBlockMemoryFreed = TotalBlockMemoryFreed;
    totalRealMemoryFreed = TotalRealMemoryFreed;
    actualMemoryAllocated = ActualMemoryAllocated;
    blockLengthAllocated = BlockLengthAllocated;
    realLengthAllocated = RealLengthAllocated;
    memoryAllocations = MemoryAllocations;
    goodMemoryAllocations = GoodMemoryAllocations;
    memoryReAllocations = MemoryReAllocations;
    goodMemoryReAllocations = GoodMemoryReAllocations;
    memoryFrees = MemoryFrees;
    goodMemoryFrees = GoodMemoryFrees;
    largestBlockRequested = LargestBlockRequested;
    largestBlockAllocated = LargestBlockAllocated;
    smallestBlockRequested = SmallestBlockRequested;
    smallestBlockAllocated = SmallestBlockAllocated;

    LeaveCriticalSection(&MemoryVarsCritSec);

#ifdef _WIN64
    char numBuf[64];
#else
    char numBuf[32];
#endif

    DEBUG_PUT(("********************************************************************************\n"
               "\n"
               "WinHttp Debug Memory Usage:\n"
               "\n"
               "\tInternetDebugMemFlags = %#08x\n"
               "\n",
               InternetDebugMemFlags
               ));
    DEBUG_PUT(("\tTotal Memory Allocated. . . , . . . . %s\n", NiceNum(numBuf, totalActualMemoryAllocated, 0)));
    DEBUG_PUT(("\tTotal Block Length Allocated. . . . . %s\n", NiceNum(numBuf, totalBlockMemoryAllocated, 0)));
    DEBUG_PUT(("\tTotal User Length Allocated . . . . . %s\n", NiceNum(numBuf, totalRealMemoryAllocated, 0)));
    DEBUG_PUT(("\tTotal Memory Freed. . . . . . . . . . %s\n", NiceNum(numBuf, totalActualMemoryFreed, 0)));
    DEBUG_PUT(("\tTotal Block Length Freed. . . . . . . %s\n", NiceNum(numBuf, totalBlockMemoryFreed, 0)));
    DEBUG_PUT(("\tTotal User Length Freed . . . . . . . %s\n", NiceNum(numBuf, totalRealMemoryFreed, 0)));
    DEBUG_PUT(("\tMemory Still Allocated. . . . . . . . %s\n", NiceNum(numBuf, actualMemoryAllocated, 0)));
    DEBUG_PUT(("\tBlock Length Still Allocated. . . . . %s\n", NiceNum(numBuf, blockLengthAllocated, 0)));
    DEBUG_PUT(("\tUser Length Still Allocated . . . . . %s\n", NiceNum(numBuf, realLengthAllocated, 0)));
    DEBUG_PUT(("\tAttempted Memory Allocations. . . . . %s\n", NiceNum(numBuf, memoryAllocations, 0)));
    DEBUG_PUT(("\tGood Memory Allocations . . . . . . . %s\n", NiceNum(numBuf, goodMemoryAllocations, 0)));
    DEBUG_PUT(("\tAttempted Memory Reallocations. . . . %s\n", NiceNum(numBuf, memoryReAllocations, 0)));
    DEBUG_PUT(("\tGood Memory Reallocations . . . . . . %s\n", NiceNum(numBuf, goodMemoryReAllocations, 0)));
    DEBUG_PUT(("\tAttempted Memory Frees. . . . . . . . %s\n", NiceNum(numBuf, memoryFrees, 0)));
    DEBUG_PUT(("\tGood Memory Frees . . . . . . . . . . %s\n", NiceNum(numBuf, goodMemoryFrees, 0)));
    DEBUG_PUT(("\tLargest Block Requested . . . . . . . %s\n", NiceNum(numBuf, largestBlockRequested, 0)));
    DEBUG_PUT(("\tLargest Block Allocated . . . . . . . %s\n", NiceNum(numBuf, largestBlockAllocated, 0)));
    DEBUG_PUT(("\tLargest Block Requested From. . . . . %s!%d\n", SourceFilename(LargestBlockRequestedFile), LargestBlockRequestedLine));
    DEBUG_PUT(("\tSmallest Block Requested. . . . . . . %s\n", NiceNum(numBuf, smallestBlockRequested, 0)));
    DEBUG_PUT(("\tSmallest Block Allocated. . . . . . . %s\n", NiceNum(numBuf, smallestBlockAllocated, 0)));
    DEBUG_PUT(("\tSmallest Block Requested From . . . . %s!%d\n", SourceFilename(SmallestBlockRequestedFile), SmallestBlockRequestedLine));
    DEBUG_PUT(("\n"
               "\tBlocks Still Allocated. . . . . . . . %s\n", NiceNum(numBuf, goodMemoryAllocations - goodMemoryFrees, 0)));
    DEBUG_PUT(("\tMemory Still Allocated. . . . . . . . %s\n", NiceNum(numBuf, totalActualMemoryAllocated - totalActualMemoryFreed, 0)));
    DEBUG_PUT(("\n"
               "********************************************************************************\n"
               "\n"));
}


PRIVATE
VOID
ReportMemoryBlocks(
    VOID
    )
{
    DEBUG_PUT(("ReportMemoryBlocks\n\n"));

    DEBUG_PUT(("AllocatedBlockList:\n\n"));

    DumpMemoryList(&AllocatedBlockList);
    if (bDeferFree) {
        DumpDeferredFreeList();
    }
}


PRIVATE
VOID
DumpDeferredFreeList(
    VOID
    )
{
    DEBUG_PUT(("DeferredFreeList:\n\n"));

    DumpMemoryList(&DeferredFreeList);
}


PRIVATE
VOID
DumpMemoryList(
    IN LPSERIALIZED_LIST lpList
    )
{
    LPDEBUG_MEMORY_HEADER lpHeader;
    int counter = 1;

    if (bUseSymbols) {

        //
        // have to load IMAGEHLP.DLL here because we're in DLL_PROCESS_DETACH
        // and if we loaded it earlier, there's a good chance the system has
        // already freed it
        //

        InitSymLib();
    }

    LockSerializedList(lpList);
    lpHeader = (LPDEBUG_MEMORY_HEADER)HeadOfSerializedList(lpList);
    while (lpHeader != (LPDEBUG_MEMORY_HEADER)SlSelf(lpList)) {

        DEBUG_PUT(("Block # %d\n", counter));


        if (!DumpBlock(lpHeader)) {
            break;
        }

        DEBUG_PUT(("********************************************************************************\n\n"));

        lpHeader = (LPDEBUG_MEMORY_HEADER)(lpHeader->List.Flink);
        ++counter;
    }
    UnlockSerializedList(lpList);
}


PRIVATE
VOID
FindAndDumpDeferredBlock(
    IN HLOCAL hLocal
    )
{
    LPDEBUG_MEMORY_HEADER lpHeader;

    LockSerializedList(&DeferredFreeList);

    lpHeader = (LPDEBUG_MEMORY_HEADER)HeadOfSerializedList(&DeferredFreeList);
    while (lpHeader != (LPDEBUG_MEMORY_HEADER)SlSelf(&DeferredFreeList)) {
        if (hLocal == (HLOCAL)lpHeader) {
            DumpBlock(lpHeader);
            break;
        }
        lpHeader = (LPDEBUG_MEMORY_HEADER)(lpHeader->List.Flink);
    }

    UnlockSerializedList(&DeferredFreeList);
}


PRIVATE
BOOL
DumpBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    )
{
    BOOL ok = DumpDebugMemoryHeader(lpHeader);

    if (!ok && bStopDumpIfBadBlock) {

        DEBUG_PUT(("*** stopping block dump: header @ %#x is bad\n", lpHeader));

        return FALSE;
    }
    if (bReportUserData) {
        DumpUserData(lpHeader);
    }
    if (bReportMemoryFooters) {

        LPDEBUG_MEMORY_FOOTER lpFooter;

        lpFooter = (LPDEBUG_MEMORY_FOOTER)
                        ((LPBYTE)lpHeader
                        + sizeof(*lpHeader)
                        + ROUND_UP_DWORD(lpHeader->RequestedLength));
        ok = DumpDebugMemoryFooter(lpFooter);
        if (!ok && bStopDumpIfBadBlock) {

            DEBUG_PUT(("*** stopping block dump: footer @ %#x is bad\n", lpFooter));

            return FALSE;
        }
    }
    return TRUE;
}


PRIVATE
BOOL
DumpDebugMemoryHeader(
    LPDEBUG_MEMORY_HEADER lpHeader
    )
{
    char numBuf[32];
    BOOL result;
    char flagsBuf[256];

    __try {
        DEBUG_PUT(("DEBUG_MEMORY_HEADER @ %#x:\n"
                   "\n",
                   lpHeader
                   ));
        DEBUG_PUT(("\tList. . . . . . . . . F=%#x B=%#x\n",
                   lpHeader->List.Flink,
                   lpHeader->List.Blink
                   ));
        DEBUG_PUT(("\tThread. . . . . . . . %#x\n",
                   lpHeader->ThreadId
                   ));
        DEBUG_PUT(("\tAllocated From. . . . %s!%d\n",
                   SourceFilename(lpHeader->CreatedFile),
                   lpHeader->CreatedLine
                   ));
        DEBUG_PUT(("\tLast Accessed From. . %s!%d\n",
                   SourceFilename(lpHeader->AccessedFile),
                   lpHeader->AccessedLine
                   ));
        DEBUG_PUT(("\tRequested Length. . . %s\n",
                   NiceNum(numBuf, lpHeader->RequestedLength, 0)
                   ));
        DEBUG_PUT(("\tBlock Length. . . . . %s\n",
                   NiceNum(numBuf, lpHeader->BlockLength, 0)
                   ));
        DEBUG_PUT(("\tActual Length . . . . %s\n",
                   NiceNum(numBuf, lpHeader->ActualLength, 0)
                   ));
        DEBUG_PUT(("\tSignature . . . . . . %x (%s)\n",
                   lpHeader->Signature,
                   (lpHeader->Signature == HEADER_SIGNATURE) ? "Good" : "BAD!!!"
                   ));
        DEBUG_PUT(("\tFlags . . . . . . . . %08x %s\n",
                   lpHeader->Flags,
                   MapMemoryFlags(lpHeader->Flags, flagsBuf)
                   ));
        DEBUG_PUT(("\tTime Deferred . . . . %08x\n",
                   lpHeader->TimeDeferred
                   ));
        DEBUG_PUT(("\tClash Test. . . . . . %d\n",
                   lpHeader->ClashTest
                   ));
        DEBUG_PUT(("\tLast Operation. . . . %s\n",
                   MapLastAccessOperation(lpHeader->LastAccessOperation)
                   ));

#if DUMP_STACK
        LPSTR symbol;
        DWORD offset;
        int i;
#if ONE_STACK

        if (lpHeader->Stack[0]) {
            symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->Stack[0], &offset);
        } else {
            symbol = "";
            offset = 0;
        }
        DEBUG_PUT(("\tStack . . . . . . . . %08x %s+%#x\n",
                   lpHeader->Stack[0],
                   symbol,
                   offset
                   ));
        for (i = 1; i < ARRAY_ELEMENTS(lpHeader->Stack); ++i) {
            //if (!lpHeader->lpHeader->Stack[i]) {
            //    break;
            //}
            if (lpHeader->Stack[i]) {
                symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->Stack[i], &offset);
            } else {
                symbol = "";
                offset = 0;
            }
            DEBUG_PUT(("\t. . . . . . . . . . . %08x %s+%#x\n",
                       lpHeader->Stack[i],
                       symbol,
                       offset
                       ));
        }

#else

        if (lpHeader->LastAccessStack[0]) {
            symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->LastAccessStack[0], &offset);
        } else {
            symbol = "";
            offset = 0;
        }
        DEBUG_PUT(("\tLastAccessStack . . . %08x %s+%#x\n",
                   lpHeader->LastAccessStack[0],
                   symbol,
                   offset
                   ));
        for (i = 1; i < ARRAY_ELEMENTS(lpHeader->LastAccessStack); ++i) {
            //if (!lpHeader->LastAccessStack[i]) {
            //    break;
            //}
            if (lpHeader->LastAccessStack[i]) {
                symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->LastAccessStack[i], &offset);
            } else {
                symbol = "";
                offset = 0;
            }
            DEBUG_PUT(("\t. . . . . . . . . . . %08x %s+%#x\n",
                       lpHeader->LastAccessStack[i],
                       symbol,
                       offset
                       ));
        }
        if (lpHeader->CreateStack[0]) {
            symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->CreateStack[0], &offset);
        } else {
            symbol = "";
            offset = 0;
        }
        DEBUG_PUT(("\tCreateStack . . . . . %08x %s+%#x\n",
                   lpHeader->CreateStack[0],
                   symbol,
                   offset
                   ));
        for (i = 1; i < ARRAY_ELEMENTS(lpHeader->CreateStack); ++i) {
            //if (!lpHeader->lpHeader->CreateStack[i]) {
            //    break;
            //}
            if (lpHeader->CreateStack[i]) {
                symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->CreateStack[i], &offset);
            } else {
                symbol = "";
                offset = 0;
            }
            DEBUG_PUT(("\t. . . . . . . . . . . %08x %s+%#x\n",
                       lpHeader->CreateStack[i],
                       symbol,
                       offset
                       ));
        }

#endif // ONE_STACK
#endif // DUMP_STACK

        DEBUG_PUT(("\tGuard . . . . . . . . %08x\n"
                   "\n",
                   lpHeader->Guard[0]
                   ));
        result = TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        //DEBUG_PUT(("DEBUG_MEMORY_HEADER @ %#x is BAD\n", lpHeader));

        result = FALSE;
    }
    return result;
}


PRIVATE
BOOL
DumpDebugMemoryFooter(
    LPDEBUG_MEMORY_FOOTER lpFooter
    )
{
    char numBuf[32];
    BOOL result;

    _try {
        DEBUG_PUT(("DEBUG_MEMORY_FOOTER @ %#x:\n"
                   "\n",
                   lpFooter
                   ));
        DEBUG_PUT(("\tGuard . . . . . . . . %08x %08x %08x %08x\n",
                   lpFooter->Guard[0],
                   lpFooter->Guard[1],
                   lpFooter->Guard[2],
                   lpFooter->Guard[3]
                   ));
        DEBUG_PUT(("\tSignature . . . . . . %x (%s)\n",
                   lpFooter->Signature,
                   (lpFooter->Signature == FOOTER_SIGNATURE) ? "Good" : "BAD!!!"
                   ));
        DEBUG_PUT(("\tBlock Length. . . . . %s\n",
                   NiceNum(numBuf, lpFooter->BlockLength, 0)
                   ));
        DEBUG_PUT(("\tGuard2. . . . . . . . %08x %08x\n"
                   "\n",
                   lpFooter->Guard2[0],
                   lpFooter->Guard2[1]
                   ));
        result = TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        //DEBUG_PUT(("DEBUG_MEMORY_FOOTER @ %#x is BAD\n", lpFooter));

        result = FALSE;
    }
    return result;
}


PRIVATE
VOID
DumpUserData(
    LPDEBUG_MEMORY_HEADER lpHeader
    )
{
    static char spaces[] = "                                              ";    // 15 * 3 + 2
    SIZE_T userSize = lpHeader->RequestedLength;
    SIZE_T Size = ROUND_UP_DWORD(userSize);
    LPBYTE Address = (LPBYTE)(lpHeader + 1);

    DEBUG_PUT(("\t%d (%#x) bytes of user data (rounded to %d (%#x)) @ %#x\n\n",
               userSize,
               userSize,
               Size,
               Size,
               Address
               ));

    if (bLimitUserData && (Size > MaxUserDataDumped)) {

        DEBUG_PUT(("*** User data length %d too large: limited to %d (probably bad block)\n",
                   Size,
                   MaxUserDataDumped
                   ));

        Size = MaxUserDataDumped;
    }

    //
    // dump out the data, debug style
    //

    while (Size) {

#define DumpUserData_BUF_SIZE 128

		char buf[DumpUserData_BUF_SIZE];
        int len;
        int clen;

        rsprintf(buf, DumpUserData_BUF_SIZE, "\t%08x  ", Address);

        clen = (int)min(Size, 16);
        if (bDumpAsDwords) {
            len = clen / 4;
        } else {
            len = clen;
        }

        //
        // dump the hex representation of each character - up to 16 per line
        //

        int i;

        for (i = 0; i < len; ++i) {
            if (bDumpAsDwords) {
				size_t pos = 11 + i * 9;
                rsprintf(&buf[pos], DumpUserData_BUF_SIZE - pos, "%08x ", ((LPDWORD)Address)[i]);
            } else {
				size_t pos = 11 + i * 3;
                rsprintf(&buf[pos], DumpUserData_BUF_SIZE - pos,
                         ((i & 15) == 7) ? "%02.2x-" : "%02.2x ",
                         Address[i] & 0xff
                         );
            }
        }

        //
        // write as many spaces as required to tab to ASCII field
        //

        int offset;

        if (bDumpAsDwords) {
            memcpy(&buf[11 + i * 9], spaces, (4 - len) * 9 + 2);
            offset = 49;
        } else {
            memcpy(&buf[11 + i * 3], spaces, (16 - len) * 3 + 2);
            offset = 60;
        }

        //
        // dump ASCII representation of each character
        //

        for (i = 0; i < clen; ++i) {

            char ch;

            ch = Address[i];
            buf[offset + i] = ((ch < 32) || (ch > 127)) ? '.' : ch;
        }

        buf[offset + i++] = '\r';
        buf[offset + i++] = '\n';
        buf[offset + i] = 0;

        //
        // InternetDebugOut() - no printf expansion (%s in data!), no prefixes
        //

        InternetDebugOut(buf, FALSE);

        Address += clen;
        Size -= clen;
    }

    InternetDebugOut("\r\n", FALSE);
}


PRIVATE
LPSTR
MapLastAccessOperation(
    MEMORY_ACTION Action
    )
{
    switch (Action) {
    case MemAllocate:
        return "Alloc";

    case MemReallocate:
        return "Realloc";

    case MemLock:
        return "Lock";

    case MemUnlock:
        return "Unlock";

    case MemFree:
        return "Free";

    case MemSize:
        return "Size";
    }
    return "?";
}


PRIVATE
LPSTR
MapMemoryFlags(
    DWORD Flags,
    LPSTR Buffer
    )
{
    LPSTR buf = Buffer;
    int i = 0;

    *buf++ = '(';
    if (Flags & LMEM_DISCARDABLE) {
        buf += wsprintf(buf, "DISCARDABLE");
        ++i;
    }
    if (Flags & LMEM_ZEROINIT) {
        if (i) {
            buf += wsprintf(buf, ", ");
        }
        ++i;
        buf += wsprintf(buf, "ZEROINIT");
    }
    if (Flags & LMEM_NODISCARD) {
        if (i) {
            buf += wsprintf(buf, ", ");
        }
        ++i;
        buf += wsprintf(buf, "NODISCARD");
    }
    if (Flags & LMEM_NOCOMPACT) {
        if (i) {
            buf += wsprintf(buf, ", ");
        }
        ++i;
        buf += wsprintf(buf, "NOCOMPACT");
    }
    if (i) {
        buf += wsprintf(buf, ", ");
    }
    ++i;
    buf += wsprintf(buf, (Flags & LMEM_MOVEABLE) ? "MOVEABLE" : "FIXED");
    *buf++ = ')';
    *buf++ = '\0';
    return Buffer;
}


PRIVATE
LPSTR
DbgMemGetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    ) {
    //if (!bUseSymbols) {
    //    return "?";
    //}

    //
    // RLF 04/14/98 - IMAGEHLP blowing up probably because we are doing this at
    //                process detach time. Just return offset and run convsym
    //                utility on WinHttp.log
    //

    //return GetDebugSymbol(Address, Offset);
    *Offset = Address;
    return "";
}

#endif // defined(USE_DEBUG_MEMORY)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\common\serialst.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    serialst.cxx

Abstract:

    Functions to deal with a serialized list. These are replaced by macros in
    the retail version, except for functions no longer inlined due to critsec
    wrapper

    Contents:
        [InitializeSerializedList]
        [TerminateSerializedList]
        [LockSerializedList]
        [UnlockSerializedList]
        [InsertAtHeadOfSerializedList]
        [InsertAtTailOfSerializedList]
        [RemoveFromSerializedList]
        [IsSerializedListEmpty]
        [HeadOfSerializedList]
        [TailOfSerializedList]
        [CheckEntryOnSerializedList]
        [(CheckEntryOnList)]
        SlDequeueHead
        SlDequeueTail
        IsOnSerializedList

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Environment:

    Win-32 user level

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#include <wininetp.h>

#if INET_DEBUG

//
// manifests
//

#define SERIALIZED_LIST_SIGNATURE   'tslS'

//
// private prototypes
//

PRIVATE
DEBUG_FUNCTION
BOOL
CheckEntryOnList(
    IN PLIST_ENTRY List,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    );

//
// data
//

BOOL fCheckEntryOnList = FALSE;
BOOL ReportCheckEntryOnListErrors = FALSE;

//
// functions
//


DEBUG_FUNCTION
BOOL
InitializeSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    initializes a serialized list

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    None.

--*/

{
    INET_ASSERT(SerializedList != NULL);

    SerializedList->Signature = SERIALIZED_LIST_SIGNATURE;
    SerializedList->LockCount = 0;

    INITIALIZE_RESOURCE_INFO(&SerializedList->ResourceInfo);

    InitializeListHead(&SerializedList->List);
    SerializedList->ElementCount = 0;
    return SerializedList->Lock.Init();
}


DEBUG_FUNCTION
VOID
TerminateSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Undoes InitializeSerializeList

Arguments:

    SerializedList  - pointer to serialized list to terminate

Return Value:

    None.

--*/

{
    INET_ASSERT(SerializedList != NULL);
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    INET_ASSERT(SerializedList->ElementCount == 0);

    if (SerializedList->ElementCount != 0) {

        DEBUG_PRINT(SERIALST,
                    ERROR,
                    ("list @ %#x has %d elements, first is %#x\n",
                    SerializedList,
                    SerializedList->ElementCount,
                    SerializedList->List.Flink
                    ));

    } else {

        INET_ASSERT(IsListEmpty(&SerializedList->List));

    }
    SerializedList->Lock.FreeLock();
}


DEBUG_FUNCTION
BOOL
LockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Acquires a serialized list locks

Arguments:

    SerializedList  - SERIALIZED_LIST to lock

Return Value:

    Success if able to acquire a lock.

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    INET_ASSERT(SerializedList->LockCount >= 0);

    if ((!SerializedList->Lock.IsInitialized() && !SerializedList->Lock.Init()) ||
         !SerializedList->Lock.Lock())
    {
        return FALSE;
    }
    else
    {
        if (SerializedList->LockCount != 0)
        {
            INET_ASSERT(SerializedList->ResourceInfo.Tid == GetCurrentThreadId());
        }
    }
    ++SerializedList->LockCount;
    SerializedList->ResourceInfo.Tid = GetCurrentThreadId();

    return TRUE;
}


DEBUG_FUNCTION
VOID
UnlockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Releases a serialized list lock

Arguments:

    SerializedList  - SERIALIZED_LIST to unlock

Return Value:

    None.

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    INET_ASSERT(SerializedList->ResourceInfo.Tid == GetCurrentThreadId());
    INET_ASSERT(SerializedList->LockCount > 0);

    --SerializedList->LockCount;
    SerializedList->Lock.Unlock();
}


DEBUG_FUNCTION
BOOL
InsertAtHeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Adds an item to the head of a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to update

    Entry           - thing to update it with

Return Value:

    FALSE - only if unable to acquire the lock

--*/

{
    INET_ASSERT(Entry != &SerializedList->List);

    if (LockSerializedList(SerializedList))
    {
        if (fCheckEntryOnList)
        {
            CheckEntryOnList(&SerializedList->List, Entry, FALSE);
        }
        InsertHeadList(&SerializedList->List, Entry);
        ++SerializedList->ElementCount;

        INET_ASSERT(SerializedList->ElementCount > 0);

        UnlockSerializedList(SerializedList);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


DEBUG_FUNCTION
BOOL
InsertAtTailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Adds an item to the head of a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to update

    Entry           - thing to update it with

Return Value:

    FALSE - only if not enough memory was available to insert an item.

--*/

{
    INET_ASSERT(Entry != &SerializedList->List);

    if (LockSerializedList(SerializedList))
    {
        if (fCheckEntryOnList) {
            CheckEntryOnList(&SerializedList->List, Entry, FALSE);
        }
        InsertTailList(&SerializedList->List, Entry);
        ++SerializedList->ElementCount;

        INET_ASSERT(SerializedList->ElementCount > 0);

        UnlockSerializedList(SerializedList);
        return TRUE;
    }
    return FALSE;
}


BOOL
DEBUG_FUNCTION
RemoveFromSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Removes the entry from a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to remove entry from

    Entry           - pointer to entry to remove

Return Value:

    FALSE if unable sycnhronize access to the list due to low-memory.

--*/

{
    INET_ASSERT((Entry->Flink != NULL) && (Entry->Blink != NULL));

    if (LockSerializedList(SerializedList))
    {
        if (fCheckEntryOnList)
        {
            CheckEntryOnList(&SerializedList->List, Entry, TRUE);
        }

        INET_ASSERT(SerializedList->ElementCount > 0);

        RemoveEntryList(Entry);
        --SerializedList->ElementCount;
        Entry->Flink = NULL;
        Entry->Blink = NULL;
        UnlockSerializedList(SerializedList);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


DEBUG_FUNCTION
BOOL
IsSerializedListEmpty(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Checks if a serialized list contains any elements

Arguments:

    SerializedList  - pointer to list to check

Return Value:

    BOOL

--*/

{
    // For simplicity, don't worry about returning additional status.
    // Due to this always being tied to additional manipulation,
    // the lock has already been acquired in all current cases.
    if (!LockSerializedList(SerializedList))
        return TRUE;

    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    BOOL empty;

    if (IsListEmpty(&SerializedList->List)) {

        INET_ASSERT(SerializedList->ElementCount == 0);

        empty = TRUE;
    } else {

        INET_ASSERT(SerializedList->ElementCount != 0);

        empty = FALSE;
    }

    UnlockSerializedList(SerializedList);

    return empty;
}


DEBUG_FUNCTION
PLIST_ENTRY
HeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Returns the element at the tail of the list, without taking the lock

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    PLIST_ENTRY
        pointer to element at tail of list

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    return SerializedList->List.Flink;
}


DEBUG_FUNCTION
PLIST_ENTRY
TailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Returns the element at the tail of the list, without taking the lock

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    PLIST_ENTRY
        pointer to element at tail of list

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    return SerializedList->List.Blink;
}


DEBUG_FUNCTION
BOOL
CheckEntryOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    )

/*++

Routine Description:

    Checks an entry exists (or doesn't exist) on a list

Arguments:

    SerializedList  - pointer to serialized list

    Entry           - pointer to entry

    ExpectedResult  - TRUE if expected on list, else FALSE

Return Value:

    BOOL
        TRUE    - expected result

        FALSE   - unexpected result

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    if (!LockSerializedList(SerializedList))
        return FALSE;

    BOOL result;

    __try {
        result = CheckEntryOnList(&SerializedList->List, Entry, ExpectedResult);
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        DEBUG_PRINT(SERIALST,
                    FATAL,
                    ("List @ %#x (%d elements) is bad\n",
                    SerializedList,
                    SerializedList->ElementCount
                    ));

        result = FALSE;
    }
    ENDEXCEPT
    UnlockSerializedList(SerializedList);

    return result;
}


PRIVATE
DEBUG_FUNCTION
BOOL
CheckEntryOnList(
    IN PLIST_ENTRY List,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    )
{
    BOOLEAN found = FALSE;
    PLIST_ENTRY p;

    if (!IsListEmpty(List)) {
        for (p = List->Flink; p != List; p = p->Flink) {
            if (p == Entry) {
                found = TRUE;
                break;
            }
        }
    }
    if (found != ExpectedResult) {
        if (ReportCheckEntryOnListErrors) {

            LPSTR description;

            description = found
                        ? "Entry %#x already on list %#x\n"
                        : "Entry %#x not found on list %#x\n"
                        ;

            DEBUG_PRINT(SERIALST,
                        ERROR,
                        (description,
                        Entry,
                        List
                        ));

            DEBUG_BREAK(SERIALST);

        }
        return FALSE;
    }
    return TRUE;
}

#else  // else !INET_DEBUG

BOOL
InitializeSerializedList(LPSERIALIZED_LIST pList)
{
    InitializeListHead(&(pList)->List);
    (pList)->ElementCount = 0;
    return (pList->Lock).Init();
}


BOOL
InsertAtHeadOfSerializedList(LPSERIALIZED_LIST list, PLIST_ENTRY entry)
{
    if (LockSerializedList(list))
    {
        InsertHeadList(&(list)->List, entry);
        ++(list)->ElementCount;
        UnlockSerializedList(list);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


BOOL
InsertAtTailOfSerializedList(LPSERIALIZED_LIST list, PLIST_ENTRY entry)
{
    if (LockSerializedList(list))
    {
        InsertTailList(&(list)->List, entry);
        ++(list)->ElementCount;
        UnlockSerializedList(list);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


BOOL
RemoveFromSerializedList(LPSERIALIZED_LIST list, PLIST_ENTRY entry)
{
    if (LockSerializedList(list))
    {
        RemoveEntryList(entry);
        --(list)->ElementCount;
        UnlockSerializedList(list);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

#endif // INET_DEBUG

//
// functions that are always functions
//


LPVOID
SlDequeueHead(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Dequeues the element at the head of the queue and returns its address or
    NULL if the queue is empty

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST to dequeue from

Return Value:

    LPVOID

--*/

{
    LPVOID entry = NULL;

    if (!IsSerializedListEmpty(SerializedList)) {
        if (LockSerializedList(SerializedList)) {
            if (!IsSerializedListEmpty(SerializedList)) {
                entry = (LPVOID)HeadOfSerializedList(SerializedList);
                if (!RemoveFromSerializedList(SerializedList, (PLIST_ENTRY)entry))
                    entry = NULL;
            }
            UnlockSerializedList(SerializedList);
        }
    }

    return entry;
}


LPVOID
SlDequeueTail(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Dequeues the element at the tail of the queue and returns its address or
    NULL if the queue is empty

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST to dequeue from

Return Value:

    LPVOID

--*/

{
    LPVOID entry = NULL;

    if (!IsSerializedListEmpty(SerializedList)) {
        if (LockSerializedList(SerializedList)) {
            if (!IsSerializedListEmpty(SerializedList)) {
                entry = (LPVOID)TailOfSerializedList(SerializedList);
                if (!RemoveFromSerializedList(SerializedList, (PLIST_ENTRY)entry))
                    entry = NULL;
            }
            UnlockSerializedList(SerializedList);
        }
    } else {
        entry = NULL;
    }
    return entry;
}


BOOL
IsOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Checks if an entry is on a serialized list. Useful to call before
    RemoveFromSerializedList() if multiple threads can remove the element

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

    Entry           - pointer to element to check

Return Value:

    BOOL
        TRUE    - Entry is on SerializedList

        FALSE   -   "    " not on     "

--*/

{
    BOOL onList = FALSE;

    if (!IsSerializedListEmpty(SerializedList)) {
        if (LockSerializedList(SerializedList)) {
            if (!IsSerializedListEmpty(SerializedList)) {
                for (PLIST_ENTRY entry = HeadOfSerializedList(SerializedList);
                    entry != (PLIST_ENTRY)SlSelf(SerializedList);
                    entry = entry->Flink) {

                    if (entry == Entry) {
                       onList = TRUE;
                       break;
                    }
                }
            }
            UnlockSerializedList(SerializedList);
        }
    }
    return onList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\dll\makefile.inc ===
!if "$(BUILD_PRODUCT)" == "IE"
MC_INC = -A
!endif

$(O)\inetmsg.rc $(O)\inetmsg.h $(O)\msg00001.bin : inetmsg.mc
    mc $(MC_INC) -v -d -r $(O) -h $(O) inetmsg.mc

winhttp.rc : $(O)\selfreg_winhttp.inf

$(O)\selfreg_winhttp.inf : selfreg.inx
    $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\debug\inetdbg.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    inetdbg.cxx

Abstract:

    Debugging functions for internet DLL

    Contents:
        InternetDebugInitialize
        InternetDebugTerminate
        InternetGetDebugInfo
        InternetSetDebugInfo
        InternetOpenDebugFile
        InternetReopenDebugFile
        InternetCloseDebugFile
        InternetFlushDebugFile
        InternetDebugSetControlFlags
        InternetDebugResetControlFlags
        InternetDebugEnter
        InternetDebugLeave
        InternetDebugError
        InternetDebugPrint
        (InternetDebugPrintString)
        InternetDebugPrintf
        InternetDebugOut
        InternetDebugDump
        InternetDebugDumpFormat
        InternetAssert
        InternetGetDebugVariable
        (InternetGetDebugVariableString)
        InternetMapError
        InternetMapStatus
        InternetMapOption
        InternetMapHttpOption
        InternetMapHttpState
        InternetMapHttpStateFlag
        InternetMapAsyncRequest
        InternetMapHandleType
        InternetMapScheme
        InternetMapOpenType
        InternetMapService
        (ExtractFileName)
        (SetDebugPrefix)
        SourceFilename
        InitSymLib
        TermSymLib
        GetDebugSymbol
        x86SleazeCallStack
        x86SleazeCallersAddress

Author:

    Richard L Firth (rfirth) 13-Feb-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    13-Feb-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include <ntverp.h>

#ifdef WINHTTP_FOR_MSMXL
#include <ieverp.h>
#endif

#include "rprintf.h"
#include <imagehlp.h>

#ifdef ENABLE_DEBUG

//
// private manifests
//

#define SWITCH_VARIABLE_NAME        "WinHttpDebugging"
#define CONTROL_VARIABLE_NAME       "WinHttpControl"
#define CATEGORY_VARIABLE_NAME      "WinHttpCategory"
#define ERROR_VARIABLE_NAME         "WinHttpError"
#define BREAK_VARIABLE_NAME         "WinHttpBreak"
//#define DEFAULT_LOG_VARIABLE_NAME   "WinHttpxLog"
#define CHECK_LIST_VARIABLE_NAME    "WinHttpCheckSerializedList"
#define LOG_FILE_VARIABLE_NAME      "WinHttpLogFile"
#define INDENT_VARIABLE_NAME        "WinHttpLogIndent"

#define DEFAULT_LOG_FILE_NAME       "WINHTTP.LOG"

#define ENVIRONMENT_VARIABLE_BUFFER_LENGTH  80

#define PRINTF_STACK_BUFFER_LENGTH  8192

//
// private macros
//

#endif

#define CASE_OF(constant)   case constant: return # constant

#ifdef ENABLE_DEBUG

//
// private prototypes
//

PRIVATE
VOID
InternetDebugPrintString(
    IN LPSTR String
    );

PRIVATE
VOID
InternetGetDebugVariableString(
    IN LPSTR lpszVariableName,
    OUT LPSTR lpszVariable,
    IN DWORD dwVariableLen
    );

PRIVATE
LPSTR
ExtractFileName(
    IN LPSTR Module,
    OUT LPSTR Buf
    );

PRIVATE
LPSTR
SetDebugPrefix(
    IN LPSTR Buffer, IN DWORD_PTR BufSize
    );
//
//
// these variables are employed in macros, so must be public
//

PUBLIC DWORD InternetDebugErrorLevel = DBG_ERROR;
PUBLIC DWORD InternetDebugControlFlags = DBG_NO_DEBUG;
PUBLIC DWORD InternetDebugCategoryFlags = 0;
PUBLIC DWORD InternetDebugBreakFlags = 0;

//
// these variables are only accessed in this module, so can be private
//

PRIVATE int InternetDebugIndentIncrement = 2;
PRIVATE HANDLE InternetDebugFileHandle = INVALID_HANDLE_VALUE;
PRIVATE char InternetDebugFilename[MAX_PATH + 1] = DEFAULT_LOG_FILE_NAME;
PRIVATE BOOL InternetDebugEnabled = TRUE;
PRIVATE DWORD InternetDebugStartTime = 0;

extern "C" {
BOOL UrlcacheDebugEnabled = FALSE;
#if defined(UNIX) && defined(ux10)
/* Temporary fix for Apogee Compiler bug on HP only */
extern BOOL fCheckEntryOnList;
#else
BOOL fCheckEntryOnList;
#endif /* UNIX */
}

//
// high frequency performance counter globals
//


PRIVATE LONGLONG ftInit;  // initial local time
PRIVATE LONGLONG pcInit;  // initial perf counter
PRIVATE LONGLONG pcFreq;  // perf counter frequency

//
// functions
//


VOID
InternetDebugInitialize(
    VOID
    )

/*++

Routine Description:

    reads environment INETDBG flags and opens debug log file if required

Arguments:

    None.

Return Value:

    None.

--*/

{
#ifndef WININET_SERVER_CORE
    //
    // ensure registry key open (normally done in GlobalDataInitialize() later)
    //

#endif //!WININET_SERVER_CORE
    
    OpenInternetSettingsKey();

    //
    // record the starting tick count for cumulative deltas
    //

    InternetDebugStartTime = GetTickCountWrap();

    if (QueryPerformanceFrequency ((LARGE_INTEGER *) &pcFreq) && pcFreq) {

        QueryPerformanceCounter ((LARGE_INTEGER *) &pcInit);
        SYSTEMTIME st;
        GetLocalTime (&st);
        SystemTimeToFileTime (&st, (FILETIME *) &ftInit);
    }

    //
    // check see if there are any debug variable overrides in the environment
    // or the registry. If "WinHttpLog=<!0>" is set then we use the flags that
    // are most commonly used to generate WININET.LOG, with no console or
    // debugger output. We allow the other variables to be overridden
    //

    char WinHttpVer[16] = {0};
    BOOL defaultDebugVariables = FALSE;
    rsprintf(WinHttpVer, 16,
            "WinHttp%dLog", 
            InternetVersionInfo.dwMajorVersion);


    InternetGetDebugVariable(WinHttpVer, (LPDWORD)&defaultDebugVariables);
    if (!defaultDebugVariables)
    {
        InternetGetDebugVariable(SWITCH_VARIABLE_NAME, (LPDWORD)&defaultDebugVariables);
    }

    if (defaultDebugVariables) {
        InternetDebugEnabled = TRUE;
        InternetDebugControlFlags = INTERNET_DEBUG_CONTROL_DEFAULT;
        InternetDebugCategoryFlags = INTERNET_DEBUG_CATEGORY_DEFAULT;
        InternetDebugErrorLevel = INTERNET_DEBUG_ERROR_LEVEL_DEFAULT;
        InternetDebugBreakFlags = 0;
    }
    
    // InternetGetDebugVariable(SWITCH_VARIABLE_NAME, (LPDWORD)&InternetDebugEnabled);
    InternetGetDebugVariable(CONTROL_VARIABLE_NAME, &InternetDebugControlFlags);
    InternetGetDebugVariable(CATEGORY_VARIABLE_NAME, &InternetDebugCategoryFlags);
    InternetGetDebugVariable(ERROR_VARIABLE_NAME, &InternetDebugErrorLevel);
    InternetGetDebugVariable(BREAK_VARIABLE_NAME, &InternetDebugBreakFlags);
    InternetGetDebugVariable(CHECK_LIST_VARIABLE_NAME, (LPDWORD)&fCheckEntryOnList);
    InternetGetDebugVariable(INDENT_VARIABLE_NAME, (LPDWORD)&InternetDebugIndentIncrement);
    InternetGetDebugVariableString(LOG_FILE_VARIABLE_NAME,
                                   InternetDebugFilename,
                                   sizeof(InternetDebugFilename)
                                   );

    UrlcacheDebugEnabled = InternetDebugEnabled &&
        (InternetDebugCategoryFlags & DBG_CACHE);

    if ((InternetDebugIndentIncrement < 0) || (InternetDebugIndentIncrement > 32)) {
        InternetDebugIndentIncrement = 2;
    }

    //
    // quit now if debugging is disabled
    //

    if (!InternetDebugEnabled) {
        InternetDebugControlFlags |= (DBG_NO_DEBUG | DBG_NO_DATA_DUMP);
        return;
    }

    //
    // if we want to write debug output to file, open WININET.LOG in the current
    // directory. Open it in text mode, for write-only (by this process)
    //

    if (InternetDebugControlFlags & DBG_TO_FILE) {
        if (!InternetReopenDebugFile(InternetDebugFilename)) {
            InternetDebugControlFlags &= ~DBG_TO_FILE;
        }
    }
}


VOID
InternetDebugTerminate(
    VOID
    )

/*++

Routine Description:

    Performs any required debug termination

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_TO_FILE) {
        InternetCloseDebugFile();
    }
    InternetDebugControlFlags = DBG_NO_DEBUG;

    CloseInternetSettingsKey();
}

DWORD
InternetGetDebugInfo(
    OUT LPINTERNET_DEBUG_INFO lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns the internal debug variables

Arguments:

    lpBuffer            - pointer to structure that receives the variables

    lpdwBufferLength    - IN: Length of buffer
                          OUT: length of returned data if successful, else
                          required length of buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS;

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD requiredLength;
    DWORD error;
    int filenameLength;

    filenameLength = ((InternetDebugFileHandle != INVALID_HANDLE_VALUE)
                        ? strlen(InternetDebugFilename) : 0) + 1;

    requiredLength = sizeof(*lpBuffer) + filenameLength;
    if ((lpBuffer != NULL) && (*lpdwBufferLength >= requiredLength)) {
        lpBuffer->ErrorLevel = InternetDebugErrorLevel;
        lpBuffer->ControlFlags = InternetDebugControlFlags;
        lpBuffer->CategoryFlags = InternetDebugCategoryFlags;
        lpBuffer->BreakFlags = InternetDebugBreakFlags;
        lpBuffer->IndentIncrement = InternetDebugIndentIncrement;
        if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
            memcpy(lpBuffer->Filename, InternetDebugFilename, filenameLength);
        } else {
            lpBuffer->Filename[0] = '\0';
        }
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    *lpdwBufferLength = requiredLength;
    return error;
}


DWORD
InternetSetDebugInfo(
    IN LPINTERNET_DEBUG_INFO lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Sets the internal debugging variables to the values in the buffer. To make
    incrmental changes, the caller must first read the variables, change the
    bits they're interested in, then change the whole lot at one go

Arguments:

    lpBuffer        - pointer to structure that contains the variables

    dwBufferLength  - size of lpBuffer. Ignored

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    UNREFERENCED_PARAMETER(dwBufferLength);
    InternetDebugErrorLevel = lpBuffer->ErrorLevel;
    InternetDebugCategoryFlags = lpBuffer->CategoryFlags;
    InternetDebugControlFlags = lpBuffer->ControlFlags;
    InternetDebugBreakFlags = lpBuffer->BreakFlags;
    InternetDebugIndentIncrement = lpBuffer->IndentIncrement;

    //
    // handle the debug file. If we get an empty string, then (if we are logging
    // to a file), close the file.
    //
    // If the filename is exactly the same as we're already using, then the
    // caller doesn't want to change the log file
    //
    // If the filename is different, then we are being asked to create a new log
    // file: close the old and open the new. If we cannot open the new file then
    // set the filename to the NUL string in the debug buffer
    //

    if (lpBuffer->Filename[0]) {
        if (strcmp(InternetDebugFilename, lpBuffer->Filename) != 0) {
            InternetCloseDebugFile();
            InternetReopenDebugFile(lpBuffer->Filename);
            if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
                strcpy(InternetDebugFilename, lpBuffer->Filename);
            } else {
                lpBuffer->Filename[0] = '\0';
            }
        }
    } else {
        InternetCloseDebugFile();
    }
    return ERROR_SUCCESS;
}


BOOL
InternetOpenDebugFile(
    VOID
    )

/*++

Routine Description:

    Opens debug filename if not already open. Use InternetDebugFilename

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - file was opened

        FALSE   - file not opened (already open or error)

--*/

{
    if (InternetDebugFileHandle == INVALID_HANDLE_VALUE) {
        InternetDebugFileHandle = CreateFile(
            InternetDebugFilename,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,  // lpSecurityAttributes
            (InternetDebugControlFlags & DBG_APPEND_FILE)
                ? OPEN_ALWAYS
                : CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL
            | FILE_FLAG_SEQUENTIAL_SCAN
            | ((InternetDebugControlFlags & DBG_FLUSH_OUTPUT)
                ? FILE_FLAG_WRITE_THROUGH
                : 0),
            NULL
            );
        return InternetDebugFileHandle != INVALID_HANDLE_VALUE;
    }
    return FALSE;
}


BOOL
InternetReopenDebugFile(
    IN LPSTR Filename
    )

/*++

Routine Description:

    (Re)opens a debug log file. Closes the current one if it is open

Arguments:

    Filename    - new file to open

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        InternetCloseDebugFile();
    }
    if (Filename && *Filename) {
        InternetDebugFileHandle = CreateFile(
            Filename,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,  // lpSecurityAttributes
            (InternetDebugControlFlags & DBG_APPEND_FILE)
                ? OPEN_ALWAYS
                : CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL
            | FILE_FLAG_SEQUENTIAL_SCAN
            | ((InternetDebugControlFlags & DBG_FLUSH_OUTPUT)
                ? FILE_FLAG_WRITE_THROUGH
                : 0),
            NULL
            );

        //
        // put our start info in the log file. Mainly useful when we're
        // appending to the file
        //

        if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {

            SYSTEMTIME currentTime;
            char filespec[MAX_PATH + 1];
            LPSTR filename;

            if (GetModuleFileName(NULL, filespec, sizeof(filespec))) {
                filename = strrchr(filespec, '\\');
                if (filename != NULL) {
                    ++filename;
                } else {
                    filename = filespec;
                }
            } else {
                filename = "";
            }

            InternetDebugGetLocalTime(&currentTime, NULL);

            InternetDebugPrintf("\n"
                                ">>>> WinHttpX Version %d.%d Build %s.%d " __DATE__ " " __TIME__ "\n"
                                ">>>> Process %s [%d (%#x)] started at %02d:%02d:%02d.%03d %02d/%02d/%d\n",
                                InternetVersionInfo.dwMajorVersion,
                                InternetVersionInfo.dwMinorVersion,
                                VER_PRODUCTVERSION_STRING,
                                InternetBuildNumber,
                                filename,
                                GetCurrentProcessId(),
                                GetCurrentProcessId(),
                                currentTime.wHour,
                                currentTime.wMinute,
                                currentTime.wSecond,
                                currentTime.wMilliseconds,
                                currentTime.wMonth,
                                currentTime.wDay,
                                currentTime.wYear
                                );

            InternetDebugPrintf(">>>> Command line = %q\n", GetCommandLine());

            InternetDebugPrintf("\n"
                                "     InternetDebugErrorLevel      = %s [%d]\n"
                                "     InternetDebugControlFlags    = %#08x\n"
                                "     InternetDebugCategoryFlags   = %#08x\n"
                                "     InternetDebugBreakFlags      = %#08x\n"
                                "     InternetDebugIndentIncrement = %d\n"
                                "\n",
                                (InternetDebugErrorLevel == DBG_INFO)       ? "Info"
                                : (InternetDebugErrorLevel == DBG_WARNING)  ? "Warning"
                                : (InternetDebugErrorLevel == DBG_ERROR)    ? "Error"
                                : (InternetDebugErrorLevel == DBG_FATAL)    ? "Fatal"
                                : (InternetDebugErrorLevel == DBG_ALWAYS)   ? "Always"
                                : "?",
                                InternetDebugErrorLevel,
                                InternetDebugControlFlags,
                                InternetDebugCategoryFlags,
                                InternetDebugBreakFlags,
                                InternetDebugIndentIncrement
                                );
            return TRUE;
        }
    }
    return FALSE;
}


VOID
InternetCloseDebugFile(
    VOID
    )

/*++

Routine Description:

    Closes the current debug log file

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        if (InternetDebugControlFlags & DBG_FLUSH_OUTPUT) {
            InternetFlushDebugFile();
        }
        CloseHandle(InternetDebugFileHandle);
        InternetDebugFileHandle = INVALID_HANDLE_VALUE;
    }
}


VOID
InternetFlushDebugFile(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        FlushFileBuffers(InternetDebugFileHandle);
    }
}


VOID
InternetDebugSetControlFlags(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Sets debug control flags

Arguments:

    dwFlags - flags to set

Return Value:

    None.

--*/

{
    InternetDebugControlFlags |= dwFlags;
}


VOID
InternetDebugResetControlFlags(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Resets debug control flags

Arguments:

    dwFlags - flags to reset

Return Value:

    None.

--*/

{
    InternetDebugControlFlags &= ~dwFlags;
}


VOID
InternetDebugEnter(
    IN DWORD Category,
    IN DEBUG_FUNCTION_RETURN_TYPE ReturnType,
    IN LPCSTR Function,
    IN LPCSTR ParameterList OPTIONAL,
    IN ...
    )

/*++

Routine Description:

    Creates an INTERNET_DEBUG_RECORD for the current function and adds it to
    the per-thread (debug) call-tree

Arguments:

    Category        - category flags, e.g. DBG_FTP

    ReturnType      - type of data it returns

    Function        - name of the function. Must be global, static string

    ParameterList   - string describing parameters to function, or NULL if none

    ...             - parameters to function

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO pThreadInfo;
    LPINTERNET_DEBUG_RECORD pRecord;

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    pThreadInfo = InternetGetThreadInfo();

    //INET_ASSERT(pThreadInfo != NULL);

    if (!pThreadInfo) {
        return;
    }

    pRecord = NEW(INTERNET_DEBUG_RECORD);

    //INET_ASSERT(pRecord != NULL);

    if (!pRecord) {
        return;
    }

    pRecord->Stack = pThreadInfo->Stack;
    pRecord->Category = Category;
    pRecord->ReturnType = ReturnType;
    pRecord->Function = Function;
    pRecord->LastTime = GetTickCountWrap();
    pThreadInfo->Stack = pRecord;
    ++pThreadInfo->CallDepth;

    //
    // if the function's category (FTP, GOPHER, HTTP) is selected in the
    // category flags, then we dump the function entry information
    //

    if (InternetDebugCategoryFlags & Category) {

#define InternetDebugEnter_BUF_SIZE PRINTF_STACK_BUFFER_LENGTH

        char buf[InternetDebugEnter_BUF_SIZE];
        LPSTR bufptr;

        bufptr = buf;
        bufptr += rsprintf(bufptr, InternetDebugEnter_BUF_SIZE, "%s(", Function);
        if (ARGUMENT_PRESENT(ParameterList)) {

            va_list parms;

            va_start(parms, ParameterList);
            bufptr += _sprintf(bufptr, InternetDebugEnter_BUF_SIZE - (bufptr - buf),(char*)ParameterList, parms);
            va_end(parms);
        }
        rsprintf(bufptr, InternetDebugEnter_BUF_SIZE - (bufptr - buf), ")\n");
        InternetDebugPrintString(buf);

        //
        // only increase the indentation if we will display debug information
        // for this category
        //

        pThreadInfo->IndentIncrement += InternetDebugIndentIncrement;
    }
}


VOID
InternetDebugLeave(
    IN DWORD_PTR Variable,
    IN LPCSTR Filename,
    IN DWORD LineNumber
    )

/*++

Routine Description:

    Destroys the INTERNET_DEBUG_RECORD for the current function and dumps info
    about what the function is returning, if requested to do so

Arguments:

    Variable    - variable containing value being returned by function

    Filename    - name of file where DEBUG_LEAVE() invoked

    LineNumber  - and line number in Filename

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO pThreadInfo;
    LPINTERNET_DEBUG_RECORD pRecord;
    LPSTR format = "";
    LPSTR errstr;
    BOOL noVar;
    char formatBuf[128];
    DWORD lastError;
#define hexnumBuf_SIZE 15
    char hexnumBuf[hexnumBuf_SIZE];

    UNREFERENCED_PARAMETER(Filename);

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    //
    // seems that something in this path can nuke the last error, so we must
    // refresh it
    //

    lastError = GetLastError();

    pThreadInfo = InternetGetThreadInfo();

    //INET_ASSERT(pThreadInfo != NULL);

    if (!pThreadInfo) {
        return;
    }

    pRecord = pThreadInfo->Stack;

    //INET_ASSERT(pRecord != NULL);

    if (!pRecord) {
        return;
    }

    //
    // we are about to output a diagnostic message to the debug log, debugger,
    // or console. First check that we are required to display messages at
    // this level. The level for function ENTER and LEAVE is INFO
    //

    if (InternetDebugErrorLevel <= DBG_INFO) {

        //
        // only display the string and reduce the indent if we are requested
        // for information about this category
        //

        errstr = NULL;
        noVar = FALSE;
        if (InternetDebugCategoryFlags & pRecord->Category) {
            switch (pRecord->ReturnType) {
            case None:
                format = "%s() returning VOID";
                noVar = TRUE;
                break;

            case Bool:
                Variable = (DWORD_PTR)(Variable ? "TRUE" : "FALSE");

                //
                // *** FALL THROUGH ***
                //

            case String:
                format = "%s() returning %s";
                break;

            case Int:
                format = "%s() returning %d";
                break;

            case Dword:
                format = "%s() returning %u";
                errstr = InternetMapError((DWORD)Variable);
                if (errstr != NULL) {
                    if (*errstr == '?') {
                        rsprintf(hexnumBuf, hexnumBuf_SIZE, "%#x", Variable);
                        errstr = hexnumBuf;
                        format = "%s() returning %u [?] (%s)";
                    } else {
                        format = "%s() returning %u [%s]";
                    }
                }
                break;

            case Handle:
            case Pointer:
                if (Variable == 0) {
                    format = "%s() returning NULL";
                    noVar = TRUE;
                } else {
                    if (pRecord->ReturnType == Handle) {
                        format = "%s() returning handle %#x";
                    } else {
                        format = "%s() returning %#x";
                    }
                }
                break;

            default:

                INET_ASSERT(FALSE);

                break;
            }

            pThreadInfo->IndentIncrement -= InternetDebugIndentIncrement;
            if (pThreadInfo->IndentIncrement < 0) {
                pThreadInfo->IndentIncrement = 0;
            }

            //
            // add line number info, if requested
            //

            strcpy(formatBuf, format);
            if (!(InternetDebugControlFlags & DBG_NO_LINE_NUMBER)) {
                strcat(formatBuf, " (line %d)");
            }
            strcat(formatBuf, "\n");

            //
            // output an empty line if we are required to separate API calls in
            // the log. Only do this if this is an API level function, and it
            // is the top-level function
            //

            if ((InternetDebugControlFlags & DBG_SEPARATE_APIS)
            && (pRecord->Stack == NULL)) {
                strcat(formatBuf, "\n");
            }

            //
            // dump the line, depending on requirements and number of arguments
            //

            if (noVar) {
                InternetDebugPrint(formatBuf,
                                   pRecord->Function,
                                   LineNumber
                                   );
            } else if (errstr != NULL) {
                InternetDebugPrint(formatBuf,
                                   pRecord->Function,
                                   Variable,
                                   errstr,
                                   LineNumber
                                   );
            } else {
                InternetDebugPrint(formatBuf,
                                   pRecord->Function,
                                   Variable,
                                   LineNumber
                                   );
            }
/*
            //
            // output an empty line if we are required to separate API calls in
            // the log. Only do this if this is an API level function, and it
            // is the top-level function
            //

            if ((InternetDebugControlFlags & DBG_SEPARATE_APIS)
            && (pRecord->Stack == NULL)) {

                //
                // don't call InternetDebugPrint - we don't need timing, thread,
                // level etc. information just for the separator
                //

                InternetDebugOut("\n", FALSE);
            }
*/
        }
    }

    //
    // regardless of whether we are outputting debug info for this category,
    // remove the debug record and reduce the call-depth
    //

    --pThreadInfo->CallDepth;
    pThreadInfo->Stack = pRecord->Stack;

    DEL(pRecord);

    //
    // refresh the last error, in case it was nuked
    //

    SetLastError(lastError);
}


VOID
InternetDebugError(
    IN DWORD Error
    )

/*++

Routine Description:

    Used to display that a function is returning an error. We try to display a
    symbolic name for the error too (as when we are returning a DWORD from a
    function, using DEBUG_LEAVE)

    Displays a string of the form:

        Foo() returning error 87 [ERROR_INVALID_PARAMETER]

Arguments:

    Error   - the error code

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO pThreadInfo;
    LPINTERNET_DEBUG_RECORD pRecord;
    LPSTR errstr;
    DWORD lastError;
    char hexnumBuf[15];

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    //
    // seems that something in this path can nuke the last error, so we must
    // refresh it
    //

    lastError = GetLastError();

    pThreadInfo = InternetGetThreadInfo();

    //INET_ASSERT(pThreadInfo != NULL);
    INET_ASSERT(GetLastError() == lastError);

    if (pThreadInfo == NULL) {
        return;
    }

    pRecord = pThreadInfo->Stack;

    //INET_ASSERT(pRecord != NULL);

    if (pRecord == NULL) {
        return;
    }

    errstr = InternetMapError(Error);
    if ((errstr == NULL) || (*errstr == '?')) {
        rsprintf(hexnumBuf, hexnumBuf_SIZE, "%#x", Error);
        errstr = hexnumBuf;
    }
    InternetDebugPrint("%s() returning %d [%s]\n",
                       pRecord->Function,
                       Error,
                       errstr
                       );

    //
    // refresh the last error, in case it was nuked
    //

    SetLastError(lastError);
}


VOID
InternetDebugPrint(
    IN LPSTR Format,
    ...
    )

/*++

Routine Description:

    Internet equivalent of printf()

Arguments:

    Format  - printf format string

    ...     - any extra args

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;
	LPSTR buttail = buf + PRINTF_STACK_BUFFER_LENGTH;

    bufptr = SetDebugPrefix(buf, PRINTF_STACK_BUFFER_LENGTH);
    if (bufptr == NULL) {
        return;
    }

    //
    // now append the string that the DEBUG_PRINT originally gave us
    //

    va_list list;

    va_start(list, Format);
    _sprintf(bufptr, buttail - bufptr, Format, list);
    va_end(list);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugPrintValist(
    IN LPSTR Format,
    va_list list
    )

/*++

Routine Description:

    Internet equivalent of printf(), but takes valist as the args

Arguments:

    Format  - printf format string

    list    - stack frame of variable arguments

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;
	LPSTR buftail = buf + PRINTF_STACK_BUFFER_LENGTH;

    bufptr = SetDebugPrefix(buf, PRINTF_STACK_BUFFER_LENGTH);
    if (bufptr == NULL) {
        return;
    }

    _sprintf(bufptr, buftail - bufptr, Format, list);

    InternetDebugOut(buf, FALSE);
}


PRIVATE
VOID
InternetDebugPrintString(
    IN LPSTR String
    )

/*++

Routine Description:

    Same as InternetDebugPrint(), except we perform no expansion on the string

Arguments:

    String  - already formatted string (may contain %s)

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;

    bufptr = SetDebugPrefix(buf, PRINTF_STACK_BUFFER_LENGTH);
    if (bufptr == NULL) {
        return;
    }

    //
    // now append the string that the DEBUG_PRINT originally gave us
    //
	buf[PRINTF_STACK_BUFFER_LENGTH - 1] = '\0'; //make sure string is always terminated
	strncpy(bufptr, String, (int)(buf + PRINTF_STACK_BUFFER_LENGTH - bufptr - 1));

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugPrintf(
    IN LPSTR Format,
    IN ...
    )

/*++

Routine Description:

    Same as InternetDebugPrint(), but we don't access the per-thread info
    (because we may not have any)

Arguments:

    Format  - printf format string

    ...     - any extra args


Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    va_list list;
    char buf[PRINTF_STACK_BUFFER_LENGTH];

    va_start(list, Format);
    _sprintf(buf, PRINTF_STACK_BUFFER_LENGTH, Format, list);
    va_end(list);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugOut(
    IN LPSTR Buffer,
    IN BOOL Assert
    )

/*++

Routine Description:

    Writes a string somewhere - to the debug log file, to the console, or via
    the debugger, or any combination

Arguments:

    Buffer  - pointer to formatted buffer to write

    Assert  - TRUE if this function is being called from InternetAssert(), in
              which case we *always* write to the debugger. Of course, there
              may be no debugger attached, in which case no action is taken

Return Value:

    None.

--*/

{
    int buflen;
    DWORD written;

    buflen = strlen(Buffer);
    if ((InternetDebugControlFlags & DBG_TO_FILE)
    && (InternetDebugFileHandle != INVALID_HANDLE_VALUE)) {
        WriteFile(InternetDebugFileHandle, Buffer, buflen, &written, NULL);
        if (InternetDebugControlFlags & DBG_FLUSH_OUTPUT) {
            InternetFlushDebugFile();
        }
    }

    if (InternetDebugControlFlags & DBG_TO_CONSOLE) {
        WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),
                     Buffer,
                     buflen,
                     &written,
                     0
                     );
    }

    if (Assert || (InternetDebugControlFlags & DBG_TO_DEBUGGER)) {
        OutputDebugString(Buffer);
    }
}


VOID
InternetDebugDump(
    IN LPSTR Text,
    IN LPBYTE Address,
    IN DWORD Size
    )

/*++

Routine Description:

    Dumps Size bytes at Address, in the time-honoured debug tradition

Arguments:

    Text    - to display before dumping data

    Address - start of buffer

    Size    - number of bytes

Return Value:

    None.

--*/

{
    //
    // if flags say no data dumps then quit
    //

    if (InternetDebugControlFlags & (DBG_NO_DEBUG | DBG_NO_DATA_DUMP)) {
        return;
    }

    //
    // display the introduction text, if any
    //

    if (Text) {
        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrint(Text);
        } else {
            InternetDebugOut(Text, FALSE);
        }
    }

#define InternetDebugDump_BUF_SIZE 256

    char buf[InternetDebugDump_BUF_SIZE];

    //
    // display a line telling us how much data there is, if requested to
    //

    if (InternetDebugControlFlags & DBG_DUMP_LENGTH) {
        rsprintf(buf, InternetDebugDump_BUF_SIZE, "%d (%#x) bytes @ %#x\n", Size, Size, Address);
        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrintString(buf);
        } else {
            InternetDebugOut(buf, FALSE);
        }
    }

    //
    // dump out the data, debug style
    //

    while (Size) {

        int len = InternetDebugDumpFormat(Address, Size, sizeof(BYTE), buf);

        //
        // if we are to indent the data to the current level, then display the
        // buffer via InternetDebugPrint() which will apply all the thread id,
        // indentation, and other options selected, else just display the data
        // via InternetDebugOut(), which will simply send it to the output media
        //

        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrintString(buf);
        } else {
            InternetDebugOut(buf, FALSE);
        }

        Address += len;
        Size -= len;
    }
}


DWORD
InternetDebugDumpFormat(
    IN LPBYTE Address,
    IN DWORD Size,
    IN DWORD ElementSize,
    OUT LPSTR Buffer
    )

/*++

Routine Description:

    Formats Size bytes at Address, in the time-honoured debug tradition, for
    data dump purposes

Arguments:

    Address     - start of buffer

    Size        - number of bytes

    ElementSize - size of each word element in bytes

    Buffer      - pointer to output buffer, assumed to be large enough

Return Value:

    DWORD   - number of bytes formatted

--*/

{
    //
    // we (currently) only understand DWORD, WORD and BYTE dumps
    //

    if ((ElementSize != sizeof(DWORD)) && (ElementSize != sizeof(WORD))) {
        ElementSize = sizeof(BYTE);
    }

    static char spaces[] = "                                               ";    // 15 * 3 + 2
    int i, len;

    len = min(Size, 16);
//assume Buffer is big enough
#define BIGBIG_BUF_SIZE (1024 * 1024 * 1024)
    rsprintf(Buffer, BIGBIG_BUF_SIZE, "%08x  ", Address);

    //
    // dump the hex representation of each character or word - up to 16 per line
    //

    DWORD offset = 10;

    for (i = 0; i < len; i += ElementSize) {

        DWORD value;
        LPSTR formatString;

        switch (ElementSize) {
        case 4:
            formatString = "%08x ";
            value = *(LPDWORD)&Address[i];
            break;

        case 2:
            formatString = "%04x ";
            value = *(LPWORD)&Address[i] & 0xffff;
            break;

        default:
            formatString = ((i & 15) == 7) ? "%02.2x-" : "%02.2x ";
            value = Address[i] & 0xff;
            break;
        }
        rsprintf(&Buffer[offset], BIGBIG_BUF_SIZE, formatString, value);
        offset += ElementSize * 2 + 1;
    }

    //
    // write as many spaces as required to tab to ASCII field
    //

    memcpy(&Buffer[offset], spaces, (16 - len) * 3 + 2);
    offset += (16 - len) * 3 + 2;

    //
    // dump ASCII representation of each character
    //

    for (i = 0; i < len; ++i) {

        char ch;

        ch = Address[i];
        Buffer[offset + i] =  ((ch < 32) || (ch > 127)) ? '.' : ch;
    }

    Buffer[offset + i++] = '\r';
    Buffer[offset + i++] = '\n';
    Buffer[offset + i] = '\0';

    return len;
}


VOID
InternetAssert(
    IN LPSTR Assertion,
    IN LPSTR FileName,
    IN DWORD LineNumber
    )

/*++

Routine Description:

    displays assertion message at debugger and raised breakpoint exception

Arguments:

    Assertion   - string describing assertion which failed

    FileName    - module where assertion failure occurred

    LineNumber  - at this line number

Return Value:

    None.

--*/

{
    char buffer[512];

    rsprintf(buffer, 512,
             "\n"
             "*** WinHttp Assertion failed: %s\n"
             "*** Source file: %s\n"
             "*** Source line: %d\n"
             "*** Thread %08x\n"
             "\n",
             Assertion,
             FileName,
             LineNumber,
             GetCurrentThreadId()
             );
    InternetDebugOut(buffer, TRUE);

    //
    // break to the debugger, unless it is requested that we don't
    //

    if (!(InternetDebugControlFlags & DBG_NO_ASSERT_BREAK)) {
        DebugBreak();
    }
}


VOID
InternetGetDebugVariable(
    IN LPSTR lpszVariableName,
    OUT LPDWORD lpdwVariable
    )

/*++

Routine Description:

    Get debug variable. First examine environment, then registry

Arguments:

    lpszVariableName    - variable name

    lpdwVariable        - returned variable

Return Value:

    None.

--*/

{
    DWORD len;
    char varbuf[ENVIRONMENT_VARIABLE_BUFFER_LENGTH];

    //
    // get the debug variables first from the environment, then - if not there -
    // from the registry
    //

    len = GetEnvironmentVariable(lpszVariableName, varbuf, sizeof(varbuf));
    if (len && len < sizeof(varbuf)) {
        *lpdwVariable = (DWORD)strtoul(varbuf, NULL, 0);
    } else {
        InternetReadRegistryDword(lpszVariableName, lpdwVariable);
    }
}


PRIVATE
VOID
InternetGetDebugVariableString(
    IN LPSTR lpszVariableName,
    OUT LPSTR lpszVariable,
    IN DWORD dwVariableLen
    )

/*++

Routine Description:

    Get debug variable string. First examine environment, then registry

Arguments:

    lpszVariableName    - variable name

    lpszVariable        - returned string variable

    dwVariableLen       - size of buffer

Return Value:

    None.

--*/

{
    if (GetEnvironmentVariable(lpszVariableName, lpszVariable, dwVariableLen) == 0) {

        char buf[MAX_PATH + 1];
        DWORD len = min(sizeof(buf), dwVariableLen);

        if (InternetReadRegistryString(lpszVariableName, buf, &len) == ERROR_SUCCESS) {
            memcpy(lpszVariable, buf, len + 1);
        }
    }
}

LPSTR
InternetMapChunkToken(
    IN CHUNK_TOKEN_VALUE eToken
    )
{
    switch(eToken)
    {
        CASE_OF(CHUNK_TOKEN_DIGIT);
        CASE_OF(CHUNK_TOKEN_DATA);
        CASE_OF(CHUNK_TOKEN_COLON);
        CASE_OF(CHUNK_TOKEN_CR);
        CASE_OF(CHUNK_TOKEN_LF);

        default:
            return "?";

    }
}

LPSTR
InternetMapChunkState(
    IN CHUNK_DECODE_STATE eState
    )
{
    switch(eState)
    {
        CASE_OF(CHUNK_DECODE_STATE_START);
        CASE_OF(CHUNK_DECODE_STATE_SIZE);
        CASE_OF(CHUNK_DECODE_STATE_SIZE_CRLF);
        CASE_OF(CHUNK_DECODE_STATE_EXT);
        CASE_OF(CHUNK_DECODE_STATE_DATA);
        CASE_OF(CHUNK_DECODE_STATE_DATA_CRLF);
        CASE_OF(CHUNK_DECODE_STATE_FOOTER_NAME);
        CASE_OF(CHUNK_DECODE_STATE_FOOTER_VALUE);
        CASE_OF(CHUNK_DECODE_STATE_FINAL_CRLF);
        CASE_OF(CHUNK_DECODE_STATE_ERROR);

        default:
            return "?";

    }
}

#endif


LPSTR
InternetMapError(
    IN DWORD Error
    )

/*++

Routine Description:

    Map error code to string. Try to get all errors that might ever be returned
    by an Internet function

Arguments:

    Error   - code to map

Return Value:

    LPSTR - pointer to symbolic error name

--*/

{
    switch (Error) {

    //
    // WINERROR errors
    //

    CASE_OF(ERROR_SUCCESS);
    CASE_OF(ERROR_INVALID_FUNCTION);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    //CASE_OF(WAIT_ABANDONED_0);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);
    //CASE_OF(STILL_ACTIVE);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);


    //
    // WINHTTP errors
    //

    CASE_OF(ERROR_WINHTTP_OUT_OF_HANDLES);
    CASE_OF(ERROR_WINHTTP_TIMEOUT);
    CASE_OF(ERROR_WINHTTP_INTERNAL_ERROR);
    CASE_OF(ERROR_WINHTTP_INVALID_URL);
    CASE_OF(ERROR_WINHTTP_UNRECOGNIZED_SCHEME);
    CASE_OF(ERROR_WINHTTP_NAME_NOT_RESOLVED);
    CASE_OF(ERROR_WINHTTP_INVALID_OPTION);
    CASE_OF(ERROR_WINHTTP_OPTION_NOT_SETTABLE);
    CASE_OF(ERROR_WINHTTP_SHUTDOWN);
    CASE_OF(ERROR_WINHTTP_INCORRECT_PASSWORD);
    CASE_OF(ERROR_WINHTTP_LOGIN_FAILURE);
    CASE_OF(ERROR_WINHTTP_OPERATION_CANCELLED);
    CASE_OF(ERROR_WINHTTP_INCORRECT_HANDLE_TYPE);
    CASE_OF(ERROR_WINHTTP_INCORRECT_HANDLE_STATE);
    CASE_OF(ERROR_WINHTTP_CANNOT_CONNECT);
    CASE_OF(ERROR_WINHTTP_CONNECTION_ERROR);
    CASE_OF(ERROR_WINHTTP_FORCE_RETRY);
    CASE_OF(ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED);
    CASE_OF(ERROR_WINHTTP_NOT_INITIALIZED);
    CASE_OF(ERROR_WINHTTP_SECURE_FAILURE);

    CASE_OF(ERROR_HTTP_HEADER_NOT_FOUND);
    CASE_OF(ERROR_HTTP_INVALID_SERVER_RESPONSE);
    CASE_OF(ERROR_HTTP_INVALID_QUERY_REQUEST);
    CASE_OF(ERROR_HTTP_HEADER_ALREADY_EXISTS);
    CASE_OF(ERROR_HTTP_REDIRECT_FAILED);
    CASE_OF(ERROR_HTTP_NOT_REDIRECTED);

    //
    // SSPI errors
    //

    CASE_OF(SEC_E_INSUFFICIENT_MEMORY);
    CASE_OF(SEC_E_INVALID_HANDLE);
    CASE_OF(SEC_E_UNSUPPORTED_FUNCTION);
    CASE_OF(SEC_E_TARGET_UNKNOWN);
    CASE_OF(SEC_E_INTERNAL_ERROR);
    CASE_OF(SEC_E_SECPKG_NOT_FOUND);
    CASE_OF(SEC_E_NOT_OWNER);
    CASE_OF(SEC_E_CANNOT_INSTALL);
    CASE_OF(SEC_E_INVALID_TOKEN);
    CASE_OF(SEC_E_CANNOT_PACK);
    CASE_OF(SEC_E_QOP_NOT_SUPPORTED);
    CASE_OF(SEC_E_NO_IMPERSONATION);
    CASE_OF(SEC_E_LOGON_DENIED);
    CASE_OF(SEC_E_UNKNOWN_CREDENTIALS);
    CASE_OF(SEC_E_NO_CREDENTIALS);
    CASE_OF(SEC_E_MESSAGE_ALTERED);
    CASE_OF(SEC_E_OUT_OF_SEQUENCE);
    CASE_OF(SEC_E_NO_AUTHENTICATING_AUTHORITY);
    CASE_OF(SEC_I_CONTINUE_NEEDED);
    CASE_OF(SEC_I_COMPLETE_NEEDED);
    CASE_OF(SEC_I_COMPLETE_AND_CONTINUE);
    CASE_OF(SEC_I_LOCAL_LOGON);
    CASE_OF(SEC_E_BAD_PKGID);
    CASE_OF(SEC_E_CONTEXT_EXPIRED);
    CASE_OF(SEC_E_INCOMPLETE_MESSAGE);


    //
    // WINSOCK errors
    //

    CASE_OF(WSAEINTR);
    CASE_OF(WSAEBADF);
    CASE_OF(WSAEACCES);
    CASE_OF(WSAEFAULT);
    CASE_OF(WSAEINVAL);
    CASE_OF(WSAEMFILE);
    CASE_OF(WSAEWOULDBLOCK);
    CASE_OF(WSAEINPROGRESS);
    CASE_OF(WSAEALREADY);
    CASE_OF(WSAENOTSOCK);
    CASE_OF(WSAEDESTADDRREQ);
    CASE_OF(WSAEMSGSIZE);
    CASE_OF(WSAEPROTOTYPE);
    CASE_OF(WSAENOPROTOOPT);
    CASE_OF(WSAEPROTONOSUPPORT);
    CASE_OF(WSAESOCKTNOSUPPORT);
    CASE_OF(WSAEOPNOTSUPP);
    CASE_OF(WSAEPFNOSUPPORT);
    CASE_OF(WSAEAFNOSUPPORT);
    CASE_OF(WSAEADDRINUSE);
    CASE_OF(WSAEADDRNOTAVAIL);
    CASE_OF(WSAENETDOWN);
    CASE_OF(WSAENETUNREACH);
    CASE_OF(WSAENETRESET);
    CASE_OF(WSAECONNABORTED);
    CASE_OF(WSAECONNRESET);
    CASE_OF(WSAENOBUFS);
    CASE_OF(WSAEISCONN);
    CASE_OF(WSAENOTCONN);
    CASE_OF(WSAESHUTDOWN);
    CASE_OF(WSAETOOMANYREFS);
    CASE_OF(WSAETIMEDOUT);
    CASE_OF(WSAECONNREFUSED);
    CASE_OF(WSAELOOP);
    CASE_OF(WSAENAMETOOLONG);
    CASE_OF(WSAEHOSTDOWN);
    CASE_OF(WSAEHOSTUNREACH);
    CASE_OF(WSAENOTEMPTY);
    CASE_OF(WSAEPROCLIM);
    CASE_OF(WSAEUSERS);
    CASE_OF(WSAEDQUOT);
    CASE_OF(WSAESTALE);
    CASE_OF(WSAEREMOTE);
    CASE_OF(WSAEDISCON);
    CASE_OF(WSASYSNOTREADY);
    CASE_OF(WSAVERNOTSUPPORTED);
    CASE_OF(WSANOTINITIALISED);
    CASE_OF(WSAHOST_NOT_FOUND);
    CASE_OF(WSATRY_AGAIN);
    CASE_OF(WSANO_RECOVERY);
    CASE_OF(WSANO_DATA);

#if 0
    //
    // RAS errors
    //

    CASE_OF(PENDING);
    CASE_OF(ERROR_INVALID_PORT_HANDLE);
    CASE_OF(ERROR_PORT_ALREADY_OPEN);
    CASE_OF(ERROR_BUFFER_TOO_SMALL);
    CASE_OF(ERROR_WRONG_INFO_SPECIFIED);
    CASE_OF(ERROR_CANNOT_SET_PORT_INFO);
    CASE_OF(ERROR_PORT_NOT_CONNECTED);
    CASE_OF(ERROR_EVENT_INVALID);
    CASE_OF(ERROR_DEVICE_DOES_NOT_EXIST);
    CASE_OF(ERROR_BUFFER_INVALID);
    CASE_OF(ERROR_ROUTE_NOT_AVAILABLE);
    CASE_OF(ERROR_ROUTE_NOT_ALLOCATED);
    CASE_OF(ERROR_INVALID_COMPRESSION_SPECIFIED);
    CASE_OF(ERROR_OUT_OF_BUFFERS);
    CASE_OF(ERROR_PORT_NOT_FOUND);
    CASE_OF(ERROR_ASYNC_REQUEST_PENDING);
    CASE_OF(ERROR_ALREADY_DISCONNECTING);
    CASE_OF(ERROR_PORT_NOT_OPEN);
    CASE_OF(ERROR_PORT_DISCONNECTED);
    CASE_OF(ERROR_NO_ENDPOINTS);
    CASE_OF(ERROR_CANNOT_OPEN_PHONEBOOK);
    CASE_OF(ERROR_CANNOT_LOAD_PHONEBOOK);
    CASE_OF(ERROR_CANNOT_FIND_PHONEBOOK_ENTRY);
    CASE_OF(ERROR_CANNOT_WRITE_PHONEBOOK);
    CASE_OF(ERROR_CORRUPT_PHONEBOOK);
    CASE_OF(ERROR_CANNOT_LOAD_STRING);
    CASE_OF(ERROR_KEY_NOT_FOUND);
    CASE_OF(ERROR_DISCONNECTION);
    CASE_OF(ERROR_REMOTE_DISCONNECTION);
    CASE_OF(ERROR_HARDWARE_FAILURE);
    CASE_OF(ERROR_USER_DISCONNECTION);
    CASE_OF(ERROR_INVALID_SIZE);
    CASE_OF(ERROR_PORT_NOT_AVAILABLE);
    CASE_OF(ERROR_CANNOT_PROJECT_CLIENT);
    CASE_OF(ERROR_UNKNOWN);
    CASE_OF(ERROR_WRONG_DEVICE_ATTACHED);
    CASE_OF(ERROR_BAD_STRING);
    CASE_OF(ERROR_REQUEST_TIMEOUT);
    CASE_OF(ERROR_CANNOT_GET_LANA);
    CASE_OF(ERROR_NETBIOS_ERROR);
    CASE_OF(ERROR_SERVER_OUT_OF_RESOURCES);
    CASE_OF(ERROR_NAME_EXISTS_ON_NET);
    CASE_OF(ERROR_SERVER_GENERAL_NET_FAILURE);
    CASE_OF(WARNING_MSG_ALIAS_NOT_ADDED);
    CASE_OF(ERROR_AUTH_INTERNAL);
    CASE_OF(ERROR_RESTRICTED_LOGON_HOURS);
    CASE_OF(ERROR_ACCT_DISABLED);
    CASE_OF(ERROR_PASSWD_EXPIRED);
    CASE_OF(ERROR_NO_DIALIN_PERMISSION);
    CASE_OF(ERROR_SERVER_NOT_RESPONDING);
    CASE_OF(ERROR_FROM_DEVICE);
    CASE_OF(ERROR_UNRECOGNIZED_RESPONSE);
    CASE_OF(ERROR_MACRO_NOT_FOUND);
    CASE_OF(ERROR_MACRO_NOT_DEFINED);
    CASE_OF(ERROR_MESSAGE_MACRO_NOT_FOUND);
    CASE_OF(ERROR_DEFAULTOFF_MACRO_NOT_FOUND);
    CASE_OF(ERROR_FILE_COULD_NOT_BE_OPENED);
    CASE_OF(ERROR_DEVICENAME_TOO_LONG);
    CASE_OF(ERROR_DEVICENAME_NOT_FOUND);
    CASE_OF(ERROR_NO_RESPONSES);
    CASE_OF(ERROR_NO_COMMAND_FOUND);
    CASE_OF(ERROR_WRONG_KEY_SPECIFIED);
    CASE_OF(ERROR_UNKNOWN_DEVICE_TYPE);
    CASE_OF(ERROR_ALLOCATING_MEMORY);
    CASE_OF(ERROR_PORT_NOT_CONFIGURED);
    CASE_OF(ERROR_DEVICE_NOT_READY);
    CASE_OF(ERROR_READING_INI_FILE);
    CASE_OF(ERROR_NO_CONNECTION);
    CASE_OF(ERROR_BAD_USAGE_IN_INI_FILE);
    CASE_OF(ERROR_READING_SECTIONNAME);
    CASE_OF(ERROR_READING_DEVICETYPE);
    CASE_OF(ERROR_READING_DEVICENAME);
    CASE_OF(ERROR_READING_USAGE);
    CASE_OF(ERROR_READING_MAXCONNECTBPS);
    CASE_OF(ERROR_READING_MAXCARRIERBPS);
    CASE_OF(ERROR_LINE_BUSY);
    CASE_OF(ERROR_VOICE_ANSWER);
    CASE_OF(ERROR_NO_ANSWER);
    CASE_OF(ERROR_NO_CARRIER);
    CASE_OF(ERROR_NO_DIALTONE);
    CASE_OF(ERROR_IN_COMMAND);
    CASE_OF(ERROR_WRITING_SECTIONNAME);
    CASE_OF(ERROR_WRITING_DEVICETYPE);
    CASE_OF(ERROR_WRITING_DEVICENAME);
    CASE_OF(ERROR_WRITING_MAXCONNECTBPS);
    CASE_OF(ERROR_WRITING_MAXCARRIERBPS);
    CASE_OF(ERROR_WRITING_USAGE);
    CASE_OF(ERROR_WRITING_DEFAULTOFF);
    CASE_OF(ERROR_READING_DEFAULTOFF);
    CASE_OF(ERROR_EMPTY_INI_FILE);
    CASE_OF(ERROR_AUTHENTICATION_FAILURE);
    CASE_OF(ERROR_PORT_OR_DEVICE);
    CASE_OF(ERROR_NOT_BINARY_MACRO);
    CASE_OF(ERROR_DCB_NOT_FOUND);
    CASE_OF(ERROR_STATE_MACHINES_NOT_STARTED);
    CASE_OF(ERROR_STATE_MACHINES_ALREADY_STARTED);
    CASE_OF(ERROR_PARTIAL_RESPONSE_LOOPING);
    CASE_OF(ERROR_UNKNOWN_RESPONSE_KEY);
    CASE_OF(ERROR_RECV_BUF_FULL);
    CASE_OF(ERROR_CMD_TOO_LONG);
    CASE_OF(ERROR_UNSUPPORTED_BPS);
    CASE_OF(ERROR_UNEXPECTED_RESPONSE);
    CASE_OF(ERROR_INTERACTIVE_MODE);
    CASE_OF(ERROR_BAD_CALLBACK_NUMBER);
    CASE_OF(ERROR_INVALID_AUTH_STATE);
    CASE_OF(ERROR_WRITING_INITBPS);
    CASE_OF(ERROR_X25_DIAGNOSTIC);
    CASE_OF(ERROR_ACCT_EXPIRED);
    CASE_OF(ERROR_CHANGING_PASSWORD);
    CASE_OF(ERROR_OVERRUN);
    CASE_OF(ERROR_RASMAN_CANNOT_INITIALIZE);
    CASE_OF(ERROR_BIPLEX_PORT_NOT_AVAILABLE);
    CASE_OF(ERROR_NO_ACTIVE_ISDN_LINES);
    CASE_OF(ERROR_NO_ISDN_CHANNELS_AVAILABLE);
    CASE_OF(ERROR_TOO_MANY_LINE_ERRORS);
    CASE_OF(ERROR_IP_CONFIGURATION);
    CASE_OF(ERROR_NO_IP_ADDRESSES);
    CASE_OF(ERROR_PPP_TIMEOUT);
    CASE_OF(ERROR_PPP_REMOTE_TERMINATED);
    CASE_OF(ERROR_PPP_NO_PROTOCOLS_CONFIGURED);
    CASE_OF(ERROR_PPP_NO_RESPONSE);
    CASE_OF(ERROR_PPP_INVALID_PACKET);
    CASE_OF(ERROR_PHONE_NUMBER_TOO_LONG);
    CASE_OF(ERROR_IPXCP_NO_DIALOUT_CONFIGURED);
    CASE_OF(ERROR_IPXCP_NO_DIALIN_CONFIGURED);
    CASE_OF(ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE);
    CASE_OF(ERROR_ACCESSING_TCPCFGDLL);
    CASE_OF(ERROR_NO_IP_RAS_ADAPTER);
    CASE_OF(ERROR_SLIP_REQUIRES_IP);
    CASE_OF(ERROR_PROJECTION_NOT_COMPLETE);
    CASE_OF(ERROR_PROTOCOL_NOT_CONFIGURED);
    CASE_OF(ERROR_PPP_NOT_CONVERGING);
    CASE_OF(ERROR_PPP_CP_REJECTED);
    CASE_OF(ERROR_PPP_LCP_TERMINATED);
    CASE_OF(ERROR_PPP_REQUIRED_ADDRESS_REJECTED);
    CASE_OF(ERROR_PPP_NCP_TERMINATED);
    CASE_OF(ERROR_PPP_LOOPBACK_DETECTED);
    CASE_OF(ERROR_PPP_NO_ADDRESS_ASSIGNED);
    CASE_OF(ERROR_CANNOT_USE_LOGON_CREDENTIALS);
    CASE_OF(ERROR_TAPI_CONFIGURATION);
    CASE_OF(ERROR_NO_LOCAL_ENCRYPTION);
    CASE_OF(ERROR_NO_REMOTE_ENCRYPTION);
    CASE_OF(ERROR_REMOTE_REQUIRES_ENCRYPTION);
    CASE_OF(ERROR_IPXCP_NET_NUMBER_CONFLICT);
    CASE_OF(ERROR_INVALID_SMM);
    CASE_OF(ERROR_SMM_UNINITIALIZED);
    CASE_OF(ERROR_NO_MAC_FOR_PORT);
    CASE_OF(ERROR_SMM_TIMEOUT);
    CASE_OF(ERROR_BAD_PHONE_NUMBER);
    CASE_OF(ERROR_WRONG_MODULE);
    CASE_OF(ERROR_INVALID_CALLBACK_NUMBER);
    CASE_OF(ERROR_SCRIPT_SYNTAX);
#endif // 0
    default:
        return "?";
    }
}


LPSTR
InternetMapStatus(
    IN DWORD Status
    )

/*++

Routine Description:

    Convert WINHTTP_CALLBACK_STATUS_ value to symbolic name

Arguments:

    Status  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Status) {
    CASE_OF(WINHTTP_CALLBACK_STATUS_RESOLVING_NAME);
    CASE_OF(WINHTTP_CALLBACK_STATUS_NAME_RESOLVED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER);
    CASE_OF(WINHTTP_CALLBACK_STATUS_SENDING_REQUEST);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REQUEST_SENT);
    CASE_OF(WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_HANDLE_CREATED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REDIRECT);
    CASE_OF(WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_READ_COMPLETE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REQUEST_ERROR);
    CASE_OF(WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE);
    }
    return "?";
}

LPCSTR InternetMapRequestError(DWORD dwResult)
{
    switch(dwResult)
    {
        CASE_OF(API_RECEIVE_RESPONSE);
        CASE_OF(API_QUERY_DATA_AVAILABLE);
        CASE_OF(API_READ_DATA);
        CASE_OF(API_WRITE_DATA);
        CASE_OF(API_SEND_REQUEST);
    }
    return ("?");
}

#ifdef ENABLE_DEBUG

LPSTR
InternetMapSSPIError(
    IN DWORD Status
    )

/*++

Routine Description:

    Convert a SSL/PCT SSPI Error Code to a string.

Arguments:

    Status  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Status) {

    CASE_OF(STATUS_SUCCESS);
    CASE_OF(SEC_E_INSUFFICIENT_MEMORY        );
    CASE_OF(SEC_E_INVALID_HANDLE             );
    CASE_OF(SEC_E_UNSUPPORTED_FUNCTION       );
    CASE_OF(SEC_E_TARGET_UNKNOWN             );
    CASE_OF(SEC_E_INTERNAL_ERROR             );
    CASE_OF(SEC_E_SECPKG_NOT_FOUND           );
    CASE_OF(SEC_E_NOT_OWNER                  );
    CASE_OF(SEC_E_CANNOT_INSTALL             );
    CASE_OF(SEC_E_INVALID_TOKEN              );
    CASE_OF(SEC_E_CANNOT_PACK                );
    CASE_OF(SEC_E_QOP_NOT_SUPPORTED          );
    CASE_OF(SEC_E_NO_IMPERSONATION           );
    CASE_OF(SEC_E_LOGON_DENIED               );
    CASE_OF(SEC_E_UNKNOWN_CREDENTIALS        );
    CASE_OF(SEC_E_NO_CREDENTIALS             );
    CASE_OF(SEC_E_MESSAGE_ALTERED            );
    CASE_OF(SEC_E_OUT_OF_SEQUENCE            );
    CASE_OF(SEC_E_NO_AUTHENTICATING_AUTHORITY);
    CASE_OF(SEC_I_CONTINUE_NEEDED            );
    CASE_OF(SEC_I_COMPLETE_NEEDED            );
    CASE_OF(SEC_I_COMPLETE_AND_CONTINUE      );
    CASE_OF(SEC_I_LOCAL_LOGON                );
    CASE_OF(SEC_E_BAD_PKGID                  );
    CASE_OF(SEC_E_CONTEXT_EXPIRED            );
    CASE_OF(SEC_E_INCOMPLETE_MESSAGE         );
//    CASE_OF(SEC_E_NO_SPM                     );
//    CASE_OF(SEC_E_NOT_SUPPORTED              );

    }
    return "?";
}




LPSTR
InternetMapHttpOption(
    IN DWORD Option
    )

/*++

Routine Description:

    Convert HTTP_QUERY_ option value to symbolic name

Arguments:

    Option  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Option) {
    CASE_OF(HTTP_QUERY_MIME_VERSION);               // 0
    CASE_OF(HTTP_QUERY_CONTENT_TYPE);               // 1
    CASE_OF(HTTP_QUERY_CONTENT_TRANSFER_ENCODING);  // 2
    CASE_OF(HTTP_QUERY_CONTENT_ID);                 // 3
    CASE_OF(HTTP_QUERY_CONTENT_DESCRIPTION);        // 4
    CASE_OF(HTTP_QUERY_CONTENT_LENGTH);             // 5
    CASE_OF(HTTP_QUERY_CONTENT_LANGUAGE);           // 6
    CASE_OF(HTTP_QUERY_ALLOW);                      // 7
    CASE_OF(HTTP_QUERY_PUBLIC);                     // 8
    CASE_OF(HTTP_QUERY_DATE);                       // 9
    CASE_OF(HTTP_QUERY_EXPIRES);                    // 10
    CASE_OF(HTTP_QUERY_LAST_MODIFIED);              // 11
    CASE_OF(HTTP_QUERY_MESSAGE_ID);                 // 12
    CASE_OF(HTTP_QUERY_URI);                        // 13
    CASE_OF(HTTP_QUERY_DERIVED_FROM);               // 14
    CASE_OF(HTTP_QUERY_COST);                       // 15
    CASE_OF(HTTP_QUERY_LINK);                       // 16
    CASE_OF(HTTP_QUERY_PRAGMA);                     // 17
    CASE_OF(HTTP_QUERY_VERSION);                    // 18
    CASE_OF(HTTP_QUERY_STATUS_CODE);                // 19
    CASE_OF(HTTP_QUERY_STATUS_TEXT);                // 20
    CASE_OF(HTTP_QUERY_RAW_HEADERS);                // 21
    CASE_OF(HTTP_QUERY_RAW_HEADERS_CRLF);           // 22
    CASE_OF(HTTP_QUERY_CONNECTION);                 // 23
    CASE_OF(HTTP_QUERY_ACCEPT);                     // 24
    CASE_OF(HTTP_QUERY_ACCEPT_CHARSET);             // 25
    CASE_OF(HTTP_QUERY_ACCEPT_ENCODING);            // 26
    CASE_OF(HTTP_QUERY_ACCEPT_LANGUAGE);            // 27
    CASE_OF(HTTP_QUERY_AUTHORIZATION);              // 28
    CASE_OF(HTTP_QUERY_CONTENT_ENCODING);           // 29
    CASE_OF(HTTP_QUERY_FORWARDED);                  // 30
    CASE_OF(HTTP_QUERY_FROM);                       // 31
    CASE_OF(HTTP_QUERY_IF_MODIFIED_SINCE);          // 32
    CASE_OF(HTTP_QUERY_LOCATION);                   // 33
    CASE_OF(HTTP_QUERY_ORIG_URI);                   // 34
    CASE_OF(HTTP_QUERY_REFERER);                    // 35
    CASE_OF(HTTP_QUERY_RETRY_AFTER);                // 36
    CASE_OF(HTTP_QUERY_SERVER);                     // 37
    CASE_OF(HTTP_QUERY_TITLE);                      // 38
    CASE_OF(HTTP_QUERY_USER_AGENT);                 // 39
    CASE_OF(HTTP_QUERY_WWW_AUTHENTICATE);           // 40
    CASE_OF(HTTP_QUERY_PROXY_AUTHENTICATE);         // 41
    CASE_OF(HTTP_QUERY_ACCEPT_RANGES);              // 42
    CASE_OF(HTTP_QUERY_SET_COOKIE);                 // 43
    CASE_OF(HTTP_QUERY_COOKIE);                     // 44
    CASE_OF(HTTP_QUERY_REQUEST_METHOD);             // 45
    CASE_OF(HTTP_QUERY_REFRESH);                    // 46
    CASE_OF(HTTP_QUERY_CONTENT_DISPOSITION);        // 47
    CASE_OF(HTTP_QUERY_AGE);                        // 48
    CASE_OF(HTTP_QUERY_CACHE_CONTROL);              // 49
    CASE_OF(HTTP_QUERY_CONTENT_BASE);               // 50
    CASE_OF(HTTP_QUERY_CONTENT_LOCATION);           // 51
    CASE_OF(HTTP_QUERY_CONTENT_MD5);                // 52
    CASE_OF(HTTP_QUERY_CONTENT_RANGE);              // 53
    CASE_OF(HTTP_QUERY_ETAG);                       // 54
    CASE_OF(HTTP_QUERY_HOST);                       // 55
    CASE_OF(HTTP_QUERY_IF_MATCH);                   // 56
    CASE_OF(HTTP_QUERY_IF_NONE_MATCH);              // 57
    CASE_OF(HTTP_QUERY_IF_RANGE);                   // 58
    CASE_OF(HTTP_QUERY_IF_UNMODIFIED_SINCE);        // 59
    CASE_OF(HTTP_QUERY_MAX_FORWARDS);               // 60
    CASE_OF(HTTP_QUERY_PROXY_AUTHORIZATION);        // 61
    CASE_OF(HTTP_QUERY_RANGE);                      // 62
    CASE_OF(HTTP_QUERY_TRANSFER_ENCODING);          // 63
    CASE_OF(HTTP_QUERY_UPGRADE);                    // 64
    CASE_OF(HTTP_QUERY_VARY);                       // 65
    CASE_OF(HTTP_QUERY_VIA);                        // 66
    CASE_OF(HTTP_QUERY_WARNING);                    // 67
    CASE_OF(HTTP_QUERY_EXPECT);                     // 68
    CASE_OF(HTTP_QUERY_PROXY_CONNECTION);           // 69
    CASE_OF(HTTP_QUERY_UNLESS_MODIFIED_SINCE);      // 70
    CASE_OF(HTTP_QUERY_ECHO_REQUEST);               // 71
    CASE_OF(HTTP_QUERY_ECHO_REPLY);                 // 72
    CASE_OF(HTTP_QUERY_ECHO_HEADERS);               // 73
    CASE_OF(HTTP_QUERY_ECHO_HEADERS_CRLF);          // 74
    CASE_OF(HTTP_QUERY_CUSTOM);                     // 65535
    }
    return "?";
}


LPSTR
InternetMapHttpState(
    IN WORD State
    )

/*++

Routine Description:

    Convert HTTPREQ_STATE_ to symbolic name

Arguments:

    State   - to map

Return Value:

    LPSTR

--*/

{
    switch (State & ~HTTPREQ_FLAG_MASK)
    {
    CASE_OF(HttpRequestStateCreating);
    CASE_OF(HttpRequestStateOpen);
    CASE_OF(HttpRequestStateRequest);
    CASE_OF(HttpRequestStateResponse);
    CASE_OF(HttpRequestStateObjectData);
    CASE_OF(HttpRequestStateError);
    CASE_OF(HttpRequestStateClosing);
    CASE_OF(HttpRequestStateReopen);
    }
    return "?";
}

LPSTR
InternetMapHttpStateFlag(
    IN WORD Flag
    )

/*++

Routine Description:

    Convert HTTPREQ_STATE_ flag to symbolic name

Arguments:

    Flag    - to map

Return Value:

    LPSTR

--*/

{
    switch (Flag & ~HTTPREQ_FLAG_MASK)
    {
    case HTTPREQ_STATE_ANYTHING_OK:
        return "ANYTHING";

    case HTTPREQ_STATE_CLOSE_OK:
        return "CLOSE";

    case HTTPREQ_STATE_ADD_OK:
        return "ADD";

    case HTTPREQ_STATE_SEND_OK:
        return "SEND";

    case HTTPREQ_STATE_READ_OK:
        return "READ";

    case HTTPREQ_STATE_QUERY_REQUEST_OK:
        return "QUERY_REQUEST";

    case HTTPREQ_STATE_QUERY_RESPONSE_OK:
        return "QUERY_RESPONSE";

    case HTTPREQ_STATE_REUSE_OK:
        return "REUSE";
    }
    return "?";
}


LPSTR
InternetMapAsyncRequest(
    IN AR_TYPE Type
    )

/*++

Routine Description:

    Convert AR_TYPE to symbolic name

Arguments:

    Type    - Async request type

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Type) {
    CASE_OF(AR_INTERNET_CONNECT);
    CASE_OF(AR_INTERNET_OPEN_URL);
    CASE_OF(AR_INTERNET_READ_FILE);
    CASE_OF(AR_INTERNET_WRITE_FILE);
    CASE_OF(AR_INTERNET_QUERY_DATA_AVAILABLE);
    CASE_OF(AR_INTERNET_FIND_NEXT_FILE);
    CASE_OF(AR_FTP_FIND_FIRST_FILE);
    CASE_OF(AR_FTP_GET_FILE);
    CASE_OF(AR_FTP_PUT_FILE);
    CASE_OF(AR_FTP_DELETE_FILE);
    CASE_OF(AR_FTP_RENAME_FILE);
    CASE_OF(AR_FTP_OPEN_FILE);
    CASE_OF(AR_FTP_CREATE_DIRECTORY);
    CASE_OF(AR_FTP_REMOVE_DIRECTORY);
    CASE_OF(AR_FTP_SET_CURRENT_DIRECTORY);
    CASE_OF(AR_FTP_GET_CURRENT_DIRECTORY);
    CASE_OF(AR_GOPHER_FIND_FIRST_FILE);
    CASE_OF(AR_GOPHER_OPEN_FILE);
    CASE_OF(AR_GOPHER_GET_ATTRIBUTE);
    CASE_OF(AR_HTTP_SEND_REQUEST);
    CASE_OF(AR_HTTP_BEGIN_SEND_REQUEST);
    CASE_OF(AR_HTTP_END_SEND_REQUEST);
    CASE_OF(AR_READ_PREFETCH);
    CASE_OF(AR_SYNC_EVENT);
    CASE_OF(AR_TIMER_EVENT);
    CASE_OF(AR_HTTP_REQUEST1);
    CASE_OF(AR_FILE_IO);
    CASE_OF(AR_INTERNET_READ_FILE_EX);
    }
    return "?";
}


LPSTR
InternetMapHandleType(
    IN DWORD HandleType
    )

/*++

Routine Description:

    Map handle type to symbolic name

Arguments:

    HandleType  - from handle object

Return Value:

    LPSTR

--*/

{
    switch (HandleType) {
    CASE_OF(TypeGenericHandle);
    CASE_OF(TypeInternetHandle);
    CASE_OF(TypeFtpConnectHandle);
    CASE_OF(TypeFtpFindHandle);
    CASE_OF(TypeFtpFindHandleHtml);
    CASE_OF(TypeFtpFileHandle);
    CASE_OF(TypeFtpFileHandleHtml);
    CASE_OF(TypeGopherConnectHandle);
    CASE_OF(TypeGopherFindHandle);
    CASE_OF(TypeGopherFindHandleHtml);
    CASE_OF(TypeGopherFileHandle);
    CASE_OF(TypeGopherFileHandleHtml);
    CASE_OF(TypeHttpConnectHandle);
    CASE_OF(TypeHttpRequestHandle);
    CASE_OF(TypeFileRequestHandle);
    CASE_OF(TypeWildHandle);
    }
    return "?";
}


LPSTR
InternetMapScheme(
    IN INTERNET_SCHEME Scheme
    )

/*++

Routine Description:

    Maps INTERNET_SCHEME_ to symbolic name

Arguments:

    Scheme  - to map

Return Value:

    LPSTR

--*/

{
    switch (Scheme) {
    CASE_OF(INTERNET_SCHEME_UNKNOWN);
    CASE_OF(INTERNET_SCHEME_DEFAULT);
    CASE_OF(INTERNET_SCHEME_HTTP);
    CASE_OF(INTERNET_SCHEME_HTTPS);
    }
    return "?";
}


LPSTR
InternetMapOpenType(
    IN DWORD OpenType
    )

/*++

Routine Description:

    Maps INTERNET_OPEN_TYPE_ to symbolic name

Arguments:

    OpenType    - to map

Return Value:

    LPSTR

--*/

{
    switch (OpenType) {
    CASE_OF(WINHTTP_ACCESS_TYPE_NO_PROXY);
    CASE_OF(WINHTTP_ACCESS_TYPE_NAMED_PROXY);
    CASE_OF(WINHTTP_ACCESS_TYPE_DEFAULT_PROXY);
    }
    return "?";
}


LPSTR
InternetMapService(
    IN DWORD Service
    )

/*++

Routine Description:

    Maps INTERNET_SERVICE_ to symbolic name

Arguments:

    Service - to map

Return Value:

    LPSTR

--*/

{
    switch (Service)
    {
        CASE_OF(INTERNET_SERVICE_HTTP);
    }
    return "?";
}

//
// private functions
//


PRIVATE
LPSTR
ExtractFileName(
    IN LPSTR Module,
    OUT LPSTR Buf
    )
{
    LPSTR filename;
    LPSTR extension;
    int   len;

    filename = strrchr(Module, '\\');
    extension = strrchr(Module, '.');
    if (filename) {
        ++filename;
    } else {
        filename = Module;
    }
    if (!extension) {
        extension = filename + strlen(filename);
    }
    len = (int) (extension - filename);
    memcpy(Buf, filename, len);
    Buf[len] = '\0';
    return Buf;
}


PRIVATE
LPSTR
SetDebugPrefix(
    IN LPSTR Buffer, IN DWORD_PTR BufSize
    )
{
	if (BufSize == 0)
		return Buffer;
	else if (BufSize == 1)
	{
		*Buffer = '\0';
		return Buffer;
	}

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

	LPSTR BufTail = Buffer + BufSize;

    //INET_ASSERT(lpThreadInfo != NULL);

    if (!lpThreadInfo) {
        return NULL;
    }

    LPINTERNET_DEBUG_RECORD lpRecord;

    lpRecord = lpThreadInfo->Stack;

    if (InternetDebugControlFlags & DBG_ENTRY_TIME) {
        if ((InternetDebugControlFlags & (DBG_DELTA_TIME | DBG_CUMULATIVE_TIME))
        && lpRecord) {

            DWORD ticks;
            DWORD ticksNow;

            ticksNow = GetTickCountWrap();
            ticks = ticksNow -  ((InternetDebugControlFlags & DBG_CUMULATIVE_TIME)
                                    ? InternetDebugStartTime
                                    : lpRecord->LastTime);

            Buffer += rsprintf(Buffer, BufTail - Buffer,
                               "% 5d.%3d ",
                               ticks / 1000,
                               ticks % 1000
                               );
            if (InternetDebugControlFlags & DBG_DELTA_TIME) {
                lpRecord->LastTime = ticksNow;
            }
        } else {

            SYSTEMTIME timeNow;

            InternetDebugGetLocalTime(&timeNow, NULL);

            Buffer += rsprintf(Buffer, BufTail - Buffer,
                               "%02d:%02d:%02d.%03d ",
                               timeNow.wHour,
                               timeNow.wMinute,
                               timeNow.wSecond,
                               timeNow.wMilliseconds
                               );
        }
    }

/*
    if (InternetDebugControlFlags & DBG_LEVEL_INDICATOR) {
        Buffer += rsprintf(Buffer, );
    }
*/

    if (InternetDebugControlFlags & DBG_THREAD_INFO) {

        //
        // thread id
        //

        Buffer += rsprintf(Buffer, BufTail - Buffer, "%08x", lpThreadInfo->ThreadId);

        //
        // INTERNET_THREAD_INFO address
        //

        if (InternetDebugControlFlags & DBG_THREAD_INFO_ADR) {
            Buffer += rsprintf(Buffer, BufTail - Buffer, ":%08x", lpThreadInfo);
        }

        //
        // ARB address
        //

        //if (InternetDebugControlFlags & DBG_ARB_ADDR) {
        //    Buffer += rsprintf(Buffer, ":%08x", lpThreadInfo->lpArb);
        //}

        //
        // FIBER address
        //

        //if (InternetDebugControlFlags & DBG_FIBER_INFO) {
        //
        //    LPVOID p;
        //
        //    p = (lpThreadInfo->lpArb != NULL)
        //      ? lpThreadInfo->lpArb->Header.lpFiber
        //      : NULL
        //      ;
        //    Buffer += rsprintf(Buffer, ":%08x", p);
        //}

        //
        // async ID
        //

        if (InternetDebugControlFlags & DBG_ASYNC_ID) {
            if (lpThreadInfo->IsAsyncWorkerThread) {
                Buffer += rsprintf(Buffer, BufTail - Buffer, ":<--->");
            } else if (lpThreadInfo->InCallback) {

                //
                // async worker thread calling back into the app; any WinInet
                // API requests during this time treated as though from the
                // app context
                //

                Buffer += rsprintf(Buffer, BufTail - Buffer, ":<c-b>");
            }
            else
            {

                //
                // this is an app thread
                //

                Buffer += rsprintf(Buffer, BufTail - Buffer, ":<app>");
            }
        }

        //
        // request handle
        //

        if (InternetDebugControlFlags & DBG_REQUEST_HANDLE) {
            Buffer += rsprintf(Buffer, BufTail - Buffer, ":%6X", lpThreadInfo->hObject);
        }

		if ((Buffer + 1) == BufTail)
			goto Quit;

        *Buffer++ = ' ';
    }

    if (InternetDebugControlFlags & DBG_CALL_DEPTH) {
        Buffer += rsprintf(Buffer, BufTail - Buffer, "%03d ", lpThreadInfo->CallDepth);
    }

    for (int i = 0; i < lpThreadInfo->IndentIncrement; ++i) {
		if ((Buffer + 1) == BufTail)
			goto Quit;
        *Buffer++ = ' ';
    }

    //
    // if we are not debugging the category - i.e we got here via a requirement
    // to display an error, or we are in a function that does not have a
    // DEBUG_ENTER - then prefix the string with the current function name
    // (obviously misleading if the function doesn't have a DEBUG_ENTER)
    //

    if (lpRecord != NULL) {
        if (!(lpRecord->Category & InternetDebugCategoryFlags)) {
            Buffer += rsprintf(Buffer, BufTail - Buffer, "%s(): ", lpRecord->Function);
        }
    }

Quit:
	*Buffer = '\0';
    return Buffer;
}

int dprintf(char * format, ...) {

    va_list args;
    char buf[PRINTF_STACK_BUFFER_LENGTH];
    int n;

    va_start(args, format);
    n = _sprintf(buf, PRINTF_STACK_BUFFER_LENGTH, format, args);
    va_end(args);
    OutputDebugString(buf);

    return n;
}


LPSTR
SourceFilename(
    LPSTR Filespec
    )
{
    if (!Filespec) {
        return "?";
    }

    LPSTR p;

    if ((p = strrchr(Filespec, '\\')) != NULL) {

        //
        // we want e.g. common\debugmem.cxx, but get
        // common\..\win32\debugmem.cxx. Bah!
        //

        //LPSTR q;
        //
        //if (q = strrchr(p - 1, '\\')) {
        //    p = q;
        //}
    }
    return p ? p + 1 : Filespec;
}

typedef BOOL (* SYMINITIALIZE)(HANDLE, LPSTR, BOOL);
typedef BOOL (* SYMLOADMODULE)(HANDLE, HANDLE, PSTR, PSTR, DWORD, DWORD);
typedef BOOL (* SYMGETSYMFROMADDR)(HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL);
typedef BOOL (* SYMCLEANUP)(HANDLE);

PRIVATE HMODULE hSymLib = NULL;
PRIVATE SYMINITIALIZE pSymInitialize = NULL;
PRIVATE SYMLOADMODULE pSymLoadModule = NULL;
PRIVATE SYMGETSYMFROMADDR pSymGetSymFromAddr = NULL;
PRIVATE SYMCLEANUP pSymCleanup = NULL;


VOID
InitSymLib(
    VOID
    )
{
    if (hSymLib == NULL) {
        hSymLib = LoadLibrary("IMAGEHLP.DLL");
        if (hSymLib != NULL) {
            pSymInitialize = (SYMINITIALIZE)GetProcAddress(hSymLib,
                                                           "SymInitialize"
                                                           );
            pSymLoadModule = (SYMLOADMODULE)GetProcAddress(hSymLib,
                                                           "SymLoadModule"
                                                           );
            pSymGetSymFromAddr = (SYMGETSYMFROMADDR)GetProcAddress(hSymLib,
                                                                   "SymGetSymFromAddr"
                                                                   );
            pSymCleanup = (SYMCLEANUP)GetProcAddress(hSymLib,
                                                     "SymCleanup"
                                                     );
            if (!pSymInitialize
            || !pSymLoadModule
            || !pSymGetSymFromAddr
            || !pSymCleanup) {
                FreeLibrary(hSymLib);
                hSymLib = NULL;
                pSymInitialize = NULL;
                pSymLoadModule = NULL;
                pSymGetSymFromAddr = NULL;
                pSymCleanup = NULL;
                return;
            }
        }
        pSymInitialize(GetCurrentProcess(), NULL, FALSE);
        //SymInitialize(GetCurrentProcess(), NULL, TRUE);
        pSymLoadModule(GetCurrentProcess(), NULL, "WININET.DLL", "WININET", 0, 0);
    }
}


VOID
TermSymLib(
    VOID
    )
{
    if (pSymCleanup) {
        pSymCleanup(GetCurrentProcess());
        FreeLibrary(hSymLib);
    }
}


LPSTR
GetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    )
{
    *Offset = Address;
    if (!pSymGetSymFromAddr) {
        return "";
    }

    //
    // BUGBUG - only one caller at a time please
    //

    static char symBuf[512];

    //((PIMAGEHLP_SYMBOL)symBuf)->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
    ((PIMAGEHLP_SYMBOL)symBuf)->SizeOfStruct = sizeof(symBuf);
    ((PIMAGEHLP_SYMBOL)symBuf)->MaxNameLength = sizeof(symBuf) - sizeof(IMAGEHLP_SYMBOL);
    if (!pSymGetSymFromAddr(GetCurrentProcess(),
                            Address,
                            Offset,
                            (PIMAGEHLP_SYMBOL)symBuf)) {
        ((PIMAGEHLP_SYMBOL)symBuf)->Name[0] = '\0';
    }
    return ((PIMAGEHLP_SYMBOL)symBuf)->Name;
}

#ifndef DONT_RIP
BOOL fRip = TRUE;
#else
BOOL fRip = FALSE;
#endif

#define _TEXTW(x) L##x
#define TEXTW(x)  _TEXTW(x)
#define SZ_MODULE "WINHTTP"
#define ARRAYSIZE(pArray) (sizeof(pArray)/sizeof(pArray[0]))
EXTERN_C const CHAR  FAR c_szRipNoFn[] = SZ_MODULE "  RIP at %s, line %d: (%s)\r\n";
EXTERN_C const WCHAR FAR c_wszRipNoFn[] = TEXTW(SZ_MODULE) L"  RIP at %s, line %d: (%s)\r\n";



static
LPCSTR
_PathFindFileNameA(
    LPCSTR pPath)
{
    LPCSTR pT;

    for (pT = pPath; *pPath; pPath = CharNextA(pPath)) {
        if ((pPath[0] == '\\' || pPath[0] == ':' || pPath[0] == '/')
            && pPath[1] &&  pPath[1] != '\\'  &&   pPath[1] != '/')
            pT = pPath + 1;
    }

    return pT;
}


static
LPCWSTR
_PathFindFileNameW(
    LPCWSTR pPath)
{
    LPCWSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == TEXTW('\\') || pPath[0] == TEXTW(':') || pPath[0] == TEXTW('/'))
            && pPath[1] &&  pPath[1] != TEXTW('\\')  &&   pPath[1] != TEXTW('/'))
            pT = pPath + 1;
    }

    return pT;
}


/*----------------------------------------------------------
Purpose: This function converts a multi-byte string to a
         wide-char string.

         If pszBuf is non-NULL and the converted string can fit in
         pszBuf, then *ppszWide will point to the given buffer.
         Otherwise, this function will allocate a buffer that can
         hold the converted string.

         If pszAnsi is NULL, then *ppszWide will be freed.  Note
         that pszBuf must be the same pointer between the call
         that converted the string and the call that frees the
         string.

Returns: TRUE
         FALSE (if out of memory)

*/
BOOL
UnicodeFromAnsi(
    LPWSTR * ppwszWide,
    LPCSTR pszAnsi,           // NULL to clean up
    LPWSTR pwszBuf,
    int cchBuf)
{
    BOOL bRet;

    // Convert the string?
    if (pszAnsi)
    {
        // Yes; determine the converted string length
        int cch;
        LPWSTR pwsz;
        int cchAnsi = lstrlenA(pszAnsi)+1;

        cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, NULL, 0);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pwszBuf)
        {
            // Yes; allocate space
            cchBuf = cch + 1;
            pwsz = (LPWSTR)LocalAlloc(LPTR, ((cchBuf)*sizeof(WCHAR)));
        }
        else
        {
            // No; use the provided buffer
            pwsz = pwszBuf;
        }

        if (pwsz)
        {
            // Convert the string
            cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, pwsz, cchBuf);
            bRet = (0 < cch);
        }
        else
        {
            bRet = FALSE;
        }

        *ppwszWide = pwsz;
    }
    else
    {
        // No; was this buffer allocated?
        if (*ppwszWide && pwszBuf != *ppwszWide)
        {
            // Yes; clean up
            LocalFree((HLOCAL)*ppwszWide);
            *ppwszWide = NULL;
        }
        bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Displays a RIP string.

Returns: TRUE to debugbreak
*/
BOOL
CcshellRipA(
    LPCSTR pszFile,
    int line,
    LPCSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCSTR psz;
    CHAR ach[256];

    psz = _PathFindFileNameA(pszFile);
    wsprintfA(ach, c_szRipNoFn, psz, line, pszEval);
    OutputDebugStringA(ach);

    if (fRip)
    {
        if (bBreakInside)
        {
            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!
            
            // MSDEV USERS:  This is not the real RIP.  Hit 
            //               Shift-F11 to jump back to the caller.
            SH_DEBUG_BREAK;                                                // ASSERT

            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Displays a RIP string.

*/
BOOL
CcshellRipW(
    LPCWSTR pszFile,
    int line,
    LPCWSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCWSTR psz;
    WCHAR ach[256];

    psz = _PathFindFileNameW(pszFile);

    // If psz == NULL, CharPrevW failed which implies we are running on Win95.  
    // We can get this if we get an assert in some of the W functions in 
    // shlwapi...  Call the A version of assert...
    if (!psz)
    {
        char szFile[MAX_PATH];
        char szEval[256];   // since the total output is thhis size should be enough...

        WideCharToMultiByte(CP_ACP, 0, pszFile, -1, szFile, ARRAYSIZE(szFile), NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, pszEval, -1, szEval, ARRAYSIZE(szEval), NULL, NULL);
        return CcshellRipA(szFile, line, szEval, bBreakInside);
    }

    wsprintfW(ach, c_wszRipNoFn, psz, line, pszEval);
    OutputDebugStringW(ach);

    if (fRip)
    {
        if (bBreakInside)
        {
            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            SH_DEBUG_BREAK;                                                // ASSERT

            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}

EXTERN_C const CHAR  FAR c_szRipMsg[] = SZ_MODULE "  RIP: ";
EXTERN_C const CHAR  FAR c_szNewline[] = "\n";

BOOL
__cdecl 
CcshellRipMsgA(
    BOOL f, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        OutputDebugStringA(c_szRipMsg);

        va_start(vArgs, pszMsg);
        wvsprintfA(ach, pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);

        OutputDebugStringA(c_szNewline);

        if (fRip)
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            SH_DEBUG_BREAK;                                                            // ASSERT
        }
    }
    return FALSE;
}

BOOL
__cdecl
CcshellRipMsgW(
    BOOL f, 
    LPCSTR pszMsg, ...)         // (this is deliberately CHAR)
{
    WCHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        LPWSTR pwsz;
        WCHAR wszBuf[128];
        OutputDebugStringA(c_szRipMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        ach[0] = L'\0';     // In case this fails
        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, ARRAYSIZE(wszBuf)))
        {
            va_start(vArgs, pszMsg);
            wvsprintfW(ach, pwsz, vArgs);
            va_end(vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
        }

        OutputDebugStringW(ach);
        OutputDebugStringA(c_szNewline);

        if (fRip)
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            SH_DEBUG_BREAK;                                                            // ASSERT
        }
    }
    return FALSE;
}

#if defined(i386)


VOID
x86SleazeCallStack(
    OUT LPVOID * lplpvStack,
    IN DWORD dwStackCount,
    IN LPVOID * Ebp
    )

/*++

Routine Description:

    Similar to x86SleazeCallersAddress but gathers a variable number of return
    addresses. We assume all functions have stack frame

Arguments:

    lplpvStack      - pointer to returned array of caller's addresses

    dwStackCount    - number of elements in lplpvStack

    Ebp             - starting Ebp if not 0, else use current stack

Return Value:

    None.

--*/

{
    DWORD my_esp;

    _asm mov my_esp, esp;

    __try {
        if (Ebp == 0) {
            Ebp = (LPVOID *)(&lplpvStack - 2);
        }
        while (dwStackCount--) {
            if (((DWORD)Ebp > my_esp + 0x10000) || ((DWORD)Ebp < my_esp - 0x10000)) {
                break;
            }
            *lplpvStack++ = *(Ebp + 1);
            Ebp = (LPVOID *)*Ebp;
            if (((DWORD)Ebp <= 0x10000)
            || ((DWORD)Ebp >= 0x80000000)
            || ((DWORD)Ebp & 3)
            || ((DWORD)Ebp > my_esp + 0x10000)
            || ((DWORD)Ebp < my_esp - 0x10000)) {
                break;
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
}


VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    )

/*++

Routine Description:

    This is a sleazy function that reads return addresses out of the stack/
    frame pointer (ebp). We pluck out the return address of the function
    that called THE FUNCTION THAT CALLED THIS FUNCTION, and the caller of
    that function. Returning the return address of the function that called
    this function is not interesting to that caller (almost worthy of Sir
    Humphrey Appleby isn't it?)

    Assumes:

        my ebp  =>  | caller's ebp |
                    | caller's eip |
                    | arg #1       | (pCaller)
                    | arg #2       | (pCallersCaller

Arguments:

    pCaller         - place where we return addres of function that called
                      the function that called this function
    pCallersCaller  - place where we return caller of above

Return Value:

    None.

--*/

{

    //
    // this only works on x86 and only if not fpo functions!
    //

    LPVOID* ebp;

    ebp = (PVOID*)&pCaller - 2; // told you it was sleazy
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCaller = *(ebp + 1);
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCallersCaller = *(ebp + 1);
}

#endif // defined(i386)

#endif // ENABLE_DEBUG

INTERNETAPI
BOOL
WINAPI
InternetDebugGetLocalTime(
    OUT SYSTEMTIME * pstLocalTime,
    OUT DWORD      * pdwMicroSec
)
{
    UNREFERENCED_PARAMETER(pdwMicroSec);
#ifndef ENABLE_DEBUG
    // QUICK HACK TO KEEP THINGS CLEAN AND STILL MEASURE WITH HIGH PERFORMANCE
    // COUNTER

    static BOOL pcTested = FALSE;
    static LONGLONG ftInit;  // initial local time
    static LONGLONG pcInit;  // initial perf counter
    static LONGLONG pcFreq;  // perf counter frequency

    if (!pcTested)
    {
        pcTested = TRUE;
        if (QueryPerformanceFrequency ((LARGE_INTEGER *) &pcFreq) && pcFreq)
        {
            QueryPerformanceCounter ((LARGE_INTEGER *) &pcInit);
            SYSTEMTIME st;
            GetLocalTime (&st);
            SystemTimeToFileTime (&st, (FILETIME *) &ftInit);
        }
    }

    if (!pcFreq)
        GetLocalTime (pstLocalTime);
    else
    {
        LONGLONG pcCurrent, ftCurrent;
        QueryPerformanceCounter ((LARGE_INTEGER *) &pcCurrent);
        ftCurrent = ftInit + ((10000000 * (pcCurrent - pcInit)) / pcFreq);
        FileTimeToSystemTime ((FILETIME *) &ftCurrent, pstLocalTime);
    }

    return TRUE;
#else
    if (!pcFreq)
        GetLocalTime (pstLocalTime);
    else
    {
        LONGLONG pcCurrent, ftCurrent;
        QueryPerformanceCounter ((LARGE_INTEGER *) &pcCurrent);
        ftCurrent = ftInit + ((10000000 * (pcCurrent - pcInit)) / pcFreq);
        FileTimeToSystemTime ((FILETIME *) &ftCurrent, pstLocalTime);
    }

    return TRUE;
#endif // ENABLE_DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\debug\rprintf.h ===
/*****************************************************************************
 *
 *  RPRINTF.C   RLF 06/15/89
 *
 *  CONTENTS    rprintf     limited re-entrant version of printf
 *              rsprintf    limited re-entrant version of sprintf
 *              _sprintf    routine which does the work
 *
 *  NOTES       Tab Stops = 4
 *
 *  $Log:   T:/pvcs/h/rprintf.h_v  $
 *
 *	  Rev 1.2   27 Jul 2001 18:25:30   SergeKh
 *	rsprintf and _sprintf signatures modified to support buffer size parameter
 *
 *    Rev 1.1   29 Oct 1989 11:50:16   Richard Firth
 * Added defines for PRINTF and SPRINTF to allow easy modification when MS gets
 * the real thing working for multi-threaded programs
 *
 *    Rev 1.0   29 Aug 1989 20:04:40   RICHARDF
 * Initial revision.
 *
 ****************************************************************************/

#ifdef UNUSED
// UNUSED - causes unneed crt bloat
int cdecl rprintf(char*, ...);
#endif
int cdecl rsprintf(char*, size_t, char*, ...);
int cdecl _sprintf(char*, size_t, char*, va_list);

#define SPRINTF rsprintf
#define PRINTF  rprintf

//#define rsprintf wsprintf
//#define _sprintf wsprintf

#define RPRINTF_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\debug\perfdiag.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    perfdiag.cxx

Abstract:

    Performance diagnostics

    Contents:
        WininetPerfLog
        PerfSleep
        PerfSelect
        PerfWaitForSingleObject
        (CPerfDiag::get_next_record)
        CPerfDiag::CPerfDiag
        CPerfDiag::~CPerfDiag
        CPerfDiag::Log(DWORD, DWORD)
        CPerfDiag::Log(DWORD, DWORD, DWORD, HINTERNET)
        CPerfDiag::Log(DWORD, DWORD, DWORD, DWORD, HINTERNET)
        CPerfDiag::Dump
        (map_perf_event)
        (map_callback_status)
        (map_async_request)
        (map_thread_pri)
        (map_length)

Author:

    Richard L Firth (rfirth) 24-Jan-1997

Revision History:

    24-Jan-1997 rfirth
        Created

--*/

#include <wininetp.h>

#if defined(USE_PERF_DIAG)

#include <perfdiag.hxx>

//
// global data
//

GLOBAL CPerfDiag * GlobalPerfDiag = NULL;
GLOBAL BOOL GlobalDumpPerfToFile = TRUE;

//
// private prototypes
//

PRIVATE LPSTR map_perf_event(DWORD dwEvent);
PRIVATE LPSTR map_callback_status(DWORD dwStatus);
PRIVATE LPSTR map_async_request(DWORD dwRequest);
PRIVATE LPSTR map_thread_pri(DWORD dwPriority);
PRIVATE LPSTR map_length(DWORD dwLength, LPSTR lpBuf);

//
// APIs
//

INTERNETAPI
VOID
WINAPI
WininetPerfLog(
    IN DWORD dwEvent,
    IN DWORD dwInfo1,
    IN DWORD dwInfo2,
    IN HINTERNET hInternet
    ) {
    if (!GlobalPerfDiag) {
        GlobalPerfDiag = New CPerfDiag;
    }
    if (GlobalPerfDiag) {
        GlobalPerfDiag->Log(dwEvent, dwInfo1, dwInfo2, GetCurrentThreadId(), hInternet);
    }
}

//
// functions
//

VOID PerfSleep(DWORD dwMilliseconds) {
    PERF_LOG(PE_YIELD_SLEEP_START);
    Sleep(dwMilliseconds);
    PERF_LOG(PE_YIELD_SLEEP_END);
}

int PerfSelect(int nfds,	
    fd_set FAR * readfds,	
    fd_set FAR * writefds,	
    fd_set FAR * exceptfds,	
    const struct timeval FAR * timeout 	
    ) {
    PERF_LOG(PE_YIELD_SELECT_START);

    int n = _I_select(nfds, readfds, writefds, exceptfds, timeout);

    PERF_LOG(PE_YIELD_SELECT_END);
    return n;
}

DWORD PerfWaitForSingleObject(
    HANDLE hObject,
    DWORD dwTimeout
    ) {
    PERF_LOG(PE_YIELD_OBJECT_WAIT_START);

    DWORD result = WaitForSingleObject(hObject, dwTimeout);

    PERF_LOG(PE_YIELD_OBJECT_WAIT_END);

    return result;
}

//
// private methods
//

LPPERF_INFO CPerfDiag::get_next_record(VOID) {

    if (!m_lpbPerfBuffer || m_bFull) {
        return NULL;
    }

    LPBYTE lpbCurrent;
    LPBYTE lpbNext;
    LPBYTE result;

    do {
        lpbCurrent = m_lpbNext;
        lpbNext = lpbCurrent + sizeof(PERF_INFO);
        result = (LPBYTE)InterlockedExchangePointer((PVOID*)&m_lpbNext, lpbNext);
    } while ((result != (LPBYTE)lpbCurrent) && (lpbCurrent < m_lpbEnd));
    if (lpbCurrent >= m_lpbEnd) {
        m_bFull = TRUE;
        OutputDebugString("*** Wininet performance log is full!\n");
        lpbCurrent = NULL;
    }
    return (LPPERF_INFO)lpbCurrent;
}

//
// public methods
//

CPerfDiag::CPerfDiag() {
    m_lpbPerfBuffer = NULL;
    m_dwPerfBufferLen = 0;
    m_lpbEnd = NULL;
    m_lpbNext = NULL;
    m_bFull = FALSE;
    m_bStarted = FALSE;
    m_bStartFinished = FALSE;
    m_liStartTime.QuadPart = 0i64;
    perf_start();
}

CPerfDiag::~CPerfDiag() {
    free_perf_buffer();
}

VOID CPerfDiag::Log(DWORD dwEvent, DWORD dwInfo) {

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo) {
        Log(dwEvent, dwInfo, 0, lpThreadInfo->ThreadId, lpThreadInfo->hObject);
    }
}

VOID CPerfDiag::Log(DWORD dwEvent, DWORD dwInfo, DWORD dwThreadId, HINTERNET hInternet) {
    Log(dwEvent, dwInfo, 0, dwThreadId, hInternet);
}

VOID CPerfDiag::Log(DWORD dwEvent, DWORD dwInfo, DWORD dwInfo2, DWORD dwThreadId, HINTERNET hInternet) {

    //if (!m_bStarted) {
    //    perf_start();
    //}

    LPPERF_INFO lpInfo = get_next_record();

    if (!lpInfo) {
        return;
    }

    lpInfo->hInternet = hInternet;
    lpInfo->dwThreadId = dwThreadId;
    lpInfo->dwThreadPriority = GetThreadPriority(GetCurrentThread());
    lpInfo->dwEvent = dwEvent;
    lpInfo->dwInfo = dwInfo;
    lpInfo->dwInfo2 = dwInfo2;
    get_time(lpInfo);
}

VOID CPerfDiag::Dump(VOID) {

    HANDLE hFile = INVALID_HANDLE_VALUE;
    static const char PerfFileName[] = "WININET.PRF";

    if (GlobalDumpPerfToFile) {
        hFile = CreateFile((LPCSTR)PerfFileName,
                           GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           INVALID_HANDLE_VALUE
                           );
        if (hFile == INVALID_HANDLE_VALUE) {
            OutputDebugString("failed to create perf file ");
            OutputDebugString((LPCSTR)PerfFileName);
            OutputDebugString("\n");
            GlobalDumpPerfToFile = FALSE;
        }
    }

    LARGE_INTEGER liFrequency;
    LONGLONG div1;
    LONGLONG div2;

    QueryPerformanceFrequency(&liFrequency);
    div1 = liFrequency.QuadPart;
    div2 = div1 / 1000000;

    LPPERF_INFO lpInfo;
    int record = 1;

    for (lpInfo = (LPPERF_INFO)m_lpbPerfBuffer; lpInfo != (LPPERF_INFO)m_lpbNext; ++lpInfo) {

        char buf[1024];
        LONGLONG ticks;
        DWORD microseconds;
        DWORD seconds;
        DWORD minutes;

        ticks = lpInfo->liTime.QuadPart - m_liStartTime.QuadPart;
        seconds = (DWORD)(ticks / div1);
        microseconds = (DWORD)((ticks % div1) / div2);

        //
        // don't understand why I have to do this? Win95 only (you could have guessed)
        // rounding error?
        //

        while (microseconds >= 1000000) {
            microseconds -= 1000000;
            ++seconds;
        }
        minutes = seconds / 60;
        seconds = seconds % 60;

        char lenbuf[32];
        char lenbuf2[32];

        int nChars = wsprintf(buf,
                              "%5d: Delta=%.2d:%.2d.%.6d TID=%08x Pri=%-8s hReq=%06x Info=%08x %-24s %-22s %s\r\n",
                              record,
                              minutes,
                              seconds,
                              microseconds,
                              lpInfo->dwThreadId,
                              map_thread_pri(lpInfo->dwThreadPriority),
                              lpInfo->hInternet,
                              lpInfo->dwInfo,
                              map_perf_event(lpInfo->dwEvent),
                              ((lpInfo->dwEvent == PE_APP_CALLBACK_START)
                              || (lpInfo->dwEvent == PE_APP_CALLBACK_END))
                                 ? map_callback_status(lpInfo->dwInfo)
                              : (((lpInfo->dwEvent == PE_WORKER_REQUEST_START)
                              || (lpInfo->dwEvent == PE_WORKER_REQUEST_END)
                              || (lpInfo->dwEvent == PE_CLIENT_REQUEST_START)
                              || (lpInfo->dwEvent == PE_CLIENT_REQUEST_END)
                              || (lpInfo->dwEvent == PE_CLIENT_REQUEST_QUEUED))
                                 ? map_async_request(lpInfo->dwInfo)
                              : (((lpInfo->dwEvent == PE_SEND_END)
                              || (lpInfo->dwEvent == PE_RECEIVE_END))
                                 ? map_length(lpInfo->dwInfo2, lenbuf)
                              : (((lpInfo->dwEvent == PE_ENTER_PATH)
                              || (lpInfo->dwEvent == PE_LEAVE_PATH)
                              || (lpInfo->dwEvent == PE_TRACE_PATH))
                                 ? (LPSTR)lpInfo->dwInfo2
                                 : ""))),
                              (((lpInfo->dwEvent == PE_CLIENT_REQUEST_END)
                              || (lpInfo->dwEvent == PE_WORKER_REQUEST_END))
                              && ((lpInfo->dwInfo == AR_INTERNET_READ_FILE)
                              || (lpInfo->dwInfo == AR_INTERNET_QUERY_DATA_AVAILABLE)))
                                 ? map_length(lpInfo->dwInfo2, lenbuf2)
                                 : ""
                             );
        if (GlobalDumpPerfToFile) {

            DWORD nWritten;

            WriteFile(hFile, buf, nChars, &nWritten, NULL);
        } else {
            OutputDebugString(buf);
        }
        ++record;
    }
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }
}


PRIVATE LPSTR map_perf_event(DWORD dwEvent) {
    switch (dwEvent) {
    case PE_START:                      return "START";
    case PE_END:                        return "END";
    case PE_CLIENT_REQUEST_START:       return "CLIENT_REQUEST_START";
    case PE_CLIENT_REQUEST_END:         return "CLIENT_REQUEST_END";
    case PE_CLIENT_REQUEST_QUEUED:      return "CLIENT_REQUEST_QUEUED";
    case PE_WORKER_REQUEST_START:       return "WORKER_REQUEST_START";
    case PE_WORKER_REQUEST_END:         return "WORKER_REQUEST_END";
    case PE_APP_CALLBACK_START:         return "APP_CALLBACK_START";
    case PE_APP_CALLBACK_END:           return "APP_CALLBACK_END";
    case PE_NAMERES_START:              return "NAMERES_START";
    case PE_NAMERES_END:                return "NAMERES_END";
    case PE_CONNECT_START:              return "CONNECT_START";
    case PE_CONNECT_END:                return "CONNECT_END";
    case PE_SEND_START:                 return "SEND_START";
    case PE_SEND_END:                   return "SEND_END";
    case PE_RECEIVE_START:              return "RECEIVE_START";
    case PE_RECEIVE_END:                return "RECEIVE_END";
    case PE_PEEK_RECEIVE_START:         return "PEEK_RECEIVE_START";
    case PE_PEEK_RECEIVE_END:           return "PEEK_RECEIVE_END";
    case PE_SOCKET_CLOSE_START:         return "SOCKET_CLOSE_START";
    case PE_SOCKET_CLOSE_END:           return "SOCKET_CLOSE_END";
    case PE_ACQUIRE_KEEP_ALIVE:         return "ACQUIRE_KEEP_ALIVE";
    case PE_RELEASE_KEEP_ALIVE:         return "RELEASE_KEEP_ALIVE";
    case PE_SOCKET_ERROR:               return "SOCKET_ERROR";
    case PE_CACHE_READ_CHECK_START:     return "CACHE_READ_CHECK_START";
    case PE_CACHE_READ_CHECK_END:       return "CACHE_READ_CHECK_END";
    case PE_CACHE_WRITE_CHECK_START:    return "CACHE_WRITE_CHECK_START";
    case PE_CACHE_WRITE_CHECK_END:      return "CACHE_WRITE_CHECK_END";
    case PE_CACHE_RETRIEVE_START:       return "CACHE_RETRIEVE_START";
    case PE_CACHE_RETRIEVE_END:         return "CACHE_RETRIEVE_END";
    case PE_CACHE_READ_START:           return "CACHE_READ_START";
    case PE_CACHE_READ_END:             return "CACHE_READ_END";
    case PE_CACHE_WRITE_START:          return "CACHE_WRITE_START";
    case PE_CACHE_WRITE_END:            return "CACHE_WRITE_END";
    case PE_CACHE_CREATE_FILE_START:    return "CACHE_CREATE_FILE_START";
    case PE_CACHE_CREATE_FILE_END:      return "CACHE_CREATE_FILE_END";
    case PE_CACHE_CLOSE_FILE_START:     return "CACHE_CLOSE_FILE_START";
    case PE_CACHE_CLOSE_FILE_END:       return "CACHE_CLOSE_FILE_END";
    case PE_CACHE_EXPIRY_CHECK_START:   return "CACHE_EXPIRY_CHECK_START";
    case PE_CACHE_EXPIRY_CHECK_END:     return "CACHE_EXPIRY_CHECK_END";
    case PE_YIELD_SELECT_START:         return "YIELD_SELECT_START";
    case PE_YIELD_SELECT_END:           return "YIELD_SELECT_END";
    case PE_YIELD_OBJECT_WAIT_START:    return "YIELD_OBJECT_WAIT_START";
    case PE_YIELD_OBJECT_WAIT_END:      return "YIELD_OBJECT_WAIT_END";
    case PE_YIELD_SLEEP_START:          return "YIELD_SLEEP_START";
    case PE_YIELD_SLEEP_END:            return "YIELD_SLEEP_END";
    case PE_TRACE:                      return "TRACE";
    case PE_ENTER_PATH:                 return "ENTER_PATH";
    case PE_LEAVE_PATH:                 return "LEAVE_PATH";
    case PE_TRACE_PATH:                 return "TRACE_PATH";
    }
    return "?";
}

PRIVATE LPSTR map_callback_status(DWORD dwStatus) {
    switch (dwStatus) {
    case WINHTTP_CALLBACK_STATUS_RESOLVING_NAME:        return "RESOLVING_NAME";
    case WINHTTP_CALLBACK_STATUS_NAME_RESOLVED:         return "NAME_RESOLVED";
    case WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER:  return "CONNECTING_TO_SERVER";
    case WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER:   return "CONNECTED_TO_SERVER";
    case WINHTTP_CALLBACK_STATUS_SENDING_REQUEST:       return "SENDING_REQUEST";
    case WINHTTP_CALLBACK_STATUS_REQUEST_SENT:          return "REQUEST_SENT";
    case WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE:    return "RECEIVING_RESPONSE";
    case WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED:     return "RESPONSE_RECEIVED";
    case WINHTTP_CALLBACK_STATUS_CTL_RESPONSE_RECEIVED: return "CTL_RESPONSE_RECEIVED";
    case WINHTTP_CALLBACK_STATUS_PREFETCH:              return "PREFETCH";
    case WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION:    return "CLOSING_CONNECTION";
    case WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED:     return "CONNECTION_CLOSED";
    case WINHTTP_CALLBACK_STATUS_HANDLE_CREATED:        return "HANDLE_CREATED";
    case WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING:        return "HANDLE_CLOSING";
    case WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE:      return "REQUEST_COMPLETE";
    case WINHTTP_CALLBACK_STATUS_REDIRECT:              return "REDIRECT";
    case WINHTTP_CALLBACK_STATUS_STATE_CHANGE:          return "STATE_CHANGE";
    case WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE:     return "HEADERS_AVAILABLE";
    case WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE:        return "DATA_AVAILABLE";
    case WINHTTP_CALLBACK_STATUS_READ_COMPLETE:         return "READ_COMPLETE";
    case WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE:        return "WRITE_COMPLETE";
    case WINHTTP_CALLBACK_STATUS_REQUEST_ERROR:         return "REQUEST_ERROR";
    }
    return "?";
}

PRIVATE LPSTR map_async_request(DWORD dwRequest) {
    switch (dwRequest) {
    case AR_INTERNET_CONNECT:               return "InternetConnect";
    case AR_INTERNET_OPEN_URL:              return "InternetOpenUrl";
    case AR_INTERNET_READ_FILE:             return "InternetReadFile";
    case AR_INTERNET_WRITE_FILE:            return "InternetWriteFile";
    case AR_INTERNET_QUERY_DATA_AVAILABLE:  return "InternetQueryDataAvailable";
    case AR_INTERNET_FIND_NEXT_FILE:        return "InternetFindNextFile";
    case AR_FTP_FIND_FIRST_FILE:            return "FtpFindFirstFile";
    case AR_FTP_GET_FILE:                   return "FtpGetFile";
    case AR_FTP_PUT_FILE:                   return "FtpPutFile";
    case AR_FTP_DELETE_FILE:                return "FtpDeleteFile";
    case AR_FTP_RENAME_FILE:                return "FtpRenameFile";
    case AR_FTP_OPEN_FILE:                  return "FtpOpenFile";
    case AR_FTP_CREATE_DIRECTORY:           return "FtpCreateDirectory";
    case AR_FTP_REMOVE_DIRECTORY:           return "FtpRemoveDirectory";
    case AR_FTP_SET_CURRENT_DIRECTORY:      return "FtpSetCurrentDirectory";
    case AR_FTP_GET_CURRENT_DIRECTORY:      return "FtpGetCurrentDirectory";
    case AR_GOPHER_FIND_FIRST_FILE:         return "GopherFindFirstFile";
    case AR_GOPHER_OPEN_FILE:               return "GopherOpenFile";
    case AR_GOPHER_GET_ATTRIBUTE:           return "GopherGetAttribute";
    case AR_HTTP_SEND_REQUEST:              return "HttpSendRequest";
    case AR_READ_PREFETCH:                  return "READ_PREFETCH";
    case AR_SYNC_EVENT:                     return "SYNC_EVENT";
    case AR_TIMER_EVENT:                    return "TIMER_EVENT";
    }
    return "?";
}

PRIVATE LPSTR map_thread_pri(DWORD dwPriority) {
    switch (dwPriority) {
    case THREAD_PRIORITY_ABOVE_NORMAL:
        return "ABOVE";

    case THREAD_PRIORITY_BELOW_NORMAL:
        return "BELOW";

    case THREAD_PRIORITY_HIGHEST:
        return "HIGHEST";

    case THREAD_PRIORITY_IDLE:
        return "IDLE";

    case THREAD_PRIORITY_LOWEST:
        return "LOWEST";

    case THREAD_PRIORITY_NORMAL:
        return "NORMAL";

    case THREAD_PRIORITY_TIME_CRITICAL:
        return "TIMECRIT";
    }
    return "?";
}

PRIVATE LPSTR map_length(DWORD dwLength, LPSTR lpBuf) {
    wsprintf(lpBuf, "%d", dwLength);
    return lpBuf;
}

#endif // defined(USE_PERF_DIAG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\debug\memalloc.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    memalloc.cxx

Abstract:

    Debug-only memory allocation routines

    Contents:
        InetInitializeDebugMemoryPackage
        InetTerminateDebugMemoryPackage
        InetAllocateMemory
        InetReallocateMemory
        (InetIsBlockMoveable)
        InetFreeMemory
        (InetCheckBlockConsistency)
        InetLockMemory
        InetUnlockMemory
        InetMemorySize
        InetCheckDebugMemoryFreed
        (x86SleazeCallersAddress)

Author:

     Richard L Firth (rfirth) 02-Feb-1995

Environment:

    Win32 user mode

Revision History:

    02-Feb-1995
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

#if INET_DEBUG

//
// manifests
//

#define HEADER_SIGNATURE    0x414d454d  // 'MEMA'
#define FOOTER_SIGNATURE    0x434f4c4c  // 'LLOC'
#define DWORD_FILL          0xa9a9a9a9
#define BYTE_FILL           0xa9
#define BYTE_FILL_EXTRA     0xcb
#define GUARD_DWORD_FILL    0xcccd21f4
#define DWORD_FREE_FILL     0xb7b7b7b7
#define BYTE_FREE_FILL      0xb7

//
// private types
//

typedef struct {

    //
    // hMoveable - local handle of moveable memory that this tag links
    //

    HLOCAL hMoveable;

} DEBUG_MOVEABLE_TAG, *LPDEBUG_MOVEABLE_TAG;

typedef struct {

    //
    // List - maintains a list of allocated blocks
    //

    LIST_ENTRY List;

    //
    // BlockLength - the size of this block, *including* all headers, footers
    // and padding
    //

    UINT BlockLength;

    //
    // RealLength - the original caller request
    //

    UINT RealLength;

    //
    // Signature - just used as a sanity check to ensure that what we are
    // dealing with is actually a block we allocated
    //

    DWORD Signature;

    //
    // LockCount - if this is moveable memory, keeps the number of times this
    // block has been locked
    //

    LONG LockCount;

    //
    // Flags - what type of memory this is, etc.
    //

    DWORD Flags;

    //
    // LastAccessOperation - the operation caller at LastAccessReturnAddress
    // performed
    //

    MEMALLOC_ACTION LastAccessOperation;

    //
    // LastAccessReturnAddress - caller of last function to perform memory
    // function operation (alloc, lock, realloc, unlock, etc) on this block
    //

    LPVOID LastAccessReturnAddress[2];

    //
    // CreatorReturnAddress - return EIP (x86-only) of caller of allocator
    // and caller of caller
    //

    LPVOID CreatorReturnAddress[2];

    //
    // Tag - if this is moveable memory, we can't add this block to the allocated
    // block list, we have to allocate a DEBUG_MOVEABLE_TAG, link that and point
    // to it from here
    //

    LPDEBUG_MOVEABLE_TAG Tag;

    //
    // Guard - just a sentinel to find out if the caller is writing before the
    // start of this block
    //

    DWORD Guard[4];

    //
    // sizeof(MEMORY_SIGNATURE) currently 17 DWORDs
    //

} DEBUG_MEMORY_HEADER, *LPDEBUG_MEMORY_HEADER;

typedef struct {

    //
    // Guard - allows us to determine if the end of allocated memory was
    // overwritten
    //

    DWORD Guard[4];

    //
    // Signature - should be the footer signature
    //

    DWORD Signature;

    //
    // BlockLength - should be the same as the header
    //

    DWORD BlockLength;

    //
    // Guard2 - to make sure the end of the block is coherent
    //

    DWORD Guard2[2];

    //
    // sizeof(DEBUG_MEMORY_FOOTER) currently 8 DWORDs
    //

} DEBUG_MEMORY_FOOTER, *LPDEBUG_MEMORY_FOOTER;

//
// data
//

LONG ActualMemoryAllocated = 0;
LONG BlockLengthAllocated = 0;
LONG RealLengthAllocated = 0;
DWORD MemoryAllocations = 0;
DWORD MemoryFrees = 0;
SERIALIZED_LIST AllocatedBlockList;

//
// macros
//

#if defined(i386)

#define GET_CALLERS_ADDRESS(p, pp)  x86SleazeCallersAddress(p, pp)

#else

#define GET_CALLERS_ADDRESS(p, pp)

#endif // defined(i386)

//
// private prototypes
//

PRIVATE
BOOL
InetIsBlockMoveable(
    IN HLOCAL hLocal
    );

PRIVATE
VOID
InetCheckBlockConsistency(
    IN LPVOID lpMemory
    );

PRIVATE
VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    );

//
// functions
//


VOID
InetInitializeDebugMemoryPackage(
    VOID
    )

/*++

Routine Description:

    Just initializes data items in this module

Arguments:

    None.

Return Value:

    None.

--*/

{
    static BOOL MemoryPackageInitialized = FALSE;

    if (!MemoryPackageInitialized) {
        InitializeSerializedList(&AllocatedBlockList);
        MemoryPackageInitialized = TRUE;
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("Memory package already initialized\n"
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
}


VOID
InetTerminateDebugMemoryPackage(
    VOID
    )

/*++

Routine Description:

    Undoes any resource allocation in InetInitializeDebugMemoryPackage, after
    checking that all memory is freed

Arguments:

    None.

Return Value:

    None.

--*/

{
    InetCheckDebugMemoryFreed();
    TerminateSerializedList(&AllocatedBlockList);
}


HLOCAL
InetAllocateMemory(
    IN UINT LocalAllocFlags,
    IN UINT NumberOfBytes
    )

/*++

Routine Description:

    Debug memory allocator: allocates memory with head & tail. Fills memory
    with signature unless otherwise requested. If this is moveable memory
    then the caller must lock the memory with InetLockMemory(), else a pointer
    will be returned to the head of the heap's real start-of-block, and the
    caller will probably nuke the signature contents (but we should discover
    this when the block is freed)

Arguments:

    LocalAllocFlags - flags to be passed on to LocalAlloc
    NumberOfBytes   - to allocate for caller

Return Value:

    LPVOID
        Success - pointer to memory after DEBUG_MEMORY_HEADER
        Failure - NULL

--*/

{
    HLOCAL hLocal;
    UINT blockLength;
    BOOL isMoveable;

    isMoveable = (LocalAllocFlags & LMEM_MOVEABLE) ? TRUE : FALSE;
    blockLength = ROUND_UP_DWORD(NumberOfBytes)
                + sizeof(DEBUG_MEMORY_HEADER)
                + sizeof(DEBUG_MEMORY_FOOTER)
                ;

    //
    // possible problem: if NumberOfBytes + signatures would overflow UINT.
    // Only really problematic on 16-bit platforms
    //

    if (blockLength < NumberOfBytes) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("can't allocate %lu bytes: would overflow\n",
                    (DWORD)NumberOfBytes
                    ));

        DEBUG_BREAK(MEMALLOC);

        return (HLOCAL)NULL;
    }

    hLocal = LocalAlloc(LocalAllocFlags, blockLength);
    if (hLocal != NULL) {

        LPVOID lpMem;
        LPDEBUG_MEMORY_HEADER lpHeader;
        DWORD dwFiller;
        BYTE bFiller;
        UINT dwFillLength;
        UINT bFillLength1;
        UINT bFillLength2;
        UINT i;
        LPVOID userPointer;

        ActualMemoryAllocated += LocalSize(hLocal);
        BlockLengthAllocated += blockLength;
        RealLengthAllocated += NumberOfBytes;
        ++MemoryAllocations;

        if (isMoveable) {
            lpMem = (LPVOID)LocalLock(hLocal);
            if (lpMem == NULL) {

                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("LocalLock(%x) failed: %d\n",
                            hLocal,
                            GetLastError()
                            ));

                DEBUG_BREAK(MEMALLOC);

            }
        } else {
            lpMem = (LPVOID)hLocal;
        }

        lpHeader = (LPDEBUG_MEMORY_HEADER)lpMem;
        InitializeListHead(&lpHeader->List);
        lpHeader->BlockLength = blockLength;
        lpHeader->RealLength = NumberOfBytes;
        lpHeader->Signature = HEADER_SIGNATURE;
        lpHeader->LockCount = 0;
        lpHeader->Flags = LocalAllocFlags;

        GET_CALLERS_ADDRESS(&lpHeader->CreatorReturnAddress[0],
                            &lpHeader->CreatorReturnAddress[1]
                            );

        lpHeader->LastAccessOperation = MemAllocate;

        for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
            lpHeader->Guard[i] = GUARD_DWORD_FILL;
        }

        if (LocalAllocFlags & LMEM_ZEROINIT) {
            dwFiller = 0;
            bFiller = 0;
        } else {
            dwFiller = DWORD_FILL;
            bFiller = BYTE_FILL;
        }
        dwFillLength = NumberOfBytes / sizeof(DWORD);
        bFillLength1 = NumberOfBytes % sizeof(DWORD);
        bFillLength2 = bFillLength1 ? (sizeof(DWORD) - bFillLength1) : 0;
        userPointer = (LPVOID)(lpHeader + 1);

        LPDWORD lpdwUserPointer = (LPDWORD)userPointer;

        for (i = 0; i < dwFillLength; ++i) {
            *lpdwUserPointer++ = dwFiller;
        }

        LPBYTE lpbUserPointer = (LPBYTE)lpdwUserPointer;

        for (i = 0; i < bFillLength1; ++i) {
            *lpbUserPointer++ = bFiller;
        }
        for (i = 0; i < bFillLength2; ++i) {
            *lpbUserPointer++ = BYTE_FILL_EXTRA;
        }

        userPointer = (LPVOID)lpbUserPointer;

        for (i = 0; i < ARRAY_ELEMENTS(((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard); ++i) {
            ((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard[i] = GUARD_DWORD_FILL;
        }
        ((LPDEBUG_MEMORY_FOOTER)userPointer)->BlockLength = blockLength;
        ((LPDEBUG_MEMORY_FOOTER)userPointer)->Signature = FOOTER_SIGNATURE;
        for (i = 0; i < ARRAY_ELEMENTS(((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard2); ++i) {
            ((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard2[i] = GUARD_DWORD_FILL;
        }

        //
        // if this is moveable memory, then we can't link it into the allocated
        // block list because if it moves, the list gets nuked. So we have to
        // allocate a DEBUG_MOVEABLE_TAG, link that and point to it from here
        //

        if (isMoveable) {

            LPDEBUG_MOVEABLE_TAG lpTag;

            lpTag = (LPDEBUG_MOVEABLE_TAG)InetAllocateMemory(LMEM_FIXED, sizeof(DEBUG_MOVEABLE_TAG));

            INET_ASSERT(lpTag != NULL);

            lpTag->hMoveable = hLocal;
            lpHeader->Tag = lpTag;
        } else {
            if (!InsertAtHeadOfSerializedList(&AllocatedBlockList, &lpHeader->List)) {
                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("InetAllocateMemory(%x): Unable to insert to allocated block list\n",
                            hLocal
                            ));

                DEBUG_BREAK(MEMALLOC);
            }
        }

        if (isMoveable) {
            if (LocalUnlock(hLocal)) {

                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("LocalUnlock(%x): memory still locked\n",
                            hLocal
                            ));

                DEBUG_BREAK(MEMALLOC);

            } else {

                DWORD err;

                err = GetLastError();
                if (err != NO_ERROR) {

                    DEBUG_PRINT(MEMALLOC,
                                ERROR,
                                ("LocalUnlock(%x) returns %d\n",
                                hLocal,
                                err
                                ));

                    DEBUG_BREAK(MEMALLOC);

                }
            }
        } else {
            hLocal = (HLOCAL)(lpHeader + 1);
        }
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to allocate %u bytes memory\n",
                    blockLength
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
    return hLocal;
}


HLOCAL
InetReallocateMemory(
    IN HLOCAL hLocal,
    IN UINT Size,
    IN UINT Flags,
    IN BOOL IsMoveable
    )

/*++

Routine Description:

    Reallocates previously allocated block

    BUGBUG - this doesn't handle the more exotic LocalReAlloc stuff, like
             DISCARDABLE memory, allocating/freeing through realloc etc

Arguments:

    hLocal      - block to reallocate
    Size        - new size
    Flags       - new flags
    IsMoveable  - TRUE if this is moveable memory. We need this help because
                  there is no good way to find out from hLocal whether this
                  memory is moveable or fixed

Return Value:

    HLOCAL

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader;
    UINT realLength;
    UINT heapLength;

    //
    // can't handle reallocating down to zero
    //

    INET_ASSERT(Size != 0);

    if (IsMoveable) {
        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);
        heapLength = LocalSize(hLocal);
    } else {
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;
        heapLength = LocalSize((HLOCAL)lpHeader);
    }

    InetCheckBlockConsistency((LPVOID)lpHeader);

    if (IsMoveable) {
        LocalUnlock(hLocal);
    }

    realLength = Size;

    Size = ROUND_UP_DWORD(Size)
         + sizeof(DEBUG_MEMORY_HEADER)
         + sizeof(DEBUG_MEMORY_FOOTER)
         ;

    ActualMemoryAllocated -= heapLength;
    BlockLengthAllocated -= lpHeader->BlockLength;
    RealLengthAllocated -= lpHeader->RealLength;

    hLocal = LocalReAlloc(hLocal, Size, Flags);
    if (hLocal != NULL) {

        LPBYTE extraPointer;
        UINT extraLength;
        UINT i;
        LPDEBUG_MEMORY_FOOTER lpFooter;

        if (IsMoveable) {
            lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);
        } else {
            lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;
        }

        lpHeader->BlockLength = Size;
        lpHeader->RealLength = realLength;
        lpHeader->Flags = Flags;

        GET_CALLERS_ADDRESS(&lpHeader->LastAccessReturnAddress[0],
                            &lpHeader->LastAccessReturnAddress[1]
                            );

        lpHeader->LastAccessOperation = MemReallocate;

        extraPointer = (LPBYTE)(lpHeader + 1) + realLength;
        extraLength = (sizeof(DWORD) - (realLength % sizeof(DWORD)))
                    & (sizeof(DWORD) - 1)
                    ;
        for (i = 0; i < extraLength; ++i) {
            *extraPointer++ = BYTE_FILL_EXTRA;
        }
        lpFooter = (LPDEBUG_MEMORY_FOOTER)((LPBYTE)(lpHeader + 1)
                 + ROUND_UP_DWORD(realLength)
                 );
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
            lpFooter->Guard[i] = GUARD_DWORD_FILL;
        }
        lpFooter->Signature = FOOTER_SIGNATURE;
        lpFooter->BlockLength = Size;
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
            lpFooter->Guard2[i] = GUARD_DWORD_FILL;
        }
        ActualMemoryAllocated += LocalSize(hLocal);
        BlockLengthAllocated += Size;
        RealLengthAllocated += lpHeader->RealLength;
        if (IsMoveable) {
            LocalUnlock(hLocal);
        } else {
            hLocal = (HLOCAL)(lpHeader + 1);
        }
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to reallocate %u bytes memory. Last error = %d\n",
                    Size,
                    GetLastError()
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
    return hLocal;
}


PRIVATE
BOOL
InetIsBlockMoveable(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Determines if hLocal is moveable or fixed memory

Arguments:

    hLocal  -

Return Value:

    BOOL

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader;
    BOOL isMoveable;

    //
    // BUGBUG - this method won't work for Win32s unless it supports SEH. But
    //          there is another method...
    //

    lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;
    __try {
        if (lpHeader->Signature == HEADER_SIGNATURE) {
            isMoveable = FALSE;
        } else {

            lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

            INET_ASSERT(lpHeader != NULL);

            isMoveable = (BOOL)(lpHeader->Signature == HEADER_SIGNATURE);
            LocalUnlock(hLocal);
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // yeowww! hLocal must be a handle to moveable memory. Either that, or
        // it is completely bogus
        //

        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

        INET_ASSERT(lpHeader != NULL);

        isMoveable = (BOOL)(lpHeader->Signature == HEADER_SIGNATURE);
        LocalUnlock(hLocal);
    }
    return isMoveable;
}


HLOCAL
InetFreeMemory(
    IN HLOCAL hLocal,
    IN BOOL IsMoveable
    )

/*++

Routine Description:

    Debug memory deallocator: checks memory is already allocated and that the
    head and tail structures are still ok. Fills freed memory with signature

Arguments:

    hLocal  - address/handle of memory to free
    IsMoveable  - TRUE if this is moveable memory. We need this help because
                  there is no good way to determine if the memory is moveable
                  or fixed

Return Value:

    HLOCAL
        Success - NULL
        Failure - hLocal

--*/

{
    UINT memFlags;
    LPDEBUG_MEMORY_HEADER lpHeader;
    BOOL isMoveable;
    UINT memSize;
    UINT blockLength;
    UINT realLength;

    if (!IsMoveable) {
        hLocal = (HLOCAL)((LPDEBUG_MEMORY_HEADER)hLocal - 1);
    }

    memFlags = LocalFlags(hLocal);

    INET_ASSERT(memFlags != LMEM_INVALID_HANDLE);
    INET_ASSERT((memFlags & LMEM_LOCKCOUNT) == 0);

    if (IsMoveable) {
        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

        INET_ASSERT(lpHeader != NULL);

    } else {
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;
    }

    memSize = LocalSize(hLocal);

    INET_ASSERT((lpHeader->BlockLength <= memSize)
                && !(lpHeader->BlockLength & (sizeof(DWORD) - 1))
                && (lpHeader->RealLength < lpHeader->BlockLength)
                );

    InetCheckBlockConsistency((LPVOID)lpHeader);

    //
    // if this is moveable memory then we didn't link it to the allocated
    // block list, but allocated a DEBUG_MOVEABLE_TAG to do the job. We
    // must remove it
    //

    if (IsMoveable) {

        LPDEBUG_MOVEABLE_TAG lpTag;

        lpTag = lpHeader->Tag;

        INET_ASSERT(lpTag->hMoveable == hLocal);

        InetFreeMemory(lpTag, FALSE);
    } else {
        if (!RemoveFromSerializedList(&AllocatedBlockList, &lpHeader->List)) {
            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("Couldn't remove %#x from allocated block list\n",
                        hLocal
                        ));

            DEBUG_BREAK(MEMALLOC);

            return hLocal;
        }
    }

    if (IsMoveable) {

        BOOL stillLocked;

        stillLocked = LocalUnlock(hLocal);

        INET_ASSERT(!stillLocked);
        INET_ASSERT(GetLastError() == NO_ERROR);

    }

    blockLength = lpHeader->BlockLength;
    realLength = lpHeader->RealLength;
    hLocal = LocalFree(hLocal);

    INET_ASSERT(hLocal == NULL);

    ActualMemoryAllocated -= memSize;
    BlockLengthAllocated -= blockLength;
    RealLengthAllocated -= realLength;
    ++MemoryFrees;

    return hLocal;
}


PRIVATE
VOID
InetCheckBlockConsistency(
    IN LPVOID lpMemory
    )

/*++

Routine Description:

    Checks that what we think is a valid allocated block (allocated by
    InetAllocateMemory), really is

Arguments:

    lpMemory    - pointer to what we think is DEBUG_MEMORY_HEADER

Return Value:

    None.

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader;
    LPDEBUG_MEMORY_FOOTER lpFooter;
    UINT i;
    BOOL headerGuardOverrun;
    BOOL footerGuardOverrun;
    BOOL footerGuard2Overrun;
    BOOL extraMemoryOverrun;
    LPBYTE lpExtraMemory;
    UINT byteLength;

    __try {
        lpHeader = (LPDEBUG_MEMORY_HEADER)lpMemory;
        lpFooter = (LPDEBUG_MEMORY_FOOTER)((LPBYTE)lpMemory
                 + (lpHeader->BlockLength - sizeof(DEBUG_MEMORY_FOOTER)))
                 ;

        headerGuardOverrun = FALSE;
        for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
            if (lpHeader->Guard[i] != GUARD_DWORD_FILL) {
                headerGuardOverrun = TRUE;
                break;
            }
        }

        footerGuardOverrun = FALSE;
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
            if (lpFooter->Guard[i] != GUARD_DWORD_FILL) {
                footerGuardOverrun = TRUE;
                break;
            }
        }

        footerGuard2Overrun = FALSE;
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
            if (lpFooter->Guard2[i] != GUARD_DWORD_FILL) {
                footerGuard2Overrun = TRUE;
                break;
            }
        }

        lpExtraMemory = (LPBYTE)(lpHeader + 1) + lpHeader->RealLength;
        extraMemoryOverrun = FALSE;
        byteLength = ROUND_UP_DWORD(lpHeader->RealLength) - lpHeader->RealLength;
        for (i = 0; i < byteLength; ++i) {
            if (lpExtraMemory[i] != BYTE_FILL_EXTRA) {
                extraMemoryOverrun = TRUE;
                break;
            }
        }

        if (headerGuardOverrun
        || footerGuardOverrun
        || footerGuard2Overrun
        || extraMemoryOverrun
        || (lpHeader->Signature != HEADER_SIGNATURE)
        || (lpFooter->Signature != FOOTER_SIGNATURE)
        || (lpFooter->BlockLength != lpHeader->BlockLength)) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("Bad block: %x\n",
                        lpMemory
                        ));

            DEBUG_BREAK(MEMALLOC);

        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        DEBUG_PRINT(MEMALLOC,
                    FATAL,
                    ("Invalid block %x - exception occurred\n",
                    lpMemory
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
}


LPVOID
InetLockMemory(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Locks a moveable memory block and increments the lock count. Checks block
    consistency

Arguments:

    hLocal  - handle of moveable memory to lock

Return Value:

    LPVOID
        pointer to locked memory

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader = NULL;
    UINT memFlags;

    memFlags = LocalFlags(hLocal);

    INET_ASSERT(memFlags != LMEM_INVALID_HANDLE);

    lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

    INET_ASSERT(lpHeader != NULL);

    InetCheckBlockConsistency((LPVOID)lpHeader);
    ++lpHeader->LockCount;

    GET_CALLERS_ADDRESS(&lpHeader->LastAccessReturnAddress[0],
                        &lpHeader->LastAccessReturnAddress[1]
                        );

    lpHeader->LastAccessOperation = MemLock;

    memFlags = LocalFlags(hLocal);

    INET_ASSERT((memFlags != LMEM_INVALID_HANDLE)
                && (lpHeader->LockCount == (LONG)(memFlags & LMEM_LOCKCOUNT))
                );

    return ++lpHeader;
}


BOOL
InetUnlockMemory(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Unlocks a (locked!) moveable memory block

Arguments:

    hLocal  - handle (pointer) of block to unlock

Return Value:

    None.

--*/

{
    UINT memFlags;
    BOOL stillLocked;
    LPDEBUG_MEMORY_HEADER lpHeader;
    DWORD lockCount;

    memFlags = LocalFlags(hLocal);

    INET_ASSERT(memFlags != LMEM_INVALID_HANDLE);
    INET_ASSERT((memFlags & LMEM_LOCKCOUNT) >= 1);

    //
    // memory must be locked or LocalFlags would have returned error.
    // Lock memory again to get pointer to block, then unlock it.
    // There should still be at least one lock on the block
    //

    lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);
    LocalUnlock(hLocal);

    InetCheckBlockConsistency((LPVOID)lpHeader);

    GET_CALLERS_ADDRESS(&lpHeader->LastAccessReturnAddress[0],
                        &lpHeader->LastAccessReturnAddress[1]
                        );

    lpHeader->LastAccessOperation = MemUnlock;

    lockCount = --lpHeader->LockCount;
    stillLocked = LocalUnlock(hLocal);

    INET_ASSERT(stillLocked ? (lockCount > 0) : GetLastError() == NO_ERROR);

    return stillLocked;
}


UINT
InetMemorySize(
    IN HLOCAL hLocal,
    IN BOOL IsMoveable
    )

/*++

Routine Description:

    Returns allocated block size

Arguments:

    hLocal      - memory handle
    IsMoveable  - TRUE if hLocal is a handle to moveable memory >>> THAT IS NOT
                  LOCKED <<<

Return Value:

    UINT

--*/

{
    UINT size;
    UINT sizeInHeader;
    LPDEBUG_MEMORY_HEADER lpHeader;

    if (IsMoveable) {
        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

        INET_ASSERT(lpHeader != NULL);

        sizeInHeader = lpHeader->RealLength;
        size = LocalSize(hLocal);
        LocalUnlock(hLocal);
    } else {
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;

        INET_ASSERT(lpHeader->Signature == HEADER_SIGNATURE);

        sizeInHeader = lpHeader->RealLength;
        size = LocalSize((HLOCAL)lpHeader);
    }

    INET_ASSERT((sizeInHeader <= size)
                && (size >= sizeof(DEBUG_MEMORY_HEADER) + sizeof(DEBUG_MEMORY_FOOTER))
                );

    return sizeInHeader;
}


BOOL
InetCheckDebugMemoryFreed(
    VOID
    )

/*++

Routine Description:

    Check that we don't have any memory allocated

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    if (ActualMemoryAllocated || (MemoryFrees != MemoryAllocations)) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("MemoryAllocated = %ld, MemoryAllocations = %lu, MemoryFrees = %lu\n",
                    ActualMemoryAllocated,
                    MemoryAllocations,
                    MemoryFrees
                    ));

        DEBUG_BREAK(MEMALLOC);

        return FALSE;
    }
    return TRUE;
}

#if defined(i386)


VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    )

/*++

Routine Description:

    This is a sleazy function that reads return addresses out of the stack/
    frame pointer (ebp). We pluck out the return address of the function
    that called THE FUNCTION THAT CALLED THIS FUNCTION, and the caller of
    that function. Returning the return address of the function that called
    this function is not interesting to that caller (almost worthy of Sir
    Humphrey Appleby isn't it?)

    Assumes:

        my ebp  =>  | caller's ebp |
                    | caller's eip |
                    | arg #1       | (pCaller)
                    | arg #2       | (pCallersCaller

Arguments:

    pCaller         - place where we return addres of function that called
                      the function that called this function
    pCallersCaller  - place where we return caller of above

Return Value:

    None.

--*/

{

    //
    // this only works on x86 and only if not fpo functions!
    //

    LPVOID* ebp;

    ebp = (PVOID*)&pCaller - 2; // told you it was sleazy
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCaller = *(ebp + 1);
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCallersCaller = *(ebp + 1);
}

#endif // defined(i386)

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\handles\autoprox.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    autoprox.cxx

Abstract:

    Contains class implementation for auto-proxy DLLs which can extent WININET's
        abilities (logic) for deciding what proxies to use.

    How auto-proxy works:
        By offloading requests to a specialized Win32 Thread which picks
        up queued up message requests for Queries, Shutdown, and Initialization


    Contents:
        AUTO_PROXY_ASYNC_MSG

Author:

    Arthur L Bierer (arthurbi) 17-Dec-1996

Revision History:

    17-Dec-1996 arthurbi
        Created

--*/

#include <wininetp.h>



AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength
    )
{
    URL_COMPONENTSA urlComponents;

    Initalize();

    if ( lpszUrl )
    {
        _lpszUrl      = lpszUrl;
        _dwUrlLength  = lstrlen(lpszUrl);
        _tUrlProtocol = isUrlScheme;
        _pmProxyQuery = PROXY_MSG_GET_PROXY_INFO;
        _pmaAllocMode = MSG_ALLOC_STACK_ONLY;

        memset(&urlComponents, 0, sizeof(urlComponents));
        urlComponents.dwStructSize = sizeof(urlComponents);
        urlComponents.lpszHostName = lpszUrlHostName;
        urlComponents.dwHostNameLength = dwUrlHostNameLength;

        //
        // parse out the host name and port. The host name will be decoded; the
        // original URL will not be modified
        //

        if (WinHttpCrackUrlA(lpszUrl, 0, ICU_DECODE, &urlComponents))
        {
           _nUrlPort            = urlComponents.nPort;
           _lpszUrlHostName     = urlComponents.lpszHostName;
           _dwUrlHostNameLength = urlComponents.dwHostNameLength;

           if ( _tUrlProtocol == INTERNET_SCHEME_UNKNOWN )
           {
               _tUrlProtocol = urlComponents.nScheme;
           }

        }
        else
        {
            _Error = GetLastError();
        }
    }
    else
    {
        _Error = ERROR_NOT_ENOUGH_MEMORY;
    }
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength
    )
{

    Initalize();

    _tUrlProtocol = isUrlScheme;
    _pmProxyQuery = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode = MSG_ALLOC_STACK_ONLY;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength,
    IN INTERNET_PORT nUrlPort
    )
{
    Initalize();

    _tUrlProtocol        = isUrlScheme;
    _pmProxyQuery        = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode        = MSG_ALLOC_STACK_ONLY;
    _nUrlPort            = nUrlPort;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
    _lpszUrl             = lpszUrl;
    _dwUrlLength         = dwUrlLength;

}

VOID
AUTO_PROXY_ASYNC_MSG::SetProxyMsg(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength,
    IN INTERNET_PORT nUrlPort
    )
{
    _tUrlProtocol        = isUrlScheme;
    _pmProxyQuery        = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode        = MSG_ALLOC_STACK_ONLY;
    _nUrlPort            = nUrlPort;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
    _lpszUrl             = lpszUrl;
    _dwUrlLength         = dwUrlLength;
}


AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN PROXY_MESSAGE_TYPE pmProxyQuery
    )
{
    Initalize();

    _pmaAllocMode = MSG_ALLOC_HEAP_MSG_OBJ_OWNS;
    _pmProxyQuery = pmProxyQuery;
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN AUTO_PROXY_ASYNC_MSG *pStaticAutoProxy
    )
{
    Initalize();

    _tUrlProtocol          = pStaticAutoProxy->_tUrlProtocol;
    _lpszUrl               = (pStaticAutoProxy->_lpszUrl) ? NewString(pStaticAutoProxy->_lpszUrl) : NULL;
    _dwUrlLength           = pStaticAutoProxy->_dwUrlLength;
    _lpszUrlHostName       =
                (pStaticAutoProxy->_lpszUrlHostName ) ?
                NewString(pStaticAutoProxy->_lpszUrlHostName, pStaticAutoProxy->_dwUrlHostNameLength) :
                NULL;
    _dwUrlHostNameLength   = pStaticAutoProxy->_dwUrlHostNameLength;
    _nUrlPort              = pStaticAutoProxy->_nUrlPort;
    _tProxyScheme          = pStaticAutoProxy->_tProxyScheme;

    //
    // ProxyHostName is something that is generated by the request,
    //   therefore it should not be copied OR freed.
    //

    INET_ASSERT( pStaticAutoProxy->_lpszProxyHostName == NULL );
    //_lpszProxyHostName     = (pStaticAutoProxy->_lpszProxyHostName ) ? NewString(pStaticAutoProxy->_lpszProxyHostName) : NULL;


    _dwProxyHostNameLength = pStaticAutoProxy->_dwProxyHostNameLength;
    _nProxyHostPort        = pStaticAutoProxy->_nProxyHostPort;
    _pmProxyQuery          = pStaticAutoProxy->_pmProxyQuery;
    _pmaAllocMode          = MSG_ALLOC_HEAP_MSG_OBJ_OWNS;
    _pProxyState           = pStaticAutoProxy->_pProxyState;

    INET_ASSERT(_pProxyState == NULL);

    _dwQueryResult         = pStaticAutoProxy->_dwQueryResult;
    _Error                 = pStaticAutoProxy->_Error;
    _MessageFlags.Dword    = pStaticAutoProxy->_MessageFlags.Dword;
    _dwProxyVersion        = pStaticAutoProxy->_dwProxyVersion;
}

AUTO_PROXY_ASYNC_MSG::~AUTO_PROXY_ASYNC_MSG(
    VOID
    )
{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "~AUTO_PROXY_ASYNC_MSG",
                NULL
                ));

    if ( IsAlloced() )
    {
        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("Freeing Allocated MSG ptr=%x\n",
                    this
                    ));


        if ( _lpszUrl )
        {
            //DEBUG_PRINT(OBJECTS,
            //            INFO,
            //            ("Url ptr=%x, %q\n",
            //            _lpszUrl,
            //            _lpszUrl
            //            ));

            FREE_MEMORY(_lpszUrl);
        }

        if ( _lpszUrlHostName )
        {
            FREE_MEMORY(_lpszUrlHostName);
        }


        if ( _pProxyState )
        {
            delete _pProxyState;
        }
    }
    if (_bFreeProxyHostName && (_lpszProxyHostName != NULL)) {
        FREE_MEMORY(_lpszProxyHostName);
    }

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\debug\rprintf.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rprintf.cxx

Abstract:

    Contains my own version of printf(), sprintf() and vprintf(). Useful since
    adding new printf escape sequences becomes easy

    Contents:
        rprintf     limited re-entrant version of printf
        rsprintf    limited re-entrant version of sprintf
        _sprintf    routine which does the work

Author:

    Richard L Firth (rfirth) 20-Jun-1995

Revision History:

    29-Aug-1989 rfirth
        Created

	27-Jul-2001 sergekh
		_sprintf modified to request buffer size to avoid overruns

	11-Apr-2002 lcleeton
	    _sprintf modified to print sockaddr's as IP address literal strings - new token %A
--*/

#include <wininetp.h>
#include "rprintf.h"

//
// defines for flags word
//

#define F_SPACES        0x00000001  // prefix field with spaces
#define F_ZEROES        0x00000002  // prefix field with zeroes
#define F_MINUS         0x00000004  // field is left justified
#define F_HASH          0x00000008  // hex field is prefixed with 0x/0X
#define F_XUPPER        0x00000010  // hex field has upper case letters
#define F_LONG          0x00000020  // long int/hex/oct prefix
#define F_PLUS          0x00000040  // prefix +'ve signed number with +
#define F_DOT           0x00000080  // separator for field and precision
#define F_NEAR          0x00000100  // far pointer has near prefix
#define F_FAR           0x00000200  // near pointer has far prefix
#define F_SREPLICATE    0x00000400  // this field replicated
#define F_EREPLICATE    0x00000800  // end of replications
#define F_UNICODE       0x00001000  // string is wide character (%ws/%wq)
#define F_QUOTING       0x00002000  // strings enclosed in double quotes
#define F_ELLIPSE       0x00004000  // a sized, quoted string ends in "..."

#define BUFFER_SIZE     1024

//
// minimum field widths for various ASCII representations of numbers
//

#define MIN_BIN_WIDTH   16          // minimum field width in btoa
#define MIN_HEX_WIDTH   8           // minimum field width in xtoa
#define MIN_INT_WIDTH   10          // minimum field width in itoa
#define MIN_LHEX_WIDTH  8           // minimum field width in long xtoa
#define MIN_LINT_WIDTH  10          // minimum field width in long itoa
#define MIN_LOCT_WIDTH  11          // minimum field width in long otoa
#define MIN_OCT_WIDTH   11          // minimum field width in otoa
#define MIN_UINT_WIDTH  10          // minimum field width in utoa

//
// character defines
//

#define EOSTR           '\0'
#define CR              '\x0d'
#define LF              '\x0a'

#if !defined(min)

#define min(a, b)   ((a)<(b)) ? (a) : (b)

#endif

PRIVATE int     _atoi(char**);
PRIVATE void    convert(char**, char*, ULONG_PTR, int, int, unsigned, char(*)(ULONG_PTR*));
PRIVATE char    btoa(ULONG_PTR *);
PRIVATE char    otoa(ULONG_PTR *);
PRIVATE char    utoa(ULONG_PTR *);
PRIVATE char    xtoa(ULONG_PTR *);
PRIVATE char    Xasc(ULONG_PTR *);

/***    rprintf - a re-entrant cut-down version of printf. Understands usual
 *                  printf format characters introduced by '%' plus one or
 *                  two additions
 *
 *      ENTRY   format  - pointer to buffer containing format string defining
 *                        the output. As per usual printf the arguments to
 *                        fill in the blanks in the format string are on the
 *                        the stack after the format string
 *
 *              <args>  - arguments on stack, size and type determined from
 *                        the format string
 *
 *      EXIT    format string used to convert arguments (if any) and print
 *              the results to stdout.
 *              The number of character copied is the value returned
 */

#ifdef UNUSED
int cdecl rprintf(char* format, ...) {

    int charsPrinted = 0;
    char buffer[BUFFER_SIZE];
    DWORD nwritten;
    va_list args;

    /* print the output into  buffer then print the formatted buffer to the
     * screen
     */

    va_start(args, format);
    charsPrinted = _sprintf(buffer, format, args);
    va_end(args);

    WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),
                              buffer,
                              charsPrinted,
                              &nwritten,
                              0
                              );
    return nwritten;
}
#endif

/***    rsprintf - a re-entrant cut-down version of sprintf. See rprintf for
 *                  details
 *
 *      ENTRY   buffer  - pointer to the buffer which will receive the
 *                        formatted output
 *
 *				buf_size - size of buffer to control overrun
 *
 *              format  - pointer to buffer which defines the formatted
 *                        output. Consists of normal printing characters
 *                        and printf-style format characters (see rprintf)
 *
 *      EXIT    characters from format string and arguments converted to
 *              character format based on format string are copied into the
 *              buffer
 *              The number of character copied is the value returned
 */

int cdecl rsprintf(char* buffer, size_t buf_size, char* format, ...) {

    va_list args;
    int n;

    va_start(args, format);
    n = _sprintf(buffer, buf_size, format, args);
    va_end(args);
    return n;
}

/***    _sprintf - performs the sprintf function. Receives an extra parameter
 *                  on the stack which is the pointer to the variable argument
 *                  list of rprintf and rsprintf
 *
 *      ENTRY   buffer  - pointer to buffer which will receive the output
 *
 *				buf_size - size of buffer to control overrun
 *
 *              format  - pointer to the format string
 *
 *              args    - variable argument list which will be used to fill in
 *                        the escape sequences in the format string
 *
 *      EXIT    The characters in the format string are used to convert the
 *              arguments and copy them to the buffer.
 *              The number of character copied is the value returned
 */


int cdecl _sprintf(char* buffer, size_t buf_size, char* format, va_list args) {

#define CHECK_BUF		if (tail == buffer) goto Quit;

    char*       original = buffer;
    int         FieldWidth;
    int         FieldPrecision;
    int         FieldLen;
    BOOL        SubDone;
    int         StrLen;
    int         i;
    DWORD       flags;
    int         replications;
    char*       s;

	//calculate tail and reserve space for 0
	char*		tail = buffer + buf_size - 1;

	if (buf_size == 0)
		return 0;
	else if (buf_size == 1)
		goto Quit;

    while (*format) {
        switch ((unsigned)*format) {
        case '\n':

            //
            // convert line-feed to carriage-return, line-feed. But only if the
            // format string doesn't already contain a carriage-return directly
            // before the line-feed! This way we can make multiple calls into
            // this function, with the same buffer, and only once expand the
            // line-feed
            //

            if (*(buffer - 1) != CR) {
                *buffer++ = CR; CHECK_BUF;
            }
            *buffer++ = LF; CHECK_BUF;
            break;

        case '%':
            SubDone = FALSE;
            flags = 0;
            FieldWidth = 0;
            FieldPrecision = 0;
            replications = 1;   /* default replication is 1 */
            while (!SubDone) {
                switch ((unsigned)*++format) {
                case '%':
                    *buffer++ = '%'; CHECK_BUF;
                    SubDone = TRUE;
                    break;

                case ' ':
                    flags |= F_SPACES;
                    break;

                case '#':
                    flags |= F_HASH;
                    break;

                case '-':
                    flags |= F_MINUS;
                    break;

                case '+':
                    flags |= F_PLUS;
                    break;

                case '.':
                    flags |= F_DOT;
                    break;

                case '*':
                    if (flags & F_DOT) {
                        FieldPrecision = va_arg(args, int);
                    } else {
                        FieldWidth = va_arg(args, int);
                    }
                    break;

                case '@':
                    replications = _atoi(&format);
                    break;

                case '[':
                    flags |= F_SREPLICATE;
                    break;

                case ']':
                    flags |= F_EREPLICATE;
                    break;

                case '0':
                    /* if this is leading zero then caller wants
                     * zero prefixed number of given width (%04x)
                     */
                    if (!(flags & F_ZEROES)) {
                        flags |= F_ZEROES;
                        break;
                    }

                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    if (flags & F_DOT) {
                        FieldPrecision = _atoi(&format);
                    } else {
                        FieldWidth = _atoi(&format);
                    }
                    break;

                case 'A':
                    CHAR            AddrBuff[INET6_ADDRSTRLEN+1];
                    DWORD           AddrStrLen;
                    LPSOCKADDR_IN   lpSin;        
                    LPSOCKADDR_IN6  lpSin6;
                    DWORD           AError;

                    
                    lpSin = va_arg(args, LPSOCKADDR_IN);
                    lpSin6 = (LPSOCKADDR_IN6)lpSin;

                    if (lpSin == NULL) {
                        
                        strcpy(AddrBuff, "<null>");
                        AddrStrLen = lstrlen(AddrBuff);

                    } else {
                    
                        if (IsBadReadPtr(lpSin, sizeof(u_short))) {
                            goto Quit;
                        }
                        if ((lpSin->sin_family != AF_INET) && (lpSin->sin_family != AF_INET6)) {
                               goto Quit;   
                        }
                        if (lpSin->sin_family == AF_INET) {
                            if (IsBadReadPtr(lpSin, sizeof(SOCKADDR_IN))) {
                                goto Quit;
                            }
                        } else {
                            if (IsBadReadPtr(lpSin, sizeof(SOCKADDR_IN6))) {
                                goto Quit;
                            }
                        }
                        AddrStrLen = sizeof(AddrBuff);
                        AError = _I_WSAAddressToStringA(
                                    (LPSOCKADDR)lpSin, 
                                    (lpSin->sin_family == AF_INET) ? sizeof(SOCKADDR_IN) : sizeof(SOCKADDR_IN6),
                                    NULL,
                                    AddrBuff,
                                    &AddrStrLen
                                    );
                        if (AError) {
                            goto Quit;
                        }
                    }
                    
                    // let %s handling do the rest!

                    s = AddrBuff;
                    replications = 0;
                    flags &= ~F_UNICODE;
                    goto s_continue;
                   
                case 'b':

                    //
                    // Binary representation
                    //

                    while (replications--) {
                        convert(&buffer,
								tail,
                                va_arg(args, unsigned int),
                                (FieldWidth) ? FieldWidth : MIN_BIN_WIDTH,
                                MIN_BIN_WIDTH,
                                flags,
                                btoa
                                );
						CHECK_BUF;
                    }
                    SubDone = TRUE;
                    break;

                case 'B':

                    //
                    // Boolean representation
                    //

                    if (va_arg(args, BOOL)) {
                        *buffer++ = 'T'; CHECK_BUF;
                        *buffer++ = 'R'; CHECK_BUF;
                        *buffer++ = 'U'; CHECK_BUF;
                        *buffer++ = 'E'; CHECK_BUF;
                    } else {
                        *buffer++ = 'F'; CHECK_BUF;
                        *buffer++ = 'A'; CHECK_BUF;
                        *buffer++ = 'L'; CHECK_BUF;
                        *buffer++ = 'S'; CHECK_BUF;
                        *buffer++ = 'E'; CHECK_BUF;
                    }
                    SubDone = TRUE;
                    break;

                case 'c':

                    //
                    // assume that a character is the size of the
                    // width of the stack which in turn has the same
                    // width as an integer
                    //

                    --FieldWidth;
                    while (replications--) {
                        for (i = 0; i < FieldWidth; i++) {
                            *buffer++ = ' '; CHECK_BUF;
                        }
                        *buffer++ = (char) va_arg(args, int); CHECK_BUF;
                    }
                    SubDone = TRUE;
                    break;

                case 'd':
                case 'i':
                    while (replications--) {

                        long l;

                        l = (flags & F_LONG) ? va_arg(args, long) : (long)va_arg(args, int);
                        if (l < 0) {
                            *buffer++ = '-'; CHECK_BUF;
                            if (flags & F_LONG) {
                                l = -(long)l;
                            } else {
                                l = -(int)l;
                            }
                        } else if (flags & F_PLUS) {
                            *buffer++ = '+'; CHECK_BUF;
                        }
                        convert(&buffer,
								tail,
                                l,
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LINT_WIDTH : MIN_INT_WIDTH,
                                flags,
                                utoa
                                );
						CHECK_BUF;
                    }
                    SubDone = TRUE;
                    break;

                case 'e':
                    /* not currently handled */
                    break;

                case 'f':
                    /* not currently handled */
                    break;

                case 'F':
                    flags |= F_FAR;
                    break;

                case 'g':
                case 'G':
                    /* not currently handled */
                    break;

                case 'h':
                    /* not currently handled */
                    break;

                case 'l':
                    flags |= F_LONG;
                    break;

                case 'L':
                    /* not currently handled */
                    break;

                case 'n':
                    *(va_arg(args, int*))  = (int)(buffer - original);
                    SubDone = TRUE;
                    break;

                case 'N':
                    flags |= F_NEAR;
                    break;

                case 'o':
                    while (replications--) {
                        convert(&buffer,
								tail,
                                (flags & F_LONG) ? va_arg(args, unsigned long) : (unsigned long)va_arg(args, unsigned),
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LOCT_WIDTH : MIN_OCT_WIDTH,
                                flags,
                                otoa
                                );
						CHECK_BUF;
                    }
                    SubDone = TRUE;
                    break;

                case 'p':
                    while (replications--) {


                        if (!(flags & F_NEAR)) {
                            convert(&buffer,
									tail,
                                    (ULONG_PTR) va_arg(args, char near *),
                                    MIN_HEX_WIDTH,
                                    MIN_HEX_WIDTH,
                                    flags | F_XUPPER,
                                    Xasc
                                    );
							CHECK_BUF;
                            *buffer++ = ':'; CHECK_BUF;
                        }
                        convert(&buffer,
								tail,
                                (ULONG_PTR)va_arg(args, unsigned),
                                MIN_HEX_WIDTH,
                                MIN_HEX_WIDTH,
                                flags | F_XUPPER,
                                Xasc
                                );
						CHECK_BUF;
                    }
                    SubDone = TRUE;
                    break;

                case 'Q':       // quoted unicode string
                    flags |= F_UNICODE;
                    // *** FALL THROUGH ***

                case 'q':
                    *buffer++ = '"'; CHECK_BUF;
                    flags |= F_QUOTING;

                    //
                    // *** FALL THROUGH ***
                    //

                case 's':
                    while (replications--) {


                        s = va_arg(args, char*);

s_continue:             // can jump here from case 'A' above

                        //  If the string has a field precision, IsBadStringPtr()
                        //should not check past that many characters because the string
                        //may not even be null-terminated (and its sufficient to check
                        //up to FieldPrecision characters).
                        //  If the string does not have a FieldPrecision, we tell
                        //IsBadStringPtr to check up to the null terminator with a -1.
                        int iIsBadStringPtrCheckSize = FieldPrecision ? FieldPrecision : -1;
                    
                        if ( s != NULL
                             && (flags & F_UNICODE
                                 ? IsBadStringPtrW( (LPWSTR)s,iIsBadStringPtrCheckSize)
                                 : IsBadStringPtrA( (LPSTR)s,iIsBadStringPtrCheckSize)))
                        {
                            *buffer++ = '('; CHECK_BUF;
                            *buffer++ = 'b'; CHECK_BUF;
                            *buffer++ = 'o'; CHECK_BUF;
                            *buffer++ = 'g'; CHECK_BUF;
                            *buffer++ = 'u'; CHECK_BUF;
                            *buffer++ = 's'; CHECK_BUF;
                            *buffer++ = 'S'; CHECK_BUF;
                            *buffer++ = 't'; CHECK_BUF;
                            *buffer++ = 'r'; CHECK_BUF;
                            *buffer++ = 'i'; CHECK_BUF;
                            *buffer++ = 'n'; CHECK_BUF;
                            *buffer++ = 'g'; CHECK_BUF;
                            *buffer++ = 'P'; CHECK_BUF;
                            *buffer++ = 't'; CHECK_BUF;
                            *buffer++ = 'r'; CHECK_BUF;
                            *buffer++ = ':'; CHECK_BUF;
                            convert(&buffer,
                                    tail,
                                    (ULONG_PTR)va_arg(args, unsigned),
                                    MIN_HEX_WIDTH,
                                    MIN_HEX_WIDTH,
                                    flags | F_XUPPER,
                                    Xasc);
                            CHECK_BUF;
                            *buffer++ = ')'; CHECK_BUF;
                            
                        }
                        else if (s != NULL)
                        {
                            // darrenmi 2/24/00 Note that if the string has a field precision,
                            // it's not always null terminated!! Don't depend on it being psz
                            // and stop when we hit our max length.
                            StrLen = 0;

                            if (flags & F_UNICODE) {
                                WCHAR   *pWork = (LPWSTR)s;
                                while((!FieldPrecision || StrLen < FieldPrecision) && *pWork)
                                {
                                    pWork++;
                                    StrLen++;
                                }
                            } else {
                                CHAR    *pWork = s;
                                while((!FieldPrecision || StrLen < FieldPrecision) && *pWork)
                                {
                                    pWork++;
                                    StrLen++;
                                }
                            }
                            
                            FieldLen = (FieldPrecision)
                                        ? min(StrLen, FieldPrecision)
                                        : StrLen
                                        ;
                            if ((flags & F_QUOTING) && (FieldPrecision > 3) && (FieldLen < StrLen)) {
                                FieldLen -= 3;
                                flags |= F_ELLIPSE;
                            }

                            for (i = 0; i < (FieldWidth - FieldLen); i++) {
                                *buffer++ = ' '; CHECK_BUF;
                            }

                            if (flags & F_UNICODE) {

                                char wbuf[4096];
                                int wi;

                                WideCharToMultiByte(CP_ACP, 0,
                                        (LPWSTR)s, -1,
                                        wbuf, 4096,
                                        NULL, NULL);

                                for (wi = 0; wbuf[wi] && FieldLen; ++wi) {
                                    *buffer = wbuf[wi];

                                    //
                                    // if this is a quoted string, and it contains
                                    // \r and/or \n, then we reverse-convert these
                                    // characters, since we don't want then to
                                    // break the string. Do the same for \t
                                    //

                                    if (flags & F_QUOTING) {

                                        char ch;

                                        ch = *buffer;
                                        if ((ch == '\r') || (ch == '\n') || (ch == '\t')) {
                                            *buffer++ = '\\'; CHECK_BUF;
                                            *buffer = (ch == '\r')
                                                        ? 'r'
                                                        : (ch == '\n')
                                                            ? 'n'
                                                            : 't'
                                                            ;
                                        }
                                    }
                                    ++buffer; CHECK_BUF;
                                    --FieldLen;
                                }
                            } else {
                                while (*s && FieldLen) {
                                    *buffer = *s++;

                                    //
                                    // if this is a quoted string, and it contains
                                    // \r and/or \n, then we reverse-convert these
                                    // characters, since we don't want then to
                                    // break the string. Do the same for \t
                                    //

                                    if (flags & F_QUOTING) {

                                        char ch;

                                        ch = *buffer;
                                        if ((ch == '\r') || (ch == '\n') || (ch == '\t')) {
                                            *buffer++ = '\\'; CHECK_BUF;
                                            *buffer = (ch == '\r')
                                                        ? 'r'
                                                        : (ch == '\n')
                                                            ? 'n'
                                                            : 't'
                                                            ;
                                        }
                                    }
                                    ++buffer; CHECK_BUF;
                                    --FieldLen;
                                }
                            }
                            if (flags & F_ELLIPSE) {
                                *buffer++ = '.'; CHECK_BUF;
                                *buffer++ = '.'; CHECK_BUF;
                                *buffer++ = '.'; CHECK_BUF;
                            }
                        } else if (!(flags & F_QUOTING)) {
                            *buffer++ = '('; CHECK_BUF;
                            *buffer++ = 'n'; CHECK_BUF;
                            *buffer++ = 'u'; CHECK_BUF;
                            *buffer++ = 'l'; CHECK_BUF;
                            *buffer++ = 'l'; CHECK_BUF;
                            *buffer++ = ')'; CHECK_BUF;
                        }
                    }
                    if (flags & F_QUOTING) {
                        *buffer++ = '"'; CHECK_BUF;
                    }
                    SubDone = TRUE;
                    break;

                case 'S':
                    break;

                case 'u':
                    while (replications--) {
                        convert(&buffer,
								tail,
                                va_arg(args, unsigned),
                                FieldWidth,
                                MIN_UINT_WIDTH,
                                flags,
                                utoa
                                );
						CHECK_BUF;
                    }
                    SubDone = TRUE;
                    break;

                case 'w':
                    flags |= F_UNICODE;
                    break;

                case 'X':
                    flags |= F_XUPPER;

                    //
                    // *** FALL THROUGH ***
                    //

                case 'x':
                    while (replications--) {
                        if (flags & F_HASH) {
                            *buffer++ = '0'; CHECK_BUF;
                            *buffer++ = (flags & F_XUPPER) ? (char)'X' : (char)'x'; CHECK_BUF;
                        }
                        convert(&buffer,
								tail,
                                (flags & F_LONG) ? va_arg(args, unsigned long) : va_arg(args, unsigned),
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LHEX_WIDTH : MIN_HEX_WIDTH,
                                flags,
                                (flags & F_XUPPER) ? Xasc : xtoa
                                );
						CHECK_BUF;
                    }
                    SubDone = TRUE;
                    break;
                } /* switch <%-specifier> */
            }
            break;

        default:
            *buffer++ = *format; CHECK_BUF;
        } /* switch <character> */
        ++format;
    } /* while */
Quit:
    *buffer = EOSTR;
    return (int)(buffer - original);
}

/***    _atoi - ascii to integer conversion used to get the field width out
 *              of the format string
 *
 *      ENTRY   p - pointer to pointer to format string
 *
 *      EXIT    returns the number found in the prefix string as a (16-bit)
 *              int format string pointer is updated past the field width
 */

PRIVATE
int _atoi(char** p) {

    int n = 0;
    int i = 5;

    while ((**p >= '0' && **p <= '9') && i--) {
        n = n*10+((int)(*(*p)++)-(int)'0');
    }

    /* put the format pointer back one since the major loop tests *++format */

    --*p;
    return n;
}

/***    convert - convert number to representation defined by procedure
 *
 *      ENTRY   buffer  - pointer to buffer to receive conversion
 *				tail	- pointer to the end of buffer to prevent overrun
 *              n       - number to convert
 *              width   - user defined field width
 *              mwidth  - minimum width for representation
 *              flags   - flags controlling conversion
 *              proc    - pointer to conversion routine
 *
 *      EXIT    buffer is updated to point past the number representation
 *              just put into it
 */

PRIVATE
void
convert(
    char** buffer,
	char* tail,
    ULONG_PTR n,
    int width,
    int mwidth,
    unsigned flags,
    char (*proc)(ULONG_PTR*)
    )
{
    char    numarray[33];
    int     MinWidth;
    int     i;

    MinWidth = (width < mwidth) ? mwidth : width;
    i = MinWidth;
    do {
        numarray[--i] = (*proc)(&n);
    } while (n);
    while (width > MinWidth-i) {
        numarray[--i] = (char)((flags & F_SPACES) ? ' ' : '0');
    }
    while (i < MinWidth) {
        *(*buffer)++ = numarray[i++];
		if (*buffer == tail)
			break;
    }
}

/***    btoa - return next (least significant) char in a binary to ASCII
 *              conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char btoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)(*pn&1)+'0';
    *pn >>= 1;
    return rch;
}

/***    otoa - return next (least significant) char in an octal to ASCII
 *              conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char otoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)'0'+(char)(*pn&7);
    *pn >>= 3;
    return rch;
}

/***    utoa - return next (least significant) char in an unsigned int to
 *              ASCII conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char utoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)'0'+(char)(*pn%10);
    *pn /= 10;
    return rch;
}

/***    xtoa - return next (least significant) char in a hexadecimal to
 *              ASCII conversion. Returns lower case hex characters
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char xtoa(ULONG_PTR *pn) {

    ULONG_PTR   n = *pn & 0x000f;
    char        rch = (n <= 9) /* decimal digit? */
                      ? (char)(n+'0')
                      : (char)(n+'0'+('a'-'9'-1));

    *pn >>= 4;
    return rch;
}

/***    Xasc - return next (least significant) char in a hexadecimal to
 *              ASCII conversion. Returns upper case hex characters
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char Xasc(ULONG_PTR *pn) {

    ULONG_PTR   n = *pn & 0x000f;
    char        rch = (n <= 9) /* decimal digit? */
                        ? (char)(n+'0')
                        : (char)(n+'0'+('A'-'9'-1));

    *pn >>= 4;
    return rch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\dll\dllentry.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dllentry.cxx

Abstract:

    Entry point for WinInet Internet client DLL

    Contents:
        WinInetDllEntryPoint

Author:

    Richard L Firth (rfirth) 10-Nov-1994

Environment:

    Win32 (user-mode) DLL

Revision History:

    10-Nov-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include <process.h>
#include <perfdiag.hxx>
#include <shlwapi.h>
#include <advpub.h>
#include <olectl.h>
#include <DLOle.h>

#ifdef WINHTTP_STATIC_LIBRARY
#error dllentry.cxx should not be built in the static winhttpx.lib!!
#endif

#if defined(__cplusplus)
extern "C" {
#endif

BOOL
WINAPI
DllMain(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    );


#if defined(__cplusplus)
}
#endif

//
// global data
//

GLOBAL CCritSec GeneralInitCritSec;

//
// functions
//

VOID AutoProxySvcDetach(VOID);
VOID AutoProxySvcUnload(VOID);


BOOL
WINAPI
DllMain(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    )

/*++

Routine Description:

    Performs global initialization and termination for all protocol modules.

    This function only handles process attach and detach which are required for
    global initialization and termination, respectively. We disable thread
    attach and detach. New threads calling Wininet APIs will get an
    INTERNET_THREAD_INFO structure created for them by the first API requiring
    this structure

Arguments:

    DllHandle   - handle of this DLL. Unused

    Reason      - process attach/detach or thread attach/detach

    Reserved    - if DLL_PROCESS_ATTACH, NULL means DLL is being dynamically
                  loaded, else static. For DLL_PROCESS_DETACH, NULL means DLL
                  is being freed as a consequence of call to FreeLibrary()
                  else the DLL is being freed as part of process termination

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Failed to initialize

--*/

{
    //
    // perform global dll initialization, if any.
    //
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
        INITIALIZE_DEBUG_REGKEY();
        INITIALIZE_MEMORY_MANAGER();

        GlobalDllHandle = DllHandle;
        GlobalPlatformType = PlatformType(&GlobalPlatformVersion5);

        if (!GeneralInitCritSec.Init())
        {
            return FALSE;
        }
        
        if (!g_pAsyncCount)
        {
            g_pAsyncCount = New CAsyncCount();

            if (!g_pAsyncCount)
                return FALSE;
        }

        if( !DLOleInitialize())
        {
            return FALSE;
        }

        INET_DEBUG_START();
        CTracer::s_CritSectionTraceInit.Init();
        CTracer::GlobalTraceInit();
        
        if (!GlobalDllInitialize() || !InternetCreateThreadInfo(TRUE))
        {
            return FALSE;
        }

        {
        DEBUG_ENTER((DBG_DLL,
                     Bool,
                     "DllMain",
                     "%#x, %s, %#x",
                     DllHandle,
                     "DLL_PROCESS_ATTACH",
                     Reserved
                     ));

        // LOG_EVENT(WINHTTP_INFO, "WinHttp loaded");

        DEBUG_LEAVE(TRUE);
        }

        break;

    case DLL_PROCESS_DETACH:

        // LOG_EVENT(WINHTTP_INFO, "WinHttp unloaded");
        
        //
        // signal to all APIs (and any other function that might have an
        // interest) that the DLL is being shutdown
        //

        GlobalDynaUnload = (Reserved == NULL) ? TRUE : FALSE;
        InDllCleanup = TRUE;

		{
		    DEBUG_ENTER((DBG_DLL,
                    Bool,
                    "DllMain",
                    "%#x, %s, %#x",
                    DllHandle,
                    "DLL_PROCESS_DETACH",
                    Reserved
                    ));

			DEBUG_PRINT(DLL,
						INFO,
						("DLL Terminated\n"
						));

			DEBUG_LEAVE(TRUE);
		}

        AutoProxySvcDetach();
        AutoProxySvcUnload();

        if (GlobalDynaUnload) {
            if (GlobalDataInitialized) {
                GlobalDataTerminate();
            }
            GlobalDllTerminate();
            InternetTerminateThreadInfo();
        }

        PERF_DUMP();

        PERF_END();

        //TERMINATE_DEBUG_MEMORY(FALSE);
        INET_DEBUG_FINISH();
        TERMINATE_DEBUG_REGKEY();

        CTracer::GlobalTraceTerm();
        //InternetDestroyThreadInfo();

        if (g_pAsyncCount)
        {
            delete g_pAsyncCount;
            g_pAsyncCount = NULL;
        }

#ifdef USE_ROCKALL
        // RENO 35983: skip Rockall destructor if process is shutting down.
        if (GlobalDynaUnload)
#endif
        {
            TERMINATE_MEMORY_MANAGER(TRUE);
        }

        GeneralInitCritSec.FreeLock();
        break;

    case DLL_THREAD_DETACH:

        //
        // kill the INTERNET_THREAD_INFO
        //

		{
			DEBUG_ENTER((DBG_DLL,
                Bool,
                "DllMain",
                "%#x, %s, %#x",
                DllHandle,
                "DLL_THREAD_DETACH",
                Reserved
                ));

	        DEBUG_LEAVE(TRUE);
		}

        InternetDestroyThreadInfo();

        MEMORY_MANAGER_ON_THREAD_DETACH();
        break;

    case DLL_THREAD_ATTACH:

        //
        // we do nothing for thread attach - if we need an INTERNET_THREAD_INFO
        // then it gets created by the function which realises we need one
        //

		{
			DEBUG_ENTER((DBG_DLL,
                Bool,
                "DllMain",
                "%#x, %s, %#x",
                DllHandle,
                "DLL_THREAD_ATTACH",
                Reserved
                ));

	        AllowCAP();

	
		    DEBUG_LEAVE(TRUE);
		}
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//
// Autoregistration entry points
//
//////////////////////////////////////////////////////////////////////////
HRESULT RegisterTypeLib()
{
    ITypeLib *  pTypeLib;
    char        szPath[MAX_PATH+1];
    OLECHAR     wszPath[MAX_PATH+1];
    HRESULT     hr;

    GetModuleFileName(GlobalDllHandle, szPath, sizeof(szPath)-1); // leave room for null char
    szPath[sizeof(szPath)-1] = '\0'; // guarantee null termination
    
    MultiByteToWideChar(CP_ACP, 0, szPath, -1, wszPath, MAX_PATH);

    hr = DL(LoadTypeLib)(wszPath, &pTypeLib);

    if (SUCCEEDED(hr))
    {
        hr = DL(RegisterTypeLib)(pTypeLib, wszPath, NULL);
        
        pTypeLib->Release();
    }

    if (FAILED(hr))
    {
        hr = SELFREG_E_TYPELIB;
    }

    return hr;
}

HRESULT UnregisterTypeLib()
{
    ITypeLib *  pTypeLib;
    TLIBATTR *  pTLibAttr;
    char        szPath[MAX_PATH+1];
    OLECHAR     wszPath[MAX_PATH+1];
    HRESULT     hr = NOERROR;


    GetModuleFileName(GlobalDllHandle, szPath, sizeof(szPath)-1); // leave room for null char
    szPath[sizeof(szPath)-1] = '\0'; // guarantee null termination
    
    MultiByteToWideChar(CP_ACP, 0, szPath, -1, wszPath, MAX_PATH);

    hr = DL(LoadTypeLib)(wszPath, &pTypeLib);

    if (SUCCEEDED(hr))
    {
        hr = pTypeLib->GetLibAttr(&pTLibAttr);

        if (SUCCEEDED(hr))
        {
            hr = DL(UnRegisterTypeLib)(pTLibAttr->guid, pTLibAttr->wMajorVerNum,
                        pTLibAttr->wMinorVerNum,
                        pTLibAttr->lcid,
                        pTLibAttr->syskind);

            pTypeLib->ReleaseTLibAttr(pTLibAttr);
        }

        pTypeLib->Release();
    }

    return hr;
}


HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);

        if (pfnri)
        {
            hr = pfnri(GlobalDllHandle, szSection, NULL);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}


STDAPI DllRegisterServer()
{

    HRESULT hr;

    if (!DelayLoad( &g_moduleOleAut32))
    {
        return E_OUTOFMEMORY;
    }
    
    hr = CallRegInstall("Reg");

    if (SUCCEEDED(hr))
    {
        hr = RegisterTypeLib();
    }

    return hr;
}



STDAPI DllUnregisterServer()
{
    HRESULT hr;

    if (!DelayLoad( &g_moduleOleAut32))
    {
        return E_OUTOFMEMORY;
    }

    UnregisterTypeLib();

    hr = CallRegInstall("Unreg");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\handles\connect.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    connect.cxx

Abstract:

    Contains methods for INTERNET_CONNECT_HANDLE_OBJECT class

    Contents:
        RMakeInternetConnectObjectHandle
        INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT
        INTERNET_CONNECT_HANDLE_OBJECT::~INTERNET_CONNECT_HANDLE_OBJECT

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>

//
// functions
//


DWORD
RMakeInternetConnectObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN LPSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Creates an INTERNET_CONNECT_HANDLE_OBJECT. Wrapper function callable from
    C code

Arguments:

    ParentHandle    - parent InternetOpen() handle

    ChildHandle     - IN: protocol-specific child handle
                      OUT: address of handle object

    lpszServerName  - pointer to server name

    nServerPort     - server port to connect to

    dwFlags         - various open flags from InternetConnect()

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    INTERNET_CONNECT_HANDLE_OBJECT * hConnect;

    hConnect = New INTERNET_CONNECT_HANDLE_OBJECT(
                                (INTERNET_HANDLE_BASE *)ParentHandle,
                                *ChildHandle,
                                lpszServerName,
                                nServerPort,
                                dwFlags
                                );

    if (hConnect != NULL) {

        hConnect->Reference();  // claim a reference for the InternetConnectA() API

        error = hConnect->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            if (!(dwFlags & WINHTTP_CONNECT_FLAG_NO_INDICATION))
            {
                error = InternetIndicateStatusNewHandle((LPVOID)hConnect);
            }

            //
            // ERROR_WINHTTP_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_WINHTTP_OPERATION_CANCELLED);

                BOOL fDeleted = hConnect->Dereference();
                INET_ASSERT(fDeleted);
                UNREFERENCED_PARAMETER(fDeleted);
                
                hConnect = NULL;
            }
        } else {
            delete hConnect;
            hConnect = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ChildHandle = (HINTERNET)hConnect;

    return error;
}


//
// INTERNET_CONNECT_HANDLE_OBJECT class implementation
//


INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT *InternetConnectObj
    ) : INTERNET_HANDLE_BASE((INTERNET_HANDLE_BASE *)InternetConnectObj)

/*++

Routine Description:

    Constructor that creates a copy of an INTERNET_CONNECT_HANDLE_OBJECT when
    generating a derived handle object, such as a HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    InternetConnectObj  - INTERNET_CONNECT_HANDLE_OBJECT to copy

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT",
                 "%#x",
                 InternetConnectObj
                 ));

    //
    // copy the name objects and server port
    //

    _HostName = InternetConnectObj->_HostName;
    _HostNameNoScopeID = InternetConnectObj->_HostNameNoScopeID;
    _HostNameFlags = InternetConnectObj->_HostNameFlags;
    _HostPort = InternetConnectObj->_HostPort;

    //
    // _SchemeType is actual scheme we use. May be different than original
    // object type when going via CERN proxy. Initially set to default (HTTP)
    //

    _SchemeType = InternetConnectObj->_SchemeType;

    DEBUG_LEAVE(0);
}


INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT(
    INTERNET_HANDLE_BASE * Parent,
    HINTERNET Child,
    LPTSTR lpszServerName,
    INTERNET_PORT nServerPort,
    DWORD dwFlags
    ) : INTERNET_HANDLE_BASE(Parent)

/*++

Routine Description:

    Constructor for direct-to-net INTERNET_CONNECT_HANDLE_OBJECT

Arguments:

    Parent          - pointer to parent handle (INTERNET_HANDLE_BASE as
                      created by InternetOpen())

    Child           - handle of child object - typically an identifying value
                      for the protocol-specific code

    lpszServerName  - name of the server we are connecting to. May also be the
                      IP address expressed as a string

    nServerPort     - the port number at the server to which we connect

    dwFlags         - creation flags from InternetConnect():

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(Child);
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_CONNECT_HANDLE_OBJECT::INTERNET_CONNECT_HANDLE_OBJECT",
                 "%#x, %#x, %q, %d, %#x, %#x",
                 Parent,
                 Child,
                 lpszServerName,
                 nServerPort,
                 dwFlags
                 ));


    // _HostName, _HostNameScopeID, _HostNameFlags all handled by SetHostName()
    SetHostName(lpszServerName);
    _HostPort = nServerPort;
    SetSchemeType(INTERNET_SCHEME_HTTP);
    SetObjectType(TypeHttpConnectHandle);
    _Status = ERROR_SUCCESS; // BUGBUG: what if we fail to allocate _HostName?


    
    DEBUG_LEAVE(0);
}


INTERNET_CONNECT_HANDLE_OBJECT::~INTERNET_CONNECT_HANDLE_OBJECT(VOID)

/*++

Routine Description:

    Destructor for INTERNET_CONNECT_HANDLE_OBJECT

Arguments:

    None.

Return Value:

    None.

--*/

{
    // Nothing to see here, people; move along!
}

VOID INTERNET_CONNECT_HANDLE_OBJECT::SetHostName(
    LPSTR lpszHostName
    )
/*++

Routine Description:

    Stores the Host Name in an INTERNET_CONNECT_HANDLE_OBJECT

Arguments:

    lpszHostName    - name of the server we are connecting to. May also be an
                      IP address expressed as a string 

Return Value:

    None.

--*/
{
    SOCKADDR_IN6 Address;
    INT Error;
    INT AddressLength;
    
    _HostNameFlags = 0;
    
    // check if this is a valid IPv4 iteral

    AddressLength = sizeof(Address);
    Error = _I_WSAStringToAddressA((LPSTR)lpszHostName, AF_INET, NULL, (LPSOCKADDR)&Address, &AddressLength);

    if (Error == 0) {
        _HostNameFlags |= _IPv4LiteralFlag; 
    } else {
    
        // not an IPv4 literal, could be an IPv6 literal

        AddressLength = sizeof(Address);
        Error = _I_WSAStringToAddressA((LPSTR)lpszHostName, AF_INET6, NULL, (LPSOCKADDR)&Address, &AddressLength);

        if (Error == 0) {

            _HostNameFlags |= _IPv6LiteralFlag;

            if (Address.sin6_scope_id != 0) {
                _HostNameFlags |= _IPv6ScopeIDFlag;
            }
        }
    }

    // If IPv6 literal address, check if it is encapsulated with '[' and ']'

    BOOL  bracketsNeeded = FALSE;
    DWORD len = strlen(lpszHostName);
    if ((_HostNameFlags & _IPv6LiteralFlag) != 0)
    { 
        if ((lpszHostName[0] != '[') || (lpszHostName[len-1] != ']'))
        {
            // no brackets so we have to add them
            bracketsNeeded = TRUE;
        }
    }

    if (!bracketsNeeded) 
    {
        _HostName = lpszHostName;
    }
    else
    {
        // using ICSTRING efficiently construct string with brackets   
        _HostName.CreateStringBuffer("[", 1, len+3); // 3 = 2 brackets + 1 null
        _HostName.Strncat(lpszHostName, len);
        _HostName.Strncat("]", 1);
    }

    // If IPv6 literal address has a scope ID then build a no-scope-id hostname

    if ((_HostNameFlags & _IPv6ScopeIDFlag) != 0)
    { 
        LPSTR lpszPercent = NULL;
        if ((lpszPercent = StrChrA(_HostName.StringAddress(), '%')) != NULL)
        {
            // using ICSTRING efficiently construct substring minus scope ID   
            len = (DWORD)(lpszPercent - _HostName.StringAddress());
            _HostNameNoScopeID.CreateStringBuffer(_HostName.StringAddress(), len, len+2); // 2 = 1 brkt + 1 null
            _HostNameNoScopeID.Strncat("]", 1);
        }
    }
    else
    {
        _HostNameNoScopeID = NULL;
    }

    //dprintf("_HostName          is %q\n", _HostName.StringAddress());
    //dprintf("_HostNameNoScopeID is %q\n", _HostNameNoScopeID.StringAddress());

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\http\cookiejar.h ===
#ifndef _COOKIE_JAR_H_
#define _COOKIE_JAR_H_

#include <wininetp.h>
#include "httpp.h"

//---------------------------------------------------------------------------
//
// CCookieBase
//
// Provides operator new which allocates extra memory
// after object and initializes the memory to zero.
//
//---------------------------------------------------------------------------

class CCookieBase
{
public:

    void * operator new(size_t cb, size_t cbExtra);
    void operator delete(void *pv);
};

//---------------------------------------------------------------------------
//
// CCookie
//
// Holds a single cookie value.
//
//---------------------------------------------------------------------------


class CCookie : public CCookieBase
{
public:

    ~CCookie();
    static CCookie *Construct(const char *pchName);

    BOOL            SetValue(const char *pchValue);
    BOOL            CanSend(BOOL fSecure);
    BOOL            IsPersistent() { return (_dwFlags & COOKIE_SESSION) == 0; }

    BOOL            PurgeAll(void *);

    DWORD           _dwFlags;
    CCookie *       _pCookieNext;
    char *          _pchName;
    char *          _pchValue;
    FILETIME        _ftExpiry;
};

//---------------------------------------------------------------------------
//
// CCookieLocation
//
// Holds all cookies for a given domain and path.
//
//---------------------------------------------------------------------------

class CCookieLocation : public CCookieBase
{
public:

    ~CCookieLocation();
    static CCookieLocation *Construct(const char *pchRDomain, const char *pchPath);

    CCookie *       GetCookie(const char *pchName, BOOL fCreate);
    BOOL            ReadCacheFile();
    BOOL            ReadCacheFileIfNeeded();
    void            Purge(BOOL (CCookie::*)(void *), void *);
    BOOL            IsMatch(const char *pchRDomain, const char *pchPath);

    FILETIME        _ftCacheFileLastModified;
    CCookie *       _pCookieKids;
    CCookieLocation*_pLocationNext;
    char *          _pchRDomain;
    char *          _pchPath;
    int             _cchPath;
    BYTE            _fReadFromCacheFileNeeded;
};


//---------------------------------------------------------------------------
//
// CCookieJar
//
// Maintains fixed size hash table of cookie location objects.
//
//---------------------------------------------------------------------------
enum SET_COOKIE_RESULT
{
    SET_COOKIE_FAIL     = 0,
    SET_COOKIE_SUCCESS  = 1,
    SET_COOKIE_DISALLOW = 2,
    SET_COOKIE_PENDING  = 3
};

class CCookieJar : public CCookieBase
{
public:

    static CCookieJar * Construct();

     CCookieJar();
    ~CCookieJar();

    DWORD             SetCookie(HTTP_REQUEST_HANDLE_OBJECT *pRequest, const char *pchURL, char *pchHeader, DWORD dwFlags);
    CCookieLocation*  GetCookies(const char *pchRDomain, const char *pchPath, CCookieLocation *pLast, FILETIME *ftCurrentTime);

    void              Purge();
    CCookieLocation** GetBucket(const char *pchRDomain);
    CCookieLocation * GetLocation(const char *pchRDomain, const char *pchPath, BOOL fCreate);
    void              Serialize(HANDLE hCookieFile);

    enum { htsize=32 };
    CCookieLocation * _apLocation[htsize];

    CCritSec          _csCookieJar;

private:
   void serializeCookie(const CCookie *pCookie, HANDLE hCookieFile, const char *pchDomain, const char *pchPath);
   void expireCookies(CCookieLocation *pLocation, FILETIME *ftRefTime);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\handles\hinet.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    hinet.cxx

Abstract:

    contains methods for INTERNET_HANDLE_BASE class

    Contents:
        HANDLE_OBJECT::HANDLE_OBJECT()
        HANDLE_OBJECT::HANDLE_OBJECT()
        HANDLE_OBJECT::Reference()
        HANDLE_OBJECT::Dereference()
        HANDLE_OBJECT::IsValid()
        INTERNET_HANDLE_BASE::INTERNET_HANDLE_BASE(LPCSTR, ...)
        INTERNET_HANDLE_BASE::INTERNET_HANDLE_BASE(INTERNET_HANDLE_BASE*)
        INTERNET_HANDLE_BASE::~INTERNET_HANDLE_BASE()
        INTERNET_HANDLE_BASE::SetAbortHandle(ICSocket)
        INTERNET_HANDLE_BASE::ResetAbortHandle()
        INTERNET_HANDLE_BASE::AbortSocket()
        INTERNET_HANDLE_BASE::SetProxyInfo()
        INTERNET_HANDLE_BASE::GetProxyInfo(LPVOID, LPDWORD)
        INTERNET_HANDLE_BASE::GetProxyInfo(INTERNET_SCHEME, LPINTERNET_SCHEME, LPSTR *, LPDWORD, LPINTERNET_PORT)

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "../http/cookiejar.h"
//
// private manifests
//

#define PROXY_REGISTRY_STRING_LENGTH    (4 K)

//
// methods
//


HANDLE_OBJECT::HANDLE_OBJECT(
    IN HANDLE_OBJECT * Parent
    )

/*++

Routine Description:

    HANDLE_OBJECT constructor

Arguments:

    Parent  - pointer to parent HANDLE_OBJECT

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "HANDLE_OBJECT",
                "%#x",
                this
                ));

    //InitializeListHead(&_List);
    _Parent = Parent;
    if (_Parent)
        _Parent->Reference();
    _Status = AllocateHandle(this, &_Handle);
    _ObjectType = TypeGenericHandle;
    _ReferenceCount = 1;
    _Invalid = FALSE;
    _Error = ERROR_SUCCESS;
    _Signature = OBJECT_SIGNATURE;
    _Context = NULL;

#if INET_DEBUG
    if (!InsertAtTailOfSerializedList(&GlobalObjectList, &_List))
        _Status = ERROR_NOT_ENOUGH_MEMORY;
#endif

    //
    // if AllocateHandle() failed then we cannot create this handle object.
    // Invalidate it ready for the destructor
    //

    if (_Status != ERROR_SUCCESS) {
        _Invalid = TRUE;
        _ReferenceCount = 0;
    }

    DEBUG_PRINT(OBJECTS,
                INFO,
                ("handle %#x created; address %#x; %d objects\n",
                _Handle,
                this,
                ElementsOnSerializedList(&GlobalObjectList)
                ));

    DEBUG_LEAVE(0);
}


HANDLE_OBJECT::~HANDLE_OBJECT(VOID)

/*++

Routine Description:

    HANDLE_OBJECT destructor. Virtual function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "~HANDLE_OBJECT",
                "%#x",
                this
                ));

#if INET_DEBUG
    //
    // remove this object from global object list
    //

    if (LockSerializedList(&GlobalObjectList))
    {
        // should always succeed since we already have the lock
        RemoveFromSerializedList(&GlobalObjectList, &_List);
        UnlockSerializedList(&GlobalObjectList);
    }
#endif

    INET_DEBUG_ASSERT((_List.Flink == NULL) && (_List.Blink == NULL));

    //
    // inform the app that this handle is completely closed
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL)
    {
        HINTERNET hCurrent = _InternetGetObjectHandle(lpThreadInfo);
        HINTERNET hCurrentMapped = _InternetGetMappedObjectHandle(lpThreadInfo);

        _InternetSetObjectHandle(lpThreadInfo, _Handle, (HINTERNET)this);

        HINTERNET hTemp = _Handle;
        InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING,
                               (LPVOID)&hTemp,
                               sizeof(hTemp)
                               );

        _InternetSetObjectHandle(lpThreadInfo, hCurrent, hCurrentMapped);
    }

    if (_Parent != NULL)
        _Parent->Dereference();
        
    //
    // now we can free up the API handle value
    //

    if (_Handle != NULL) {
        _Status = FreeHandle(_Handle);

        INET_ASSERT(_Status == ERROR_SUCCESS);

    }

    //
    // set the signature to a value that indicates the handle has been
    // destroyed (not useful in debug builds)
    //

    _Signature = DESTROYED_OBJECT_SIGNATURE;

    INET_ASSERT((_ReferenceCount == 0) && _Invalid);

    DEBUG_PRINT(OBJECTS,
                INFO,
                ("handle %#x destroyed; type %s; address %#x; %d objects\n",
                _Handle,
                InternetMapHandleType(_ObjectType),
                this,
                ElementsOnSerializedList(&GlobalObjectList)
                ));

    DEBUG_LEAVE(0);
}


DWORD
HANDLE_OBJECT::Reference(
    VOID
    )

/*++

Routine Description:

    Increases the reference count on the HANDLE_OBJECT

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    Handle has already been invalidated
                  ERROR_ACCESS_DENIED
                    Handle object is being destroyed, cannot use it

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Dword,
                 "HANDLE_OBJECT::Reference",
                 "{%#x}",
                 _Handle
                 ));

    DWORD error;

    if (_Invalid) {

        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("handle object %#x [%#x] is invalid\n",
                    _Handle,
                    this
                    ));

        error = ERROR_INVALID_HANDLE;
    } else {
        error = ERROR_SUCCESS;
    }

    //
    // even if the handle has been invalidated (i.e. closed), we allow it
    // to continue to be referenced. The caller should return the fact
    // that the handle has been invalidated, but may require information
    // from the object in order to do so (e.g. in async thread)
    //

    do
    {
        LONG lRefCountBeforeIncrement = _ReferenceCount;

        //
        // refcount is > 0 means that the object's destructor has not been called yet
        //
        if (lRefCountBeforeIncrement > 0)
        {
            //
            // try to increment the refcount using compare-exchange
            //
#ifndef _WIN64
            LONG lRefCountCurrent = (LONG)SHInterlockedCompareExchange((LPVOID*)&_ReferenceCount,
                                                                       (LPVOID)(lRefCountBeforeIncrement + 1),
                                                                       (LPVOID)lRefCountBeforeIncrement);
#else
            //
            // can't use SHInterlockedCompareExchange on win64 because the values are really LONG's (32-bits) but they
            // are treated as pointers (64-bits) because SHInterlockedCompareExchange should really be called 
            // SHInterlockedCompareExchangePointer (sigh...).
            //
            LONG lRefCountCurrent = InterlockedCompareExchange(&_ReferenceCount,
                                                               lRefCountBeforeIncrement + 1,
                                                               lRefCountBeforeIncrement);
#endif        
            if (lRefCountCurrent == lRefCountBeforeIncrement)
            {
                //
                // since SHInterlockedCompareExchange returns the value in _ReferenceCount 
                // before the exchange, we know the exchange sucessfully took place (i.e. we 
                // sucessfully incremented the refrence count of the object by one)
                //
                INET_ASSERT(lRefCountCurrent > 0);
                break;
            }
        }
        else
        {
            //
            // the refcount dropped to zero before we could increment it,
            // so the object is being destroyed. 
            //
            error = ERROR_ACCESS_DENIED;
            break;
        }

    } while (TRUE);

    DEBUG_PRINT(REFCOUNT,
                INFO,
                ("handle object %#x [%#x] ReferenceCount = %d\n",
                _Handle,
                this,
                _ReferenceCount
                ));

    DEBUG_LEAVE(error);

    return error;
}


BOOL
HANDLE_OBJECT::Dereference(
    VOID
    )

/*++

Routine Description:

    Reduces the reference count on the HANDLE_OBJECT, and if it goes to zero,
    the object is deleted

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - this object was deleted

        FALSE   - this object is still valid

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Bool,
                 "HANDLE_OBJECT::Dereference",
                 "{%#x}",
                 _Handle
                 ));

    //
    // by the time we get here, the reference count should not be 0. There
    // should be 1 call to Dereference() for each call to Reference()
    //

    INET_ASSERT(_ReferenceCount != 0);

    BOOL deleted = FALSE;

    if (InterlockedDecrement(&_ReferenceCount) == 0)
    {
        deleted = TRUE;
    }


    if (deleted)
    {
        //
        // if we are calling the destructor, the handle had better be invalid!
        //
        INET_ASSERT(_Invalid);
        
        //
        // this handle has now been closed. If there is no activity on it
        // then it will be destroyed
        //

        DEBUG_PRINT(REFCOUNT,
                    INFO,
                    ("handle object %#x [%#x] ReferenceCount = %d\n",
                    _Handle,
                    this,
                    _ReferenceCount
                    ));

        delete this;
    } else {

        DEBUG_PRINT(REFCOUNT,
                    INFO,
                    ("handle object %#x [%#x] ReferenceCount = %d\n",
                    _Handle,
                    this,
                    _ReferenceCount
                    ));
    }

    DEBUG_LEAVE(deleted);

    return deleted;
}


DWORD
HANDLE_OBJECT::IsValid(
    IN HINTERNET_HANDLE_TYPE ExpectedHandleType
    )

/*++

Routine Description:

    Checks a HANDLE_OBJECT for validity

Arguments:

    ExpectedHandleType  - type of object we are testing for. Can be
                          TypeWildHandle which matches any valid handle

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    The handle object is invalid

                  ERROR_WINHTTP_INCORRECT_HANDLE_TYPE
                    The handle object is valid, but not the type we want

--*/

{
    DWORD error;

    //
    // test handle object within try..except in case we are given a bad address
    //

    __try {
        if (_Signature == OBJECT_SIGNATURE) {

            error = ERROR_SUCCESS;

            //
            // check handle type if we are asked to do so.
            //

            if (ExpectedHandleType != TypeWildHandle) {
                if (ExpectedHandleType != this->GetHandleType()) {
                    error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
                }
            }
        } else {
            error = ERROR_INVALID_HANDLE;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_HANDLE;
    }
    ENDEXCEPT
    return error;
}


INTERNET_HANDLE_BASE::INTERNET_HANDLE_BASE(
    LPCSTR UserAgent,
    DWORD AccessMethod,
    LPSTR ProxyServerList,
    LPSTR ProxyBypassList,
    DWORD Flags
    ) : HANDLE_OBJECT(NULL)

/*++

Routine Description:

    Creates the handle object for InternetOpen()

Arguments:

    UserAgent       - name of agent (user-agent string for HTTP)

    AccessMethod    - DIRECT, PROXY or PRECONFIG

    ProxyServerList - one or more proxy servers. The string has the form:

                        [<scheme>=][<scheme>"://"]<server>[":"<port>][";"*]

    ProxyBypassList - zero or more addresses which if matched will result in
                      requests NOT going via the proxy (only if PROXY access).
                      The string has the form:

                        bp_entry ::= [<scheme>"://"]<server>[":"<port>]
                        bp_macro ::= "<local>"
                        bp_list ::= [<> | bp_entry bp_macro][";"*]

    Flags           - various open flags:

                        WINHTTP_FLAG_ASYNC - not support in WinHttpX

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_BASE::INTERNET_HANDLE_BASE",
                 NULL
                 ));


    //
    // if the HANDLE_OBJECT constructor failed then bail out now
    //

    if (_Status != ERROR_SUCCESS) {

        DEBUG_PRINT(OBJECTS,
                    ERROR,
                    ("early-exit: _Status = %d\n",
                    _Status
                    ));

        DEBUG_LEAVE(0);

        return;
    }

    _PPContext = 0;

    _fDisableTweener = TRUE;
    _fDisableKeyring = TRUE;

    _ThreadToken = 0;
    
    _IsCopy = FALSE;
    _UserAgent = (LPSTR)UserAgent;
    _ProxyInfo = NULL;
    _dwInternetOpenFlags = Flags;
    _WinsockLoaded = FALSE;

    _Context = NULL;

    _MaxConnectionsPerServer    = WINHTTP_CONNS_PER_SERVER_UNLIMITED;
    _MaxConnectionsPer1_0Server = WINHTTP_CONNS_PER_SERVER_UNLIMITED;
    
    //
    // set _Async based on the WINHTTP_FLAG_ASYNC supplied to InternetOpen()
    //

    _dwCodePage                 = CP_UTF8;
    _Async = (Flags & WINHTTP_FLAG_ASYNC) ? TRUE : FALSE;

    //
    // no data available yet
    //

    SetAvailableDataLength(0);

    //
    // not yet end of file
    //

    ResetEndOfFile();

    //
    // no status callback by default
    //

    _StatusCallback = NULL;
    _StatusCallbackType = FALSE;
    _dwStatusCallbackFlags = 0;

    SetObjectType(TypeInternetHandle);

    _ProxyInfoResourceLock.Initialize();

    _Status = SetProxyInfo(AccessMethod, ProxyServerList, ProxyBypassList);

    //
    // if _pICSocket is not NULL then this is the socket that this object handle
    // is currently working on. We close it to cancel the operation
    //

    _pICSocket = NULL;

    
    if (::OpenThreadToken(
                GetCurrentThread(),
                TOKEN_READ | TOKEN_IMPERSONATE,
                FALSE,
                &_ThreadToken
                ) == FALSE)
    {
        _ThreadToken = 0;
    }
    //
    // load winsock now.
    //

    if (_Status == ERROR_SUCCESS) {
    
        _Status = LoadWinsock();
        _WinsockLoaded = (_Status == ERROR_SUCCESS);

        if ( _Status == ERROR_SUCCESS )
        {
             LONG lOpenHandleCnt;

             LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

             if ( lpThreadInfo )
             {
                 lOpenHandleCnt = InterlockedIncrement((LPLONG)&GlobalInternetOpenHandleCount);

                 if ( lOpenHandleCnt == 0 )
                 {
                    DWORD fAlreadyInInit = (DWORD) InterlockedExchange((LPLONG) &GlobalAutoProxyInInit, TRUE);

                    UNREFERENCED_PARAMETER(fAlreadyInInit);
                    INET_ASSERT (! fAlreadyInInit );

                    g_pGlobalProxyInfo->ReleaseQueuedRefresh();

                    InterlockedExchange((LPLONG)&GlobalAutoProxyInInit, FALSE);
                 }
             }
        }
    }

    DEBUG_LEAVE(0);
}


INTERNET_HANDLE_BASE::INTERNET_HANDLE_BASE(
    INTERNET_HANDLE_BASE *INetObj
    ) : HANDLE_OBJECT((HANDLE_OBJECT*)INetObj)

/*++

Routine Description:

    Constructor for derived handle object. We are creating this handle as part
    of an INTERNET_CONNECT_HANDLE_OBJECT

Arguments:

    INetObj - pointer to INTERNET_HANDLE_BASE to copy

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_BASE::INTERNET_HANDLE_BASE",
                 "{IsCopy}"
                 ));

    _PPContext = INetObj->_PPContext;
    _fDisableTweener = INetObj->_fDisableTweener;
    _fDisableKeyring = INetObj->_fDisableKeyring;
    _ThreadToken = INetObj->_ThreadToken;
    
    _IsCopy = TRUE;

    //
    // copy user agent string
    //

    //
    // BUGBUG - compiler generated copy constructor (no new string)
    //

    _UserAgent = INetObj->_UserAgent;

    //
    // do not inherit the proxy info - code must go to parent handle
    //

    _ProxyInfo = NULL;

    _ProxyInfoResourceLock.Initialize();

    _dwInternetOpenFlags = INetObj->_dwInternetOpenFlags;

    //
    // creating this handle didn't load winsock
    //

    _WinsockLoaded = FALSE;

    //
    // inherit the context, async flag and status callback from
    // the parent object handle
    //

    _Context = INetObj->_Context;
 
    _MaxConnectionsPerServer    = INetObj->_MaxConnectionsPerServer;
    _MaxConnectionsPer1_0Server = INetObj->_MaxConnectionsPer1_0Server;

    _dwCodePage = INetObj->_dwCodePage;

    _Async = INetObj->_Async;

    //
    // inherit callback function
    //

    SetAvailableDataLength(0);
    ResetEndOfFile();
    _StatusCallback = INetObj->_StatusCallback;
    _StatusCallbackType = INetObj->_StatusCallbackType;
    _dwStatusCallbackFlags = INetObj->_dwStatusCallbackFlags;


    //
    // no socket operation to abort yet
    //

    _pICSocket = NULL;

    //
    // BUGBUG - this overwrites status set above?
    //

    _Status = INetObj->_Status;


    DEBUG_LEAVE(0);
}


INTERNET_HANDLE_BASE::~INTERNET_HANDLE_BASE(
    VOID
    )

/*++

Routine Description:

    INTERNET_HANDLE_BASE destructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_BASE::~INTERNET_HANDLE_BASE",
                 ""
                 ));


    if (_ProxyInfo && !IsProxyGlobal() && (_ProxyInfo != PROXY_INFO_DIRECT))
    {
        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("Free-ing ProxyInfo\n"
                    ));

        delete _ProxyInfo;
        _ProxyInfo = NULL;
    }


    //
    // if this handle is not a copy (i.e., it is a Session handle), then delete
    // the Passport context
    //

    if (!IsCopy()) {

        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("Not a Copy...\n"
                    ));

        if (_PPContext)
        {
            ::PP_FreeContext(_PPContext);
        }

        //
        // don't unload winsock. There really is no need to unload separately
        // from process detach and if we do unload, we first have to terminate
        // async support. Dynaloading and unloading winsock is vestigial
        //

        //if (_WinsockLoaded) {
        //    UnloadWinsock();
        //}

        if (_ThreadToken)
        {
            ::CloseHandle(_ThreadToken);
            _ThreadToken = NULL;
        }
    }

    DEBUG_LEAVE(0);
}

DWORD
INTERNET_HANDLE_BASE::ExchangeStatusCallback(
    LPWINHTTP_STATUS_CALLBACK lpStatusCallback,
    BOOL fType,
    DWORD dwFlags
    )
{
    DWORD error;


    WINHTTP_STATUS_CALLBACK callback;

    // exchange new and current callbacks
    callback = _StatusCallback;
    _StatusCallback = *lpStatusCallback;
    *lpStatusCallback = callback;
    _StatusCallbackType = fType;
    _dwStatusCallbackFlags = dwFlags;
    error = ERROR_SUCCESS;

    return error;
}


VOID
INTERNET_HANDLE_BASE::SetAbortHandle(
    IN ICSocket * Socket
    )

/*++

Routine Description:

    Associates with this request handle the ICSocket object currently being used
    for network I/O

Arguments:

    Socket  - pointer to ICSocket

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS | DBG_SOCKETS,
                 None,
                 "INTERNET_HANDLE_BASE::SetAbortHandle",
                 "{%#x} %#x [sock=%#x ref=%d]",
                 GetPseudoHandle(),
                 Socket,
                 Socket ? Socket->GetSocket() : 0,
                 Socket ? Socket->ReferenceCount() : 0
                 ));

    INET_ASSERT(Socket != NULL);

    //
    // first off, increase the socket reference count to stop any other threads
    // killing it whilst we are performing the socket operation. The only way
    // another thread can dereference the socket is by calling our AbortSocket()
    // method
    //

    Socket->Reference();

    //
    // now associate the socket object with this handle object. We should not
    // have a current association
    //

    ICSocket * pSocket;

    pSocket = (ICSocket *) InterlockedExchangePointer((PVOID*)&_pICSocket, Socket);

    //
    // because ConnectSocket() can call this method multiple times without
    // intervening calls to ResetAbortHandle(), pSocket can legitimately be
    // non-NULL at this point
    //

    //INET_ASSERT(pSocket == NULL);

    //
    // if the handle was invalidated on another thread before we got
    // chance to set the socket to close, then abort the request now
    //

    //
    // BUGBUG - screws up normal FTP close handle processing - we
    //          have to communicate with the server in order to
    //          drop the connection
    //

    //if (IsInvalidated()) {
    //    AbortSocket();
    //}

    DEBUG_LEAVE(0);
}


VOID
INTERNET_HANDLE_BASE::ResetAbortHandle(
    VOID
    )

/*++

Routine Description:

    Disassociates this request handle and the ICSocket object when the network
    operation has completed

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS | DBG_SOCKETS,
                 None,
                 "INTERNET_HANDLE_BASE::ResetAbortHandle",
                 "{%#x}",
                 GetPseudoHandle()
                 ));

    //
    // there really should be a ICSocket associated with this object, otherwise
    // our handle close/invalidation logic is broken
    //

    //
    // however, we can call ResetAbortHandle() from paths where we completed
    // early, not having called SetAbortHandle()
    //

    //INET_ASSERT(pSocket != NULL);

    //
    // so if there was a ICSocket associated with this object then remove the
    // reference added in SetAbortHandle()
    //


    ICSocket * pICSocket;

    pICSocket = (ICSocket *)InterlockedExchangePointer((PVOID*)&_pICSocket, NULL);
    if (pICSocket != NULL) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("socket=%#x ref=%d\n",
                    pICSocket->GetSocket(),
                    pICSocket->ReferenceCount()
                    ));

        pICSocket->Dereference();
    }

    DEBUG_LEAVE(0);
}


VOID
INTERNET_HANDLE_BASE::AbortSocket(
    VOID
    )

/*++

Routine Description:

    If there is a ICSocket associated with this handle object then abort it. This
    forces the current network operation aborted and the request to complete
    with ERROR_WINHTTP_OPERATION_CANCELLED

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS | DBG_SOCKETS,
                 None,
                 "INTERNET_HANDLE_BASE::AbortSocket",
                 "{%#x, %#x [sock=%#x, ref=%d]}",
                 GetPseudoHandle(),
                 (_pICSocket != NULL)
                    ? (LPVOID)_pICSocket
                    : (LPVOID)_pICSocket,
                 _pICSocket
                    ? _pICSocket->GetSocket()
                    : (_pICSocket
                        ? _pICSocket->GetSocket()
                        : 0),
                 _pICSocket
                    ? _pICSocket->ReferenceCount()
                    : (_pICSocket
                        ? _pICSocket->ReferenceCount()
                        : 0)
                 ));

    //
    // get the associated ICSocket. It may have already been removed by a call
    // to ResetAbortHandle()
    //

    //
    // if there is an associated ICSocket then abort it (close the socket handle)
    // which will complete the current network I/O (if active) with an error.
    // Once the ICSocket is aborted, we reduce the reference count that was added
    // in SetAbortHandle(). This may cause the ICSocket to be deleted
    //

    LPVOID pAddr;

    pAddr = (LPVOID)InterlockedExchangePointer((PVOID*)&_pICSocket, NULL);
    if (pAddr != NULL) {

        ICSocket * pSocket = (ICSocket *)pAddr;
//dprintf(">>>>>>>> %#x AbortSocket %#x [%#x]\n", GetCurrentThreadId(), pSocket, pSocket->GetSocket());
        pSocket->Abort();
        pSocket->Dereference();
    }

    DEBUG_LEAVE(0);
}


DWORD
INTERNET_HANDLE_BASE::Refresh()
/*++

Routine Description:

    Refreshes the proxy info on an InternetOpen() HINTERNET based on the parameters

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Return Value:

    DWORD
        Success - ERROR_SUCCESS

--*/
{

    //
    // Reload the proxy info from registry into the GlobalProxyInfo object,
    // unless it was changed in-process to something else.
    //

    if (!g_pGlobalProxyInfo->IsModifiedInProcess()) {

        return LoadProxySettings();

    } else {

        //
        // not using global proxy or it has been set to something other
        // than the registry contents. Just return success
        //

        return ERROR_SUCCESS;
    }
}



DWORD
INTERNET_HANDLE_BASE::SetProxyInfo(
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL
    )

/*++

Routine Description:

    Sets the proxy info on an InternetOpen() HINTERNET based on the parameters

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:

    dwAccessType    - type of proxy access required

    lpszProxy       - pointer to proxy server list

    lpszProxyBypass - pointer to proxy bypass list

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "INTERNET_HANDLE_BASE::SetProxyInfo",
                "%s (%d), %#x (%q), %#x (%q)",
                InternetMapOpenType(dwAccessType),
                dwAccessType,
                lpszProxy,
                lpszProxy,
                lpszProxyBypass,
                lpszProxyBypass
                ));

    //
    // Session and HTTP Request objects can have proxy information
    //

    INET_ASSERT((GetHandleType()==TypeInternetHandle) || (GetHandleType()==TypeHttpRequestHandle));

/*

    We are setting the proxy information for an InternetOpen() handle. Based on
    the current and new settings we do the following (Note: the handle is
    initialized to DIRECT operation):

                                        current access
                +---------------------------------------------------------------
        new     |      DIRECT        |       PROXY        |      PRECONFIG
       access   |                    |                    |
    +-----------+--------------------+--------------------+---------------------
    | DIRECT    | No action          | Delete proxy info  | Remove reference to
    |           |                    |                    | global proxy info
    +-----------+--------------------+--------------------+---------------------
    | PROXY     | Set new proxy info | Delete proxy info. | Remove reference to
    |           |                    | Set new proxy info | global proxy info.
    |           |                    |                    | Set new proxy info
    +-----------+--------------------+--------------------+---------------------
    | PRECONFIG | Set proxy info to  | Delete proxy info. | No action
    |           | global proxy info  | Set proxy info to  |
    |           |                    | global proxy info  |
    +-----------+--------------------+--------------------+---------------------
*/

    DWORD error = ERROR_SUCCESS;
    PROXY_INFO * proxyInfo = NULL;

    //
    // acquire proxy info for exclusive access
    //

    if (!AcquireProxyInfo(TRUE))
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if (IsProxy()) {

        //
        // delete private proxy info, or unlink from global proxy info
        //

        SafeDeleteProxyInfo();
    }


    switch (dwAccessType)
    {
        case WINHTTP_ACCESS_TYPE_NO_PROXY:
            proxyInfo = PROXY_INFO_DIRECT;
            break;

        case WINHTTP_ACCESS_TYPE_NAMED_PROXY:
            {
                INET_ASSERT(!IsProxy());

                INTERNET_HANDLE_OBJECT * pSession;

                if (IsCopy())
                {
                    pSession = GetRootHandle(this);
                }
                else
                {
                    pSession = static_cast<INTERNET_HANDLE_OBJECT *>(this);
                    INET_ASSERT(pSession->IsValid(TypeInternetHandle) == ERROR_SUCCESS);
                }

                proxyInfo = New PROXY_INFO;
                if (proxyInfo != NULL) {
                    proxyInfo->InitializeProxySettings();
                    proxyInfo->SetSessionObject(pSession);
                    error = proxyInfo->GetError();
                    if (error == ERROR_SUCCESS &&
                        lpszProxy ) 
                    {

                        INTERNET_PROXY_INFO_EX info;
                        memset(&info, 0, sizeof(info));
                        info.dwStructSize = sizeof(info);
                        info.dwFlags = (PROXY_TYPE_DIRECT | PROXY_TYPE_PROXY);

                        info.lpszProxy = lpszProxy;
                        info.lpszProxyBypass = lpszProxyBypass;

                        error = proxyInfo->SetProxySettings(&info, TRUE /*modified*/);

                    }
                    if (error != ERROR_SUCCESS) {
                        delete proxyInfo;
                        proxyInfo = NULL;
                    }
                } else {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                }

                break;
            }

        case WINHTTP_ACCESS_TYPE_DEFAULT_PROXY:
            {
                INTERNET_HANDLE_OBJECT * pSession;

                if (IsCopy())
                {
                    pSession = GetRootHandle(this);
                }
                else
                {
                    pSession = static_cast<INTERNET_HANDLE_OBJECT *>(this);
                    INET_ASSERT(pSession->IsValid(TypeInternetHandle) == ERROR_SUCCESS);
                }

                // Refresh global proxy info.
                Refresh();

                proxyInfo = New PROXY_INFO;
                if (proxyInfo != NULL) {
                    proxyInfo->InitializeProxySettings();
                    proxyInfo->SetSessionObject(pSession);
                    error = proxyInfo->GetError();
                    if (error == ERROR_SUCCESS)
                    {

                        INTERNET_PROXY_INFO_EX info;
                        memset(&info, 0, sizeof(info));
                        info.dwStructSize = sizeof(info);

                        INET_ASSERT(g_pGlobalProxyInfo != NULL);

                        error = g_pGlobalProxyInfo->GetProxySettings(&info, FALSE);

                        if (error == ERROR_SUCCESS)
                        {
                            error = proxyInfo->SetProxySettings(&info, TRUE /*modified*/);

                            if (info.lpszProxy)
                            {
                                FREE_MEMORY(info.lpszProxy);
                            }
                            if (info.lpszProxyBypass)
                            {
                                FREE_MEMORY(info.lpszProxyBypass);
                            }
                        }
                    }
                    if (error != ERROR_SUCCESS)
                    {
                        delete proxyInfo;
                        proxyInfo = NULL;
                    }
                } else {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                }

                break;
            }

        default:
            proxyInfo = NULL;
            break;
    }

    SetProxyInfo(proxyInfo);

    ReleaseProxyInfo();

quit:
    DEBUG_LEAVE(error);

    return error;
}


DWORD
INTERNET_HANDLE_BASE::GetProxyStringInfo(
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns the current proxy information for this INTERNET_HANDLE_BASE

Arguments:

    lpBuffer            - pointer to buffer where WINHTTP_PROXY_INFOA will be
                          written, and any proxy strings (if sufficient space)

    lpdwBufferLength    - IN: number of bytes in lpBuffer
                          OUT: number of bytes returned in lpBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    lpBuffer doesn't have enough space to hold the proxy
                    information. *lpdwBufferLength has the required size

--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "INTERNET_HANDLE_BASE::GetProxyStringInfo",
                "%#x, %#x [%d]",
                lpBuffer,
                lpdwBufferLength,
                lpdwBufferLength ? *lpdwBufferLength : 0
                ));

    INET_ASSERT(!IsCopy());

    AcquireProxyInfo(FALSE);

    DWORD error;

    if (IsProxy()) {
        error = _ProxyInfo->GetProxyStringInfo(lpBuffer, lpdwBufferLength);
    } else {
        if (*lpdwBufferLength >= sizeof(WINHTTP_PROXY_INFOA)) {

            WINHTTP_PROXY_INFOA * lpInfo = (WINHTTP_PROXY_INFOA *)lpBuffer;

            lpInfo->dwAccessType = WINHTTP_ACCESS_TYPE_NO_PROXY;
            lpInfo->lpszProxy = NULL;
            lpInfo->lpszProxyBypass = NULL;
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        *lpdwBufferLength = sizeof(WINHTTP_PROXY_INFOA);
    }

    ReleaseProxyInfo();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
INTERNET_HANDLE_BASE::GetProxyInfo(
    IN AUTO_PROXY_ASYNC_MSG **ppQueryForProxyInfo
    )

/*++

Routine Description:

    Returns all proxy information based on a protocol scheme

Arguments:

    tProtocol           - protocol to get proxy info for

    lptScheme           - returned scheme

    lplpszHostName      - returned proxy name

    lpdwHostNameLength  - returned length of proxy name

    lpHostPort          - returned proxy port

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

--*/

{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "INTERNET_HANDLE_BASE::GetProxyInfo",
                 "%#x",
                 ppQueryForProxyInfo
                 ));

    INET_ASSERT((GetHandleType() == TypeInternetHandle) ||
                (GetHandleType() == TypeHttpRequestHandle));

    DWORD error;

    AcquireProxyInfo(FALSE);

    if ( _ProxyInfo && _ProxyInfo != PROXY_INFO_DIRECT )
    {
        error = _ProxyInfo->QueryProxySettings(ppQueryForProxyInfo);
    }
    else
    {
        error = ERROR_SUCCESS;
        (*ppQueryForProxyInfo)->SetUseProxy(FALSE);
    }

    ReleaseProxyInfo();

    DEBUG_LEAVE(error);

    return error;
}


BOOL
INTERNET_HANDLE_BASE::RedoSendRequest(
    IN OUT LPDWORD lpdwError,
    IN DWORD dwSecureStatus,
    IN AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo,
    IN CServerInfo *pOriginServer,
    IN CServerInfo *pProxyServer
    )
{

    INET_ASSERT(!IsCopy());

    BOOL rc;

   AcquireProxyInfo(FALSE);

    if ( _ProxyInfo )
    {
        rc = _ProxyInfo->RedoSendRequest(
                                         lpdwError,
                                         dwSecureStatus,
                                         pQueryForProxyInfo,
                                         pOriginServer,
                                         pProxyServer
                                         );
    }
    else
    {
        rc = FALSE;
    }

    ReleaseProxyInfo();

    return rc;
}

INTERNET_HANDLE_OBJECT::INTERNET_HANDLE_OBJECT
    (LPCSTR ua, DWORD access, LPSTR proxy, LPSTR bypass, DWORD flags)
        : INTERNET_HANDLE_BASE (ua, access, proxy, bypass, flags)
{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_OBJECT::INTERNET_HANDLE_OBJECT",
                 NULL
                 ));
                 
    InterlockedIncrement(&g_cSessionCount);
    if (g_pAsyncCount)
    {
        if (flags & WINHTTP_FLAG_ASYNC)
        {
            _Status = g_pAsyncCount->AddRef();
        }
    }
    else
    {
        RIP(FALSE);
    }

    InitializeSerializedList(&_ServerInfoList);
    //
    // WinHttpX supports session cookies. Each session has it's own
    // cookie jar, instead of a shared global cookie jar as in WinInet.
    //
    _CookieJar = NULL;
    _pOptionalParams = NULL;
    _pSessionCertCache = NULL;
    _pAutoProxy = NULL;
    _hAPBinding = NULL;

    _pResolverCache = New CResolverCache(&_Status);
    if (!_pResolverCache)
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    if (_Status == ERROR_SUCCESS)
    {
        _CookieJar = CreateCookieJar();
        if (_CookieJar == NULL)
            _Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (_Status == ERROR_SUCCESS)
    {
        _pSessionCertCache = New SECURITY_CACHE_LIST;
        if (!_pSessionCertCache || !_pSessionCertCache->Initialize())
        {
            _Status = ERROR_NOT_ENOUGH_MEMORY;

            if (_pSessionCertCache)
            {
                delete _pSessionCertCache;
                _pSessionCertCache = NULL;
            }
        }
    }

    if (_Status == ERROR_SUCCESS)
    {
        _pAutoProxy = New CAutoProxy(this);

        if (!_pAutoProxy || !_pAutoProxy->Initialize())
        {
            _Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    DEBUG_LEAVE(0);
};

INTERNET_HANDLE_OBJECT::~INTERNET_HANDLE_OBJECT ( )
{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_HANDLE_OBJECT::~INTERNET_HANDLE_OBJECT",
                 NULL
                 ));
                 
    PurgeServerInfoList(TRUE);

    TerminateSerializedList(&_ServerInfoList);

    if (_pResolverCache)
    {
        _pResolverCache->EmptyHandlesList();
        delete _pResolverCache;
    }
    
    delete _pOptionalParams;
    _pOptionalParams = NULL;
    // Delete Cookie Jar
    CloseCookieJar(_CookieJar);
    _CookieJar = NULL;

    if (_hAPBinding)
    {
        ::RpcBindingFree(&_hAPBinding);
        _hAPBinding = NULL;
    }

    if (_pSessionCertCache)
        _pSessionCertCache->Release();

    if (_pAutoProxy)
        delete _pAutoProxy;

    if (g_pAsyncCount)
    {
        if (_Async)
            g_pAsyncCount->Release();
    }
    else
    {
        RIP(FALSE);
    }
        
    DEBUG_LEAVE(0);
}

//
// This function walks up to the InternetOpen handle from either
// a connect handle (child) or a request handle (grandchild).
// We only go one or two hops rather than recurse.
//

INTERNET_HANDLE_OBJECT* GetRootHandle (HANDLE_OBJECT* pHandle)
{
    pHandle = (HANDLE_OBJECT*) pHandle->GetParent();
    INET_ASSERT (pHandle);
    if (pHandle->GetHandleType() == TypeInternetHandle)
        return (INTERNET_HANDLE_OBJECT*) pHandle;

    pHandle =  (HANDLE_OBJECT*) pHandle->GetParent();
    INET_ASSERT (pHandle);
    INET_ASSERT (pHandle->GetHandleType() == TypeInternetHandle);
    return (INTERNET_HANDLE_OBJECT*) pHandle;
}

BOOL INTERNET_HANDLE_OBJECT::ClearPassportCookies(PSTR pszUrl)
{
    BOOL fRetVal = FALSE;

    char *  pchRDomain = NULL;
    char *  pchPath = NULL;
    BOOL    fSecure;

    if (!PathAndRDomainFromURL(pszUrl, &pchRDomain, &pchPath, &fSecure, FALSE))
    {
        return fRetVal;
    }

    CCookieJar* pcj = _CookieJar;
    if (pcj->_csCookieJar.Lock())
    {
        FILETIME ftNow;
        GetSystemTimeAsFileTime(&ftNow);

        CCookieLocation *pLocation = pcj->GetCookies(pchRDomain, pchPath, NULL, &ftNow);

        while (pLocation) 
        {
            CCookie *pCookie = NULL;
            
            if (NULL != (pCookie = pLocation->GetCookie("MSPAuth", FALSE)))
            {
                pCookie->SetValue(NULL);
            }

            if (NULL != (pCookie = pLocation->GetCookie("MSPProf", FALSE)))
            {
                pCookie->SetValue(NULL);
            }

            if (NULL != (pCookie = pLocation->GetCookie("MSPProfC", FALSE)))
            {
                pCookie->SetValue(NULL);
            }

            if (NULL != (pCookie = pLocation->GetCookie("MSPSec", FALSE)))
            {
                pCookie->SetValue(NULL);
            }

            pLocation = pcj->GetCookies(pchRDomain, pchPath, pLocation, &ftNow);
        } // while (pLocation)
        pcj->_csCookieJar.Unlock();
    } // if pcj->_csCookieJar.Lock()

    fRetVal = TRUE;

    if (pchRDomain)
    {
        FREE_MEMORY(pchRDomain);
    }

    if (pchPath)
    {
        FREE_MEMORY(pchPath);
    }

    return fRetVal;
}

//
//
//INTERNET_HANDLE_BASE::SetDwordOption() and HTTP_REQUEST_HANDLE_OBJECT::SetDwordOption()
//maintain DWORD options with the following semantics:
//  1)  Settings affect behavior of request and are per-request configureable.
//  2)  Defaults for new requests are stored in the session and those defaults are per-session configureable.
//
//

/* 
 * When called from API functions,
 * caller should SetLastError() in case of failure
 */
BOOL
INTERNET_HANDLE_OBJECT::SetDwordOption(
    IN DWORD dwDwordOption,
    IN DWORD dwDwordValue
    )
{
    BOOL bRetval = TRUE;
    
    if (!_pOptionalParams)
    {
        _pOptionalParams = New OPTIONAL_SESSION_PARAMS();

        if (!_pOptionalParams)
        {
            bRetval = FALSE;
            goto quit;
        }
    }

    switch (dwDwordOption) 
    {
    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
        _pOptionalParams->dwResolveTimeout = dwDwordValue;
        break;

    case WINHTTP_OPTION_CONNECT_TIMEOUT:
        _pOptionalParams->dwConnectTimeout = dwDwordValue;
        break;

    case WINHTTP_OPTION_CONNECT_RETRIES:
        _pOptionalParams->dwConnectRetries = dwDwordValue;
        break;

    case WINHTTP_OPTION_SEND_TIMEOUT:
        _pOptionalParams->dwSendTimeout = dwDwordValue;
        break;

    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
        _pOptionalParams->dwReceiveTimeout = dwDwordValue;

        // Ensure that the ReceiveResponse timeout is not less than the Receive timeout
        _pOptionalParams->dwReceiveResponseTimeout = max(dwDwordValue, _pOptionalParams->dwReceiveResponseTimeout);
        break;

    case WINHTTP_OPTION_RECEIVE_RESPONSE_TIMEOUT:
        // Ensure that the ReceiveResponse timeout is not less than the Receive timeout
        _pOptionalParams->dwReceiveResponseTimeout = max(dwDwordValue, _pOptionalParams->dwReceiveTimeout);
        break;

    case WINHTTP_OPTION_REDIRECT_POLICY:
        _pOptionalParams->dwRedirectPolicy = dwDwordValue;
        break;

    case WINHTTP_OPTION_AUTOLOGON_POLICY:
        _pOptionalParams->dwAutoLogonPolicy = dwDwordValue;
        break;

    case WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS:
        _pOptionalParams->dwMaxHttpAutomaticRedirects = dwDwordValue;
        break;
        
    case WINHTTP_OPTION_MAX_HTTP_STATUS_CONTINUE:
        _pOptionalParams->dwMaxHttpStatusContinues = dwDwordValue;
        break;

    case WINHTTP_OPTION_MAX_RESPONSE_HEADER_SIZE:
        _pOptionalParams->dwMaxResponseHeaderSize = dwDwordValue;
        break;
        
    case WINHTTP_OPTION_MAX_RESPONSE_DRAIN_SIZE:
        _pOptionalParams->dwMaxResponseDrainSize = dwDwordValue;
        break;

    default:
        INET_ASSERT(0);
        bRetval = FALSE;
    }

quit:
    return bRetval;
}


/* 
 * When called from API functions,
 * caller should SetLastError() in case of failure
 */
BOOL
INTERNET_HANDLE_OBJECT::SetTimeout(
    IN DWORD dwTimeoutOption,
    IN DWORD dwTimeoutValue
    )
{
    switch (dwTimeoutOption) 
    {
    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_RETRIES:
    case WINHTTP_OPTION_SEND_TIMEOUT:
    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
    case WINHTTP_OPTION_RECEIVE_RESPONSE_TIMEOUT:
        return SetDwordOption( dwTimeoutOption, dwTimeoutValue);
    default:
        INET_ASSERT(0);
        return FALSE;
    }
}

/* 
 * When called from API functions,
 * caller should SetLastError() in case of failure
 */
BOOL
INTERNET_HANDLE_OBJECT::SetTimeouts(
    IN DWORD        dwResolveTimeout,
    IN DWORD        dwConnectTimeout,
    IN DWORD        dwSendTimeout,
    IN DWORD        dwReceiveTimeout
    )
{
    BOOL bRetval = TRUE;
    
    if (!_pOptionalParams)
    {
        _pOptionalParams = New OPTIONAL_SESSION_PARAMS();

        if (!_pOptionalParams)
        {
            bRetval = FALSE;
            goto quit;
        }
    }

    _pOptionalParams->dwResolveTimeout = dwResolveTimeout;
    _pOptionalParams->dwConnectTimeout = dwConnectTimeout;
    _pOptionalParams->dwSendTimeout = dwSendTimeout;
    _pOptionalParams->dwReceiveTimeout = dwReceiveTimeout;
    
    // Ensure that the ReceiveResponse timeout is not less than the Receive timeout
    _pOptionalParams->dwReceiveResponseTimeout = max(dwReceiveTimeout, _pOptionalParams->dwReceiveResponseTimeout);
            
quit:
    return bRetval;
}

/* 
 * When called from API functions,
 * caller should SetLastError() in case of failure
 */
BOOL
INTERNET_HANDLE_OBJECT::GetDwordOption(
    IN DWORD dwDwordOption,
    OUT DWORD* pdwDwordValue
    )
{
    BOOL bRetval = TRUE;
    if (!_pOptionalParams)
    {
        _pOptionalParams = New OPTIONAL_SESSION_PARAMS();

        if (!_pOptionalParams)
        {
            bRetval = FALSE;
            goto quit;
        }
    }
    
    switch (dwDwordOption) 
    {
    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
        *pdwDwordValue = _pOptionalParams->dwResolveTimeout;
        break;
    case WINHTTP_OPTION_CONNECT_TIMEOUT:
        *pdwDwordValue = _pOptionalParams->dwConnectTimeout;
        break;
    case WINHTTP_OPTION_CONNECT_RETRIES:
        *pdwDwordValue = _pOptionalParams->dwConnectRetries;
        break;
    case WINHTTP_OPTION_SEND_TIMEOUT:
        *pdwDwordValue = _pOptionalParams->dwSendTimeout;
        break;
    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
        *pdwDwordValue = _pOptionalParams->dwReceiveTimeout;
        break;
    case WINHTTP_OPTION_RECEIVE_RESPONSE_TIMEOUT:
        *pdwDwordValue = _pOptionalParams->dwReceiveResponseTimeout;
        break;
    case WINHTTP_OPTION_REDIRECT_POLICY:
        *pdwDwordValue = _pOptionalParams->dwRedirectPolicy;
        break;
    case WINHTTP_OPTION_AUTOLOGON_POLICY:
        *pdwDwordValue = _pOptionalParams->dwAutoLogonPolicy;
        break;
    case WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS:
        *pdwDwordValue = _pOptionalParams->dwMaxHttpAutomaticRedirects;
        break;
    case WINHTTP_OPTION_MAX_HTTP_STATUS_CONTINUE:
        *pdwDwordValue = _pOptionalParams->dwMaxHttpStatusContinues;
        break;
    case WINHTTP_OPTION_MAX_RESPONSE_HEADER_SIZE:
        *pdwDwordValue = _pOptionalParams->dwMaxResponseHeaderSize;
        break;
    case WINHTTP_OPTION_MAX_RESPONSE_DRAIN_SIZE:
        *pdwDwordValue = _pOptionalParams->dwMaxResponseDrainSize;
        break;

    default:
        INET_ASSERT(0);
        bRetval = FALSE;
        break;
    }

quit:    
    return bRetval;
}

/* 
 * When called from API functions,
 * caller should SetLastError() in case of failure
 */
BOOL
INTERNET_HANDLE_OBJECT::GetTimeout(
    IN DWORD dwTimeoutOption,
    OUT DWORD* pdwTimeoutValue
    )
{
    switch (dwTimeoutOption) 
    {
    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_RETRIES:
    case WINHTTP_OPTION_SEND_TIMEOUT:
    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
    case WINHTTP_OPTION_RECEIVE_RESPONSE_TIMEOUT:
        return GetDwordOption( dwTimeoutOption, pdwTimeoutValue);
        
    default:
        INET_ASSERT(0);
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\handles\http.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    http.cxx

Abstract:

    Contains methods for HTTP_REQUEST_HANDLE_OBJECT class

    Contents:
        RMakeHttpReqObjectHandle
        HTTP_REQUEST_HANDLE_OBJECT::HTTP_REQUEST_HANDLE_OBJECT
        HTTP_REQUEST_HANDLE_OBJECT::~HTTP_REQUEST_HANDLE_OBJECT
        HTTP_REQUEST_HANDLE_OBJECT::SetProxyName
        HTTP_REQUEST_HANDLE_OBJECT::GetProxyName
        HTTP_REQUEST_HANDLE_OBJECT::ReuseObject
        HTTP_REQUEST_HANDLE_OBJECT::ResetObject
        HTTP_REQUEST_HANDLE_OBJECT::SetAuthenticated
        HTTP_REQUEST_HANDLE_OBJECT::IsAuthenticated

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>

//
// functions
//


DWORD
RMakeHttpReqObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN CLOSE_HANDLE_FUNC wCloseFunc,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    C-callable wrapper for creating an HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    ParentHandle    - mapped address of parent (connect) handle

    ChildHandle     - IN: protocol-specific handle value associated with object
                        *** NOT USED FOR HTTP ***
                      OUT: mapped address of HTTP_REQUEST_HANDLE_OBJECT

    wCloseFunc      - address of protocol-specific function to be called when
                      object is closed
                        *** NOT USED FOR HTTP ***

    dwFlags         - app-supplied flags

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * hHttp;

    hHttp = New HTTP_REQUEST_HANDLE_OBJECT(
                    (INTERNET_CONNECT_HANDLE_OBJECT *)ParentHandle,
                    *ChildHandle,
                    wCloseFunc,
                    dwFlags
                    );
    if (hHttp != NULL) {
        hHttp->Reference(); // claim a reference for HttpOpenRequestA() API
        error = hHttp->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            error = InternetIndicateStatusNewHandle((LPVOID)hHttp);

            //
            // ERROR_WINHTTP_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_WINHTTP_OPERATION_CANCELLED);

                BOOL fDeleted = hHttp->Dereference();
                INET_ASSERT(fDeleted);
                UNREFERENCED_PARAMETER(fDeleted);
                
                hHttp = NULL;
            }
        } else {
            delete hHttp;
            hHttp = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ChildHandle = (HINTERNET)hHttp;

    return error;
}

//
// HTTP_REQUEST_HANDLE_OBJECT class implementation
//


HTTP_REQUEST_HANDLE_OBJECT::HTTP_REQUEST_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT * Parent,
    HINTERNET Child,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD dwFlags
    ) : INTERNET_CONNECT_HANDLE_OBJECT(Parent)

/*++

Routine Description:

    Constructor for direct-to-net HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    Parent      - parent object

    Child       - IN: HTTPREQ structure pointer
                  OUT: pointer to created HTTP_REQUEST_HANDLE_OBJECT

    wCloseFunc  - address of function that closes/destroys HTTPREQ structure

    dwFlags     - open flags (e.g. INTERNET_FLAG_RELOAD)

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER(Child);
    UNREFERENCED_PARAMETER(wCloseFunc);
    DEBUG_ENTER((DBG_OBJECTS,
                Dword,
                "HTTP_REQUEST_HANDLE_OBJECT",
                "%#x, async?=%B",
                this, Parent ? Parent->IsAsyncHandle() : FALSE
                ));

    if (g_pAsyncCount)
    {
        if (Parent && Parent->IsAsyncHandle())
        {
            _Status = g_pAsyncCount->AddRef();
        }
    }
    else
    {
        RIP(FALSE);
    }

    _dwSecurityFlags = 0;

    _dwBytesRead = 0;
    _dwBytesWritten = 0;

    m_lpszRetUrl = NULL;
    
    _pProxyCreds = NULL;
    _pServerCreds = NULL;

    _KnowSupportedSchemes = FALSE;
    _PreferredScheme = 0;
    _SupportedSchemes = 0;
    _AuthTarget = 0;
    _pszRealm = NULL;

    _Socket = NULL;
    _QueryBuffer = NULL;
    _QueryBufferLength = 0;
    _QueryOffset = 0;
    _QueryBytesAvailable = 0;
    _bKeepAliveConnection = FALSE;
    _bNoLongerKeepAlive = FALSE;
    _OpenFlags = dwFlags | INTERNET_FLAG_KEEP_CONNECTION;
    _State = HttpRequestStateCreating;
    _RequestMethod = HTTP_METHOD_TYPE_UNKNOWN;
    _dwOptionalSaved = 0;
    _lpOptionalSaved = NULL;
    _fOptionalSaved = FALSE;
    _bIsWriteRequired = FALSE;
    _ResponseBuffer = NULL;
    _ResponseBufferLength = 0;
    ResetResponseVariables();
    _RequestHeaders.SetIsRequestHeaders(TRUE);
    _ResponseHeaders.SetIsRequestHeaders(FALSE);
    _fTalkingToSecureServerViaProxy = FALSE;
    _bViaProxy = 0;
    _fRequestUsingProxy = FALSE;
    _bWantKeepAlive = FALSE;

    _ServerInfo = NULL;
    _OriginServer = NULL;
    SetServerInfoWithScheme(INTERNET_SCHEME_HTTP, FALSE);

    //
    // set the read/write buffer sizes to the default values (8K)
    //

    _ReadBufferSize = (8 K);
    _WriteBufferSize = (8 K);

    _CacheUrlName = NULL;
    
    SetObjectType(TypeHttpRequestHandle);

    _pAuthCtx         = NULL;
    _pTunnelAuthCtx   = NULL;
    _pCreds             = NULL;
    _pTweenerProxyCreds = NULL;

    _NoResetBits.Dword = 0;  // only here are we ever allowed to assign to Dword.

    SetDisableNTLMPreauth(GlobalDisableNTLMPreAuth);
    
    _ProxyHostName = NULL;
    _ProxyHostNameLength = NULL;
    _ProxyPort = INTERNET_INVALID_PORT_NUMBER;

    _SocksProxyHostName = NULL;
    _SocksProxyHostNameLength = NULL;
    _SocksProxyPort = INTERNET_INVALID_PORT_NUMBER;

    _CachedCookieHeader = NULL;

    _HaveReadFileExData = FALSE;
    memset(&_BuffersOut, 0, sizeof(_BuffersOut));
    _BuffersOut.dwStructSize = sizeof(_BuffersOut);
    _BuffersOut.lpvBuffer = (LPVOID)&_ReadFileExData;

    m_fPPAbortSend = FALSE;

    _dwEnableFlags = 0;

    SetPriority(0);

#ifdef RLF_TEST_CODE

    static long l = 0;
    SetPriority(l++);

#endif

    _RTT = 0;

    if (_Status == ERROR_SUCCESS) {
        _Status = _RequestHeaders.GetError();
        if (_Status == ERROR_SUCCESS) {
            _Status = _ResponseHeaders.GetError();
        }
    }
    
    // Timeout and retry parameters

    INTERNET_HANDLE_OBJECT* pRoot = GetRootHandle(Parent);
    OPTIONAL_SESSION_PARAMS* pParams = pRoot->GetOptionalParams();

    if (pParams)
    {
        _dwResolveTimeout = pParams->dwResolveTimeout;
        _dwConnectTimeout = pParams->dwConnectTimeout;
        _dwConnectRetries = pParams->dwConnectRetries;
        _dwSendTimeout    = pParams->dwSendTimeout;
        _dwReceiveTimeout = pParams->dwReceiveTimeout;
        _dwReceiveResponseTimeout = pParams->dwReceiveResponseTimeout;
        _dwRedirectPolicy = pParams->dwRedirectPolicy;
        _dwAutoLogonPolicy = pParams->dwAutoLogonPolicy;
        _dwMaxHttpAutomaticRedirects = pParams->dwMaxHttpAutomaticRedirects;
        _dwMaxHttpStatusContinues = pParams->dwMaxHttpStatusContinues;
        _dwMaxResponseHeaderSize = pParams->dwMaxResponseHeaderSize;
        _dwMaxResponseDrainSize = pParams->dwMaxResponseDrainSize;
    }
    else
    {
        _dwResolveTimeout = GlobalResolveTimeout;
        _dwConnectTimeout = GlobalConnectTimeout;
        _dwConnectRetries = GlobalConnectRetries;
        _dwSendTimeout    = GlobalSendTimeout;
        _dwReceiveTimeout = GlobalReceiveTimeout;
        _dwReceiveResponseTimeout = GlobalReceiveResponseTimeout;
        _dwRedirectPolicy = WINHTTP_OPTION_REDIRECT_POLICY_DEFAULT;
        _dwAutoLogonPolicy = WINHTTP_AUTOLOGON_SECURITY_LEVEL_DEFAULT;
        _dwMaxHttpAutomaticRedirects = GlobalMaxHttpRedirects;
        _dwMaxHttpStatusContinues = GlobalMaxHttpStatusContinues;
        _dwMaxResponseHeaderSize = GlobalMaxHeaderSize;
        _dwMaxResponseDrainSize = GlobalMaxDrainSize;
    }

    if ((_OpenFlags & WINHTTP_FLAG_SECURE) &&
        (_Status = LoadSecurity()) == ERROR_SUCCESS)
    {
        if (!pRoot->GetSslSessionCache()->IsImpersonationLevelInitialized())
        {
            pRoot->GetSslSessionCache()->SetImpersonationLevel(TRUE);
        }

        m_pSecurityInfo = pRoot->GetSslSessionCache()->Find(GetHostName(), GetHostPort());
        if (NULL == m_pSecurityInfo)
        {
            m_pSecurityInfo = New SECURITY_CACHE_LIST_ENTRY(
                    pRoot->GetSslSessionCache()->IsImpersonationEnabled(),
                    GetHostName(), GetHostPort());
        }
    }
    else
    {
        m_pSecurityInfo = NULL;
    }

    _fAsyncFsmInProgress = FALSE;
    
    _uniqueID = TRACE_GET_REQUEST_ID();

    _xsProp[WINHTTP_OPTION_PASSWORD & WINHTTP_OPTION_MASK].SetSecuritySensitive();
    _xsProp[WINHTTP_OPTION_PROXY_PASSWORD & WINHTTP_OPTION_MASK].SetSecuritySensitive();

    _fProxyTunnelingSuppressWrite = FALSE;

    DEBUG_LEAVE(_Status);
}


HTTP_REQUEST_HANDLE_OBJECT::~HTTP_REQUEST_HANDLE_OBJECT(
    VOID
    )

/*++

Routine Description:

    Destructor for HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "~HTTP_REQUEST_HANDLE_OBJECT",
                "%#x",
                this
                ));

    delete [] m_lpszRetUrl;

    //
    // close the socket (or free it to the pool if keep-alive)
    //

    //
    // Authentication Note:
    // The CloseConnection parameter to force the connection closed
    // is set if we received a challenge but didn't respond, otherwise
    // IIS will get confused when a subsequent request recycles the
    // socket from the keep-alive pool.
    //

    CloseConnection(GetAuthState() == AUTHSTATE_CHALLENGE);

    //
    // If there's an authentication context, unload the provider.
    //

    if (_pAuthCtx) {
        delete _pAuthCtx;
    }
    if (_pTunnelAuthCtx) {
        delete _pTunnelAuthCtx;
    }

    //
    // free the various buffers
    //

    FreeResponseBuffer();
    FreeQueryBuffer();
    SetProxyName(NULL,NULL,0);

    FreeURL();
    
    if (m_pSecurityInfo != NULL) {
        m_pSecurityInfo->Release();
    }

    if (_pProxyCreds)
    {
        delete _pProxyCreds;
    }
    if (_pServerCreds)
    {
        delete _pServerCreds;
    }

    if (_pszRealm)
    {
        FREE_MEMORY(_pszRealm);
    }

    if (_CachedCookieHeader)
    {
        FREE_MEMORY(_CachedCookieHeader);
    }

    if (_ServerInfo != NULL)
        _ServerInfo->Dereference();
    if (_OriginServer != NULL)
        _OriginServer->Dereference();

    if (g_pAsyncCount)
    {
        if (_Async)
            g_pAsyncCount->Release();
    }
    else
    {
        RIP(FALSE);
    }

    DEBUG_LEAVE(0);
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::SetProxyName(
    IN LPSTR lpszProxyHostName,
    IN DWORD dwProxyHostNameLength,
    IN INTERNET_PORT ProxyPort
    )

/*++

Routine Description:

    Set proxy name in object. If already have name, free it. Don't set name if
    current pointer is input

Arguments:

    lpszProxyHostName       - pointer to proxy name to add

    dwProxyHostNameLength   - length of proxy name

    ProxyPort               - port

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::SetProxyName",
                 "{%q, %d, %d}%q, %d, %d",
                 _ProxyHostName,
                 _ProxyHostNameLength,
                 _ProxyPort,
                 lpszProxyHostName,
                 dwProxyHostNameLength,
                 ProxyPort
                 ));

    if (lpszProxyHostName != _ProxyHostName) {
        if (_ProxyHostName != NULL) {
            _ProxyHostName = (LPSTR)FREE_MEMORY(_ProxyHostName);

            INET_ASSERT(_ProxyHostName == NULL);

            SetOverrideProxyMode(FALSE);
        }
        if (lpszProxyHostName != NULL) {
            _ProxyHostName = NEW_STRING(lpszProxyHostName);
            if (_ProxyHostName == NULL) {
                dwProxyHostNameLength = 0;
            }
        }
        _ProxyHostNameLength = dwProxyHostNameLength;
        _ProxyPort = ProxyPort;
    } else if (lpszProxyHostName != NULL) {

        DEBUG_PRINT(HTTP,
                    WARNING,
                    ("!!! lpszProxyHostName == _ProxyHostName (%#x)\n",
                    lpszProxyHostName
                    ));

        INET_ASSERT(dwProxyHostNameLength == _ProxyHostNameLength);
        INET_ASSERT(ProxyPort == _ProxyPort);

    }

    DEBUG_LEAVE(0);
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::GetProxyName(
    OUT LPSTR* lplpszProxyHostName,
    OUT LPDWORD lpdwProxyHostNameLength,
    OUT LPINTERNET_PORT lpProxyPort
    )

/*++

Routine Description:

    Return address & length of proxy name plus proxy port

Arguments:

    lplpszProxyHostName     - returned address of name

    lpdwProxyHostNameLength - returned length of name

    lpProxyPort             - returned port

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::GetProxyName",
                 "{%q, %d, %d}%#x, %#x, %#x",
                 _ProxyHostName,
                 _ProxyHostNameLength,
                 _ProxyPort,
                 lplpszProxyHostName,
                 lpdwProxyHostNameLength,
                 lpProxyPort
                 ));

    *lplpszProxyHostName = _ProxyHostName;
    *lpdwProxyHostNameLength = _ProxyHostNameLength;
    *lpProxyPort = _ProxyPort;

    DEBUG_LEAVE(0);
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::ReuseObject(
    VOID
    )

/*++

Routine Description:

    Make the object re-usable: clear out any received data and headers and
    reset the state to open

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReuseObject",
                 NULL
                 ));

    _ResponseHeaders.FreeHeaders();
    FreeResponseBuffer();
    ResetResponseVariables();
    _ResponseHeaders.Initialize();
    SetState(HttpRequestStateOpen);
    ResetEndOfFile();
    _ResponseFilterList.ClearList();
    _QueryOffset = 0;
    _QueryBytesAvailable = 0;
    _dwQuerySetCookieHeader = 0;
    if (m_pSecurityInfo)
    {
        // Update the security info again based on the hostname
        // because we might have been redirected.
        if (!(_OpenFlags & WINHTTP_FLAG_SECURE) ||
            (stricmp(m_pSecurityInfo->GetHostName(), GetHostName())))
        {
            // before we release m_pSecurityInfo, we need to remember the SecurityFlags, otherwise
            // we will lose it. If the redir goes to an HTTPS site, we need to re-apply these flags.
            _dwSecurityFlags = m_pSecurityInfo->GetSecureFlags();

            m_pSecurityInfo->Release();
            m_pSecurityInfo = NULL;
        }
    }

    DEBUG_LEAVE(0);
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ResetObject(
    IN BOOL bForce,
    IN BOOL bFreeRequestHeaders
    )

/*++

Routine Description:

    This method is called when we we are clearing out a partially completed
    transaction, mainly for when we have determined that an if-modified-since
    request, or a response that has not invalidated the cache entry can be
    retrieved from cache (this is a speed issue)

    Abort the connection and clear out the response headers and response
    buffer; clear the response variables (all done by AbortConnection()).

    If bFreeRequestHeaders, clear out the request headers.

    Reinitialize the response headers. We do not reset the object state, but we
    do reset the end-of-file status

Arguments:

    bForce              - TRUE if connection is forced closed

    bFreeRequestHeaders - TRUE if request headers should be freed

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ResetObject",
                 "%B, %B",
                 bForce,
                 bFreeRequestHeaders
                 ));

    DWORD error;

    error = AbortConnection(bForce);
    if (error == ERROR_SUCCESS) {
        if (bFreeRequestHeaders) {
            _RequestHeaders.FreeHeaders();
        }
        _ResponseHeaders.Initialize();
        ResetEndOfFile();
    }

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::SetAuthenticated(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    SetAuthenticated    -

Return Value:

    None.

--*/

{
    if (!_Socket)
    {
        INET_ASSERT(FALSE);
    }
    else
    {
        _Socket->SetAuthenticated();
    }
}


BOOL
HTTP_REQUEST_HANDLE_OBJECT::IsAuthenticated(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    IsAuthenticated -

Return Value:

    BOOL

--*/

{
    return (_Socket ? _Socket->IsAuthenticated() : FALSE);
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::SetObjectName(
    LPSTR lpszObjectName,
    LPSTR lpszExtension,
    URLGEN_FUNC * procProtocolUrl
    )
{
    DWORD   dwLen, dwError;
    INTERNET_SCHEME schemeType;

    //
    // if there is already an object name, then free it. We are replacing it
    //

    //
    // BUGBUG - make _CacheUrlString an ICSTRING
    //

    FreeURL();

    //
    // get protocol specific url
    //

    if (procProtocolUrl) {

        //
        // if we are going via proxy AND this is an FTP object AND the user name
        // consists of <username>@<servername> then <servername> is the real
        // server name, and _HostName is the name of the proxy
        //

        //
        // BUGBUG - this is a bit of a hack(!)
        //
        // Note: FTP support has been removed (ssulzer, 3/2000).
        //

        LPSTR target = GetHostName();

        schemeType = GetSchemeType();

        // make the scheme type https if necessary

        schemeType = (((schemeType == INTERNET_SCHEME_DEFAULT)||
                      (schemeType == INTERNET_SCHEME_HTTP)) &&
                      (GetOpenFlags() & WINHTTP_FLAG_SECURE))?
                      INTERNET_SCHEME_HTTPS: schemeType;

        LPSTR lpszNewUrl = NULL;

        dwError = (*procProtocolUrl)(schemeType,
                                     target,
                                     NULL,
                                     lpszObjectName,
                                     lpszExtension,
                                     _HostPort,
                                     &lpszNewUrl,
                                     &dwLen
                                     );

        if (dwError == ERROR_SUCCESS) {

            if (!SetURLPtr (&lpszNewUrl)) {
                FREE_MEMORY (lpszNewUrl);
                dwError = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    else {
        dwError = ERROR_INVALID_PARAMETER;
    }

    if (dwError == ERROR_SUCCESS) {

        DEBUG_PRINT(HANDLE,
                    INFO,
                    ("Url: %s\n",
                    _CacheUrlName
                    ));

    }
    return dwError;
}


//=============================================================================
BOOL HTTP_REQUEST_HANDLE_OBJECT::GetUserAndPass
    (BOOL fProxy, LPSTR *pszUser, LPSTR *pszPass)
{
    DWORD dwUser, dwPass;
    
    if (fProxy)
    {
        dwUser = WINHTTP_OPTION_PROXY_USERNAME & WINHTTP_OPTION_MASK;
        dwPass = WINHTTP_OPTION_PROXY_PASSWORD & WINHTTP_OPTION_MASK;
    }
    else
    {
        dwUser = WINHTTP_OPTION_USERNAME & WINHTTP_OPTION_MASK;
        dwPass = WINHTTP_OPTION_PASSWORD & WINHTTP_OPTION_MASK;
    }
    
    *pszUser = _xsProp[dwUser].GetPtr();
    *pszPass = _xsProp[dwPass].GetUnencryptedString();
    if (*pszUser && *pszPass)
        return TRUE;
    else        
    {
        *pszUser = NULL;
        *pszPass = NULL;
        return FALSE;
    }
}

//=============================================================================
VOID HTTP_REQUEST_HANDLE_OBJECT::ClearUserAndPass(BOOL fProxy)
{
    DWORD dwUser, dwPass;
    
    if (fProxy)
    {
        dwUser = WINHTTP_OPTION_PROXY_USERNAME & WINHTTP_OPTION_MASK;
        dwPass = WINHTTP_OPTION_PROXY_PASSWORD & WINHTTP_OPTION_MASK;
    }
    else
    {
        dwUser = WINHTTP_OPTION_USERNAME & WINHTTP_OPTION_MASK;
        dwPass = WINHTTP_OPTION_PASSWORD & WINHTTP_OPTION_MASK;
    }

    _xsProp[dwUser].Free();
    _xsProp[dwPass].Free();
}
//=============================================================================
BOOL HTTP_REQUEST_HANDLE_OBJECT::SetURL (LPSTR lpszUrl)
{
    LPSTR lpszNew;

    // Make an undecorated copy of the URL.

    lpszNew = NewString(lpszUrl);
    if (!lpszNew)
        return FALSE;

    // Clear any previous cache key and record the new one.
    FreeURL();
    INET_ASSERT (lpszNew);
    _CacheUrlName = lpszNew;
    return TRUE;
}

//=============================================================================
BOOL HTTP_REQUEST_HANDLE_OBJECT::SetURLPtr(LPSTR* ppszUrl)
{
    // Swap in the new URL as the cache key.
    FreeURL();
    _CacheUrlName = *ppszUrl;
    *ppszUrl = NULL;
    return TRUE;
}

//=============================================================================
DWORD HTTP_REQUEST_HANDLE_OBJECT::SetServerInfoWithScheme(
    IN INTERNET_SCHEME tScheme,
    IN BOOL bDoResolution,
    IN OPTIONAL BOOL fNtlm
    )

/*++

Routine Description:

    Associates a SERVER_INFO with this INTERNET_CONNECT_HANDLE_OBJECT based on
    the host name for which this object was created and an optional scheme
    type

Arguments:

    tScheme         - scheme type we want SERVER_INFO for

    bDoResolution   - TRUE if we are to resolve the host name if creating a new
                      SERVER_INFO object

    fNtlm           - TRUE if we are tunnelling for NTLM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    UNREFERENCED_PARAMETER(tScheme);
    UNREFERENCED_PARAMETER(fNtlm);
    DEBUG_ENTER((DBG_OBJECTS,
                 Dword,
                 "INTERNET_CONNECT_HANDLE_OBJECT::SetServerInfo",
                 "%s (%d), %B, %B",
                 InternetMapScheme(tScheme),
                 tScheme,
                 bDoResolution,
                 fNtlm
                 ));


    if (_ServerInfo != NULL) {
        ::ReleaseServerInfo(_ServerInfo);
    }

    //
    // use the base service type to find the server info
    //

//dprintf("getting server info for %q (current = %q)\n", hostName, GetHostName());

    INTERNET_HANDLE_OBJECT * lpParent = GetRootHandle (this);

    DWORD error = lpParent->GetServerInfo(GetHostName(),
                                INTERNET_SERVICE_HTTP,
                                bDoResolution,
                                &_ServerInfo
                                );
    DEBUG_LEAVE(error);

    return error;
}


//=============================================================================
DWORD HTTP_REQUEST_HANDLE_OBJECT::SetServerInfo(
    IN LPSTR lpszServerName,
    IN DWORD dwServerNameLength
    )

/*++

Routine Description:

    Associates a SERVER_INFO with this INTERNET_CONNECT_HANDLE_OBJECT based on
    the host name in the parameters

Arguments:

    lpszServerName      - name of server

    dwServerNameLength  - length of lpszServerName

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Dword,
                 "INTERNET_CONNECT_HANDLE_OBJECT::SetServerInfo",
                 "%q, %d",
                 lpszServerName,
                 dwServerNameLength
                 ));

    if (_ServerInfo != NULL) {
        ::ReleaseServerInfo(_ServerInfo);
    }

    //
    // use the base service type to find the server info
    //

    char hostName[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    int copyLength = (int)min(sizeof(hostName) - 1, dwServerNameLength);

    memcpy(hostName, lpszServerName, copyLength);
    hostName[copyLength] = '\0';

    INTERNET_HANDLE_OBJECT * lpParent = GetRootHandle (this);
    DWORD error = lpParent->GetServerInfo(hostName,
                                INTERNET_SERVICE_HTTP,
                                FALSE,
                                &_ServerInfo
                                );

    DEBUG_LEAVE(error);

    return error;
}

//=============================================================================
VOID HTTP_REQUEST_HANDLE_OBJECT::SetOriginServer(
    IN CServerInfo * pServerInfo
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    pServerInfo -

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "INTERNET_CONNECT_HANDLE_OBJECT::SetOriginServer",
                 "%#x{%q}",
                 pServerInfo,
                 pServerInfo ? pServerInfo->GetHostName() : ""
                 ));

    if (_OriginServer == NULL) {
        _OriginServer = pServerInfo;
        if (pServerInfo != NULL) {
            pServerInfo->Reference();
        }
    }

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\handles\hutil.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    hutil.cxx

Abstract:

    contains outdated c-c++ interface functions

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>

DWORD
RIsHandleLocal(
    HINTERNET Handle,
    BOOL * IsLocalHandle, // dead
    BOOL * IsAsyncHandle,
    HINTERNET_HANDLE_TYPE ExpectedHandleType
    )
{
    INTERNET_HANDLE_OBJECT* HandleObj = (INTERNET_HANDLE_OBJECT*) Handle;
    DWORD Error = HandleObj->IsValid(ExpectedHandleType);
    UNREFERENCED_PARAMETER(IsLocalHandle);
    if (Error != ERROR_SUCCESS)
        return Error;
    *IsAsyncHandle = HandleObj->IsAsyncHandle();
    return ERROR_SUCCESS;
}


DWORD
RGetHandleType(
    HINTERNET Handle,
    LPHINTERNET_HANDLE_TYPE HandleType
    )
{
    HANDLE_OBJECT *HandleObj = (HANDLE_OBJECT *)Handle;
    DWORD error;

    //
    // validate handle before we use it.
    //

    error = HandleObj->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {

        //
        // find the handle type.
        //

        *HandleType = HandleObj->GetHandleType();
    }
    return error;
}

DWORD
RGetContext(
    HINTERNET hInternet,
    DWORD_PTR *lpdwContext
    )
{
    DWORD error;

    //
    // ensure the handle is valid
    //

    error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        *lpdwContext = ((INTERNET_HANDLE_OBJECT*)hInternet)->GetContext();
    }
    return error;
}

DWORD
RSetContext(
    HINTERNET hInternet,
    DWORD_PTR dwContext
    )
{
    DWORD error;

    //
    // ensure the handle is valid
    //

    error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        ((INTERNET_HANDLE_OBJECT*)hInternet)->SetContext(dwContext);
    }
    return error;
}

DWORD
RGetStatusCallback(
    IN HINTERNET Handle,
    OUT LPWINHTTP_STATUS_CALLBACK lpStatusCallback
    )
{
    //
    // NULL handle should have been caught before we got here
    // (its in WINHTTPQueryOption())
    //

    INET_ASSERT(Handle != NULL);

    *lpStatusCallback = ((INTERNET_HANDLE_OBJECT *)Handle)->GetStatusCallback();
    return ERROR_SUCCESS;
}

DWORD
RExchangeStatusCallback(
    IN HINTERNET Handle,
    IN OUT LPWINHTTP_STATUS_CALLBACK lpStatusCallback,
    IN BOOL fType,
    IN DWORD dwFlags)
{
    DWORD error;

    //
    // NULL handle value should have been caught already
    // (in WINHTTPSetStatusCallback())
    //

    INET_ASSERT(Handle != NULL);

    error = ((HANDLE_OBJECT *)Handle)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        error = ((INTERNET_HANDLE_OBJECT *)Handle)->
                                ExchangeStatusCallback(lpStatusCallback, fType, dwFlags);
    }
    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\http\cookie.cxx ===
//---------------------------------------------------------------------------
//
// COOKIE.CXX
//
//     Cookie Jar
//
//     This file implements cookies as defined by Navigator 4 behavior and the
//     specification at http://www.netscape.com/newsref/std/cookie_spec.html.
//     If Navigator 4 and the specification are not in agreement, we try to
//     match the Navigator 4 behavior.
//
//     The following describes some interesting aspects of cookie behavior.
//
// SYNTAX
//
//    Syntax for cookie is
//
//          [[name]=] value [; options]
//
//    The name is everything before "=" with leading and  trailing whitespace
//    removed.  The value is everything after "=" and before ";" with leading
//    and trailing whitespace removed.  The name and value can contain spaces,
//    quotes or any other character except ";" and "=".  The name and equal
//    sign are optional.
//
//    Example:  =foo  ->  name: <blank> value: foo
//              foo   ->  name: <blank> value: foo
//              foo=  ->  name: foo     value: <blank>
//              ;     ->  name: <blank> value: <blank>
//
// ORDER
//
//    Cookies with a more specific path are sent before cookies with
//    a less specific path mapping.  The domain does not contibute
//    to the ordering of cookies.
//
//    If the path length of two cookies are equal, then the cookies
//    are ordered by time of creation.  Navigator maintains this
//    ordering across domain and path boundaries.  IE maintains this
//    ordering for a specific domain and path. It is difficult to match
//    the Navigator behavior and there are no known bugs because of
//    this difference.
//
// MATCHING
//
//    Path matches are done at the character level.  Any
//    directory structure in the path is ignored.
//
//    Navigator matches domains at the character level and ignores
//    the structure of the domain name.
//
//    Previous versions of IE tossed the leading "." on a domain name.
//    With out this information, character by character compares are
//    can produce incorrect results.  For backwards compatibilty with
//    old cookie we continue to match on a component by component basis.
//
//    Some examples of the difference are:
//
//       Cookie domain   Document domain  Navigator match  IE match
//       .foo.com        foo.com          no               yes
//       bar.x.com       foobar.x.com     yes              no
//
// ACCEPTING COOKIES
//
//    A cookie is rejected if the path specified in the set cookie
//    header is not a prefix of document's path.
//
//    Navigator rejects a cookie if the domain specified in the
//    set cookie header does not contain at least two periods
//    or the domain is not a suffix of the document's domain.
//    The suffix match is done on a character by character basis.
//
//    Navigator ignores all the stuff in the specification about
//    three period matching and the seven special top level domains.
//
//    IE rejects a cookie if the domain specified by the cookie
//    header does not contain at least one embedded period or the
//    domain is not a suffix of the documents domain.
//
//    Cookies are accepted if the path specified in the set cookie
//    header is a prefix of the document's path and the domain
//    specified in the set cookie header.
//
//    The difference in behavior is a result of the matching rules
//    described in the previous section.
//
//---------------------------------------------------------------------------

#include <wininetp.h>
#include "httpp.h"
//#include "..\inc\cookie.h"
#include "cookiejar.h"

#define CCH_COOKIE_MAX  (5 * 1024)

static char s_achEmpty[] = "";

// Hard-coded list of special domains. If any of these are present between the 
// second-to-last and last dot we will require 2 embedded dots.
// The domain strings are reversed to make the compares easier

static const char *s_pachSpecialRestrictedDomains[] = 
    {"MOC", "UDE", "TEN", "GRO", "VOG", "LIM", "TNI" };  

static const char s_chSpecialAllowedDomains[] = "vt.";  // domains ending with ".tv" always only need one dot

struct CookieInfo {

   char *pchRDomain;
   char *pchPath;
   char *pchName;
   char *pchValue;
   unsigned long dwFlags;
   FILETIME ftExpiration;
};

//---------------------------------------------------------------------------
//
// String utilities
//
//---------------------------------------------------------------------------

static char *
StrnDup(const char *pch, int cch)
{
    char *pchAlloc = (char *)ALLOCATE_MEMORY(cch + 1);
    if (!pchAlloc)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    memcpy(pchAlloc, pch, cch);
    pchAlloc[cch] = 0;

    return pchAlloc;
}

static BOOL
IsPathMatch(const char *pchPrefix, const char *pchStr)
{
    while (*pchPrefix == *pchStr && *pchStr)
    {
        pchPrefix += 1;
        pchStr += 1;
    }

    //  if the match is incomplete, its not a valid path match.
    if (*pchPrefix != 0)
        return FALSE;

    //
    //  Furthermore, reject matches like '/path1/' and '/path1/../path2'
    //  We could try to canonicalize pchStr, but its sufficient to just
    //say any path with a '..' after the matched prefix doesn't match the
    //prefix.  Usually WinHTTP canonicalizes the path before this point
    //anyhow.
    //

    while (*pchStr != 0)
    {
        pchStr++;
        if (*(pchStr-1) == '.'
            && *(pchStr) == '.')
        {
            return FALSE;
        }
    }

    return TRUE;
}

static BOOL
IsDomainMatch(const char *pchPrefix, const char *pchStr)
{
    while (*pchPrefix == *pchStr && *pchStr)
    {
        pchPrefix += 1;
        pchStr += 1;
    }

    return *pchPrefix == 0 && (*pchStr == 0 || *pchStr == '.');
}

static BOOL
IsPathLegal(const char *pchHeader, const char *pchDocument)
{
    UNREFERENCED_PARAMETER(pchHeader);
    UNREFERENCED_PARAMETER(pchDocument);
    return TRUE;
}

static BOOL
IsSpecialDomain(const char *pch, int nCount)
{
    for (int i = 0 ; i < ARRAY_ELEMENTS(s_pachSpecialRestrictedDomains) ; i++ )
    {
        if (StrCmpNIC(pch, s_pachSpecialRestrictedDomains[i], nCount) == 0)
            return TRUE;
    }

    return FALSE;
}

static BOOL
IsDomainLegal(const char *pchHeader, const char *pchDocument)
{
    const char *pchCurrent = pchHeader;
    int nSegment = 0;
    int dwCharCount = 0;
    int rgcch[2] = { 0, 0 };  // How many characters between dots

    // Must have at least one period in name.
    // and contains nothing but '.' is illegal 

    int dwSegmentLength = 0;
    const char * pchSecondPart = NULL; // for a domain string such as 
    BOOL fIPAddress = TRUE;
    for (; *pchCurrent; pchCurrent++)
    {
        if (isalpha(*pchCurrent))
        {
            fIPAddress = FALSE;
        }

        if (*pchCurrent == '.')
        {
            if (nSegment < 2)
            {
                // Remember how many characters we have between the last two dots
                // For example if domain header is .microsoft.com
                // rgcch[0] should be 3 for "com"
                // rgcch[1] should be 9 for "microsoft"
                rgcch[nSegment] = dwSegmentLength;

                if (nSegment == 1)
                {
                    pchSecondPart = pchCurrent - dwSegmentLength;
                }
            }
            dwSegmentLength = 0;
            nSegment += 1;
        }
        else
        {
            dwSegmentLength++;
        }
        dwCharCount++;
    }

    // The code below depends on the leading dot being removed from the domain header.
    // The parse code does that, but an assert here just in case something changes in the 
    // parse code.
    INET_ASSERT(*(pchCurrent - 1) != '.');

    if (fIPAddress)
    {
        // If we're given an IP address, we must match the entire IP address, not just a part
        while (*pchHeader == *pchDocument && *pchDocument)
        {
            pchHeader++;
            pchDocument++;
        }
        return !(*pchHeader || *pchDocument); 
    }
    
    // Remember the count of the characters between the begining of the header and 
    // the first dot. So for domain=abc.com this will set rgch[1] = 3. 
    // Note that this assumes that if domain=.abc.com the leading dot has been stripped
    // out in the parse code. See assert above.
    if (nSegment < 2 )
    {
        rgcch[nSegment] = dwSegmentLength;
        if (nSegment==1)
        {
            pchSecondPart = pchCurrent - dwSegmentLength;
        }
    }

    // If the domain name is of the form abc.xx.yy where the number of characters between the last two dots is less than 
    // 2 we require a minimum of two embedded dots. This is so you are not allowed to set cookies readable by all of .co.nz for 
    // example. However this rule is not sufficient and we special case things like .edu.nz as well.

    // VENKATK: moved in following changes from wininet:
    // if last substring <= 2, and not .tv, and 
    // second-last substring <=2 OR one of restricted special domains,
    // then it's not a minimal domain.
    int cEmbeddedDotsNeeded = 1;

    if(rgcch[0] <= 2 
       && 0 != StrCmpNIC( pchHeader, s_chSpecialAllowedDomains, sizeof( s_chSpecialAllowedDomains) - 1)
       && (rgcch[1] <= 2
           || IsSpecialDomain(pchSecondPart, rgcch[1])))
    {
        cEmbeddedDotsNeeded = 2;
    }

    if (nSegment < cEmbeddedDotsNeeded || dwCharCount == nSegment)
        return FALSE;

    // Mismatch between header and document not allowed.
    // Must match full components of domain name.

    while (*pchHeader == *pchDocument && *pchDocument)
    {
        pchHeader += 1;
        pchDocument += 1;
    }

    return *pchHeader == 0 && (*pchDocument == 0 || *pchDocument == '.' );
}


void
LowerCaseString(char *pch)
{
    for (; *pch; pch++)
    {
        if (*pch >= 'A' && *pch <= 'Z')
            *pch += 'a' - 'A';
    }
}

void
ReverseString(char *pchFront)
{
    char *pchBack;
    char  ch;
    int   cch;

    cch = strlen(pchFront);

    pchBack = pchFront + cch - 1;

    cch = cch / 2;
    while (--cch >= 0)
    {
        ch = tolower(*pchFront);
        *pchFront = tolower(*pchBack);
        *pchBack = ch;

        pchFront += 1;
        pchBack -= 1;
    }
}

BOOL
PathAndRDomainFromURL(const char *pchURL, char **ppchRDomain, char **ppchPath, BOOL *pfSecure, BOOL bStrip)
{
    char *pchDomainBuf;
    char *pchRDomain = NULL;
    char *pchPathBuf;
    char *pchPath = NULL;
    char *pchExtra;
    DWORD cchDomain;
    DWORD cchPath;
    DWORD cchExtra;
    BOOL  fSuccess = FALSE;
    DWORD dwError;
    INTERNET_SCHEME ustScheme;

    dwError = CrackUrl((char *)pchURL,
             0,
             FALSE,
             &ustScheme,
             NULL,          //  Scheme Name
             NULL,          //  Scheme Lenth
             &pchDomainBuf,
             &cchDomain,
             TRUE,
             NULL,          //  Internet Port
             NULL,          //  UserName
             NULL,          //  UserName Length
             NULL,          //  Password
             NULL,          //  Password Lenth
             &pchPathBuf,
             &cchPath,
             &pchExtra,     //  Extra
             &cchExtra,     //  Extra Length
             NULL);

    if (dwError != ERROR_SUCCESS)
    {
        SetLastError(dwError);
        goto Cleanup;
    }

    if ( ustScheme != INTERNET_SCHEME_HTTP &&
         ustScheme != INTERNET_SCHEME_HTTPS &&
         ustScheme != INTERNET_SCHEME_UNKNOWN)
    {
        //
        // known scheme should be supported
        // e.g. 3rd party pluggable protocol should be able to
        // call cookie api to setup cookies...
        //
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    *pfSecure = ustScheme == INTERNET_SCHEME_HTTPS;

    if(bStrip)
    {
        while (cchPath > 0)
        {
            if (pchPathBuf[cchPath - 1] == '/' || pchPathBuf[cchPath - 1] == '\\')
            {
                break;
            }
        cchPath -= 1;
        }
    }

    pchRDomain = StrnDup(pchDomainBuf, cchDomain);
    if (!pchRDomain)
        goto Cleanup;

    LowerCaseString(pchRDomain);
    ReverseString(pchRDomain);

    pchPath = (char *)ALLOCATE_MEMORY(cchPath + 2);
    if (!pchPath)
        goto Cleanup;

    if (*pchPathBuf != '/')
    {
        *pchPath = '/';
        memcpy(pchPath + 1, pchPathBuf, cchPath);
        pchPath[cchPath + 1] = TEXT('\0');
    }
    else
    {
        memcpy(pchPath, pchPathBuf, cchPath);
        pchPath[cchPath] = TEXT('\0');
    }

    fSuccess = TRUE;

Cleanup:
    if (!fSuccess)
    {
        if (pchRDomain)
            FREE_MEMORY(pchRDomain);
        if (pchPath)
            FREE_MEMORY(pchPath);
    }
    else
    {
        *ppchRDomain = pchRDomain;
        *ppchPath = pchPath;
    }

    return fSuccess;
}

//---------------------------------------------------------------------------
//
// CCookieBase implementation
//
//---------------------------------------------------------------------------

void *
CCookieBase::operator new(size_t cb, size_t cbExtra)
{
    void *pv = ALLOCATE_MEMORY(cb + cbExtra);
    if (!pv)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    memset(pv, 0, cb);
    return pv;
}

inline void
CCookieBase::operator delete(void *pv)
{
    FREE_MEMORY(pv);
}

//---------------------------------------------------------------------------
//
// CCookie implementation
//
//---------------------------------------------------------------------------

CCookie *
CCookie::Construct(const char *pchName)
{
    CCookie *pCookie = new(strlen(pchName) + 1) CCookie();
    if (!pCookie)
        return NULL;

    pCookie->_pchName = (char *)(pCookie + 1);
    pCookie->_pchValue = s_achEmpty;
    strcpy(pCookie->_pchName, pchName);

    pCookie->_dwFlags = COOKIE_SESSION;

    return pCookie;
}

CCookie::~CCookie()
{
    if (_pchValue != s_achEmpty)
        FREE_MEMORY(_pchValue);
}

BOOL
CCookie::SetValue(const char *pchValue)
{
    int   cchValue;

    if (_pchValue != s_achEmpty)
        FREE_MEMORY(_pchValue);

    if (!pchValue || !*pchValue)
    {
        _pchValue = s_achEmpty;
    }
    else
    {
        cchValue = strlen(pchValue) + 1;
        _pchValue = (char *)ALLOCATE_MEMORY(cchValue);
        if (!_pchValue)
        {
            _pchValue = s_achEmpty;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        memcpy(_pchValue, pchValue, cchValue);
    }
    return TRUE;
}

BOOL
CCookie::CanSend(BOOL fSecure)
{
    return (fSecure || !(_dwFlags & COOKIE_SECURE));
}

BOOL CCookie::PurgeAll(void *)
{
    return TRUE;
}


BOOL
WriteString(HANDLE hFile, const char *pch)
{
    DWORD cb;
    return pch && *pch ? WriteFile(hFile, pch, strlen(pch), &cb, NULL) : TRUE;
}

BOOL
WriteStringLF(HANDLE hFile, const char *pch)
{
    DWORD cb;

    if (!WriteString(hFile, pch)) return FALSE;
    return WriteFile(hFile, "\n", 1, &cb, NULL);
}


//---------------------------------------------------------------------------
//
// CCookieLocation implementation
//
//---------------------------------------------------------------------------

CCookieLocation *
CCookieLocation::Construct(const char *pchRDomain, const char *pchPath)
{
    int cchPath = strlen(pchPath);

    CCookieLocation *pLocation = new(strlen(pchRDomain) + cchPath + 2) CCookieLocation();
    if (!pLocation)
        return NULL;

    pLocation->_cchPath = cchPath;
    pLocation->_pchPath = (char *)(pLocation + 1);
    pLocation->_pchRDomain = pLocation->_pchPath + cchPath + 1;

    strcpy(pLocation->_pchRDomain, pchRDomain);
    strcpy(pLocation->_pchPath, pchPath);

    return pLocation;
}

CCookieLocation::~CCookieLocation()
{
    Purge(CCookie::PurgeAll, NULL);
}

CCookie *
CCookieLocation::GetCookie(const char *pchName, BOOL fCreate)
{
    CCookie *pCookie;

    CCookie **ppCookie = &_pCookieKids;

    for (pCookie = _pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
    {
        if (strcmp(pchName, pCookie->_pchName) == 0)
            return pCookie;
        ppCookie = &pCookie->_pCookieNext;
    }

    if (!fCreate)
        return NULL;

    pCookie = CCookie::Construct(pchName);
    if (!pCookie)
        return NULL;

    //
    // Insert cookie at end of list to match Navigator's behavior.
    //

    pCookie->_pCookieNext = NULL;
    *ppCookie = pCookie;

    return pCookie;
}

void
CCookieLocation::Purge(BOOL (CCookie::*pfnPurge)(void *), void *pv)
{
    CCookie **ppCookie = &_pCookieKids;
    CCookie *pCookie;

    while ((pCookie = *ppCookie) != NULL)
    {
        if ((pCookie->*pfnPurge)(pv))
        {
            *ppCookie = pCookie->_pCookieNext;
            delete pCookie;
        }
        else
        {
            ppCookie = &pCookie->_pCookieNext;
        }
    }
}

BOOL
CCookieLocation::IsMatch(const char *pchRDomain, const char *pchPath)
{
    return IsDomainMatch(_pchRDomain, pchRDomain) &&
        IsPathMatch(_pchPath, pchPath);
}


//---------------------------------------------------------------------------
//
// CCookieJar implementation
//
//---------------------------------------------------------------------------


CCookieJar *
CCookieJar::Construct()
{
    return new(0) CCookieJar();
}

CCookieJar::CCookieJar()
{
    _csCookieJar.Init();
}

CCookieJar::~CCookieJar()
{
    for (int i = ARRAY_ELEMENTS(_apLocation); --i >= 0; )
    {
        CCookieLocation *pLocation = _apLocation[i];
        while (pLocation)
        {
            CCookieLocation *pLocationT = pLocation->_pLocationNext;
            delete pLocation;
            pLocation = pLocationT;
        }
    }
}

CCookieLocation **
CCookieJar::GetBucket(const char *pchRDomain)
{
    int ch;
    int cPeriod = 0;
    unsigned int hash = 0;

    for (; (ch = *pchRDomain) != 0; pchRDomain++)
    {
        if (ch == '.')
        {
            cPeriod += 1;
            if (cPeriod >= 2)
                break;
        }
        hash = (hash * 29) + ch;
    }

    hash = hash % ARRAY_ELEMENTS(_apLocation);

    return &_apLocation[hash];
}

CCookieLocation *
CCookieJar::GetLocation(const char *pchRDomain, const char *pchPath, BOOL fCreate)
{
    int cchPath = strlen(pchPath);
    CCookieLocation *pLocation = NULL;
    CCookieLocation **ppLocation = GetBucket(pchRDomain);

    // To support sending more specific cookies before less specific,
    // we keep list sorted by path length.

    while ((pLocation = *ppLocation) != NULL)
    {
        if (pLocation->_cchPath < cchPath)
            break;

        if (strcmp(pLocation->_pchPath, pchPath) == 0 &&
            strcmp(pLocation->_pchRDomain, pchRDomain) == 0)
            return pLocation;

        ppLocation = &pLocation->_pLocationNext;
    }

    if (!fCreate)
        goto Cleanup;

    pLocation = CCookieLocation::Construct(pchRDomain, pchPath);
    if (!pLocation)
        goto Cleanup;

    pLocation->_pLocationNext = *ppLocation;
    *ppLocation = pLocation;

Cleanup:
    return pLocation;
}

void 
CCookieJar::expireCookies(CCookieLocation *pLocation, FILETIME *pftNow) {

   FILETIME ftCurrent;

   if (pftNow==NULL)
      GetSystemTimeAsFileTime(&ftCurrent);
   else
      ftCurrent = *pftNow;

   CCookie **previous = & pLocation->_pCookieKids;

   CCookie *pCookie = pLocation->_pCookieKids;

   while (pCookie) 
   {
      /* Session cookies do not expire so we only check persistent cookies */
      if ((pCookie->_dwFlags & COOKIE_SESSION) == 0)
      {

         /* "CompareFileTime" macro returns {+1, 0, -1} similar to "strcmp" */
         int cmpresult = CompareFileTime(ftCurrent, pCookie->_ftExpiry);

         if (cmpresult==1) /* Cookie has expired: remove from linked list & delete */
         { 
            *previous = pCookie->_pCookieNext;
            delete pCookie;
            pCookie = *previous;
            continue;
         }
      }

      /* Otherwise cookie is still valid: advance to next node */
      previous = & (pCookie->_pCookieNext);
      pCookie = pCookie->_pCookieNext;
   }   
}



CCookieLocation*
CCookieJar::GetCookies(const char *pchRDomain, const char *pchPath, CCookieLocation *pLast, FILETIME *ftCurrentTime)  {

   for (CCookieLocation *pLocation = pLast ? pLast->_pLocationNext : *GetBucket(pchRDomain);
        pLocation;
        pLocation = pLocation->_pLocationNext)
   {
      if (pLocation->IsMatch(pchRDomain, pchPath))
      {
         /* Found matching cookies...
            Before returning linked list to the user, check expiration 
            times, deleting cookies which are no longer valid */
         expireCookies(pLocation, ftCurrentTime);
         return pLocation;
      }
   }

   /* Reaching this point means no matching cookies were found */
   return NULL;
}

void
CCookieJar::Purge()
{
    // NOT IMPLEMENTED
}


//
//  PARSE tracks both the last parsed token and the current buffer location for ParseToken()
//  pchToken points to the parsed token.
//  pchBuffer points to the next location in the buffer to be parsed.
//  fEqualFound indicates if the token was terminated by an equal sign.
//
struct PARSE
{
    char *pchBuffer;
    char *pchToken;
    BOOL fEqualFound;
};

static char *
SkipWS(char *pch)
{
    while (*pch == ' ' || *pch == '\t')
        pch += 1;

    return pch;
}

static BOOL
ParseToken(PARSE *pParse, BOOL fBreakOnSpecialTokens, BOOL fBreakOnEqual, BOOL fAllowQuotedToken = FALSE)
{
    char ch;
    char *pch;
    char *pchEndToken;

    pParse->fEqualFound = FALSE;

    pch = SkipWS(pParse->pchBuffer);
    if (*pch == 0)
    {
        pParse->pchToken = pch;
        return FALSE;
    }

    if (*pch == '\"' && fAllowQuotedToken)
    {
        pch++;
        //  Return the token as begining after the quote
        pParse->pchToken = pch;

        //  Scan until the next quote.
        while(*pch != '\0' && *pch != '\"')
        {
            pch++;
        }

        //  Expecting final quote.  If not found, error.
        //If found, return the quoted token.
        if (*pch == '\0')
        {
            pParse->pchBuffer = pch;
            return FALSE;
        }
        else
        {
            INET_ASSERT(*pch == '\"');
            *pch = '\0';
            pch++;
            pParse->pchBuffer = pch;
            return TRUE;
        }
    }

    pParse->pchToken = pch;
    pchEndToken = pch;

    while ((ch = *pch) != 0)
    {
        pch += 1;
        if (ch == ';')
        {
            break;
        }
        else if (fBreakOnEqual && ch == '=')
        {
            pParse->fEqualFound = TRUE;
            break;
        }
        else if (ch == ' ' || ch == '\t')
        {
            if (fBreakOnSpecialTokens)
            {
                if ((strnicmp(pch, "expires", sizeof("expires") - 1) == 0) ||
                    (strnicmp(pch, "Max-Age", sizeof("Max-Age") - 1) == 0) ||
                    (strnicmp(pch, "path", sizeof("path") - 1) == 0) ||
                    (strnicmp(pch, "domain", sizeof("domain") - 1) == 0) ||
                    (strnicmp(pch, "secure", sizeof("secure") - 1) == 0))
                {
                    break;
                }
            }
        }
        else
        {
            pchEndToken = pch;
        }
    }

    *pchEndToken = 0;
    pParse->pchBuffer = pch;
    return TRUE;
}


static void
ParseHeader(
    char *pchHeader,
    CookieInfo *pCookie
   )
{
   char **ppchName = & (pCookie->pchName);
   char **ppchValue = & (pCookie->pchValue);
   char **ppchPath = & (pCookie->pchPath);
   char **ppchRDomain = & (pCookie->pchRDomain);

   PARSE parse;

    parse.pchBuffer = pchHeader;

    *ppchName = NULL;
    *ppchValue = NULL;
    *ppchPath = NULL;
    *ppchRDomain = NULL;
    pCookie->dwFlags = COOKIE_SESSION;

    // If only one of name or value is specified, Navigator
    // uses name=<blank> and value as what ever was specified.
    // Example:  =foo  ->  name: <blank> value: foo
    //           foo   ->  name: <blank> value: foo
    //           foo=  ->  name: foo     value: <blank>

    if (ParseToken(&parse, FALSE, TRUE))
    {
        *ppchName = parse.pchToken;
        if (parse.fEqualFound)
        {
            if (ParseToken(&parse, FALSE, FALSE))
            {
                *ppchValue = parse.pchToken;
            }
            else
            {
                *ppchValue = s_achEmpty;
            }
        }
        else
        {
            *ppchValue = *ppchName;
            *ppchName = s_achEmpty;
        }
    }

    while (ParseToken(&parse, FALSE, TRUE))
    {
        if (stricmp(parse.pchToken, "expires") == 0)
        {
            if (parse.fEqualFound && ParseToken(&parse, TRUE, FALSE, TRUE))
            {
                // WinHttpX treats persistent cookies as session cookies with expiration
                if (FParseHttpDate(& pCookie->ftExpiration, parse.pchToken)) 
                {
                   //  Don't make the cookie persistent if the parsing fails
                   //  If the parsing succeeds and we have an expiration time,
                   //make sure its not session so the expiry is used.
                   pCookie->dwFlags &= ~COOKIE_SESSION;
                }
            }
        }
        else if (stricmp(parse.pchToken, "Max-Age") == 0)
        {
            //  excerpt below from http://www.ietf.org/rfc/rfc2109.txt
            //
            //Max-Age=delta-seconds
            //      Optional.  The Max-Age attribute defines the lifetime of the
            //      cookie, in seconds.  The delta-seconds value is a decimal non-
            //      negative integer.  After delta-seconds seconds elapse, the client
            //      should discard the cookie.  A value of zero means the cookie
            //      should be discarded immediately.
            //
            if (parse.fEqualFound && ParseToken(&parse, TRUE, FALSE, TRUE))
            {
                LPSTR szValue = parse.pchToken;
                DWORD dwMaxAge;
                FILETIME ftExpires;

                //  Try to extract the Max-Age value.  If its malformed, set
                //MaxAge to 0 to flush the cookie.
                if (!ExtractDword( &szValue, strlen(parse.pchToken), &dwMaxAge))
                {
                    dwMaxAge = 0;
                }

                //  Add the max age to the current file time to compute the
                //expiration time.
                GetSystemTimeAsFileTime(&ftExpires);
                AddLongLongToFT(&ftExpires, ((LONGLONG)dwMaxAge) * (LONGLONG)10000000);
                
                pCookie->ftExpiration = ftExpires;   
                //  Make sure the cookie is no longer considered a session
                //cookie so that the expiration time is actually applied.
                pCookie->dwFlags &= ~COOKIE_SESSION;
            }
        }
        else if (stricmp(parse.pchToken, "domain") == 0)
        {
            if (parse.fEqualFound )
            {
                if( ParseToken(&parse, TRUE, FALSE, TRUE))
                {
                    // Previous versions of IE tossed the leading
                    // "." on domain names.  We continue this behavior
                    // to maintain compatiblity with old cookie files.
                    // See comments at the top of this file for more
                    // information.

                    if (*parse.pchToken == '.') parse.pchToken += 1;
                    ReverseString(parse.pchToken);
                    *ppchRDomain = parse.pchToken;
                }
                else
                {
                    *ppchRDomain = parse.pchToken;
                }
            }
        }
        else if (stricmp(parse.pchToken, "path") == 0)
        {
            if (parse.fEqualFound && ParseToken(&parse, TRUE, FALSE, TRUE))
            {
                *ppchPath = parse.pchToken;
            }
            else
            {
                *ppchPath = s_achEmpty;
            }
        }
        else if (stricmp(parse.pchToken, "secure") == 0)
        {
            pCookie->dwFlags |= COOKIE_SECURE;

            if (parse.fEqualFound)
            {
                ParseToken(&parse, TRUE, FALSE, TRUE);
            }
        }
        else
        {
            if (parse.fEqualFound)
            {
                ParseToken(&parse, TRUE, FALSE, TRUE);
            }
        }
    }

    if (!*ppchName)
    {
        *ppchName = *ppchValue = s_achEmpty;
    }
}

DWORD
CCookieJar::SetCookie(HTTP_REQUEST_HANDLE_OBJECT *pRequest, const char *pchURL, char *pchHeader, DWORD dwFlags = 0)
{
    char *pchDocumentRDomain = NULL;
    char *pchDocumentPath = NULL;
    BOOL  fDocumentSecure;
    DWORD dwRet = SET_COOKIE_FAIL;
    CCookieLocation *pLocation;
    BOOL fHaveCookieJarLock = FALSE;

    CookieInfo cookieStats;

    UNREFERENCED_PARAMETER(pRequest);

    ParseHeader(pchHeader, &cookieStats);

    char *pchName = cookieStats.pchName;
    char *pchValue = cookieStats.pchValue;
    char *pchHeaderPath = cookieStats.pchPath;
    char *pchHeaderRDomain = cookieStats.pchRDomain;
    DWORD dwFlagsFromParse = cookieStats.dwFlags;
       
    // merge flags given with those found by the parser.
    dwFlags |= dwFlagsFromParse;

    if (!PathAndRDomainFromURL(pchURL, &pchDocumentRDomain, &pchDocumentPath, &fDocumentSecure, FALSE))
        goto Cleanup;

    //
    // Verify domain and path
    //

    if ((pchHeaderRDomain && !IsDomainLegal(pchHeaderRDomain, pchDocumentRDomain)) ||
        (pchHeaderPath && !IsPathLegal(pchHeaderPath, pchDocumentPath)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    if (!pchHeaderRDomain)
        pchHeaderRDomain = pchDocumentRDomain;

    if (!pchHeaderPath)
        pchHeaderPath = pchDocumentPath;

    // We need to discard any extra info (i.e. query strings and fragments)
    // from the url.
    if (pchHeaderPath)
    {
        PTSTR psz = pchHeaderPath;
        while (*psz)
        {
            if (*psz==TEXT('?') || *psz==TEXT('#'))
            {
                *psz = TEXT('\0');
                break;
            }
            psz++;
        }
    }

    //   WinHttpX treats persistent cookies as session cookies, subject
    //   to the expiration rules
    //   Also it does not implement zone policies set by URLMON
    //
    //   Finally, we can add the cookie!
    //

    {
        if (_csCookieJar.Lock())
        {
            fHaveCookieJarLock = TRUE;
            
            pLocation = GetLocation(pchHeaderRDomain, pchHeaderPath, TRUE);

            if (pLocation)
            {
                CCookie *pCookie;

                pCookie = pLocation->GetCookie(pchName, TRUE);
                if (!pCookie)
                    goto Cleanup;

                //
                // If the cookie's value or flags have changed, update it.
                //
                if (pCookie->SetValue(pchValue))
                {
                    pCookie->_dwFlags = dwFlags;
                    pCookie->_ftExpiry = cookieStats.ftExpiration;
                }
                else
                {
                    //  Oops, alloc failed.  This cookie is toast, lets expire it.
                    pCookie->_dwFlags = dwFlags;
                    pCookie->_dwFlags &= ~COOKIE_SESSION;  // session cookies don't expire..
                    pCookie->_ftExpiry.dwLowDateTime = 0;
                    pCookie->_ftExpiry.dwHighDateTime = 0;
                }
             }
            _csCookieJar.Unlock();
            fHaveCookieJarLock = FALSE;
        }
    }

    dwRet = SET_COOKIE_SUCCESS;

Cleanup:

    if (fHaveCookieJarLock)
        _csCookieJar.Unlock();
    if (pchDocumentRDomain)
        FREE_MEMORY(pchDocumentRDomain);
    if (pchDocumentPath)
        FREE_MEMORY(pchDocumentPath);

    return dwRet;
}


//---------------------------------------------------------------------------
//
// External APIs
//
//---------------------------------------------------------------------------


CCookieJar *
CreateCookieJar()
{
    return CCookieJar::Construct();
}

void
CloseCookieJar(CCookieJar * CookieJar)
{
    if (CookieJar)
    {
        delete CookieJar;
    }
}

#ifndef WININET_SERVER_CORE
void
PurgeCookieJar()
{
}
#endif


//
//  rambling comments, delete before checkin...
//
// returns struc, and pending, error
//  on subsequent attempts passes back, with index, or index incremented
// perhaps can store index in fsm, and the rest in UI 
//  need to handle multi dlgs, perhaps via checking added Cookie.
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ExtractSetCookieHeaders(LPDWORD lpdwHeaderIndex)
{
    char *pchHeader = NULL;
    DWORD cbHeader;
    DWORD iQuery = 0;
    int   cCookies = 0;
    DWORD error = ERROR_WINHTTP_HEADER_NOT_FOUND;
    const DWORD cbHeaderInit = CCH_COOKIE_MAX * sizeof(char) - 1;

    pchHeader = New char[CCH_COOKIE_MAX];

    if (pchHeader == NULL || !_ResponseHeaders.LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    INET_ASSERT(lpdwHeaderIndex);

    cbHeader = cbHeaderInit;

    iQuery = *lpdwHeaderIndex;

    while (QueryResponseHeader(HTTP_QUERY_SET_COOKIE,
            pchHeader,
            &cbHeader,
            0,
            &iQuery) == ERROR_SUCCESS)
    {
        pchHeader[cbHeader] = 0;

        INTERNET_HANDLE_OBJECT *pRoot = GetRootHandle (this);
        CCookieJar* pcj = pRoot->_CookieJar;
        DWORD dwRet = pcj->SetCookie(this, GetURL(), pchHeader);

        if (dwRet == SET_COOKIE_SUCCESS)
        {
            cCookies += 1;
            *lpdwHeaderIndex = iQuery;
            error = ERROR_SUCCESS;
        } 
        else if (dwRet == SET_COOKIE_PENDING) 
        {
            error = ERROR_IO_PENDING;

            INET_ASSERT(iQuery != 0);
            *lpdwHeaderIndex = iQuery - 1; // back up and retry this cookie

            break;
        }

        cbHeader = cbHeaderInit;
    }

    _ResponseHeaders.UnlockHeaders();

Cleanup:
    if (pchHeader)
        delete [] pchHeader;

    return error;
}

VOID
HTTP_REQUEST_HANDLE_OBJECT::CreateCookieHeaderIfNeeded(VOID)
{
    char *  pchRDomain = NULL;
    char *  pchPath = NULL;
    BOOL    fSecure, fHeadersLocked=FALSE;
    DWORD   cch = 0;
    int     cchName;
    int     cchValue;
    char *  pchHeader = NULL;
    char *  pchHeaderStart = NULL;
    DWORD   dwIndex = 0;

    if (!LockHeaders())
        goto Cleanup;
    
    fHeadersLocked = TRUE;
    
    //
    //  Before the first call to SendRequest, the WinHttp client may set custom
    //cookies by setting the HTTP_QUERY_COOKIE header.  This header, or an empty
    //string, will be saved off to _CachedCookieHeader so it can be reused on subsequent
    //calls to SendRequest on the same request handle.
    //
    //  If on subsequent calls the WinHttp client removes the cookies header,
    //we will honor that change by clearing the _CachedCookieHeader to an empty string.
    //All other changes to the cookie header are ignored.
    //
    //  (this forces the requirement that the WinHttp client sets custom cookies
    //before the first SendRequest, but does allow the client to clear the custom
    //cookies later if need be, perhaps in response to a redirect)
    //
    switch (QueryRequestHeader(HTTP_QUERY_COOKIE, NULL, &cch, 0, &dwIndex))
    {
    default:
    case ERROR_WINHTTP_HEADER_NOT_FOUND:
        //
        // If there is currently no Cookie request header (perhaps it got
        // discarded by the application during a callback notification),
        // then ensure that the app's cached Cookie request header is also
        // marked as empty.
        //
        if (_CachedCookieHeader && _CachedCookieHeader[0] != '\0')
        {
            FREE_MEMORY(_CachedCookieHeader);
            _CachedCookieHeader = NULL;
        }

        if (_CachedCookieHeader == NULL)
        {
            _CachedCookieHeader = (LPSTR) ALLOCATE_FIXED_MEMORY(1);
            if (_CachedCookieHeader == NULL)
                goto Cleanup;
            _CachedCookieHeader[0] = '\0';
        }
        break;

    case ERROR_INSUFFICIENT_BUFFER:
        // If there is a cached Cookie request header, then set it as the
        // initial value of the Cookie header. Additional cookies from
        // the Cookie Jar will be appended to this.
        if (_CachedCookieHeader)
        {
            if (_CachedCookieHeader[0] == '\0')
            {
                ReplaceRequestHeader(HTTP_QUERY_COOKIE, NULL, 0, 0, 0);
            }
            else
            {
                ReplaceRequestHeader(HTTP_QUERY_COOKIE, _CachedCookieHeader,
                                     lstrlen(_CachedCookieHeader), 0, 0);
            }
        }
        //
        // If the application sets a Cookie request header before calling
        // SendRequest, then cache its value.  After the first SendRequest
        // call, we know _CachedCookieHeader will be non-NULL indicating that
        // the current cookie request header may have been generated by
        // WinHttp and therefore should not be cached.
        //
        else
        {
            _CachedCookieHeader = (LPSTR) ALLOCATE_FIXED_MEMORY(cch + 1);
            if (_CachedCookieHeader == NULL)
                goto Cleanup;
            if (!QueryRequestHeader(HTTP_QUERY_COOKIE, _CachedCookieHeader, &cch, 0, &dwIndex))
            {
                FREE_MEMORY(_CachedCookieHeader);
                _CachedCookieHeader = NULL;
                goto Cleanup;
            }
        }
        break;
    }


    if (!PathAndRDomainFromURL(GetURL(), &pchRDomain, &pchPath, &fSecure, FALSE))
        goto Cleanup;

    fSecure = GetOpenFlags() & WINHTTP_FLAG_SECURE;

    {
        INTERNET_HANDLE_OBJECT *pRoot = GetRootHandle (this);
        CCookieJar* pcj = pRoot->_CookieJar;

        if (pcj->_csCookieJar.Lock())
        {
            FILETIME ftNow;
            GetSystemTimeAsFileTime(&ftNow);

            CCookieLocation *pLocation = pcj->GetCookies(pchRDomain, pchPath, NULL, &ftNow);

            while (pLocation) 
            {
                for (CCookie *pCookie = pLocation->_pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
                {
                    if (pCookie->CanSend(fSecure))
                    {
                        if (pchHeaderStart == NULL)
                        {
                            pchHeaderStart = (char *) ALLOCATE_FIXED_MEMORY(CCH_COOKIE_MAX * sizeof(char));
                            if (pchHeaderStart == NULL)
                                break;
                        }
    
                        pchHeader = pchHeaderStart;

                        cch = 0;
                        cch += cchName = strlen(pCookie->_pchName);
                        cch += cchValue = strlen(pCookie->_pchValue);
                        if (cchName) cch += 1; // for equal sign

                        if (cch < CCH_COOKIE_MAX)
                        {
                            if (cchName > 0)
                            {
                                memcpy(pchHeader, pCookie->_pchName, cchName);
                                pchHeader += cchName;
                                *pchHeader++ = '=';
                            }

                            if (cchValue > 0)
                            {
                                memcpy(pchHeader, pCookie->_pchValue, cchValue);
                                pchHeader += cchValue;
                            }

                            AddRequestHeader(HTTP_QUERY_COOKIE,
                                           pchHeaderStart,
                                           cch,
                                           0, 
                                           HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON);
                        }
                    }  // if (CanSend)
                } // for (pCookie)

                pLocation = pcj->GetCookies(pchRDomain, pchPath, pLocation, &ftNow);
            } // while (pLocation)
            pcj->_csCookieJar.Unlock();
        } // if pcj->_csCookieJar.Lock()
    }

Cleanup:
    if (fHeadersLocked)
        UnlockHeaders();
    if (pchHeaderStart)
        FREE_MEMORY(pchHeaderStart);
    if (pchRDomain)
        FREE_MEMORY(pchRDomain);
    if (pchPath)
        FREE_MEMORY(pchPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\http\chunkflt.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    chunkflt.cxx

Abstract:

    Contains a filter for encoding and decoding chunked transfers.

    Contents:
        FILTER_LIST::Insert
        FILTER_LIST::RemoveAll
        FILTER_LIST::Decode
        ChunkFilter::Reset
        ChunkFilter::Decode
        ChunkFilter::Encode
        ChunkFilter::RegisterContext
        ChunkFilter::UnregisterContext

Revision History:

    Created 13-Feb-2001

--*/

#include <wininetp.h>

// Global lookup table to map 0x0 - 0x7f bytes for obtaining mapping to its
// token value.  All values above 0x7f are considered to be data.
const BYTE g_bChunkTokenTable[] =
{
    /* 0x00 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_LF,    CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_CR,    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x10 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x20 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x30 */
    CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT,
    CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT,
    CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_COLON, CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x40 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT,
    CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x50 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x60 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT,
    CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DIGIT, CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,

    /* 0x70 */
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,
    CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA,  CHUNK_TOKEN_DATA
};

// Look-up table to map a token in a given state to the next state
const CHUNK_DECODE_STATE g_eMapChunkTokenToNextState[CHUNK_DECODE_STATE_LAST+1][CHUNK_TOKEN_LAST+1] =
{
/*
    |---------DIGIT----------|-------------CR-------------|-------------LF------------|----------COLON----------|-----------DATA----------|
*/
    // CHUNK_DECODE_STATE_START
    CHUNK_DECODE_STATE_SIZE,  CHUNK_DECODE_STATE_SIZE,     CHUNK_DECODE_STATE_SIZE,    CHUNK_DECODE_STATE_SIZE,  CHUNK_DECODE_STATE_SIZE,

    // CHUNK_DECODE_STATE_SIZE
    CHUNK_DECODE_STATE_SIZE,  CHUNK_DECODE_STATE_SIZE_CRLF,CHUNK_DECODE_STATE_ERROR,   CHUNK_DECODE_STATE_EXT,   CHUNK_DECODE_STATE_EXT,

    // CHUNK_DECODE_STATE_SIZE_CRLF
    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_SIZE_CRLF,CHUNK_DECODE_STATE_DATA,    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR,

    // CHUNK_DECODE_STATE_EXT
    CHUNK_DECODE_STATE_EXT,   CHUNK_DECODE_STATE_SIZE_CRLF,CHUNK_DECODE_STATE_ERROR,   CHUNK_DECODE_STATE_EXT,   CHUNK_DECODE_STATE_EXT,

    // CHUNK_DECODE_STATE_DATA
    CHUNK_DECODE_STATE_SIZE,  CHUNK_DECODE_STATE_DATA_CRLF,CHUNK_DECODE_STATE_ERROR,   CHUNK_DECODE_STATE_DATA,  CHUNK_DECODE_STATE_ERROR,

    // CHUNK_DECODE_STATE_DATA_CRLF
    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_DATA_CRLF,CHUNK_DECODE_STATE_SIZE,    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR,

    // CHUNK_DECODE_STATE_FOOTER_NAME
    CHUNK_DECODE_STATE_FOOTER_NAME, CHUNK_DECODE_STATE_FINAL_CRLF, CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_FOOTER_VALUE, CHUNK_DECODE_STATE_FOOTER_NAME,
    
    // CHUNK_DECODE_STATE_FOOTER_VALUE
    CHUNK_DECODE_STATE_FOOTER_VALUE, CHUNK_DECODE_STATE_FOOTER_CRLF, CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_FOOTER_VALUE, CHUNK_DECODE_STATE_FOOTER_VALUE,
    
    // CHUNK_DECODE_STATE_FOOTER_CRLF
    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_FINAL_CRLF, CHUNK_DECODE_STATE_FOOTER_NAME, CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR,

    // CHUNK_DECODE_STATE_FINAL_CRLF
    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_FINAL_CRLF, CHUNK_DECODE_STATE_FINISHED, CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR,

    // CHUNK_DECODE_STATE_QUOTED_DATA -- go until next quote, then manually revert to m_eQuoteExitState
    CHUNK_DECODE_STATE_QUOTED_DATA, CHUNK_DECODE_STATE_QUOTED_DATA,    CHUNK_DECODE_STATE_QUOTED_DATA,   CHUNK_DECODE_STATE_QUOTED_DATA, CHUNK_DECODE_STATE_QUOTED_DATA,

    // CHUNK_DECODE_STATE_ERROR
    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR,    CHUNK_DECODE_STATE_ERROR,   CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR,

    // CHUNK_DECODE_STATE_FINISHED -- force client to reset before reuse
    CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR,    CHUNK_DECODE_STATE_ERROR,   CHUNK_DECODE_STATE_ERROR, CHUNK_DECODE_STATE_ERROR
};

// Helper macros

// Where to next?
#define MAP_CHUNK_TOKEN_TO_NEXT_STATE(eCurState, chToken) \
    (g_eMapChunkTokenToNextState[(eCurState)][(chToken)])
    
// Given a byte, what does it represent w/regards to chunked responses
#define GET_CHUNK_TOKEN(ch)  ((ch) & 0x80 ? CHUNK_TOKEN_DATA : g_bChunkTokenTable[ch])

// Should only be used with digit tokens.
// Expects byte in range 0x30-0x39 (digits), 0x41-0x46 (uppercase hex),
// or 0x61-0x66 (lowercase hex)
#define GET_VALUE_FROM_ASCII_HEX(ch)  ((ch) - ((ch) & 0xf0) + (((ch) & 0x40) ? 9 : 0))


HRESULT ChunkFilter::Reset(DWORD_PTR dwContext)
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ChunkFilter::Reset",
                 "%#x",
                 dwContext
                 ));
   
    if (dwContext)
        (reinterpret_cast<ChunkDecodeContext *>(dwContext))->Reset();

    DEBUG_LEAVE(TRUE);

    return S_OK;
}

HRESULT
ChunkFilter::Decode(
    DWORD_PTR dwContext,
    IN OUT LPBYTE pInBuffer,
    IN DWORD dwInBufSize,
    IN OUT LPBYTE *ppOutBuffer,
    IN OUT LPDWORD pdwOutBufSize,
    OUT LPDWORD pdwBytesRead,
    OUT LPDWORD pdwBytesWritten
    )
/*++

Routine Description:

    Decode downloaded chunked data based on the inputted context and
    its current state

Arguments:

    dwContext       - registered encode/decode context for this filter

    pInBuffer       - input data buffer to be processed

    dwInBufSize     - byte count of pInBuffer

    ppOutBuffer     - allocated buffer containing encoded/decoded data if
                      not done in place with pInBuffer.

    pdwOutBufSize   - size of allocated output buffer, or 0 if pInBuffer holds
                      the processed data

    pdwBytesRead    - Number of input buffer bytes used

    pdwBytesWritten - Number of output buffer bytes written
                      
Return Value:

    HRESULT
        Success - S_OK

        Failure - E_FAIL

--*/
{
    HRESULT hResult = S_OK;
    LPBYTE pCurrentLoc = pInBuffer;
    LPBYTE pStartOfChunk = pInBuffer;
    ChunkDecodeContext * pCtx = reinterpret_cast<ChunkDecodeContext *>(dwContext);
    CHUNK_DECODE_STATE ePreviousState; 
    BYTE chToken;

    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ChunkFilter::Decode",
                 "%x, [%x, %.10q], %u, %x, %u, %x, %x",
                 dwContext,
                 pInBuffer,
                 pInBuffer,
                 dwInBufSize,
                 ppOutBuffer,
                 pdwOutBufSize,
                 pdwBytesRead,
                 pdwBytesWritten
                 ));

    if (!dwContext)
    {
        hResult = E_INVALIDARG;
        goto quit;
    }
    else if (!pdwBytesRead || !pdwBytesWritten || !pInBuffer ||
        (ppOutBuffer && !pdwOutBufSize))
    {
        hResult = E_POINTER;
        goto quit;
    }

    *pdwBytesRead  = 0;
    *pdwBytesWritten = 0;
    
    while (*pdwBytesRead < dwInBufSize &&
           pCtx->GetState() != CHUNK_DECODE_STATE_ERROR)
    {
        bool fUseTransitionMatrix = false;
        chToken = (BYTE)GET_CHUNK_TOKEN(*pCurrentLoc);
        ePreviousState = pCtx->GetState();
        pCtx->CheckStateSize();
        pCtx->IncrementStateSize();

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("ChunkFilter::Decode: %q, %q, %u/%u\n",
                    InternetMapChunkState(ePreviousState),
                    InternetMapChunkToken((CHUNK_TOKEN_VALUE)chToken),
                    *pdwBytesRead,
                    dwInBufSize
                    ));
        
        INET_ASSERT(pCurrentLoc < pInBuffer + dwInBufSize);

        switch (pCtx->GetState())
        {
            case CHUNK_DECODE_STATE_START:
                pCtx->Reset();
                pCtx->SetState(CHUNK_DECODE_STATE_SIZE);

                // fall through
                    
            case CHUNK_DECODE_STATE_SIZE:
            {
                if (chToken == CHUNK_TOKEN_DIGIT)
                {
                    if (pCtx->m_dwParsedSize & 0xF0000000)
                    {
                        // Don't allow overflow if by some chance
                        // the server is trying to send a chunk over
                        // 0x0FFFFFFF bytes worth in size.
                        pCtx->SetState(CHUNK_DECODE_STATE_ERROR);
                        break;
                    }
                            
                    pCtx->m_dwParsedSize <<= 4;
                    pCtx->m_dwParsedSize  += GET_VALUE_FROM_ASCII_HEX(*pCurrentLoc);
                }
                else
                {
                    
                    fUseTransitionMatrix = true;
                }
                break;
            }
            case CHUNK_DECODE_STATE_SIZE_CRLF:
                // Handle the zero case which can take us to the footer or final CRLF
                // If it's the final CRLF, then this should be the end of the data.
                if (pCtx->m_dwParsedSize == 0 && chToken == CHUNK_TOKEN_LF)
                {
                    pCtx->SetState(CHUNK_DECODE_STATE_FOOTER_NAME);
                }
                else
                {
                    fUseTransitionMatrix = true;
                }
                break;
            case CHUNK_DECODE_STATE_DATA:
            {
                INET_ASSERT(pCtx->m_dwParsedSize);
                    
                // account for EOB
                if (pCurrentLoc + pCtx->m_dwParsedSize <= pInBuffer + dwInBufSize)
                {
                    const DWORD dwParsedSize = pCtx->m_dwParsedSize;

                    // Move or skip the parsed size and crlf, if needed.
                    // The start of the chunk could be equal this time if
                    // spread across multiple decode calls.
                    if (pStartOfChunk != pCurrentLoc)
                    {
                        MoveMemory(pStartOfChunk,
                                   pCurrentLoc,
                                   dwParsedSize);
                    }

                    // -1 so we can look at the first byte after the data
                    // in the next pass.
                    pCurrentLoc += dwParsedSize - 1;
                    *pdwBytesRead += dwParsedSize - 1;
                    *pdwBytesWritten += dwParsedSize;
                    pStartOfChunk += dwParsedSize;
                    pCtx->m_dwParsedSize = 0;

                    pCtx->IncrementStateSize(dwParsedSize-1);

                    // Should be CRLF terminated
                    pCtx->SetState(CHUNK_DECODE_STATE_DATA_CRLF);
                }
                else 
                {
                    const DWORD dwSlice = dwInBufSize - (DWORD)(pCurrentLoc - pInBuffer);

                    // We're reaching the end of the buffer before
                    // the end of the chunk.  Update the parsed
                    // size remaining, so it will be carried over
                    // to the next call.
                    if (pStartOfChunk != pCurrentLoc)
                    {
                        // Skip over preceding size info.
                        MoveMemory(pStartOfChunk,
                                   pCurrentLoc,
                                   dwSlice);
                    }

                    // -1 so we can look at the first byte after the data
                    // in the next pass.  Offset should never be bigger than DWORD since
                    // since that's the biggest chunk we can handle.
                    *pdwBytesWritten += dwSlice;
                    pCtx->m_dwParsedSize -= dwSlice;
                    *pdwBytesRead += dwSlice - 1;
                    pCurrentLoc = pInBuffer + dwInBufSize - 1;

                    pCtx->IncrementStateSize(dwSlice-1);
                }
                break;
            }

            case CHUNK_DECODE_STATE_EXT:
            case CHUNK_DECODE_STATE_FOOTER_VALUE:
                if( (char)*pCurrentLoc == '"')
                    pCtx->SetStateEnterQuotedData();
                else
                    fUseTransitionMatrix = true;
                break;
            
            case CHUNK_DECODE_STATE_QUOTED_DATA:
                if( (char)*pCurrentLoc == '"')
                    pCtx->SetStateLeaveQuotedData();
                else
                    fUseTransitionMatrix = true;
                break;
                    
            // All remaining states simply parse over the value and
            // change state, depending on the token.
            default:
            {
                fUseTransitionMatrix = true;
                break;
            }
        }
        
        if( fUseTransitionMatrix)
        {
            pCtx->SetState(MAP_CHUNK_TOKEN_TO_NEXT_STATE(
                    ePreviousState,
                    chToken));
        }
        
        (*pdwBytesRead)++;
        pCurrentLoc++;
    }

    if (pCtx->GetState() == CHUNK_DECODE_STATE_ERROR)
    {
        DEBUG_PRINT(HTTP,
                    INFO,
                    ("ChunkFilter::Decode entered error state\n"
                    ));
        hResult = HRESULT_FROM_WIN32(pCtx->m_dwError);
    }
    
quit:
    DEBUG_LEAVE(hResult == S_OK ? TRUE : FALSE);
    
    return hResult;
}

HRESULT
ChunkFilter::Encode(
    DWORD_PTR dwContext,
    IN OUT LPBYTE pInBuffer,
    IN DWORD dwInBufSize,
    IN OUT LPBYTE *ppOutBuffer,
    IN OUT LPDWORD pdwOutBufSize,
    OUT LPDWORD pdwBytesRead,
    OUT LPDWORD pdwBytesWritten
    )
/*++

Routine Description:

    Chunk data for uploading based on the inputted context and current state

Arguments:

    dwContext       - registered encode/decode context for this filter

    pInBuffer       - input data buffer to be processed

    dwInBufSize     - byte count of pInBuffer

    ppOutBuffer     - allocated buffer containing encoded/decoded data if
                      not done in place with pInBuffer.

    pdwOutBufSize   - size of allocated output buffer, or 0 if pInBuffer holds
                      the processed data

    pdwBytesRead    - Number of input buffer bytes used

    pdwBytesWritten - Number of output buffer bytes written
                      
Return Value:

    HRESULT
        E_NOTIMPL - currently no chunked upload support

--*/
{
    // We don't support chunked uploads...yet
    UNREFERENCED_PARAMETER(dwContext);
    UNREFERENCED_PARAMETER(pInBuffer);
    UNREFERENCED_PARAMETER(dwInBufSize);
    UNREFERENCED_PARAMETER(ppOutBuffer);
    UNREFERENCED_PARAMETER(pdwOutBufSize);
    UNREFERENCED_PARAMETER(pdwBytesRead);
    UNREFERENCED_PARAMETER(pdwBytesWritten);
    return E_NOTIMPL;
}


HRESULT
ChunkFilter::RegisterContext(OUT DWORD_PTR *pdwContext)
{
    INET_ASSERT(0);  //
    return RegisterContextEx(pdwContext, (DWORD)-1);
}


HRESULT 
ChunkFilter::RegisterContextEx(OUT DWORD_PTR *pdwContext, DWORD dwMaxHeaderSize)
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ChunkFilter::RegisterContext",
                 "%#x",
                 pdwContext
                 ));

    HRESULT hr = S_OK;

    if (!pdwContext || IsBadWritePtr(pdwContext, sizeof(DWORD_PTR)))
    {
        hr = E_POINTER;
        goto quit;
    }

    *pdwContext = (DWORD_PTR) New ChunkDecodeContext(dwMaxHeaderSize);

    if (!*pdwContext)
    {
        hr = E_OUTOFMEMORY;
    }

quit:
    DEBUG_LEAVE(hr == S_OK ? TRUE : FALSE);

    return hr;
}

HRESULT
ChunkFilter::UnregisterContext(IN DWORD_PTR dwContext)
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ChunkFilter::UnregisterContext",
                 "%#x",
                 dwContext
                 ));

    HRESULT hr = S_OK;
    
    if (!dwContext)
    {
        hr = E_INVALIDARG;
        goto quit;
    }
    
    delete reinterpret_cast<ChunkDecodeContext *>(dwContext);

quit:
    DEBUG_LEAVE(hr == S_OK ? TRUE : FALSE);
    return hr;
}


// Always inserts as the beginning of the list
BOOL
FILTER_LIST::Insert(IN BaseFilter *pFilter, IN DWORD_PTR dwContext)
{
    LPFILTER_LIST_ENTRY pNewEntry;
    pNewEntry = New FILTER_LIST_ENTRY;
        
    if (pNewEntry != NULL)
    {
        pNewEntry->pFilter = pFilter;
        pNewEntry->dwContext = dwContext;
        pNewEntry->pNext = _pFilterEntry;
        _pFilterEntry = pNewEntry;
        _uFilterCount++;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


VOID
FILTER_LIST::ClearList()
{
    LPFILTER_LIST_ENTRY pEntry = _pFilterEntry;
    while (pEntry)
    {
        pEntry->pFilter->UnregisterContext(pEntry->dwContext);
        pEntry = pEntry->pNext;
        delete _pFilterEntry;
        _pFilterEntry = pEntry;
    }
    _uFilterCount = 0;
}


DWORD
FILTER_LIST::Decode(
    IN OUT LPBYTE pInBuffer,
    IN DWORD dwInBufSize,
    IN OUT LPBYTE *ppOutBuffer,
    IN OUT LPDWORD pdwOutBufSize,
    OUT LPDWORD pdwBytesRead,
    OUT LPDWORD pdwBytesWritten
    )
{
    LPFILTER_LIST_ENTRY pEntry = _pFilterEntry;
    HRESULT hr = S_OK;
    DWORD dwBytesRead = 0;
    DWORD dwBytesWritten = 0;
    LPBYTE pLocalInBuffer = pInBuffer;
    DWORD dwLocalInBufSize = dwInBufSize;

    *pdwBytesRead = 0;
    *pdwBytesWritten = 0;
      
    // Loop through filters which should be in the proper order
    while (pEntry)
    {
        dwBytesRead = 0;
        dwBytesWritten = 0;
        // At a minimum, we're guaranteed the decode method parses
        // the input buffer until one of the following is met:
        //
        // - Input buffer is fully parsed and processed
        // - Output buffer is filled up
        // - Decoder reaches a finished state
        // - Error occurs while processing input data
        //
        // Currently, only 1, 3, and 4 are possible since chunked
        // transfers are decoded in place.  We also don't need
        // to loop since chunked decoding is always fully done
        // in the first pass.
        do
        {
            pLocalInBuffer = pLocalInBuffer + dwBytesRead;
            dwLocalInBufSize = dwLocalInBufSize - dwBytesRead;
            dwBytesWritten = 0;
            dwBytesRead = 0;
            hr =  pEntry->pFilter->Decode(pEntry->dwContext,
                                          pLocalInBuffer,
                                          dwLocalInBufSize,
                                          ppOutBuffer,
                                          pdwOutBufSize,
                                          &dwBytesRead,
                                          &dwBytesWritten
                                          );

            *pdwBytesWritten += dwBytesWritten;
            *pdwBytesRead += dwBytesRead;
              
            if (hr == S_OK && dwBytesRead < dwLocalInBufSize)
            {
                // Given the current requirements we shouldn't be here
                // if there's still input buffer data to process.
                RIP(FALSE);
                hr = E_FAIL;
                goto quit;
            }
        } while  (hr == S_OK &&
                  dwLocalInBufSize > 0 &&
                  dwBytesRead < dwLocalInBufSize);
        pEntry = pEntry->pNext;
    }
    INET_ASSERT(hr != S_OK || dwBytesRead == dwLocalInBufSize);
quit:
    switch (hr)
    {
        case S_OK:
            return ERROR_SUCCESS;

        case E_OUTOFMEMORY:
            return ERROR_NOT_ENOUGH_MEMORY;

        case HRESULT_FROM_WIN32(ERROR_WINHTTP_INVALID_SERVER_RESPONSE):
            return ERROR_WINHTTP_INVALID_SERVER_RESPONSE;

        case HRESULT_FROM_WIN32(ERROR_WINHTTP_CHUNKED_ENCODING_HEADER_SIZE_OVERFLOW):
            return ERROR_WINHTTP_CHUNKED_ENCODING_HEADER_SIZE_OVERFLOW;

        default:
            return ERROR_WINHTTP_INTERNAL_ERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\handles\proxysup.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    proxysup.cxx

Abstract:

    Contains class implementation for proxy server and proxy bypass list

    Contents:
        IsLocalMacro

        PROXY_SERVER_LIST_ENTRY::WriteEntry

        PROXY_SERVER_LIST::AddList
        PROXY_SERVER_LIST::Find
        PROXY_SERVER_LIST::Add
        PROXY_SERVER_LIST::ProxyScheme
        PROXY_SERVER_LIST::GetProxyHostName
        PROXY_SERVER_LIST::AddToBypassList
        PROXY_SERVER_LIST::GetList

        PROXY_BYPASS_LIST_ENTRY::WriteEntry

        PROXY_BYPASS_LIST::AddList
        PROXY_BYPASS_LIST::Find
        PROXY_BYPASS_LIST::Add
        PROXY_BYPASS_LIST::IsBypassed
        PROXY_BYPASS_LIST::IsHostInBypassList
        PROXY_BYPASS_LIST::GetList

        PROXY_INFO::GetProxyStringInfo
        PROXY_INFO::HostBypassesProxy
        PROXY_INFO::RedoSendRequest
        PROXY_INFO::Terminate
        PROXY_INFO::CleanOutLists

        PROXY_STATE::GetNextProxy

        (GetRegistryProxyParameter)

Author:

    Richard L Firth (rfirth) 03-Feb-1996

Revision History:

    03-Feb-1996 rfirth
        Created

--*/

#include <wininetp.h>

//
// private manifests
//

#define DEFAULT_PROXY_BUFFER_LENGTH     (4 K)
#define MAX_IP_ADDRESS_STRING_LENGTH    (4 * 4 - 1) // ###.###.###.###
#define PROXY_REGISTRY_STRING_LENGTH    (4 K)

//
// private types
//

typedef enum {
    STATE_START,
    STATE_PROTOCOL,
    STATE_SCHEME,
    STATE_SERVER,
    STATE_PORT,
    STATE_END,
    STATE_ERROR
} PARSER_STATE;


//
// private prototypes
//

PRIVATE
LPSTR
GetRegistryProxyParameter(
    IN LPSTR lpszParameterName
    );





//
// functions
//


BOOL
IsLocalMacro(
    IN LPSTR lpszMetaName,
    IN DWORD dwMetaNameLength
    )

/*++

Routine Description:

    Checks for local macro name

Arguments:

    lpszMetaName        - name to check

    dwMetaNameLength    - length

Return Value:

    BOOL
        TRUE    - it is <local>

        FALSE   - not

--*/

{
    INET_ASSERT(lpszMetaName != NULL);

    static const char s_local[] = "<local>";

    return (strnicmp(s_local, lpszMetaName, dwMetaNameLength) == 0);
}


//
// member functions
//


BOOL
PROXY_SERVER_LIST_ENTRY::WriteEntry(
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Writes this proxy server list entry as a string in the supplied buffer

Arguments:

    lpszBuffer          - pointer to buffer where string is written

    lpdwBufferLength    - IN: amount of space in buffer
                          OUT: number of bytes copied, or required size

Return Value:

    BOOL
        TRUE    - entry written to buffer

        FALSE   - entry not written to buffer - *lpdwBufferLength contains
                  required size

--*/

{
    DWORD requiredLength;
    LPSTR protocolName;
    DWORD protocolNameLength;
    LPSTR schemeName;
    DWORD schemeNameLength;
    INTERNET_PORT magnitude = 1;

    protocolName = MapUrlScheme(_Protocol, &protocolNameLength);
    if (protocolName != NULL) {
        requiredLength = protocolNameLength + 1;    // for '='
    } else {
        requiredLength = 0;
    }
    schemeName = MapUrlScheme(_Scheme, &schemeNameLength);
    if (schemeName != NULL) {
        requiredLength += schemeNameLength + sizeof("://") - 1;
    }
    requiredLength += _ProxyName.StringLength();
    if (_ProxyPort != INTERNET_INVALID_PORT_NUMBER) {
        for (INTERNET_PORT n = 10000, i = 5; n > 0; n /= 10, --i) {
            if (_ProxyPort / n) {
                requiredLength += i + 1;    // for ':'
                magnitude = n;
                break;
            }
        }
    }

    BOOL success;

    if (*lpdwBufferLength > requiredLength) {
        if (protocolName != NULL) {
            memcpy(lpszBuffer, protocolName, protocolNameLength);
            lpszBuffer += protocolNameLength;
            *lpszBuffer++ = '=';
        }
        if (schemeName != NULL) {
            memcpy(lpszBuffer, schemeName, schemeNameLength);
            lpszBuffer += schemeNameLength;
            memcpy(lpszBuffer, "://", sizeof("://") - 1);
            lpszBuffer += sizeof("://") - 1;
        }
        _ProxyName.CopyTo(lpszBuffer);
        lpszBuffer += _ProxyName.StringLength();
        if (_ProxyPort != INTERNET_INVALID_PORT_NUMBER) {
            *lpszBuffer++ = ':';
            for (INTERNET_PORT n = _ProxyPort, i = magnitude; i; i /= 10) {
                *lpszBuffer++ = (char)(n / i) + '0';
                n %= i;
            }
        }
        success = TRUE;
    } else {
        success = FALSE;
    }
    *lpdwBufferLength = requiredLength;
    return success;
}


DWORD
PROXY_SERVER_LIST::AddList(
    IN LPSTR lpszList
    )

/*++

Routine Description:

    Parses a list of proxy servers and creates a PROXY_SERVER_LIST_ENTRY for
    each one

Arguments:

    lpszList    - pointer to list of proxies of the form:

                    [<scheme>=][<scheme>"://"]<server>[":"<port>][";"*]

                  The list can be NULL, in which case we read it from the
                  registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    At least one entry in lpszList is bogus

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_SERVER_LIST::AddList",
                "%.80q",
                lpszList
                ));

    DWORD entryLength;
    LPSTR protocolName;
    DWORD protocolLength;
    LPSTR schemeName;
    DWORD schemeLength;
    LPSTR serverName;
    DWORD serverLength;
    PARSER_STATE state;
    DWORD nSlashes;
    INTERNET_PORT port;
    BOOL done;

    entryLength = 0;
    protocolName = lpszList;
    protocolLength = 0;
    schemeName = NULL;
    schemeLength = 0;
    serverName = NULL;
    serverLength = 0;
    state = STATE_PROTOCOL;
    nSlashes = 0;
    port = 0;
    done = FALSE;

    //
    // walk the list, pulling out the various scheme parts
    //

    do {

        char ch = *lpszList++;

        if ((nSlashes == 1) && (ch != '/')) {
            state = STATE_ERROR;
            break;
        }

        switch (ch) {
        case '=':
            if ((state == STATE_PROTOCOL) && (entryLength != 0)) {
                protocolLength = entryLength;
                entryLength = 0;
                state = STATE_SCHEME;
                schemeName = lpszList;
            } else {

                //
                // '=' can't legally appear anywhere else
                //

                state = STATE_ERROR;
            }
            break;

        case ':':
            switch (state) {
            case STATE_PROTOCOL:
                if (*lpszList == '/') {
                    schemeName = protocolName;
                    protocolName = NULL;
                    schemeLength = entryLength;
                    protocolLength = 0;
                    state = STATE_SCHEME;
                } else if (*lpszList != '\0') {
                    serverName = protocolName;
                    serverLength = entryLength;
                    state = STATE_PORT;
                } else {
                    state = STATE_ERROR;
                }
                entryLength = 0;
                break;

            case STATE_SCHEME:
                if (*lpszList == '/') {
                    schemeLength = entryLength;
                } else if (*lpszList != '\0') {
                    serverName = schemeName;
                    serverLength = entryLength;
                    state = STATE_PORT;
                } else {
                    state = STATE_ERROR;
                }
                entryLength = 0;
                break;

            case STATE_SERVER:
                serverLength = entryLength;
                state = STATE_PORT;
                entryLength = 0;
                break;

            default:
                state = STATE_ERROR;
                break;
            }
            break;

        case '/':
            if ((state == STATE_SCHEME) && (nSlashes < 2) && (entryLength == 0)) {
                if (++nSlashes == 2) {
                    state = STATE_SERVER;
                    serverName = lpszList;
                }
            } else {
                state = STATE_ERROR;
            }
            break;

        default:
            if (state != STATE_PORT) {
                ++entryLength;
            } else if (isdigit(ch)) {

                //
                // BUGBUG - we will overflow if >65535
                //

                port = port * 10 + (ch - '0');
            } else {

                //
                // STATE_PORT && non-digit character - error
                //

                state = STATE_ERROR;
            }
            break;

        case '\0':
            done = TRUE;

            //
            // fall through
            //

        case '\t':
        case '\n':
        case '\v':  // vertical tab, 0x0b
        case '\f':  // form feed, 0x0c
        case '\r':
        case ' ':
        case ';':
        case ',':
            if (serverLength == 0) {
                serverLength = entryLength;
            }
            if (serverLength != 0) {
                if (serverName == NULL) {
                    serverName = (schemeName != NULL)
                        ? schemeName
                        : protocolName;
                }

                INET_ASSERT(serverName != NULL);

                INTERNET_SCHEME protocol;

                if (protocolLength != 0) {
                    protocol = MapUrlSchemeName(protocolName, protocolLength);
                } else {
                    protocol = INTERNET_SCHEME_DEFAULT;
                }

                INTERNET_SCHEME scheme;

                if (schemeLength != 0) {
                    scheme = MapUrlSchemeName(schemeName, schemeLength);
                } else {
                    scheme = INTERNET_SCHEME_DEFAULT;
                }

                //
                // add an entry if this is a protocol we handle and we don't
                // already have an entry for it
                //

                if ((protocol != INTERNET_SCHEME_UNKNOWN)
                && (scheme != INTERNET_SCHEME_UNKNOWN)

                //
                // we can only currently handle CERN (secure or unsecure) and
                // FTP proxies, so kick out anything that wants to go via any
                // other proxy scheme
                //

                && ((scheme == INTERNET_SCHEME_DEFAULT)
                || (scheme == INTERNET_SCHEME_HTTP)
                || (scheme == INTERNET_SCHEME_HTTPS))) {
                    if (!Find(protocol)) {

                        //
                        // don't worry if Add() fails - we just continue
                        //

                        Add(protocol, scheme, serverName, serverLength, port);
                    }
                }
            }
            entryLength = 0;
            protocolName = lpszList;
            protocolLength = 0;
            schemeName = NULL;
            schemeLength = 0;
            serverName = NULL;
            serverLength = 0;
            nSlashes = 0;
            port = 0;
            state = STATE_PROTOCOL;
            break;
        }
        if (state == STATE_ERROR) {
            break;
        }
    } while (!done);

    DWORD error;

    if (state == STATE_ERROR) {
        error = ERROR_INVALID_PARAMETER;
    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_SERVER_LIST::Find(
    IN INTERNET_SCHEME tScheme
    )

/*++

Routine Description:

    Find a PROXY_SERVER_LIST_ENTRY based on the scheme

Arguments:

    tScheme - protocol scheme to find

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "PROXY_SERVER_LIST::Find",
                "%s",
                InternetMapScheme(tScheme)
                ));

    BOOL found = FALSE;

    if (!LockSerializedList(&_List))
        goto quit;

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);

        if (info->_Protocol == tScheme) {
            found = TRUE;
            break;
        }
    }

    UnlockSerializedList(&_List);

quit:
    DEBUG_LEAVE(found);

    return found;
}


DWORD
PROXY_SERVER_LIST::Add(
    IN INTERNET_SCHEME tProtocol,
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort
    )

/*++

Routine Description:

    Create an add a PROXY_SERVER_LIST_ENTRY to the PROXY_SERVER_LIST

Arguments:

    tProtocol           - protocol which uses the proxy

    tScheme             - scheme used to talk to the proxy

    lpszHostName        - proxy host name

    dwHostNameLength    - length of proxy host name

    nPort               - port at proxy host

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_SERVER_LIST::Add",
                "%s, %s, %.*q, %d, %d",
                InternetMapScheme(tProtocol),
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort
                ));

    PROXY_SERVER_LIST_ENTRY * entry;

    entry = New PROXY_SERVER_LIST_ENTRY(tProtocol,
                                        tScheme,
                                        lpszHostName,
                                        dwHostNameLength,
                                        nPort
                                        );

    DWORD error = ERROR_SUCCESS;

    if (entry != NULL) {
        error = entry->GetError();
        if (error == ERROR_SUCCESS) {
            //error = entry->ResolveAddress();
            //if (error == ERROR_SUCCESS) {
            //    InsertAtTailOfSerializedList(&_List, &entry->_List);
            //}
            if (entry->_Protocol == INTERNET_SCHEME_DEFAULT) {
                if (!InsertAtTailOfSerializedList(&_List, &entry->_List)) {
                    delete entry;
                    error = ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                if (!InsertAtHeadOfSerializedList(&_List, &entry->_List)) {
                    delete entry;
                    error = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        } else {
            delete entry;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    DEBUG_LEAVE(error);

    return error;
}


INTERNET_SCHEME
PROXY_SERVER_LIST::ProxyScheme(
    IN INTERNET_SCHEME tProtocol
    )

/*++

Routine Description:

    Determines protocol over which tScheme goes through proxy

Arguments:

    tProtocol   - protocol scheme used to retrieve data (e.g. FTP)

Return Value:

    INTERNET_SCHEME
        Success - scheme by which protocol goes via proxy

        Failure - INTERNET_SCHEME_UNKNOWN
--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Int,
                "PROXY_SERVER_LIST::ProxyScheme",
                "%s",
                InternetMapScheme(tProtocol)
                ));

    INTERNET_SCHEME tScheme = INTERNET_SCHEME_UNKNOWN;

    if (!LockSerializedList(&_List))
        goto quit;

    //
    // the list really shouldn't be empty if we're here
    //

    INET_ASSERT(!IsSerializedListEmpty(&_List));

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);

        //
        // if we find a match for the protocol, or this protocol is handled by
        // the default proxy entry then we are done
        //

        if ((info->_Protocol == tProtocol)
        || (info->_Protocol == INTERNET_SCHEME_DEFAULT)) {
            tScheme = info->_Scheme;

            //
            // the default scheme is HTTP (CERN proxy)
            //

            if (tScheme == INTERNET_SCHEME_DEFAULT) {
                tScheme = INTERNET_SCHEME_HTTP;
            }
            break;
        }
    }

    UnlockSerializedList(&_List);

quit:
    DEBUG_LEAVE(tScheme);

    return tScheme;
}


BOOL
PROXY_SERVER_LIST::GetProxyHostName(
    IN INTERNET_SCHEME tProtocol,
    IN OUT LPINTERNET_SCHEME lptScheme,
    OUT LPSTR * lplpszHostName,
    OUT LPBOOL lpbFreeHostName,
    OUT LPDWORD lpdwHostNameLength,
    OUT LPINTERNET_PORT lpHostPort
    )

/*++

Routine Description:

    Given a protocol, map it to the proxy we use to retrieve the data

Arguments:

    tProtocol           - protocol to map (e.g. find the proxy for FTP)

    lptScheme           - IN: preferred scheme if INTERNET_SCHEME_DEFAULT
                          OUT: returned scheme

    lplpszHostName      - pointer to returned pointer to host name

    lpbFreeHostName     - returned TRUE if *lplpszHostName allocated

    lpdwHostNameLength  - pointer to returned host name length

    lpHostPort          - pointer to returned host port

Return Value:

    BOOL
        TRUE    - requested info has been returned

        FALSE   - requested info was not found

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Bool,
                 "PROXY_SERVER_LIST::GetProxyHostName",
                 "%s, %#x, %#x, %#x, %#x, %#x",
                 InternetMapScheme(tProtocol),
                 lptScheme,
                 lplpszHostName,
                 lpbFreeHostName,
                 lpdwHostNameLength,
                 lpHostPort
                 ));

    INET_ASSERT(tProtocol != INTERNET_SCHEME_UNKNOWN);

    //
    // *lptScheme must now be one of the recognized schemes, or the default
    //

    INET_ASSERT((*lptScheme == INTERNET_SCHEME_DEFAULT)
                || (*lptScheme == INTERNET_SCHEME_HTTP)
                || (*lptScheme == INTERNET_SCHEME_HTTPS)
                || (*lptScheme == INTERNET_SCHEME_SOCKS)
                );

    BOOL found = FALSE;

    if (!LockSerializedList(&_List))
        goto quit;

    //
    // the list really shouldn't be empty if we're here
    //

    INET_ASSERT(!IsSerializedListEmpty(&_List));

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);

        //
        // if we find a match for the protocol, or this protocol is handled by
        // the default proxy entry then we are done
        //
        // Hack: But make sure its NOT socks since, socks must be
        //  an exact match !!! No defaults.
        //

        if ((info->_Protocol == tProtocol)
        || ((info->_Protocol == INTERNET_SCHEME_DEFAULT)
                && (tProtocol != INTERNET_SCHEME_SOCKS)  )) {

            INTERNET_SCHEME scheme = info->_Scheme;

            //
            // the returned scheme is the input preferred scheme unless it was
            // the default scheme in which case we return HTTP (CERN proxy)
            //

            if (scheme == INTERNET_SCHEME_DEFAULT) {
                scheme = (*lptScheme == INTERNET_SCHEME_DEFAULT)
                            ? INTERNET_SCHEME_HTTP
                            : *lptScheme;
            }
            *lptScheme = scheme;
            *lpbFreeHostName = FALSE;
            *lpdwHostNameLength = 0;
            *lplpszHostName = NewString(info->_ProxyName.StringAddress(),
                                        info->_ProxyName.StringLength()
                                        );
            if (*lplpszHostName != NULL) {
                *lpbFreeHostName = TRUE;
                *lpdwHostNameLength = info->_ProxyName.StringLength();
            }

            INTERNET_PORT port = info->_ProxyPort;

            //
            // map the default port value
            //

            if (port == INTERNET_INVALID_PORT_NUMBER) {
                switch (scheme) {
                case INTERNET_SCHEME_HTTP:
                    port = INTERNET_DEFAULT_HTTP_PORT;
                    break;

                case INTERNET_SCHEME_HTTPS:
                    port = INTERNET_DEFAULT_HTTPS_PORT;
                    break;

                case INTERNET_SCHEME_SOCKS:
                    port = INTERNET_DEFAULT_SOCKS_PORT;
                    break;
                }
            }
            *lpHostPort = port;
            found = TRUE;

            DEBUG_PRINT(PROXY,
                        INFO,
                        ("proxy = %s://%s:%d\n",
                        MapUrlSchemeToName(scheme),
                        info->_ProxyName.StringAddress(),
                        port
                        ));

            break;
        }
    }

    UnlockSerializedList(&_List);

quit:
    DEBUG_LEAVE(found);

    return found;
}


DWORD
PROXY_SERVER_LIST::AddToBypassList(
    IN PROXY_BYPASS_LIST * lpBypassList
    )

/*++

Routine Description:

    For all proxy servers in the server list, we add the details to the bypass
    list. By default, an app mustn't send a request to the proxy via the proxy!
    Additionally, the app should not have to specifically nominate the proxy
    server(s) as bypassing the proxy

Arguments:

    lpBypassList    - pointer to bypass proxy list where proxy servers will be
                      added

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error = ERROR_SUCCESS;
    PLIST_ENTRY entry = HeadOfSerializedList(&_List);

    while ((entry != (PLIST_ENTRY)SlSelf(&_List)) && (error == ERROR_SUCCESS)) {

        PROXY_SERVER_LIST_ENTRY * info = (PROXY_SERVER_LIST_ENTRY *)entry;

        if (!lpBypassList->Find(info->_Scheme,
                                info->_ProxyName.StringAddress(),
                                info->_ProxyName.StringLength(),
                                info->_ProxyPort)) {
            error = lpBypassList->Add(info->_Scheme,
                                      info->_ProxyName.StringAddress(),
                                      info->_ProxyName.StringLength(),
                                      info->_ProxyPort
                                      );
        }
        entry = entry->Flink;
    }
    return error;
}


VOID
PROXY_SERVER_LIST::GetList(
    OUT LPSTR * lplpszList,
    IN DWORD dwBufferLength,
    IN OUT LPDWORD lpdwRequiredLength
    )

/*++

Routine Description:

    Writes the list of proxy servers to a buffer, and/or returns the required
    buffer length

Arguments:

    lplpszList          - pointer to pointer to buffer where list is written, if
                          sufficient space

    dwBufferLength      - amount of space in *lplpszList

    lpdwRequiredLength  - OUT: cumulative size of data

Return Value:

    None.

--*/

{
    LPSTR lpszList = *lplpszList;
    BOOL firstTime = TRUE;
    BOOL outOfBuffer = FALSE;

    if (!LockSerializedList(&_List))
        return;

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);
        if (!firstTime) {

            //
            // write delimiter if enough space
            //

            if (dwBufferLength >= 1) {
                *lpszList++ = ' ';
                --dwBufferLength;
            }
            ++*lpdwRequiredLength;
        } else {
            firstTime = FALSE;
        }

        //
        // find the length of the current entry & write it to the buffer if
        // enough space
        //

        DWORD length = dwBufferLength;

        info->WriteEntry(lpszList, &length);
        if (dwBufferLength >= length) {

            //
            // we wrote it
            //

            dwBufferLength -= length;
        } else {

            //
            // no buffer left
            //

            dwBufferLength = 0;
            outOfBuffer = TRUE;
        }
        *lpdwRequiredLength += length;
        lpszList += length;
    }

    if (!outOfBuffer) {
        if (dwBufferLength > 0) {
            *lpszList++ = '\0';
            *lplpszList = lpszList;
        }
    }

    //
    // add 1 for the terminating NUL
    //

    ++*lpdwRequiredLength;

    UnlockSerializedList(&_List);
}


BOOL
PROXY_BYPASS_LIST_ENTRY::WriteEntry(
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Writes this proxy bypass list entry as a string in the supplied buffer

Arguments:

    lpszBuffer          - pointer to buffer where string is written

    lpdwBufferLength    - IN: amount of space in buffer
                          OUT: number of bytes copied, or required size

Return Value:

    BOOL
        TRUE    - entry written to buffer

        FALSE   - entry not written to buffer - *lpdwBufferLength contains
                  required size

--*/

{
    DWORD requiredLength;
    LPSTR schemeName;
    DWORD schemeNameLength;
    INTERNET_PORT magnitude = 1;

    if (_Scheme != INTERNET_SCHEME_DEFAULT) {
        schemeName = MapUrlScheme(_Scheme, &schemeNameLength);
        requiredLength = schemeNameLength + sizeof("://") - 1;
    } else {
        schemeName = NULL;
        requiredLength = 0;
        schemeNameLength = 0;
    }
    if (IsLocal()) {
        requiredLength += sizeof("<local>") - 1;
    } else {
        requiredLength += _Name.StringLength();
    }
    if (_Port != INTERNET_INVALID_PORT_NUMBER) {
        for (INTERNET_PORT n = 10000, i = 5; n > 0; n /= 10, --i) {
            if (_Port / n) {
                requiredLength += i + 1;
                magnitude = n;
                break;
            }
        }
    }

    BOOL success;

    if (*lpdwBufferLength > requiredLength) {
        if (schemeName != NULL) {
            memcpy(lpszBuffer, schemeName, schemeNameLength);
            lpszBuffer += schemeNameLength;
            memcpy(lpszBuffer, "://", sizeof("://") - 1);
            lpszBuffer += sizeof("://") - 1;
        }
        if (IsLocal()) {
            memcpy(lpszBuffer, "<local>", sizeof("<local>") - 1);
            lpszBuffer += sizeof("<local>") - 1;
        } else {
            _Name.CopyTo(lpszBuffer);
            lpszBuffer += _Name.StringLength();
        }
        if (_Port != INTERNET_INVALID_PORT_NUMBER) {
            *lpszBuffer++ = ':';
            for (INTERNET_PORT n = _Port, i = magnitude; i; i /= 10) {
                *lpszBuffer++ = (char)(n / i) + '0';
                n %= i;
            }
        }
        success = TRUE;
    } else {
        success = FALSE;
    }
    *lpdwBufferLength = requiredLength;
    return success;
}


DWORD
PROXY_BYPASS_LIST::AddList(
    IN LPSTR lpszList
    )

/*++

Routine Description:

    Parses a list of proxy bypass specifiers and adds them to the list

Arguments:

    lpszList    - pointer to string containing list of proxy bypass specifiers.
                  The format is:

                    [<scheme>"://"][<server>][":"<port>"]

                  The list can be NULL, in which case we read it from the
                  registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_BYPASS_LIST::AddList",
                "%.80q",
                lpszList
                ));

    DWORD entryLength;
    LPSTR schemeName;
    DWORD schemeLength;
    LPSTR serverName;
    DWORD serverLength;
    PARSER_STATE state;
    DWORD nSlashes;
    INTERNET_PORT port;
    BOOL done;

    entryLength = 0;
    schemeName = lpszList;
    schemeLength = 0;
    serverName = NULL;
    serverLength = 0;
    state = STATE_SCHEME;
    nSlashes = 0;
    port = 0;
    done = FALSE;

    //
    // walk the list, pulling out the various scheme parts
    //

    do {

        char ch = *lpszList++;

        if ((nSlashes == 1) && (ch != '/')) {
            state = STATE_ERROR;
            break;
        }

        switch (ch) {
        case ':':
            switch (state) {
            case STATE_SCHEME:
                if (*lpszList == '/') {
                    schemeLength = entryLength;
                } else if (*lpszList != '\0') {
                    serverName = schemeName;
                    serverLength = entryLength;
                    if (serverLength == 0) {
                        serverLength = 1;
                        serverName = "*";
                    }
                    state = STATE_PORT;
                } else {
                    state = STATE_ERROR;
                }
                entryLength = 0;
                break;

            case STATE_SERVER:
                serverLength = entryLength;
                state = STATE_PORT;
                entryLength = 0;
                break;

            default:
                state = STATE_ERROR;
                break;
            }
            break;

        case '/':
            if ((state == STATE_SCHEME) && (nSlashes < 2) && (entryLength == 0)) {
                if (++nSlashes == 2) {
                    state = STATE_SERVER;
                    serverName = lpszList;
                }
            } else {
                state = STATE_ERROR;
            }
            break;

        default:
            if (state != STATE_PORT) {
                ++entryLength;
            } else if (isdigit(ch)) {

                //
                // BUGBUG - we will overflow if >65535
                //

                port = port * 10 + (ch - '0');
            } else {

                //
                // STATE_PORT && non-digit character - error
                //

                state = STATE_ERROR;
            }
            break;

        case '\0':
            done = TRUE;

            //
            // fall through
            //

        case '\t':
        case '\n':
        case '\v':  // vertical tab, 0x0b
        case '\f':  // form feed, 0x0c
        case '\r':
        case ' ':
        case ';':
        case ',':
            if (serverLength == 0) {
                serverLength = entryLength;
                if ((serverLength == 0)
                && ((state == STATE_SERVER) || (state == STATE_PORT))) {

                    //
                    // we found e.g. "http://" or "http://:80". We allow this as
                    // "http://*" or "http://*:80"
                    //

                    serverLength = 1;
                    serverName = "*";
                }
            }
            if (serverLength != 0) {
                if (serverName == NULL) {
                    serverName = schemeName;
                }

                INTERNET_SCHEME scheme;

                if (schemeLength != 0) {
                    scheme = MapUrlSchemeName(schemeName, schemeLength);
                } else {
                    scheme = INTERNET_SCHEME_DEFAULT;
                }

                //
                // add an entry if this is a protocol we handle and we don't
                // already have an entry for it
                //

                if ((scheme != INTERNET_SCHEME_UNKNOWN)
                && !Find(scheme, serverName, serverLength, port)) {

                    //
                    // don't worry if Add() fails - we just continue
                    //

                    Add(scheme, serverName, serverLength, port);
                }
            }
            entryLength = 0;
            schemeName = lpszList;
            schemeLength = 0;
            serverName = NULL;
            serverLength = 0;
            nSlashes = 0;
            port = 0;
            state = STATE_SCHEME;
            break;
        }
        if (state == STATE_ERROR) {
            break;
        }
    } while (!done);

    DWORD error;

    if (state == STATE_ERROR) {
        error = ERROR_INVALID_PARAMETER;
    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_BYPASS_LIST::Find(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName OPTIONAL,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort
    )

/*++

Routine Description:

    Determines if a proxy bypass entry matches the criteria.

    Currently, name matching is simplistic: e.g. "*.com" and "**.com" are
    treated as 2 separate strings, where we should collapse multiple wildcard
    specifiers, etc. Also: "w*" should replace "ww*", etc.

Arguments:

    tScheme             - scheme for this entry

    lpszHostName        - host name or address. May contain wildcards (*)

    dwHostNameLength    - length of host name or address

    nPort               - port

Return Value:

    BOOL
        TRUE    - an entry corresponding to the arguments was found

        FALSE   - didn't find entry

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "PROXY_BYPASS_LIST::Find",
                "%s, %.*q, %d, %d",
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort
                ));

    BOOL isLocal = IsLocalMacro(lpszHostName, dwHostNameLength);
    BOOL found = FALSE;

    if (!LockSerializedList(&_List))
        goto quit;

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_BYPASS_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_BYPASS_LIST_ENTRY, _List);

        //
        // do the easy bits first
        //

        if (!((info->_Scheme == tScheme)
        || (info->_Scheme == INTERNET_SCHEME_DEFAULT))) {
            continue;
        }
        if (!((info->_Port == nPort)
        || (info->_Port == INTERNET_INVALID_PORT_NUMBER))) {
            continue;
        }

        //
        // check for name match
        //

        if (info->_LocalSemantics) {
            if (isLocal) {
                found = TRUE;
                break;
            } else {
                continue;
            }
        }

        //
        // not local semantics, have to match target
        //

        //
        // BUGBUG - we only do simplistic matching. If the strings don't match
        //          exactly, except for case, they are deemed to be different
        //

        if (info->_Name.Strnicmp(lpszHostName, (int)dwHostNameLength) != 0) {
            continue;
        }

        //
        // any path that didn't continue, or has not already broken out has
        // succeeded in finding a match
        //

        DEBUG_PRINT(PROXY,
                    INFO,
                    ("Matched: %q, %q\n",
                    lpszHostName,
                    info->_Name.StringAddress()
                    ));

        found = TRUE;
        break;
    }

    UnlockSerializedList(&_List);

quit:
    DEBUG_LEAVE(found);

    return found;
}


DWORD
PROXY_BYPASS_LIST::Add(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort
    )

/*++

Routine Description:

    Create and add a PROXY_BYPASS_LIST_ENTRY to the PROXY_BYPASS_LIST

Arguments:

    tScheme             - scheme to bypass. May be 0 meaning any protocol

    lpszHostName        - name of host to bypass. May be name or IP address and
                          may contain wildcard characters

    dwHostNameLength    - length of bypass name string

    nPort               - port to bypass. May be 0, meaning any port

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_BYPASS_LIST::Add",
                "%s, %.*q, %d, %d",
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort
                ));

    PROXY_BYPASS_LIST_ENTRY * entry;

    entry = New PROXY_BYPASS_LIST_ENTRY(tScheme,
                                        lpszHostName,
                                        dwHostNameLength,
                                        nPort
                                        );

    DWORD error = ERROR_SUCCESS;

    if (entry != NULL) {
        error = entry->GetError();
        if (error == ERROR_SUCCESS) {
            //
            // if the bypass entry uses local name matching semantics, then we add
            // it to the end of the list, else the head. The reason we do this is
            // to allow <local> to be a default after all other (possibly also
            // local) entries are checked
            //

            if (entry->IsLocal()) {
                if (!InsertAtTailOfSerializedList(&_List, &entry->_List)) {
                    delete entry;
                    error = ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                if (!InsertAtHeadOfSerializedList(&_List, &entry->_List)) {
                    delete entry;
                    error = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        } else {
            delete entry;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_BYPASS_LIST::IsBypassed(
    IN INTERNET_HANDLE_OBJECT* pSessionObject,
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort,
    IN BOOL IsAddress,
    IN LPSOCKADDR lpSockAddr OPTIONAL
    )

/*++

Routine Description:

    Determines if a scheme/name/port is bypassed

Arguments:

    tScheme             - can be 0, meaning match any scheme

    lpszHostName        - can contain wildcards. May be name or IP address

    dwHostNameLength    - length of name/address part. May be 0, meaning match
                          any name/address

    nPort               - can be 0, meaning match any port

    IsAddress           - TRUE means hostname is a literal address

    lpSockAddr          - optional parsed literal address in a SockAddr

Return Value:

    BOOL
        TRUE    - an entry on the bypass list matched the criteria

        FALSE   - the host identified by the parameters is not on this bypass
                  list

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "PROXY_BYPASS_LIST::IsBypassed",
                "%s, %.*q, %d, %d, %B, %A",
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort,
                IsAddress,
                lpSockAddr
                ));

    INET_ASSERT(lpszHostName != NULL);
    INET_ASSERT(dwHostNameLength != 0);

    //
    // if we have a literal address try to map it to something already in the cache
    //

    LPSTR mappedName = NULL;

    if (IsAddress && lpSockAddr) {
        mappedName = MapNetAddressToName(pSessionObject, lpSockAddr);
        if (mappedName) {
            lpszHostName = mappedName;
            dwHostNameLength = lstrlen(lpszHostName);
        }
    }
    
    BOOL found;
    found = IsHostInBypassList (
                tScheme,
                lpszHostName,
                dwHostNameLength,
                nPort,
                IsAddress);

    if (mappedName != NULL) {

        mappedName = (LPSTR)FREE_MEMORY(mappedName);
        INET_ASSERT(mappedName == NULL);
    }

    DEBUG_LEAVE(found);
    return found;
}


BOOL
PROXY_BYPASS_LIST::IsHostInBypassList(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort,
    IN BOOL isAddress
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    tScheme             -
    lpszHostName        -
    dwHostNameLength    -
    nPort               -
    isAddress           -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Bool,
                 "PROXY_BYPASS_LIST::IsHostInBypassList",
                 "%d (%s), %.*q, %d, %d, %B",
                 tScheme,
                 InternetMapScheme(tScheme),
                 dwHostNameLength,
                 lpszHostName,
                 dwHostNameLength,
                 nPort,
                 isAddress
                 ));

    BOOL found = FALSE;

    //
    // if not an address, determine if the name contains at least one dot
    //

    BOOL isDot;

    if (!isAddress) {
        isDot = FALSE;
        for (DWORD i = 0; i < dwHostNameLength; ++i) {
            if (lpszHostName[i] == '.') {
                isDot = TRUE;
                break;
            }
        }
    } else {

        //
        // literal addresses have real (v4) or virtual (v6) dots 
        // i.e. we don't want to match <local> below
        //

        isDot = TRUE;
    }

    if (!LockSerializedList(&_List))
        goto quit;

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_BYPASS_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_BYPASS_LIST_ENTRY, _List);

        //
        // do the easy bits first
        //

        if (!((info->_Scheme == tScheme)
        || (info->_Scheme == INTERNET_SCHEME_DEFAULT))) {
            continue;
        }
        if (!((info->_Port == nPort)
        || (info->_Port == INTERNET_INVALID_PORT_NUMBER))) {
            continue;
        }

        //
        // check local semantics
        //

        if (info->_LocalSemantics) {
            if (!isDot) {

                DEBUG_PRINT(PROXY,
                            INFO,
                            ("%q matched by <local>\n",
                            lpszHostName
                            ));

                found = TRUE;

                //
                // <local> is in the bypass list and the name does not contain a
                // dot. It bypasses the proxy
                //

                break;
            } else {

                //
                // the name contains a dot, but it may be matched by another
                // proxy bypass entry
                //

                continue;
            }
        }

        //
        // check for name match. Note that we take no special action if the host
        // name contains wildcard characters
        //

        LPSTR target = info->_Name.StringAddress();

        //
        // NULL target name matches any server name/address
        //

        if (target != NULL) {

            DEBUG_PRINT(PROXY,
                        INFO,
                        ("trying to match %q with %q\n",
                        lpszHostName,
                        target
                        ));

            DWORD i = 0;
            DWORD j = 0;
            DWORD i_back = (DWORD)-1;

            while ((target[i] != '\0') && (j < dwHostNameLength)) {
                if (target[i] == tolower(lpszHostName[j])) {
                    ++i;
                    ++j;
                } else if (target[i] == '*') {
                    while (target[i + 1] == '*') {
                        ++i;
                    }
                    i_back = i;
                    ++i;
                    while ((tolower(lpszHostName[j]) != target[i])
                    && (j < dwHostNameLength)) {
                        ++j;
                    }
                } else if (i_back != (DWORD)-1) {

                    //
                    // '*' is greedy closure. We already saw a '*' but later we
                    // discovered a mismatch. We will go back and try to eat as
                    // many characters as we can till the next match, or we hit
                    // the end of the string
                    //

                    i = i_back;
                } else {

                    //
                    // no match; quit
                    //

                    j = 0;
                    break;
                }

                //
                // if we reached the end of the target, but not the host name
                // AND we already met a '*' then back up
                //

                if ((target[i] == '\0')
                && (j != dwHostNameLength)
                && (i_back != (DWORD)-1)) {
                    i = i_back;
                }
            }

            //
            // if we hit the end of the host name while matching any character,
            // bump the target to the next non-star character
            //

            while (target[i] == '*') {
                ++i;
            }

            //
            // the host name matched if we reached the end of the target and end
            // of the host name
            //

            if (!((target[i] == '\0') && (j == dwHostNameLength))) {
                continue;
            }
        }

        //
        // any path that didn't continue, or has not already broken out has
        // succeeded in finding a match
        //

        DEBUG_PRINT(PROXY,
                    INFO,
                    ("Matched: %q, %q\n",
                    lpszHostName,
                    target
                    ));

        found = TRUE;
        break;
    }

    UnlockSerializedList(&_List);

quit:
    DEBUG_LEAVE(found);

    return found;
}


VOID
PROXY_BYPASS_LIST::GetList(
    OUT LPSTR * lplpszList,
    IN DWORD dwBufferLength,
    IN OUT LPDWORD lpdwRequiredLength
    )

/*++

Routine Description:

    Writes the list of proxy bypass servers to a buffer, and/or returns the
    required buffer length

Arguments:

    lplpszList          - pointer to pointer to buffer where list is written, if
                          sufficient space

    dwBufferLength      - amount of space in *lplpszList

    lpdwRequiredLength  - OUT: cumulative size of data

Return Value:

    None.
--*/

{
    LPSTR lpszList = *lplpszList;
    BOOL firstTime = TRUE;
    BOOL outOfBuffer = FALSE;

    if (!LockSerializedList(&_List))
        return;

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_BYPASS_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_BYPASS_LIST_ENTRY, _List);
        if (!firstTime) {

            //
            // write delimiter if enough space
            //

            if (dwBufferLength >= 1) {
                *lpszList++ = ' ';
                --dwBufferLength;
            }
            ++*lpdwRequiredLength;
        } else {
            firstTime = FALSE;
        }

        //
        // find the length of the current entry & write it to the buffer if
        // enough space
        //

        DWORD length = dwBufferLength;

        info->WriteEntry(lpszList, &length);
        if (dwBufferLength >= length) {

            //
            // we wrote it
            //

            dwBufferLength -= length;
        } else {

            //
            // no buffer left
            //

            dwBufferLength = 0;
            outOfBuffer = TRUE;
        }
        *lpdwRequiredLength += length;
        lpszList += length;
    }

    if (!outOfBuffer) {
        if (dwBufferLength > 0) {
            *lpszList++ = '\0';
            *lplpszList = lpszList;
        }
    }

    //
    // add 1 for the terminating NUL
    //

    ++*lpdwRequiredLength;
    UnlockSerializedList(&_List);
}

//
// PROXY_INFO - methods are defined below
//

VOID 
PROXY_INFO::InitializeProxySettings(
    VOID
    )    

/*++

Routine Description:

    Initalizes Proxy_Info objects

Arguments:

    None.

Return Value:

    None. 

--*/

{
    _ProxyServerList    = NULL;
    _ProxyBypassList    = NULL;
    _fDisableDirect     = FALSE;
    _fModifiedInProcess = FALSE;

    _Lock.Initialize();
    _Error = _Lock.IsInitialized()
                ? ERROR_SUCCESS
                : ERROR_WINHTTP_INTERNAL_ERROR;
}


VOID 
PROXY_INFO::TerminateProxySettings(
    VOID
    )

/*++

Routine Description:

    Cleans up and destroys Proxy_Info objects

Arguments:

    None.

Return Value:

    None. 

--*/

{
    //DEBUG_ENTER((DBG_OBJECTS,
    //             None,
    //             "PROXY_INFO::TerminateProxySettings",
    //             NULL
    //             ));

    Lock(TRUE);
    CleanOutLists();
    Unlock();

    //DEBUG_LEAVE(0);
}




DWORD
PROXY_INFO::SetProxySettings(
    IN LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fModifiedInProcess
    )

/*++

Routine Description:

    Sets the proxy info. Either creates new proxy server and bypass lists, or
    removes them (proxy to direct)

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:

    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fModifiedInProcess  - TRUE, if this object keeps a seperate set of values from those
                            stored in the registry store



Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::SetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fModifiedInProcess
                 ));

    //
    // parameters should already be validated by caller
    //

    BOOL newList;
    LPCTSTR serverList;
    LPCTSTR bypassList;

    DWORD error = ERROR_SUCCESS;

    serverList = NULL;
    bypassList = NULL;
    newList = FALSE;
    _fModifiedInProcess = fModifiedInProcess;
    _dwSettingsVersion  = lpProxySettings->dwCurrentSettingsVersion;

    UPDATE_GLOBAL_PROXY_VERSION();

    if ( lpProxySettings->dwFlags & PROXY_TYPE_PROXY ) 
    {        
        serverList = lpProxySettings->lpszProxy;
        bypassList = lpProxySettings->lpszProxyBypass;

        if (serverList != NULL) {            
            newList = TRUE;
        }
    }

    //
    // about to start changing contents - acquire lock
    //

    Lock(TRUE);

    // remember disable direct flag...
    SetDisableDirect( (lpProxySettings->dwFlags & PROXY_TYPE_DIRECT) ? FALSE : TRUE  );

    //
    // clear out current contents,
    //

    CleanOutLists();

    //
    // Set the Static Proxy Lists
    //
        
    if (newList) 
    {

        INET_ASSERT((serverList != NULL) && (*serverList != 0));

        _ProxyServerList = New PROXY_SERVER_LIST(serverList);
        _ProxyBypassList = New PROXY_BYPASS_LIST(bypassList);

        if ((_ProxyServerList != NULL) && (_ProxyBypassList != NULL)) {
            _Error = _ProxyServerList->GetError();
            if (_Error == ERROR_SUCCESS) {
                _Error = _ProxyBypassList->GetError();
                if (_Error == ERROR_SUCCESS) {

                    //
                    // add all proxy servers to bypass list
                    //

                    _Error = _ProxyServerList->AddToBypassList(_ProxyBypassList);
                    if (_Error != ERROR_SUCCESS) {
                        CleanOutLists();
                    }
                }
            }
        } else {
            _Error = ERROR_NOT_ENOUGH_MEMORY;
            CleanOutLists();
        }
        error = _Error;
    }

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO::GetProxySettings(
    OUT LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fCheckVersion = FALSE
    )

/*++

Routine Description:

    Gets the proxy info. 

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:

    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fCheckVersion       - ignored 


Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - 

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::GetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fCheckVersion
                 ));

    DWORD error = ERROR_SUCCESS;

    if ( fCheckVersion == TRUE )
    {
        INET_ASSERT(FALSE);
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // about to start reading contents - acquire lock
    //

    Lock(FALSE);

    if ( ! IsDisableDirect() ) {
        lpProxySettings->dwFlags |= PROXY_TYPE_DIRECT;
    }

    if ( IsProxySettingsConfigured() ) 
    {   
        lpProxySettings->dwFlags |= PROXY_TYPE_PROXY;

        lpProxySettings->lpszProxy       = _ProxyServerList->CopyString();
        lpProxySettings->lpszProxyBypass = _ProxyBypassList->CopyString();

        if ( lpProxySettings->lpszProxy == NULL || 
             lpProxySettings->lpszProxyBypass == NULL )
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            if ( lpProxySettings->lpszProxy != NULL ) {
                FREE_MEMORY(lpProxySettings->lpszProxy);
                lpProxySettings->lpszProxy = NULL;
            }
            if ( lpProxySettings->lpszProxyBypass != NULL ) {
                FREE_MEMORY(lpProxySettings->lpszProxyBypass);
                lpProxySettings->lpszProxyBypass = NULL;
            }
        }
    }

    INET_ASSERT(lpProxySettings->dwFlags == WINHTTP_ACCESS_TYPE_DEFAULT_PROXY
        || lpProxySettings->dwFlags == WINHTTP_ACCESS_TYPE_NO_PROXY
        || lpProxySettings->dwFlags == WINHTTP_ACCESS_TYPE_NAMED_PROXY);

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO::RefreshProxySettings(
    IN BOOL fForceRefresh
    )
/*++

Routine Description:

    Refreshes the Proxy Information

    This doesn't make sense on PROXY_INFO, nothing done

Arguments:

    fForceRefresh - forces a resync of all settings, turning this on slows things down

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - 

--*/

{
    UNREFERENCED_PARAMETER(fForceRefresh);
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::RefreshProxySettings",
                 "%B",
                 fForceRefresh
                 ));


    DEBUG_LEAVE(ERROR_SUCCESS);
 
    return ERROR_SUCCESS;
}


DWORD
PROXY_INFO::QueryProxySettings(
    IN AUTO_PROXY_ASYNC_MSG **ppQueryForProxyInfo
    )

/*++

Routine Description:

    Determines what proxy type, proxy name, and port the caller should use
    given an Url, its length, a target host, a target port, and output space
    to store the result.

    The result may be a complete string containing a Netscape style string with
    a delimited set of proxies, and access methods.  An example of this may
    look like:
    "PROXY itgproxy:80; PROXY proxy:80; PROXY 192.168.100.2:1080; SOCKS 192.168.100.2; DIRECT"
    This means we must try itgproxy, if this proxy fails we go on to proxy, and on to 192.168.100.2, etc.
    Note that if itgproxy, proxy, and 192.168.100.2 all fail we can try a SOCKS proxy, and if this fails we
    can try a direct connection.

    If there is an external proxy DLL registered and valid, we defer to it to decide
    what proxy to use, and thus ignore internal proxy information.

    Note this function can also be used to retrive mapping of protocol to proxy.  For example,
    if tUrlProtocol == INTERNET_SCHEME_FTP, the result *lptProxyScheme == INTERNET_SCHEME_SOCKS
    which means we should use a socks proxy/firewall for FTP accesss.

Arguments:

    tScheme             - can be 0, meaning match any scheme

    lpszHostName        - can contain wildcards. May be name or IP address

    nPort               - can be 0, meaning match any port

    pfAutoProxy         - TRUE if an auto-proxy is being used.

Return Value:

    BOOL
        TRUE    - an entry on the bypass list matched the criteria

        FALSE   - the host identified by the parameters is not on this bypass
                  list

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::QueryProxySettings",
                 "%#X",
                 ppQueryForProxyInfo
                 ));

    AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo = *ppQueryForProxyInfo;
    BOOL fIsByPassed = FALSE;
    BOOL fProxyConnect = FALSE;
    
    DWORD error = ERROR_SUCCESS;

    Lock(FALSE);

    if (!IsProxySettingsConfigured())  // virtual func, perhaps replace with faster internal?
    {
        fProxyConnect = FALSE;
        goto quit;
    }

    //
    // Ok, if we're here we are NOT using the Auto-Proxy DLL.
    //  1. Determine if we are Bypassed ( and thus prevented from using a proxy )
    //  2. Map the Protocol to a Proxy type.
    //  3. Grab the hostname of the proxy we wish to use.
    //

    if ( pQueryForProxyInfo->_lpszUrlHostName && pQueryForProxyInfo->_dwUrlHostNameLength > 0 )
    {
        fIsByPassed = IsBypassed(
                        pQueryForProxyInfo->_tUrlProtocol,
                        pQueryForProxyInfo->_lpszUrlHostName,
                        pQueryForProxyInfo->_dwUrlHostNameLength,
                        pQueryForProxyInfo->_nUrlPort
                        );

        if ( fIsByPassed )
        {
            goto quit;
        }
    }

    pQueryForProxyInfo->_tProxyScheme = ProxyScheme(pQueryForProxyInfo->_tUrlProtocol);

    if ( pQueryForProxyInfo->_tProxyScheme == INTERNET_SCHEME_UNKNOWN )
    {
       pQueryForProxyInfo->_tProxyScheme = INTERNET_SCHEME_SOCKS;
       pQueryForProxyInfo->_tUrlProtocol = INTERNET_SCHEME_SOCKS;
    }
    if (pQueryForProxyInfo->_bFreeProxyHostName
        && (pQueryForProxyInfo->_lpszProxyHostName != NULL)) {
        FREE_MEMORY(pQueryForProxyInfo->_lpszProxyHostName);
    }

    fProxyConnect = GetProxyHostName(
                        pQueryForProxyInfo->_tUrlProtocol,
                        &(pQueryForProxyInfo->_tProxyScheme),
                        &(pQueryForProxyInfo->_lpszProxyHostName),
                        &(pQueryForProxyInfo->_bFreeProxyHostName),
                        &(pQueryForProxyInfo->_dwProxyHostNameLength),
                        &(pQueryForProxyInfo->_nProxyHostPort)
                        );

quit:

    pQueryForProxyInfo->_dwQueryResult = (DWORD) fProxyConnect;

    //
    // If we've disabled direct connections, then fail
    //  when there is no proxy
    //

    if ( !fProxyConnect && IsDisableDirect() ) {         
        error = ERROR_WINHTTP_CANNOT_CONNECT;
    }

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}



DWORD
PROXY_INFO::GetProxyStringInfo(
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    IMPORTANT PLEASE READ: LEGACY FUNCTION, this does not support all the new
      proxy behaviors, left here for Wininet compat with older programs

    Returns the proxy server and bypass lists in an INTERNET_PROXY_INFO. Called
    by InternetQueryOption(WINHTTP_OPTION_PROXY)

    Assumes: Access to this is serialized while we are getting this info

Arguments:

    lpBuffer            - pointer to buffer where information will be returned

    lpdwBufferLength    - IN: size of lpBuffer in BYTEs
                          OUT: number of BYTEs returned in lpBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the required buffer length
--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_INFO::GetProxyStringInfo",
                "%#x, %#x [%d]",
                lpBuffer,
                lpdwBufferLength,
                *lpdwBufferLength
                ));

    DEBUG_PRINT(PROXY,
                INFO,
                ("Calling Legacy GetProxyStringInfo, NEW CODE SHOULD AVOID THIS CODE PATH\n"
                ));

    DWORD requiredSize = sizeof(WINHTTP_PROXY_INFOA);
    LPSTR lpVariable = (LPSTR)(((WINHTTP_PROXY_INFOA *)lpBuffer) + 1);
    LPSTR lpszProxy;

    Lock(FALSE);

    if (_ProxyServerList != NULL) {
        lpszProxy = lpVariable;
        _ProxyServerList->GetList(&lpVariable,
                                  (*lpdwBufferLength > requiredSize)
                                    ? (*lpdwBufferLength - requiredSize)
                                    : 0,
                                  &requiredSize
                                  );
    } else {
        lpszProxy = NULL;
    }

    LPSTR lpszProxyBypass;

    if (_ProxyBypassList != NULL) {

        DWORD size = requiredSize;

        lpszProxyBypass = lpVariable;
        _ProxyBypassList->GetList(&lpVariable,
                                  (*lpdwBufferLength > requiredSize)
                                    ? (*lpdwBufferLength - requiredSize)
                                    : 0,
                                  &requiredSize
                                  );
        if (requiredSize == size) {
            lpszProxyBypass = NULL;
        }
    } else {
        lpszProxyBypass = NULL;
    }

    DWORD error;

    if (*lpdwBufferLength >= requiredSize) {

        LPINTERNET_PROXY_INFO lpInfo = (LPINTERNET_PROXY_INFO)lpBuffer;

        lpInfo->dwAccessType = (lpszProxy == NULL)
                                    ? WINHTTP_ACCESS_TYPE_NO_PROXY
                                    : WINHTTP_ACCESS_TYPE_NAMED_PROXY;
        lpInfo->lpszProxy = lpszProxy;
        lpInfo->lpszProxyBypass = lpszProxyBypass;
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    *lpdwBufferLength = requiredSize;

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_INFO::RedoSendRequest(
    IN OUT LPDWORD lpdwError,
    IN DWORD dwSecureStatus,
    IN AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo,
    IN CServerInfo *pOriginServer,
    IN CServerInfo *pProxyServer
    )
/*++

Routine Description:

    Determines whether a connection needs to be retried do to a failed proxy.

Arguments:


    lpdwError   - Error code of connection.

    pProxyState - Pointer to proxy_state returned when acquiring the proxy information.


Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Bool,
                 "PROXY_INFO::RedoSendRequest",
                 "%#x [%d, %d], %#x",
                 lpdwError,
                 lpdwError ? *lpdwError : 0,
                 dwSecureStatus,
                 pQueryForProxyInfo
                 ));

    BOOL fReturn = FALSE;
    PROXY_STATE *pProxyState = NULL;

    if ( pQueryForProxyInfo )
    {
        pProxyState = pQueryForProxyInfo->_pProxyState;

        //
        // On success,
        //

        if ( *lpdwError == ERROR_SUCCESS )
        {
            if ( pQueryForProxyInfo->IsCanCacheResult() && 
                 pProxyState &&                  
                 pOriginServer &&
                 pProxyServer )
            {
                
                pOriginServer->SetCachedProxyServerInfo(
                    pProxyServer,                    
                    pQueryForProxyInfo->GetVersion(),
                    pQueryForProxyInfo->IsUseProxy(),
                    pQueryForProxyInfo->_tUrlProtocol,
                    pQueryForProxyInfo->_nUrlPort,
                    pQueryForProxyInfo->_tProxyScheme,
                    pQueryForProxyInfo->_nProxyHostPort
                    );
            }
        }
        else if ( *lpdwError != ERROR_SUCCESS &&
                  *lpdwError != ERROR_WINHTTP_OPERATION_CANCELLED &&
                  (*lpdwError != ERROR_WINHTTP_SECURE_FAILURE ||
                   dwSecureStatus & ~(WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA |
                                      WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID |
                                      WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID |
                                      WINHTTP_CALLBACK_STATUS_FLAG_SECURITY_CHANNEL_ERROR |
                                      WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED |
                                      WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED)) &&
                  *lpdwError != ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED )
        {
            //
            // For backround detection, we need to retry
            //  waiting for the backround results to complete
            //
            // Otherwise, If we have additional proxies, 
            //  we need to retry them as well.
            //

            if ( pQueryForProxyInfo->IsBackroundDetectionPending() )
            {
                *lpdwError = ERROR_SUCCESS;
                fReturn = TRUE;
            }
            else if ( pProxyState &&
                     !pProxyState->IsEmpty() &&
                      pProxyState->IsAnotherProxyAvail() )               
            {
                INTERNET_PORT LastProxyUsedPort; 
                LPSTR lpszLastProxyUsed = pProxyState->GetLastProxyUsed(&LastProxyUsedPort);

                Lock(FALSE);

                if ( ( lpszLastProxyUsed == NULL ) ||
                     _BadProxyList.AddEntry(lpszLastProxyUsed, LastProxyUsedPort) != ERROR_SUCCESS )
                {
                    fReturn = FALSE;                    
                }
                else
                {
                    *lpdwError = ERROR_SUCCESS;
                    fReturn = TRUE;
                }

                Unlock();
            }
        }
    }

    DEBUG_LEAVE(fReturn);

    return fReturn;
}

VOID PROXY_INFO::SetSessionObject(INTERNET_HANDLE_OBJECT * pSessionObject)
{
    INET_ASSERT(pSessionObject->GetHandleType() == TypeInternetHandle);
    _pSessionObject = pSessionObject;
}


VOID
PROXY_INFO::CleanOutLists(
    VOID
    )

/*++

Routine Description:

    Delete proxy server and bypass lists if not empty

    N.B. Exclusive lock MUST be acquired before calling this method

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 None,
                 "PROXY_INFO::CleanOutLists",
                 NULL
                 ));

    if (_ProxyServerList != NULL) {
        delete _ProxyServerList;
        _ProxyServerList = NULL;
    }
    if (_ProxyBypassList != NULL) {
        delete _ProxyBypassList;
        _ProxyBypassList = NULL;
    }

    DEBUG_LEAVE(0);
}

//
// PROXY_INFO_GLOBAL - Global Object thats inherits and expands the basic functionality 
//   of basic PROXY_INFO behavior.  The new functionality includes wrapping Auto-Proxy
///  and Auto-detection routines
//


BOOL
PROXY_INFO::HostBypassesProxy(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR           lpszHostName,
    IN DWORD           cchHostName
    )

/*++

Routine Description:

    Determine if request should bypass proxy for host

Arguments:

    tScheme         -
    lpszHostName    -
    cchHostName     -

Return Value:

    BOOL

--*/

{
    BOOL bReturn = FALSE;
    DWORD dwServiceType;

    // Only do this if it is for a scheme wininet supports.
    if (tScheme == INTERNET_SCHEME_HTTP ||
        tScheme == INTERNET_SCHEME_HTTPS ||
        tScheme == INTERNET_SCHEME_DEFAULT)
    {
        dwServiceType = INTERNET_SERVICE_HTTP;
    }
    else
    {
        return bReturn;
    }

    // LOCK
    Lock(FALSE);

    bReturn = IsHostInBypassList(lpszHostName, cchHostName);

    Unlock();
    return bReturn;
}


VOID
PROXY_INFO_GLOBAL::TerminateProxySettings(
    VOID
    )

/*++

Routine Description:

    Destroy PROXY_INFO_GLOBAL object

Arguments:

    None.

Return Value:

    None.

--*/

{
    PROXY_INFO::TerminateProxySettings();
}

DWORD
PROXY_INFO_GLOBAL::SetProxySettings(
    IN LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fModifiedInProcess
    )

/*++

Routine Description:

    Sets the proxy info.  Mainly handles Auto-Config, its decendent will handle static stuff

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:
    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fModifiedInProcess  - TRUE if this object is not from the registry, but 
                           a modifed setting for this process (that overrides reg values)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::SetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fModifiedInProcess
                 ));

    DWORD error = ERROR_SUCCESS;

    //
    // about to start changing contents - acquire lock
    //

    Lock(TRUE);

    //
    // Once we're set to Modified, we're modified for the lifetime of the
    //   the process, and thus we no longer accept Registry settings
    //

    if ( IsModifiedInProcess() && 
         !fModifiedInProcess )
    {
        error = ERROR_SUCCESS;
        goto quit;
    }

    if ( _lpszConnectionName != NULL ) {
        FREE_MEMORY(_lpszConnectionName);
    }

    _lpszConnectionName = lpProxySettings->lpszConnectionName ? 
                            NewString(lpProxySettings->lpszConnectionName) : 
                            NULL;

    _dwProxyFlags = lpProxySettings->dwFlags;

    //
    // Set the Static Proxy Lists
    //
        
    error = PROXY_INFO::SetProxySettings(lpProxySettings, fModifiedInProcess);

quit:

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO_GLOBAL::GetProxySettings(
    IN LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fCheckVersion = FALSE
    )

/*++

Routine Description:

    Gather the proxy info.  Mainly handles Auto-Config, its decendent will handle static stuff

Arguments:
    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fCheckVersion       - 

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::GetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fCheckVersion
                 ));

    //
    // about to start reading contents - acquire lock
    //

    Lock(FALSE);

    DWORD error = ERROR_SUCCESS;

    lpProxySettings->lpszConnectionName =
                        _lpszConnectionName ? 
                            NewString(_lpszConnectionName) : 
                            NULL;

    lpProxySettings->dwFlags = _dwProxyFlags;


    //
    // Get the Static Proxy Lists
    //
        
    error = PROXY_INFO::GetProxySettings(lpProxySettings, fCheckVersion);

//quit:

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO_GLOBAL::RefreshProxySettings(
    IN BOOL fForceRefresh
    )

/*++

Routine Description:

    Force a refresh of automatic settings, such as auto-proxy, auto-detect

Arguments:
    
    fForceRefresh - Forces a hard refresh

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    UNREFERENCED_PARAMETER(fForceRefresh);
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::RefreshProxySettings",
                 "%B",
                 fForceRefresh
                 ));

    DWORD error = ERROR_SUCCESS;

    Lock(FALSE);

    //
    // Force reload of registry settings and download of auto-proxy file from server
    //

    if ( IsRefreshDisabled())
    {
        QueueRefresh();
        goto quit;
    }


    //
    // Get the Static Proxy Lists
    //
        
    //error = PROXY_INFO::RefreshProxySettings(fForceRefresh);

quit:

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}

VOID
PROXY_INFO_GLOBAL::ReleaseQueuedRefresh(
    VOID
    )
/*++

Routine Description:

    Force a refresh of automatic settings, such as auto-proxy, auto-detect,
     When InternetOpen is called, allowing async threads.

Arguments:
    
    None.

Return Value:

    None.

--*/

{
    DWORD error = ERROR_SUCCESS;

    Lock(FALSE);

    SetRefreshDisabled(FALSE);

    if ( _fQueuedRefresh ) 
    {
        error = RefreshProxySettings(
                    FALSE
                    );

    }

    _fQueuedRefresh = FALSE;

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();
}




DWORD
PROXY_INFO_GLOBAL::QueryProxySettings(
    IN AUTO_PROXY_ASYNC_MSG **ppQueryForProxyInfo
    )

/*++

Routine Description:

    Aquries Proxy Information.

    Note: if ppProxyState returns a non-NULL pointer than the Proxy
    strings can be assumed to be allocated pointers to strings.  Freeing
    the ppProxyState object will result in the pointers being freed as well.
    Otherwise the pointers will be to global string data that will not be
    freed unexpectedly.



Arguments:

    tUrlProtocol -  Scheme type, protocol that is being used.

    lpszUrl      -  Url being accessed.

    dwUrlLength  -  size of Url.

    lpszUrlHostName - Host name of site to connect to.

    dwUrlHostNameLength - Host name length.

    nUrlPort      - Port of server to connect to.

    lptProxyScheme - On output contains the correct proxy server type to use.
                        ex: if a SOCKS proxy is to be used to handle the FTP protocol,
                            this will be a INTERNET_SCHEME_SOCKS.

    lplpszProxyHostName - Pointer to allocated memory containing the address of
                           the proxy host name.



Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::QueryProxySettings",
                 "%#x",
                 ppQueryForProxyInfo
                 ));

    INET_ASSERT(ppQueryForProxyInfo);

    DWORD error = ERROR_SUCCESS;
    BOOL fNeedsGetNextProxy = FALSE;
    BOOL fLocked = FALSE;
    AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo = *ppQueryForProxyInfo;

    //
    // If we're dealing with a list of Proxies, we may have already tried one
    //  proxy and failed.  So go to the next proxy in the list
    //  and see if another one is availble to try.
    //

    if ( pQueryForProxyInfo->IsProxyEnumeration() )
    {
        fNeedsGetNextProxy = TRUE;
        goto quit;
    }

    if ( pQueryForProxyInfo->IsQueryOnCallback() &&
         ! pQueryForProxyInfo->IsAvoidAsyncCall())
    {
        goto quit;
    }

    Lock(FALSE);
    fLocked = TRUE;

    //
    // Use normal Proxy infomation stored in the registry
    //

    error = PROXY_INFO::QueryProxySettings(&pQueryForProxyInfo);

    if ( error != ERROR_SUCCESS)
    {
        goto quit;
    }

quit:

    if ( error == ERROR_SUCCESS &&
          ( fNeedsGetNextProxy ||
            pQueryForProxyInfo->IsProxyEnumeration())  )
    {
        error = pQueryForProxyInfo->GetNextProxy(_BadProxyList);
    }

    if ( fLocked )
    {
        Unlock();
    }

//fastquit:

    DEBUG_LEAVE(error);

    return error;
}


//
// PROXY_STATE - an abstraction object used to provice simple string enumeration
//   given a list of proxies that need to be tested 
// 



BOOL
PROXY_STATE::GetNextProxy(
    IN  INTERNET_SCHEME   tUrlScheme,
    IN  BAD_PROXY_LIST &  BadProxyList,
    OUT LPINTERNET_SCHEME lptProxyScheme,
    OUT LPSTR * lplpszProxyHostName,
    OUT LPBOOL lpbFreeProxyHostName,
    OUT LPDWORD lpdwProxyHostNameLength,
    OUT LPINTERNET_PORT lpProxyHostPort
    )

/*++

Routine Description:

    Parses the current Proxy State information to acquire the
        proxy name, port, type to use.


Arguments:

    tUrlScheme   -  Scheme type, protocol that is being used.

    BadProxyList -  Reference to array of bad proxies that we can add/remove/check
                        from.

    lptProxyScheme - On output contains the correct proxy server type to use.
                        ex: if a SOCKS proxy is to be used to handle the FTP protocol,
                            this will be a INTERNET_SCHEME_SOCKS.

    lplpszProxyHostName - Pointer to allocated memory containing the address of
                           the proxy host name.

    lpbFreeProxyHostName - TRUE if *lplpszProxyHostName was allocated

    lpdwProxyHostNameLength - length of lplpszProxyHostName.

    lpProxyHostPort    - Host Port of Proxy.



Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    LPSTR lpszDelimiter = NULL;
    BOOL  fReturn       = FALSE;
    LPSTR lpszPortDelim = NULL;
    LPSTR lpszPort      = NULL;


    if ( !_fIsMultiProxyList )
    {
        *lptProxyScheme = _tProxyScheme;
        *lplpszProxyHostName = _lpszAutoProxyList;
        *lpbFreeProxyHostName = FALSE;
        *lpdwProxyHostNameLength = _dwcbAutoProxyList;
        *lpProxyHostPort  = _proxyHostPort;
    }

    _fIsAnotherProxyAvail = FALSE;

    while ( *_lpszOffset != '\0' )
    {
        LPSTR lpszNewOffset ;

        //
        // Remove the delimiter so we can see the next token.
        //  ex: PROXY foo:80; DIRECT
        //  we would find DIRECT first with strstr, if we didn't
        //  delimit first.
        //

        lpszDelimiter = strchr(_lpszOffset, ';' );

        if ( lpszDelimiter == NULL )
        {
            lpszDelimiter = strchr(_lpszOffset, ',' );
        }

        if ( lpszDelimiter )
        {
            *lpszDelimiter = '\0';
        }

        lpszNewOffset=
            strstr(_lpszOffset, "DIRECT");

        if ( lpszNewOffset )
        {
            lpszNewOffset += sizeof("DIRECT");
            _lpszOffset    = lpszNewOffset;

            //
            // FALSE means direct.
            //

            fReturn = FALSE;
            goto quit;
        }

        //
        // Its not direct, try PROXY or SOCKS.
        //

        lpszNewOffset =
            strstr(_lpszOffset, "PROXY");


        if ( lpszNewOffset)
        {
            lpszNewOffset += sizeof("PROXY");
            *lpProxyHostPort = INTERNET_DEFAULT_HTTP_PORT;

            if ( tUrlScheme == INTERNET_SCHEME_HTTPS )
            {
                *lptProxyScheme = INTERNET_SCHEME_HTTPS;
            }
            else
            {
                *lptProxyScheme = INTERNET_SCHEME_HTTP;

            }
        }
        else
        {
            lpszNewOffset =
                strstr(_lpszOffset, "SOCKS");

            if ( lpszNewOffset )
            {
                lpszNewOffset   += sizeof("SOCKS");
                *lptProxyScheme  = INTERNET_SCHEME_SOCKS;
                *lpProxyHostPort = INTERNET_DEFAULT_SOCKS_PORT;
            }
        }

        //
        // Now do the generic common things for SOCKS, or PROXY
        // entries, ie: get port, hostname, and hostname size.
        //

        if ( lpszNewOffset )
        {
            _lpszOffset    = lpszNewOffset;

            SKIPWS(_lpszOffset);

            *lplpszProxyHostName = _lpszOffset;
            *lpbFreeProxyHostName = FALSE;

            lpszPortDelim = strchr(_lpszOffset, ':');

            if ( lpszPortDelim )
            {
                *lpszPortDelim = '\0';
                lpszPort  = lpszPortDelim+1;

                *lpProxyHostPort = (INTERNET_PORT)
                    atoi(lpszPort);
            }

            *lpdwProxyHostNameLength = lstrlen(_lpszOffset);

            if (BadProxyList.IsBadProxyName(*lplpszProxyHostName, *lpProxyHostPort))
            {
                if ( lpszDelimiter )
                {
                    _lpszOffset = (lpszDelimiter+1);
                }
                else
                {
                    _lpszOffset = _lpszAutoProxyList + _dwcbAutoProxyList;
                }

                continue;
            }

            fReturn = TRUE;
        }

        break;
    }

quit:

    //if ( lpszPortDelim )
    //{
    //    *lpszPortDelim = ':';
    //}

    if ( lpszDelimiter )
    {
        *lpszDelimiter = ';';

        _lpszOffset = (lpszDelimiter+1);
    }
    else
    {
        _lpszOffset = _lpszAutoProxyList + _dwcbAutoProxyList;
    }

    if ( fReturn )
    {
        _lpszLastProxyUsed = *lplpszProxyHostName;
        _LastProxyUsedPort = *lpProxyHostPort;

        //
        // If theres another possible proxy in this list,
        //   then we'll need to remember that
        //

        if ( _lpszOffset &&
             *_lpszOffset &&
                (strstr(_lpszOffset, "PROXY") ||
                 strstr(_lpszOffset, "DIRECT") ||  
                 strstr(_lpszOffset, "SOCKS"))
            )
        {
            _fIsAnotherProxyAvail = TRUE;
        }
    }

    return fReturn;
}



#ifndef WININET_SERVER_CORE

PRIVATE
LPSTR
GetRegistryProxyParameter(
    IN LPSTR lpszParameterName
    )

/*++

Routine Description:

    Reads a string from the registry into a buffer, then shrinks the buffer

Arguments:

    lpszParameterName   - name of string to retrieve

Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    LPSTR buffer = NULL;
    DWORD length = PROXY_REGISTRY_STRING_LENGTH;
    BOOL done = FALSE;

    do {
        buffer = (LPSTR)ResizeBuffer(buffer, length, FALSE);
        if (done || (buffer == NULL)) {
            break;
        }

        DWORD error;

        error = InternetReadRegistryString(lpszParameterName, buffer, &length);
        length = (error == ERROR_SUCCESS) ? ((length == 0) ? 0 : (length + 1)) : 0;
        done = TRUE;
    } while (TRUE);

    return buffer;
}
#endif //!WININET_SERVER_CORE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\http\httpp.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    httpp.h

Abstract:

    Private master include file for the HTTP API project.

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

--*/

//
//  Local include files.
//

#include "proc.h"
#include "headers.h"

extern
BOOL
HttpDateToSystemTime(
    IN LPSTR lpszHttpDate,
    OUT LPSYSTEMTIME lpSystemTime
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\http\hdrbuf.cxx ===
#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

#include <wininetp.h>

#define DATE_AND_TIME_STRING_BUFFER_LENGTH  128

PRIVATE
BOOL
FMatchList(
    LPSTR *lplpList,
    DWORD cListLen,
    HEADER_STRING *lpHeader,
    LPSTR    lpBase
    )
{
    DWORD i;
    for (i=0; i < cListLen; ++i) {
       if (!lpHeader->Strnicmp(lpBase, lplpList[i], strlen(lplpList[i]))) {
          return (TRUE);
       }
    }
    return(FALSE);
}


DWORD
FASTCALL
CalculateHashNoCase(
    IN LPCSTR lpszString,
    IN DWORD dwStringLength
    )

/*++

Routine Description:

    Calculate a case-insensitive hash number given a string. Assumes input is
    7-bit ASCII

Arguments:

    lpszString      - string to hash

    dwStringLength  - length of lpszString, or -1 if we need to calculate

Return Value:

    DWORD - a generated hash value

--*/

{
    DWORD dwHash = HEADER_HASH_SEED;

    while (dwStringLength != 0) {
        CHAR ch = *lpszString;

        if ((ch >= 'A') && (ch <= 'Z')) {
            ch = MAKE_LOWER(ch);
        }
        dwHash += (DWORD)(dwHash << 5) + ch; /*+ *pszName++;*/

        ++lpszString;
        --dwStringLength;
    }
    return dwHash;
}

//
// methods
//



DWORD
HTTP_HEADERS::AllocateHeaders(
    IN DWORD dwNumberOfHeaders
    )

/*++

Routine Description:

    Allocates or grows the array of header pointers (HEADER_STRING objects)

Arguments:

    dwNumberOfHeaders   - number of additional header slots to create

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AllocateHeaders",
                 "%d",
                 dwNumberOfHeaders
                 ));

    PERF_ENTER(AllocateHeaders);

    //
    // we really need to be able to realloc an array of HEADER_STRING objects
    // (see below)
    //

    DWORD error;
    DWORD slots = _TotalSlots;


    if (dwNumberOfHeaders == 0)
    {
        INET_ASSERT(0);  //  AllocateHeaders() asked to allocate 0 headers.. a mistake in the calling code.
        error = ERROR_SUCCESS;
        goto quit;
    }

    if (_TotalSlots + dwNumberOfHeaders > (INVALID_HEADER_INDEX-1))
    {
        //  We may end up allocating fewer than we were asked for, but we'll always allocate at least one.
        dwNumberOfHeaders = (INVALID_HEADER_INDEX-1)-_TotalSlots;
    }

    if ( dwNumberOfHeaders == 0)
    {
        error = ERROR_WINHTTP_HEADER_COUNT_EXCEEDED;
        goto quit;
    }
    _lpHeaders = (HEADER_STRING *)ResizeBuffer((HLOCAL)_lpHeaders,
                                               (_TotalSlots + dwNumberOfHeaders)
                                                    * sizeof(HEADER_STRING),
                                               FALSE // not moveable
                                               );
    if (_lpHeaders != NULL) {
        _NextOpenSlot = _TotalSlots;
        _TotalSlots += dwNumberOfHeaders;
        _FreeSlots += dwNumberOfHeaders;

        //
        // this is slightly ugly, but it seems there's no easy C++ way to
        // do this - we need to be able to realloc() an array of objects
        // created by new(), but so far, it can't be done
        //

        for (; slots < _TotalSlots; ++slots) {
            _lpHeaders[slots].Clear();
        }
        error = ERROR_SUCCESS;
    } else {

        INET_ASSERT(FALSE);
        _NextOpenSlot = 0;
        _TotalSlots = 0;
        _FreeSlots = 0;
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

quit:

    INET_ASSERT(_FreeSlots <= _TotalSlots);

    PERF_LEAVE(AllocateHeaders);

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_HEADERS::FreeHeaders(
    VOID
    )

/*++

Routine Description:

    Free the headers strings and the headers array

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "FreeHeaders",
                 NULL
                 ));

    if (!LockHeaders())
    {
        goto quit;
    }

    //
    // free up each individual entry (free string buffers)
    //

    for (DWORD i = 0; i < _TotalSlots; ++i) {
        _lpHeaders[i] = (LPSTR)NULL;
    }

    //
    // followed by the array itself
    //

    if (_lpHeaders) {
        _lpHeaders = (HEADER_STRING *)FREE_MEMORY((HLOCAL)_lpHeaders);

        INET_ASSERT(_lpHeaders == NULL);
    }

    _TotalSlots = 0;
    _FreeSlots = 0;
    _HeadersLength = 0;
    _lpszVerb = NULL;
    _dwVerbLength = 0;
    _lpszObjectName = NULL;
    _dwObjectNameLength = 0;
    _lpszVersion = NULL;
    _dwVersionLength = 0;

    UnlockHeaders();

quit:
    DEBUG_LEAVE(0);
}


DWORD
HTTP_HEADERS::CopyHeaders(
    IN OUT LPSTR * lpBuffer,
    IN LPSTR lpszObjectName,
    IN DWORD dwObjectNameLength
    )

/*++

Routine Description:

    Copy the headers to the caller's buffer. Each header is terminated by CR-LF.
    This method is called to convert the request headers list to a buffer that
    we can send to the server

    N.B. This function MUST be called with the headers already locked

Arguments:

    lpBuffer            - pointer to pointer to buffer where headers are
                          written. We update the pointer

    lpszObjectName      - optional object name

    dwObjectNameLength  - optional object name length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory while trying to synchronize src data access

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "CopyHeaders",
                 "%#x, %#x [%q], %d",
                 lpBuffer,
                 lpszObjectName,
                 lpszObjectName,
                 dwObjectNameLength
                 ));

    DWORD dwError = ERROR_SUCCESS;
    if (!LockHeaders())
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    DWORD i = 0;

    if (lpszObjectName != NULL) {
        memcpy(*lpBuffer, _lpszVerb, _dwVerbLength);
        *lpBuffer += _dwVerbLength;
        *(*lpBuffer)++ = ' ';
        memcpy(*lpBuffer, lpszObjectName, dwObjectNameLength);
        *lpBuffer += dwObjectNameLength;
        *(*lpBuffer)++ = ' ';
        memcpy(*lpBuffer, _lpszVersion, _dwVersionLength);
        *lpBuffer += _dwVersionLength;
        *(*lpBuffer)++ = '\r';
        *(*lpBuffer)++ = '\n';
        i = 1;
    }
    for (; i < _TotalSlots; ++i) {
        if (_lpHeaders[i].HaveString()) {
            _lpHeaders[i].CopyTo(*lpBuffer);
            *lpBuffer += _lpHeaders[i].StringLength();
            *(*lpBuffer)++ = '\r';
            *(*lpBuffer)++ = '\n';
        }
    }

    UnlockHeaders();

quit:
    DEBUG_LEAVE(dwError);

    return dwError;
}


HEADER_STRING *
FASTCALL
HTTP_HEADERS::FindFreeSlot(
    DWORD* piSlot
    )

/*++

Routine Description:

    Finds the next free slot in the headers list, or adds some new slots

    N.B. This function MUST be called with the headers already locked

Arguments:

    piSlot: returns index of slot found

Return Value:

    HEADER_STRING *  - pointer to next free slot

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Pointer,
                 "FindFreeSlot",
                 NULL
                 ));

    PERF_ENTER(FindFreeSlot);

    DWORD i;
    DWORD error;
    HEADER_STRING * header = NULL;

    //
    // if there are no free slots, allocate some more
    //

    if (_FreeSlots == 0) {
        i = _TotalSlots;
        error = AllocateHeaders(HEADERS_INCREMENT);
    } else {
        i = 0;
        error = ERROR_SUCCESS;
        if (!_lpHeaders[_NextOpenSlot].HaveString())
        {
            --_FreeSlots;
            header = &_lpHeaders[_NextOpenSlot];
            *piSlot = _NextOpenSlot;
            _NextOpenSlot = (_NextOpenSlot == (_TotalSlots-1)) ? (_TotalSlots-1) : _NextOpenSlot++;
            goto quit;
        }
    }
    if (error == ERROR_SUCCESS) {
        for (; i < _TotalSlots; ++i) {
            if (!_lpHeaders[i].HaveString()) {
                --_FreeSlots;
                header = &_lpHeaders[i];
                *piSlot = i;
                _NextOpenSlot = (i == (_TotalSlots-1)) ? (_TotalSlots-1) : (i+1);
                break;
            }
        }
        if (header == NULL) {

            //
            // we would have just allocated extra slots if we didn't have
            // any, so we shouldn't be here
            //

            INET_ASSERT(FALSE);

            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
    }

quit:
    _Error = error;

    PERF_LEAVE(FindFreeSlot);

    DEBUG_LEAVE(header);

    return header;
}


VOID
HTTP_HEADERS::ShrinkHeader(
    IN LPBYTE pbBase,
    IN DWORD  iSlot,
    IN DWORD  dwOldQueryIndex,
    IN DWORD  dwNewQueryIndex,
    IN DWORD  cbNewSize
    )

/*++

Routine Description:

    Low level function that does a surgical replace of one header with another.
    This code updates internal structures such as bKnownHeaders and the stored
    hash value for the new Header.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    None.

--*/

{
    HEADER_STRING* pHeader = _lpHeaders + iSlot;

    UNREFERENCED_PARAMETER(pbBase);

    INET_ASSERT(_bKnownHeaders[dwOldQueryIndex] == (BYTE) iSlot ||
                dwNewQueryIndex == dwOldQueryIndex );

    //
    // Swap in the new header.  Update Length, Hash, and its cached position
    //  in the known header array.
    //

    _bKnownHeaders[dwOldQueryIndex] = INVALID_HEADER_INDEX;
    _bKnownHeaders[dwNewQueryIndex] = (BYTE) iSlot;

    pHeader->SetLength (cbNewSize);
    pHeader->SetHash (GlobalKnownHeaders[dwNewQueryIndex].HashVal);
}

DWORD
inline
HTTP_HEADERS::SlowFind(
    IN LPSTR lpBase,
    IN LPCSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN DWORD dwIndex,
    IN DWORD dwHash,
    OUT DWORD *lpdwQueryIndex,
    OUT BYTE  **lplpbPrevIndex
    )

/*++

Routine Description:

    Finds the next occurance of lpszHeaderName in the header array, uses
    a cached table of well known headers to accerlate the search if the
    string is a known header.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    DWORD  - index to Slot in array, or INVALID_HEADER_SLOT if not found

--*/

{

    //
    // Now see if this is a known header passed in as a string,
    //   If it is, we save ourselves the loop, and just map it right in to a known header
    //

    DWORD dwKnownQueryIndex = GlobalHeaderHashs[(dwHash % MAX_HEADER_HASH_SIZE)];

    *lpdwQueryIndex = INVALID_HEADER_SLOT;

    if ( dwKnownQueryIndex != 0 )
    {
        dwKnownQueryIndex--;

        if ( ((int)dwHeaderNameLength >= GlobalKnownHeaders[dwKnownQueryIndex].Length) &&
             strnicmp(lpszHeaderName,
                      GlobalKnownHeaders[dwKnownQueryIndex].Text,
                      GlobalKnownHeaders[dwKnownQueryIndex].Length) == 0)
        {
            *lpdwQueryIndex = dwKnownQueryIndex;

            INET_ASSERT((int)(dwHeaderNameLength) == GlobalKnownHeaders[dwKnownQueryIndex].Length);

            if ( lplpbPrevIndex )
            {
                return FastNukeFind(
                        dwKnownQueryIndex,
                        dwIndex,
                        lplpbPrevIndex
                        );
            }
            else
            {
                return FastFind(
                        dwKnownQueryIndex,
                        dwIndex
                        );
            }
        }
    }

    //
    // Otherwise we painfully enumerate the whole array of headers
    //

    for (DWORD i = 0; i < _TotalSlots; ++i)
    {
        HEADER_STRING * pString;

        pString = &_lpHeaders[i];

        if (!pString->HaveString()) {
            continue;
        }

        if (pString->HashStrnicmp(lpBase,
                                  lpszHeaderName,
                                  dwHeaderNameLength,
                                  dwHash) == 0)
        {

            //
            // if we haven't reached the required index yet, continue
            //

            if (dwIndex != 0) {
                --dwIndex;
                continue;
            }

            return i; // found index/slot
        }
    }

    return INVALID_HEADER_SLOT; // not found
}


DWORD
inline
HTTP_HEADERS::FastFind(
    IN DWORD  dwQueryIndex,
    IN DWORD  dwIndex
    )
/*++

Routine Description:

    Finds the next occurance of a known header string in the lpHeaders array.
    Since this is a known string, an index is used to refer to it.
    A cached table of well known headers is used to accerlate the search.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    DWORD  - index to Slot in array, or INVALID_HEADER_SLOT if not found

--*/

{
    DWORD dwSlot;

    dwSlot = _bKnownHeaders[dwQueryIndex];

    while ( (dwIndex > 0) && (dwSlot < INVALID_HEADER_INDEX) )
    {
        HEADER_STRING * pString;

        pString = &_lpHeaders[dwSlot];
        dwSlot  = pString->GetNextKnownIndex();

        dwIndex--;
    }

    if ( dwSlot >= INVALID_HEADER_INDEX)
    {
        return INVALID_HEADER_SLOT;
    }

    return dwSlot; // found it.
}


DWORD
inline
HTTP_HEADERS::FastNukeFind(
    IN DWORD  dwQueryIndex,
    IN DWORD  dwIndex,
    OUT BYTE **lplpbPrevIndex
    )
/*++

Routine Description:

    Finds the next occurance of a known header string in the lpHeaders array.
    Since this is a known string, an index is used to refer to it.
    A cached table of well known headers is used to accerlate the search.
    Also provides a ptr to ptr to the slot which directs us to the one found.
    This is needed for deletion purposes.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    DWORD  - index to Slot in array, or INVALID_HEADER_SLOT if not found

--*/

{
    BYTE *lpbSlot;

    *lplpbPrevIndex = lpbSlot = &_bKnownHeaders[dwQueryIndex];
    dwIndex++;

    while ( (dwIndex > 0) && (*lpbSlot < INVALID_HEADER_INDEX) )
    {
        HEADER_STRING * pString;

        pString = &_lpHeaders[*lpbSlot];
        *lplpbPrevIndex = lpbSlot;
        lpbSlot  = pString->GetNextKnownIndexPtr();

        dwIndex--;
    }

    if ( **lplpbPrevIndex >= INVALID_HEADER_INDEX ||
         dwIndex > 0 )
    {
        return INVALID_HEADER_SLOT;
    }

    return ((DWORD) **lplpbPrevIndex); // found it.
}

VOID
HTTP_HEADERS::RemoveAllByIndex(
    IN DWORD dwQueryIndex
    )
/*++

Routine Description:

    Removes all Known Headers found in the header array.

    N.B. This function MUST be called with the headers already locked

Arguments:

    dwQueryIndex - index to known header string to remove from array.

Return Value:

    None.

--*/


{
    BYTE bSlot;
    BYTE bPrevSlot;

    bSlot = bPrevSlot  = _bKnownHeaders[dwQueryIndex];

    while (bSlot < INVALID_HEADER_INDEX)
    {
        HEADER_STRING * pString;

        bPrevSlot   = bSlot;
        pString     = &_lpHeaders[bSlot];
        bSlot       = (BYTE) pString->GetNextKnownIndex();

        RemoveHeader(bPrevSlot, dwQueryIndex, &_bKnownHeaders[dwQueryIndex]);
    }

    _bKnownHeaders[dwQueryIndex] = INVALID_HEADER_INDEX;

    return;
}


BOOL
inline
HTTP_HEADERS::HeaderMatch(
    IN DWORD dwHash,
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    OUT DWORD *lpdwQueryIndex
    )

/*++

Routine Description:

    Looks up a Known HTTP header string using its Hash value and
     string contained the name of the header.

Arguments:

    dwHash              - Hash value of header name string

    lpszHeaderName      - name of header we are matching

    dwHeaderNameLength  - length of header name string

    lpdwQueryIndex      - If found, this is the HTTP_QUERY_* based index to the header.

Return Value:

    BOOL
        Success - The string and hash matched againsted a known header

        Failure - There is no known header for that hash & string pair.

--*/

{
    *lpdwQueryIndex = GlobalHeaderHashs[(dwHash % MAX_HEADER_HASH_SIZE)];

    if ( *lpdwQueryIndex != 0 )
    {
        (*lpdwQueryIndex)--;

        if ( ((int)dwHeaderNameLength == GlobalKnownHeaders[*lpdwQueryIndex].Length) &&
             strnicmp(lpszHeaderName,
                      GlobalKnownHeaders[*lpdwQueryIndex].Text,
                      GlobalKnownHeaders[*lpdwQueryIndex].Length) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}


BYTE
inline
HTTP_HEADERS::FastAdd(
    IN DWORD  dwQueryIndex,
    IN DWORD  dwSlot
    )
/*++

Routine Description:

    Rapidly adds a known string to the header array, this function
     is used to matain coherency of the _bKnownHeaders which
     contained indexed offsets into the header array for known headers.

    Note that this function is used instead of latter listed below
     in order to maintain proper order in headers received.

    N.B. This function MUST be called with the headers already locked

Arguments:

    dwQueryIndex - index to known header string to remove from array.

    dwSlot - Slot in which this header is being added.

Return Value:

    None.

--*/


{
    BYTE *lpbSlot;

    lpbSlot = &_bKnownHeaders[dwQueryIndex];

    while ( (*lpbSlot < INVALID_HEADER_INDEX) )
    {
        HEADER_STRING * pString;

        pString  = &_lpHeaders[*lpbSlot];
        lpbSlot  = pString->GetNextKnownIndexPtr();
    }

    INET_ASSERT(*lpbSlot == INVALID_HEADER_INDEX);

    *lpbSlot = (BYTE) dwSlot;
    return INVALID_HEADER_INDEX;
}


//BYTE
//inline
//HTTP_HEADERS::FastAdd(
//    IN DWORD  dwQueryIndex,
//    IN DWORD  dwSlot
//    )
//{
//    BYTE bOldSlot;
//
//    bOldSlot = _bKnownHeaders[dwQueryIndex];
//    _bKnownHeaders[dwQueryIndex] = (BYTE) dwSlot;
//
//    return bOldSlot;
//}




DWORD
HTTP_HEADERS::AddHeader(
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Adds a single header to the array of headers, given the header name and
    value. Called via HttpOpenRequest()

Arguments:

    lpszHeaderName      - pointer to name of header to add, e.g. "Accept:"

    dwHeaderNameLength  - length of the header name

    lpszHeaderValue     - pointer to value of header to add, e.g. "text/html"

    dwHeaderValueLength - length of the header value

    dwIndex             - if coalescing headers, index of header to update

    dwFlags             - flags controlling function:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            CLEAN_HEADER
                                - header is supplied by user, so we must ensure
                                  it has correct format

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory allocating string

                  ERROR_INVALID_PARAMETER
                    The header value was bad

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AddHeader",
                 "%.*q, %d, %.*q, %d, %d, %#x",
                 min(dwHeaderNameLength + 1, 80),
                 lpszHeaderName,
                 dwHeaderNameLength,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(AddHeader);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;

    if (!LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    INET_ASSERT(lpszHeaderName != NULL);
    INET_ASSERT(*lpszHeaderName != '\0');
    INET_ASSERT(dwHeaderNameLength != 0);
    INET_ASSERT(lpszHeaderValue != NULL);
    //INET_ASSERT(*lpszHeaderValue != '\0');  A header with no value is allowed
    //INET_ASSERT(dwHeaderValueLength != 0);  A header with no value is allowed
    INET_ASSERT(_FreeSlots <= _TotalSlots);

    //
    // we may have been handed a header with a trailing colon. We don't care
    // for such nasty imagery
    //

    if (lpszHeaderName[dwHeaderNameLength - 1] == ':') {
        --dwHeaderNameLength;
    }

    DWORD dwQueryIndex;
    DWORD dwHash = CalculateHashNoCase(lpszHeaderName, dwHeaderNameLength);

    //
    // if we are coalescing headers then find a header with the same name
    //

    if ((dwFlags & COALESCE_HEADER_WITH_COMMA) ||
        (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) )
    {
        DWORD dwSlot;

        dwSlot = SlowFind(
                    NULL,
                    lpszHeaderName,
                    dwHeaderNameLength,
                    dwIndex,
                    dwHash,
                    &dwQueryIndex,
                    NULL
                    );

        if (dwSlot != ((DWORD) -1))
        {
            if (dwHeaderValueLength > 0) // don't bother appending if empty value
            {
                HEADER_STRING * pString;

                pString = &_lpHeaders[dwSlot];

                //
                // found what we are looking for. Coalesce it
                //

                pString->ResizeString((sizeof("; ")-1) + dwHeaderValueLength); // save us from multiple reallocs

                pString->Strncat(
                                 (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) ?
                                     "; " :
                                     ", ",
                                  2);

                pString->Strncat(lpszHeaderValue, dwHeaderValueLength);
                _HeadersLength += 2 + dwHeaderValueLength;
            }
            error = ERROR_SUCCESS;

        }
    }
    else
    {

        //
        // Check to verify that the header we're adding is a known header,
        //   If its a known header we use dwQueryIndex to update the known header array
        //   otherwise, IF ITS NOT, we make sure to set dwQueryIndex to INVALID_...
        //

        if (! HeaderMatch(dwHash, lpszHeaderName, dwHeaderNameLength, &dwQueryIndex) )
        {
            dwQueryIndex = INVALID_HEADER_SLOT;
        }

        /*
        // Perhaps this more efficent ???
        dwQueryIndex = GlobalHeaderHashs[(dwHash % MAX_HEADER_HASH_SIZE)];

        if ( dwQueryIndex != 0 )
        {
            dwQueryIndex--;

            if ( ((int)dwHeaderNameLength < GlobalKnownHeaders[dwQueryIndex].Length) ||
                 strnicmp(lpszHeaderName,
                          GlobalKnownHeaders[dwQueryIndex].Text,
                          GlobalKnownHeaders[dwQueryIndex].Length) != 0)
            {
                dwQueryIndex = INVALID_HEADER_SLOT;
            }
        }
        else
        {
            dwQueryIndex = INVALID_HEADER_SLOT;
        }
        */
    }


    //
    // if we didn't find the header value or we are not coalescing then add the
    // header
    //

    if (error == ERROR_HTTP_HEADER_NOT_FOUND)
    {
        //
        // find the next slot for this header
        //

        HEADER_STRING * freeHeader;
        DWORD iSlot;

        freeHeader = FindFreeSlot(&iSlot);
        if (freeHeader == NULL) {
            error = GetError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto Cleanup;
        }


        freeHeader->CreateStringBuffer((LPVOID)lpszHeaderName,
                                       dwHeaderNameLength,
                                       dwHeaderNameLength
                                       + sizeof(": ") - 1
                                       + dwHeaderValueLength
                                       + 1 // for extra NULL terminator
                                       );
        if (freeHeader->IsError()) {
            error = ::GetLastError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto Cleanup;
        }
        freeHeader->Strncat((LPVOID)": ", sizeof(": ") - 1);
        if (dwHeaderValueLength > 0)
        {
            freeHeader->Strncat((LPVOID)lpszHeaderValue, dwHeaderValueLength);
        }
        _HeadersLength += dwHeaderNameLength
                        + (sizeof(": ") - 1)
                        + dwHeaderValueLength
                        + (sizeof("\r\n") - 1)
                        ;
        freeHeader->SetHash(dwHash);

        if ( dwQueryIndex != INVALID_HEADER_SLOT )
        {
            freeHeader->SetNextKnownIndex(FastAdd(dwQueryIndex, iSlot));
        }

        error = ERROR_SUCCESS;
    }

Cleanup:
    UnlockHeaders();

quit:
    PERF_LEAVE(AddHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::AddHeader(
    IN DWORD dwQueryIndex,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Adds a single header to the array of headers, given the header name and
    value. Called via HttpOpenRequest()

Arguments:

    dwQueryIndex        - a index into a array of known HTTP headers, see wininet.h HTTP_QUERY_* codes

    lpszHeaderValue     - pointer to value of header to add, e.g. "text/html"

    dwHeaderValueLength - length of the header value

    dwIndex             - if coalescing headers, index of header to update

    dwFlags             - flags controlling function:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            CLEAN_HEADER
                                - header is supplied by user, so we must ensure
                                  it has correct format

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory allocating string

                  ERROR_INVALID_PARAMETER
                    The header value was bad

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AddHeader",
                 "%q, %u, %.*q, %d, %d, %#x",
                 GlobalKnownHeaders[dwQueryIndex].Text,
                 dwQueryIndex,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(AddHeader);

    INET_ASSERT(dwQueryIndex <= HTTP_QUERY_MAX);
    INET_ASSERT(lpszHeaderValue != NULL);
    // INET_ASSERT(*lpszHeaderValue != '\0'); A header with no value is allowed
    // INET_ASSERT(dwHeaderValueLength != 0); A header with no value is allowed
    INET_ASSERT(_FreeSlots <= _TotalSlots);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    LPSTR lpszHeaderName;
    DWORD dwHeaderNameLength;
    DWORD dwHash;

    dwHash             = GlobalKnownHeaders[dwQueryIndex].HashVal;
    lpszHeaderName     = GlobalKnownHeaders[dwQueryIndex].Text;
    dwHeaderNameLength = GlobalKnownHeaders[dwQueryIndex].Length;

    //
    // if we are coalescing headers then find a header with the same name
    //

    if ((dwFlags & COALESCE_HEADER_WITH_COMMA) ||
        (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) )
    {
        DWORD dwSlot;

        dwSlot = FastFind(
                    dwQueryIndex,
                    dwIndex
                    );

        if (dwSlot != INVALID_HEADER_SLOT)
        {
            if (dwHeaderValueLength > 0) // don't bother appending if empty value
            {
                HEADER_STRING * pString;

                pString = &_lpHeaders[dwSlot];

                //
                // found what we are looking for. Coalesce it
                //

                pString->ResizeString((sizeof("; ")-1) + dwHeaderValueLength); // save us from multiple reallocs

                pString->Strncat(
                                 (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) ?
                                     "; " :
                                     ", ",
                                  2);

                pString->Strncat(lpszHeaderValue, dwHeaderValueLength);
                _HeadersLength += 2 + dwHeaderValueLength;
            }
            error = ERROR_SUCCESS;

        }
    }


    //
    // if we didn't find the header value or we are not coalescing then add the
    // header
    //

    if (error == ERROR_HTTP_HEADER_NOT_FOUND)
    {
        //
        // find the next slot for this header
        //

        HEADER_STRING * freeHeader;
        DWORD iSlot;

        freeHeader = FindFreeSlot(&iSlot);
        if (freeHeader == NULL) {
            error = GetError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto quit;
        }


        freeHeader->CreateStringBuffer((LPVOID)lpszHeaderName,
                                       dwHeaderNameLength,
                                       dwHeaderNameLength
                                       + sizeof(": ") - 1
                                       + dwHeaderValueLength
                                       + 1 // for extra NULL terminator
                                       );
        if (freeHeader->IsError()) {
            error = ::GetLastError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto quit;
        }
        freeHeader->Strncat((LPVOID)": ", sizeof(": ") - 1);
        if (dwHeaderValueLength > 0)
        {
            freeHeader->Strncat((LPVOID)lpszHeaderValue, dwHeaderValueLength);
        }
        _HeadersLength += dwHeaderNameLength
                        + (sizeof(": ") - 1)
                        + dwHeaderValueLength
                        + (sizeof("\r\n") - 1)
                        ;
        freeHeader->SetHash(dwHash);
        freeHeader->SetNextKnownIndex(FastAdd(dwQueryIndex, iSlot));

        error = ERROR_SUCCESS;
    }

quit:

    PERF_LEAVE(AddHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::ReplaceHeader(
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Replaces a HTTP (request) header. The header can be replaced with a NULL
    value, meaning that the header is removed

Arguments:

    lpszHeaderName      - pointer to the header name

    dwHeaderNameLength  - length of the header name

    lpszHeaderValue     - pointer to the header value

    dwHeaderValueLength - length of the header value

    dwIndex             - index of header to replace

    dwFlags             - flags controlling function. Allowed flags are:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            ADD_HEADER
                                - if the header-name is not found and there is
                                  a valid header-value, then the header is added

                            ADD_HEADER_IF_NEW
                                - if the header-name exists then we return an
                                  error, else we add the header-value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_HTTP_HEADER_NOT_FOUND
                    The requested header wasn't found

                  ERROR_HTTP_HEADER_ALREADY_EXISTS
                    The header already exists, and was not added or replaced

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory trying to acquire lock

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ReplaceHeader",
                 "%.*q, %d, %.*q, %d, %d, %#x",
                 min(dwHeaderNameLength + 1, 80),
                 lpszHeaderName,
                 dwHeaderNameLength,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(ReplaceHeader);

    INET_ASSERT(lpszHeaderName != NULL);
    INET_ASSERT(dwHeaderNameLength != 0);
    INET_ASSERT(lpszHeaderName[dwHeaderNameLength - 1] != ':');

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD dwHash = CalculateHashNoCase(lpszHeaderName, dwHeaderNameLength);
    DWORD dwSlot;
    DWORD dwQueryIndex;
    BYTE *pbPrevByte;

    if (!LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    dwSlot = SlowFind(
                NULL,
                lpszHeaderName,
                dwHeaderNameLength,
                dwIndex,
                dwHash,
                &dwQueryIndex,
                &pbPrevByte
                );

    if ( dwSlot != ((DWORD) -1))
    {
        //
        // if ADD_HEADER_IF_NEW is set, then we already have the header
        //

        if (dwFlags & ADD_HEADER_IF_NEW) {
            error = ERROR_HTTP_HEADER_ALREADY_EXISTS;
            goto Cleanup;
        }

        //
        // for both replace and remove operations, we are going to remove
        // the current header
        //

        RemoveHeader(dwSlot, dwQueryIndex, pbPrevByte);

        //
        // if replacing then add the new header value
        //

        if (dwHeaderValueLength != 0)
        {
            if ( dwQueryIndex != ((DWORD) -1) )
            {
                error = AddHeader(dwQueryIndex,
                                  lpszHeaderValue,
                                  dwHeaderValueLength,
                                  0,
                                  dwFlags
                                  );
            }
            else
            {
                error = AddHeader(lpszHeaderName,
                                  dwHeaderNameLength,
                                  lpszHeaderValue,
                                  dwHeaderValueLength,
                                  0,
                                  dwFlags
                                  );
            }


        } else {
            error = ERROR_SUCCESS;
        }
    }

    //
    // if we didn't find the header but ADD_HEADER is set then we simply add it
    // but only if the value length is not zero
    //

    if ((error == ERROR_HTTP_HEADER_NOT_FOUND)
    && (dwHeaderValueLength != 0)
    && (dwFlags & (ADD_HEADER | ADD_HEADER_IF_NEW)))
    {
        if ( dwQueryIndex != ((DWORD) -1) )
        {
            error = AddHeader(dwQueryIndex,
                              lpszHeaderValue,
                              dwHeaderValueLength,
                              0,
                              dwFlags
                              );
        }
        else
        {
            error = AddHeader(lpszHeaderName,
                              dwHeaderNameLength,
                              lpszHeaderValue,
                              dwHeaderValueLength,
                              0,
                              dwFlags
                              );

        }
    }

Cleanup:

    UnlockHeaders();

quit:
    PERF_LEAVE(ReplaceHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::ReplaceHeader(
    IN DWORD dwQueryIndex,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Replaces a HTTP (request) header. The header can be replaced with a NULL
    value, meaning that the header is removed

Arguments:

    lpszHeaderValue     - pointer to the header value

    dwQueryIndex        - a index into a array of known HTTP headers, see wininet.h HTTP_QUERY_* codes

    dwHeaderValueLength - length of the header value

    dwIndex             - index of header to replace

    dwFlags             - flags controlling function. Allowed flags are:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            ADD_HEADER
                                - if the header-name is not found and there is
                                  a valid header-value, then the header is added

                            ADD_HEADER_IF_NEW
                                - if the header-name exists then we return an
                                  error, else we add the header-value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_HTTP_HEADER_NOT_FOUND
                    The requested header wasn't found

                  ERROR_HTTP_HEADER_ALREADY_EXISTS
                    The header already exists, and was not added or replaced

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory trying to acquire lock

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ReplaceHeader",
                 "%q, %u, %.*q, %d, %d, %#x",
                 GlobalKnownHeaders[dwQueryIndex].Text,
                 dwQueryIndex,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(ReplaceHeader);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD dwSlot;
    BYTE *pbPrevByte;

    if (!LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    dwSlot = FastNukeFind(
                dwQueryIndex,
                dwIndex,
                &pbPrevByte
                );

    if ( dwSlot != INVALID_HEADER_SLOT)
    {
        //
        // if ADD_HEADER_IF_NEW is set, then we already have the header
        //

        if (dwFlags & ADD_HEADER_IF_NEW) {
            error = ERROR_HTTP_HEADER_ALREADY_EXISTS;
            goto Cleanup;
        }

        //
        // for both replace and remove operations, we are going to remove
        // the current header
        //

        RemoveHeader(dwSlot, dwQueryIndex, pbPrevByte);

        //
        // if replacing then add the new header value
        //

        if (dwHeaderValueLength != 0)
        {
            error = AddHeader(dwQueryIndex,
                              lpszHeaderValue,
                              dwHeaderValueLength,
                              0,
                              dwFlags
                              );
        } else {
            error = ERROR_SUCCESS;
        }
    }

    //
    // if we didn't find the header but ADD_HEADER is set then we simply add it
    // but only if the value length is not zero
    //

    if ((error == ERROR_HTTP_HEADER_NOT_FOUND)
    && (dwHeaderValueLength != 0)
    && (dwFlags & (ADD_HEADER | ADD_HEADER_IF_NEW)))
    {
        error = AddHeader(dwQueryIndex,
                          lpszHeaderValue,
                          dwHeaderValueLength,
                          0,
                          dwFlags
                          );
    }

Cleanup:

    UnlockHeaders();

quit:
    PERF_LEAVE(ReplaceHeader);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_HEADERS::FindHeader(
    IN LPSTR lpBase,
    IN LPCSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN DWORD dwModifiers,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
    )

/*++

Routine Description:

    Finds a request or response header

Arguments:

    lpBase              - base for offset HEADER_STRINGs

    lpszHeaderName      - pointer to header name

    dwHeaderNameLength  - length of header name

    dwModifiers         - flags which modify returned value

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of results, or required length of lpBuffer

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the amount required

                  ERROR_HTTP_HEADER_NOT_FOUND
                    The specified header (or index of header) was not found

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory trying to acquire lock

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_HEADERS::FindHeader",
                 "%#x [%.*q], %d, %#x, %#x [%#x], %#x, %#x [%d]",
                 lpszHeaderName,
                 min(dwHeaderNameLength + 1, 80),
                 lpszHeaderName,
                 dwHeaderNameLength,
                 lpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 dwModifiers,
                 lpdwIndex,
                 *lpdwIndex
                 ));


    PERF_ENTER(FindHeader);



    INET_ASSERT(lpdwIndex != NULL);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD dwSlot;
    HEADER_STRING * pString;
    DWORD dwQueryIndex;
    DWORD dwHash = CalculateHashNoCase(lpszHeaderName, dwHeaderNameLength);

    if (!LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    dwSlot = SlowFind(
                lpBase,
                lpszHeaderName,
                dwHeaderNameLength,
                *lpdwIndex,
                dwHash,
                &dwQueryIndex,
                NULL
                );

    if ( dwSlot != ((DWORD) -1) )
    {
        pString = &_lpHeaders[dwSlot];

        //
        // found the header - get to the value
        //

        DWORD stringLen;
        LPSTR value;

        stringLen = pString->StringLength();

        INET_ASSERT(stringLen > dwHeaderNameLength);

        //
        // get a pointer to the value string
        //

        value = pString->StringAddress(lpBase) + dwHeaderNameLength;
        stringLen -= dwHeaderNameLength;

        //
        // the input string could be a substring of a different header
        //

        //INET_ASSERT(*value != ':');

        //
        // find the first non-space character in the value.
        //
        // N.B.: Servers can return empty headers, so we may end up with a
        // zero length string
        //

        do {
            ++value;
            --stringLen;
        } while ((stringLen > 0) && (*value == ' '));

        //
        // get the data in the format requested by the app
        //

        LPVOID lpData = NULL;
        DWORD dwDataSize = 0;
        DWORD dwRequiredSize = 0;
        SYSTEMTIME systemTime;
        DWORD number;

        //
        // error is no longer ERROR_HTTP_HEADER_NOT_FOUND, but it might not
        // really be success either...
        //

        error = ERROR_SUCCESS;

        if (dwModifiers & HTTP_QUERY_FLAG_SYSTEMTIME) {

            char buf[DATE_AND_TIME_STRING_BUFFER_LENGTH];

            if (stringLen < sizeof(buf)) {

                //
                // value probably does not point at a zero-terminated string
                // which HttpDateToSystemTime() expects, so we make a copy
                // and terminate it
                //

                memcpy((LPVOID)buf, (LPVOID)value, stringLen);
                buf[stringLen] = '\0';
                if (HttpDateToSystemTime(buf, &systemTime)) {
                    lpData = (LPVOID)&systemTime;
                    dwRequiredSize = dwDataSize = sizeof(systemTime);
                } else {

                    //
                    // couldn't convert date/time. Presume header must be bogus
                    //

                    error = ERROR_HTTP_INVALID_QUERY_REQUEST;

                    DEBUG_PRINT(HTTP,
                                ERROR,
                                ("cannot convert %.40q to SYSTEMTIME\n",
                                value
                                ));

                }
            } else {

                //
                // we would break the date/time buffer!
                //

                error = ERROR_WINHTTP_INTERNAL_ERROR;
            }
        } else if (dwModifiers & HTTP_QUERY_FLAG_NUMBER) {
            if (isdigit(*value)) {
                number = 0;
                for (int i = 0;
                    (stringLen > 0) && isdigit(value[i]);
                    ++i, --stringLen) {

                    number = number * 10 + (DWORD)(value[i] - '0');
                }
                lpData = (LPVOID)&number;
                dwRequiredSize = dwDataSize = sizeof(number);
            } else {

                //
                // not a numeric field. Request must be bogus for this header
                //

                error = ERROR_HTTP_INVALID_QUERY_REQUEST;

                DEBUG_PRINT(HTTP,
                            ERROR,
                            ("cannot convert %.20q to NUMBER\n",
                            value
                            ));

            }
        } else {
            lpData = (LPVOID)value;
            dwDataSize = stringLen;
            dwRequiredSize = dwDataSize + 1;
        }

        //
        // if error == ERROR_SUCCESS then we can attempt to copy the data
        //

        if (error == ERROR_SUCCESS) {
            if (*lpdwBufferLength < dwRequiredSize) {
                *lpdwBufferLength = dwRequiredSize;
                error = ERROR_INSUFFICIENT_BUFFER;
            } else {
                memcpy(lpBuffer, lpData, dwDataSize);
                *lpdwBufferLength = dwDataSize;

                //
                // if dwRequiredSize > dwDataSize, then this is a variable-
                // length item (i.e. a STRING!) so we add a terminating '\0'
                //

                if (dwRequiredSize > dwDataSize) {

                    INET_ASSERT(dwRequiredSize - dwDataSize == 1);

                    ((LPSTR)lpBuffer)[dwDataSize] = '\0';
                }

                //
                // successfully retrieved the requested header - bump the
                // index
                //

                ++*lpdwIndex;
            }
        }
    }

    UnlockHeaders();

quit:
    PERF_LEAVE(FindHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::FindHeader(
    IN LPSTR lpBase,
    IN DWORD dwQueryIndex,
    IN DWORD dwModifiers,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
    )
/*++

Routine Description:

    Finds a request or response header, based on index to the header name we are searching for.

Arguments:

    lpBase              - base for offset HEADER_STRINGs

    dwQueryIndex        - a index into a array of known HTTP headers, see wininet.h HTTP_QUERY_* codes

    dwModifiers         - flags which modify returned value

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of results, or required length of lpBuffer

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the amount required

                  ERROR_HTTP_HEADER_NOT_FOUND
                    The specified header (or index of header) was not found

--*/
{

    DWORD error;
    LPSTR lpData;
    DWORD dwDataSize = 0;
    DWORD dwRequiredSize = 0;
    SYSTEMTIME systemTime;
    DWORD number;

    error = FastFindHeader(
                lpBase,
                dwQueryIndex,
                (LPVOID *)&lpData,
                &dwDataSize,
                *lpdwIndex
                );

    if ( error != ERROR_SUCCESS )
    {
        goto quit;
    }

    //
    // get the data in the format requested by the app
    //

    if (dwModifiers & HTTP_QUERY_FLAG_SYSTEMTIME)
    {
        char buf[DATE_AND_TIME_STRING_BUFFER_LENGTH];

        if (dwDataSize < sizeof(buf))
        {

            //
            // value probably does not point at a zero-terminated string
            // which HttpDateToSystemTime() expects, so we make a copy
            // and terminate it
            //

            memcpy((LPVOID)buf, (LPVOID)lpData, dwDataSize);
            buf[dwDataSize] = '\0';
            if (HttpDateToSystemTime(buf, &systemTime)) {
                lpData = (LPSTR)&systemTime;
                dwRequiredSize = dwDataSize = sizeof(systemTime);
            } else {

                //
                // couldn't convert date/time. Presume header must be bogus
                //

                error = ERROR_HTTP_INVALID_QUERY_REQUEST;

                DEBUG_PRINT(HTTP,
                            ERROR,
                            ("cannot convert %.40q to SYSTEMTIME\n",
                            lpData
                            ));

            }
        }
        else
        {

            //
            // we would break the date/time buffer!
            //

            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
    }
    else if (dwModifiers & HTTP_QUERY_FLAG_NUMBER)
    {
        if (isdigit(*lpData)) {
            number = 0;
            for (int i = 0;
                (dwDataSize > 0) && isdigit(lpData[i]);
                ++i, --dwDataSize) {

                number = number * 10 + (DWORD)(lpData[i] - '0');
            }
            lpData = (LPSTR)&number;
            dwRequiredSize = dwDataSize = sizeof(number);
        } else {

            //
            // not a numeric field. Request must be bogus for this header
            //

            error = ERROR_HTTP_INVALID_QUERY_REQUEST;

            DEBUG_PRINT(HTTP,
                        ERROR,
                        ("cannot convert %.20q to NUMBER\n",
                        lpData
                        ));

        }
    }
    else
    {
        dwRequiredSize = dwDataSize + 1;
    }

    //
    // if error == ERROR_SUCCESS then we can attempt to copy the data
    //

    if (error == ERROR_SUCCESS)
    {
        if (*lpdwBufferLength < dwRequiredSize)
        {
            *lpdwBufferLength = dwRequiredSize;
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            memcpy(lpBuffer, lpData, dwDataSize);
            *lpdwBufferLength = dwDataSize;

            //
            // if dwRequiredSize > dwDataSize, then this is a variable-
            // length item (i.e. a STRING!) so we add a terminating '\0'
            //

            if (dwRequiredSize > dwDataSize)
            {
                INET_ASSERT(dwRequiredSize - dwDataSize == 1);

                ((LPSTR)lpBuffer)[dwDataSize] = '\0';
            }

            //
            // successfully retrieved the requested header - bump the
            // index
            //

            ++*lpdwIndex;
        }
    }
quit:

    return error;
}



DWORD
HTTP_HEADERS::FastFindHeader(
    IN LPSTR lpBase,
    IN DWORD dwQueryIndex,
    OUT LPVOID *lplpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwIndex
    )

/*++

Routine Description:

    Finds a request or response header slightly quicker than its higher level
     cousin, FindHeader.   Unlike FindHeader this function simply returns
     a pointer and length, and does not copy header data.


    lpBase              - base address of strings

    dwQueryIndex        - a index into a array known HTTP headers, see wininet.h HTTP_QUERY_* codes

    lplpBuffer          - pointer to pointer of the actual header to be returned in.

    lpdwBufferLength    - OUT: if successful, length of output buffer, minus 1
                               for any trailing EOS, or if the buffer is not
                               large enough, the size required

    dwIndex             - a index of which header we're asking for, as there can be multiple headers
                          under the same name.

Arguments:

    lpBase              - base for offset HEADER_STRINGs

    lpszHeaderName      - pointer to header name

    dwHeaderNameLength  - length of header name

    dwModifiers         - flags which modify returned value

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of results, or required length of lpBuffer

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the amount required

                  ERROR_HTTP_HEADER_NOT_FOUND
                    The specified header (or index of header) was not found

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_HEADERS::FastFindHeader",
                 "%q, %#x, %#x [%#x], %u",
                 GlobalKnownHeaders[dwQueryIndex].Text,
                 lplpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 dwIndex
                 ));

    PERF_ENTER(FindHeader);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;

    HEADER_STRING * curHeader;
    DWORD dwSlot;

    dwSlot = FastFind(dwQueryIndex, dwIndex);

    if ( dwSlot != INVALID_HEADER_SLOT)
    {
        //
        // found the header - get to the value
        //

        DWORD stringLen;
        LPSTR value;

        curHeader = GetSlot(dwSlot);

        //
        // get a pointer to the value string
        //

        value     = curHeader->StringAddress(lpBase) + (GlobalKnownHeaders[dwQueryIndex].Length+1);
        stringLen = curHeader->StringLength() - (GlobalKnownHeaders[dwQueryIndex].Length+1);

        //
        // find the first non-space character in the value.
        //
        // N.B.: Servers can return empty headers, so we may end up with a
        // zero length string
        //

        while ((stringLen > 0) && (*value == ' '))
        {
            ++value;
            --stringLen;
        }

        //
        // get the data in the format requested by the app
        //

        //
        // error is no longer ERROR_HTTP_HEADER_NOT_FOUND, but it might not
        // really be success either...
        //

        error = ERROR_SUCCESS;

        *lplpBuffer = (LPVOID)value;
        *lpdwBufferLength = stringLen;
    }

    PERF_LEAVE(FindHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::QueryRawHeaders(
    IN LPSTR lpBase,
    IN BOOL bCrLfTerminated,
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns all the request or response headers in a single buffer. The headers
    can be returned as ASCIIZ strings, or CR-LF terminated strings

Arguments:

    lpBase              - base address of strings

    bCrLfTerminated     - TRUE if each string is terminated with CR-LF

    lpBuffer            - pointer to buffer to write headers

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: if successful, length of output buffer, minus 1
                               for any trailing EOS, or if the buffer is not
                               large enough, the size required

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory trying to acquire lock
--*/

{
    PERF_ENTER(QueryRawHeaders);

    DWORD error = ERROR_SUCCESS;
    DWORD requiredLength = 0;
    LPSTR lpszBuffer = (LPSTR)lpBuffer;

    if (!LockHeaders())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    for (DWORD i = 0; i < _TotalSlots; ++i) {
        if (_lpHeaders[i].HaveString()) {

            DWORD length;

            length = _lpHeaders[i].StringLength();

            requiredLength += length + (bCrLfTerminated ? 2 : 1);
            if (*lpdwBufferLength > requiredLength) {
                _lpHeaders[i].CopyTo(lpBase, lpszBuffer);
                lpszBuffer += length;
                if (bCrLfTerminated) {
                    *lpszBuffer++ = '\r';
                    *lpszBuffer++ = '\n';
                } else {
                    *lpszBuffer++ = '\0';
                }
            }
        }
    }

    if (bCrLfTerminated)
    {
        requiredLength += 2;
        if (*lpdwBufferLength > requiredLength)
        {
            *lpszBuffer++ = '\r';
            *lpszBuffer++ = '\n';
        }
    }

    UnlockHeaders();

    ++requiredLength;

    if (*lpdwBufferLength < requiredLength) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        *lpszBuffer = '\0';
        --requiredLength;   // remove 1 for trailing '\0'
    }
    *lpdwBufferLength = requiredLength;

quit:
    PERF_LEAVE(QueryRawHeaders);

    return error;
}


DWORD
HTTP_HEADERS::QueryFilteredRawHeaders(
    IN LPSTR lpBase,
    IN LPSTR *lplpFilterList,
    IN DWORD cListElements,
    IN BOOL  fExclude,
    IN BOOL  fSkipVerb,
    IN BOOL bCrLfTerminated,
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns all the request or response headers in a single buffer. The headers
    can be returned as ASCIIZ strings, or CR-LF terminated strings

Arguments:

    lpBase              - base address of strings

    bCrLfTerminated     - TRUE if each string is terminated with CR-LF

    lpBuffer            - pointer to buffer to write headers

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: if successful, length of output buffer, minus 1
                               for any trailing EOS, or if the buffer is not
                               large enough, the size required

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD error = ERROR_NOT_SUPPORTED;

    DWORD requiredLength = 0;
    LPSTR lpszBuffer = (LPSTR)lpBuffer;
    BOOL fCopy;

    DWORD i = fSkipVerb ? 1 : 0;
    for (; i < _TotalSlots; ++i) {
       if (_lpHeaders[i].HaveString()) {
          fCopy = TRUE;
          if (lplpFilterList
             && FMatchList(lplpFilterList, cListElements, _lpHeaders+i, lpBase)) {
             fCopy = fExclude?FALSE:TRUE;
          }
          if (fCopy) {
              DWORD length;

              length = _lpHeaders[i].StringLength();
              requiredLength += length + (bCrLfTerminated ? 2 : 1);
              if (*lpdwBufferLength > requiredLength) {
                    _lpHeaders[i].CopyTo(lpBase, lpszBuffer);
                   lpszBuffer += length;
                   if (bCrLfTerminated) {
                       *lpszBuffer++ = '\r';
                       *lpszBuffer++ = '\n';
                    } else {
                       *lpszBuffer++ = '\0';
                   }
                }
            }
        }
    }

    if (bCrLfTerminated)
    {
        requiredLength += 2;
        if (*lpdwBufferLength > requiredLength)
        {
            *lpszBuffer++ = '\r';
            *lpszBuffer++ = '\n';
        }
    }

    ++requiredLength;


    if (*lpdwBufferLength < requiredLength) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        *lpszBuffer = '\0';
        --requiredLength;   // remove 1 for trailing '\0'
        error = ERROR_SUCCESS;
    }
    *lpdwBufferLength = requiredLength;
    return error;
}


DWORD
HTTP_HEADERS::AddRequest(
    IN LPSTR lpszVerb,
    IN LPSTR lpszObject,
    IN LPSTR lpszVersion
    )

/*++

Routine Description:

    Builds the request line from its constituent parts. The request line is the
    first (0th) header in the request headers

    Assumes:    1. This is the one-and-only call to this method
                2. lpszObject must already be escaped if necessary

Arguments:

    lpszVerb    - pointer to HTTP verb, e.g. "GET"

    lpszObject  - pointer to HTTP object name, e.g. "/users/albert/~emc2.htm".

    lpszVersion - pointer to HTTP version string, e.g. "HTTP/1.0"

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    PERF_ENTER(AddRequest);

    //
    // there must not be a header when this method is called
    //

    INET_ASSERT(_HeadersLength == 0);

    DWORD error = ERROR_SUCCESS;
    int verbLen = lstrlen(lpszVerb);
    int objectLen = lstrlen(lpszObject);
    int versionLen = lstrlen(lpszVersion);
    int len = verbLen       // "GET"
            + 1             //     ' '
            + objectLen     //        "/users/albert/~emc2.htm"
            + 1             //                                 ' '
            + versionLen    //                                    "HTTP/1.0"
            + 1             //                                              '\0'
            ;

    //
    // we are about to start updating the headers for the current
    // HTTP_REQUEST_HANDLE_OBJECT. Serialize access
    //

    HEADER_STRING * pRequest = GetFirstHeader();
    HEADER_STRING & request = *pRequest;

    if (pRequest == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    INET_ASSERT(!request.HaveString());

    _lpszVerb = NULL;
    _dwVerbLength = 0;
    _lpszObjectName = NULL;
    _dwObjectNameLength = 0;
    _lpszVersion = NULL;
    _dwVersionLength = 0;

    request.CreateStringBuffer((LPVOID)lpszVerb, verbLen, len);
    if (request.IsError()) {
        error = GetLastError();

        INET_ASSERT(error != ERROR_SUCCESS);

    } else {
        request += ' ';
        request.Strncat((LPVOID)lpszObject, objectLen);
        request += ' ';
        request.Strncat((LPVOID)lpszVersion, versionLen);

        _HeadersLength = len - 1 + (sizeof("\r\n") - 1);

        //
        // we have used the first free slot in the headers array
        //

        --_FreeSlots;

        //
        // update the component variables in case of a ModifyRequest()
        //

        _lpszVerb = request.StringAddress();
        _dwVerbLength = verbLen;
        _lpszObjectName = _lpszVerb + verbLen + 1;
        _dwObjectNameLength = objectLen;
        _lpszVersion = _lpszObjectName + objectLen + 1;
        _dwVersionLength = versionLen;
        SetRequestVersion();
        error = request.IsError() ? ::GetLastError() : ERROR_SUCCESS;
    }

quit:

    PERF_LEAVE(AddRequest);

    return error;
}


DWORD
HTTP_HEADERS::ModifyRequest(
    IN HTTP_METHOD_TYPE tMethod,
    IN LPSTR lpszObjectName,
    IN DWORD dwObjectNameLength,
    IN LPSTR lpszVersion OPTIONAL,
    IN DWORD dwVersionLength
    )

/*++

Routine Description:

    Updates the request line. Used in redirection

Arguments:

    tMethod             - type of new method

    lpszObjectName      - pointer to new object name

    dwObjectNameLength  - length of new object name

    lpszVersion         - optional pointer to version string

    dwVersionLength     - length of lpszVersion string if present

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ModifyRequest",
                 "%s, %q, %d, %q, %d",
                 MapHttpMethodType(tMethod),
                 lpszObjectName,
                 dwObjectNameLength,
                 lpszVersion,
                 dwVersionLength
                 ));

    PERF_ENTER(ModifyRequest);

    INET_ASSERT(lpszObjectName != NULL);
    INET_ASSERT(dwObjectNameLength != 0);

    //
    // there must already be a header when this method is called
    //

    INET_ASSERT(_HeadersLength != 0);

    //
    // we are about to start updating the headers for the current
    // HTTP_REQUEST_HANDLE_OBJECT. Serialize access
    //

    //
    // BUGBUG [arthurbi] using two HEADER_STRINGs here causes an extra
    //  ReAlloc when use the Copy operator between the two.
    //

    HEADER_STRING * pRequest = GetFirstHeader();
    HEADER_STRING & request = *pRequest;
    HEADER_STRING newRequest;
    LPCSTR lpcszVerb;
    DWORD verbLength;
    DWORD error = ERROR_SUCCESS;
    DWORD length;

    //
    // there must already be a request line
    //

    if (pRequest == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    INET_ASSERT(request.HaveString());

    //
    // get the verb/method to use.
    //

    if (tMethod == HTTP_METHOD_TYPE_UNKNOWN) {

        //
        // the method is unknown, read the old one out of the string
        //  and save off, basically we're reusing the previous one.
        //

        lpcszVerb = request.StringAddress();

        for (DWORD i = 0; i < request.StringLength(); i++) {
            if (lpcszVerb[i] == ' ') {
                break;
            }
        }

        INET_ASSERT((i > 0) && (i < (DWORD)request.StringLength()));

        verbLength = (DWORD)i;
    } else {

        //
        // its one of the normal kind, just map it.
        //

        verbLength = MapHttpMethodType(tMethod, &lpcszVerb);
    }
    if (lpszVersion == NULL) {
        lpszVersion = _lpszVersion;
        dwVersionLength = _dwVersionLength;
    }

    _lpszVerb = NULL;
    _dwVerbLength = 0;
    _lpszObjectName = NULL;
    _dwObjectNameLength = 0;
    _lpszVersion = NULL;
    _dwVersionLength = 0;

    //
    // calculate the new length from the component lengths we originally set
    // in AddRequest(), and the new object name
    //

    length = verbLength + 1 + dwObjectNameLength + 1 + dwVersionLength + 1;

    //
    // create a new request line
    //

    newRequest.CreateStringBuffer((LPVOID)lpcszVerb, verbLength, length);
    if (newRequest.IsError()) {
        error = GetLastError();
    } else {
        newRequest += ' ';
        newRequest.Strncat((LPVOID)lpszObjectName, dwObjectNameLength);
        newRequest += ' ';
        newRequest.Strncat((LPVOID)lpszVersion, dwVersionLength);

        //
        // remove the current request line length from the header buffer
        // aggregate
        //

        _HeadersLength -= request.StringLength();

        //
        // make the current request line the new one
        //

        request = newRequest.StringAddress();

        //
        // and update the address and length variables (version length is the
        // only thing that stays the same)
        //

        if (!request.IsError()) {
            _lpszVerb = request.StringAddress();
            _dwVerbLength = verbLength;
            _lpszObjectName = _lpszVerb + verbLength + 1;
            _dwObjectNameLength = dwObjectNameLength;
            _lpszVersion = _lpszObjectName + dwObjectNameLength + 1;
            _dwVersionLength = dwVersionLength;
            SetRequestVersion();

        //
        // and the new request line length to the aggregate header length
        //

            _HeadersLength += request.StringLength();
        } else {
            error = GetLastError();
        }
    }

quit:

    PERF_LEAVE(ModifyRequest);

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_HEADERS::SetRequestVersion(
    VOID
    )

/*++

Routine Description:

    Set _RequestVersionMajor and _RequestVersionMinor based on the HTTP
    version string

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_HEADERS::SetRequestVersion",
                 NULL
                 ));

    INET_ASSERT(_lpszVersion != NULL);

    _RequestVersionMajor = 0;
    _RequestVersionMinor = 0;
    if (strncmp(_lpszVersion, "HTTP/", sizeof("HTTP/") - 1) == 0) {

        LPSTR pNum = _lpszVersion + sizeof("HTTP/") - 1;

        ExtractInt(&pNum, 0, (LPINT)&_RequestVersionMajor);
        while (!isdigit(*pNum) && (*pNum != '\0')) {
            ++pNum;
        }
        ExtractInt(&pNum, 0, (LPINT)&_RequestVersionMinor);

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("request version = %d.%d\n",
                    _RequestVersionMajor,
                    _RequestVersionMinor
                    ));

    } else {

        DEBUG_PRINT(HTTP,
                    WARNING,
                    ("\"HTTP/\" not found in %q\n",
                    _lpszVersion
                    ));

    }

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\http\httptime.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    httptime.h

Abstract:

    This file contains the numerical defines for the date/parsing routines located
    in the httptime.cxx file.

Author:

    Arthur Bierer (arthurbi) 12-Dec-1997

Revision History:

--*/


#ifndef _HTTPTIME_H_
#define _HTTPTIME_H_

#define BASE_DEC 10 // base 10

//
// Date indicies used to figure out what each entry is.
//


#define DATE_INDEX_DAY_OF_WEEK     0

#define DATE_1123_INDEX_DAY        1
#define DATE_1123_INDEX_MONTH      2
#define DATE_1123_INDEX_YEAR       3
#define DATE_1123_INDEX_HRS        4
#define DATE_1123_INDEX_MINS       5
#define DATE_1123_INDEX_SECS       6

#define DATE_ANSI_INDEX_MONTH      1
#define DATE_ANSI_INDEX_DAY        2
#define DATE_ANSI_INDEX_HRS        3
#define DATE_ANSI_INDEX_MINS       4
#define DATE_ANSI_INDEX_SECS       5
#define DATE_ANSI_INDEX_YEAR       6

#define DATE_INDEX_TZ              7

#define DATE_INDEX_LAST            DATE_INDEX_TZ
#define MAX_DATE_ENTRIES           (DATE_INDEX_LAST+1)




//
// DATE_TOKEN's DWORD values used to determine what day/month we're on
//

#define DATE_TOKEN_JANUARY      1
#define DATE_TOKEN_FEBRUARY     2
#define DATE_TOKEN_MARCH        3
#define DATE_TOKEN_APRIL        4
#define DATE_TOKEN_MAY          5
#define DATE_TOKEN_JUNE         6
#define DATE_TOKEN_JULY         7
#define DATE_TOKEN_AUGUST       8
#define DATE_TOKEN_SEPTEMBER    9
#define DATE_TOKEN_OCTOBER      10
#define DATE_TOKEN_NOVEMBER     11
#define DATE_TOKEN_DECEMBER     12       

#define DATE_TOKEN_LAST_MONTH   (DATE_TOKEN_DECEMBER+1)

#define DATE_TOKEN_SUNDAY       0
#define DATE_TOKEN_MONDAY       1
#define DATE_TOKEN_TUESDAY      2                  
#define DATE_TOKEN_WEDNESDAY    3
#define DATE_TOKEN_THURSDAY     4
#define DATE_TOKEN_FRIDAY       5
#define DATE_TOKEN_SATURDAY     6

#define DATE_TOKEN_LAST_DAY     (DATE_TOKEN_SATURDAY+1)
 
#define DATE_TOKEN_GMT          0xFFFFFFFD

#define DATE_TOKEN_LAST         DATE_TOKEN_GMT

#define DATE_TOKEN_ERROR        (DATE_TOKEN_LAST+1)

                            
#endif  // _HTTPTIME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\http\hdrparse.cxx ===
#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// HTTP_HEADER_PARSER implementation
//

HTTP_HEADER_PARSER::HTTP_HEADER_PARSER(
    IN LPSTR szHeaders,
    IN DWORD cbHeaders
    ) : HTTP_HEADERS()

/*++

Routine Description:

    Constructor for the HTTP_HEADER_PARSER object.  Calls ParseHeaders to
      build a parsed version of the header string passed in.

Arguments:

    szHeaders      - pointer to the headers to parse

    cbHeaders      - length of the headers

Return Value:

    None.

--*/

{
    DWORD dwBytesScaned = 0;
    BOOL fFoundCompleteLine;
    BOOL fFoundEndOfHeaders;
    DWORD error;

    error = ParseHeaders(
        szHeaders,
        cbHeaders,
        TRUE, // Eof
        &dwBytesScaned,
        &fFoundCompleteLine,
        &fFoundEndOfHeaders
        );

    INET_ASSERT(error == ERROR_SUCCESS);
    INET_ASSERT(fFoundCompleteLine);
    INET_ASSERT(fFoundEndOfHeaders);
}


/*  //  some test cases which can be used to test ParseStatusLine()
char bad1[] = "HTTP1.1 200 Description yeah yeah\r\n";
char bad2[] = "HTTP/1234.1 200 Description yeah yeah\r\n";
char bad3[] = "HTTP/1.1234 200 Description yeah yeah\r\n";
char bad4[] = "HTTP/1.1 1234 Description yeah yeah\r\n";
char bad5[] = "HTTP/    1.1 200 Description yeah yeah\r\n";
char bad6[] = "HTTP/1.1    200 Description yeah yeah\r\n";
char bad7[] = "HTTP/1.1 200Description yeah yeah\r\n";
char bad8[3000] = "HTTP/1.1 200 Description yeah yeah";
char bad9[] = "HTTP/1 1.1 200 Description yeah yeah\r\n";
char good1[] = "HTTP/   123.123   200 Description yeah yeah\r\n";
*/


DWORD
HTTP_HEADER_PARSER::ParseStatusLine(
    IN LPSTR lpHeaderBase,
    IN DWORD dwBufferLength,
    IN BOOL fEof,
    IN OUT DWORD *lpdwBufferLengthScanned,
    OUT BOOL *lpfNeedMoreBuffer,
    OUT DWORD *lpdwStatusCode,
    OUT DWORD *lpdwMajorVersion,
    OUT DWORD *lpdwMinorVersion
    )

/*++

Routine Description:

    Parses the Status line of an HTTP server response.  Takes care of adding the status
     line to HTTP header array.

    From HTTP v1.1. spec:
    {
      Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
      HTTP-Version   = "HTTP" "/" 1*DIGIT "." 1*DIGIT
      Status-Code = 1*DIGIT
      Reason-Phrase = *<TEXT, excluding CR LF>
      (1*DIGIT means at least one digit, maybe more)
    }

    WinHTTP strictly enforces the status line spec.  The only exception is that up to 3
    spaces are allowed before the Status-Code and major version number.

    To prevent malicious servers from hogging the channel, the integers are limited to
    3 digits and the Reason-Phrase is limited to GlobalMaxSizeStatusLineResultText characters.

    "HTTP" could be other things like "S-HTTP", this is checked by UpdateFromHeaders()
    before ParseStatusLine() is called.  The existence of the first '/' is verified before
    ParseStatusLine is called.

Arguments:

    lpszHeader      - pointer to the header to check

    dwHeaderLength  - length of the header

Return Value:

    BOOL  - TRUE if line was successively parsed and processed, FALSE otherwise

--*/

{

#define BEFORE_VERSION_NUMBERS 0
#define MAJOR_VERSION_NUMBER   1
#define MINOR_VERSION_NUMBER   2
#define STATUS_CODE_NUMBER     3
#define AFTER_STATUS_CODE      4
#define MAX_STATUS_INTS        4

    LPSTR lpszEnd = lpHeaderBase + dwBufferLength;
    LPSTR response = lpHeaderBase + *lpdwBufferLengthScanned;
    DWORD dwBytesScanned = 0;
    DWORD dwStatusLineLength = 0;
    LPSTR lpszStatusLine = NULL;
    int ver_state = BEFORE_VERSION_NUMBERS;
    BOOL afStatusIntsFound[MAX_STATUS_INTS] = {0};
    DWORD adwStatusInts[MAX_STATUS_INTS] = {0};
    DWORD dwStatusPieceLength = 0;
    BOOL error = ERROR_WINHTTP_INTERNAL_ERROR;

    lpszStatusLine = response;

    //
    // While walking the Status Line looking for terminating \r\n,
    //   we extract the Major.Minor Versions and Status Code in that order.
    //   text and spaces will lie between/before/after the three numbers
    //   but the idea is to remeber which number we're calculating based on a numeric state
    //   If all goes well the loop will churn out an array with the 3 numbers plugged in as DWORDs
    //

    while ((response < lpszEnd) && (*response != '\r') && (*response != '\n'))
    {
        switch (ver_state)
        {
            case BEFORE_VERSION_NUMBERS:
                //
                //  We've already matched the status line with something
                //of the form "****/" in UpdateFromHeaders(), we can ignore everything
                //through the first '/'.
                //
                if (*response == '/')
                {
                    INET_ASSERT(ver_state == BEFORE_VERSION_NUMBERS);
                    ver_state++; // = MAJOR_VERSION_NUMBER
                    dwStatusPieceLength = 0;  // next piece is either spaces or an int
                }

                break;

            case MAJOR_VERSION_NUMBER:

                if (*response == '.' && ver_state == MAJOR_VERSION_NUMBER)
                {
                    ver_state++; // = MINOR_VERSION_NUMBER
                    dwStatusPieceLength = 0;  // next piece is an int
                    break;
                }
                // fall through

            case MINOR_VERSION_NUMBER:

                if (*response == ' ' && ver_state == MINOR_VERSION_NUMBER)
                {
                    ver_state++; // = STATUS_CODE_NUMBER
                    dwStatusPieceLength = 0;  // next piece is either spaces or an int.
                    break;
                }
                // fall through

            case STATUS_CODE_NUMBER:

                if (isdigit(*response))
                {
                    if (!afStatusIntsFound[ver_state])
                    {
                        //  transitioning from counting spaces
                        //to counting integers
                        dwStatusPieceLength = 0;
                    }

                    //  Allow up to 3 digits per integer.
                    if (++dwStatusPieceLength > 3)
                        goto doneInvalidStatusLine;
                    
                    int val = *response - '0';
                    afStatusIntsFound[ver_state] = TRUE;
                    adwStatusInts[ver_state] = adwStatusInts[ver_state] * 10 + val;
                }
                else if (adwStatusInts[STATUS_CODE_NUMBER] > 0 )
                {
                    INET_ASSERT(ver_state == STATUS_CODE_NUMBER);
                    if (*response != ' ')
                        goto doneInvalidStatusLine;
                    ver_state++; // = AFTER_STATUS_CODE
                    dwStatusPieceLength = 0;  // next piece is the status line
                    break;
                }
                else if (*response == ' ' && !afStatusIntsFound[ver_state])
                {
                    //
                    //  Before processing MAJOR_VERSION_NUMBER or STATUS_CODE_NUMBER,
                    //allow up to 3 spaces.
                    //
                    //  Multiple spaces are being allowed here because it is
                    //legacy behavior and may therefore be necessary, and being non-strict
                    //about it doesn't put anything at risk.
                    //
                    if (++dwStatusPieceLength > 3)
                        goto doneInvalidStatusLine;
                }
                else
                {
                    //  We fail if anything outside the spec is found, except
                    //for allowing multiple spaces before the status code.
                    goto doneInvalidStatusLine;
                }

                break;

            case AFTER_STATUS_CODE:
                //
                //  This will advance to the next CR or LF..
                //
                //  We limit Reason-Phrase length to protect against malicious socket hogging
                //

                if (++dwStatusPieceLength > GlobalMaxSizeStatusLineResultText)
                {
                    goto doneInvalidStatusLine;
                }
                break;

        }

        ++response;
        ++dwBytesScanned;
    }

    dwStatusLineLength = dwBytesScanned;

    //  If everything has been to spec so far we now expect a final CRLF.  For interop with certain
    //sloppy servers we allow 0-2 CRs before the LF.

    if (response==lpszEnd)
        goto doneNeedMoreData;

    //  CR
    if ( *response == '\r')
    {
        ++response;
        ++dwBytesScanned;
    }

    if (response==lpszEnd)
        goto doneNeedMoreData;

    //  CR
    if ( *response == '\r')
    {
        ++response;
        ++dwBytesScanned;
    }

    if (response==lpszEnd)
        goto doneNeedMoreData;

    //LF
    if ( *response != '\n')
        goto doneInvalidStatusLine;
    ++response;  //  we know its safe to step again since we checked if (respone+1 == lpszEnd) above.
    ++dwBytesScanned;

    //
    //  Some validation checking
    //
    //  All three status ints must have been found.
    //  I found some code that assumes that if the Status Code == 0, then
    //the status line hasn't been parsed yet.  To be sure this assumption
    //remains true, explicitly reject status lines with a 0 status code.
    //
    if (afStatusIntsFound[MAJOR_VERSION_NUMBER] != TRUE
        || afStatusIntsFound[MINOR_VERSION_NUMBER] != TRUE
        || afStatusIntsFound[STATUS_CODE_NUMBER] != TRUE
        || adwStatusInts[STATUS_CODE_NUMBER] == 0)
    {
        goto doneInvalidStatusLine;
    }

    //
    // Now we have our parsed header to add to the array
    //

    HEADER_STRING * freeHeader;
    DWORD iSlot;

    freeHeader = FindFreeSlot(&iSlot);
    if (freeHeader == NULL) {
        INET_ASSERT(FALSE);
        goto doneFailError;
    } else {
        INET_ASSERT(iSlot == 0); // status line should always be first
        freeHeader->CreateOffsetString((DWORD)(lpszStatusLine - lpHeaderBase), dwStatusLineLength);
        freeHeader->SetHash(0); // status line has no hash value.
    }

    //
    //  Success..  fill in the output params appropriately.
    //
    
    *lpfNeedMoreBuffer = FALSE;
    *lpdwStatusCode    = adwStatusInts[STATUS_CODE_NUMBER];
    *lpdwMajorVersion  = adwStatusInts[MAJOR_VERSION_NUMBER];
    *lpdwMinorVersion  = adwStatusInts[MINOR_VERSION_NUMBER];

    *lpdwBufferLengthScanned += dwBytesScanned;
    error = ERROR_SUCCESS;
    goto exitFinalReturn;

doneNeedMoreData:
    if (fEof)
        goto doneInvalidStatusLine;
    error = ERROR_SUCCESS;
    *lpfNeedMoreBuffer = TRUE;
    goto exitFinalReturn;

doneInvalidStatusLine:
    error = ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
    *lpfNeedMoreBuffer = FALSE;
    goto exitFinalReturn;

doneFailError:
    error = ERROR_WINHTTP_INTERNAL_ERROR;
    *lpfNeedMoreBuffer = FALSE;
    goto exitFinalReturn;

exitFinalReturn:
    return error;
}

DWORD
HTTP_HEADER_PARSER::ParseHeaders(
    IN LPSTR lpHeaderBase,
    IN DWORD dwBufferLength,
    IN BOOL fEof,
    IN OUT DWORD *lpdwBufferLengthScanned,
    OUT LPBOOL pfFoundCompleteLine,
    OUT LPBOOL pfFoundEndOfHeaders
    )

/*++

Routine Description:

    Loads headers into HTTP_HEADERS member for subsequent parsing.

    Parses string based headers and adds their parts to an internally stored
    array of HTTP_HEADERS.

    Input is assumed to be well formed Header Name/Value pairs, each deliminated
    by ':' and '\r\n'.

Arguments:

    lpszHeader      - pointer to the header to check

    dwHeaderLength  - length of the header

Return Value:

    None.

--*/


{

    LPSTR lpszEnd = lpHeaderBase + dwBufferLength;
    LPSTR response = lpHeaderBase + *lpdwBufferLengthScanned;
    DWORD dwBytesScanned = 0;
    BOOL success = FALSE;
    DWORD error = ERROR_SUCCESS;

    *pfFoundCompleteLine = FALSE;
    *pfFoundEndOfHeaders  = FALSE;

    if( response > lpszEnd)
    {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //
    // Each iteration of the following loop
    // walks an HTTP header line of the form:
    //  HeaderName: HeaderValue\r\n
    //

    do
    {
        DWORD dwHash = HEADER_HASH_SEED;
        LPSTR lpszHeaderName;
        DWORD dwHeaderNameLength = 0;
        DWORD dwHeaderLineLength = 0;
        DWORD dwPreviousAmountOfBytesScanned = dwBytesScanned;

        //
        // Remove leading whitespace from header
        //

        while ( (response < lpszEnd) && ((*response == ' ') || (*response == '\t')) )
        {
            ++response;
            ++dwBytesScanned;
        }

        //
        // Scan for HeaderName:
        //

        lpszHeaderName = response;
        dwPreviousAmountOfBytesScanned = dwBytesScanned;

        while ((response < lpszEnd) && (*response != ':') && (*response != '\r') && (*response != '\n'))
        {
            //
            // This code incapsulates CalculateHashNoCase as an optimization,
            //   we attempt to calculate the Hash value as we parse the header.
            //

            CHAR ch = *response;

            if ((ch >= 'A') && (ch <= 'Z')) {
                ch = MAKE_LOWER(ch);
            }
            dwHash += (DWORD)(dwHash << 5) + ch;

            ++response;
            ++dwBytesScanned;
        }

        dwHeaderNameLength = (DWORD) (response - lpszHeaderName);

        //
        // catch bogus responses: if we find what looks like one of a (very)
        // small set of HTML tags, then assume the previous header was the
        // last
        //

        if ((dwHeaderNameLength >= sizeof("<HTML>") - 1)
            && (*lpszHeaderName == '<')
            && (!strnicmp(lpszHeaderName, "<HTML>", sizeof("<HTML>") - 1)
                || !strnicmp(lpszHeaderName, "<HEAD>", sizeof("<HEAD>") - 1))) {
            *pfFoundEndOfHeaders  = TRUE;
            break;
        }

        //
        // Keep scanning till end of the line.
        //

        while ((response < lpszEnd) && (*response != '\r') && (*response != '\n'))
        {
            ++response;
            ++dwBytesScanned;
        }

        dwHeaderLineLength = (DWORD) (response - lpszHeaderName); // note: this headerLINElength

        if (response == lpszEnd) {

            //
            // response now points one past the end of the buffer. We may be looking
            // over the edge...
            //
            // if we're at the end of the connection then the server sent us an
            // incorrectly formatted response. Probably an error.
            //
            // Otherwise its a partial response. We need more
            //


            DEBUG_PRINT(HTTP,
                        INFO,
                        ("found end of short response\n"
                        ));

            success = fEof ? TRUE : FALSE;

            //
            // if we really hit the end of the response then update the amount of
            // headers scanned
            //

            if (!success) {
                dwBytesScanned = dwPreviousAmountOfBytesScanned;
            }

            break;

        }
        else
        {

            //
            // we reached a CR or LF. This is the end of this current header. Find
            // the start of the next one
            //

            //
            // first, strip off any trailing spaces from the current header. We do
            // this by simply reducing the string length. We only look for space
            // and tab characters. Only do this if we have a non-zero length header
            //

            if (dwHeaderLineLength != 0) {
                for (int i = -1; response[i] == ' ' || response[i] == '\t'; --i) {
                    --dwHeaderLineLength;
                }
            }

            INET_ASSERT((int)dwHeaderLineLength >= 0);

            //
            // some servers respond with "\r\r\n". Lame
            // A new twist: "\r \r\n". Lamer
            //

            while ((response < lpszEnd)
            && ((*response == '\r') || (*response == ' '))) {
                ++response;
                ++dwBytesScanned;
            }
            if (response == lpszEnd) {

                //
                // hit end of buffer without finding LF
                //

                success = FALSE;

                DEBUG_PRINT(HTTP,
                            WARNING,
                            ("hit end of buffer without finding LF\n"
                            ));

                //
                // get more data, reparse this line
                //

                dwBytesScanned = dwPreviousAmountOfBytesScanned;
                break;
            } else if (*response == '\n') {
                ++response;
                ++dwBytesScanned;

                //
                // if we found the empty line then we are done
                //

                if (dwHeaderLineLength == 0) {
                    *pfFoundEndOfHeaders  = TRUE;
                    break;
                }
                success = TRUE;
            }
        }

        if (lpszHeaderName[dwHeaderNameLength] != ':')
        {
            error = ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
            goto quit;
        }

        //
        // Now we have our parsed header to add to the array
        //

        HEADER_STRING * freeHeader;
        DWORD iSlot;

        freeHeader = FindFreeSlot(&iSlot);
        if (freeHeader == NULL) {
            error = GetError();
            goto quit;

        } else {
            freeHeader->CreateOffsetString((DWORD) (lpszHeaderName - lpHeaderBase), dwHeaderLineLength);
            freeHeader->SetHash(dwHash);
        }


        //CHAR szTemp[256];
        //
        //memcpy(szTemp, lpszHeaderName, dwHeaderLineLength);
        //lpszHeaderName[dwHeaderLineLength] = '\0';

        //DEBUG_PRINT(HTTP,
        //    INFO,
        //    ("ParseHeaders: adding=%q\n", lpszHeaderName
        //    ));


        //
        // Now see if this is a known header we are adding, if so then we note that fact
        //

        DWORD dwKnownQueryIndex;

        if (HeaderMatch(dwHash, lpszHeaderName, dwHeaderNameLength, &dwKnownQueryIndex) )
        {
            freeHeader->SetNextKnownIndex(FastAdd(dwKnownQueryIndex, iSlot));
        }
    } while (TRUE);

quit:

    *lpdwBufferLengthScanned += dwBytesScanned;
    *pfFoundCompleteLine = success;

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\http\add.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    add.cxx

Abstract:

    This file contains the implementation of the HttpAddRequestHeadersA API.

    The following functions are exported by this module:

        HttpAddRequestHeadersA
        WinHttpAddRequestHeaders

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    Modified to make HttpAddRequestHeadersA remotable. madana (2/8/95)

--*/

#include <wininetp.h>
#include "httpp.h"

//
// private manifests
//

#define VALID_ADD_FLAGS (HTTP_ADDREQ_FLAG_ADD_IF_NEW \
                        | HTTP_ADDREQ_FLAG_ADD \
                        | HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA \
                        | HTTP_ADDREQ_FLAG_REPLACE \
                        | HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON \
                        )

//
// functions
//


INTERNETAPI
BOOL
WINAPI
HttpAddRequestHeadersA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )

/*++

Routine Description:

    Appends additional header(s) to an HTTP request handle

Arguments:

    hRequest        - An open HTTP request handle returned by HttpOpenRequest()

    lpszHeaders     - The headers to append to the request. Each header must be
                      terminated by a CR/LF pair.

    dwHeadersLength - The length (in characters) of the headers. If this is -1L
                      then lpszHeaders is assumed to be zero terminated (ASCIIZ)

    dwModifiers     - flags controlling operation. Can be one or more of:

                        HTTP_ADDREQ_FLAG_ADD_IF_NEW
                            - add the header, but only if it does not already
                              exist. Index must be zero

                        HTTP_ADDREQ_FLAG_ADD
                            - if HTTP_ADDREQ_FLAG_REPLACE is set, but the header
                              is not found and this flag is set then the header
                              is added, so long as there is a valid header-value

                        HTTP_ADDREQ_FLAG_COALESCE
                        HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON
                        HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA
                            - concatenate headers of same name. E.g. if we
                              already have "Accept: text/html" then adding
                              "Accept: text/*" will create
                              "Accept: text/html, text/*"

                        HTTP_ADDREQ_FLAG_REPLACE
                            - replaces the named header. Only one header can be
                              supplied. If header-value is empty then the header
                              is removed

Return Value:

    Success - TRUE
                The header was appended successfully

    Failure - FALSE
                The operation failed. Error status is available by calling
                GetLastError()

--*/

{
    DEBUG_ENTER((DBG_API,
                     Bool,
                     "HttpAddRequestHeadersA",
                     "%#x, %.80q, %d, %#x",
                     hRequest,
                     lpszHeaders,
                     dwHeadersLength,
                     dwModifiers
                     ));

    DWORD error;
    HINTERNET hRequestMapped = NULL;
    DWORD nestingLevel = 0;

    if (!GlobalDataInitialized) {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info
    //

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    //
    // map the handle
    //

    error = MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hRequestMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpRequestHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate parameters
    //

    INET_ASSERT(!(
    (lpszHeaders == NULL)
    || (*lpszHeaders == '\0')
    || (dwHeadersLength == 0)
    || (dwModifiers & (HTTP_ADDREQ_FLAGS_MASK & ~VALID_ADD_FLAGS))) );

    INET_ASSERT(error == ERROR_SUCCESS);

    //
    // BUGBUG - we should determine whether the app is trying to give us a bogus
    //          header, and whether the header conforms to the format:
    //
    //                          "<header>[:[ <value>]]"
    //

    if (dwHeadersLength == (DWORD)-1) 
    {
        dwHeadersLength = (DWORD)lstrlen(lpszHeaders);
    }
        
    if (error == ERROR_SUCCESS) {
        error = wHttpAddRequestHeaders(hRequestMapped,
                                       lpszHeaders,
                                       dwHeadersLength,
                                       dwModifiers
                                       );
    }

quit:

    _InternetDecNestingCount(nestingLevel);

done:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(HTTP, error);

        SetLastError(error);
    }

    if (hRequestMapped != NULL) {
        DereferenceObject((LPVOID)hRequestMapped);
    }

    DEBUG_LEAVE(error == ERROR_SUCCESS);

    return error == ERROR_SUCCESS;
}


INTERNETAPI
BOOL
WINAPI
WinHttpAddRequestHeaders(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )

/*++

Routine Description:

    Appends additional header(s) to an HTTP request handle.

Arguments:

    hHttpRequest - An open HTTP request handle returned by HttpOpenRequest().

    lpszHeaders - The headers to append to the request. Each header must be
        terminated by a CR/LF pair.

    dwHeadersLength - The length (in characters) of the headers. If this is
        -1L, then lpszHeaders is assumed to be zero terminated (ASCIIZ).

    dwModifiers     -

Return Value:

    TRUE - The header was appended successfully.

    FALSE - The operation failed. Error status is available by calling
        GetLastError().

Comments:

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpAddRequestHeaders",
                     "%#x, %.80wq, %d, %#x",
                     hRequest,
                     lpszHeaders,
                     dwHeadersLength,
                     dwModifiers
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;

    if (!lpszHeaders 
        || *lpszHeaders==L'\0' 
        || !dwHeadersLength
        || ((dwHeadersLength == -1)
            ? IsBadStringPtrW(lpszHeaders, (UINT_PTR)-1)
            : IsBadReadPtr(lpszHeaders, dwHeadersLength))
        || (dwModifiers & (HTTP_ADDREQ_FLAGS_MASK & ~VALID_ADD_FLAGS)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        MEMORYPACKET mpHeaders;
        ALLOC_MB(lpszHeaders, (dwHeadersLength==-1L ? 0 : dwHeadersLength), mpHeaders);
        if (mpHeaders.psStr)
        {
            UNICODE_TO_ANSI(lpszHeaders, mpHeaders);
            fResult = HttpAddRequestHeadersA(hRequest, mpHeaders.psStr, mpHeaders.dwSize, dwModifiers);
        }
        else
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

#define DEFAULT_BEGIN_SIZE 8
#define EXPAND_SIZE 8

static const CHAR IsValidHeaderNameChar[] =
{
//  0       1       2       3       4       5       6       7
    FALSE,  FALSE,  FALSE,  FALSE,  FALSE,  FALSE,  FALSE,  FALSE,
    FALSE,  FALSE,  FALSE,  FALSE,  FALSE,  FALSE,  FALSE,  FALSE,
    FALSE,  FALSE,  FALSE,  FALSE,  FALSE,  FALSE,  FALSE,  FALSE,
    FALSE,  FALSE,  FALSE,  FALSE,  FALSE,  FALSE,  FALSE,  FALSE,

//  ' '             '"'
    FALSE,  TRUE,   FALSE,  TRUE,   TRUE,   TRUE,   TRUE,   TRUE,
//  '('     ')'                     ','                     '/'    
    FALSE,  FALSE,  TRUE,   TRUE,   FALSE,  TRUE,   TRUE,   FALSE,
    TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,
//                  ':'     ';'     '<'     '='     '>'     '?'
    TRUE,   TRUE,   FALSE,  FALSE,  FALSE,  FALSE,  FALSE,  FALSE,

//  '@'
    FALSE,  TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,
    TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,
    TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,
//                          '['     '\'     ']'
    TRUE,   TRUE,   TRUE,   FALSE,  FALSE,  FALSE,  TRUE,   TRUE,

    TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,
    TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,
    TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,
//                          '{''            '}'             DEL
    TRUE,   TRUE,   TRUE,   FALSE,  TRUE,   FALSE,  TRUE,   FALSE
};

BOOL IsValidHeaderName(LPCWSTR lpszHeaderName)
{
    WCHAR wch;
    int nIndex=0;
    
    for ( ; (wch=lpszHeaderName[nIndex]) != 0; nIndex++)
    {
        if ((wch > ARRAY_ELEMENTS(IsValidHeaderNameChar))
            || !IsValidHeaderNameChar[wch])
        {
            return FALSE;
        }
    }

    return TRUE;
}

typedef struct _headerrec
{
    LPSTR lpName;
    int nName;
    LPSTR lpValue;
    int nValue;
}
HEADER_REC;


PUBLIC
DWORD
wHttpAddRequestHeaders(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )

/*++

Routine Description:

    Worker function to append additional header(s) to an HTTP request handle

Arguents:

    hRequest        - handle of HTTP request

    lpszHeaders     - pointer to buffer containing one or more headers

    dwHeadersLength - length of lpszHeaders. Cannot be -1 at this stage

    dwModifiers     - flags controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The header string(s) was bad after all

                  ERROR_WINHTTP_INCORRECT_HANDLE_STATE
                    We can't add headers to this object at this time

                  ERROR_HTTP_HEADER_NOT_FOUND
                    We were asked to replace a header, but couldn't find it

                  ERROR_HTTP_HEADER_ALREADY_EXISTS
                    We were asked to add a header, only if one of the same name
                    doesn't already exist. It does

--*/

{
    //
    // dwHeadersLength cannot be -1 or 0 at this stage. Nor can lpszHeaders be
    // NULL
    //

    INET_ASSERT(lpszHeaders != NULL);
    INET_ASSERT(dwHeadersLength != (DWORD)-1);
    INET_ASSERT(dwHeadersLength != 0);

    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "wHttpAddRequestHeaders",
                 "%#x, %#x [%.80q], %d, %#x",
                 hRequest,
                 lpszHeaders,
                 lpszHeaders,
                 dwHeadersLength,
                 dwModifiers
                 ));

    //
    // get the underlying object and check that we can add headers
    //

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequest;
    HEADER_REC* pHeaders = NULL;
    
    DWORD error;

    if (!IS_VALID_HTTP_STATE(pRequest, ADD, TRUE))
    {
        error = ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
        goto quit;
    }

    DWORD offset;
    LPSTR header;

    offset = 0;
    header = (LPSTR)lpszHeaders;

    int nCount = DEFAULT_BEGIN_SIZE;
    pHeaders = (HEADER_REC *)ALLOCATE_FIXED_MEMORY (sizeof(HEADER_REC)*nCount);
    int nHeader = 0;
    if (!pHeaders)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    error = ERROR_SUCCESS;

    do 
    {
        //
        // first time: ignore any empty strings; subsequent time: clean off any
        // trailing line termination
        //

        while ((offset < dwHeadersLength)
        && ((lpszHeaders[offset] == '\r') || (lpszHeaders[offset] == '\n')))
        {
            ++offset;
        }
        
        if (offset == dwHeadersLength)
        {
            //
            // even if app tried adding empty line(s), we return success
            //

            error = ERROR_SUCCESS;
            break;
        }

        DWORD length;
        DWORD nameLength;
        DWORD valueLength;
        LPSTR value;

        nameLength = 0;
        valueLength = 0;
        value = NULL;

        //
        // break the header into header-name, header-value pairs. Exclude CR-LF
        // from the header-value (if present)
        //
        
        for (length = 0, header = (LPSTR)&lpszHeaders[offset];
            offset < dwHeadersLength;
            ++length, ++offset) 
        {
            char ch = header[length];

            if (ch == '\r')
            {
                //
                // end of this particular header?
                //
                if (((offset+2) < dwHeadersLength)
                    && nameLength
                    && (header[length+1] == '\n')
                    && ((header[length+2] == ' ')
                        || (header[length+2] == '\t'))
                   )
                {
                    //LWS allowing header to spill over to next line
                    length+=2;
                    offset+=2;
                }
                else
                {
                    break;
                }
            }
            else if (ch == '\n')
            {
                //
                // end of this particular header?
                //
                break;
            }
            else if (ch == ':')
            {
                if (nameLength == 0) 
                {
                    //
                    // found end of header name
                    //

                    nameLength = length;
                    value = &header[length];
                }
            }

            if (nameLength == 0)
            {
                if ((ch > ARRAY_ELEMENTS(IsValidHeaderNameChar))
                    || !IsValidHeaderNameChar[ch])
                {
                    error = ERROR_INVALID_PARAMETER;
                    goto quit;
                }
            }
        }
        
        if (length == 0)
        {
            //
            // empty string
            //

            continue;
        }
        else if (nameLength == 0)
        {
            //
            // entry consists of just header-name (e.g. "Accept[\r\n]")
            //

            nameLength = length;
        }
        else
        {
            //
            // find the start of the header-value
            //

            valueLength = (DWORD) (header + length - value);

            //ideally we wouldn't eat through all the leading white space or : in the
            // header value because they may be significant.
            // Don't know of any examples though, so can keep it as such.
            //
            // N.B. We are allowing any mixture of ':' and ' ' between header
            // name and value, but this is probably not a big deal...
            //

            while ((*value == ':') || (*value == ' ') && (valueLength != 0))
            {
                ++value;
                --valueLength;
            }
        }

        if (!value
            && !(dwModifiers & (HTTP_ADDREQ_FLAG_REPLACE | HTTP_ADDREQ_FLAG_ADD_IF_NEW)))
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        pHeaders[nHeader].lpName = header;
        pHeaders[nHeader].nName = nameLength;
        pHeaders[nHeader].lpValue = value;
        pHeaders[nHeader].nValue = valueLength;

        if (++nHeader >= nCount)
        {
            nCount += EXPAND_SIZE;

			HEADER_REC* pNewHeaders = (HEADER_REC *)REALLOCATE_MEMORY(pHeaders, sizeof(HEADER_REC)*nCount);

            if (pNewHeaders)
				pHeaders = pNewHeaders;
			else
            {
				FREE_MEMORY(pHeaders);
				pHeaders = NULL;
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
        }
    }
    while (error == ERROR_SUCCESS);

    for (int nIndex=0; nIndex<nHeader; nIndex++)
    {    
        if (dwModifiers
            & (HTTP_ADDREQ_FLAG_REPLACE | HTTP_ADDREQ_FLAG_ADD_IF_NEW))
        {
            //
            // replace or remove the header
            //

            error = pRequest->ReplaceRequestHeader(
                                pHeaders[nIndex].lpName,
                                pHeaders[nIndex].nName,
                                pHeaders[nIndex].lpValue,
                                pHeaders[nIndex].nValue,
                                dwModifiers & HTTP_ADDREQ_INDEX_MASK,
                                dwModifiers & HTTP_ADDREQ_FLAGS_MASK
                                );
        }
        else
        {
            //
            // add a single, unterminated header string to the request headers.
            // Since these headers came from the app, we don't trust it to get
            // the header termination right (number & type of line terminators)
            // so we add it ourselves
            //

            error = pRequest->AddRequestHeader(
                                pHeaders[nIndex].lpName,
                                pHeaders[nIndex].nName,
                                pHeaders[nIndex].lpValue,
                                pHeaders[nIndex].nValue,
                                dwModifiers & HTTP_ADDRE