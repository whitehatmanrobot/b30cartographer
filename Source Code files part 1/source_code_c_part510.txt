"-COInetProtSnk::ReportProgress (pwzStatusText:%ws, hr:%lx)", pwzStatusText, hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProtSnk::ReportData
//
//  Synopsis:
//
//  Arguments:  [grfBSCF] --
//              [ULONG] --
//              [ulProgressMax] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProtSnk::ReportData(DWORD grfBSCF, ULONG ulProgress,ULONG ulProgressMax)
{
    PerfDbgLog3(tagCTransaction, this, "+COInetProtSnk::ReportData(grfBSCF:%lx, ulProgress:%ld, ulProgressMax:%ld)",
                                       grfBSCF, ulProgress, ulProgressMax);
    HRESULT hr = NOERROR;

    hr = _pProtSnk->ReportData( grfBSCF, ulProgress, ulProgressMax);
  
    PerfDbgLog1(tagCTransaction, this, "-COInetProtSnk::ReportData (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProtSnk::ReportResult
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [dwError] --
//              [wzResult] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProtSnk::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR wzResult)
{
    PerfDbgLog(tagCTransaction, this, "+COInetProtSnk::ReportResult");
    HRESULT hr = NOERROR;

    hr = _pProtSnk->ReportResult(hrResult, dwError, wzResult);
    
    PerfDbgLog1(tagCTransaction, this, "-COInetProtSnk::ReportResult (hr:%lx)", hr);
    return hr;
}
#endif // 0
//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    PerfDbgLog(tagCTransaction, this, "+COInetProt::QueryInterface");

    *ppvObj = NULL;

    if (_pUnk)
    {
        hr = _pUnk->QueryInterface(riid, ppvObj);
    }
    else
    {
        if (   (riid == IID_IUnknown)
            || (riid == IID_IOInetProtocol))
        {
            *ppvObj = (IOInetProtocol *) this;
            AddRef();
        }
        else if (riid == IID_IOInetProtocolSink)
        {
            *ppvObj = (IOInetProtocolSink *) this;
            AddRef();
        }
        else if (riid == IID_IServiceProvider)
        {
            *ppvObj = (IServiceProvider *) this;
            AddRef();
        }
        else if (riid == IID_IOInetPriority)
        {
            *ppvObj = (IOInetPriority *) this;
            AddRef();
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }


    PerfDbgLog1(tagCTransaction, this, "-COInetProt::QueryInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetProt::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetProt::AddRef(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "COInetProt::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::AddRef");

    LONG lRet;
    
    if (_pUnk)
    {
        lRet = _pUnk->AddRef();
    }
    else
    {
        lRet = ++_CRefs;
    }
    
    PerfDbgLog1(tagCTransaction, this, "-COInetProt::AddRef (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetProt::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetProt::Release(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "COInetProt::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Release");

    LONG lRet;
    if (_pUnk)
    {
        lRet = _pUnk->Release();
    }
    else
    {
        lRet = --_CRefs;
        if (_CRefs == 0)
        {
            //
            // release all objects
            if (_pProtSnk)
            {
                _pProtSnk->Release();
            }
            if (_pProt)
            {
                _pProt->Release();
            }

            if (_dwMode & PP_DELETE)
            {
                delete this;
            }
        }
    }

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Release (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pOInetProtSnk, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD_PTR dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolRoot::Start",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x",
                this, pwzUrl, pOInetProtSnk, pOIBindInfo, grfSTI, dwReserved
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Start\n");
    HRESULT hr = NOERROR;

    TransAssert((pOIBindInfo && pOInetProtSnk && pwzUrl));

    // Just before starting the transaction give it the priority.

    IOInetPriority * pOInetPriority = NULL;
    if (_pProt->QueryInterface(IID_IOInetPriority, (void **) &pOInetPriority) == S_OK)
    {
        pOInetPriority->SetPriority(_nPriority);
        pOInetPriority->Release();
    }

    delete [] _pwzUrl;
    _pwzUrl = OLESTRDuplicate(pwzUrl);

    hr = _pProt->Start(pwzUrl, pOInetProtSnk, pOIBindInfo, grfSTI, dwReserved);
    
    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Start (hr:%lx)\n", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Continue(PROTOCOLDATA *pStateInfoIn)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolRoot::Continue",
                "this=%#x, %#x",
                this, pStateInfoIn
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Continue\n");

    HRESULT hr = _pProt->Continue(pStateInfoIn);

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Continue (hr:%lx)\n",hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Abort
//
//  Synopsis:
//
//  Arguments:  [hrReason] --
//              [dwOptions] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Abort(HRESULT hrReason, DWORD dwOptions)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolRoot::Abort",
                "this=%#x, %#x, %#x",
                this, hrReason, dwOptions
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Abort\n");
    HRESULT hr = NOERROR;

    hr = _pProt->Abort(hrReason, dwOptions);

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Abort (hr:%lx)\n", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Terminate
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Terminate(DWORD dwOptions)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolRoot::Terminate",
                "this=%#x, %#x",
                this, dwOptions
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Terminate\n");
    HRESULT hr = NOERROR;

    TransAssert((_pProt));
    
    hr = _pProt->Terminate(dwOptions);
    SetProtocolSink(0);
    SetServiceProvider(0);

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Terminate (hr:%lx)\n", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Suspend
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Suspend()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolRoot::Suspend",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Suspend\n");

    HRESULT hr = _pProt->Suspend();

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Suspend (hr:%lx)\n", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Resume
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Resume()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolRoot::Resume",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Resume\n");

    HRESULT hr = _pProt->Resume();

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Resume (hr:%lx)\n", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Read(void *pBuffer, ULONG cbBuffer,ULONG *pcbRead)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocol::Read",
                "this=%#x, %#x, %#x, %#x",
                this, pBuffer, cbBuffer, pcbRead
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Read\n");
    HRESULT     hr = E_FAIL;

    BOOL fRead = TRUE;
    DWORD dwCopy = 0;
    DWORD dwCopyNew = 0;

    if ((_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP))
        && _cbBufferUnread)
    {
        fRead = FALSE;

        // copy data form the local buffer to the provide buffer
        if (cbBuffer <= _cbBufferUnread)
        {
            dwCopy = cbBuffer;
            hr = S_OK;
        } 
        else
        {
            dwCopy = _cbBufferUnread;
            fRead = TRUE;
        }
        memcpy(pBuffer, _pBuffer+(_cbBufferFilled-_cbBufferUnread), dwCopy);
        _cbBufferUnread -= dwCopy;
    }

    if (fRead)
    {
        if (_pProt)
        {
            hr = _pProt->Read( ((LPBYTE)pBuffer) + dwCopy, cbBuffer - dwCopy, &dwCopyNew);
            _cbTotalBytesRead += dwCopyNew;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    if (pcbRead)
    {
        *pcbRead = dwCopy + dwCopyNew;
    }
 

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Read (hr:%lx)\n",hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocol::Seek",
                "this=%#x, %#x, %#x, %#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Seek\n");

    HRESULT hr = _pProt->Seek(dlibMove, dwOrigin, plibNewPosition);

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Seek (hr:%lx)\n", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::LockRequest(DWORD dwOptions)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocol::LockRequest",
                "this=%#x, %#x",
                this, dwOptions
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::LockRequest\n");

    HRESULT hr = hr = _pProt->LockRequest(dwOptions);

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::LockRequest (hr:%lx)\n",hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::UnlockRequest()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocol::UnlockRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::UnlockRequest\n");
    HRESULT hr = NOERROR;

    hr = _pProt->UnlockRequest();

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::UnlockRequest (hr:%lx)\n", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::OnDataReceived
//
//  Synopsis:
//
//  Arguments:  [grfBSC] --
//              [cbBytesAvailable] --
//              [dwTotalSize] --
//              [pcbNewAvailable] --
//
//  Returns:
//
//  History:    4-15-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::OnDataReceived(DWORD *pgrfBSC, DWORD *pcbBytesAvailable, DWORD *pdwTotalSize)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::OnDataReceived",
                "this=%#x, %#x, %#x, %#x",
                this, pgrfBSC, pcbBytesAvailable, pdwTotalSize
                ));
                
    PerfDbgLog3(tagCTransaction, this, "+COInetProt::OnDataReceived (grfBSC:%lx,  *pcbBytesAvailable:%ld, _cbTotalBytesRead:%ld)",
                                    *pgrfBSC, *pcbBytesAvailable, _cbTotalBytesRead);
    HRESULT hr = NOERROR;
    DWORD grfBSC = *pgrfBSC;
    BOOL fEndOfData = FALSE;
    
    if (_fWaitOnHandler)
    {
        hr = S_NEEDMOREDATA;
    }
    else if (  
        ((_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP | PI_CLASSINSTALL))
            && (!_fMimeVerified || _fNeedMoreData))
        ||
        ((_dwOInetBdgFlags & PI_CLASSINSTALL) && !_fClassInstallChecked)
            )
    {
        DWORD dwNewData = 0;
        TransAssert((_pProt && _cbDataSniffMin));

        //TransAssert((pcbBytesAvailable && *pcbBytesAvailable)); 
        //TransAssert((pdwTotalSize));

        // _cbTotalBytesRead = # of bytes read so far
        if (_cbBufferFilled < _cbDataSniffMin)
        {
            // no bytes read so far
            TransAssert((_cbTotalBytesRead < _cbDataSniffMin));
            // read data into buffer and report progess
            do
            {
                PProtAssert((_pBuffer && (_pBuffer + _cbBufferFilled) ));
                hr = _pProt->Read(_pBuffer + _cbBufferFilled, _cbBufferSize - _cbBufferFilled, &dwNewData);
                _cbTotalBytesRead += dwNewData;
                _cbBufferFilled += dwNewData;
                _cbBufferUnread += dwNewData;
            } while ((hr == S_OK) && (_cbBufferFilled < _cbDataSniffMin));

            // now check if this is docfile
            // if so download at least 2k
            if (!_fDocFile && _cbBufferFilled && (IsDocFile(_pBuffer, _cbBufferFilled) == S_OK))
            {
                _fDocFile = TRUE;
                
                // we may need to sniff to maximum to find handler

                if (_cbBufferSize < DATASNIFSIZEDOCFILE_MAX)
                {
                    LPBYTE pBufferTemp;

                    pBufferTemp = (LPBYTE) new BYTE[DATASNIFSIZEDOCFILE_MAX];
                    if (pBufferTemp)
                    {
                        memcpy(pBufferTemp, _pBuffer, _cbBufferFilled);
                        delete [] _pBuffer;
                        _pBuffer = pBufferTemp;
                        _cbBufferSize = DATASNIFSIZEDOCFILE_MAX;
                        
                        if (hr == NOERROR)
                        {
                            //since we increased the buffersize and we want to drain DATASNIFSIZEDOCFILE_MAX bytes.
                            do
                            {
                                PProtAssert((_pBuffer && (_pBuffer + _cbBufferFilled) ));
                                hr = _pProt->Read(_pBuffer + _cbBufferFilled, _cbBufferSize - _cbBufferFilled, &dwNewData);
                                _cbTotalBytesRead += dwNewData;
                                _cbBufferFilled += dwNewData;
                                _cbBufferUnread += dwNewData;
                            } while ((hr == S_OK) && (_cbBufferFilled < _cbBufferSize));                       
                        }
                    }
                }
                
                _cbDataSniffMin =  (*pdwTotalSize && *pdwTotalSize < _cbBufferSize) ? *pdwTotalSize : _cbBufferSize;                    
            }

            if ((hr == E_PENDING) && (_cbBufferFilled < _cbDataSniffMin))
            {
                // do not report anything - wait until we get more data
                // a request is pending at this time
                // need more data to sniff properly
                hr  = S_NEEDMOREDATA;
            }
            else if (hr == NOERROR || hr == E_PENDING)
            {
                TransAssert((_cbTotalBytesRead != 0));

                // report the data we have in the buffer or
                // the available #
                DWORD cbBytesReport =  (*pcbBytesAvailable > _cbTotalBytesRead) ? *pcbBytesAvailable : _cbTotalBytesRead + 1;

                if (*pdwTotalSize && ((cbBytesReport > *pdwTotalSize)))
                {
                    cbBytesReport = *pdwTotalSize;
                }
                *pcbBytesAvailable = cbBytesReport;
            }
            else if (hr == S_FALSE)
            {
                // end of stream
                *pgrfBSC |=  (BSCF_LASTDATANOTIFICATION & BSCF_DATAFULLYAVAILABLE);
                *pcbBytesAvailable = *pdwTotalSize =  _cbTotalBytesRead;
                fEndOfData = TRUE;
            }
            
            if (   (!_fMimeVerified)
                && (   (*pcbBytesAvailable >= _cbDataSniffMin)
                    || (hr == S_FALSE)) )
            {
                // enough data or end of stream
                _fMimeVerified = TRUE;
                LPWSTR  pwzStr = 0;
                DWORD dwMimeFlags = FMFD_DEFAULT;
                if( !_pwzFileName )
                {
                    dwMimeFlags = FMFD_URLASFILENAME;        
                }
                hr = FindMimeFromData(NULL, (_pwzFileName) ? _pwzFileName : _pwzUrl, _pBuffer, _cbBufferFilled, _pwzMimeSuggested, dwMimeFlags, &pwzStr, 0);

                TransAssert(pwzStr);

                // note: _pwzUrl & _pwzFileName may be used later for composing URL
                //       in code base attribute of active document (deleted in destructor)
                
                if (pwzStr)
                {
                    _fMimeReported = 1;
                    _pProtSnk->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pwzStr);
                }
                else
                {
                    TransAssert((!_pwzMimeSuggested));
                }

                if (pwzStr)
                {
                    delete [] _pwzMimeSuggested;
                    _pwzMimeSuggested = pwzStr;
                    pwzStr = 0;
                }

                if (   _fDocFile
                    && (_dwOInetBdgFlags & PI_DOCFILECLSIDLOOKUP))
                {
                    // find the class id and send it on
                    CLSID clsid;

                    HRESULT hr1 = GetClassDocFileBuffer(_pBuffer, _cbBufferFilled, &clsid);
                    if (hr1 == NOERROR)
                    {
                        if (_pwzStrClsId)
                        {
                            delete [] _pwzStrClsId;
                            _pwzStrClsId = NULL;
                        }
                        StringFromCLSID(clsid, &_pwzStrClsId);
                        if (_pwzStrClsId)
                        {
                            _fReportedClassId = TRUE;
                            _pProtSnk->ReportProgress(BINDSTATUS_CLASSIDAVAILABLE, _pwzStrClsId);
                        }
                    }
                }
            }
        }

        //On a BTS->BTO scenario, we should get into this loop with the lesser of DATASNIFSIZEDOCFILE_MIN or TOTAL_SIZE.
        //On a BTO scenario, the situation is the same as before, except hr=S_NEEDMOREDATA if size<DATASNIF_MIN.
        //On a BTS scenario, this block will not be entered.
        if (   (_dwOInetBdgFlags & PI_CLASSINSTALL)
            && !_fGotHandler )
        {
            _fClassInstallChecked = TRUE;
            
            BOOL fIgnoreMimeClsid = FALSE;
            DWORD dwVersionMS = 0, dwVersionLS = 0;
            LPWSTR pwzCodeBase = 0, pwzVerInfo = 0;
            CLSID clsid;
            HRESULT hr1;

            if (!_fReportedClassId && _pwzStrClsId && _pProtSnk)
            {
                _fReportedClassId = TRUE;
                _pProtSnk->ReportProgress(BINDSTATUS_CLASSIDAVAILABLE, _pwzStrClsId);
            }
            
            if (IsHandlerAvailable((_pwzFileName) ? _pwzFileName : _pwzUrl, _pwzMimeSuggested, &clsid, _pBuffer, _cbBufferFilled) == S_OK)
            {
                _fGotHandler = TRUE;
            }
            else if (_fDocFile)
            {
                // try get code base + version information
                // even if handler is installed, a newer version may be required for this doc file

                hr1 = GetCodeBaseFromDocFile(_pBuffer, _cbBufferFilled, &pwzCodeBase, _pwzUrl, &dwVersionMS, &dwVersionLS);

                // convert version info. to string
                if (SUCCEEDED(hr1) && (dwVersionMS || dwVersionLS))
                {
                    CHAR szVerInfo[MAX_PATH];

                    wsprintfA(szVerInfo,"%ld,%ld", dwVersionMS, dwVersionLS);
                    pwzVerInfo = DupA2W(szVerInfo);
                }
                
                // if failed to get codebase, keep sniffing
                // if we are at end of bits then go with out a code base

                _fNeedMoreData = FAILED(hr1) && (_cbBufferFilled < _cbDataSniffMin) && (!fEndOfData);
            }

            //BUGBUG #51944: This currently requires a DocFile and CodeBase property

            if (!_fNeedMoreData && !_fGotHandler && _fDocFile && pwzCodeBase)
            {
                LPOLESTR pwzClsId = 0;

                if (!IsEqualCLSID(clsid, CLSID_NULL))
                {
                    StringFromCLSID(clsid, &pwzClsId);
                }
                else if (_pwzMimeSuggested)
                {
                    // this is an optimization, if no CLSID and only this as mime type
                    // then we won't find anything in ObjectStore
                    if (!StrCmpNIW(_pwzMimeSuggested, L"application/octet-stream", 24))
                    {
                        _fGotHandler = TRUE;
                    }
                }

                if (!_fGotHandler && (pwzClsId || _pwzMimeSuggested))
                {
                    LPWSTR pwzClassStr = 0;
                    int cbClassStr;

                    cbClassStr = (pwzCodeBase ? lstrlenW(pwzCodeBase) : 0)
                        + (pwzClsId ? lstrlenW(pwzClsId) : 0)
                        + (_pwzMimeSuggested ? lstrlenW(_pwzMimeSuggested) : 0)
                        + (pwzVerInfo ? (lstrlenW(pwzVerInfo) + 1) : 0)
                        + 3;

                    pwzClassStr = new WCHAR[cbClassStr];

                    if (pwzClassStr)
                    {
                        //BUGBUG: This is a bit of a hack, we have a collection of
                        //info to pass into filter, we concatenate it into one long
                        //string and send it in.

                        *pwzClassStr = '\0';
                        if (pwzCodeBase && *pwzCodeBase)
                        {
                            StrCpyW(pwzClassStr, pwzCodeBase);
                        }

                        StrCatW(pwzClassStr, L"?");

                        if (pwzClsId)
                        {
                            StrCatW(pwzClassStr, pwzClsId);
                        }
                        else if (_pwzMimeSuggested)
                        {
                            StrCatW(pwzClassStr, _pwzMimeSuggested);
                        }

                        if (pwzVerInfo)
                        {
                            StrCatW(pwzClassStr, L"?");
                            StrCatW(pwzClassStr, pwzVerInfo);
                        }                               
                    
                        _pCTrans->ReportProgress(BINDSTATUS_CLASSINSTALLLOCATION, 
                                        pwzClassStr);

                        delete [] pwzClassStr;

                        // don't process this code branch again
                        _fGotHandler = TRUE;

                        // wait on more data now
                        hr = S_NEEDMOREDATA;

                       // wait on more data for future calls
                        _fWaitOnHandler = TRUE;

                        // wait for more data to sniff
                        _fNeedMoreData = TRUE;

                    }

                    delete [] pwzClsId;

                } // pwzClsId || _pwzMimeSuggested
            } // !_fNeedMoreData

            if (pwzCodeBase)
            {
                CoTaskMemFree(pwzCodeBase);
            }

            if (pwzVerInfo)
            {
                delete [] pwzVerInfo;
            }

            // if we don't need to sniff any more, curb _cbDataSniffMin
            if (_fDocFile && _fGotHandler)
            {   
                _cbDataSniffMin =  (*pdwTotalSize && *pdwTotalSize < DATASNIFSIZEDOCFILE_MIN) ? *pdwTotalSize : DATASNIFSIZEDOCFILE_MIN;
            }

            // once we have a handler we can release pwzUrl & pwzFilename
            if (_fGotHandler)
            {
                delete [] _pwzUrl;
                _pwzUrl = 0;
                delete [] _pwzFileName;
                _pwzFileName = 0;
            }

            // report the data we have in the buffer or
            // the available #
            *pcbBytesAvailable =  (*pcbBytesAvailable > _cbTotalBytesRead) ? *pcbBytesAvailable : _cbTotalBytesRead + 1;
        }  // PI_CLASSINSTALL && !_fGotHandler
  
        if (*pdwTotalSize && (*pdwTotalSize < *pcbBytesAvailable))
        {
            *pcbBytesAvailable = *pdwTotalSize;
        }
        
        if (hr == S_FALSE)
        {
            hr = NOERROR;
        }
    }
    
    {
        CLock lck(_mxs);
        _cbBytesReported = *pcbBytesAvailable;
    }
    //TransAssert((pcbBytesAvailable && *pcbBytesAvailable)); 
    //TransAssert((hr == NOERROR || hr == S_NEEDMOREDATA));

    PerfDbgLog2(tagCTransaction, this, "-COInetProt::OnDataReceived (hr:%lx, _cbBufferFilled:%ld)", hr, _cbBufferFilled);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Switch
//
//  Synopsis:
//
//  Arguments:  [pStateInfo] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Switch(PROTOCOLDATA *pStateInfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolSink::Switch",
                "this=%#x, %#x",
                this, pStateInfo
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Switch");
    HRESULT hr = NOERROR;

    hr = _pProtSnk->Switch(pStateInfo);
   
    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Switch (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::ReportProgress
//
//  Synopsis:
//
//  Arguments:  [NotMsg] --
//              [szStatusText] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::ReportProgress(ULONG NotMsg, LPCWSTR pwzStatusText)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolSink::ReportProgress",
                "this=%#x, %#x, %.80wq",
                this, NotMsg, pwzStatusText
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::ReportProgress");
    HRESULT hr = NOERROR;

    switch (NotMsg)
    {
    case BINDSTATUS_FILTERREPORTMIMETYPE:
    {
        if( _pCTrans && pwzStatusText )
        {
            // mime filter sending signal to tell us the true mime type
            _pCTrans->UpdateVerifiedMimeType(pwzStatusText);
        }
        
    }
    break;


    case BINDSTATUS_MIMETYPEAVAILABLE:
        if (_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP | PI_CLASSINSTALL))
        {
            // report the mime later after sniffing data
            _pwzMimeSuggested = OLESTRDuplicate(pwzStatusText);
        }
        else
        {
            hr = _pProtSnk->ReportProgress(NotMsg, pwzStatusText);
        }

    break;

    case BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE:
    {
        // disable mime sniffing
        _dwOInetBdgFlags &= (~PI_MIMEVERIFICATION &~PI_DOCFILECLSIDLOOKUP &~PI_CLASSINSTALL);
        hr = _pProtSnk->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pwzStatusText);

    }
    break;

    case BINDSTATUS_CACHEFILENAMEAVAILABLE :
        _pwzFileName = OLESTRDuplicate(pwzStatusText);
        hr = _pProtSnk->ReportProgress(NotMsg, pwzStatusText);
    break;

    case BINDSTATUS_DIRECTBIND:
        _fMimeVerified = TRUE;
    break;
    
    case BINDSTATUS_ENDDOWNLOADCOMPONENTS :
        if (_fWaitOnHandler)
        {
            // don't stall ReportData any more
            _fWaitOnHandler = FALSE;

            // we're done with our stuff, skip sniffing
            _fNeedMoreData = FALSE;
           
        }


    default:
    {
        hr = _pProtSnk->ReportProgress(NotMsg, pwzStatusText);
    }

    } // end switch
    
    PerfDbgLog1(tagCTransaction, this, "-COInetProt::ReportProgress (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::ReportData
//
//  Synopsis:
//
//  Arguments:  [grfBSCF] --
//              [ULONG] --
//              [ulProgressMax] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::ReportData(DWORD grfBSCF, ULONG ulProgress,ULONG ulProgressMax)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolSink::ReportData",
                "this=%#x, %#x, %#x, %#x",
                this, grfBSCF, ulProgress, ulProgressMax
                ));
                
    PerfDbgLog3(tagCTransaction, this, "+COInetProt::ReportData(grfBSCF:%lx, ulProgress:%ld, ulProgressMax:%ld)",
                                       grfBSCF, ulProgress, ulProgressMax);
    HRESULT hr = NOERROR, hr2;

    TransAssert((ulProgress));

    if (   ((_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP | PI_CLASSINSTALL))
        && (!_fMimeVerified || _fNeedMoreData))
        ||
            ((_dwOInetBdgFlags & PI_CLASSINSTALL) && !_fClassInstallChecked)
       )
    {
        if (   (OnDataReceived(&grfBSCF, &ulProgress, &ulProgressMax) == NOERROR)
            && _pProtSnk 
            && (ulProgress || (!ulProgress && !ulProgressMax)) )
        {
            // OnDataReceived sniffs data and calls Read - EOF with ReportResult might occure
            //TransAssert((ulProgress));
            TransAssert((_fMimeReported));
            hr = _pProtSnk->ReportData( grfBSCF, ulProgress, ulProgressMax);
        }
    }
    else 
    {
        TransAssert((ulProgress));
        hr = _pProtSnk->ReportData( grfBSCF, ulProgress, ulProgressMax);
    }

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::ReportData (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::ReportResult
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [dwError] --
//              [wzResult] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR wzResult)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolSink::ReportResult",
                "this=%#x, %#x, %#x, %.80wq",
                this, hrResult, dwError, wzResult
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::ReportResult");
    HRESULT hr = NOERROR;

    hr = _pProtSnk->ReportResult(hrResult, dwError, wzResult);
    
    PerfDbgLog1(tagCTransaction, this, "-COInetProt::ReportResult (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Initialize
//
//  Synopsis:
//
//  Arguments:  [pCTrans] --
//              [dwMode] --
//              [dwOptions] --
//              [pUnk] --
//              [pProt] --
//              [pProtSnk] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Initialize(CTransaction *pCTrans,IServiceProvider *pSrvPrv, DWORD dwMode, DWORD dwOptions, 
                                    IUnknown *pUnk, IOInetProtocol *pProt, IOInetProtocolSink *pProtSnk, LPWSTR pwzUrl)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::Initialize",
                "this=%#x, %#x, %#x, %#x, %#x, %#x, %#x, %#x, %.80wq",
                this, pCTrans, pSrvPrv, dwMode, dwOptions, pUnk, pProt, pProtSnk, pwzUrl
                ));
                
    HRESULT hr = NOERROR;
    _dwMode = dwMode;
    _pUnk = pUnk;
    //_pProt = pProt;
    //_pProtSnk = pProtSnk;
    _pCTrans = pCTrans;
    _pSrvPrv = pSrvPrv;
    if (_pSrvPrv)
    {
        _pSrvPrv->AddRef();
    }
    SetProtocolSink(pProtSnk);
    SetProtocol(pProt);
    
    _dwOInetBdgFlags = dwOptions;
    if (_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP))
    {
        ULONG cbBufferSize;
        
        TransAssert(( DATASNIFSIZE_MIN <= DATASNIFSIZEDOCFILE_MIN));

        if (_dwOInetBdgFlags & PI_CLASSINSTALL)
        {
            cbBufferSize = DATASNIFSIZEDOCFILE_MAX;
        }
        else
        {
            cbBufferSize = DATASNIFSIZEDOCFILE_MIN; //DATASNIFSIZE_MIN; 
        }

        if (cbBufferSize != _cbBufferSize)
        {
            _cbBufferSize = cbBufferSize;
            delete [] _pBuffer;
            _pBuffer = (LPBYTE) new BYTE[_cbBufferSize];
        }

        if (!_pBuffer)
        {
            _cbBufferSize = 0;
            hr = E_OUTOFMEMORY;
        }
        else
        {
            _cbDataSniffMin = DATASNIFSIZE_MIN;
        }
        
        if (pwzUrl)
        {
            delete [] _pwzUrl;
            _pwzUrl = OLESTRDuplicate(pwzUrl);
        }

    }
    TransAssert((_pProt && _pProtSnk));

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::QueryService
//
//  Synopsis:
//
//  Arguments:  [rsid] --
//              [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT IUnknown_QueryService(IUnknown* punk, REFGUID rsid, REFIID riid, void ** ppvObj);

HRESULT COInetProt::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IServiceProvider::QueryService",
                "this=%#x, %#x, %#x, %#x",
                this, &rsid, &riid, ppvObj
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::QueryService");
    HRESULT     hr = NOERROR;
    VDATETHIS(this);
    TransAssert((ppvObj));

    if (_pSrvPrv)
    {
        hr = _pSrvPrv->QueryService(rsid,riid, ppvObj);
    }
    else
    {
        hr = IUnknown_QueryService(_pProtSnk, rsid, riid, ppvObj);
    }

    TransAssert(( ((hr == E_NOINTERFACE) && !*ppvObj)  || ((hr == NOERROR) && *ppvObj) ));

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::QueryService (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP COInetProt::SetPriority(LONG nPriority)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetPriority::SetPriority",
                "this=%#x, %#x",
                this, nPriority
                ));
                
    PerfDbgLog1(tagCTransaction, this, "+COInetProt::SetPriority (%ld)", nPriority);

    HRESULT hr = S_OK;

    _nPriority = nPriority;

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::SetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP COInetProt::GetPriority(LONG * pnPriority)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetPriority::GetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::GetPriority");

    HRESULT hr;

    if (!pnPriority)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pnPriority = _nPriority;
        hr = S_OK;
    }

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::GetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\precomp1.inc ===
#//+---------------------------------------------------------------
#//
#//  File:      precomp1.inc
#//
#//  Contents:  directives for global precompiled include file when the
#//             sources file is two directories below com (or wherever
#//             this file is located).  We could easily have precomp3 and
#//             precomp4 for other areas.The urlint.* files should not
#//             otherwise be mentioned in the sources files.
#//
#//
#//----------------------------------------------------------------

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\..\inc\trans.h
PRECOMPILED_TARGET=$(GPCH_BUILD)\$(_OBJ_DIR)\*\trans.pch
PRECOMPILED_OPTION=/Yutrans.h /Fp$(GPCH_BUILD)\$(_OBJ_DIR)\*\trans.pch
PRECOMPILED_OBJ=$(GPCH_BUILD)\$(_OBJ_DIR)\*\trans.obj


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\oinet.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       oinet.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#include "oinet.hxx"
#ifndef unix
#include "..\mon\urlcf.hxx"
#else
#include "../mon/urlcf.hxx"
#endif /* unix */
#define BREAK_ONERROR(hrBreak) if (FAILED(hrBreak)) { break; }

PerfDbgTag(tagCOInetSession, "Urlmon", "Log COInetSession", DEB_SESSION);

COInetSession *g_pCOInetSession = 0;
CMutexSem      g_mxsOInet;       // single access to media holder

#define SESSIONOPTIONF_SHORTCIRCUIT_KNOWN_PROTOCOLS      (0x00000040)
BYTE           g_bShortcircuitKnownProtocols = TRUE;

typedef enum _tagOISM_FLAG
{
    OISM_NOADDREF = 0x00000001
} OISM_FLAGS;

extern BOOL  g_bCanUseSimpleBinding;
extern LONG g_cTransLevelHandler;


//+---------------------------------------------------------------------------
//
//  Function:   CoInternetGetSession
//
//  Synopsis:   exported API
//
//  Arguments:  [ppOInetSession] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-14-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoInternetGetSession(DWORD dwMode, IOInetSession **ppOInetSession, DWORD dwReserved)
{
    DEBUG_ENTER_API((DBG_TRANS,
                    Hresult,
                    "CoInternetGetSession",
                    "%#x, %#x, %#x",
                    dwMode, ppOInetSession, dwReserved
                    ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCOInetSession, NULL, "+CoInternetGetSession");

    COInetSession *pCOInetSession = 0;

    hr = GetCOInetSession(dwMode, &pCOInetSession, dwReserved);
    if (hr == NOERROR )
    {
        *ppOInetSession = (IOInetSession *)pCOInetSession;
    }

    PerfDbgLog1(tagCOInetSession, NULL, "-CoInternetGetSession (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteOInetSession
//
//  Synopsis:   deletes the global OInetSession
//              called by tls.cxx
//
//  Arguments:  [dwReserved] --
//
//  Returns:
//
//  History:    1-22-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT DeleteOInetSession(DWORD dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "DeleteOInetSession",
                "%#x",
                dwReserved
                ));
                    
    PerfDbgLog(tagCOInetSession, NULL, "+DeleteOInetSession");
    HRESULT hr = NOERROR;
    CLock lck(g_mxsOInet);

    if (g_pCOInetSession)
    {
        delete g_pCOInetSession;
        g_pCOInetSession = 0;
    }

    PerfDbgLog1(tagCOInetSession, NULL, "-DeleteOInetSession (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetOInetSession
//
//  Synopsis:
//
//  Arguments:  [dwMode] --
//              [ppOInetSession] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetCOInetSession(DWORD dwMode, COInetSession **ppOInetSession, DWORD dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "GetCOInetSession",
                "%#x, %#x, %#x",
                dwMode, ppOInetSession, dwReserved
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCOInetSession, NULL, "+GetOInetSession");
    CLock lck(g_mxsOInet);

    TransAssert(( (ppOInetSession != NULL) && (dwReserved == 0) && "Invalid argument"));

    if (ppOInetSession && !dwReserved)
    {
        if (g_pCOInetSession == 0)
        {
            hr = COInetSession::Create(0, &g_pCOInetSession);
        }

        if (g_pCOInetSession)
        {
            if (!(dwMode & OISM_NOADDREF))
            {
                g_pCOInetSession->AddRef();
            }

            *ppOInetSession = g_pCOInetSession;
        }
        else
        {
            hr =  E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog1(tagCOInetSession, NULL, "-GetOInetSession (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::Create
//
//  Synopsis:
//
//  Arguments:  [dwMode] --
//              [ppCOInetSession] --
//
//  Returns:
//
//  History:    11-15-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT COInetSession::Create(DWORD dwMode, COInetSession **ppCOInetSession)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::Create",
                "%#x, %#x",
                dwMode, ppCOInetSession
                ));
                
    PerfDbgLog(tagCOInetSession, NULL, "+GetOInetSession::Create");
    HRESULT hr = NOERROR;

    COInetSession *pSes = 0;

    TransAssert(( (ppCOInetSession != NULL) && (dwMode == 0) && "Invalid argument"));

    if (ppCOInetSession)
    {
        pSes = new COInetSession();

        if (pSes)
        {
            *ppCOInetSession = pSes;
        }
        else
        {
            hr =  E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog1(tagCOInetSession, NULL, "-GetOInetSession::Create (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::QueryInterface");
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    *ppvObj = NULL;
    if ((riid == IID_IUnknown) || (riid == IID_IOInetSession) )
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::QueryInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetSession::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetSession::AddRef(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "COInetSession::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    LONG lRet = ++_CRefs;
    PerfDbgLog1(tagCOInetSession, this, "COInetSession::AddRef (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetSession::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetSession::Release(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "COInetSession::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        // this is global
        //delete this;
    }

    PerfDbgLog1(tagCOInetSession, this, "COInetSession::Release (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::RegisterNameSpace
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//              [ULONG] --
//              [cProtocols] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::RegisterNameSpace(IClassFactory *pCF, REFCLSID rclsid, LPCWSTR pszProtocol,
                                               ULONG  cPatterns, const LPCWSTR *ppwzPatterns, DWORD dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetSession::RegisterNameSpace",
                "this=%#x, %#x, %#x, %.80wq, %#x, %#x, %#x",
                this, pCF, &rclsid, pszProtocol, cPatterns, ppwzPatterns, dwReserved
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::RegisterNameSpace");
    HRESULT hr = E_NOTIMPL;

    hr = _CProtMgrNameSpace.Register(pCF,rclsid, pszProtocol);
    if( hr == NOERROR && 
        (DLD_PROTOCOL_NONE != IsKnownProtocol(pszProtocol) ) )
    {
        UpdateTransLevelHandlerCount(TRUE);
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::RegisterNameSpace (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::UnregisterNameSpace
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::UnregisterNameSpace(IClassFactory *pCF, LPCWSTR pszProtocol)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetSession::UnregisterNameSpace",
                "this=%#x, %#x, %.80wq",
                this, pCF, pszProtocol
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::UnregisterNameSpace");
    HRESULT hr = E_NOTIMPL;

    hr = _CProtMgrNameSpace.Unregister(pCF, pszProtocol);
    if( hr == NOERROR &&
        (DLD_PROTOCOL_NONE != IsKnownProtocol(pszProtocol) ) )
    {
        UpdateTransLevelHandlerCount(FALSE);
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::UnregisterNameSpace (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::RegisterMimeFilter
//
//  Synopsis:
//
//  Arguments:  [const] --
//              [ULONG] --
//              [ctypes] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::RegisterMimeFilter(IClassFactory *pCF, REFCLSID rclsid, LPCWSTR pwzType)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetSession::RegisterMimeFilter",
                "this=%#x, %#x, %#x, %.80wq",
                this, pCF, &rclsid, pwzType
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::RegisterMimeFilter");
    HRESULT hr;

    hr = _CProtMgrMimeFilter.Register(pCF,rclsid, pwzType);
    if( hr == NOERROR )
    {
        UpdateTransLevelHandlerCount(TRUE);
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::RegisterMimeFilter (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::UnregisterMimeFilter
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::UnregisterMimeFilter(IClassFactory *pCF, LPCWSTR pszType)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetSession::UnregisterMimeFilter",
                "this=%#x, %#x, %.80wq",
                this, pCF, pszType
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::UnregisterMimeFilter");
    HRESULT hr;

    hr = _CProtMgrMimeFilter.Unregister(pCF, pszType);
    if( hr == NOERROR )
    {
        UpdateTransLevelHandlerCount(FALSE);
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::UnregisterMimeFilter (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::CreateBinding
//
//  Synopsis:
//
//  Arguments:  [IUnknown] --
//              [REFIID] --
//              [IUnknown] --
//              [IOInetBinding] --
//              [DWORD] --
//              [dwOption] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::CreateBinding(LPBC pBC, LPCWSTR wzUrl,IUnknown *pUnkOuter,
                                        IUnknown **ppUnk,IOInetProtocol **ppOInetProt, DWORD dwOption)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetSession::CreateBinding",
                "this=%#x, %#x, %.80wq, %#x, %#x, %#x, %#x",
                this, pBC, wzUrl, pUnkOuter, ppUnk, ppOInetProt, dwOption
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::CreateBinding");
    HRESULT hr = E_NOTIMPL;

    DWORD dwLocation = 0;
    CLSID clsid = CLSID_NULL; 

    // NetDocs specific hack (IEv60 Bug# 25642):
    if(!g_bShortcircuitKnownProtocols && !(dwOption & PI_PREFERDEFAULTHANDLER))
    {
        // QueryInfo with QUERY_CAN_NAVIGATE, if true (or failure), let the default action take place. 
        // If false, add a PI_PREFERDEFAULTHANDLER to dwOption to (preferably) load the internal handler.

        // Having NetDocs implement the IInternetProtocolInfo on the Class Factory instead of 
        // the APP for performance, a CoInternetQueryInfo will work in either case, because 
        // COInetSession::CreateProtocolInfo (conveniently ;-)  ) queries the Class Factory 
        // first for IInternetProtocolInfo.

        DWORD dwCanNavigate = TRUE;
        DWORD dwDummy;

        // Can NetDocs navigate?:
        HRESULT hr = /* CoInternet */ QueryInfo(
                    wzUrl,
                    QUERY_CAN_NAVIGATE,
                    0,
                    (LPVOID)&dwCanNavigate,
                    sizeof(dwCanNavigate),
                    &dwDummy,
                    0);

        if ((hr == S_OK) && (!dwCanNavigate))
            dwOption |= PI_PREFERDEFAULTHANDLER;
    }

    if (dwOption & PI_PREFERDEFAULTHANDLER)
    {
        // allow non-IE urlmon clients to load only the default handlers.
        DWORD dwProtID = IsKnownProtocol(wzUrl);
        if (dwProtID)
            hr = CreateFirstProtocol(wzUrl, NULL, NULL, ppOInetProt, &clsid, &dwLocation, BINDF_PREFERDEFAULTHANDLER);

        if (SUCCEEDED(hr))
            goto Exit;

        dwOption &= ~PI_PREFERDEFAULTHANDLER;
        clsid = CLSID_NULL;
    }
    
    if (dwOption & PI_LOADAPPDIRECT)
    {
        hr = CreateFirstProtocol(wzUrl, NULL, NULL, ppOInetProt, &clsid, &dwLocation); 
    }
    else if( pBC || !g_bCanUseSimpleBinding || g_cTransLevelHandler)
    {
        hr = GetTransactionObjects(pBC, wzUrl, pUnkOuter, ppUnk, ppOInetProt, dwOption, 0);
    }
    else
    {
        DWORD dwProtID = 0;
        dwProtID = IsKnownProtocol(wzUrl);
        if( dwProtID  )
        {
            hr = CreateFirstProtocol(wzUrl, NULL, NULL, ppOInetProt, &clsid, &dwLocation); 
        }
        else
        {
            hr = GetTransactionObjects(pBC, wzUrl, pUnkOuter, ppUnk, 
                                       ppOInetProt, dwOption, 0);

        }
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::CreateBinding (hr:%lx)", hr);

Exit:
    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::SetSessionOption
//
//  Synopsis:
//
//  Arguments:  [LPVOID] --
//              [DWORD] --
//              [DWORD] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//              02-09-2001   GaneshS (S. Ganesh)      NetDocs Hack
//                               This hack allows NetDocs to (re)set an option to prevent 
//                               short-circuit of (their overridden) known protocols, in 
//                               CoInternetQueryInfo.
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::SetSessionOption(DWORD dwOption,LPVOID pBuffer,DWORD dwBufferLength,DWORD dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetSession::SetSessionOption",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, dwOption, pBuffer, dwBufferLength, dwReserved
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::SetSessionOption");
    HRESULT hr = E_NOTIMPL;

    if(SESSIONOPTIONF_SHORTCIRCUIT_KNOWN_PROTOCOLS == dwOption)
    {
        TransAssert(pBuffer);
        TransAssert(dwBufferLength == 1);
        g_bShortcircuitKnownProtocols = *(BYTE *)pBuffer;
        hr = S_OK;
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::SetSessionOption (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::GetSessionOption
//
//  Synopsis:
//
//  Arguments:  [LPVOID] --
//              [DWORD] --
//              [DWORD] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::GetSessionOption(DWORD dwOption,LPVOID pBuffer,DWORD *pdwBufferLength,DWORD dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetSession::GetSessionOption",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, dwOption, pBuffer, pdwBufferLength, dwReserved
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::GetSessionOption");
    HRESULT hr = E_NOTIMPL;

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::GetSessionOption (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::ParseUrl
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [ParseAction] --
//              [dwFlags] --
//              [pwzResult] --
//              [cchResult] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-13-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::ParseUrl(
    LPCWSTR     pwzUrl,
    PARSEACTION ParseAction,
    DWORD       dwFlags,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD      *pcchResult,
    DWORD       dwReserved
    )
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetProtocolInfo::ParseUrl",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x, %#x, %#x",
                this, pwzUrl, ParseAction, dwFlags, pwzResult, cchResult, pcchResult, dwReserved
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::ParseUrl");
    HRESULT hr;
    IOInetProtocolInfo  *pProtInfo = 0;

    do
    {
        hr = CreateProtocolInfo(pwzUrl, &pProtInfo);
        BREAK_ONERROR(hr);

        hr = pProtInfo->ParseUrl(pwzUrl, ParseAction, dwFlags, pwzResult, cchResult, pcchResult, dwReserved);

        break;
    } while (TRUE);

    if (pProtInfo)
    {
        pProtInfo->Release();
    }

    if (FAILED(hr))
    {
        hr = INET_E_DEFAULT_ACTION;
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::ParseUrl (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::CombineUrl
//
//  Synopsis:
//
//  Arguments:  [pwzBaseUrl] --
//              [pwzRelativeUrl] --
//              [dwFlags] --
//              [pwzResult] --
//              [cchResult] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-13-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::CombineUrl(
    LPCWSTR     pwzBaseUrl,
    LPCWSTR     pwzRelativeUrl,
    DWORD       dwFlags,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD      *pcchResult,
    DWORD       dwReserved
    )
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetProtocolInfo::CombineUrl",
                "this=%#x, %.80wq, %.80wq, %#x, %#x, %#x, %#x, %#x",
                this, pwzBaseUrl, pwzRelativeUrl, dwFlags, pwzResult, cchResult, pcchResult, dwReserved
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::CombineUrl");
    HRESULT hr;
    IOInetProtocolInfo  *pProtInfo = 0;

    do
    {
        hr = CreateProtocolInfo(pwzBaseUrl, &pProtInfo);
        BREAK_ONERROR(hr);

        hr = pProtInfo->CombineUrl(pwzBaseUrl, pwzRelativeUrl, dwFlags, pwzResult, cchResult, pcchResult, dwReserved);

        break;
    } while (TRUE);

    if (pProtInfo)
    {
        pProtInfo->Release();
    }

    if (FAILED(hr))
    {
        hr = INET_E_DEFAULT_ACTION;
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::CombineUrl (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::CompareUrl
//
//  Synopsis:
//
//  Arguments:  [pwzUrl1] --
//              [pwzUrl2] --
//              [dwFlags] --
//
//  Returns:
//
//  History:    4-13-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::CompareUrl(
    LPCWSTR pwzUrl1,
    LPCWSTR pwzUrl2,
    DWORD dwFlags
    )
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetProtocolInfo::CompareUrl",
                "this=%#x, %.80wq, %.80wq, %#x",
                this, pwzUrl1, pwzUrl2, dwFlags
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::CompareUrl");
    HRESULT hr;
    IOInetProtocolInfo  *pProtInfo = 0;

    do
    {
        hr = CreateProtocolInfo(pwzUrl1, &pProtInfo);
        BREAK_ONERROR(hr);

        hr = pProtInfo->CompareUrl(pwzUrl1, pwzUrl2, dwFlags);

        break;
    } while (TRUE);

    if (pProtInfo)
    {
        pProtInfo->Release();
    }

    if (FAILED(hr))
    {
        hr = INET_E_DEFAULT_ACTION;
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::CompareUrl (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::QueryInfo
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [dwOption] --
//              [pBuffer] --
//              [cbBuffer] --
//              [pcbBuf] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-14-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::QueryInfo(
    LPCWSTR pwzUrl,
    QUERYOPTION   QueryOption,
    DWORD         dwQueryFlags,
    LPVOID pBuffer,
    DWORD   cbBuffer,
    DWORD  *pcbBuf,
    DWORD   dwReserved
    )
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetProtocolInfo::QueryInfo",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x, %#x, %#x",
                this, pwzUrl, QueryOption, dwQueryFlags, pBuffer, cbBuffer, pcbBuf, dwReserved
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::QueryInfo");
    HRESULT hr;
    IOInetProtocolInfo  *pProtInfo = 0;
    CLSID clsid;

    do
    {
        hr = CreateProtocolInfo(pwzUrl, &pProtInfo);
        BREAK_ONERROR(hr);

        hr = pProtInfo->QueryInfo(pwzUrl, QueryOption, dwQueryFlags, pBuffer, cbBuffer, pcbBuf, dwReserved);

        break;
    } while (TRUE);

    if (pProtInfo)
    {
        pProtInfo->Release();
    }

    if (FAILED(hr))
    {
        hr = INET_E_DEFAULT_ACTION;
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::QueryInfo (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}




// internal methods

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::FindFirstCF
//
//  Synopsis:
//
//  Arguments:  [pszProt] --
//              [ppUnk] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-15-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::FindFirstCF(LPCWSTR pszProt, IClassFactory **ppUnk, CLSID *pclsid, 
                                        DWORD* pdwLocation, DWORD dwOpt)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::FindFirstCF",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x",
                this, pszProt, ppUnk, pclsid, pdwLocation, dwOpt
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::FindFirstCF");
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;

    TransAssert(pdwLocation);
    if( dwOpt )
    {
        *ppUnk = NULL;

        // different loading mechanism
        DWORD dwEl = 1;
        DWORD dwFlags = 0;
        HRESULT hrReg = _CProtMgr.LookupClsIDFromReg(
                    pszProt, pclsid, &dwEl, &dwFlags, dwOpt);

        if( hrReg == NOERROR )
        {
            hrReg = CoGetClassObject(
                                    *pclsid, 
                                    CLSCTX_INPROC_SERVER,
                                    NULL,
                                    IID_IClassFactory, 
                                    (void**)ppUnk );

            if (hrReg == NOERROR)
            {
                hr = NOERROR;
            }
        }

        goto End;     
    }

    *pdwLocation = LOC_NAMESPACE;

    switch (*pdwLocation)
    {
    default:
        TransAssert((FALSE));
        break;
    case LOC_NAMESPACE:
        hr = _CProtMgrNameSpace.FindFirstCF(pszProt, ppUnk, pclsid);
        if (hr == NOERROR)
        {
            break;
        }
        *pdwLocation = LOC_INTERNAL;

    case LOC_INTERNAL:
        hr = FindInternalCF(pszProt, ppUnk, pclsid, pdwLocation);
        if (hr == NOERROR)
        {
            break;
        }
        *pdwLocation = LOC_EXTERNAL;

    case LOC_EXTERNAL:
        hr = _CProtMgr.FindFirstCF(pszProt, ppUnk, pclsid);
        break;
    }

End:

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::FindFirstCF (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::FindNextCF
//
//  Synopsis:
//
//  Arguments:  [pszProt] --
//              [ppUnk] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-15-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::FindNextCF(LPCWSTR pszProt, IClassFactory **ppUnk, CLSID *pclsid, DWORD* pdwLocation)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::FindNextCF",
                "this=%#x, %.80wq, %#x, %#x, %#x",
                this, pszProt, ppUnk, pclsid, pdwLocation
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::FindNextCF");
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;

    TransAssert(pdwLocation);
    switch (*pdwLocation)
    {
    default:
        TransAssert((FALSE));
        break;
    case LOC_NAMESPACE:
        hr = _CProtMgrNameSpace.FindNextCF(pszProt, ppUnk, pclsid);
        if (hr == NOERROR)
        {
            break;
        }
        *pdwLocation = LOC_INTERNAL;

    case LOC_INTERNAL:

        hr = FindInternalCF(pszProt, ppUnk, pclsid, pdwLocation);
        if (hr != NOERROR)
        {
            hr = _CProtMgr.FindFirstCF(pszProt, ppUnk, pclsid);
        }
        *pdwLocation = LOC_EXTERNAL;
        break;

    case LOC_EXTERNAL:
        // valid case - just return INET_E_UNKNOWN_PROTOCOL
        break;
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::FindNextCF (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::FindInternalCF
//
//  Synopsis:
//
//  Arguments:  [pszProt] --
//              [ppUnk] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-15-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::FindInternalCF(LPCWSTR pszProt, IClassFactory **ppUnk, CLSID *pclsid, DWORD* pdwLocation)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::FindInternalCF",
                "this=%#x, %.80wq, %#x, %#x, %#x",
                this, pszProt, ppUnk, pclsid, pdwLocation
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::FindInternalCF");
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;

    TransAssert(pdwLocation && (*pdwLocation == LOC_INTERNAL));

    DWORD dwProtoId;

    if ((dwProtoId = IsKnownProtocol(pszProt)) != DLD_PROTOCOL_NONE)
    {

        *pclsid = *GetKnownOInetProtocolClsID(dwProtoId);

        IClassFactory *pCF = NULL;
        if (_ProtMap[dwProtoId].pCF != 0)
        {
            pCF = _ProtMap[dwProtoId].pCF;
        }
        else
        {
            pCF = (IClassFactory *) new CUrlClsFact(*pclsid, dwProtoId);
            if (pCF)
            {
                _ProtMap[dwProtoId].pCF = pCF;
            }
        }
        if (pCF)
        {
            *ppUnk = pCF;
            pCF->AddRef();
            hr = NOERROR;
        }
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::FindInternalCF (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::CreateFirstProtocol
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pUnkOuter] --
//              [ppUnk] --
//              [ppProt] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-15-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::CreateFirstProtocol(LPCWSTR pwzUrl, IUnknown *pUnkOuter, IUnknown **ppUnk,  
                                IOInetProtocol **ppProt, CLSID *pclsid, DWORD* pdwLocation, DWORD dwOpt) 
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::CreateFirstProtocol",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x, %#x, %#x",
                this, pwzUrl, pUnkOuter, ppUnk, ppProt, pclsid, pdwLocation, dwOpt
                ));
                
    PerfDbgLog2(tagCOInetSession, this, "+COInetSession::CreateFirstProtocol (szUrlL:%ws, pUnkOuter:%lx)", pwzUrl, pUnkOuter);
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    IClassFactory *pCF = 0;

    TransAssert((pwzUrl && ppProt && pclsid));
    TransAssert (( (pUnkOuter && ppUnk) || (!pUnkOuter && !ppUnk) ));
    TransAssert(pdwLocation);
    
    *pclsid = CLSID_NULL;

    // check if protocol part
    WCHAR  wzProt[ULPROTOCOLLEN];
    wcsncpy(wzProt, pwzUrl, ULPROTOCOLLEN);
    wzProt[ULPROTOCOLLEN-1] = 0;

    LPWSTR pwzProt = wcschr(wzProt, ':');
    do 
    {
        if (!pwzProt)
        {
            break;
        }
        *pwzProt = 0;

        if (dwOpt & BINDF_PREFERDEFAULTHANDLER)
        {
            DWORD tempLocation = *pdwLocation;
            *pdwLocation = LOC_INTERNAL;
            hr = FindInternalCF(wzProt, &pCF, pclsid, pdwLocation);
            if (NOERROR != hr)
            {
                *pdwLocation = tempLocation;
                dwOpt &= ~BINDF_PREFERDEFAULTHANDLER;
                hr = FindFirstCF(wzProt, &pCF, pclsid, pdwLocation, dwOpt);
            }
        }
        else
            hr = FindFirstCF(wzProt, &pCF, pclsid, pdwLocation, dwOpt);
                
        if (NOERROR == hr)
        {
            TransAssert((pCF));

            if (pUnkOuter)
            {
                TransAssert((ppUnk));
                hr = pCF->CreateInstance(pUnkOuter, IID_IUnknown, (void **)ppUnk);

                if (hr == NOERROR)
                {
                    TransAssert((*ppUnk));
                    hr = (*ppUnk)->QueryInterface(IID_IOInetProtocol, (void **) ppProt);
                }
            }
            // create an instance without aggregation
            if (!pUnkOuter || (hr == CLASS_E_NOAGGREGATION))
            {
                if( dwOpt == 1)
                {
                    hr = pCF->CreateInstance(NULL, IID_IOInetProtocolRoot, (void **)ppProt);
                }
                else
                {
                    hr = pCF->CreateInstance(NULL, IID_IOInetProtocol, (void **)ppProt);
                }
            }

            pCF->Release();
        }
        else
        {
            // look up the registry
            hr = MK_E_SYNTAX;
        }
        break;
    }
    while (TRUE);

    if (hr != NOERROR)
    {
        *ppProt = 0;
    }

    TransAssert((   (hr == NOERROR && *pclsid != CLSID_NULL)
                 || (hr != NOERROR) ));

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::CreateFirstProtocol(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::CreateNextProtocol
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pUnkOuter] --
//              [ppUnk] --
//              [ppProt] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-15-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::CreateNextProtocol(LPCWSTR pwzUrl, IUnknown *pUnkOuter, IUnknown **ppUnk,  
                                            IOInetProtocol **ppProt, CLSID *pclsid, DWORD* pdwLocation)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::CreateNextProtocol",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x, %#x",
                this, pwzUrl, pUnkOuter, ppUnk, ppProt, pclsid, pdwLocation
                ));
                
    PerfDbgLog2(tagCOInetSession, this, "+COInetSession::CreateNextProtocol (szUrlL:%ws, pUnkOuter:%lx)", pwzUrl?pwzUrl:L"", pUnkOuter);
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;

    IClassFactory *pCF = 0;

    TransAssert((pwzUrl && ppProt && pclsid));
    TransAssert (( (pUnkOuter && ppUnk) || (!pUnkOuter && !ppUnk) ));
    TransAssert(pdwLocation);
    
    *pclsid = CLSID_NULL;

    if ( (hr = FindNextCF(pwzUrl, &pCF, pclsid, pdwLocation)) == NOERROR )
    {
        TransAssert((pCF));

        if (pUnkOuter)
        {
            TransAssert((ppUnk));
            hr = pCF->CreateInstance(pUnkOuter, IID_IUnknown, (void **)ppUnk);

            if (hr == NOERROR)
            {
                TransAssert((*ppUnk));
                hr = (*ppUnk)->QueryInterface(IID_IOInetProtocol, (void **) ppProt);
            }
        }
        // create an instance without aggregation
        if (!pUnkOuter || (hr == CLASS_E_NOAGGREGATION))
        {
            hr = pCF->CreateInstance(NULL, IID_IOInetProtocol, (void **)ppProt);
        }

        pCF->Release();
    }
    else
    {
        // look up the registry
        hr = MK_E_SYNTAX;
    }

    if (hr != NOERROR)
    {
        *ppProt = 0;
    }

    TransAssert((   (hr == NOERROR && *pclsid != CLSID_NULL)
                 || (hr != NOERROR) ));

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::CreateNextProtocol(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::CreateHandler
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pUnkOuter] --
//              [ppUnk] --
//              [ppProt] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-15-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::CreateHandler(LPCWSTR pwzUrl, IUnknown *pUnkOuter, IUnknown **ppUnk,  
                                        IOInetProtocol **ppProt, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::CreateHandler",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x",
                this, pwzUrl, pUnkOuter, ppUnk, ppProt, pclsid
                ));
                
    PerfDbgLog2(tagCOInetSession, this, "+COInetSession::CreateHandler (szUrlL:%ws, pUnkOuter:%lx)", pwzUrl?pwzUrl:L"", pUnkOuter);
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    IClassFactory *pCF = 0;

    TransAssert((pwzUrl && ppProt && pclsid));
    TransAssert (( (pUnkOuter && ppUnk) || (!pUnkOuter && !ppUnk) ));

    *pclsid = CLSID_NULL;

    if ( (hr = _CProtMgrMimeFilter.FindFirstCF(pwzUrl, &pCF, pclsid)) == NOERROR )
    {
        TransAssert((pCF));

        if (pUnkOuter)
        {
            hr = pCF->CreateInstance(pUnkOuter, IID_IUnknown, (void **)ppUnk);

            if (hr == NOERROR)
            {
                TransAssert((*ppUnk));
                hr = (*ppUnk)->QueryInterface(IID_IOInetProtocol, (void **) ppProt);
            }
        }
        // create an instance without aggregation
        if (!pUnkOuter || (hr == CLASS_E_NOAGGREGATION))
        {
            hr = pCF->CreateInstance(NULL, IID_IOInetProtocol, (void **)ppProt);
        }

        pCF->Release();
    }
    else
    {
        // look up the registry
        hr = MK_E_SYNTAX;
    }

    TransAssert((   (hr == NOERROR && *pclsid != CLSID_NULL)
                 || (hr != NOERROR) ));

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::CreateHandler(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::FindOInetProtocolClsID
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-20-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::FindOInetProtocolClsID(LPCWSTR pwzUrl, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::FindOInetProtocolClsID",
                "this=%#x, %.80wq, %#x",
                this, pwzUrl, pclsid
                ));
                
    PerfDbgLog1(tagCOInetSession, this, "+COInetSession::FindOInetProtocolClsID (pwzUrl:%ws)", pwzUrl?pwzUrl:L"");
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;

    DWORD dwProtId = IsKnownProtocol(pwzUrl);

    DWORD dwLocation = 0;
    
    if (dwProtId != DLD_PROTOCOL_NONE)
    {
        *pclsid = *GetKnownOInetProtocolClsID(dwProtId);
        hr = NOERROR;
    }
    else
    {
        // try to find the first protocol
        {
            IClassFactory *pCF = 0;
            // check if protocol part
            WCHAR  wzProt[ULPROTOCOLLEN];
            wcsncpy(wzProt, pwzUrl, ULPROTOCOLLEN);
            wzProt[ULPROTOCOLLEN-1] = 0;

            LPWSTR pwzProt = wcschr(wzProt, ':');
            if (pwzProt)
            {
                *pwzProt = 0;
                hr = FindFirstCF(wzProt, &pCF, pclsid, &dwLocation);
            }
            
            if (pCF)
            {
                pCF->Release();
            }
        }
    
        // lookup the registry
        if (hr != NOERROR)
        {
            hr = _CProtMgr.LookupClsIDFromReg(pwzUrl, pclsid);
        }
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::FindOInetProtocolClsID(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsOInetProtocol
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//
//  Returns:
//
//  History:    11-11-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL IsOInetProtocol(IBindCtx *pbc, LPCWSTR pwzUrl)
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "IsOInetProtocol",
                "%#x, %.80wq",
                pbc, pwzUrl
                ));
                
    PerfDbgLog1(tagCOInetSession, NULL, "+IOInetProtocol (pwzUrl:%ws)", pwzUrl?pwzUrl:L"");
    BOOL fRet = FALSE;
    CLSID clsid;
    COInetSession *pCOInetSession = 0;
    HRESULT hr;

    // check if a BSC is registerted if not register our own one - for Office!
    IUnknown *pUnk = NULL;
    hr = GetObjectParam(pbc, REG_BSCB_HOLDER, IID_IBindStatusCallback, (IUnknown**)&pUnk);
    if (SUCCEEDED(hr))
    {
        TransAssert((pUnk));
        IServiceProvider *pServiceProv = 0;
        hr = pUnk->QueryInterface(IID_IServiceProvider,(void **) &pServiceProv);
        if (SUCCEEDED(hr))
        {
            TransAssert((pServiceProv));

            IOInetProtocol *pIOInetProt = 0;
            hr = pServiceProv->QueryService(IID_IOInetProtocol, IID_IOInetProtocol, (void **) &pIOInetProt);
            if (SUCCEEDED(hr) && pIOInetProt)
            {
                // always check for a valid out pointer - some service provider return
                // S_OK and null for the out parameter

                pIOInetProt->Release();
                fRet = TRUE;
            }
            pServiceProv->Release();
        }
        pUnk->Release();
    }

    if (   (fRet == FALSE)
        && ((GetCOInetSession(0,&pCOInetSession,0)) == NOERROR))
    {
        if (pCOInetSession->FindOInetProtocolClsID(pwzUrl, &clsid) == NOERROR)
        {
            fRet = TRUE;
        }

        pCOInetSession->Release();
    }

    PerfDbgLog1(tagCOInetSession, NULL, "-IsOInetProtocol (fRet:%ld)", fRet);

    DEBUG_LEAVE(fRet);
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::CreateProtocolInfo
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [ppProtInfo] --
//
//  Returns:
//
//  History:    04-20-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::CreateProtocolInfo(LPCWSTR pwzUrl, IOInetProtocolInfo **ppProtInfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::CreateProtocolInfo",
                "this=%#x, %.80wq, %#x",
                this, pwzUrl, ppProtInfo
                ));
                
    PerfDbgLog1(tagCOInetSession, this, "+COInetSession::CreateProtocolInfo (szUrlL:%ws)", pwzUrl);
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    IClassFactory *pCF = 0;
    CLSID clsid;

    TransAssert((pwzUrl && ppProtInfo));

    DWORD dwLocation = 0;
    
    // check if protocol part
    WCHAR  wzProt[ULPROTOCOLLEN];
    wcsncpy(wzProt, pwzUrl, ULPROTOCOLLEN);
    wzProt[ULPROTOCOLLEN-1] = 0;

    LPWSTR pwzProt = wcschr(wzProt, ':');

    do
    {
        if (!pwzProt)
        {
            break;
        }

        *pwzProt = 0;

        if ( (hr = FindFirstCF(wzProt, &pCF, &clsid, &dwLocation)) == NOERROR )
        {
            TransAssert((pCF));

            hr = pCF->QueryInterface(IID_IOInetProtocolInfo, (void **)ppProtInfo);

            if (hr != NOERROR)
            {
                hr = pCF->CreateInstance(NULL, IID_IOInetProtocolInfo, (void **)ppProtInfo);
            }

            pCF->Release();
        }
        else
        {
            // look up the registry
            hr = MK_E_SYNTAX;
        }

        if (hr != NOERROR)
        {
            *ppProtInfo = 0;
        }
        break;
    } while (TRUE);

    TransAssert((   (hr == NOERROR && clsid != CLSID_NULL)
                 || (hr != NOERROR) ));

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::CreateProtocolInfo(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::CreateSecurityMgr
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [ppSecMgr] --
//
//  Returns:
//
//  History:    4-28-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::CreateSecurityMgr(LPCWSTR pwzUrl, IInternetSecurityManager **ppSecMgr)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::CreateSecurityMgr",
                "this=%#x, %.80wq, %#x",
                this, pwzUrl, ppSecMgr
                ));
                
    PerfDbgLog1(tagCOInetSession, this, "+COInetSession::CreateSecurityMgr (szUrlL:%ws)", pwzUrl);
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    IClassFactory *pCF = 0;
    CLSID clsid;

    TransAssert((pwzUrl && ppSecMgr));

    DWORD dwLocation = 0;
    // check if protocol part
    WCHAR  wzProt[ULPROTOCOLLEN];
    wcsncpy(wzProt, pwzUrl, ULPROTOCOLLEN);
    wzProt[ULPROTOCOLLEN-1] = 0;

    LPWSTR pwzProt = wcschr(wzProt, ':');

    do
    {
        if (!pwzProt)
        {
            break;
        }

        *pwzProt = 0;

        if ( (hr = FindFirstCF(wzProt, &pCF, &clsid, &dwLocation)) == NOERROR )
        {
            TransAssert((pCF));

            hr = pCF->CreateInstance(NULL, IID_IInternetSecurityManager, (void **)ppSecMgr);

            pCF->Release();
        }
        else
        {
            // look up the registry
            hr = MK_E_SYNTAX;
        }

        if (hr != NOERROR)
        {
            *ppSecMgr = 0;
        }
        break;
    } while (TRUE);

    TransAssert((   (hr == NOERROR && clsid != CLSID_NULL)
                 || (hr != NOERROR) ));

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::CreateSecurityMgr(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

BOOL CanUseSimpleBinding()
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CanUseSimpleBinding",
                NULL
                ));
                
    HKEY hNSRoot;

    if( RegOpenKey(HKEY_CLASSES_ROOT, SZNAMESPACEROOT, &hNSRoot) 
            == ERROR_SUCCESS)
    {   
        DWORD dwIndex = 0;
        char szName[256];
        LONG ret = ERROR_SUCCESS;
        while(1) 
        {
            szName[0] = '\0';
        
            ret = RegEnumKey(hNSRoot, dwIndex, szName, 256); 
            if( ret == ERROR_SUCCESS )
            {
                if(    !StrCmpNI(szName, "http",    strlen("http")    )
                    || !StrCmpNI(szName, "ftp",     strlen("ftp")     )
                    || !StrCmpNI(szName, "gopher",  strlen("gopher")  )
                    || !StrCmpNI(szName, "https",   strlen("https")   )
                    || !StrCmpNI(szName, "file",    strlen("file")    )
                   )
                {
                    RegCloseKey(hNSRoot);

                    DEBUG_LEAVE(FALSE);
                    return FALSE;
                }

                dwIndex ++;
            }
            else
            {
                RegCloseKey(hNSRoot);

                DEBUG_LEAVE(TRUE);
                return TRUE;
            }
        }
    } 

    DEBUG_LEAVE(TRUE);
    return TRUE;
}


VOID
COInetSession::UpdateTransLevelHandlerCount(BOOL bAttach)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "COInetSession::UpdateTransLevelHandlerCount",
                "this=%#x, %B",
                this, bAttach
                ));
                
    CLock lck(g_mxsOInet);
    if( bAttach )
    {
        g_cTransLevelHandler++;
    }
    else
    {
        g_cTransLevelHandler--;
        if( g_cTransLevelHandler < 0 )
            g_cTransLevelHandler = 0;
    }

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\modallp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       msgflter.cxx
//
//  Contents:   class for intellignet modal loop uses in sychronous binding
//
//  Classes:
//
//  Functions:
//
//  History:    8-21-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>

//+---------------------------------------------------------------------------
//
//  Method:     CModalLoop::CModalLoop
//
//  Synopsis:
//
//  Arguments:  [phr] --
//
//  Returns:
//
//  History:    8-21-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CModalLoop::CModalLoop(HRESULT *phr)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CModalLoop::CModalLoop",
                "this=%#x, %#x",
                this, phr
                ));
                
    UrlMkAssert((phr));

    // BUGBUG 3384: message filter is bogus.  Disable for now.
    // *phr = CoRegisterMessageFilter(this, &_pMsgFlter);
    _pMsgFlter = NULL;
    *phr = 0x80000000;

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CModalLoop::~CModalLoop
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    8-21-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CModalLoop::~CModalLoop()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CModalLoop::~CModalLoop",
                "this=%#x",
                this
                ));
                
    IMessageFilter *pthis;

    if (_pMsgFlter)
    {
        HRESULT hr = CoRegisterMessageFilter(_pMsgFlter, &pthis);
        // we should get back our messagefilter we installed
        // in ctor
        TransAssert(( (hr == NOERROR) && (this == pthis) ));
        _pMsgFlter->Release();
    }
    
    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CModalLoop::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    8-21-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CModalLoop::QueryInterface( REFIID riid, void **ppv )
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CModalLoop::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppv
                ));
                
    HRESULT     hr = NOERROR;
    UrlMkDebugOut((DEB_BINDING, "%p _IN CModalLoop::QueryInterface (%lx, %p)\n", this, riid, ppv));

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IMessageFilter) )
    {
        *ppv = (void FAR *)(IMessageFilter *)this;
        AddRef();
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CModalLoop::QueryInterface (%lx)[%p]\n", this, hr, *ppv));

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CModalLoop::AddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CModalLoop::AddRef( void )
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CModalLoop::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    UrlMkDebugOut((DEB_BINDING, "%p _IN CModalLoop::AddRef\n", this));

    LONG lRet = ++_CRefs;

    UrlMkDebugOut((DEB_BINDING, "%p OUT CModalLoop::AddRef (%ld)\n", this, lRet));

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CModalLoop::Release
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CModalLoop::Release( void )
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CModalLoop::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    UrlMkDebugOut((DEB_BINDING, "%p _IN CModalLoop::Release\n", this));

    LONG lRet = --_CRefs;
    if (_CRefs == 0)
    {
        delete this;
    }
    UrlMkDebugOut((DEB_BINDING, "%p OUT CModalLoop::Release (%ld)\n", this, lRet));

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   HandleInComingCall
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//
//  Returns:
//
//  History:    8-21-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(DWORD) CModalLoop::HandleInComingCall(DWORD dwCallType,HTASK htaskCaller,DWORD dwTickCount,LPINTERFACEINFO lpInterfaceInfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CModalLoop::HandleInComingCall",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, dwCallType, htaskCaller, dwTickCount, lpInterfaceInfo
                ));
                
    DWORD dwRet = 0;
    UrlMkDebugOut((DEB_BINDING, "%p _IN CModalLoop::HandleInComingCall \n", this));

    if (_pMsgFlter)
    {
        dwRet = _pMsgFlter->HandleInComingCall(dwCallType, htaskCaller, dwTickCount, lpInterfaceInfo);
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CModalLoop::HandleInComingCall (dwRet:%lx)\n", this, dwRet));

    DEBUG_LEAVE(dwRet);
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   RetryRejectedCall
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//
//  Returns:
//
//  History:    8-21-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(DWORD) CModalLoop::RetryRejectedCall(HTASK htaskCallee,DWORD dwTickCount,DWORD dwRejectType)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CModalLoop::RetryRejectedCall",
                "this=%#x, %#x, %#x, %#x",
                this, htaskCallee, dwTickCount, dwRejectType
                ));
                
    DWORD dwRet = 0;
    UrlMkDebugOut((DEB_BINDING, "%p _IN CModalLoop::RetryRejectedCall \n", this));

    if (_pMsgFlter)
    {
        dwRet = _pMsgFlter->RetryRejectedCall( htaskCallee, dwTickCount, dwRejectType);
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CModalLoop::RetryRejectedCall (dwRet:%lx)\n", this, dwRet));

    DEBUG_LEAVE(dwRet);
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   MessagePending
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//
//  Returns:
//
//  History:    8-21-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(DWORD) CModalLoop::MessagePending(HTASK htaskCallee,DWORD dwTickCount,DWORD dwPendingType)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CModalLoop::MessagePending",
                "this=%#x, %#x, %#x, %#x",
                this, htaskCallee, dwTickCount, dwPendingType
                ));
                
    DWORD dwRet = 0;
    UrlMkDebugOut((DEB_BINDING, "%p _IN CModalLoop::MessagePending \n", this));

    if (_pMsgFlter)
    {
        dwRet = _pMsgFlter->MessagePending( htaskCallee, dwTickCount, dwPendingType);
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CModalLoop::MessagePending (dwRet:%lx)\n", this, dwRet));

    DEBUG_LEAVE(dwRet);
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CModalLoop::HandlePendingMessage
//
//  Synopsis:
//
//  Arguments:  [dwPendingType] --
//              [dwPendingRecursion] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    8-21-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CModalLoop::HandlePendingMessage(DWORD dwPendingType, DWORD dwPendingRecursion, DWORD dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CModalLoop::HandlePendingMessage",
                "this=%#x, %#x, %#x, %#x",
                this, dwPendingType, dwPendingRecursion, dwReserved
                ));
                
    HRESULT hr = NOERROR;
    DWORD dwRet = 0;
    HTASK htaskCallee = 0;
    DWORD dwTickCount = 0;

    UrlMkDebugOut((DEB_BINDING, "%p _IN CModalLoop::HandlePendingMessage \n", this));


    if (_pMsgFlter)
    {
        dwRet = _pMsgFlter->MessagePending( htaskCallee, dwTickCount, dwPendingType);
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CModalLoop::HandlePendingMessage (dwRet:%lx)\n", this, dwRet));

    DEBUG_LEAVE(dwRet);
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\protocol.h ===
// protocl.h
// This file contains templates and externs to things that are protocl specific



BOOL FBeginHttpTransaction(
   LPDLD lpDownload
   );

void TerminateHttpTransaction(
   LPDLD lpDownload
   );


BOOL FBeginFtpTransaction(
   LPDLD lpDownload
   );

void TerminateFtpTransaction(
   LPDLD lpDownload
   );


BOOL FBeginGopherTransaction(
   LPDLD lpDownload
   );

void TerminateGopherTransaction(
   LPDLD lpDownload
   );


BOOL FBeginFileTransaction(
   LPDLD lpDownload
   );

void TerminateFileTransaction(
   LPDLD lpDownload
   );

// BUGBUG couldn't we use the pdld to indicate whether this was restarted
// instead of using additional parameters?
BOOL FPreprocessHttpResponse(LPDLD	pdld, BOOL *lpfRestarted);
BOOL FPreprocessFtpResponse(LPDLD   lpDownload, BOOL *lpfRestarted);

extern char vszHttp[];
extern char vszFtp[];
extern char vszGopher[];
extern char vszFile[];
extern char vszLocal[];
extern char vszHttps[];
extern HINTERNET	vhSession;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\transact.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       transact.cxx
//
//  Contents:   Class that performs the download of a particular request.
//
//  Classes:
//
//  Functions:
//
//  History:    12-04-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#include "oinet.hxx"

static CHAR gwzAcceptEncHeaders[] = "Accept-Encoding: gzip, deflate";
extern BOOL g_bHasMimeHandlerForTextHtml;

extern  IInternetSecurityManager*   g_pSecurityManager;
extern  CMutexSem                   g_mxsSession;

PerfDbgExtern(tagCTransaction);
    DbgExtern(tagCTransactionErr);

HRESULT GetClassDocFileBuffer(LPVOID pbuffer, DWORD dwSize, CLSID *pclsid);
extern DWORD g_dwSettings;

#if DBG==1

#else
#define USE_NOTIFICATION_EXCEPTION_FILTER   //Not in this lifetime
#endif //


#define szHKSniffFlag   "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
#define szHKSniffValue  "SniffDocFile"

BOOL IsSpecialUrl(WCHAR *pchURL);

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    PerfDbgLog(tagCTransaction, this, "+CTransaction::QueryInterface");

    *ppvObj = NULL;
    hr = _pUnkOuter->QueryInterface(riid, ppvObj);

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::QueryInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CTransaction::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTransaction::AddRef(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CTransaction::IUnknown::AddRef",
                "this=%#x",
                this
                ));

    LONG lRet = ++_CRefs;
    PerfDbgLog1(tagCTransaction, this, "CTransaction::AddRef (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CTransaction::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTransaction::Release(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CTransaction::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::Release");

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        delete this;
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Release (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Switch
//
//  Synopsis:
//
//  Arguments:  [pStateInfo] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Switch(PROTOCOLDATA *pStateInfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolSink::Switch",
                "this=%#x, %#x",
                this, pStateInfo
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransaction::Switch");
    HRESULT hr = NOERROR;

    DWORD grfFlags = pStateInfo->grfFlags;
    AddRef();

    if (IsFreeThreaded())
    {
        if (grfFlags & PD_FORCE_SWITCH)
        {
            CTransPacket * pCTP = new CTransPacket(pStateInfo);

            if (pCTP)
            {
                hr = _pClntProtSink->Switch(pCTP);
            }
        }
        else
        {
            // handle request on this thread
            _pProt->Continue(pStateInfo);
        }
    }
    else
    {
        CTransPacket *pCTP = new CTransPacket(pStateInfo);

        if (pCTP)
        {
            AddCTransPacket(pCTP);

            if ((grfFlags & PI_FORCE_ASYNC) || !IsApartmentThread())
            {
                _cPostedMsg++;
                AddRef();
                /****
                PerfDbgLog4(tagCTransaction, this, "CINet:%lx === PostMessage (Msg:%#x) WM_TRANS_PACKET - dwCurrentSize:%ld, dwTotalSize:%ld",
                    _pProt, XDBG(++_wTotalPostedMsg,0), pCTP->_dwCurrentSize, pCTP->_dwTotalSize);
                ****/
                PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM) (WPARAM)GetTotalPostedMsgId(), (LPARAM)this);
            }
            else
            {
                OnINetCallback();
            }
        }
    }
    Release();

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Switch (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::ReportProgress
//
//  Synopsis:
//
//  Arguments:  [NotMsg] --
//              [szStatusText] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::ReportProgress(ULONG NotMsg, LPCWSTR szStatusText)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolSink::ReportProgress",
                "this=%#x, %#x, %.80wq",
                this, NotMsg, szStatusText
                ));


    AddRef();
    PerfDbgLog(tagCTransaction, this, "+CTransaction::ReportProgress");
    HRESULT hr = NOERROR;

    if (PreDispatch() != S_OK)
    {
        // nothing to do any more!
    }
    else if (IsFreeThreaded())
    {
        // handle request on this thread
        hr = DispatchReport((BINDSTATUS) NotMsg, _grfBSCF, _ulCurrentSize, _ulTotalSize, (LPWSTR)szStatusText, 0);
    }
    else
    {
        CTransPacket *pCTP = new CTransPacket( (BINDSTATUS) NotMsg, NOERROR, szStatusText, _ulCurrentSize, _ulTotalSize);

        if (pCTP)
        {
        #if DBG==1
            DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
            DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
        #elif defined(PERFTAGS)
            DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
            DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
        #endif
            
            //BUGBUG: this is a hack where small doc files are loaded in one swipe and
            //the class install filter is not loaded because an BINDSTATUS_ENDDOWNLOAD
            //already occurs in transaction packet list.
            if (NotMsg == BINDSTATUS_CLASSINSTALLLOCATION)
            {
                AddCTransPacket(pCTP, FALSE);
            }
            else
            {
                AddCTransPacket(pCTP);
            }

            if (!IsApartmentThread())
            {
                _cPostedMsg++;
                AddRef();
                PerfDbgLog4(tagCTransaction, this, "CINet:%lx === PostMessage (Msg:%#x) WM_TRANS_PACKET - dwCurrentSize:%ld, dwTotalSize:%ld",
                                _pProt, XDBG(++_wTotalPostedMsg,0), dwCurrentSizePerf, dwTotalSizePerf);
                PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM)GetTotalPostedMsgId(), (LPARAM)this);

            }
            else
            {
                OnINetCallback();
            }
        }
    }

    PostDispatch();

    Release();
    PerfDbgLog1(tagCTransaction, this, "-CTransaction::ReportProgress (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::ReportData
//
//  Synopsis:
//
//  Arguments:  [grfBSCF] --
//              [ULONG] --
//              [ulProgressMax] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::ReportData(DWORD grfBSCF, ULONG ulProgress,ULONG ulProgressMax)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolSink::ReportData",
                "this=%#x, %#x, %u, %u",
                this, grfBSCF, ulProgress, ulProgressMax
                ));


    PerfDbgLog3(tagCTransaction, this, "+CTransaction::ReportData(grfBSCF:%lx, ulProgress:%ld, ulProgressMax:%ld)",
                                       grfBSCF, ulProgress, ulProgressMax);

    HRESULT hr = NOERROR;
    BOOL fAsync = FALSE;

    BINDSTATUS bndStatus = BINDSTATUS_DOWNLOADINGDATA;
    AddRef();

    if (   (PreDispatch() == S_OK)
        && (   (_ulCurrentSize <= ulProgress)
             || (    (grfBSCF & BSCF_LASTDATANOTIFICATION)
                 && !(_grfBSCF & BSCF_LASTDATANOTIFICATION))
             || (grfBSCF & BSCF_ASYNCDATANOTIFICATION)
            ))
    {

        if (grfBSCF & BSCF_FIRSTDATANOTIFICATION)
        {
            bndStatus = BINDSTATUS_BEGINDOWNLOADDATA;
            _grfBSCF |= BSCF_FIRSTDATANOTIFICATION;
        }

        if (grfBSCF & BSCF_LASTDATANOTIFICATION)
        {
            bndStatus = BINDSTATUS_ENDDOWNLOADDATA;
            _grfBSCF |= BSCF_LASTDATANOTIFICATION;
        }

        if (grfBSCF & BSCF_DATAFULLYAVAILABLE)
        {
            _grfBSCF |= BSCF_DATAFULLYAVAILABLE;
        }

        if (grfBSCF & BSCF_ASYNCDATANOTIFICATION)
        {
            fAsync = TRUE;
        }

        _ulCurrentSize = ulProgress;
        _ulTotalSize  = ulProgressMax;
        TransAssert((   (_ulTotalSize == 0)
                     || (_ulCurrentSize <= _ulTotalSize) ));

        if (IsFreeThreaded())
        {
            hr = DispatchReport(bndStatus, _grfBSCF, _ulCurrentSize, _ulTotalSize, 0, 0);
        }
        else
        {
            CTransPacket *pCTP = new CTransPacket(bndStatus, NOERROR, NULL, _ulCurrentSize, _ulTotalSize);

            if (pCTP)
            {
            #if DBG==1
                DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
                DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
            #elif defined(PERFTAGS)
                DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
                DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
            #endif
                AddCTransPacket(pCTP);

                if (!IsApartmentThread() || fAsync)
                {
                    _cPostedMsg++;
                    AddRef();
                    PerfDbgLog4(tagCTransaction, this, "CINet:%lx === PostMessage (Msg:%#x) WM_TRANS_PACKET - dwCurrentSize:%ld, dwTotalSize:%ld",
                                    _pProt, XDBG(++_wTotalPostedMsg,0), dwCurrentSizePerf, dwTotalSizePerf);
                    PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM) (WPARAM)GetTotalPostedMsgId(), (LPARAM)this);

                }
                else
                {
                    OnINetCallback();
                }
            }
        }
    }

    PostDispatch();

    Release();

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::ReportData (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::OnDataReceived
//
//  Synopsis:
//
//  Arguments:  [grfBSC] --
//              [cbBytesAvailable] --
//              [dwTotalSize] --
//              [pcbNewAvailable] --
//
//  Returns:
//
//  History:    4-15-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::OnDataReceived(DWORD *pgrfBSC, DWORD *pcbBytesAvailable, DWORD *pdwTotalSize) //, DWORD *pcbNewAvailable)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::OnDataReceived",
                "this=%#x, %#x, %#x, %#x",
                this, pgrfBSC, pcbBytesAvailable, pdwTotalSize
                ));
                
    PerfDbgLog3(tagCTransaction, this, "+CTransaction::OnDataReceived (grfBSC:%lx,  cbBytesAvailable:%ld, _cbTotalBytesRead:%ld)",
                                    *pgrfBSC, *pcbBytesAvailable, _cbTotalBytesRead);
    HRESULT hr = NOERROR;
    DWORD grfBSC = *pgrfBSC;
    DWORD cbBytesAvailable = *pcbBytesAvailable;
    DWORD dwTotalSize = *pdwTotalSize;
    DWORD *pcbNewAvailable = &cbBytesAvailable;

    *pcbNewAvailable = cbBytesAvailable;

    do
    {
        // check if mimeverification was requested
        //
        if (!(_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP)) )
        {
            break;
        }
        // get the buffer
        //
        if (!_pBuffer)
        {
            _cbBufferSize = DATASNIFSIZEDOCFILE_MIN; //DATASNIFSIZE_MIN;
            _pBuffer = (LPBYTE) new BYTE[_cbBufferSize];
        }
        if (!_pBuffer)
        {
            hr = E_OUTOFMEMORY;
            break;
        }


        DWORD dwNewData = 0;
        TransAssert((_pProt && _cbDataSniffMin));

        // _cbTotalBytesRead = # of bytes read so far
        if (_cbTotalBytesRead < _cbDataSniffMin)
        {
            // no bytes read so far
            TransAssert((_cbTotalBytesRead < _cbDataSniffMin));
            // read data into buffer and report progess
            do
            {
                hr = _pProt->Read(_pBuffer + _cbBufferFilled, _cbBufferSize - _cbBufferFilled, &dwNewData);
                _cbTotalBytesRead += dwNewData;
                _cbBufferFilled += dwNewData;
            } while ((hr == S_OK) && (_cbTotalBytesRead < _cbDataSniffMin));

            // now check if this is docfile
            // if so download at least 2k
            if (!_fDocFile && _cbBufferFilled && (IsDocFile(_pBuffer, _cbBufferFilled) == S_OK))
            {
                _fDocFile = TRUE;
                _cbDataSniffMin =  (dwTotalSize && dwTotalSize < DATASNIFSIZEDOCFILE_MIN) ? dwTotalSize : DATASNIFSIZEDOCFILE_MIN;
            }

            if ((hr == E_PENDING) && (_cbTotalBytesRead < _cbDataSniffMin))
            {
                // do not report anything - wait until we get more data
                // a request is pending at this time
                // need more data to sniff properly
                hr  = S_NEEDMOREDATA;
            }
            else if (hr == NOERROR || hr == E_PENDING)
            {
                TransAssert((_cbTotalBytesRead != 0));

                // report the data we have in the buffer or
                // the available #
                DWORD cbBytesReport =  (cbBytesAvailable > _cbTotalBytesRead) ? cbBytesAvailable : _cbTotalBytesRead + 1;

                if (dwTotalSize && ((cbBytesReport > dwTotalSize)))
                {
                    cbBytesReport =  dwTotalSize;
                }
                *pcbNewAvailable = cbBytesReport;
            }
            else if (hr == S_FALSE)
            {
                // end of stream
                *pgrfBSC |=  (BSCF_LASTDATANOTIFICATION & BSCF_DATAFULLYAVAILABLE);
                *pcbBytesAvailable = *pdwTotalSize =  _cbTotalBytesRead;
            }

            if (   (!_fMimeVerified)
                && (   (*pcbNewAvailable >= _cbDataSniffMin)
                    || (hr == S_FALSE)) )
            {
                // enough data or end of stream
                _fMimeVerified = TRUE;
                LPWSTR  pwzStr = 0;
                FindMimeFromData(NULL, _pwzFileName,_pBuffer, _cbBufferFilled, _pwzMimeSuggested, 0, &pwzStr, 0);

                if (pwzStr)
                {
                    _pClntProtSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pwzStr);
                } 
                else
                {
                    TransAssert((!_pwzMimeSuggested));
                }

                if (pwzStr)
                {
                    delete [] _pwzMimeSuggested;
                    _pwzMimeSuggested = pwzStr;
                    pwzStr = 0;
                }

                if (   _fDocFile
                    && (_dwOInetBdgFlags & PI_DOCFILECLSIDLOOKUP))
                {
                    // find the class id and send it on
                    CLSID clsid;

                    HRESULT hr1 = GetClassDocFileBuffer(_pBuffer, _cbBufferFilled, &clsid);
                    if (hr1 == NOERROR)
                    {
                        LPOLESTR pwzStrClsId;
                        StringFromCLSID(clsid, &pwzStrClsId);
                        if (pwzStrClsId)
                        {
                           _pClntProtSink->ReportProgress(BINDSTATUS_CLASSIDAVAILABLE, pwzStrClsId);
                        }
                        delete [] pwzStrClsId;
                    }
                }
                delete [] pwzStr;

            }
            hr = NOERROR;
        }
        //TransAssert((cbBytesAvailable <= *pcbNewAvailable));
        if (cbBytesAvailable > *pcbNewAvailable)
        {
            *pcbNewAvailable = cbBytesAvailable;
        }
        if (dwTotalSize && (dwTotalSize < *pcbNewAvailable))
        {
            *pcbNewAvailable = dwTotalSize;
        }
    
        break;
    } while (TRUE);

    {
        CLock lck(_mxs);
        _cbBytesReported = *pcbNewAvailable;
        *pdwTotalSize = dwTotalSize;
    }

    PerfDbgLog2(tagCTransaction, this, "-CTransaction::OnDataReceived (hr:%lx, _cbBufferFilled:%lx)", hr, _cbBufferFilled);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::ReportResult
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [dwError] --
//              [wzResult] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR wzResult)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolSink::ReportResult",
                "this=%#x, %#x, %#x, %.80wq",
                this, hrResult, dwError, wzResult
                ));

    PerfDbgLog3(tagCTransaction, this, "+CTransaction::ReportResult [hr:%lX, dwError;%lX (%ld)]", hrResult, dwError, dwError);
    HRESULT hr = NOERROR;

    AddRef();

    BOOL fReport = FALSE;
    
    {   //BEGIN SYNC BLOCK
        CLock lck(_mxsBind);
        if (!_fResultReported)
        {
            _fResultReported = TRUE;
            fReport = TRUE;
        }
    }   // END SYNC BLOCK

    if (fReport)
    {
        _hrResult = hrResult;
        _dwResult = dwError;

        if (_pwzResult)
        {
            delete [] _pwzResult;
        }
        _pwzResult = OLESTRDuplicate((LPWSTR)wzResult);

        if (IsFreeThreaded())
        {

            // handle request on this thread
            hr = DispatchReport(BINDSTATUS_RESULT, _grfBSCF, _ulCurrentSize, _ulTotalSize, _pwzResult, _dwResult, _hrResult);
        }
        else
        {
            CTransPacket *pCTP = new CTransPacket( (BINDSTATUS) ((_hrResult == NOERROR) ? BINDSTATUS_RESULT : BINDSTATUS_ERROR),
                                                    _hrResult, _pwzResult, _ulCurrentSize, _ulTotalSize, _dwResult);

            if (pCTP)
            {
            #if DBG==1
                DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
                DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
            #elif defined(PERFTAGS)
                DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
                DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
            #endif
                AddCTransPacket(pCTP);

                if (!IsApartmentThread() || 
                    _fForceAsyncReportResult || 
                    ((_hrResult==INET_E_REDIRECTING) && (_dwOInetBdgFlags & PI_SYNCHRONOUS)))
                {
                    _cPostedMsg++;
                    AddRef();
                    PerfDbgLog4(tagCTransaction, this, "CINet:%lx === PostMessage (Msg:%#x) WM_TRANS_PACKET - dwCurrentSize:%ld, dwTotalSize:%ld",
                                    _pProt, XDBG(++_wTotalPostedMsg,0), dwCurrentSizePerf, dwTotalSizePerf);
                    PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM) (WPARAM)GetTotalPostedMsgId(), (LPARAM)this);

                }
                else
                {
                    OnINetCallback();
                }
            }
        }
    }
    else
    {
        // should not happen with our protocols
        hr = E_FAIL;
    }
    
    Release();

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::ReportResult (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::QueryBindFlags
//
//  Synopsis:
//
//  Arguments:  [DWORD* ] -- emits binding flags
//
//  Returns:
//
//  History:    04-07-2000   RajeevD (Rajeev Dujari)   Created
//
//  Notes: Hack for netdocs to grab binding flags.
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::QueryBindFlags (DWORD* pdwFlags)
{
    *pdwFlags = _dwOInetBdgFlags;
    return S_OK;
}


// protocolinfo methods

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Authenticate
//
//  Synopsis:
//
//  Arguments:  [phwnd] --
//              [LPWSTR] --
//              [pszPassword] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Authenticate(HWND* phwnd, LPWSTR *pszUsername,LPWSTR *pszPassword)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IAuthenticate::Authenticate",
                "this=%#x, %#x, %#x, %#x",
                this, phwnd, pszUsername, pszPassword
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::Authenticate");
    HRESULT hr = E_FAIL;
    IAuthenticate *pBasicAuth = 0;

    AddRef();
    hr = QueryService(IID_IAuthenticate,IID_IAuthenticate, (void **) &pBasicAuth);

    if ((hr == NOERROR) && pBasicAuth)
    {
         hr = pBasicAuth->Authenticate(phwnd, pszUsername,pszPassword);
    }
    else
    {
        UrlMkAssert((pBasicAuth == NULL));
        *phwnd = 0;
        *pszUsername = 0;
        *pszPassword = 0;
    }
    Release();

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Authenticate (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::QueryOption
//
//  Synopsis:
//
//  Arguments:  [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::QueryOption(DWORD dwOption, LPVOID pBuffer, DWORD *pcbBuf)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::QueryOption",
                "this=%#x, %#x, %#x, %#x",
                this, dwOption, pBuffer, pcbBuf
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::QueryOption");
    HRESULT hr = E_FAIL;
    if (_pProt)
    {
        if (!_pInetInfo)
        {
            hr = _pProt->QueryInterface(IID_IWinInetInfo, (void **) &_pInetInfo);
            TransAssert(( (hr == NOERROR && _pInetInfo) || (hr != NOERROR && !_pInetInfo) ));
            if ((hr == NOERROR) && _pUnkInner)
            {
                Release();
            }

        }

        if (_pInetInfo)
        {

            hr = _pInetInfo->QueryOption(dwOption, pBuffer, pcbBuf);
        }
    }
    PerfDbgLog1(tagCTransaction, this, "-CTransaction::QueryOption (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::QueryInfo
//
//  Synopsis:
//
//  Arguments:  [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//              [pdwFlags] --
//              [pdwReserved] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::QueryInfo(DWORD dwOption, LPVOID pBuffer, DWORD *pcbBuf, DWORD *pdwFlags, DWORD *pdwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::QueryInfo",
                "this=%#x, %#x, %#x, %#x, %#x, %#x",
                this, dwOption, pBuffer, pcbBuf, pdwFlags, pdwReserved
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::QueryInfo");
    HRESULT hr = E_FAIL;
    if (_pProt)
    {
        if (!_pInetHttpInfo)
        {
            hr = _pProt->QueryInterface(IID_IWinInetHttpInfo, (void **) &_pInetHttpInfo);
            TransAssert(( (hr == NOERROR && _pInetHttpInfo) || (hr != NOERROR && !_pInetHttpInfo) ));
            if ((hr == NOERROR) && _pUnkInner)
            {
                Release();
            }

        }
        if (_pInetHttpInfo)
        {
            hr = _pInetHttpInfo->QueryInfo(dwOption, pBuffer, pcbBuf, pdwFlags, pdwReserved);
        }
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::QueryInfo (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//IOInetBindInfo methods
//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::GetBindInfo
//
//  Synopsis:
//
//  Arguments:  [pdwBINDF] --
//              [pbindinfo] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::GetBindInfo(DWORD *pdwBINDF, BINDINFO *pbindinfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetBindInfo::GetBindInfo",
                "this=%#x, %#x, %#x",
                this, pdwBINDF, pbindinfo
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::GetBindInfo");
    HRESULT hr = NOERROR;

    TransAssert((pdwBINDF && pbindinfo));

    TransAssert((_pClntBindInfo));
    hr = _pClntBindInfo->GetBindInfo(pdwBINDF, pbindinfo);

    if (SUCCEEDED(hr))
    {
        PerfDbgLog(tagCTransaction, this, "---CTrans::BINDF_FROMURLMON---");
        *pdwBINDF |= BINDF_FROMURLMON;
    }

    // never do a post on redirect
    if (_pwzRedirectUrl)
    {
        if( pbindinfo && (pbindinfo->dwBindVerb == BINDVERB_POST) )
        {
            pbindinfo->dwBindVerb = BINDVERB_GET;
        }
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::GetBindInfo (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::GetBindString
//
//  Synopsis:
//
//  Arguments:  [ulStringType] --
//              [ppwzStr] --
//              [cEl] --
//              [pcElFetched] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::GetBindString(ULONG ulStringType, LPOLESTR *ppwzStr, ULONG cEl, ULONG *pcElFetched)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetBindInfo::GetBindString",
                "this=%#x, %#x, #%#x, %u, %#x",
                this, ulStringType, ppwzStr, cEl, pcElFetched
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::GetBindString");
    HRESULT hr = INET_E_USE_DEFAULT_SETTING;

    // we handles the encoding here
   
    if (    _fEncodingHandlerEnabled  
         && ulStringType == BINDSTRING_ACCEPT_ENCODINGS
         && ppwzStr
         && cEl )
    {
        LPWSTR pwzAcpHeaders = NULL;
        pwzAcpHeaders = DupA2W(gwzAcceptEncHeaders);
        
        if( pwzAcpHeaders ) 
        {
            *ppwzStr =  pwzAcpHeaders;
            *pcElFetched = 1;
            hr = NOERROR;
        }
        else
        {
            hr = E_OUTOFMEMORY;
            *pcElFetched = 0;
        }
    }
    else
    {

        TransAssert((_pClntBindInfo));
    
        hr = _pClntBindInfo->GetBindString(ulStringType, ppwzStr, cEl, pcElFetched);

        PerfDbgLog1(tagCTransaction, this, "-CTransaction::GetBindString (hr:%lx)", hr);
    }


    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::QueryService
//
//  Synopsis:
//
//  Arguments:  [rsid] --
//              [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT IUnknown_QueryService(IUnknown* punk, REFGUID rsid, REFIID riid, void ** ppvObj);

HRESULT CTransaction::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IServiceProvider::QueryService",
                "this=%#x, %#x, %#x, %#x",
                this, &rsid, &riid, ppvObj
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::QueryService");
    HRESULT     hr = NOERROR;
    VDATETHIS(this);
    TransAssert((ppvObj));

    hr = IUnknown_QueryService(_pClntProtSink, rsid, riid, ppvObj);

    TransAssert(( ((hr == E_NOINTERFACE) && !*ppvObj)  || ((hr == NOERROR) && *ppvObj) ));

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::QueryService (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::CTransaction
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransaction::CTransaction(DWORD grfFlags, LPBYTE pByte, ULONG cbSizeBuffer, IUnknown *pUnkOuter)
                          :  _CRefs(), _cPacketsInList(0), _cPostedMsg(0)
                          ,  _CProtEmbed(), _CProtClsInstaller()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransaction::CTransaction",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, grfFlags, pByte, cbSizeBuffer, pUnkOuter
                ));

    _flags = 0;

    if (!pUnkOuter)
    {
        pUnkOuter = &_Unknown;
    }
    _pUnkOuter = pUnkOuter;


    _pCTransNext = NULL;
    _pClntProtSink = NULL;
    _hwndNotify = NULL;
    _pCTransMgr = GetThreadTransactionMgr();
    _State = TransSt_None;
    _cBdgRefs = 0;
    _pCTPHead = NULL;
    _pCTPTail = NULL;
    _pCTPCur = NULL;
    _fDispatch = FALSE;
    _ThreadTransferState = TS_None;
    _fResultReported = FALSE;
    _fTerminated = FALSE;
    _fTerminating = FALSE;
    _fResultDispatched = FALSE;
    _fResultReceived = TRUE;
    _hrResult = NOERROR;
    _dwResult = 0;
    _dwPacketsTotal = 0;
    _grfInternalFlags = 0;
    _pProt = NULL;
    _clsidProtocol = CLSID_NULL;
    _pBndInfo = NULL;
    _pInetInfo = NULL;
    _pInetHttpInfo = NULL;
    _pBndCtx = NULL;
    _dwThreadId = GetCurrentThreadId();
    _dwProcessId = GetCurrentProcessId();
    _grfBSCF = 0;
    _pUnkInner = 0;
    _dwOInetBdgFlags = grfFlags;

    _pBuffer = pByte;                   // DNLD_BUFFER_SIZE  size buffer
    _cbBufferSize  = cbSizeBuffer;
    _cbTotalBytesRead = 0 ;
    _cbBufferFilled = 0;                //how much of the buffer is in use
    _pwzUrl = 0;
    _pwzRedirectUrl = 0;
    _dwTerminateOptions = 0;
    _cbDataSniffMin = DATASNIFSIZE_MIN;
    _fDocFile = FALSE;
    _fMimeVerified = FALSE;
    _fAttached = FALSE;
    _fLocked = FALSE;
    _fModalLoopRunning = FALSE;
    _fUnlocked = FALSE;
    _fMimeHandlerEnabled = TRUE;
    _fEncodingHandlerEnabled = TRUE;
    _fClsInstallerHandlerEnabled = TRUE;
    _fMimeHandlerLoaded = FALSE;
    _pwzFileName = 0;
    _pwzAttachmentName = 0;
    _pwzMimeSuggested = 0; 
    _fProtEmbed = TRUE;
    _fStarting = FALSE;
    _fReceivedAbort = FALSE;
    _fReceivedTerminate = FALSE;
    _hrAbort = NOERROR;
    _dwAbort = 0;
    _dwDispatchLevel = 0;
    _fForceAsyncReportResult = FALSE;
    _fPreferDefaultHandler = FALSE;
    _pwzResult = NULL;
    
#if DBG==1
    _wTotalPostedMsg = 0;
#endif
    _pClntBindInfo = 0;

     _nPriority = THREAD_PRIORITY_NORMAL;
     
     _fContentDispositionAttach = FALSE;
     _fAcceptRanges = FALSE;
    
    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::~CTransaction
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransaction::~CTransaction()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransaction::~CTransaction",
                "this=%#x",
                this
                ));

    PerfDbgLog1(tagCTransaction, this, "+CTransaction::~CTransaction [Url:%ws]", _pwzUrl);

    if (_fLocked && _pProt)
    {
        _pProt->UnlockRequest();
    }
        
    if (_pBuffer)
    {
        delete [] _pBuffer;
    }

    if (_pwzRedirectUrl)
    {
        delete [] _pwzRedirectUrl;
    }

    if (_pwzUrl)
    {
        delete [] _pwzUrl;
    }

    if (_pwzFileName)
    {
        delete [] _pwzFileName;
    }

    if (_pwzAttachmentName)
    {
        delete [] _pwzAttachmentName;
    }

    if (_pwzMimeSuggested)
    {
        delete [] _pwzMimeSuggested;
    }

    if (_pwzProtClsId)
    {
        delete [] _pwzProtClsId;
    }

    if (_pwzResult)
    {
        delete [] _pwzResult;
    }
    
    // Remove ourselves from the global internet transaction list.
    // We should always be in the list.
    if (_pCTransMgr)
    {
        _pCTransMgr->RemoveTransaction(this);
        _pCTransMgr = NULL;
    }

    // Release any leftover packets

    while (_pCTPHead)
    {
        CTransPacket * pCTP = _pCTPHead;
        _pCTPHead = pCTP->GetNext();
        delete pCTP;
    }

    if (_pBndCtx)
    {
        _pBndCtx->Release();
    }

    if (_pClntBindInfo)
    {
        _pClntBindInfo->Release();
        _pClntBindInfo = 0;
    }

    if (_pClntProtSink)
    {
        _pClntProtSink->Release();
    }

    if (_pProt && !_pUnkInner)
    {
        _pProt->Release();
    }
    _pProt = NULL;

    if (_pInetInfo && !_pUnkInner)
    {
        _pInetInfo->Release();
    }
    _pInetInfo = NULL;

    if (_pInetHttpInfo && !_pUnkInner)
    {
        _pInetHttpInfo->Release();
    }
    _pInetHttpInfo = NULL;

    if (_pUnkInner)
    {
        PerfDbgLog1(tagCTransaction, this, "+CTransaction::~CTransaction release pUnkInner (pCINet:%lx)", _pProt);
        _pUnkInner->Release();
        _pUnkInner = NULL;
    }

    if (_pBndInfo)
    {
        //  BINDINFO_FIX(laszlog) 8-18-96

#if DBG == 1
        if (_pBndInfo->stgmedData.tymed != TYMED_NULL)
        {
            PerfDbgLog1(tagCTransaction, this, "+CTransaction::~CTransaction ReleaseStgMedium (%lx)", _pBndInfo->stgmedData);
        }
#endif

        ReleaseBindInfo(_pBndInfo);

        delete _pBndInfo;
    }

    PerfDbgLog(tagCTransaction, this, "-CTransaction::~CTransaction");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Create
//
//  Synopsis:   Creates and initializes a new transaction object
//
//  Arguments:  [pCBdg] --
//              [fConvertData] --
//              [ppCTrans] --
//
//  Returns:
//
//  History:    12-07-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::Create(IBindCtx *pBC, DWORD grfFlags, IUnknown *pUnkOuter, IUnknown **ppUnk, CTransaction **ppCTrans)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::Create",
                "%#x, %#x, %#x, %#x, %#x",
                pBC, grfFlags, pUnkOuter, ppUnk, ppCTrans
                ));
                
    PerfDbgLog(tagCTransaction, NULL, "+CTransaction::Create");

    HRESULT hr = NOERROR;
    TransAssert((ppCTrans != NULL));

    // Create the object
    CTransaction *pCTrans = new CTransaction(grfFlags, NULL, 0, pUnkOuter);

    if (pCTrans)
    {
        // notification window is needed for apartment threaded case
        if  (    (grfFlags & OIBDG_APARTMENTTHREADED )
             &&  (pCTrans->GetNotificationWnd() == NULL))
        {
            delete pCTrans;
            *ppCTrans = NULL;
            hr = E_FAIL;
        }
        else
        {
            // set the cbinding assosiated with it
            pCTrans->SetState(TransSt_Initialized);
            *ppCTrans = pCTrans;
            
            // pCTrans has refcount of 1 now
            // get the pUnkInner; pUnkInner does not addref pUnkOuter
            if (pUnkOuter && ppUnk)
            {
                *ppUnk = pCTrans->GetIUnkInner();
                // addref the outer object since releasing pCINet will go cause a release on pUnkOuter
                PProtAssert((*ppUnk));
            }
        }

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    PerfDbgLog1(tagCTransaction, NULL, "-CTransaction::Create (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::GetTransBindInfo
//
//  Synopsis:   Get the transaction bindinfo
//              Called to pass bindinfo on in IBSC::GetBindInfo and
//              also called by CINet
//
//  Arguments:
//
//  Returns:
//
//  History:    1-16-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BINDINFO *CTransaction::GetTransBindInfo()
{
    DEBUG_ENTER((DBG_TRANS,
                Pointer,
                "CTransaction::GetTransBindInfo",
                "this=%#x",
                this
                ));

    if (_pBndInfo == NULL)
    {
        _pBndInfo = new BINDINFO;

        if (_pBndInfo)
        {
            _pBndInfo->cbSize = sizeof(BINDINFO);
            _pBndInfo->szExtraInfo = 0;
            _pBndInfo->grfBindInfoF = 0;
        }
    }
    else
    {
        _pBndInfo->cbSize = sizeof(BINDINFO);
    }

    DEBUG_LEAVE(_pBndInfo);
    return _pBndInfo;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::RestartOperation
//
//  Synopsis:   Starts the asycn transaction operation
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-07-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::RestartOperation(LPWSTR pwzURL, DWORD dwCase)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::RestartOperation",
                "this=%#x, %.80wq, %#x",
                this, pwzURL, dwCase
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::RestartOperation");

    HRESULT     hr = NOERROR;
    VDATETHIS(this);
    COInetSession *pCOInetSession = 0;
    IOInetProtocol *pProt = 0;

    DWORD dwLocation = 0;
    
    AddRef();

    do
    {

        if (GetState() == TransSt_OperationFinished)
        {
            hr = E_FAIL;
            break;
        }
        
        //
        // case: Start of Transaction
        //

        //TransAssert((_pClntProtSink == NULL));
        BOOL fFirstCreated = FALSE;

        if (dwCase != 0x00000001)
        {
            hr = E_INVALIDARG;
            break;
        }

        // We must have at least one node in the client request linked list
        TransAssert((_pClntProtSink != NULL));
        TransAssert((_pUnkInner == 0));
        TransAssert((_pProt));

        hr = QueryService(IID_IOInetProtocol, IID_IOInetProtocol ,(void **)&pProt);

        if (hr != NOERROR)
        {
            if ((hr = GetCOInetSession(0,&pCOInetSession,0)) == NOERROR)
            {
                DWORD dwOption = _fPreferDefaultHandler ? BINDF_PREFERDEFAULTHANDLER : 0;
                hr = pCOInetSession->CreateFirstProtocol(pwzURL, (IOInetBindInfo *) this, &_pUnkInner, &pProt, &_clsidProtocol, &dwLocation, dwOption);
                fFirstCreated = TRUE;
                if ((hr == NOERROR) && _pUnkInner)
                {
                    TransAssert((pProt));
                    pProt->Release();
                }
            }
        }
        else
        {
            // bugbug: find the correct cls id here.
            _clsidProtocol = CLSID_FtpProtocol;
        }

        if (hr != NOERROR)
        {
            TransAssert((!pProt && !_pUnkInner));
            pProt = 0;
            _pUnkInner = 0;
            break;
        }

        BOOL fNext;
        TransAssert((pProt));
        do  // loop over protocols
        {
            fNext = FALSE;
            TransAssert((hr == NOERROR));
            
            // Start the download operation
            TransAssert((pProt != NULL));
 
            {
                delete [] _pwzProtClsId;
                _pwzProtClsId =  0;

                HRESULT hr1 = StringFromCLSID(_clsidProtocol, &_pwzProtClsId);
                if (SUCCEEDED(hr1))
                {
                    _pClntProtSink->ReportProgress(BINDSTATUS_PROTOCOLCLASSID, _pwzProtClsId);
                }
            }

            SetState(TransSt_OperationStarted);


            if (_fProtEmbed)
            {
                _CProtEmbed.SetProtocol(pProt);
            }
            else
            {
                _pProt = pProt;
            }
            _fResultReported = FALSE;

            hr = pProt->Start(pwzURL, this, (IOInetBindInfo *)this, 0,0);

            if (hr == E_PENDING)
            {
                hr = NOERROR;
            }
            else if (hr == INET_E_USE_DEFAULT_PROTOCOLHANDLER)
            {
                fNext = TRUE;

                if (!_pUnkInner)
                {
                    pProt->Release();
                }

                if( _fProtEmbed )
                {
                    _CProtEmbed.SetProtocol(NULL);
                }

                pProt = 0;
                if (_pUnkInner)
                {
                    _pUnkInner->Release();
                    _pUnkInner = 0;
                }

                // bugbug: need to reset the protocol inside the embed protocol handler
                

                if (!fFirstCreated)
                {
                    DWORD dwOption = _fPreferDefaultHandler ? BINDF_PREFERDEFAULTHANDLER : 0;
                    hr = pCOInetSession->CreateFirstProtocol(pwzURL, (IOInetBindInfo *) this, &_pUnkInner, &pProt, &_clsidProtocol, &dwLocation, dwOption);
                    fFirstCreated = TRUE;
                }
                else
                {
                    hr = pCOInetSession->CreateNextProtocol(pwzURL, (IOInetBindInfo *) this, &_pUnkInner, &pProt, &_clsidProtocol, &dwLocation);
                }

                if (hr != NOERROR)
                {
                    TransAssert((!pProt && !_pUnkInner));
                    pProt = 0;
                    _pUnkInner = 0;
                    fNext = FALSE;

                }
                else if (_pUnkInner)
                {
                    // release the extra addref - aggregation
                    Release();
                }
            }
            else if (hr != NOERROR)
            {
                // do not allow pending packages be dispatched
                // any more
                fNext = FALSE;
                _fDispatch = TRUE;
                
                if (pProt)
                {
                    // Bug# 18869: If pwzURL ends up redirecting again (in other words, 
                    // a nested call to CTransaction::RestartOperation again), and the URL 
                    // redirected to errors out, Terminate() would be called within the 
                    // nested call. Now when the pProt->Start() method propogates that error
                    // from that nested call, and this section of code is hit again, _pClntProtSink
                    // has already been released (and nulled) by the nested CTransaction::RestartOperation.
                    // Alternatively, _fResultDispatched could be checked for TRUE:
                    if(_pClntProtSink)
                    {
                        if( hr == INET_E_REDIRECT_TO_DIR && _pwzRedirectUrl)
                        {
                            _pClntProtSink->ReportResult(hr, 0, _pwzRedirectUrl);
                        }
                        else
                        {
                            _pClntProtSink->ReportResult(_hrResult, _dwResult, 0);
                        }
                    }
                    _fResultDispatched = TRUE;
                    Terminate(0);
                }
            }

        } while  (fNext == TRUE);

        if (   (_dwOInetBdgFlags & PI_SYNCHRONOUS)
            && SUCCEEDED(hr) 
            && (_fModalLoopRunning == FALSE))
        {
            // complet the binding in case of sychronous bind
            TransAssert((_dwOInetBdgFlags & OIBDG_APARTMENTTHREADED));
            _fModalLoopRunning = TRUE;
            hr = CompleteOperation(_dwOInetBdgFlags & (BDGFLAGS_ATTACHED|BDGFLAGS_BTS_BTO));
            _fModalLoopRunning = FALSE;
        }
        
        break;
    } while (TRUE);

    if (pCOInetSession)
    {
        pCOInetSession->Release();
    }

    Release();

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::RestartOperation (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//
// Create global security manager object on demand.
//
HRESULT EnsureSecurityManager ()
{
    if(g_pSecurityManager == NULL)
    {
        // Only 1 thread should be in here, this is to protect
        // global variable g_pSecurityManager
        CLock lck(g_mxsSession);

        if (g_pSecurityManager == NULL)
            return CoInternetCreateSecurityManager( NULL, &g_pSecurityManager, 0);
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Redirect
//
//  Synopsis:   creates a new cinet object
//
//  Arguments:  [szUrl] --
//
//  Returns:
//
//  History:    7-17-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::Redirect(LPWSTR pwzUrl)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::Redirect",
                "this=%#x, %.80wq",
                this, pwzUrl
                ));
                
    PerfDbgLog1(tagCTransaction, this, "+CTransaction::Redirect (szUrlL:%ws)", pwzUrl);
    HRESULT hr = NOERROR;

    TransAssert((pwzUrl != NULL));
    CLSID clsid;

    // Check to see if a non-"special" URL is redirecting to a "special" URL
    //
    if (!IsSpecialUrl(_pwzUrl)         // The original URL
        && IsSpecialUrl(pwzUrl))       // The redirected URL
    {
        // Check the registry workaround
        //
        static DWORD bAllowRedirectToScript = 2;

        if (bAllowRedirectToScript == 2)
        {
            // Read the key and set the static
            BOOL fDefault = FALSE;
            DWORD dwSize = sizeof(DWORD);
            
            SHRegGetUSValue(
                    "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings",
                    "AllowRedirectToScript", 
                    NULL, 
                    (LPBYTE) &bAllowRedirectToScript, 
                    &dwSize, 
                    FALSE, 
                    (LPVOID) &fDefault, 
                    sizeof(fDefault));
        }

        // If it's not allowed, abort the transaction
        //
        if (!bAllowRedirectToScript)
        {
            // Can't redirect to a scripting URL.
            //
            hr = E_ACCESSDENIED;
        }
    }

    // NOTICE-2002/03/04-ganeshs - NTRAID#NTBUG9-556240 - Security: Block redirects to local machine
    // 
    if(SUCCEEDED(hr) && SUCCEEDED(hr = EnsureSecurityManager()))
    {
        // Set conservative defaults:
        DWORD dwZoneIDSource = URLZONE_UNTRUSTED;
        DWORD dwZoneIDTarget = URLZONE_LOCAL_MACHINE;

        if (SUCCEEDED(hr = g_pSecurityManager->MapUrlToZone(pwzUrl, &dwZoneIDTarget, 0))
            && (dwZoneIDTarget == URLZONE_LOCAL_MACHINE) 
            && (SUCCEEDED(hr = g_pSecurityManager->MapUrlToZone(_pwzUrl, &dwZoneIDSource, 0))))
        {

            if (dwZoneIDSource != URLZONE_LOCAL_MACHINE 
                && dwZoneIDSource != URLZONE_INTRANET 
                && dwZoneIDSource != URLZONE_TRUSTED) 
            {
                // Block redirect:
                hr = E_ACCESSDENIED;
            }
        }
    }

    if(!SUCCEEDED(hr))
    {
        Abort(hr, 0);
    }
    else
    {
        {
            COInetSession *pCOInetSession = 0;
            if ((hr = GetCOInetSession(0,&pCOInetSession,0)) == NOERROR)
            {
                hr = pCOInetSession->FindOInetProtocolClsID(pwzUrl, &clsid);
                pCOInetSession->Release();
            }
        }

        if (hr == NOERROR)
        {
            //
            // remove remaining packages from the queue
            //
            {
                CTransPacket *pCTP = 0;

                while ((pCTP = GetNextCTransPacket()) != NULL)
                {
                    // delete the data now
                    delete pCTP;
                }
            }

            IOInetProtocol *pCINetOld = _pProt;

            if (_pInetInfo && !_pUnkInner)
            {
                _pInetInfo->Release();
            }
            _pInetInfo = NULL;

            if (_pInetHttpInfo && !_pUnkInner)
            {
                _pInetHttpInfo->Release();
            }
            _pInetHttpInfo = NULL;

            //
            // no post on redirect
            if (_pBndInfo && (_pBndInfo->dwBindVerb == BINDVERB_POST))
            {
                _pBndInfo->dwBindVerb = BINDVERB_GET;
            }
            if (_fProtEmbed)
            {
                IOInetProtocol *pProt = 0;

                hr = _CProtEmbed.GetProtocol(&pProt);
                if (hr == NOERROR)
                {
                    pProt->Terminate(0);
                    pProt->Release();
                }
                _CProtEmbed.SetProtocol(0);
                if (_pUnkInner)
                {
                    //PerfDbgLog2(tagCTransaction, this, "+CTransaction::~CTransaction Nulling (pCINet:%lx, hServer:%lx)", _pProt, _pProt->_hServer);
                    _pUnkInner->Release();
                    _pUnkInner = NULL;
                }
            }
            else
            {
                _pProt->Terminate(0);

                if (_pProt && !_pUnkInner)
                {
                    //PerfDbgLog2(tagCTransaction, this, "+CTransaction::~CTransaction Nulling (pCINet:%lx, hServer:%lx)", _pProt, _pProt->_hServer);
                    _pProt->Release();
                }
                _pProt = NULL;

                if (_pUnkInner)
                {
                    //PerfDbgLog2(tagCTransaction, this, "+CTransaction::~CTransaction Nulling (pCINet:%lx, hServer:%lx)", _pProt, _pProt->_hServer);
                    _pUnkInner->Release();
                    _pUnkInner = NULL;
                }
            }
            
            SetState(TransSt_Initialized);
            hr = RestartOperation(pwzUrl,0x00000001);
             
        }
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Redirect(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::AddClientOInet
//
//  Synopsis:   Adds clients OInet interfaces.
//
//  Arguments:  [pCBdg] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::AddClientOInet(IOInetProtocolSink *pOInetProtSink, IOInetBindInfo *pOInetBindInfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::AddClientOInet",
                "this=%#x, %#x, %#x",
                this, pOInetProtSink, pOInetBindInfo
                ));
                
    PerfDbgLog2(tagCTransaction, this, "+CTransaction::AddClientOInet, pProtocolSink:%lx, pBindInfo:%lx", pOInetProtSink, pOInetBindInfo);

    TransAssert((pOInetProtSink && pOInetBindInfo));
    
    RemoveClientOInet();

    if (_fProtEmbed)
    {
        _CProtEmbed.SetProtocolSink(pOInetProtSink);
        _pClntProtSink = &_CProtEmbed;
        _cBdgRefs++;
    }
    else
    {
        _cBdgRefs++;
        _pClntProtSink = pOInetProtSink;
        pOInetProtSink->AddRef();
    }
    
    _pClntBindInfo = pOInetBindInfo;
    pOInetBindInfo->AddRef();

    PerfDbgLog(tagCTransaction, this, "-CTransaction::AddClientOInet");

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::RemoveClientOInet
//
//  Synopsis:   Removes OInetProtocolSink and OInetBindInfo interfaces. 
//
//  Arguments:  
//
//  Returns:
//
//  History:    2-02-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::RemoveClientOInet()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::RemoveClientOInet",
                "this=%#x",
                this
                ));
                
    PerfDbgLog1(tagCTransaction, this, "+CTransaction::RemoveClientOInet _pClntProtSink:%lx", _pClntProtSink);
    HRESULT hr = NOERROR;
    BOOL fRelease = FALSE;

    if (_fProtEmbed && _cBdgRefs)
    {
        _CProtEmbed.SetProtocolSink(0);
        _CProtEmbed.SetServiceProvider(0);
        _pClntProtSink = 0;
        _cBdgRefs--;
    }
    else if (_pClntProtSink)
    {
        _pClntProtSink->Release();
        _pClntProtSink = 0;
        _cBdgRefs--;
        fRelease = TRUE;
    }
    
    if (_pClntBindInfo)
    {
        _pClntBindInfo->Release();
        _pClntBindInfo = 0;
    }

    TransAssert((_pClntProtSink == 0 && _cBdgRefs == 0));

    hr = (fRelease) ? S_OK : S_FALSE;

    PerfDbgLog2(tagCTransaction, this, "-CTransaction::RemoveClientOInet (_pClntProtSink:%lx, hr:%lx)", _pClntProtSink, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

#if 0
//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::RemoveAllCBindings
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-02-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::RemoveAllCBindings()
{
    PerfDbgLog(tagCTransaction, this, "+CTransaction::RemoveAllCBindings");
    HRESULT hr = NOERROR;
    CBinding *pCBdg;
    CBinding *pCBdgNext;

    TransAssert((_pClntProtSink == 0 &&    _cBdgRefs == 0));
    /*
    
    TransAssert((   (_cBdgRefs == 0 && _pClntProtSink == NULL)
                 || (_cBdgRefs != 0 && _pClntProtSink != NULL) ));

    if (_pClntProtSink)
    {
        _pClntProtSink->Release();
        _pClntProtSink = 0;
        _cBdgRefs--;

    }

    // the list should be empty now
    DbgLog1(tagCTransaction, this, "=== CTransaction::RemoveAllCBindings Removing transaction, cRefs:%ld", _cBdgRefs);
    TransAssert((_cBdgRefs == 0));
    TransAssert((_pCTransMgr));

    // remove the transaction if no cbindings left
    //_pCTransMgr->RemoveTransaction(this);
    //_pCTransMgr = NULL;

    _pClntProtSink = NULL;
    */
    
    PerfDbgLog(tagCTransaction, this, "-CTransaction::RemoveAllCBindings");
    return hr;
}
#endif // 0
//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::MyPeekMessage
//
//  Synopsis:   This function is called whenever we want to do a PeekMessage.
//              It has special handling for WM_QUIT messages.
//
//  Arguments:  [pMsg] - message structure
//              [hWnd] - window to peek on
//              [min/max] - min and max message numbers
//              [wFlag] - peek flags
//
//  Returns:    TRUE  - a message is available
//              FALSE - no messages available
//
//  Algorithm:
//
//  History:    7-26-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::MyPeekMessage(MSG *pMsg, HWND hwnd, UINT min, UINT max, WORD wFlag)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::MyPeekMessage",
                "this=%#x, %#x, %#x, %#x, %#x, %#x",
                this, pMsg, hwnd, min, max, wFlag
                ));
                
    HRESULT hr = S_OK;
    BOOL fRet = PeekMessage(pMsg, hwnd, min, max, wFlag);
    if (fRet)
    {
        PerfDbgLog3(tagCTransaction, this, "MyPeekMessage: hwnd:%#x, msg:%#x time:%#x", pMsg->hwnd, pMsg->message, pMsg->time);
        if (pMsg->message == WM_QUIT)
        {
            PostQuitMessage((int)pMsg->wParam);
            hr  = S_FALSE;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::CompleteOperation
//
//  Synopsis:   Simple modal loop
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-13-95   JohannP (Johann Posch)   Created
//
//  Notes:      BUGBUG: NOT COMPLETE YET!
//
//----------------------------------------------------------------------------
HRESULT CTransaction::CompleteOperation(BOOL fNested)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::CompleteOperation",
                "this=%#x, %B",
                this, fNested
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::CompleteOperation");

    MSG msg;
    HRESULT hr = NO_ERROR;

    CUrlMkTls tls(hr);
    LONG cDispatchLevel;
    BOOL fDispatch = _fDispatch;

    if (hr == NOERROR)
    {
        HRESULT hr1 = NOERROR;
        HRESULT hrPeek;

        CModalLoop MsgFlter(&hr1);

        AddRef();
        cDispatchLevel = tls->cDispatchLevel;

        TransAssert((cDispatchLevel >= 0));
        tls->cDispatchLevel++;

        if (fNested)
        {
            fDispatch = _fDispatch;
            _fDispatch = FALSE;
        }

        // run the modal loop in case we have a IMessageFilter
        if (hr1 == NOERROR)
        {
            DWORD dwWakeReason = WAIT_TIMEOUT;
            DWORD dwInput = QS_ALLINPUT;
            DWORD dwWaitTime = 1000;
            DWORD dwIBSCLevel = (tls->cDispatchLevel > 1)
                                    ? IBSCLEVEL_TOPLEVEL : IBSCLEVEL_NESTED;

            while (GetState() != TransSt_OperationFinished)
            {
                dwWakeReason = MsgWaitForMultipleObjects(0, 0, FALSE, dwWaitTime, dwInput);

                if (   (dwWakeReason == (WAIT_OBJECT_0 + 0))
                    || (dwWakeReason == WAIT_TIMEOUT))
                {
                    DWORD dwStatus = GetQueueStatus(QS_ALLINPUT);


                    // some messages are in the queue
                    if (dwStatus)
                    {

                        while ((hrPeek = MyPeekMessage(&msg, _hwndNotify, WM_USER, WM_TRANS_LAST, PM_REMOVE | PM_NOYIELD)) == S_OK)
                        {
                            TranslateMessage(&msg);
                            DispatchMessage(&msg);
                        }
                        if (hrPeek == S_FALSE)
                        {
                            hr  = S_FALSE;
                            goto End;
                        }
                        // call MessagePending on
                        MsgFlter.HandlePendingMessage(dwStatus,cDispatchLevel,0);

                    }
                }
            }
        }
        else
        {
            // just run a dispatch loop for our own messages
            while (GetState() != TransSt_OperationFinished)
            {
                // wake up every 5 seconds
                // this is needed since our msg might be dispatched somewhere else
                // on the stack inside the protocol
                DWORD dwWaitTime = 5000;
                //changed QS_ALLINPUT to QS_POSTMESSAGE so that we wake up only for new posted messages.
                //QS_ALLINPUT was making us return as soon as there were any messges in the queue.
                //Ideally, we only want to wait for posted messages for the _hwndNotify handle in the WM_USER
                //to WM_TRANS_LAST range.
                DWORD dwWakeReason = MsgWaitForMultipleObjects(0, 0, FALSE, dwWaitTime, QS_POSTMESSAGE);


                if (dwWakeReason == (WAIT_OBJECT_0 + 0))
                {
                    while ((hrPeek = MyPeekMessage(&msg, _hwndNotify, WM_USER, WM_TRANS_LAST, PM_REMOVE | PM_NOYIELD)) == S_OK)
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                    if (hrPeek == S_FALSE)
                    {
                        hr  = S_FALSE;
                        goto End;
                    }
                }
                else if (dwWakeReason == WAIT_TIMEOUT)
                {
                    // nothing to do here
                }
            }
        }

        hr = GetHResult();

        //
        // dispatch all the other notification messages
        //
        while ((hrPeek = MyPeekMessage(&msg, _hwndNotify, WM_USER, WM_TRANS_LAST, PM_REMOVE | PM_NOYIELD)) == S_OK)
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

    End:
        if (fNested)
        {
            _fDispatch = fDispatch;
        }

        // reset the dispatch level
        tls->cDispatchLevel--;
        Release();
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::CompleteOperation (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::PrepareThreadTransfer
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::PrepareThreadTransfer()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::PrepareThreadTransfer",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::PrepareThreadTransfer");
    TransAssert(( IsApartmentThread() ));
    TransAssert((_ThreadTransferState == TS_None));

    HRESULT hr = E_OUTOFMEMORY;

    if (   _ThreadTransferState == TS_None
        && _pCTPCur)
    {
        // make a copy of the current packet
        // this packet will be send to the new
        // thread once the transfer completed

        _pCTPTransfer = new CTransPacket( (BINDSTATUS) BINDSTATUS_INTERNAL);

        if (_pCTPTransfer)
        {
            hr = NOERROR;
            *_pCTPTransfer = *_pCTPCur;

            _ThreadTransferState = TS_Prepared;

            if (_pProt)
            {
                IOInetThreadSwitch *pOInetThS;
                HRESULT hr1 = _pProt->QueryInterface(IID_IOInetThreadSwitch,(void **) &pOInetThS);

                if (hr1 == NOERROR)
                {
                    TransAssert((pOInetThS));
                    pOInetThS->Prepare();
                    pOInetThS->Release();
                }
            }
        }
    }

    PerfDbgLog(tagCTransaction, this, "-CTransaction::PrepareThreadTransfer");

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::ThreadTransfer
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::ThreadTransfer()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::ThreadTransfer",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::ThreadTransfer");
    TransAssert(( !IsApartmentThread() ));
    TransAssert((_ThreadTransferState == TS_Prepared));

    HRESULT hr = NOERROR;

    if (_ThreadTransferState == TS_Prepared)
    {
        _hwndNotify = GetThreadNotificationWnd();

        // check the threadID and set the new window
        _dwThreadId = GetCurrentThreadId();

        _ThreadTransferState = TS_Completed;
        TransAssert((_pCTPTransfer));
        if (_pCTPTransfer)
        {
            CTransPacket *pCTP = _pCTPTransfer;
            #if DBG==1
                DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
                DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
            #elif defined(PERFTAGS)
                DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
                DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
            #endif
            _pCTPTransfer = NULL;

            AddCTransPacket(pCTP, FALSE);
            {
                _cPostedMsg++;
                AddRef();
                PerfDbgLog4(tagCTransaction, this, "CINet:%lx === CTransaction::ThreadTransfer (Msg:%#x) WM_TRANS_PACKET - dwCurrentSize:%ld, dwTotalSize:%ld",
                    _pProt, XDBG(++_wTotalPostedMsg,0), dwCurrentSizePerf, dwTotalSizePerf);
                #if DBG==1
                PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM)_wTotalPostedMsg, (LPARAM)this);
                #else
                PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM) 0, (LPARAM)this);
                #endif

            }
            {
                IOInetThreadSwitch *pOInetThS;
                HRESULT hr1 =_pProt->QueryInterface(IID_IOInetThreadSwitch,(void **) &pOInetThS);

                if (hr1 == NOERROR)
                {
                    TransAssert((pOInetThS));
                    pOInetThS->Continue();
                    pOInetThS->Release();
                }
            }
        }
    }

    PerfDbgLog(tagCTransaction, this, "-CTransaction::ThreadTransfer");

    DEBUG_LEAVE(hr);
    return hr;
}

/* this code path valid only for Trident BTS -> Shdocvw BTO */
void CTransaction::ResumeDispatchingPackets()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransaction::ResumeDispatchingPackets",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::ResumeReadingPackets");
    TransAssert(( IsApartmentThread() ));

    TransAssert((_pCTPTransfer));
    if (_pCTPTransfer)
    {
        CTransPacket *pCTP = _pCTPTransfer;
        #if DBG==1
            DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
            DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
        #elif defined(PERFTAGS)
            DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
            DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
        #endif
        _pCTPTransfer = NULL;

        AddCTransPacket(pCTP, FALSE);
        
        // report AcceptRanges and ContentDispositionAttach.       
        {
            CTransPacket *pCTP;
            
            if (_fAcceptRanges)
            {
                pCTP = new CTransPacket( 
                    BINDSTATUS_ACCEPTRANGES, NOERROR, NULL, _ulCurrentSize, _ulTotalSize);
                if (pCTP)
                    AddCTransPacket(pCTP, FALSE);
            }

            if (_fContentDispositionAttach)
            {
                pCTP = new CTransPacket( 
                    BINDSTATUS_CONTENTDISPOSITIONATTACH, NOERROR, (_pwzFileName?_pwzFileName:_pwzAttachmentName), _ulCurrentSize, _ulTotalSize);
                if (pCTP)
                    AddCTransPacket(pCTP, FALSE);
            }
        }
        
        
        _fDispatch = FALSE;
        {
            _cPostedMsg++;
            AddRef();
            PerfDbgLog4(tagCTransaction, this, "CINet:%lx === CTransaction::ThreadTransfer (Msg:%#x) WM_TRANS_PACKET - dwCurrentSize:%ld, dwTotalSize:%ld",
                _pProt, XDBG(++_wTotalPostedMsg,0), dwCurrentSizePerf, dwTotalSizePerf);
            #if DBG==1
            PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM)_wTotalPostedMsg, (LPARAM)this);
            #else
            PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM) 0, (LPARAM)this);
            #endif

        }
    }
    
    PerfDbgLog(tagCTransaction, this, "-CTransaction::ResumeDispatchingPackets");

    DEBUG_LEAVE(0);
    return;
}

/* this code path valid only for Trident BTS -> Shdocvw BTO */
void CTransaction::SuspendDispatchingPackets(CTransPacket* pCTP)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransaction::SuspendDispatchingPackets",
                "this=%#x",
                this
                ));
                
    _pCTPTransfer = new CTransPacket( (BINDSTATUS) BINDSTATUS_INTERNAL);

    if (_pCTPTransfer)
        *_pCTPTransfer = *pCTP;

    DEBUG_LEAVE(0);
    return;
}

#ifdef UNUSED
//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::TransmitPaket
//
//  Synopsis:
//
//  Arguments:  [uiMsg] --
//              [pdld] --
//
//  Returns:
//
//  History:    12-08-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::TransmitPacket(BINDSTATUS NMsg, CINet * pCINet, LPCWSTR szStr,DWORD cbAvailable, DWORD cbTotal)
{
    PerfDbgLog(tagCTransaction, this, "+CTransaction::TransmitPacket");

    HRESULT hr = NOERROR;

    _dwPacketsTotal++;

    CTransPacket *pCTP = new CTransPacket(NMsg, NOERROR, szStr,cbAvailable,cbTotal);

    if (pCTP)
    {
    #if DBG==1
        DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
        DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
    #elif defined(PERFTAGS)
        DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
        DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
    #endif
        if (cbAvailable)
        {
            pCTP->_dwCurrentSize = cbAvailable;
        }
        if (cbTotal)
        {
            pCTP->_dwTotalSize = cbTotal;
        }

        AddCTransPacket(pCTP);

        if ( pCTP->IsLastNotMsg() || !IsApartmentThread() ||  pCTP->IsAsyncNotMsg() )
        {
            _cPostedMsg++;
            AddRef();
            PerfDbgLog4(tagCTransaction, this, "CINet:%lx === CTransaction::TransmitPacket (Msg:%#x) WM_TRANS_PACKET - dwCurrentSize:%ld, dwTotalSize:%ld",
                _pProt, XDBG(++_wTotalPostedMsg,0), dwCurrentSizePerf, dwTotalSizePerf);
            #if DBG==1
            PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM)_wTotalPostedMsg, (LPARAM)this);
            #else
            PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM) 0, (LPARAM)this);
            #endif

        }
        else
        {
            OnINetCallback();
        }

    }
    else
    {
        // post message indicating the packet could not be allocated
        PostMessage(_hwndNotify, WM_TRANS_OUTOFMEMORY, (WPARAM)NULL, (LPARAM)this);
        hr = E_OUTOFMEMORY;
    }

    PerfDbgLog(tagCTransaction, this, "-CTransaction::TransmitPacket");
    return hr;
}
#endif //UNUSED

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::DispatchReport
//
//  Synopsis:
//
//  Arguments:  [NotMsg] --
//              [grfBSCF] --
//              [dwCurrentSize] --
//              [dwTotalSize] --
//              [pwzStr] --
//              [dwError] --
//              [hrReport] --
//
//  Returns:
//
//  History:    4-15-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::DispatchReport(BINDSTATUS NotMsg, DWORD grfBSCF, DWORD dwCurrentSize, DWORD dwTotalSize, LPCWSTR pwzStr, DWORD dwError, HRESULT hresult)
                                               
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::DispatchReport",
                "this=%#x, %#x, %#x, %#x, %#x, %.80wq, %#x, %#x",
                this, NotMsg, grfBSCF, dwCurrentSize, dwTotalSize, pwzStr, dwError, hresult
                ));
                
    PerfDbgLog1(tagCTransaction, this, "+CTransaction::DispatchReport [NotMsg:%lx]", NotMsg);
    HRESULT hr = NOERROR;
    IOInetProtocolSink *pCBdg = _pClntProtSink;
    static const WCHAR *wzClsStr = L"Class Install Handler ";

    if (_fTerminated || !_pClntProtSink)
    {
        // nothing to do
        if (   !_fTerminated
            && (   (BINDSTATUS_RESULT == NotMsg)
                || (BINDSTATUS_ERROR == NotMsg)) )
        {
           _fResultDispatched =  TRUE;
           Terminate(0);
        }
    }
    else
    {
        // clean out the old transfer state
        //
        if (_ThreadTransferState == TS_Completed)
        {
            _ThreadTransferState = TS_None;
        }

        switch (NotMsg)
        {
        case BINDSTATUS_BEGINDOWNLOADDATA:
            if (_dwOInetBdgFlags & PI_DATAPROGRESS)
            {
                pCBdg->ReportProgress(NotMsg, pwzStr);
            }
        case BINDSTATUS_DOWNLOADINGDATA:
        case BINDSTATUS_ENDDOWNLOADDATA:
        {
            //
            // check amount of data an verify mime is requested
            //
            if (OnDataReceived(&grfBSCF, &dwCurrentSize, &dwTotalSize) == NOERROR)
            {
                if (   (NotMsg == BINDSTATUS_ENDDOWNLOADDATA)
                    && (_dwOInetBdgFlags & PI_DATAPROGRESS))
                {
                    pCBdg->ReportProgress(NotMsg, pwzStr);
                }
                hr = pCBdg->ReportData(grfBSCF, dwCurrentSize, dwTotalSize);
            }
        }
        break;
        case BINDSTATUS_REDIRECTING     :
        {
            // report the progress on the redirect url
            TransAssert((pwzStr));
            hr = pCBdg->ReportProgress(NotMsg, pwzStr);
            SetRedirectUrl((LPWSTR)pwzStr);
        }
        break;
        case BINDSTATUS_RESULT:
        case BINDSTATUS_ERROR:
        {
            if (   (hresult == INET_E_REDIRECTING)
                && (pwzStr))
            {
                // Note: it is legal here NOT to have a redirect url
                // if wininet does redirct and it fails it  will reprot this error.
                
                // report progress on redirect and to the redirect
                hr = pCBdg->ReportProgress(BINDSTATUS_REDIRECTING, pwzStr);
                SetRedirectUrl((LPWSTR)pwzStr);
                hr = Redirect((LPWSTR)pwzStr);
                if (   (hr != NOERROR) 
                    && (hr != E_PENDING)
                    && !_fResultDispatched)
                {
                    _fResultDispatched = TRUE;
                    hr = pCBdg->ReportResult(hr, 0, 0);
                }
            }
            else
            {
                _fResultDispatched = TRUE;
                hr = pCBdg->ReportResult(_hrResult, _dwResult, pwzStr);
            }
            
        }
        break;

        case BINDSTATUS_ENCODING:
        {
            /****
            // load the encode filter here
            TransAssert((pwzStr));

            if (_fEncodingHandlerEnabled && pwzStr)
            {
                  // disable data sniff on _CProtEmbed
                  DWORD dwEmbedBndFlags = _CProtEmbed.GetOInetBindFlags();
                  dwEmbedBndFlags &= (~PI_MIMEVERIFICATION & ~PI_DOCFILECLSIDLOOKUP & ~PI_CLASSINSTALL);
                  _CProtEmbed.SetOInetBindFlags(dwEmbedBndFlags);
                 _CProtEncoding.Initialize(this, 0, PP_PRE_SWITCH, _dwOInetBdgFlags, 0, _pProt, _pClntProtSink, 0);
                //hr = LoadHandler(pwzStr, &_CProtEncoding, 0);
                LoadHandler(pwzStr, &_CProtEncoding, 0);
            }
            ***/
        }
        break;

        case BINDSTATUS_CLASSINSTALLLOCATION:
            TransAssert((pwzStr));
            if (_fClsInstallerHandlerEnabled && pwzStr)
            {
                _CProtClsInstaller.Initialize(this, 0, PP_PRE_SWITCH, _dwOInetBdgFlags, 0, _pProt, _pClntProtSink, 0);
                LPWSTR pwzClsURL = 0;
                
                pwzClsURL = new WCHAR[lstrlenW(_pwzUrl) + lstrlenW(pwzStr) + lstrlenW(wzClsStr) + 2]; // +1 for NULL, +1 for another NULL after _pwzUrl

                if (pwzClsURL)
                {
                    StrCpyW(pwzClsURL, wzClsStr);

                    StrCatW(pwzClsURL, _pwzUrl);
                    StrCatW(pwzClsURL, L" ");
                    StrCatW(pwzClsURL, pwzStr);

                    pwzClsURL[lstrlenW(wzClsStr) - 1] = L'\0';
                    pwzClsURL[lstrlenW(_pwzUrl) + lstrlenW(wzClsStr)] = L'\0';
                    
                    hr = LoadHandler(pwzClsURL, &_CProtClsInstaller, 0);
                
                    delete [] pwzClsURL;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            // tell sink to stop waiting on handler (since we're broken)
            if (FAILED(hr))
            {   
                pCBdg->ReportProgress(BINDSTATUS_ENDDOWNLOADCOMPONENTS,NULL);   
            }

        break;

        case BINDSTATUS_CLASSIDAVAILABLE:
            TransAssert((pwzStr));
            hr = pCBdg->ReportProgress(NotMsg, pwzStr);
        break;
        
        case BINDSTATUS_MIMETYPEAVAILABLE:
            TransAssert((pwzStr));
            if ( _fMimeHandlerEnabled && pwzStr && _fProtEmbed && 
                 !_fMimeHandlerLoaded)
            {
                //
                // load a mime filter with the embedded prot class
                if( StrCmpNIW( pwzStr, L"text/html", 9) )
                {
                    hr = LoadHandler(pwzStr, &_CProtEmbed, 0);
                    if (hr == NOERROR)
                    {
                        pCBdg->ReportProgress(BINDSTATUS_LOADINGMIMEHANDLER, NULL);
                        _fMimeHandlerLoaded = TRUE;
                    }
                }
                else
                {
                    //
                    // special treatment for text/html to speed up the
                    // main IE download path 
                    //
                    if(g_bHasMimeHandlerForTextHtml)
                    {
                        hr = LoadHandler(pwzStr, &_CProtEmbed, 0);
                        if (hr == NOERROR)
                        {
                            pCBdg->ReportProgress(BINDSTATUS_LOADINGMIMEHANDLER, NULL);
                            _fMimeHandlerLoaded = TRUE;
                        }
                        else
                        {
                            // to account for cases where the mime type has additional
                            // attribute=value pairs after text/html.  
                            // ( RFC for HTTP 1.1 provides for this. )
                            // eg. Content-Type: text/html; charset=ISO-8859-4
                            if ( StrCmpNIW(pwzStr, L"text/html;", 10) )                            
                                g_bHasMimeHandlerForTextHtml = FALSE;
                            else
                            {
                                hr = LoadHandler(L"text/html", &_CProtEmbed, 0);
                                if (hr == NOERROR)
                                {
                                    pCBdg->ReportProgress(BINDSTATUS_LOADINGMIMEHANDLER, NULL);
                                    _fMimeHandlerLoaded = TRUE;
                                }
                                else
                                    g_bHasMimeHandlerForTextHtml = FALSE;
                            }
                        }
                    }
                    
                }

            }

            if (_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP))
            {
                // report the mime later after sniffing data
                _pwzMimeSuggested = OLESTRDuplicate((LPWSTR)pwzStr);
            }
            else
            {
                hr = pCBdg->ReportProgress(NotMsg, pwzStr);
            }

        break;

        case BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE:
        {
            TransAssert((pwzStr));
            if (_fMimeHandlerEnabled && pwzStr && _fProtEmbed && !_fMimeHandlerLoaded)
            {
                // load a mime filter with the embedded prot class
                hr = LoadHandler(pwzStr, &_CProtEmbed, 0);
                if (hr == NOERROR)
                {
                    pCBdg->ReportProgress(BINDSTATUS_LOADINGMIMEHANDLER, NULL);
                    _fMimeHandlerLoaded = TRUE;
                }

            }

            // disable datasniff on _CProtEmbed so we are able to pass through
            DWORD dwEmbedBndFlags = _CProtEmbed.GetOInetBindFlags();
            dwEmbedBndFlags &= (~PI_MIMEVERIFICATION &~PI_DOCFILECLSIDLOOKUP &~PI_CLASSINSTALL);
            _CProtEmbed.SetOInetBindFlags(dwEmbedBndFlags);

            // the mime filter may already updated the mime type
            // if we are already verified, then ignore this one
            if( _fMimeHandlerLoaded && _fMimeVerified && _pwzMimeSuggested )
            {
                hr = pCBdg->ReportProgress( 
                    BINDSTATUS_MIMETYPEAVAILABLE, _pwzMimeSuggested);
            }
            else
            {
                _pwzMimeSuggested = OLESTRDuplicate((LPWSTR)pwzStr);
                _fMimeVerified = TRUE;

                // we should only report BINDSTATUS_MIMETYPEAVAILABLE 
                // (BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE stops at here)
                hr = pCBdg->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pwzStr);
            }
        }    
        break;

        case BINDSTATUS_CACHEFILENAMEAVAILABLE :
            TransAssert((pwzStr));
            if (_pwzFileName)
                delete [] _pwzFileName;
            _pwzFileName = OLESTRDuplicate((LPWSTR)pwzStr);
            hr = pCBdg->ReportProgress(NotMsg, pwzStr);
            break;

        case BINDSTATUS_CONTENTDISPOSITIONATTACH:
            _fContentDispositionAttach = TRUE;
            if (_pwzAttachmentName)
                delete [] _pwzAttachmentName;
            if (pwzStr)
                _pwzAttachmentName = OLESTRDuplicate((LPWSTR)pwzStr);
            else
                _pwzAttachmentName = NULL;
            hr = pCBdg->ReportProgress(NotMsg, pwzStr);
            break;
            
        case BINDSTATUS_ACCEPTRANGES:
            _fAcceptRanges = TRUE;
            hr = pCBdg->ReportProgress(NotMsg, pwzStr);
            break;
            
        default:
        {
            hr = pCBdg->ReportProgress(NotMsg, pwzStr);
        }

        } // end switch
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::DispatchReport (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CTransaction::PreDispatch()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::PreDispatch",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::PreDispatch");
    HRESULT hr = S_OK;

    {   // single access block
        CLock lck(_mxsBind);
        if (_fTerminated || _fTerminating)
        {
            hr = S_FALSE;
        }
        else
        {
            _dwDispatchLevel++;
        }
    }
    
    PerfDbgLog1(tagCTransaction, this, "-CTransaction::PreDispatch (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CTransaction::PostDispatch()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::PostDispatch",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::PostDispatch");
    HRESULT hr = NOERROR;
    BOOL fCallTerminate = FALSE;


    {   // single access block
        CLock lck(_mxsBind);
        _dwDispatchLevel--;
        fCallTerminate = _fReceivedTerminate;
        _fReceivedTerminate = FALSE;
    }

    if (fCallTerminate)
    {
        Terminate(_dwTerminateOptions);
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::PostDispatch (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::DispatchPacket
//
//  Synopsis:
//
//  Arguments:  [pCTPIn] --
//
//  Returns:
//
//  History:    2-02-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::DispatchPacket(CTransPacket *pCTPIn)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::DispatchPacket",
                "this=%#x, %#x",
                this, pCTPIn
                ));
                
    PerfDbgLog2(tagCTransaction, this, "+CTransaction::DispatchPacket [pCTPIn:%lx, NotMsg:%lx]", pCTPIn, pCTPIn->GetNotMsg());
    HRESULT hr = NOERROR;
    
    // the packet should be in the list
    TransAssert((_fDispatch == TRUE));
    TransAssert((_pCTPCur == NULL && pCTPIn));
    _pCTPCur = pCTPIn;

    hr = DispatchReport(pCTPIn->GetNotMsg(), _grfBSCF, pCTPIn->_dwCurrentSize, pCTPIn->_dwTotalSize, pCTPIn->_pwzStr, pCTPIn->_dwResult, pCTPIn->_hrResult);

    _pCTPCur = NULL;

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::DispatchPacket (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::OnINetCallback
//
//  Synopsis:
//
//  Arguments:  [pCTPIn] --
//
//  Returns:
//
//  History:    12-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::OnINetCallback(BOOL fFromMsgQueue)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::OnINetCallback",
                "this=%#x, %B",
                this, fFromMsgQueue
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::OnINetCallback");
    HRESULT hrRelease = NOERROR;
    CTransPacket *pCTP = NULL;

    if (fFromMsgQueue)
    {
        _cPostedMsg--;
    }

    // the packet should be in the list
    if (   IsApartmentThread()
        && (_fDispatch == FALSE)
        && GotCTransPacket() )
    {
        _fDispatch = TRUE;
        BOOL fDispatch = (_ThreadTransferState == TS_None) || (_ThreadTransferState == TS_Completed);

        ThreadSwitchState TSState = _ThreadTransferState;

        // multiple packets migth be dispatched -
        // therefor the list of packets might be empty

        while (   fDispatch
               && ((pCTP = GetNextCTransPacket()) != NULL))
        {
            if (pCTP->GetNotMsg() == BINDSTATUS_INTERNAL)
            {
                OnINetInternalCallback(pCTP);
            }
            else
            {
                hrRelease = DispatchPacket(pCTP);
            }

            if (   (TSState == TS_None)
                && (_ThreadTransferState == TS_Prepared))
            {
                // do not dispatch any further packages on this thread
                // wait until the transfer completes
                fDispatch = FALSE;
            }

            //TRIDENT BTS->BTO
            if (hrRelease == INET_E_TERMINATED_BIND)
            {
                SuspendDispatchingPackets(pCTP);
                
                fDispatch = FALSE;
            }

            // delete the data now
            delete pCTP;
        }

        if (hrRelease == INET_E_TERMINATED_BIND)
            hrRelease = NOERROR; //TRIDENT BTS->BTO reset hrRelease 
        else
            _fDispatch = FALSE;
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::OnINetCallback (hr:%lx)", hrRelease);

    DEBUG_LEAVE(hrRelease);
    return hrRelease;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::OnINetInternalCallback
//
//  Synopsis:
//
//  Arguments:  [dwState] --
//              [fFromMsgQueue] --
//
//  Returns:
//
//  History:    3-05-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::OnINetInternalCallback(CTransPacket *pCTPIn)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::OnINetInternalCallback",
                "this=%#x, %#x",
                this, pCTPIn
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::OnINetInternalCallback");
    HRESULT hr = NOERROR;
    TransAssert((IsApartmentThread()));
    TransAssert((_pProt));

    _cPostedMsg--;
    _pProt->Continue(pCTPIn);

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::OnINetInternalCallback (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   UrlMonInvokeExceptionFilter
//
//  Synopsis:
//
//  Arguments:  [lCode] --
//              [lpep] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LONG UrlMonInvokeExceptionFilter( DWORD lCode, LPEXCEPTION_POINTERS lpep )
{
    DEBUG_ENTER((DBG_TRANS,
                Int,
                "UrlMonInvokeExceptionFilter",
                "%#x, %#x",
                lCode, lpep
                ));
                
#if DBG == 1
    DbgLog2(tagCTransactionErr, NULL, "Exception 0x%#x at address 0x%#x",
               lCode, lpep->ExceptionRecord->ExceptionAddress);
    DebugBreak();
#endif

    DEBUG_LEAVE(EXCEPTION_EXECUTE_HANDLER);
    return EXCEPTION_EXECUTE_HANDLER;
}

//+---------------------------------------------------------------------------
//
//  Function:   TransactionWndProc
//
//  Synopsis:   the transaction callback function
//
//  Arguments:  [hWnd] --
//              [WPARAM] --
//              [wParam] --
//              [lParam] --
//
//  Returns:
//
//  History:    12-02-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LRESULT CALLBACK TransactionWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "TransactionWndProc",
                "%#x, %#u, %#x, %#x",
                hWnd, msg, wParam, lParam
                ));

    if ((msg >= WM_TRANS_FIRST && msg <= WM_TRANS_LAST))
    {
        switch (msg)
        {
        case WM_TRANS_PACKET:
        {
           DWORD dwFault;
           CTransaction  *pCTrans = (CTransaction *) lParam;
#ifdef WITH_EXCEPTION
           _try
#endif //WITH_EXCEPTION
            {
                TransAssert((pCTrans != NULL));
                PerfDbgLog1(tagCTransaction, pCTrans, "+CTransaction::TransactionWndProc (Msg:%#x)", wParam);

                pCTrans->OnINetCallback(TRUE);

                if (pCTrans->Release() == 0)
                {
                    DbgLog(tagCTransaction, pCTrans, "=== CTransaction::TransactionWndProc Last Release!");
                    pCTrans = 0;
                }

                PerfDbgLog1(tagCTransaction, pCTrans, "-CTransaction::TransactionWndProc (Msg:%#x) WM_TRANS_PACKET", wParam);
            }
#ifdef WITH_EXCEPTION
            _except(UrlMonInvokeExceptionFilter(GetExceptionCode(), GetExceptionInformation()))
            {
                dwFault = GetExceptionCode();

                #if DBG == 1
                //
                // UrlMon catches exceptions when the client generates them. This is so we can
                // cleanup properly, and allow urlmon to continue.
                //
                if (   dwFault == STATUS_ACCESS_VIOLATION
                    || dwFault == 0xC0000194 /*STATUS_POSSIBLE_DEADLOCK*/
                    || dwFault == 0xC00000AA /*STATUS_INSTRUCTION_MISALIGNMENT*/
                    || dwFault == 0x80000002 /*STATUS_DATATYPE_MISALIGNMENT*/ )
                {
                    WCHAR iidName[256];
                    iidName[0] = 0;
                    char achProgname[256];
                    achProgname[0] = 0;

                    GetModuleFileNameA(NULL,achProgname,sizeof(achProgname));
                    DbgLog2(tagCTransactionErr, pCTrans,
                                   "UrlMon has caught a fault 0x%08x on behalf of application %s",
                                   dwFault, achProgname);

                }
                #endif
            }
#ifdef unix
            __endexcept
#endif /* unix */
#endif //WITH_EXCEPTION
        }
        break;
        case WM_TRANS_NOPACKET:
        case WM_TRANS_OUTOFMEMORY:
            // tell the
            break;
        case WM_TRANS_INTERNAL:
            {
                TransAssert((FALSE));
            }
            break;

        }
    }

    DWORD lResult = (DWORD)DefWindowProc(hWnd, msg, wParam, lParam);

    DEBUG_LEAVE(lResult);
    return lResult;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::AddCTransPacket
//
//  Synopsis:
//
//  Arguments:  [pCTP] --
//
//  Returns:
//
//  History:    12-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CTransaction::AddCTransPacket(CTransPacket *pCTP, BOOL fTail)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransaction::AddCTransPacket",
                "this=%#x, %#x, %B",
                this, pCTP, fTail
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransaction::AddCTransPacket");
    CLock lck(_mxs);
    //TransAssert((pCTP != NULL && (pCTP->GetNotMsg() > Notify_None && pCTP->GetNotMsg() <= Notify_Internal) ));

    if (fTail)
    {

        if (_pCTPHead == NULL)
        {
            TransAssert((_pCTPTail == NULL));
            TransAssert((_cPacketsInList == 0));
            _pCTPHead = pCTP;
            _pCTPTail = pCTP;
            _pCTPTail->SetNext(NULL);

        }
        else
        {
            _pCTPTail->SetNext(pCTP);
            _pCTPTail = pCTP;
        }
    }
    else
    {
        // add it at the front
        if (_pCTPHead == NULL)
        {
            TransAssert((_pCTPTail == NULL));
            TransAssert((_cPacketsInList == 0));
            _pCTPHead = pCTP;
            _pCTPTail = pCTP;
            _pCTPTail->SetNext(NULL);

        }
        else
        {
            pCTP->SetNext(_pCTPHead);
            _pCTPHead = pCTP;
        }
    }
    _cPacketsInList++;
    TransAssert((_cPacketsInList > 0));

    PerfDbgLog3(tagCTransaction, this, "-CTransaction::AddCTransPacket [pCTP(%lx)[%lx], cPackets:%ld] ",
        pCTP, pCTP->GetNotMsg(),_cPacketsInList);
        
    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::GetNextCTransPacket
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransPacket *CTransaction::GetNextCTransPacket()
{
    DEBUG_ENTER((DBG_TRANS,
                Pointer,
                "CTransaction::GetNextCTransPacket",
                "this=%#x",
                this
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransaction::GetNextCTransPacket");
    CLock lck(_mxs);
    CTransPacket *pCTP;

    pCTP = _pCTPHead;
    if (_pCTPHead == NULL)
    {
        TransAssert((_pCTPTail == NULL));
        TransAssert((_cPacketsInList == 0));
    }
    else if (_pCTPHead == _pCTPTail)
    {
        TransAssert((_pCTPTail->GetNext() == NULL));
        // only one packet in fifo
        _pCTPHead = _pCTPTail = NULL;
    }
    else
    {
        _pCTPHead = _pCTPHead->GetNext();
    }

    if (pCTP)
    {
        _cPacketsInList--;
    }

    //TransAssert((   (pCTP == NULL) || (pCTP != NULL && (pCTP->GetNotMsg() > Notify_None && pCTP->GetNotMsg() <= Notify_Internal)) ));

    TransAssert((   ((pCTP == NULL) && (_cPacketsInList == 0))
                 || ((pCTP != NULL) && (_cPacketsInList >= 0)) ));

    /*
    TransAssert((   ((pCTP == NULL) && (_cPacketsInList == 0))
                 || ((pCTP != NULL) && (_cPacketsInList >= 0))
                 || ((pCTP != NULL) && (_cPacketsInList == 0) && ((pCTP->GetNotMsg() == Notify_None) || (pCTP->GetNotMsg() == Notify_Error )))
               ));
    */


    PerfDbgLog2(tagCTransaction, this, "-CTransaction::GetNextCTransPacket [pCTP(%lx), cPackets:%ld] ",
        pCTP, _cPacketsInList);
        
    DEBUG_LEAVE(pCTP);
    return pCTP;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::GotCTransPacket
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CTransaction::GotCTransPacket()
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CTransaction::GotCTransPacket",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::GotCTransPacket");
    CLock lck(_mxs);
    BOOL fGot = _pCTPHead ? true : false;
    PerfDbgLog(tagCTransaction, this, "-CTransaction::GotCTransPacket");
        
    DEBUG_LEAVE(fGot);
    return fGot;
}

CTransPacket::CTransPacket(PROTOCOLDATA *pSI)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransPacket::CTransPacket",
                "this=%#x, %#x",
                this, pSI
                ));

    TransAssert((pSI));
    grfFlags    = pSI->grfFlags;
    dwState     = pSI->dwState ;
    pData       = pSI->pData   ;
    cbData      = pSI->cbData  ;

    _dwCurrentSize  = 0;
    _dwTotalSize    = 0;
    _dwResult       = 0;
    _pwzStr         = 0;
    _hrResult       = 0;
    _NotMsg         = (BINDSTATUS) BINDSTATUS_INTERNAL;
        
    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransPacket::CTransPacket
//
//  Synopsis:
//
//  Arguments:  [NMsg] --
//              [hrRet] --
//              [szStr] --
//              [cbAvailable] --
//              [cbTotal] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransPacket::CTransPacket(BINDSTATUS NMsg, HRESULT hrRet, LPCWSTR szStr, DWORD cbAvailable, DWORD cbTotal, DWORD dwResult)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransPacket::CTransPacket",
                "this=%#x, %#x, %#x, %.80wq, %#x, %#x, %#x",
                this, NMsg, hrRet, szStr, cbAvailable, cbTotal, dwResult
                ));
                
    PerfDbgLog1(tagCTransaction, this, "+CTransPacket::CTransPacket (NMsg:%lx)", NMsg);

    _dwCurrentSize = cbAvailable;
    _dwTotalSize = cbTotal;
    _hrResult = hrRet;
    _pCTPNext = NULL;
    _NotMsg = NMsg;
    _pwzStr = NULL;
    _dwResult = dwResult;

    if (szStr)
    {
        _pwzStr = OLESTRDuplicate( (LPWSTR)szStr );
    }

    dwState = _NotMsg;
    pData = this;
    cbData = sizeof(CTransPacket);
    grfFlags = 0;

    PerfDbgLog(tagCTransaction, this, "-CTransPacket::CTransPacket");
        
    DEBUG_LEAVE(0);
}

CTransPacket& CTransPacket::operator=(const CTransPacket& CTPSrc)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransPacket::operator=",
                "this=%#x, %#x",
                this, CTPSrc
                ));

    if (&CTPSrc != this)
    {
        grfFlags    = CTPSrc.grfFlags;
        dwState     = CTPSrc.dwState ;
        pData       = CTPSrc.pData   ;
        cbData      = CTPSrc.cbData  ;

        _dwCurrentSize  = CTPSrc._dwCurrentSize;
        _dwTotalSize    = CTPSrc._dwTotalSize;
        _dwResult       = CTPSrc._dwResult;
        _pwzStr         = NULL;
        _hrResult       = CTPSrc._hrResult;
        _NotMsg         = CTPSrc._NotMsg;
        _pCTPNext       = CTPSrc._pCTPNext;
        
        if (CTPSrc._pwzStr)
        {
            _pwzStr = OLESTRDuplicate( CTPSrc._pwzStr );
        }
    }

    DEBUG_LEAVE(0);
    return *this;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransPacket::~CTransPacket
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransPacket::~CTransPacket()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransPacket::~CTransPacket",
                "this=%#x",
                this
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransPacket::~CTransPacket");

    if (_pwzStr)
    {
        delete _pwzStr;
    }

    PerfDbgLog(tagCTransaction, this, "-CTransPacket::~CTransPacket");
        
    DEBUG_LEAVE(0);
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::CPrivUnknown::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::CPrivUnknown::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::CPrivUnknown::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));

    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    PerfDbgLog(tagCTransaction, this, "+CTransaction::CPrivUnknown::QueryInterface");
    CTransaction *pCTrans = GETPPARENT(this, CTransaction, _Unknown);

    *ppvObj = NULL;
    if ((riid == IID_IUnknown) || (riid == IID_IOInetProtocolSink) )
    {
        *ppvObj = (IOInetProtocolSink *) pCTrans;
        pCTrans->AddRef();
    }
    else if (riid == IID_IOInetBindInfo)
    {
        *ppvObj = (IOInetBindInfo *) pCTrans;
        pCTrans->AddRef();
    }
    else if (riid == IID_IServiceProvider)
    {
        *ppvObj = (IServiceProvider *) pCTrans;
        pCTrans->AddRef();
    }
    else if (riid == IID_IAuthenticate)
    {
        *ppvObj = (IAuthenticate *) pCTrans;
        pCTrans->AddRef();
    }
    else if (riid == IID_IOInetProtocol)
    {
        *ppvObj = (IOInetProtocol *) pCTrans;
        pCTrans->AddRef();
    }
    else if (riid == IID_IOInetPriority)
    {
        *ppvObj = (IOInetPriority *) pCTrans;
        pCTrans->AddRef();
    }
    else if (riid == IID_ITransProtocolSink)
    {
        *ppvObj = (ITransProtocolSink *) pCTrans;
        pCTrans->AddRef();
    }
    else if (riid == IID_IWrappedProtocol)
    {
        *ppvObj = (IWrappedProtocol *) pCTrans;
        pCTrans->AddRef();
    }
    else if (pCTrans->_pUnkInner)
    {
        hr = pCTrans->_pUnkInner->QueryInterface(riid, ppvObj);
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::CPrivUnknown::QueryInterface (hr:%lx)", hr);
        
    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CTransaction::CPrivUnknown::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTransaction::CPrivUnknown::AddRef(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CTransaction::CPrivUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::CPrivUnknown::IUnknown::AddRef");

    LONG lRet = ++_CRefs;

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::CPrivUnknown::AddRef (cRefs:%ld)", lRet);
        
    DEBUG_LEAVE(lRet);
    return lRet;
}
//+---------------------------------------------------------------------------
//
//  Function:   CTransaction::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTransaction::CPrivUnknown::Release(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CTransaction::CPrivUnknown::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::CPrivUnknown::Release");

    CTransaction *pCTransaction = GETPPARENT(this, CTransaction, _Unknown);

    LONG lRet = --_CRefs;

    if (lRet == 0)
    {
        delete pCTransaction;
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::CPrivUnknown::Release (cRefs:%ld)", lRet);
        
    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::OnAttach
//
//  Synopsis:
//
//  Arguments:  [pwzURL] --
//              [pOInetBindInfo] --
//              [pOInetProtSink] --
//              [riid] --
//              [grfOptions] --
//              [pClsidProtocol] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::OnAttach(LPCWSTR pwzURL, IOInetBindInfo *pOInetBindInfo, IOInetProtocolSink *pOInetProtSink, DWORD grfOptions, DWORD_PTR dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::OnAttach",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x",
                this, pwzURL, pOInetBindInfo, pOInetProtSink, grfOptions, dwReserved
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::OnAttach");
    HRESULT     hr = NOERROR;
    VDATETHIS(this);
    do
    {
        hr = NOERROR;
        if (_pwzProtClsId)
        {
            pOInetProtSink->ReportProgress(BINDSTATUS_PROTOCOLCLASSID, _pwzProtClsId);
        }

        if (_pwzRedirectUrl)
        {
            pOInetProtSink->ReportProgress(BINDSTATUS_REDIRECTING,_pwzRedirectUrl);
        }

        if (   (grfOptions & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP))
            && _fMimeVerified
            && _pwzMimeSuggested)
        {
            pOInetProtSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, _pwzMimeSuggested);
        }

        if (_fMimeHandlerLoaded)
        {
            pOInetProtSink->ReportProgress(BINDSTATUS_LOADINGMIMEHANDLER, NULL);
        }                        

        if (_pwzFileName)
        {
            pOInetProtSink->ReportProgress(BINDSTATUS_CACHEFILENAMEAVAILABLE, _pwzFileName);
        }

        // report data now
        // Shdocvw BTO->BTS case
        if (!IsApartmentThread())
        {
            ThreadTransfer();
        }
        // Shdocvw BTO -> Trident BTS case
        else if (_pCTPCur)
        {
            HRESULT hr1;
            hr1 = DispatchReport(_pCTPCur->GetNotMsg(),_grfBSCF, _pCTPCur->_dwCurrentSize, _pCTPCur->_dwTotalSize, _pCTPCur->_pwzStr, 0);
        }
        // Trident BTS-> Shdocvw BTO
        else if (_grfInternalFlags & BDGFLAGS_BTS_BTO)
        {
            ResumeDispatchingPackets();
        }
        
        break;
    } while (TRUE);

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::OnAttach (hr:%lx)", hr);
        
    DEBUG_LEAVE(hr);
    return hr;
}


//
//  IOInetProtocol
//
//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Start
//
//  Synopsis:
//
//  Arguments:  [pwzURL] --
//              [pOInetProtSink] --
//              [pOInetBindInfo] --
//              [grfOptions] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Start(LPCWSTR pwzURL, IOInetProtocolSink *pOInetProtSink,
                                 IOInetBindInfo *pOInetBindInfo, DWORD grfOptions, DWORD_PTR dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolRoot::Start",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x",
                this, pwzURL, pOInetProtSink, pOInetBindInfo, grfOptions, dwReserved
                ));


    PerfDbgLog(tagCTransaction, this, "+CTransaction::Start");
    HRESULT     hr = NOERROR;
    VDATETHIS(this);
    COInetSession *pCOInetSession = 0;
    DWORD dwLocation = 0;
    
    AddRef();

    do
    {
        if (   !pwzURL
            || !pOInetBindInfo
            || !pOInetProtSink
           )
        {
            hr = E_INVALIDARG;
            break;
        }
        if (GetState() == TransSt_OperationFinished)
        {
            hr = E_FAIL;
            break;
        }

        _fPreferDefaultHandler = (grfOptions & BINDF_PREFERDEFAULTHANDLER)?TRUE:FALSE;
        //
        //  case Attachment
        //
        if (GetState() == TransSt_OperationStarted)
        {
            {   // single access block
                CLock lck(_mxsBind);

                TransAssert((grfOptions & (BDGFLAGS_ATTACHED|BDGFLAGS_BTS_BTO)));
                
                if (grfOptions & BDGFLAGS_PARTIAL)
                {
                    _grfInternalFlags |= BDGFLAGS_PARTIAL;
                }
                
/* False asserts after Trident BTS->BTO
                TransAssert((_grfInternalFlags & BDGFLAGS_PARTIAL));
                TransAssert((!_fAttached));
 */
                _fAttached = TRUE;
                if (grfOptions & BDGFLAGS_ATTACHED)
                {
                    _grfInternalFlags &= ~BDGFLAGS_BTS_BTO;
                    _grfInternalFlags |= BDGFLAGS_ATTACHED;
                }
                else if (grfOptions & BDGFLAGS_BTS_BTO)
                {
                    _grfInternalFlags |= BDGFLAGS_BTS_BTO;
                    _CProtEmbed.InitAttachedBindToObject();
                }
                
                if (_fProtEmbed)
                {
                    // no sniffing in this object
                    _dwOInetBdgFlags = (grfOptions & ~(PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP | PI_CLASSINSTALL));
                }
                else
                {
                    _dwOInetBdgFlags = (grfOptions | PI_DATAPROGRESS);
                }


                AddClientOInet(pOInetProtSink, pOInetBindInfo);
         
            }
            
            hr = OnAttach(pwzURL, pOInetBindInfo, pOInetProtSink, grfOptions, dwReserved);
            break;
        }

        if (grfOptions & PI_NOMIMEHANDLER)
                _fMimeHandlerEnabled = FALSE;

        //
        // case: Start of Transaction
        //

        TransAssert((_pClntProtSink == NULL));
        BOOL fFirstCreated = FALSE;

        {   // single access block
            CLock lck(_mxsBind);

            int cchUrlLen;

            cchUrlLen  = wcslen(pwzURL) + 1;
            _pwzUrl = (LPWSTR) new WCHAR [cchUrlLen];
            if (!_pwzUrl)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            wcscpy(_pwzUrl, pwzURL);
            
            TransAssert((_pClntProtSink == 0 && _cBdgRefs == 0));
            
            AddClientOInet(pOInetProtSink, pOInetBindInfo);

            if (grfOptions & BDGFLAGS_PARTIAL)
            {
                _grfInternalFlags |= BDGFLAGS_PARTIAL;
            }

            if (_fProtEmbed)
            {
                // no sniffing in this object
                _dwOInetBdgFlags = (grfOptions & ~(PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP | PI_CLASSINSTALL));
            }
            else
            {
                _dwOInetBdgFlags = (grfOptions | PI_DATAPROGRESS);
            }

        } // end single access

        // 
        // OE4( yet another shipped-so-we-can't-fix product ) will assume
        // ReportResult is always Async (urlmon post a message), because
        // they will do TWO reportResult, if we don't do Async, Terminate
        // will called before the first ReportResult returns, which cleans
        // up everything, when OE4 calls back with second ReportResult, they
        // will fault in urlmon.
        // 
        LONG dwMS = sizeof("mhtml:") - 1;
        if( wcslen(_pwzUrl) >= dwMS && !StrCmpNIW(_pwzUrl, L"mhtml:", dwMS) ) 
        {
            _fForceAsyncReportResult = TRUE;
        }
   
    

        // We must have at least one node in the client request linked list
        TransAssert((_pClntProtSink != NULL));

        hr = QueryService(IID_IOInetProtocol, IID_IOInetProtocol ,(void **)&_pProt);
        // work around InfoViewer bug(IE4 RAID #53224), 
        // they will return NOERROR with _pProt=NULL on QueryService()
        if( hr == NOERROR && _pProt == NULL)
        {
            hr = E_NOINTERFACE;
        }

        if (hr != NOERROR)
        {
            if ((hr = GetCOInetSession(0,&pCOInetSession,0)) == NOERROR)
            {
                DWORD dwOption = _fPreferDefaultHandler ? BINDF_PREFERDEFAULTHANDLER : 0;
                hr = pCOInetSession->CreateFirstProtocol(pwzURL, (IOInetBindInfo *) this, &_pUnkInner, &_pProt, &_clsidProtocol, &dwLocation, dwOption);
                fFirstCreated = TRUE;
                if ((hr == NOERROR) && _pUnkInner)
                {
                    TransAssert((_pProt));
                    _pProt->Release();
                }
            }
        }
        else
        {
            // bugbug: find the correct cls id here.
            _clsidProtocol = CLSID_FtpProtocol;
        }

        if (hr != NOERROR)
        {
            TransAssert((!_pProt && !_pUnkInner));
            _pProt = 0;
            _pUnkInner = 0;
            break;
        }

        BOOL fNext;
        BOOL fProtEmbedded = FALSE; // embed only once
        TransAssert((_pProt));
        do  // loop over protocols
        {
            fNext = FALSE;
            TransAssert((hr == NOERROR));
            
            // Start the download operation
            TransAssert((_pProt != NULL));
            TransAssert(( !IsEqualIID(GetProtocolClassID(),CLSID_NULL) ));

            {
                delete [] _pwzProtClsId;
                _pwzProtClsId =  0;

                HRESULT hr1 = StringFromCLSID(_clsidProtocol, &_pwzProtClsId);
                if (SUCCEEDED(hr1))
                {
                    pOInetProtSink->ReportProgress(BINDSTATUS_PROTOCOLCLASSID, _pwzProtClsId);
                }
            }

            SetState(TransSt_OperationStarted);


            IOInetProtocol* pProtNotAgged = NULL; 
            if (_fProtEmbed && !fProtEmbedded)
            {
                _CProtEmbed.Initialize(this, 0, PP_PRE_SWITCH, grfOptions, 0, _pProt, pOInetProtSink, (LPWSTR )pwzURL);
                _pClntProtSink = (IOInetProtocolSink *)&_CProtEmbed;
                
                if (_pUnkInner)
                {
                    // release the protocol we loaded
                    _pProt->Release();
                }
                else
                {
                    // hold on to the non-aggregrated original prot, 
                    // we will need to release it in case of we don't use 
                    // this protocol 
                    pProtNotAgged = _pProt; 
                }

                _pProt = &_CProtEmbed;
                fProtEmbedded = TRUE;
                if (_pUnkInner)
                {
                    // extra addref for second pointer to this class
                    _pProt->AddRef();
                }
            
            }

            // Just before starting the transaction give it the priority.

            IOInetPriority * pOInetPriority = NULL;
            if (_pProt->QueryInterface(IID_IOInetPriority, (void **) &pOInetPriority) == S_OK)
            {
                pOInetPriority->SetPriority(_nPriority);
                pOInetPriority->Release();
            }

            {   // single access block
                CLock lck(_mxsBind);
                _fStarting = TRUE;
            }

            hr = _pProt->Start(pwzURL, this, (IOInetBindInfo *)this, 0,0);

            {   // single access block
                CLock lck(_mxsBind);
                _fStarting = FALSE;
            }

            if (_fReceivedAbort && (hr != NOERROR))
            {
                Abort(_hrAbort, _dwAbort);
            }
            else if (hr == E_PENDING)
            {
                hr = NOERROR;
            }
            else if (hr == INET_E_USE_DEFAULT_PROTOCOLHANDLER)
            {
                fNext = TRUE;
                AddRef();

                if (!_pUnkInner)
                {
                    _pProt->Release();
                }
                if (fProtEmbedded)
                {
                    if(pProtNotAgged)
                    {
                        pProtNotAgged->Release(); 
                        pProtNotAgged = 0;
                    }
                    _CProtEmbed.SetProtocol(NULL);
                }
                fProtEmbedded = FALSE;
                _pProt = 0;

                if (_pUnkInner)
                {
                    _pUnkInner->Release();
                    _pUnkInner = 0;
                }

                // bugbug: need to reset the protocol inside the embed protocol handler

                if (!fFirstCreated)
                {
                    DWORD dwOption = _fPreferDefaultHandler ? BINDF_PREFERDEFAULTHANDLER : 0;
                    hr = pCOInetSession->CreateFirstProtocol(pwzURL, (IOInetBindInfo *) this, &_pUnkInner, &_pProt, &_clsidProtocol, &dwLocation, dwOption);
                    fFirstCreated = TRUE;
                }
                else
                {
                    hr = pCOInetSession->CreateNextProtocol(pwzURL, (IOInetBindInfo *) this, &_pUnkInner, &_pProt, &_clsidProtocol, &dwLocation);
                }
                
                if (hr != NOERROR)
                {
                    TransAssert((!_pProt && !_pUnkInner));
                    _pProt = 0;
                    _pUnkInner = 0;
                    fNext = FALSE;

                }
                else if (_pUnkInner)
                {
                    // release the extra addref - aggregation
                    Release();
                }

            }
            else if (hr != NOERROR)
            {
                // do not allow pending packages be dispatched
                // any more
                fNext = FALSE;
                _fDispatch = TRUE;
                if (_pProt && !_fTerminated)
                {
                    _fResultDispatched = TRUE;

                    if (fProtEmbedded)
                    {
                        _pClntProtSink->ReportResult(_hrResult, _dwResult, 0);
                    }
                    else
                    {
                        pOInetProtSink->ReportResult(_hrResult, _dwResult, 0);
                    }
                    Terminate(0);
                }
            }

            if(pProtNotAgged)
            {
                pProtNotAgged->Release(); 
                pProtNotAgged = 0;
            }
            
        } while  (fNext == TRUE);

        if (   (grfOptions & PI_SYNCHRONOUS)
            && SUCCEEDED(hr) 
            && (_fModalLoopRunning == FALSE))
        {
            // complet the binding in case of sychronous bind
            TransAssert((grfOptions & OIBDG_APARTMENTTHREADED));
            _fModalLoopRunning = TRUE;
            hr = CompleteOperation(grfOptions & (BDGFLAGS_ATTACHED|BDGFLAGS_BTS_BTO));
            _fModalLoopRunning = FALSE;
        }

        break;
    } while (TRUE);

    if (pCOInetSession)
    {
        pCOInetSession->Release();
    }

    Release();

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Start (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfo] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Continue(PROTOCOLDATA *pStateInfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolRoot::Continue",
                "this=%#x, %#x",
                this, pStateInfo
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransaction::Continue");
    VDATETHIS(this);

    HRESULT hr = NOERROR;

    hr = _pProt->Continue(pStateInfo);

    delete (CTransPacket *)pStateInfo;

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Continue (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Abort
//
//  Synopsis:
//
//  Arguments:  [hrReason] --
//              [dwOptions] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Abort(HRESULT hrReason, DWORD dwOptions)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolRoot::Abort",
                "this=%#x, %#x, %#x",
                this, hrReason, dwOptions
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransaction::Abort");
    VDATETHIS(this);

    HRESULT hr = NOERROR;
    BOOL fAbort = FALSE;
    {   // single access block

        CLock lck(_mxsBind);

        if (!_fAborted && !_fTerminated && _pProt && (_ThreadTransferState == TS_None))
        {
            _fReceivedAbort = TRUE;
            _hrAbort = hrReason;
            _dwAbort = dwOptions;
            // terminate might complete async!
            if (hrReason == NOERROR)
            {
                hrReason = E_ABORT;
            }
            if (!_fStarting)
            {
                _fAborted = TRUE;
                fAbort = TRUE;
            }
        }
    } // end single access

    if (fAbort)
    {
        hr = _pProt->Abort(hrReason, dwOptions);
        if( hr == INET_E_RESULT_DISPATCHED )
        {
            //
            // CINet already dispatch the ReportResult and it
            // is currently in the CTrans's msg queue, we need to 
            // reset those flag so that when the ReportResult
            // finally get processed, we won't get confused 
            // (Terminate gets called)
            //  
            _fAborted = FALSE;
            _fReceivedAbort = FALSE;
        }
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Abort (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Terminate
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Terminate(DWORD dwOptions)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolRoot::Terminate",
                "this=%#x, %#x",
                this, dwOptions
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransaction::Terminate");
    VDATETHIS(this);
    HRESULT hr = E_FAIL;
    BOOL fTotalTerminate = FALSE;

    do 
    {

        {   // single access block
            CLock lck(_mxsBind);

            if (_fTerminated)
            {
                break;
            }

            if (_dwDispatchLevel)
            {
                _fReceivedTerminate = TRUE;
                _dwTerminateOptions = dwOptions;
                break;
            }
            else
            {
                _fTerminating = TRUE;
            }
            fTotalTerminate = _fTerminated;

            TransAssert((  (dwOptions == BDGFLAGS_PARTIAL)
                         || (dwOptions == BDGFLAGS_ATTACHED)
                         || (dwOptions == BDGFLAGS_BTS_BTO)
                         || (dwOptions == 0) ));
                         
            //TransAssert((_grfInternalFlags & BDGFLAGS_PARTIAL));

            if (dwOptions & BDGFLAGS_PARTIAL)
            {
                // remove the first sink
                // 
                if (!(_grfInternalFlags & BDGFLAGS_ATTACHED))
                {
                    // the new sink is not yet attached
                    TransAssert((_cBdgRefs == 1));
                    RemoveClientOInet();

                    // now make sure we shut down this on case no thread transfer is going on
                    if (_ThreadTransferState == TS_None)
                    {
                        _fAborted = TRUE;
                    }
                    
                }
                else
                {
                   TransAssert((   ((_cBdgRefs == 1) && (_pClntProtSink != 0)) 
                                || ((_cBdgRefs == 0) && (_pClntProtSink == 0)) ));
                }
            }
            else if (dwOptions & BDGFLAGS_ATTACHED)
            {
                TransAssert((_cBdgRefs == 1));
                RemoveClientOInet();
            }
            else if (dwOptions & BDGFLAGS_BTS_BTO)
            {
                TransAssert((_cBdgRefs == 1));
                RemoveClientOInet();
            }
            else
            {
                // nothing to do here
            }
            
        }

        if (   !fTotalTerminate
            && (_fResultDispatched || _fAborted))
        {
            fTotalTerminate = TRUE;
            
            hr = NOERROR;
            RemoveClientOInet();

            //
            // release pointers from the APP
            //
            if (_pInetInfo && !_pUnkInner)
            {
                _pInetInfo->Release();
                _pInetInfo = NULL;
            }

            if (_pInetHttpInfo && !_pUnkInner)
            {
                _pInetHttpInfo->Release();
                _pInetHttpInfo = NULL;
            }
                    
            if (_pProt)
            {
                _pProt->Terminate(0);
            }

            if (_pBndInfo)
            {
                //
                #if DBG == 1
                if (_pBndInfo->stgmedData.tymed != TYMED_NULL)
                {
                    PerfDbgLog1(tagCTransaction, this, "+CTransaction::Terminate ReleaseStgMedium (%lx)", _pBndInfo->stgmedData);
                }
                #endif
                ReleaseBindInfo(_pBndInfo);
                delete _pBndInfo;
                _pBndInfo = NULL;
            }
            if (_fProtEmbed && _pUnkInner && !_fLocked && !_fUnlocked)
            {
                // remove extra refcount
                _pProt->Release();
            }
            
            //
            //
            SetState(TransSt_OperationFinished);

            TransAssert((_cBdgRefs == 0));
            //TransAssert(( _fAborted || (!_fAborted && (_cPacketsInList == 0)) ));
        }
        
        {   // single access block
            CLock lck(_mxsBind);
            _fTerminating = FALSE;
            if (fTotalTerminate)
            {
                _fTerminated = TRUE;
            }
        }
        
        break;
    } while (TRUE);

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Terminate (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Suspend
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Suspend()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolRoot::Suspend",
                "this=%#x",
                this
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransaction::Suspend");
    VDATETHIS(this);
    CLock lck(_mxsBind);

    HRESULT hr = NOERROR;

    if( _pProt )
    {
        hr = _pProt->Suspend();
    }
    else
    {
        hr = E_NOTIMPL;
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Suspend (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Resume
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Resume()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolRoot::Resume",
                "this=%#x",
                this
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransaction::Resume");
    VDATETHIS(this);
    CLock lck(_mxsBind);

    HRESULT hr = NOERROR;

    hr = _pProt->Resume();

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Resume (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Read
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [cbBuffer] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Read(void *pBuffer, ULONG cbBuffer, ULONG *pcbRead)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocol::Read",
                "this=%#x, %#x, %#x, %#x",
                this, pBuffer, cbBuffer, pcbRead
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransaction::Read");
    HRESULT     hr = E_FAIL;
    VDATETHIS(this);
    CLock lck(_mxsBind);

    BOOL fRead = TRUE;
    DWORD dwCopy = 0;
    DWORD dwCopyNew = 0;
    
    if (   (_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP))
             && (_cbBufferFilled))
    {
        fRead = FALSE;

        // copy data form the local buffer to the provide buffer
        if (cbBuffer < _cbBufferFilled)
        {
            dwCopy = cbBuffer;
            memcpy(pBuffer, _pBuffer, cbBuffer);
            // move the memory to the front
            memcpy(_pBuffer, _pBuffer + cbBuffer, _cbBufferFilled - cbBuffer);
            _cbBufferFilled -= cbBuffer;
            hr = S_OK;
        }
        else if (cbBuffer == _cbBufferFilled)
        {
            dwCopy = _cbBufferFilled;
            memcpy(pBuffer, _pBuffer, _cbBufferFilled);
            _cbBufferFilled = 0;
            hr = S_OK;
        }
        else
        {
            //
            // user buffer is greater than what is available in
            //
            dwCopy = _cbBufferFilled;
            memcpy(pBuffer, _pBuffer, _cbBufferFilled);
            _cbBufferFilled = 0;
            fRead = TRUE;
            hr = E_PENDING;
        }
    }

    if (fRead == TRUE)
    {
        if (_pProt)
        {
            hr = _pProt->Read( ((LPBYTE)pBuffer) + dwCopy, cbBuffer - dwCopy, &dwCopyNew);
            _cbTotalBytesRead += dwCopyNew;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    if (pcbRead)
    {
        *pcbRead = dwCopy + dwCopyNew;
    }

    PerfDbgLog4(tagCTransaction, this, "-CTransaction::Read (hr:%lx, cbRead:%lx, _cbTotalBytesRead:%lx, _cbBytesReported:%lx)",
                                        hr, *pcbRead, _cbTotalBytesRead, _cbBytesReported);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Seek
//
//  Synopsis:
//
//  Arguments:  [dlibMove] --
//              [dwOrigin] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocol::Seek",
                "this=%#x, %#x, %#x, %#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::Seek");
    VDATETHIS(this);
    CLock lck(_mxsBind);

    HRESULT hr = NOERROR;

    hr = _pProt->Seek(dlibMove, dwOrigin, plibNewPosition);

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Seek (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::LockRequest(DWORD dwOptions)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocol::LockRequest",
                "this=%#x, %#x",
                this, dwOptions
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::LockRequest");
    VDATETHIS(this);
    CLock lck(_mxsBind);

    HRESULT hr = NOERROR;

    hr = _pProt->LockRequest(dwOptions);
    if (SUCCEEDED(hr))
    {
        _fLocked = TRUE;
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::LockRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::UnlockRequest()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocol::UnlockRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::UnlockRequest");
    VDATETHIS(this);
    CLock lck(_mxsBind);

    HRESULT hr = NOERROR;

    hr = _pProt->UnlockRequest();
    if (SUCCEEDED(hr))
    {
        _fLocked = FALSE;
        _fUnlocked = TRUE;
        if (_fProtEmbed && _pUnkInner)
        {
            // remove extra refcount to the protocol
            _pProt->Release();
        }
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::UnlockRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::SetPriority
//
//  Synopsis:
//
//  Arguments:  [nPriority] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::SetPriority(LONG nPriority)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetPriority::SetPriority",
                "this=%#x, %d",
                this, nPriority
                ));
                
    PerfDbgLog1(tagCTransaction, this, "+CTransaction::SetPriority (%ld)", nPriority);

    HRESULT hr = S_OK;

    _nPriority = nPriority;

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::SetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::GetPriority
//
//  Synopsis:
//
//  Arguments:  [pnPriority] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::GetPriority(LONG * pnPriority)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetPriority::GetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::GetPriority");

    HRESULT hr;

    if (!pnPriority)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pnPriority = _nPriority;
        hr = S_OK;
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::GetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::LoadHandler
//
//  Synopsis:
//
//  Arguments:  [pwzStr] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::LoadHandler(LPCWSTR pwzURL, COInetProt *pCProtHndl, DWORD dwMode)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::LoadHandler",
                "this=%#x, %.80wq, %#x, %#x",
                this, pwzURL, pCProtHndl, dwMode
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::LoadHandler");

    HRESULT     hr = NOERROR;
    VDATETHIS(this);
    
    IOInetProtocol      *pProtHandler = 0;
    IOInetProtocolSink  *pProtSnkHandler = 0;

    IOInetProtocolSink  *pProtSnkHandlerToMe = 0;
    IOInetProtocol      *pProtHandlerToMe = 0;
    
    COInetSession       *pCOInetSession = 0;
    CLSID                clsidHandler;

    PROTOCOLFILTERDATA FilterData = {sizeof(PROTOCOLFILTERDATA), 0 ,0, 0,0};
    
    hr = E_FAIL;

    do
    {
        if (!pwzURL || !pCProtHndl)
        {
            hr = E_INVALIDARG;
            break;
        }

        if (!_fProtEmbed)
        {
            // can not load a handler without the embedded object
            break;
        }

        if ((hr = GetCOInetSession(0,&pCOInetSession,0)) != NOERROR)
        {
            break;
        }
        hr = pCOInetSession->CreateHandler(pwzURL, 0, 0, &pProtHandler, &clsidHandler);
        if (FAILED(hr))
        {
            break;
        }
        //
        // get the interfaces for the handler
        //
        TransAssert((pProtHandler));

        FilterData.pProtocolSink = 0;
        FilterData.pProtocol = 0;
        FilterData.pUnk = 0;
        FilterData.dwFilterFlags = 0;

        if (_dwOInetBdgFlags & PI_PASSONBINDCTX)
        {
            // do not need to addref pointer
            FilterData.pUnk = _pBndCtx;
        }
        

        hr = pProtHandler->QueryInterface(IID_IOInetProtocolSink, (void **) &pProtSnkHandler);
        if (hr != NOERROR)
        {
            break;
        }
        // set up the handler now
        {
            DWORD dwOptions = 0;
            TransAssert((pProtSnkHandler));
            pProtHandlerToMe = (IOInetProtocol *) pCProtHndl;
            pProtSnkHandlerToMe = (IOInetProtocolSink *) pCProtHndl;
            FilterData.pProtocol = pProtHandlerToMe;
            _pClntProtSink = pProtSnkHandler;
            _pProt = pProtHandler; 
        }
        
        hr = pProtHandler->Start(pwzURL, pProtSnkHandlerToMe, (IOInetBindInfo *)this, PI_FILTER_MODE | PI_FORCE_ASYNC, (DWORD_PTR) &FilterData);

        if (hr == NOERROR)
        {
        }   
        else if (hr == E_PENDING)
        {   
            // send on the first junk of data
        
            hr = NOERROR;
        }
        else
        {
            pProtHandler->Release();
            pProtHandler = 0;
        }

        break;
    } while (TRUE);

    if (pCOInetSession)
    {
        pCOInetSession->Release();
    }

    if (pProtHandler)
    {
        pProtHandler->Release();
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction:: (hr:%lx)", hr);
        
    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::UpdateVerifiedMimeType
//
//  Synopsis:
//
//  Arguments:  [pwzMime] --
//
//  Returns:
//
//  History:    5-20-1998   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CTransaction::UpdateVerifiedMimeType(LPCWSTR pwzMime)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransaction::UpdateVerifiedMimeType",
                "this=%#x, %.80wq",
                this, pwzMime
                ));
                
    if( pwzMime )
    {

        if( _pwzMimeSuggested )
        {
            delete [] _pwzMimeSuggested;
        }

        _pwzMimeSuggested = OLESTRDuplicate((LPWSTR)pwzMime);
        _fMimeVerified = TRUE;
    }
        
    DEBUG_LEAVE(0);
}


HRESULT CTransaction::GetWrapperCode(LONG * pnCode, DWORD_PTR dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IWrappedProtocol::GetWrapperCode",
                 "this=%#x, %#x, %#x",
                this, pnCode, dwReserved
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::GetWrapperCode");

    HRESULT hr;

    if(!pnCode)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pnCode = 0;
        hr = S_OK;
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::GetWrapperCode (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\transapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       transapi.cxx
//
//  Contents:   API's for internal use
//
//  Classes:
//
//  Functions:
//
//  History:    4-26-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#include "oinet.hxx"
#include <shlwapi.h>
#include <shlwapip.h>
#include <winineti.h>
#include "datasnif.hxx"
#include <winver.h> 
#include <mshtml.h>

PerfDbgTag(tagTransApi, "Urlmon", "Log Trans API", DEB_DATA);

static char szMimeKey[]     = "MIME\\Database\\Content Type\\";
const ULONG ulMimeKeyLen    = ((sizeof(szMimeKey)/sizeof(char))-1);
LPCSTR pszDocObject         = "DocObject";
LPCSTR pszInprocServer      = "InprocServer32";
LPCSTR pszLocalServer       = "LocalServer32";

#define INTERNET_SETTING_KEY    "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"

extern LPSTR        g_pszUserAgentString;
extern BYTE         g_bShortcircuitKnownProtocols;
HMODULE             g_hLibPluginOcx = NULL;

HRESULT GetClassDocFileBuffer(LPVOID pbuffer, DWORD dwSize, CLSID *pclsid);

// borrow from urlmon\download to check if Doc Object handler is installed
// need CLocalComponentInfo & IsControlLocallyInstalled
#ifndef unix
#include "..\download\cdl.h"
#else
#include "../download/cdl.h"
#endif /* unix */

// DocFile properties and constants for extracting CodeBase property
#define DOCFILE_NUMPROPERTIES 3
#define DOCFILE_PROPID_CODEBASE 3
#define DOCFILE_PROPID_MAJORVERSION 4
#define DOCFILE_PROPID_MINORVERSION 5

//
// this new apis should be made public
//
STDAPI URLDownloadW(IUnknown *pUnk, LPCWSTR pwzURL, DWORD pBindInfo, IBindStatusCallback *pBSCB, DWORD dwReserved);
STDAPI URLDownloadA(IUnknown *pUnk, LPCSTR  pszURL, DWORD pBindInfo, IBindStatusCallback *pBSCB, DWORD dwReserved);

#define CF_INGNORE_SLASH 0x00000001     //ignore slash when comparing urls

typedef enum tagCLSCTXEX
{
/*
    // ole default class context values
    CLSCTX_INPROC_SERVER            = 0x0001,
    CLSCTX_INPROC_HANDLER           = 0x0002,
    CLSCTX_LOCAL_SERVER             = 0x0004,
    CLSCTX_INPROC_SERVER16          = 0x0008,
    CLSCTX_REMOTE_SERVER            = 0x0010,
    CLSCTX_INPROC_HANDLER16         = 0x0020,
    CLSCTX_INPROC_SERVERX86         = 0x0040,
    CLSCTX_INPROC_HANDLERX86        = 0x0080
*/
    // new class context values used in GetClassFileOrMime
    CLSCTX_INPROC_DOCOBJECT         = 0x0100,
    CLSCTX_LOCAL_DOCOBJECT          = 0x0200,
    CLSCTX_INPROC_CONTROL           = 0x0400,
    CLSCTX_INPROC_X_CONTROL         = 0x0800,
    CLSCTX_INPROC_PLUGIN            = 0x1000
}   CLSCTXEX;

#define CLSCTX_DOCOBJECT (CLSCTX_INPROC_DOCOBJECT|CLSCTX_LOCAL_DOCOBJECT)

const GUID CLSID_PluginHost =
{
    0x25336921, 0x03F9, 0x11cf, {0x8F, 0xD0, 0x00, 0xAA, 0x00, 0x68, 0x6F, 0x13}
};
const GUID CLSID_MsHtml =
{
    0x25336920, 0x03F9, 0x11cf, {0x8F, 0xD0, 0x00, 0xAA, 0x00, 0x68, 0x6F, 0x13}
};

const GUID FMTID_CodeBase =
{
    0xfe2d9191, 0x7fba, 0x11d0, {0xb3, 0xc2, 0x00, 0xa0, 0xc9, 0x0a, 0xea, 0x82}
};


//+---------------------------------------------------------------------------
//
//  Function:   GetClsIDInfo
//
//  Synopsis:
//
//  Arguments:  [pclsid] --     class id
//              [ClsCtxIn] --   unused
//              [pClsCtx] --    class context of class passed in
//
//  Returns:    S_OK on success
//              E_OUTOFMEMORY
//              E_FAIL
//
//  History:    7-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetClsIDInfo(CLSID *pclsid, DWORD ClsCtxIn, DWORD *pClsCtx)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetClsIDInfo",
                "%#x, %#x, %#x",
                pclsid, ClsCtxIn, pClsCtx
                ));
                
    PerfDbgLog(tagTransApi, NULL, "+GetClsIDInfo");
    HRESULT hr = E_FAIL;

    TransAssert(( pClsCtx && pclsid && !IsEqualGUID(*pclsid, CLSID_NULL) ));

    LPSTR pszCls = StringAFromCLSID(pclsid);

    if (!pszCls)
    {
        hr = E_OUTOFMEMORY;
        *pClsCtx = 0;
    }
    else
    {
        CHAR  szCLSID[CLSIDSTR_MAX + 8];
        HKEY  hClsRegEntry;
        CHAR  szValue[64];
        long  lSize;
        DWORD dwClsCtx = 0;

        strcpy(szCLSID, "CLSID\\");
        strcat(szCLSID, pszCls);

        if (RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hClsRegEntry) == ERROR_SUCCESS)
        {
            lSize = 64;
            HKEY hkeySrv32;
            if( RegOpenKey(hClsRegEntry, pszInprocServer, &hkeySrv32) 
                == ERROR_SUCCESS)
            {
                dwClsCtx |= CLSCTX_INPROC;
                RegCloseKey(hkeySrv32);
            }

            lSize = 64;
            if (RegQueryValue(hClsRegEntry, pszLocalServer, szValue, &lSize) == ERROR_SUCCESS)
            {
                dwClsCtx |= CLSCTX_LOCAL_SERVER;
            }
            lSize = 64;
            if (RegQueryValue(hClsRegEntry, pszDocObject, szValue, &lSize) == ERROR_SUCCESS)
            {
                dwClsCtx |= CLSCTX_INPROC_DOCOBJECT;
            }

            RegCloseKey(hClsRegEntry);
        }

        if (dwClsCtx)
        {
            hr = S_OK;
            *pClsCtx = dwClsCtx;
        }

        delete pszCls;
    }

    PerfDbgLog1(tagTransApi, NULL, "-GetClsIDInfo (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindFileExtension
//
//  Synopsis:
//
//  Arguments:  [pszFileName] --
//
//  Returns:
//
//  History:    2-09-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR FindFileExtension(LPSTR pszFileName)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                String,
                "FindFileExtension",
                "%.80q",
                pszFileName
                ));
            
    PerfDbgLog1(tagTransApi, NULL, "+FindFileExtension (szFileName:%s)", pszFileName);
    LPSTR pStr = NULL;

    if (pszFileName)
    {
        LPSTR lpF = pszFileName + strlen(pszFileName);

        if (lpF)
        {
            while (lpF >= pszFileName)
            {
                if (*lpF=='.')
                {
                    pStr = lpF;
                    break;
                }
                if (*lpF=='/')
                {
                    break;
                }
                lpF--;
            }
        }
    }

    PerfDbgLog1(tagTransApi, NULL, "-FindFileExtension (pStr:%s)", pStr);

    DEBUG_LEAVE(pStr);
    return pStr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsDocFile
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//
//  Returns:    S_OK            buffer is begin of docfile
//              S_FALSE         not begin of docfile
//              E_INVALIDARG    arguments incorrect
//
//  History:    2-09-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT IsDocFile(LPVOID pBuffer, DWORD cbSize)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "IsDocFile",
                "%#x, %#x",
                pBuffer, cbSize
                ));
                
    PerfDbgLog(tagTransApi, NULL, "+IsDocFile");
    HRESULT hr;

    // The byte combination that identifies that a file is a storage of
    // some kind
    BYTE SIGSTG[] = {0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1};
    BYTE CBSIGSTG = sizeof(SIGSTG);

    TransAssert(((pBuffer != NULL) &&  (cbSize != 0) ));

    if (!pBuffer  || (cbSize == 0))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = (!memcmp(pBuffer, SIGSTG, CBSIGSTG)) ? S_OK : S_FALSE;
    }

    PerfDbgLog1(tagTransApi, NULL, "-IsDocFile (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetMimeFromExt
//
//  Synopsis:
//
//  Arguments:  [pszExt] --
//              [pszMime] --
//              [cbMime] --
//
//  Returns:
//
//  History:    4-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetMimeFromExt(LPSTR pszExt, LPSTR pszMime, DWORD *pcbMime)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetMimeFromExt",
                "%.80q, %.80q, %#x",
                pszExt, pszMime, pcbMime
                ));
                
    PerfDbgLog1(tagTransApi, NULL, "+GetMimeFromExt (szExt:%s)", pszExt);
    HRESULT hr = E_FAIL;

    *pszMime = '\0';
    TransAssert((pszExt[0] == '.'));

    // the entry begins with '.' so it may be a file extension
    // query the value (which is the ProgID)

    HKEY hMimeKey = NULL;

    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, pszExt, 0, KEY_QUERY_VALUE, &hMimeKey) == ERROR_SUCCESS)
    {
        DWORD dwType = 1;
        if (RegQueryValueEx(hMimeKey, szContent, NULL, &dwType, (LPBYTE)pszMime, pcbMime) == ERROR_SUCCESS)
        {
            hr = NOERROR;
        }
        RegCloseKey(hMimeKey);
    }

    PerfDbgLog2(tagTransApi, NULL, "-GetMimeFromExt (pszMime:%s, hr:%lx)", pszMime, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetMimeFileExtension
//
//  Synopsis:
//
//  Arguments:  [pszMime] --
//              [pclsid] --
//
//  Returns:
//
//  History:    2-22-96   JohannP (Johann Posch)   Created
//
//  Notes:      BUGBUG: needs to be optimized!
//
//----------------------------------------------------------------------------
HRESULT GetMimeFileExtension(LPSTR pszMime, LPSTR pszExt, DWORD cbSize)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetMimeFileExtension",
                "%.80q, %.80q, %#x",
                pszMime, pszExt, cbSize
                ));
                
    PerfDbgLog1(tagTransApi, NULL, "+GetMimeFileExtension (MimeStr:%s)", pszMime);
    HRESULT hr = REGDB_E_CLASSNOTREG;

    HKEY hMimeKey = NULL;
    DWORD dwError;
    DWORD dwType;
    char szValue[256];
    DWORD dwValueLen = 256;
    char szKey[SZMIMESIZE_MAX + ulMimeKeyLen];

    if ((pszMime == 0) || (pszExt == 0))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pszExt = 0;

        strcpy(szKey, szMimeKey);
        strncat(szKey,pszMime, SZMIMESIZE_MAX);

        switch (RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_QUERY_VALUE, &hMimeKey))
        {
            case ERROR_SUCCESS:
                hr = NOERROR;
            break;
            // win32 will return file not found instead of bad key
            case ERROR_FILE_NOT_FOUND:
            case ERROR_BADKEY:
                hr = REGDB_E_CLASSNOTREG;
            break;
            default:
                hr = REGDB_E_READREGDB;
            break;
        }
        if (hr == NOERROR)
        {
            dwValueLen = 256;
            dwError = RegQueryValueEx(hMimeKey
                                        , szExtension
                                        , NULL
                                        , &dwType
                                        , (LPBYTE)szValue
                                        , &dwValueLen);

            if (  (dwError == ERROR_SUCCESS)
                && pszExt
                && dwValueLen
                && (dwValueLen <= cbSize) )
            {
                StrNCpy(pszExt, szValue, dwValueLen);
            }
        }
    }

    if (hMimeKey)
    {
        RegCloseKey(hMimeKey);
    }

    PerfDbgLog2(tagTransApi, NULL, "-GetMimeFileExtension (hr:%lx, szExt:%s)", hr, pszExt);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetClassMime
//
//  Synopsis:
//
//  Arguments:  [pszMime] --
//              [pclsid] --
//              [fIgnoreMimeClsid] --
//
//  Returns:
//
//  History:    2-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetClassMime(LPSTR pszMime, CLSID *pclsid, BOOL fIgnoreMimeClsid)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetClassMime",
                "%.80q, %#x, %B",
                pszMime, pclsid, fIgnoreMimeClsid
                ));
                
    PerfDbgLog1(tagTransApi, NULL, "+GetClassMime (MimeStr:%s)", pszMime);
    HRESULT hr = REGDB_E_CLASSNOTREG;
    DWORD dwFlags = (fIgnoreMimeClsid) ? MIMEFLAGS_IGNOREMIME_CLASSID: 0;
    HKEY hMimeKey = NULL;
    DWORD dwClsCtx;

    DWORD dwError;
    DWORD dwType;
    char szValue[256];
    DWORD dwValueLen = 256;
    char szKey[SZMIMESIZE_MAX + ulMimeKeyLen];

    if ((pszMime == 0) || (*pszMime == 0))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        strcpy(szKey, szMimeKey);
        strcat(szKey, pszMime);

        switch (RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_QUERY_VALUE, &hMimeKey))
        {
            case ERROR_SUCCESS:
                hr = NOERROR;
            break;
            // win32 will return file not found instead of bad key
            case ERROR_FILE_NOT_FOUND:
            case ERROR_BADKEY:
                hr = REGDB_E_CLASSNOTREG;
            break;
            default:
                hr = REGDB_E_READREGDB;
            break;
        }
        if (hr == NOERROR)
        {
            // if fIgnoreMimeClsid is set, ignore the CLSID entry
            // in the HKCR\MIME tree.
            if (!fIgnoreMimeClsid)
            {
                dwError = RegQueryValueEx(hMimeKey, szClassID, NULL
                                        , &dwType, (LPBYTE)szValue, &dwValueLen);

                hr = REGDB_E_CLASSNOTREG;


                if (dwError == ERROR_SUCCESS)
                {
                    WCHAR sz[256];
                    A2W(szValue,sz,256);
                    hr = CLSIDFromString(sz, pclsid);
                }

                if (hr == NOERROR)
                {
                    goto End;
                }
            }

            hr = REGDB_E_CLASSNOTREG;

            dwValueLen = 256;
            dwError = RegQueryValueEx(hMimeKey
                                        , szExtension
                                        , NULL
                                        , &dwType
                                        , (LPBYTE)szValue
                                        , &dwValueLen);

            if (dwError == ERROR_SUCCESS)
            {

                hr = GetClassFromExt(szValue,pclsid);
                //class still not known
                // try extension
            }
        }
    }

End:
    if (hMimeKey)
    {
        RegCloseKey(hMimeKey);
    }

    PerfDbgLog1(tagTransApi, NULL, "-GetClassMime (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetMimeFlags
//
//  Synopsis:
//
//  Arguments:  [pszMime] --
//              [pdwFlags] --
//
//  Returns:
//
//  History:    2-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetMimeFlags(LPCWSTR pwzMime, DWORD *pdwFlags)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetMimeFlags",
                "%.80wq, %#x",
                pwzMime, pdwFlags
                ));
                
    TransDebugOut((DEB_DATA, "API _IN GetMimeFlags (MimeStr:%ws)\n", pwzMime));
    HRESULT hr = E_FAIL;

    HKEY hMimeKey = NULL;
    DWORD dwError;
    DWORD dwType;
    DWORD dwFlags = 0;
    char szValue[256];
    DWORD dwValueLen = 256;
    char szKey[SZMIMESIZE_MAX + ulMimeKeyLen];

    if ((pwzMime == 0) || (*pwzMime == 0) || !pdwFlags)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        strcpy(szKey, szMimeKey);
        W2A(pwzMime, szKey + ulMimeKeyLen, SZMIMESIZE_MAX);

        *pdwFlags = 0;

        switch (RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_QUERY_VALUE, &hMimeKey))
        {
            case ERROR_SUCCESS:
                hr = NOERROR;
            break;
            // win32 will return file not found instead of bad key
            case ERROR_FILE_NOT_FOUND:
            case ERROR_BADKEY:
                hr = REGDB_E_CLASSNOTREG;
            break;
            default:
                hr = REGDB_E_READREGDB;
            break;
        }
        if (hr == NOERROR)
        {
            dwValueLen = sizeof(DWORD);
            dwError = RegQueryValueEx(hMimeKey, szFlags, NULL
                                    , &dwType, (LPBYTE)&dwFlags, &dwValueLen);

            hr = E_FAIL;

            if (dwError == ERROR_SUCCESS)
            {
                *pdwFlags = dwFlags;
                hr = NOERROR;
            }
        }
    }

    if (hMimeKey)
    {
        RegCloseKey(hMimeKey);
    }

    TransDebugOut((DEB_DATA, "API OUT GetMimeFlags (DWFLAGS:%lx, hr:%lx)\n", dwFlags, hr));

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetMimeInfo
//
//  Synopsis:
//
//  Arguments:  [pszMime] --
//              [pclsid] --
//              [pdwFlags] --
//              [pdwMimeFlags] --
//
//  Returns:
//
//  History:    2-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetMimeInfo(LPSTR pszMime, CLSID *pclsid, DWORD dwFlags, DWORD *pdwMimeFlags)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetMimeInfo",
                "%.80q, %#x, %#x, %#x",
                pszMime, pclsid, dwFlags, pdwMimeFlags
                ));
                
    PerfDbgLog1(tagTransApi, NULL, "+GetMimeInfo (MimeStr:%s)", pszMime);
    HRESULT hr = REGDB_E_CLASSNOTREG;

    BOOL fIgnoreMimeClsid = (dwFlags & MIMEFLAGS_IGNOREMIME_CLASSID);

    HKEY hMimeKey = NULL;
    DWORD dwError;
    DWORD dwType;
    char szValue[256];
    DWORD dwValueLen = 256;
    char szKey[SZMIMESIZE_MAX + ulMimeKeyLen];

    if ((pszMime == 0) || (*pszMime == 0))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        strcpy(szKey, szMimeKey);
        strcat(szKey, pszMime);

        switch (RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_QUERY_VALUE, &hMimeKey))
        {
            case ERROR_SUCCESS:
                hr = NOERROR;
            break;
            // win32 will return file not found instead of bad key
            case ERROR_FILE_NOT_FOUND:
            case ERROR_BADKEY:
                hr = REGDB_E_CLASSNOTREG;
            break;
            default:
                hr = REGDB_E_READREGDB;
            break;
        }
        if (hr == NOERROR)
        {
            // if fIgnoreMimeClsid is set, ignore the CLSID entry
            // in the HKCR\MIME tree.
            if (!fIgnoreMimeClsid)
            {
                dwError = RegQueryValueEx(hMimeKey, szClassID, NULL
                                        , &dwType, (LPBYTE)szValue, &dwValueLen);

                hr = REGDB_E_CLASSNOTREG;


                if (dwError == ERROR_SUCCESS)
                {
                    WCHAR sz[256];
                    A2W(szValue,sz,256);
                    hr = CLSIDFromString(sz, pclsid);
                }

                if (hr == NOERROR)
                {
                    goto End;
                }
            }

            hr = REGDB_E_CLASSNOTREG;

            dwValueLen = 256;
            dwError = RegQueryValueEx(hMimeKey
                                        , szExtension
                                        , NULL
                                        , &dwType
                                        , (LPBYTE)szValue
                                        , &dwValueLen);

            if (dwError == ERROR_SUCCESS)
            {

                hr = GetClassFromExt(szValue,pclsid);
            }

            if (pdwMimeFlags)
            {
                DWORD dwFlags = 0;
                *pdwMimeFlags = 0;
                dwValueLen = sizeof(DWORD);
                dwError = RegQueryValueEx(hMimeKey, szFlags, NULL
                                        , &dwType, (LPBYTE)&dwFlags, &dwValueLen);
                if (dwError == ERROR_SUCCESS)
                {
                    *pdwMimeFlags = dwFlags;
                }
            }
        }
    }

End:
    if (hMimeKey)
    {
        RegCloseKey(hMimeKey);
    }

    PerfDbgLog1(tagTransApi, NULL, "-GetMimeInfo (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     GetClassFromExt
//
//  Synopsis:
//
//  Arguments:  [pszExt] --
//              [pclsid] --
//
//  Returns:
//
//  History:    2-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetClassFromExt(LPSTR pszExt, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetClassFromExt",
                "%.80q, %#x",
                pszExt, pclsid
                ));
                
    PerfDbgLog1(tagTransApi, NULL, "+GetClassFromExt (szExt:%s)", pszExt);
    HRESULT hr = REGDB_E_CLASSNOTREG;

    HKEY        hkRoot = HKEY_CLASSES_ROOT;
    char        szFileExt[MAX_PATH];
    DWORD       cbFileExt = sizeof(szFileExt);

    *pclsid = CLSID_NULL;
    char szProgID[MAX_PATH];
    LONG  cbProgID = sizeof(szProgID);

    if (pszExt[0] == '\0')
    {
        goto End;
    }

    strcpy(szFileExt,pszExt);

    TransAssert((szFileExt[0] == '.'));

    // the entry begins with '.' so it may be a file extension
    // query the value (which is the ProgID)

    if (RegQueryValue(hkRoot, szFileExt, szProgID, &cbProgID) == ERROR_SUCCESS)
    {
        // we got the value (ProgID), now query for the CLSID
        // string and convert it to a CLSID

        char szClsid[40];
        LONG  cbClsid = sizeof(szClsid);
        strcat(szProgID, "\\Clsid");

        if (RegQueryValue(HKEY_CLASSES_ROOT, szProgID, szClsid,&cbClsid) == ERROR_SUCCESS)
        {
            // make sure the clsid is valid
            cbProgID = sizeof(szProgID);
            char szClsidEntry[80];
            strcpy(szClsidEntry, "Clsid\\");
            strcat(szClsidEntry, szClsid);

            if (RegQueryValue(HKEY_CLASSES_ROOT, szClsidEntry,szProgID, &cbProgID) == ERROR_SUCCESS)
            {
                CLSID clsid;
                WCHAR sz[256];
                A2W(szClsid,sz,256);
                hr = CLSIDFromString(sz, pclsid);

                if (hr != NOERROR)
                {
                    *pclsid = CLSID_NULL;
                    hr = REGDB_E_CLASSNOTREG;
                }
            }
        }
    }
End:

    PerfDbgLog1(tagTransApi, NULL, "-GetClassFromExt (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsValidURL
//
//  Synopsis:
//
//  Arguments:  [pBC] --
//              [szURL] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-16-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI IsValidURL(LPBC pBC, LPCWSTR szURL, DWORD dwReserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "IsValidURL",
                    "%#x, %.80wq, %#x",
                    pBC, szURL, dwReserved
                    ));
                
    HRESULT hr;
    PerfDbgLog2(tagTransApi, NULL, "+IsValidURL(pBC:%lx, szURL:%ws)",pBC,szURL);
    WCHAR   wzUrlStr[MAX_URL_SIZE + 1];

    if (szURL == NULL)
    {
        hr = E_INVALIDARG;
    }
    else if (   (ConstructURL(pBC, NULL, NULL, (LPWSTR)szURL, wzUrlStr, sizeof(wzUrlStr), CU_CANONICALIZE) == NOERROR)
             && IsOInetProtocol(pBC, wzUrlStr))
    {
        hr = NOERROR;
    }
    else
    {
        hr = S_FALSE;
    }

    PerfDbgLog3(tagTransApi, NULL, "-IsValidURL(pBC:%lx, szURL:%ws, hr:%lx)",pBC,szURL,hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUrlScheme
//
//  Synopsis:
//
//  Arguments:  pcwsz -- the URL
//              [szURL] --
//              [dwReserved] --
//
//  Returns:    URL_SCHEME_*
//
//----------------------------------------------------------------------------

DWORD
GetUrlScheme(LPCWSTR pcwzUrl)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetUrlScheme",
                "%.80wq",
                pcwzUrl
                ));
                
    if(pcwzUrl)
    {
        PARSEDURLW puW;
        puW.cbSize = sizeof(puW);
        if(SUCCEEDED(ParseURLW(pcwzUrl, &puW)))
        {
            DEBUG_LEAVE(puW.nScheme);
            return puW.nScheme;
        }
    }

    DEBUG_LEAVE(URL_SCHEME_INVALID);
    return URL_SCHEME_INVALID;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetClassFileOrMime2
//
//  Synopsis:
//
//  Arguments:  [pBC] --
//              [wzFilename] --
//              [pBuffer] --
//              [cbSize] --
//              [pwzMime] --
//              [dwReserved] --
//              [pclsid] --
//              [fIgnoreMimeClsid] --
//
//  Returns:
//
//  History:    4-16-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI GetClassFileOrMime2(LPBC pBC, LPCWSTR pwzFilename, LPVOID pBuffer, DWORD cbSize,
                          LPCWSTR pwzMimeIn, DWORD dwReserved, CLSID *pclsid, BOOL fIgnoreMimeClsid)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "GetClassFileOrMime2",
                    "%#x, %.80wq, %#x, %#x, %.80wq, %#x, %#x, %B",
                    pBC, pwzFilename, pBuffer, cbSize, pwzMimeIn, dwReserved, pclsid, fIgnoreMimeClsid
                    ));
                
    PerfDbgLog1(tagTransApi, NULL, "+GetClassFileOrMime(%lx)",pBC);
    HRESULT hr = REGDB_E_CLASSNOTREG;
    HRESULT hrPlugin = REGDB_E_CLASSNOTREG;
    HRESULT hrClass = REGDB_E_CLASSNOTREG;
    char szMime[SZMIMESIZE_MAX];
    char szFilename[MAX_PATH];
    LPSTR pszMime = NULL;
    LPSTR pszFilename = NULL;
    LPSTR pszExt = NULL;
    LPWSTR pwzMime = (LPWSTR)pwzMimeIn;
    DWORD cbMime = SZMIMESIZE_MAX;
    CLSID clsidPlugin = CLSID_NULL;
    BOOL  fDocFile = FALSE;
    DWORD dwClsCtx = 0;
    DWORD dwFlags = (fIgnoreMimeClsid) ? MIMEFLAGS_IGNOREMIME_CLASSID : 0;


    if (   pclsid == NULL
        || (!pwzFilename && (!pBuffer || !cbSize) && !pwzMimeIn))
    {
        hr = E_INVALIDARG;
        goto errRet;
    }
    *pclsid = CLSID_NULL;

    //sniff data here or when setting the mime
    if (pBuffer && cbSize)
    {
        fDocFile = (IsDocFile(pBuffer,cbSize) == S_OK);
        if (fDocFile)
        {
            // do not pass the buffer - no need to sniff data
            hr = FindMimeFromData(pBC, pwzFilename, NULL, 0, pwzMimeIn, 0, &pwzMime, 0);
        }
        else
        {
            hr = FindMimeFromData(pBC, pwzFilename, pBuffer, cbSize, pwzMimeIn, 0, &pwzMime, 0);
        }
    }

    if (pwzMime)
    {
        // convert the mime
        W2A(pwzMime, szMime, SZMIMESIZE_MAX);
        pszMime = szMime;
    }

    if (pwzFilename)
    {
        W2A(pwzFilename, szFilename, MAX_PATH);
        pszFilename = szFilename;
    }

    // 1. find the class based on the mime
    if (pszMime)
    {
        if (pBC)
        {
            hr = FindMediaTypeClass(pBC, szMime, pclsid, 0);
        }

        if (hr != NOERROR)
        {
            // get the class from the mime string
            hr = FindMediaTypeClassInfo(pszMime, pszFilename, pclsid, &dwClsCtx, dwFlags);
        }
    }

    // 2. find class of docfile
    if ((hr != NOERROR || IsEqualGUID(*pclsid, CLSID_NULL)) && cbSize && fDocFile)
    {
        // get class from docfile
        hr = GetClassDocFileBuffer(pBuffer, cbSize, pclsid);
    }

    // 3. use the file to find the class
    if (   (hr != NOERROR)
        && pszFilename)
    {
        pszExt = FindFileExtension(pszFilename);

        // use extension and use class mapping
        if (pszExt != NULL)
        {
            char szMimeExt[SZMIMESIZE_MAX];
            DWORD cbMimeExt = SZMIMESIZE_MAX;

            // get the mime for the file
            hr = GetMimeFromExt(pszExt,szMimeExt, &cbMimeExt);

            if (   (hr == NOERROR)
                && (   (pszMime && strcmp(pszMime, szMimeExt))
                    || !pszMime)
               )
            {
                hr = REGDB_E_CLASSNOTREG;
                if (pBC)
                {
                    // check for class mapping
                    hr = FindMediaTypeClass(pBC, szMimeExt, pclsid, 0);
                }

                if (hr != NOERROR)
                {
                    // get the class from the mime string
                    hr = FindMediaTypeClassInfo(szMimeExt, pszFilename, pclsid, &dwClsCtx, dwFlags);
                }
            }
        }

        // last call GetClassFile
        if ( hr != NOERROR && pwzFilename && (!pwzMime || fDocFile) )
        {
            hr = GetClassFile(pwzFilename, pclsid);
        }

        // should never need to use file to locate CLSID_HTMLDocument
        if (IsEqualGUID(*pclsid, CLSID_HTMLDocument))
        {
            *pclsid = CLSID_NULL;
            hrClass = REGDB_E_CLASSNOTREG;
        }
    }

    // 4. if available check the class id and
    //    trigger check for plugin class id if needed
    if (   (hr == NOERROR)
        && !IsEqualGUID(*pclsid, CLSID_NULL))
    {

        hrClass = NOERROR;
        if (dwClsCtx == 0)
        {
            hr = GetClsIDInfo(pclsid, 0, &dwClsCtx);
        }

        if (hr == NOERROR)
        {
            if (dwClsCtx  & CLSCTX_DOCOBJECT)
            {
                // server of class is a docobject
                hrPlugin = NOERROR;
            }
            else if (dwClsCtx  & CLSCTX_INPROC)
            {
                // server of class is inproc

                // check if the class is mshtml tread it as docobject and stop
                // looking for plugin
                if (IsEqualGUID(*pclsid, CLSID_MsHtml))
                {
                    hrPlugin = NOERROR;
                }
            }
            else if (dwClsCtx  & CLSCTX_LOCAL_SERVER)
            {
                // server of class is local
            }
        }
        // else
        // class is not properly registered
        //
    }

    // 5. check if the download is for a plugin
    //    if yes get the plugin host class id
    if (hrPlugin != NOERROR)
    {
        if (pszExt == NULL && pszFilename)
        {
            pszExt = FindFileExtension(pszFilename);
        }

        // if we have a mime and/or an extension mime check if
        // this is a plugin or an ocx
        if (pszExt || pszMime)
        {
            hrPlugin = GetPlugInClsID(pszExt, NULL, pszMime, &clsidPlugin);
        }

    }
    else
    {
        hrPlugin = E_FAIL;
    }

    // 6. the plugin class use it
    if ( (hrPlugin == NOERROR) && !(dwReserved & GETCLASSFILEORMIME_IGNOREPLUGIN))
    {
        *pclsid = clsidPlugin;
        hr = hrPlugin;
    }
    // used the class found
    else
    {
        hr = hrClass;
    }

    if (pwzMime != pwzMimeIn)
    {
        delete [] pwzMime;
    }

    TransAssert((   (hr != NOERROR && IsEqualGUID(*pclsid, CLSID_NULL))
                 || (hr == NOERROR && !IsEqualGUID(*pclsid, CLSID_NULL)) ));

errRet:
    TransAssert((hr == NOERROR  || hr == REGDB_E_CLASSNOTREG  || hr == E_INVALIDARG));
    PerfDbgLog1(tagTransApi, NULL, "-GetClassFileOrMime (hr:%lx)",hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetClassFileOrMime
//
//  Synopsis:
//
//  Arguments:  [pBC] --
//              [wzFilename] --
//              [pBuffer] --
//              [cbSize] --
//              [pwzMime] --
//              [dwReserved] --
//              [pclsid] --
//
//  Returns:
//
//  History:    4-16-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI GetClassFileOrMime(LPBC pBC, LPCWSTR pwzFilename, LPVOID pBuffer, DWORD cbSize,
                          LPCWSTR pwzMimeIn, DWORD dwReserved, CLSID *pclsid)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "GetClassFileOrMime",
                    "%#x, %.80wq, %#x, %#x, %.80wq, %#x, %#x",
                    pBC, pwzFilename, pBuffer, cbSize, pwzMimeIn, dwReserved, pclsid
                    ));
                    
    HRESULT hr = GetClassFileOrMime2(pBC, pwzFilename, pBuffer, cbSize, pwzMimeIn,
        dwReserved, pclsid, FALSE);

    DEBUG_LEAVE_API(hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetClassDocFileBuffer
//
//  Synopsis:
//
//  Arguments:  [pbuffer] --
//              [dwSize] --
//              [pclsid] --
//
//  Returns:
//
//  History:    2-28-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetClassDocFileBuffer(LPVOID pbuffer, DWORD dwSize, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetClassDocFileBuffer",
                "%#x, %#x, %#x",
                pbuffer, dwSize, pclsid
                ));
                
    PerfDbgLog(tagTransApi, NULL, "+GetClassDocFileBuffer");
    HRESULT hr = E_FAIL;

    ILockBytes *pilb;
    IStorage *pstg;
    STATSTG stat;

    HGLOBAL hGlobal = 0;
    hGlobal = GlobalAlloc(GMEM_FIXED | GMEM_NODISCARD, dwSize);
    if (hGlobal)
    {
        memcpy(hGlobal, pbuffer, dwSize);

        hr = CreateILockBytesOnHGlobal(hGlobal,FALSE,&pilb);
        if (hr == NOERROR)
        {
            hr = StgOpenStorageOnILockBytes(pilb,NULL,STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                        NULL,0,&pstg);

            if (hr == NOERROR)
            {
                pstg->Stat(&stat, STATFLAG_NONAME);
                pstg->Release();
                *pclsid = stat.clsid;
            }
            else
            {
                hr = E_FAIL;
            }
        }
        GlobalFree(hGlobal);
    }

    PerfDbgLog1(tagTransApi, NULL, "-GetClassDocFileBuffer (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT GetCodeBaseFromDocFile(LPBYTE pBuffer, ULONG ulSize, LPWSTR *pwzClassStr, 
                               LPWSTR pwzBaseUrl, DWORD *lpdwVersionMS, DWORD *lpdwVersionLS);

//+---------------------------------------------------------------------------
//
//  Method:     IsHandlerAvailable
//
//  Synopsis:
//
//  Arguments:  [pClsid] --
//              [pMime] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT IsHandlerAvailable(LPWSTR pwzUrl, LPWSTR pwzMime, CLSID *pclsid, LPBYTE pBuffer, ULONG cbSize)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "IsHandlerAvailable",
                "%.80wq, %.80wq, %#x, %#x, %#x",
                pwzUrl, pwzMime, pclsid, pBuffer, cbSize
                ));
                
    PerfDbgLog(tagTransApi, NULL, "+GetCodeBaseFromDocFile");
    HRESULT hr = E_FAIL, hr1;
    LPWSTR szDistUnit = 0;
    BOOL fIgnoreMimeClsid = FALSE, fHasHandler = FALSE, fDocFile = FALSE;
    CLocalComponentInfo lci;
    CHAR szKey[SZMIMESIZE_MAX + ulMimeKeyLen];
    CHAR szMime[SZMIMESIZE_MAX];
    LPSTR pszUrl = 0;

    W2A(pwzMime, szMime, SZMIMESIZE_MAX);
    pszUrl = DupW2A(pwzUrl);        // can potentially be very long

    if ((pwzMime == 0) || (*pwzMime == 0))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        HKEY hMimeKey = 0;
     
        *pclsid = CLSID_NULL;

        strcpy(szKey, szMimeKey);
        strcat(szKey, szMime);

        // NOTE: different handlers may be implemented in different ways, for example.
        // the abscence of a CLSID does not imply the handler is bad or missing.

        // check if mime type exists in "Content Type" branch
        if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_QUERY_VALUE, &hMimeKey) == ERROR_SUCCESS)
        {
            fHasHandler = TRUE;
            RegCloseKey(hMimeKey);
            hMimeKey = 0;
        }
        
        // if not check if extension type has handler
        if (!fHasHandler)
        {
            LPSTR pszExt = FindFileExtension(pszUrl);

            // try for handler of extension
            if (pszExt && *pszExt == '.')
            {
                hMimeKey = 0;

                // there may be a handler for this extension already
                if (RegOpenKeyEx(HKEY_CLASSES_ROOT, pszExt, 0, KEY_QUERY_VALUE, &hMimeKey) == ERROR_SUCCESS)
                {
                    fHasHandler = TRUE;
                    RegCloseKey(hMimeKey);
                }
            }
        }

        // we haven't found a handler yet, in case of DocFile, check if CLSID associated
        // with it exists.  
        if (!fHasHandler && SUCCEEDED(IsDocFile(pBuffer,cbSize)))
        {
            DWORD dwVersionMS = 0, dwVersionLS = 0;
            LPWSTR pwzCodeBase = 0;

            hr1 = GetCodeBaseFromDocFile(pBuffer, cbSize, &pwzCodeBase, NULL, &dwVersionMS, &dwVersionLS);
            if (pwzCodeBase) {

                delete pwzCodeBase;
            }

            hr1 = GetClassDocFileBuffer(pBuffer, cbSize, pclsid);

            if (SUCCEEDED(hr1) && !IsEqualCLSID(*pclsid, CLSID_NULL))
            {
                StringFromCLSID(*pclsid, &szDistUnit);

                hr1 = IsControlLocallyInstalled(NULL, pclsid, szDistUnit, dwVersionMS, dwVersionLS, &lci, NULL);

                if (hr1 == S_OK)
                {
                    fHasHandler = TRUE;
                }

                if (szDistUnit)
                {
                    delete szDistUnit;
                }
            }
        }
    }

    if (pszUrl)
    {
        delete [] pszUrl;
    }

    if (fHasHandler)
    {
        hr = S_OK;
    }    
    else
    {
        hr = S_FALSE;
    }

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     GetCodeBaseFromDocFile
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [ulSize] --
//              [pwzClassStr] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetCodeBaseFromDocFile(LPBYTE pBuffer, ULONG ulSize, LPWSTR *pwzClassStr, 
                               LPWSTR pwzBaseUrl, DWORD *lpdwVersionMS, DWORD *lpdwVersionLS)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetCodeBaseFromDocFile",
                "%#x, %#x, %#x, %.80wq, %#x, %#x",
                pBuffer, ulSize, pwzClassStr, pwzBaseUrl, lpdwVersionMS, lpdwVersionLS
                ));
                
    PerfDbgLog(tagTransApi, NULL, "+GetCodeBaseFromDocFile");
    HRESULT hr = E_FAIL;

    ILockBytes *pilb;
    IStorage *pstg;
    STATSTG stat;

    static ULONG cpSpec = DOCFILE_NUMPROPERTIES;
    static PROPSPEC rgpSpec[DOCFILE_NUMPROPERTIES] = { 
                                { PRSPEC_PROPID, DOCFILE_PROPID_CODEBASE },
                                { PRSPEC_PROPID, DOCFILE_PROPID_MAJORVERSION },
                                { PRSPEC_PROPID, DOCFILE_PROPID_MINORVERSION } };
            
    PROPVARIANT rgVarDisplay[DOCFILE_NUMPROPERTIES];
    
    if (!pwzClassStr || !lpdwVersionMS || !lpdwVersionLS)
    {
        hr = E_INVALIDARG;
    }
    else 
    {   
        HGLOBAL hGlobal = 0;
        hGlobal = GlobalAlloc(GMEM_FIXED | GMEM_NODISCARD, ulSize);

        *pwzClassStr = 0;

        if (hGlobal)
        {
            memcpy(hGlobal, pBuffer, ulSize);

            hr = CreateILockBytesOnHGlobal(hGlobal,FALSE,&pilb);
            if (hr == NOERROR)
            {
                hr = StgOpenStorageOnILockBytes(pilb,NULL,STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                            NULL,0,&pstg);
                if (hr == NOERROR)
                {
                    IPropertySetStorage *ppss = 0;
                    
                    hr = pstg->QueryInterface(IID_IPropertySetStorage, (void **)&ppss);
                    if (SUCCEEDED(hr)) 
                    {
                        IPropertyStorage *pps = 0;

                        //BUGBUG: there is potential for error here if data structure of
                        // PropertyStorage is not fully loaded.  since we have read only access
                        // we should be ok.

                        hr = ppss->Open(FMTID_CodeBase, STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE, (IPropertyStorage **)&pps);
                        if (SUCCEEDED(hr))
                        {
                            hr = pps->ReadMultiple(cpSpec, rgpSpec, rgVarDisplay);
                            if (SUCCEEDED(hr)) 
                            {
                                *pwzClassStr = rgVarDisplay[0].pwszVal;
                                *lpdwVersionMS = rgVarDisplay[1].ulVal;
                                *lpdwVersionLS = rgVarDisplay[2].ulVal;
                            }
                            pps->Release();
                        }
                        ppss->Release();
                    }
                    pstg->Release();
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            GlobalFree(hGlobal);
        }
    }

    if (SUCCEEDED(hr) && pwzBaseUrl)
    {
        LPWSTR pwzNewClassStr = 0;
        DWORD dwLen, dwNewLen;
        HRESULT hr1;

        // we do not know what the combined maximum Url length is, so as
        // an upper bound we take twice the combined url's plus 10.
        dwLen = 2*(lstrlenW(pwzBaseUrl) + lstrlenW(*pwzClassStr)) + 10;

        pwzNewClassStr = new WCHAR[dwLen];

        if (pwzNewClassStr)
        {
            hr1 = CoInternetCombineUrl(pwzBaseUrl, *pwzClassStr, ICU_NO_ENCODE, pwzNewClassStr, dwLen, &dwNewLen, 0);
            
            if (SUCCEEDED(hr1) && dwNewLen)
            {
                delete [] *pwzClassStr;
                *pwzClassStr = pwzNewClassStr;
            }
            else
            {
                delete [] pwzNewClassStr;
            }
        }
    }

    PerfDbgLog1(tagTransApi, NULL, "-GetCodeBaseFromDocFile (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   UrlMkSetSessionOption
//
//  Synopsis:
//
//  Arguments:  [dwOption] --
//              [pBuffer] --
//              [dwBufferLength] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    5-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI UrlMkSetSessionOption(DWORD dwOption, LPVOID pBuffer, DWORD dwBufferLength, DWORD dwReserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "UrlMkSetSessionOption",
                    "%#x, %#x, %#x, %#x",
                    dwOption, pBuffer, dwBufferLength, dwReserved
                    ));
    // BUGBUG - Function not threadsafe.
    
    PerfDbgLog(tagTransApi, NULL, "+UrlMkSetSessionOption");

    HRESULT hr;

    switch(dwOption)
    {
        // Change the User Agent string for this process.
        case URLMON_OPTION_USERAGENT:
        {
            // Validate buffer, allocate new user agent string,
            // delete old if necessary, copy and reference with
            // g_pszUserAgentString.

            if (!(pBuffer && dwBufferLength))
            {
                hr = E_INVALIDARG;
                break;
            }

            LPSTR pszTemp = new CHAR[dwBufferLength + 1];
            if (!pszTemp)
            {
                TransAssert(pszTemp && "Allocating memory for User-Agent header failed");
                hr = E_OUTOFMEMORY;
                break;
            }

            memcpy(pszTemp, pBuffer, dwBufferLength);
            pszTemp[dwBufferLength] = '\0';
            
            if (g_pszUserAgentString)
            {
                delete [] g_pszUserAgentString;
            }

            g_pszUserAgentString = pszTemp;
            hr = S_OK;
            break;
        }

        // Refresh user agent string from registry for this process.
        case URLMON_OPTION_USERAGENT_REFRESH:
        {
            // Refresh, delete old user agent string if necessary.
            // g_pszUserAgentString references refreshed string.

            LPSTR pszTemp = g_pszUserAgentString;            

            // NULL forces GetUserAgentString to refresh from registry.
            g_pszUserAgentString = NULL;
            g_pszUserAgentString = (LPSTR) GetUserAgentString();

            if (!g_pszUserAgentString)
            {
                g_pszUserAgentString = pszTemp;
                hr = S_FALSE;
                break;
            }
            
            // Need to set this on the session handle also.
            if (g_hSession)
                InternetSetOption(g_hSession, INTERNET_OPTION_USER_AGENT,
                    g_pszUserAgentString, strlen(g_pszUserAgentString));


            delete [] pszTemp;
            hr = S_OK;
            break;
        }
        
        // Set or reload proxy info from registry.
        case INTERNET_OPTION_PROXY:
        case INTERNET_OPTION_REFRESH:
        {
            // InternetSetOption does its own buffer validation.
            if (InternetSetOption(NULL, dwOption, pBuffer, dwBufferLength))
            {
                hr = S_OK;
                break;
            }

            hr = S_FALSE;
            break;
        }
                
        default:
        {
            hr = E_INVALIDARG;
            break;
        }
    }
                        
    PerfDbgLog1(tagTransApi, NULL, "-UrlMkSetSessionOption (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}
            
            
//+---------------------------------------------------------------------------
//
//  Function:   UrlMkGetSessionOption
//
//  Synopsis:
//
//  Arguments:  [dwOption] --
//              [pBuffer] --
//              [dwBufferLength] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    5-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI UrlMkGetSessionOption(DWORD dwOption, LPVOID pBuffer, DWORD dwBufferLength, DWORD *pdwBufferLengthOut, DWORD dwReserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "UrlMkSetSessionOption",
                    "%#x, %#x, %#x, %#x",
                    dwOption, pBuffer, dwBufferLength, dwReserved
                    ));
                    
    PerfDbgLog(tagTransApi, NULL, "+UrlMkGetSessionOption");
    HRESULT hr = E_FAIL;

    if( !pdwBufferLengthOut )
    {
        DEBUG_LEAVE_API(E_INVALIDARG);
        return E_INVALIDARG;
    }

    if (dwOption == URLMON_OPTION_USERAGENT)
    {
        // get the default user agent string
        LPCSTR pszStr = GetUserAgentString();

        DWORD cLen = strlen(pszStr);
        *pdwBufferLengthOut = cLen + 1;

        hr = E_OUTOFMEMORY;

        if (cLen < dwBufferLength )
        {
            if( pBuffer )
            {
                strcpy((LPSTR)pBuffer, pszStr);
// AOL BUG 66102 - we always return E_FAIL
//                 hr = NOERROR;
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
    }
    else if (dwOption == URLMON_OPTION_URL_ENCODING)
    {
        if( !pBuffer || dwBufferLength < sizeof(DWORD) )
        {
            hr = E_INVALIDARG;
        }
        else
        {
            DWORD dwEncoding = URL_ENCODING_NONE;
            BOOL fDefault = FALSE;
            DWORD dwUrlEncodingDisableUTF8;
            DWORD dwSize = sizeof(DWORD);
            
            if( ERROR_SUCCESS == SHRegGetUSValue(
                    INTERNET_SETTING_KEY,
                    "UrlEncoding", 
                    NULL, 
                    (LPBYTE) &dwUrlEncodingDisableUTF8, 
                    &dwSize, 
                    FALSE, 
                    (LPVOID) &fDefault, 
                    sizeof(fDefault) )  )
            {
                if( dwUrlEncodingDisableUTF8)
                    dwEncoding = URL_ENCODING_DISABLE_UTF8;
                else
                    dwEncoding = URL_ENCODING_ENABLE_UTF8;
            }

            hr = NOERROR;
            *pdwBufferLengthOut = sizeof(DWORD);
            memcpy(pBuffer, (LPVOID)(&dwEncoding), sizeof(DWORD));
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog1(tagTransApi, NULL, "-UrlMkGetSessionOption (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetPlugInClsID
//
//  Synopsis:   load the plugin ocx; get the FindPluginByExtA address
//              call the FindPluginByExtA api
//
//  Arguments:  [pszExt] --
//              [szMime] --
//              [pclsid] --
//
//  Returns:    NOERROR and plugin class id if file is handled by plugin
//              REGDB_E_CLASSNOTREG otherwise
//
//  History:    7-16-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetPlugInClsID(LPSTR pszExt, LPSTR pszName, LPSTR pszMime, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetPlugInClsID",
                "%.80q, %.80q, %.80q, %#x",
                pszExt, pszName, pszMime, pclsid
                ));
                
    HRESULT hr = REGDB_E_CLASSNOTREG;
    PerfDbgLog3(tagTransApi, NULL, "+GetPlugInClsID (pszExt:%s, pszName:%s, pszMime:%s)", pszExt, pszName, pszMime);

    typedef BOOL (WINAPI * pfnFINDPLUGINBYEXT)(char *szExt, char *szName, char *szMime);

    static pfnFINDPLUGINBYEXT pfnFindPlugin = NULL;
    static BOOL fPluginLoaded = FALSE;
    static BOOL fGotProcAddr = FALSE;

    if (!fPluginLoaded)
    {
        g_hLibPluginOcx = LoadLibraryA("plugin.ocx");
        fPluginLoaded = TRUE;
    }

    if (g_hLibPluginOcx != NULL)
    {
        if (!fGotProcAddr)
        {
            pfnFindPlugin = (pfnFINDPLUGINBYEXT)GetProcAddress(g_hLibPluginOcx, "FindPluginByExtA");
            fGotProcAddr = TRUE;
            if (pfnFindPlugin == NULL)
            {
                DbgLog(tagTransApi, NULL, "Failed to find entry point FindPluginByExt in  plugin.ocx");
            }
        }

        if (pfnFindPlugin && pfnFindPlugin(pszExt, pszName, pszMime))
        {
            hr = S_OK;
        }
    }
    else
    {
        DbgLog(tagTransApi, NULL, "Failed to find plugin.ocx");
    }

    if (hr == S_OK)
    {
        *pclsid = CLSID_PluginHost;
    }

    PerfDbgLog1(tagTransApi, NULL, "-GetPlugInClsID (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   StringAFromCLSID
//
//  Synopsis:   returns an ansi string of given class id
//
//  Arguments:  [pclsid] -- the class id
//
//  Returns:    pointer to class id string or
//              NULL if out of memory
//
//  History:    7-20-96   JohannP (Johann Posch)   Created
//
//  Notes:      string pointer has to be deleted with delete (operator)
//
//----------------------------------------------------------------------------
LPSTR StringAFromCLSID(CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "StringAFromCLSID",
                "%#x",
                pclsid
                ));
                
    LPOLESTR pwzStr;
    LPSTR    pszStr = NULL;

    TransAssert((pclsid));

    StringFromCLSID(*pclsid, &pwzStr);

    if (pwzStr)
    {
        pszStr =  SzDupWzToSz(pwzStr, TRUE);
        delete pwzStr;
    }

    DEBUG_LEAVE(pszStr);
    return pszStr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CLSIDFromStringA
//
//  Synopsis:
//
//  Arguments:  [pszClsid] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-20-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CLSIDFromStringA(LPSTR pszClsid, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CLSIDFromStringA",
                "%.80q, %#x",
                pszClsid, pclsid
                ));
                
    WCHAR sz[CLSIDSTR_MAX];
    A2W(pszClsid,sz,CLSIDSTR_MAX);
    HRESULT hr = CLSIDFromString(sz, pclsid);

    DEBUG_LEAVE(hr);
    return hr;
}


#include "ocidl.h"
#ifndef unix
#include "..\urlhlink\urlhlink.h"
#else
#include "../urlhlink/urlhlink.h"
#endif /* unix */
#define IS_E_PENDING(hr) (hr == E_PENDING)

//+---------------------------------------------------------------------------
//
//  Function:   URLDownloadA
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//              [szURL] --
//              [pBindInfo] --
//              [pBSCB] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    7-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI URLDownloadA(IUnknown *pUnk, LPCSTR pszURL, DWORD pBindInfo, IBindStatusCallback *pBSCB, DWORD dwReserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "URLDownloadA",
                    "%#x, %.80q, %#x, %#x, %#x",
                    pUnk, pszURL, pBindInfo, pBSCB, dwReserved
                    ));
                    
    PerfDbgLog1(tagTransApi, NULL, "+URLDownloadA (pszUrl:%s)", pszURL);
    HRESULT hr = NOERROR;
    LPCWSTR pwzUrl = DupA2W((LPSTR) pszURL);

    if (pwzUrl)
    {
        hr = URLDownloadW(pUnk,pwzUrl,pBindInfo,pBSCB, 0);
    }

    PerfDbgLog1(tagTransApi, NULL, "-URLDownloadA (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   URLDownloadW
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//              [pwzURL] --
//              [pBindInfo] --
//              [pBSCB] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    7-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI URLDownloadW(IUnknown *pUnk, LPCWSTR pwzURL, DWORD pBindInfo, IBindStatusCallback *pBSCB, DWORD dwReserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "URLDownloadW",
                    "%#x, %.80wq, %#x, %#x, %#x",
                    pUnk, pwzURL, pBindInfo, pBSCB, dwReserved
                    ));
                    
    PerfDbgLog1(tagTransApi, NULL, "+URLDownloadW (pwzUrl:%ws)", pwzURL);
    HRESULT             hr;
    IOleObject *        pOleObject = 0;
    IServiceProvider *  pServiceProvider = 0;
    IMoniker *          pmkr = 0;
    IBindCtx *          pBndCtx = 0;
    IBindHost *         pBindHost = 0;

    IStream * pstrm = 0;

    // Don't bother if we don't have a caller...

    if( pUnk )
    {
        // By convention the we give the caller first crack at service
        // provider. The assumption here is that if they implement it
        // they have the decency to forward QS's to their container.

        hr = pUnk->QueryInterface( IID_IServiceProvider,
                                        (void**)&pServiceProvider );

        if( FAILED(hr) )
        {
            // Ok, now try the 'slow way' : maybe the object is an 'OLE' object
            // that knows about it's client site:

            hr = pUnk->QueryInterface( IID_IOleObject, (void**)&pOleObject );

            if( SUCCEEDED(hr) )
            {
                IOleClientSite * pClientSite = 0;

                hr = pOleObject->GetClientSite(&pClientSite);

                if( SUCCEEDED(hr) )
                {
                    // Now see if we have a service provider at that site
                    hr = pClientSite->QueryInterface
                                            ( IID_IServiceProvider,
                                            (void**)&pServiceProvider );
                }

                if( pClientSite )
                    pClientSite->Release();
            }
            else
            {
                // Ok, it's not an OLE object, maybe it's one of these
                // new fangled 'ObjectWithSites':

                IObjectWithSite * pObjWithSite = 0;

                hr = pUnk->QueryInterface( IID_IObjectWithSite,
                                                    (void**)&pObjWithSite );

                if( SUCCEEDED(hr) )
                {
                    // Now see if we have a service provider at that site

                    hr = pObjWithSite->GetSite(IID_IServiceProvider,
                                                (void**)&pServiceProvider);
                }

                if( pObjWithSite )
                    pObjWithSite->Release();

            }
            if( pOleObject )
                pOleObject->Release();

        }

        // BUGBUG: In the code above we stop looking at one level up --
        //  this may be too harsh and we should loop on client sites
        // until we get to the top...

        if( !pServiceProvider )
            hr = E_UNEXPECTED;

        // Ok, we have a service provider, let's see if BindHost is
        // available. (Here there is some upward delegation going on
        // via service provider).

        if( SUCCEEDED(hr) )
            hr = pServiceProvider->QueryService( SID_SBindHost, IID_IBindHost,
                                                        (void**)&pBindHost );

        if( pServiceProvider )
            pServiceProvider->Release();

        pmkr = 0;
    }

    if (pBindHost)
    {
        // This allows the container to actually drive the download
        // by creating it's own moniker.

        hr = pBindHost->CreateMoniker( LPOLESTR(pwzURL),NULL, &pmkr,0 );



        if( SUCCEEDED(hr) )
        {
            // This allows containers to hook the download for
            // doing progress and aborting

            hr = pBindHost->MonikerBindToStorage(pmkr, NULL, pBSCB, IID_IStream,(void**)&pstrm);
        }

        pBindHost->Release();
    }
    else
    {
        // If you are here, then either the caller didn't pass
        // a 'caller' pointer or the caller is not in a BindHost
        // friendly environment.

        hr = CreateURLMoniker( 0, pwzURL, &pmkr );

        if( SUCCEEDED(hr) )
        {
            hr = CreateAsyncBindCtx( 0,pBSCB,0, &pBndCtx );
        }

        if (SUCCEEDED(hr))
        {
            hr = pmkr->BindToStorage( pBndCtx, NULL, IID_IStream, (void**)&pstrm );
        }

    }

    if( pstrm )
        pstrm->Release();

    if( pmkr )
        pmkr->Release();

    if( pBndCtx )
        pBndCtx->Release();

    PerfDbgLog1(tagTransApi, NULL, "-URLDownloadW (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindMimeFromData
//
//  Synopsis:
//
//  Arguments:  [pBC] --
//              [pwzURL] --
//              [pBuffer] --
//              [cbSize] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    3-28-97   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI FindMimeFromData(
                        LPBC pBC,                               // bind context - can be NULL
                        LPCWSTR pwzUrl,                     // url - can be null
                        LPVOID pBuffer,                     // buffer with data to sniff - can be null (pwzUrl must be valid)
                        DWORD cbSize,                   // size of buffer
                        LPCWSTR pwzMimeProposed,    // proposed mime if - can be null
                        DWORD dwMimeFlags,                  // will be determined
                        LPWSTR *ppwzMimeOut,        // the suggested mime
                        DWORD dwReserved)                   // must be 0
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "FindMimeFromData",
                    "%#x, %.80wq, %#x, %#x, %.80wq, %#x, %.80wq, %#x",
                    pBC, pwzUrl, pBuffer, cbSize, pwzMimeProposed, dwMimeFlags, ppwzMimeOut, dwReserved
                    ));
                    
    LPCWSTR wzMimeFromData = 0;
    HRESULT hr = E_FAIL;

    PerfDbgLog1(tagTransApi, NULL, "+FindMimeFromData (sugg: %ws)", pwzMimeProposed ? pwzMimeProposed : L"NULL");
    if (   !ppwzMimeOut
        || (!pwzUrl && !pBuffer))
    {
        hr = E_INVALIDARG;
    }
    else if( pBuffer || pwzMimeProposed )
    {
        CContentAnalyzer ca;
        wzMimeFromData = ca.FindMimeFromData(pwzUrl,(char*) pBuffer, cbSize, pwzMimeProposed, dwMimeFlags);

        if (wzMimeFromData)
        {
            *ppwzMimeOut = OLESTRDuplicate(wzMimeFromData);
            if (*ppwzMimeOut)
            {
                hr = NOERROR;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

        }
    }
    else
    {
        // file extension is the only solution
        LPSTR pszExt = NULL;
        CHAR  szUrl[MAX_PATH]; 
        CHAR  szMime[MAX_PATH];
        DWORD cbMime = MAX_PATH;
        
        W2A(pwzUrl, szUrl, MAX_PATH);
        pszExt = FindFileExtension(szUrl);

        if( pszExt )
        {
            hr = GetMimeFromExt(pszExt, szMime, &cbMime);
        }
        else
        {
            hr = E_FAIL;
        }

        if( SUCCEEDED(hr) )
        {
            *ppwzMimeOut = DupA2W(szMime);    
            if (*ppwzMimeOut)
            {
                hr = NOERROR;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    PerfDbgLog1(tagTransApi, NULL, "-FindMimeFromData (actual: %ws)", wzMimeFromData ? wzMimeFromData : L"NULL" );

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoInternetParseUrl
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [ParseAction] --
//              [dwFlags] --
//              [pszResult] --
//              [cchResult] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-13-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoInternetParseUrl(
    LPCWSTR     pwzUrl,
    PARSEACTION ParseAction,
    DWORD       dwFlags,
    LPWSTR      pszResult,
    DWORD       cchResult,
    DWORD      *pcchResult,
    DWORD       dwReserved
    )
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CoInternetParseUrl",
                    "%.80wq, %#x, %#x, %#x, %#x, %#x, %#x",
                    pwzUrl, ParseAction, dwFlags, pszResult, cchResult, pcchResult, dwReserved
                    ));
                    
    PerfDbgLog(tagTransApi, NULL, "+CoInternetParseUrl");
    COInetSession *pOInetSession = 0;
    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (!g_bShortcircuitKnownProtocols || !IsKnownProtocol(pwzUrl)) 
    {
        hr = GetCOInetSession(0, &pOInetSession,0);

        if (hr == NOERROR)
        {
            hr = pOInetSession->ParseUrl(pwzUrl, ParseAction, dwFlags,  pszResult, cchResult, pcchResult, dwReserved);
            pOInetSession->Release();
        }
    }
    
    if (hr == INET_E_DEFAULT_ACTION)
    {
        hr = E_FAIL;

        switch (ParseAction)
        {
        case PARSE_CANONICALIZE      :
            *pcchResult = cchResult;
            hr = UrlCanonicalizeW(pwzUrl, pszResult, pcchResult, dwFlags);
        break;
        case PARSE_SCHEMA            :
            *pcchResult = cchResult;
            hr = UrlGetPartW(pwzUrl, pszResult, pcchResult, URL_PART_SCHEME, 0);   
            break;

        break;
        case PARSE_SITE              :
        break;
        case PARSE_DOMAIN            :
            *pcchResult = cchResult;
            hr = UrlGetPartW(pwzUrl, pszResult, pcchResult, URL_PART_HOSTNAME, 0);   
            TransAssert(hr != E_POINTER);
            break;

        break;
        case PARSE_FRIENDLY          :
        break;
        case PARSE_SECURITY_URL   :
        // should return "schema:host"  for all protocols
        break;
        case PARSE_ROOTDOCUMENT      :
        {
            PARSEDURLW puW;
            puW.cbSize = sizeof(PARSEDURLW);
            if (SUCCEEDED(ParseURLW(pwzUrl, &puW)) && IsHierarchicalScheme(puW.nScheme))
            {
                DWORD cchRequired = 1;
                // The first URLGetPartW call is just to get the number of chars required for the hostname.
                // This is not as efficient but keeps the code simpler.
                if ((UrlGetPartW(pwzUrl, pszResult, &cchRequired, URL_PART_HOSTNAME, 0)) == E_POINTER)
                {
                    cchRequired += (puW.cchProtocol + 3);
                    if (cchResult >= cchRequired)
                    {
                        LPWSTR pszCopyTo = pszResult;

                        *pcchResult = cchRequired - 1;    // don't include terminating NULL char.
                        memcpy(pszCopyTo, puW.pszProtocol, puW.cchProtocol * sizeof(WCHAR));
                        pszCopyTo += puW.cchProtocol;
                        memcpy(pszCopyTo, L"://", 3 * sizeof(WCHAR));
                        pszCopyTo += 3;

                        DWORD cchHost = (DWORD) (cchResult - (pszCopyTo - pszResult));
                        hr = UrlGetPartW(pwzUrl, pszCopyTo, &cchHost, URL_PART_HOSTNAME, 0);
                    }
                    else 
                    {
                        *pcchResult = cchRequired;
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
        break;

        case PARSE_DOCUMENT          :
        break;
        case PARSE_ANCHOR            :
        break;
        case PARSE_ENCODE            :
        case PARSE_UNESCAPE          :
            *pcchResult = cchResult;
            hr = UrlUnescapeW((LPWSTR)pwzUrl, pszResult, pcchResult, dwFlags);
        break;
        case PARSE_ESCAPE            :
        case PARSE_DECODE            :
            *pcchResult = cchResult;
            hr = UrlEscapeW(pwzUrl, pszResult, pcchResult, dwFlags);
        break;
        case PARSE_PATH_FROM_URL     :
            *pcchResult = cchResult;
            hr = PathCreateFromUrlW(pwzUrl, pszResult, pcchResult, dwFlags);
        break;
        case PARSE_URL_FROM_PATH     :
            *pcchResult = cchResult;
            hr = UrlCreateFromPathW(pwzUrl, pszResult, pcchResult, dwFlags);
        break;
        case PARSE_LOCATION          :
        {
            hr = E_FAIL;
            *pcchResult = 0;
            LPCWSTR pwzStr = UrlGetLocationW(pwzUrl); //, pszResult, pcchResult, dwFlags);
            if (pwzStr)
            {
                DWORD dwlen = wcslen(pwzStr);
                if (dwlen < cchResult)
                {
                    wcscpy(pszResult, pwzStr);
                    *pcchResult = dwlen;
                    hr = NOERROR;
                }
                else
                {
                    // buffer too small
                }
            }
        }
        break;
        case PARSE_MIME              :
        default:
            hr = E_FAIL;
        }
    }

    PerfDbgLog1(tagTransApi, NULL, "-CoInternetParseUrl (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     IsHierarchicalScheme
//
//  Synopsis:
//
//  Arguments:  [dwScheme] --
//
//  Returns:
//
//  History:    6-16-1997   Sanjays (Sanjay Shenoy)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL IsHierarchicalScheme(DWORD dwScheme)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Bool,
                "IsHierarchicalScheme",
                "%#x",
                dwScheme
                ));
                
    BOOL bReturn;

    switch ( dwScheme )
    {
        case URL_SCHEME_HTTP:
        case URL_SCHEME_FTP:
        case URL_SCHEME_HTTPS:
        case URL_SCHEME_NEWS:
        case URL_SCHEME_GOPHER:
        case URL_SCHEME_NNTP:
        case URL_SCHEME_TELNET:
        case URL_SCHEME_SNEWS:
            bReturn = TRUE;
            break;
        default:
            bReturn = FALSE;
            break;
    }

    DEBUG_LEAVE(bReturn);
    return bReturn;
}  

//+---------------------------------------------------------------------------
//
//  Method:     IsHierarchicalUrl
//
//  Synopsis:
//
//  Arguments:  [pwszUrl] --
//
//  Returns:
//
//  History:    6-16-1997   Sanjays (Sanjay Shenoy)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL IsHierarchicalUrl(LPCWSTR pwszUrl)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Bool,
                "IsHierarchicalUrl",
                "%.80wq",
                pwszUrl
                ));
                
    DWORD dwScheme = URL_SCHEME_INVALID;

    if(pwszUrl)
    {
        PARSEDURLW pu;
        pu.cbSize = sizeof(pu);
        if(SUCCEEDED(ParseURLW(pwszUrl, &pu)))
            dwScheme = pu.nScheme;
    }
  
    BOOL fRet = IsHierarchicalScheme(dwScheme);

    DEBUG_LEAVE(fRet);
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CoInternetGetSecurityUrl
//
//  Synopsis:
//
//  Arguments:  [pwszUrl] --
//              [ppszSecUrl] --
//              [psuAction]
//              [dwReserved]
//  Returns:
//
//  History:    4-28-1997   Sanjays (Sanjay Shenoy)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDAPI CoInternetGetSecurityUrl(
    LPCWSTR pwszUrl,
    LPWSTR *ppwszSecUrl,    // out argument.
    PSUACTION   psuAction,
    DWORD dwReserved
    )
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CoInternetGetSecurityUrl",
                    "%.80wq, %#x, %#x, %#x",
                    pwszUrl, ppwszSecUrl, psuAction, dwReserved
                    ));
                    
    PerfDbgLog(tagTransApi, NULL, "+CoInternetGetSecurityUrl");
    COInetSession *pOInetSession = NULL;

    if (pwszUrl == NULL || ppwszSecUrl == NULL)
    {
        DEBUG_LEAVE_API(E_INVALIDARG);
        return E_INVALIDARG;
    }
    
    if (psuAction != PSU_DEFAULT && psuAction != PSU_SECURITY_URL_ONLY)
    {
        DEBUG_LEAVE_API(E_NOTIMPL);
        return E_NOTIMPL;
    }

    LPWSTR pwszSecUrl = (LPWSTR) pwszUrl;
    *ppwszSecUrl = NULL;
    BOOL bAllocSecUrl = FALSE; // Should we free pwszSecUrl?

    HRESULT hr = S_OK;

    // Step 1    
    // If this is a custom protocol, give it a chance to return back the 
    // security URL first. 

    hr = GetCOInetSession(0, &pOInetSession, 0);

    if (hr == NOERROR)
    {
        DWORD dwId;
        // It is important to loop here. The URL returned by a pluggable protocol by calling
        // PARSE_SECURITY_URL might be another pluggable protocol. 
        while ( !g_bShortcircuitKnownProtocols || ((dwId = IsKnownProtocol(pwszSecUrl)) == DLD_PROTOCOL_NONE) 
                || (dwId == DLD_PROTOCOL_STREAM)) // Special case mk: hack since there could be a 
                                                  // namespace handler defined for it. 
        {
        
            // Allocate as much memory as the url. This should be a good upper limit in most all cases.
            DWORD cchIn = lstrlenW(pwszSecUrl) + 1;
            DWORD cchOut = 0;

            LPWSTR pwszTmp = new WCHAR[cchIn];

            if (pwszTmp != NULL)
                hr = pOInetSession->ParseUrl(pwszSecUrl, PARSE_SECURITY_URL, 0, pwszTmp, cchIn, &cchOut, 0);
            else 
                hr = E_OUTOFMEMORY;


            // Not enough memory.
            if (hr == S_FALSE)
            {
                // Plug prot claims it needs more memory but asks us for a buffer of a 
                // smaller size.
                TransAssert(cchIn < cchOut);
                if (cchIn >= cchOut)
                {
                    hr = E_UNEXPECTED;
                }
                else
                {
                    cchIn = cchOut;
                    delete [] pwszTmp;
                    pwszTmp = new WCHAR[cchIn];

                    if ( pwszTmp != NULL ) 
                    {                  
                        hr = pOInetSession->ParseUrl(pwszSecUrl, PARSE_SECURITY_URL, 0, pwszTmp, cchIn, &cchOut, 0);
                        TransAssert(hr != S_FALSE);
                    }                
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // If for some reason the pluggable protocol just returned back
                // the original string, don't go into an infinite loop.
                if (0 == StrCmpW(pwszSecUrl, pwszTmp))
                {
                    delete [] pwszTmp;
                    break;
                }

                if (bAllocSecUrl)
                    delete [] pwszSecUrl;

                pwszSecUrl = pwszTmp;
                bAllocSecUrl = TRUE;
            }
            else 
            {
                if (hr == INET_E_DEFAULT_ACTION || hr == E_NOTIMPL)
                {
                    // This implies the pluggable protocol just wants us to use the 
                    // base url as the security url. 
                    hr = S_OK;
                }

                delete [] pwszTmp;
                break;
            }
        }
    }
    else 
    {
        // Some protocols don't support the IInternetProtocolInfo interface.
        // We will do the best we can. 
        hr = S_OK;
    }

    // End of Step 1.                                                          
    // At this point we have the security URL. We are done if the PSUACTION 
    // indicated we should only be getting the security URL.
    
    if (psuAction == PSU_SECURITY_URL_ONLY)
    {
        if (SUCCEEDED(hr))
        {
            // If we didn't allocate memory for pwszSecUrl i.e. it is the same as the 
            // input string, we have to do that before returning it back. 
            if (!bAllocSecUrl)    
            {
                *ppwszSecUrl = new WCHAR [(lstrlenW(pwszSecUrl) + 1)];
                if (*ppwszSecUrl != NULL)
                    StrCpyW(*ppwszSecUrl, pwszSecUrl);
                else
                    hr = E_OUTOFMEMORY;
            }
            else
            {
                *ppwszSecUrl = pwszSecUrl;
            }
        }
    }
    else
    {
        TransAssert(psuAction == PSU_DEFAULT);                                 
        // Step 2.
        // If URL after Step 1 is still not well known ask the protocol handler to simplify
        // it it is well known call UrlGetPart in shlwapi.

        LPWSTR pwszRet = NULL;

        if (SUCCEEDED(hr))
        {
            if (pwszSecUrl == NULL)
            {
                TransAssert(FALSE); // This has to be due to a bug in Step 1.
                pwszSecUrl = (LPWSTR) pwszUrl;   // recover as best as we can.
            }


            // Since Step 2 is just supposed to strip off parts we can safely assume that 
            // the out string will be smaller than the input string. 

            DWORD cchIn = lstrlenW(pwszSecUrl) + 1;
            DWORD cchOut = 0;
            pwszRet = new WCHAR[cchIn];

            if (pwszRet == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else if (!g_bShortcircuitKnownProtocols || !IsKnownProtocol(pwszSecUrl))
            {
                TransAssert(pOInetSession);

                if (pOInetSession)
                    hr = pOInetSession->ParseUrl(pwszSecUrl, PARSE_SECURITY_DOMAIN, 0, pwszRet, cchIn, &cchOut, 0);
                else
                    hr = INET_E_DEFAULT_ACTION ; // no protocol info ==> use default

                TransAssert(hr != S_FALSE);   // Should never require more memory
                if (hr == INET_E_DEFAULT_ACTION || hr == E_NOTIMPL)
                {
                    StrCpyW(pwszRet, pwszSecUrl);
                    hr = S_OK;
                }
            }
            else  // Known protocol call shlwapi.
            {
                if (IsHierarchicalUrl(pwszSecUrl))
                {
                    hr = UrlGetPartW(pwszSecUrl, pwszRet, &cchIn, URL_PART_HOSTNAME, URL_PARTFLAG_KEEPSCHEME);   
                    TransAssert(hr != E_POINTER);
                }
                else
                {
                    // Just copy the string from step 1, we can't do any meaningful processing.
                    hr = INET_E_DEFAULT_ACTION;
                }


                // If UrlGetPart didn't process it, just pass the original string back.
                if (!SUCCEEDED(hr))
                {
                    hr = S_OK;
                    StrCpyW(pwszRet, pwszSecUrl);
                }
            }
        }

        // End of Step 2. 
    

        if (bAllocSecUrl)
            delete [] pwszSecUrl;

        if (SUCCEEDED(hr))
        {
            TransAssert(pwszRet != NULL);
            *ppwszSecUrl = pwszRet;
        }
    }

    PerfDbgLog1(tagTransApi, NULL, "-CoInternetGetSecurityUrl (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoInternetCombineUrl
//
//  Synopsis:
//
//  Arguments:  [pwzBaseUrl] --
//              [pwzRelativeUrl] --
//              [dwFlags] --
//              [pszResult] --
//              [cchResult] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-13-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoInternetCombineUrl(
    LPCWSTR     pwzBaseUrl,
    LPCWSTR     pwzRelativeUrl,
    DWORD       dwFlags,
    LPWSTR      pszResult,
    DWORD       cchResult,
    DWORD      *pcchResult,
    DWORD       dwReserved
    )
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CoInternetCombineUrl",
                    "%.80wq, %.80wq, %#x, %#x, %#x, %#x, %#x",
                    pwzBaseUrl, pwzRelativeUrl, dwFlags, pszResult, cchResult, pcchResult, dwReserved
                    ));
                    
    PerfDbgLog(tagTransApi, NULL, "+CoInternetCombineUrl");
    COInetSession *pOInetSession = 0;

    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (!g_bShortcircuitKnownProtocols || !IsKnownProtocol(pwzBaseUrl))
    {
        hr = GetCOInetSession(0, &pOInetSession,0);

        if (hr == NOERROR)
        {
            hr = pOInetSession->CombineUrl(pwzBaseUrl, pwzRelativeUrl, dwFlags, pszResult, cchResult, pcchResult, dwReserved);
            pOInetSession->Release();
        }
    }
    if (hr == INET_E_DEFAULT_ACTION)
    {
        DWORD   dwRes = cchResult;

        hr = UrlCombineW(pwzBaseUrl, pwzRelativeUrl, pszResult, &dwRes, dwFlags);
        *pcchResult = dwRes;
    }

    PerfDbgLog1(tagTransApi, NULL, "-CoInternetCombineUrl (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoInternetCompareUrl
//
//  Synopsis:
//
//  Arguments:  [pwzUrl1] --
//              [pwzUrl2] --
//              [dwFlags] --
//
//  Returns:
//
//  History:    4-13-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoInternetCompareUrl(
    LPCWSTR pwzUrl1,
    LPCWSTR pwzUrl2,
    DWORD dwFlags
    )
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CoInternetCompareUrl",
                    "%.80wq, %.80wq, %#x",
                    pwzUrl1, pwzUrl2, dwFlags
                    ));
                    
    PerfDbgLog(tagTransApi, NULL, "+CoInternetCompareUrl");
    COInetSession *pOInetSession = 0;
    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (!g_bShortcircuitKnownProtocols || !IsKnownProtocol(pwzUrl1)) 
    {
        hr = GetCOInetSession(0, &pOInetSession,0);

        if (hr == NOERROR)
        {
            hr = pOInetSession->CompareUrl(pwzUrl1, pwzUrl2, dwFlags);
            pOInetSession->Release();
        }
    }
    if (hr == INET_E_DEFAULT_ACTION)
    {
        int iRes = UrlCompareW(pwzUrl1, pwzUrl2, dwFlags & CF_INGNORE_SLASH);
        if (iRes == 0)
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    PerfDbgLog1(tagTransApi, NULL, "-CoInternetCompareUrl (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoInternetQueryInfo
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [dwOptions] --
//              [pvBuffer] --
//              [cbBuffer] --
//              [pcbBuffer] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-14-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoInternetQueryInfo(
    LPCWSTR     pwzUrl,
    QUERYOPTION QueryOption,
    DWORD       dwQueryFlags,
    LPVOID      pvBuffer,
    DWORD       cbBuffer,
    DWORD      *pcbBuffer,
    DWORD       dwReserved
    )
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CoInternetQueryInfo",
                    "%.80wq, %#x, %#x, %#x, %#x, %#x, %#x",
                    pwzUrl, QueryOption, dwQueryFlags, pvBuffer, cbBuffer, pcbBuffer, dwReserved
                    ));
                    
    PerfDbgLog(tagTransApi, NULL, "+CoInternetQueryInfo");
    COInetSession *pOInetSession = 0;

    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (!g_bShortcircuitKnownProtocols || !IsKnownProtocol(pwzUrl))
    {
        hr = GetCOInetSession(0, &pOInetSession,0);

        if (hr == NOERROR)
        {
            hr = pOInetSession->QueryInfo(pwzUrl, QueryOption, dwQueryFlags, pvBuffer, cbBuffer, pcbBuffer, dwReserved);
            pOInetSession->Release();
        }
    }
  
    if (hr == INET_E_DEFAULT_ACTION)
    {
        switch (QueryOption)
        {
        case QUERY_USES_NETWORK:
        case QUERY_USES_CACHE:
            {
                if (!pvBuffer || cbBuffer < sizeof(DWORD))
                {
                    DEBUG_LEAVE_API(E_FAIL);
                    return E_FAIL;
                }

                if (pcbBuffer)
                {
                    *pcbBuffer = sizeof(DWORD);
                }

                switch (GetUrlScheme(pwzUrl)) 
                {
                    case URL_SCHEME_FILE:
                    case URL_SCHEME_NEWS:
                    case URL_SCHEME_NNTP:
                    case URL_SCHEME_MK:
                    case URL_SCHEME_SHELL:
                    case URL_SCHEME_SNEWS:
                    case URL_SCHEME_LOCAL:
                        *((DWORD *)pvBuffer) = FALSE;
                        
                        DEBUG_LEAVE_API(S_OK);
                        return S_OK;

                    case URL_SCHEME_FTP:
                    case URL_SCHEME_HTTP:
                    case URL_SCHEME_GOPHER:
                    case URL_SCHEME_TELNET:
                    case URL_SCHEME_WAIS:
                    case URL_SCHEME_HTTPS:
                        *((DWORD *)pvBuffer) = TRUE;
                        
                        DEBUG_LEAVE_API(S_OK);
                        return S_OK;

                    default:
                    
                        DEBUG_LEAVE_API(E_FAIL);
                        return E_FAIL;
                }
            }
            break;

         case QUERY_IS_CACHED:
         case QUERY_IS_INSTALLEDENTRY:
         case QUERY_IS_CACHED_OR_MAPPED:
            {
                char szUrl[MAX_URL_SIZE];
                DWORD dwFlags = 0;

                if(QueryOption == QUERY_IS_INSTALLEDENTRY)
                {
                    dwFlags = INTERNET_CACHE_FLAG_INSTALLED_ENTRY;
                }
                else if(QueryOption == QUERY_IS_CACHED_OR_MAPPED)
                {
                    dwFlags = INTERNET_CACHE_FLAG_ENTRY_OR_MAPPING;
                }
                // Otherwise let the flags remain as 0
                
                if (!pvBuffer || cbBuffer < sizeof(DWORD))
                {
                    DEBUG_LEAVE_API(E_FAIL);
                    return E_FAIL;
                }
                
                if (pcbBuffer)
                {
                    *pcbBuffer = sizeof(DWORD);
                }

                W2A(pwzUrl, szUrl, MAX_URL_SIZE);

                char *pchLoc = StrChr(szUrl, TEXT('#'));
                if (pchLoc)
                    *pchLoc = TEXT('\0');
        
                *((DWORD *)pvBuffer) = GetUrlCacheEntryInfoEx(szUrl, NULL, NULL, NULL, NULL, NULL, dwFlags);

                DEBUG_LEAVE_API(S_OK);
                return S_OK;
            }
            break;

        case QUERY_CAN_NAVIGATE:
            {
                //Bug#107130 - If we couldn't find the NEWS protocol, or it refused to answer this query,
                // trident assumes that it CAN navigate, and leads to above bug.
                // If we couldn't load this protocol, or it delegated to us, we now give Trident what they want.
                if (URL_SCHEME_NEWS == GetUrlScheme(pwzUrl))
                {
                    if (!pvBuffer || cbBuffer < sizeof(DWORD))
                    {
                        DEBUG_LEAVE_API(E_FAIL);
                        return E_FAIL;
                    }
                    
                    if (pcbBuffer)
                    {
                        *pcbBuffer = sizeof(DWORD);
                    }

                    *((DWORD *)pvBuffer) = FALSE;
                    
                    DEBUG_LEAVE_API(S_OK);
                    return S_OK;
                }
            }
            break;
             
        default:
            // do not know what do to
            hr = E_FAIL;
        }
    }

    PerfDbgLog1(tagTransApi, NULL, "-CoInternetQueryInfo (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoInternetGetProtocolFlags
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pdwFlags] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-14-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoInternetGetProtocolFlags(
    LPCWSTR     pwzUrl,
    DWORD      *pdwFlags,
    DWORD       dwReserved
    )
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CoInternetGetProtocolFlags",
                    "%.80wq, %#x, %#x",
                    pwzUrl, pdwFlags, dwReserved
                    ));
                    
    PerfDbgLog(tagTransApi, NULL, "+CoInternetGetProtocolFlags");
    COInetSession *pOInetSession = 0;

    HRESULT hr = E_NOTIMPL;

    PerfDbgLog1(tagTransApi, NULL, "-CoInternetGetProtocolFlags (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CoInternetCreateSecurityManager
//
//  Synopsis:
//
//  Arguments:  [pSP] --
//              [pSM] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-28-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoInternetCreateSecurityManager(IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CoInternetCreateSecurityManager",
                    "%#x, %#x, %#x",
                    pSP, ppSM, dwReserved
                    ));
                    
    PerfDbgLog(tagTransApi, NULL, "+CoInternetCreateUrlSecurityManager");
    HRESULT hr = NOERROR;

    hr = InternetCreateSecurityManager(0, IID_IInternetSecurityManager, (void **)ppSM, dwReserved);

    PerfDbgLog1(tagTransApi, NULL, "-CoInternetCreateUrlSecurityManager (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoInternetCreateZoneManager
//
//  Synopsis:
//
//  Arguments:  [pSP] --
//              [ppZM] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-28-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoInternetCreateZoneManager(IServiceProvider *pSP, IInternetZoneManager **ppZM, DWORD dwReserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CoInternetCreateZoneManager",
                    "%#x, %#x, %#x",
                    pSP, ppZM, dwReserved
                    ));
                    
    PerfDbgLog(tagTransApi, NULL, "+CoInternetCreateUrlZoneManager");
    HRESULT hr;

    hr = InternetCreateZoneManager(0, IID_IInternetZoneManager, (void **) ppZM, dwReserved);

    PerfDbgLog1(tagTransApi, NULL, "-CoInternetCreateUrlZoneManager (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}


BOOL PDFNeedProgressiveDownload()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Bool,
                "PDFNeedProgressiveDownload",
                NULL
                ));
                
    HKEY    hClsRegEntry;
    CHAR    szInProc[CLSIDSTR_MAX + 64];
    CHAR    szPath[MAX_PATH];
    long    lSize;
    BOOL    fRet = TRUE;
    BYTE*   pVerBuffer = NULL;
    DWORD   cbFileVersionBufSize;
    DWORD   dwTemp;
    unsigned uiLength = 0;
    VS_FIXEDFILEINFO *lpVSFixedFileInfo;

    strcpy(szInProc, 
           "CLSID\\{CA8A9780-280D-11CF-A24D-444553540000}\\InProcServer32");

    if( ERROR_SUCCESS != RegOpenKey(
                    HKEY_CLASSES_ROOT, szInProc, &hClsRegEntry) )
    {
        goto Exit;
    }

    // now we are at HKCR\CLSID\xxx-yyyy\InProcServer32
    // we need to get the path to the ocx
    lSize = MAX_PATH;
    if( ERROR_SUCCESS != RegQueryValue(
                    hClsRegEntry, NULL, szPath, &lSize) )
    {
        RegCloseKey(hClsRegEntry);
        goto Exit;
    }

    // done with key
    RegCloseKey(hClsRegEntry);
    
    // we have the path now
    if((cbFileVersionBufSize = GetFileVersionInfoSize( szPath, &dwTemp)) == 0 )
    {
        goto Exit;
    }

    pVerBuffer = new BYTE[cbFileVersionBufSize];
    if( !pVerBuffer )
    {
        goto Exit;
    }

    if( !GetFileVersionInfo(szPath, 0, cbFileVersionBufSize, pVerBuffer) )
    {
        goto Exit;
    }

    if( !VerQueryValue( 
            pVerBuffer, TEXT("\\"),(LPVOID*)&lpVSFixedFileInfo, &uiLength) ) 
    {
        goto Exit;
    }

    if( lpVSFixedFileInfo->dwFileVersionMS == 0x00010003 &&
        lpVSFixedFileInfo->dwFileVersionLS < 170 )
    {
        // this is 3.0 or 3.01, we should disable progressive download
        fRet = FALSE;
    }


Exit:
    if( pVerBuffer != NULL)
        delete [] pVerBuffer;

    DEBUG_LEAVE(fRet);
    return fRet;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\protmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       protmgr.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#include <shlwapip.h>
#include "oinet.hxx"

PerfDbgTag(tagCProtMgr, "Urlmon", "Log CProtMgr", DEB_PROT);

//+---------------------------------------------------------------------------
//
//  Method:     CProtMgr::Register
//
//  Synopsis:
//
//  Arguments:  [LPOLESTR] --
//              [ULONG] --
//              [cProtocols] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgr::Register(IClassFactory *pCF, REFCLSID rclsid, LPCWSTR pszProtocol,
                                ULONG  cPatterns, const LPCWSTR *ppwzPatterns, DWORD dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgr::Register",
                "this=%#x, %#x, %#x, %.80wq, %#x, %#x, %#x",
                this, pCF, &rclsid, pszProtocol, cPatterns, ppwzPatterns, dwReserved
                ));
                
    PerfDbgLog(tagCProtMgr, this, "+CProtMgr::Register");
    HRESULT hr = NOERROR;

    TransAssert((pCF && pszProtocol));
    CLock lck(_mxs);


    if (pCF && pszProtocol)
    {
        char szStr[ULPROTOCOLLEN];
        W2A(pszProtocol, szStr, ULPROTOCOLLEN);

        ATOM atom = AddAtom(szStr);

        CNodeData *pNodeIns = new CNodeData(atom, pCF, rclsid);

        if (pNodeIns)
        {
            if (_cElements < 0)
            {
                _cElements = 0;
            }
            pNodeIns->_pNextNode = _pNextNode;
            _pNextNode = pNodeIns;
            _cElements++;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog1(tagCProtMgr, this, "-CProtMgr::Register (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CProtMgr::Unregister
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgr::Unregister(IClassFactory *pCF, LPCWSTR pszProtocol)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgr::Unregister",
                "this=%#x, %#x, %.80wq",
                this, pCF, pszProtocol
                ));
                
    PerfDbgLog(tagCProtMgr, this, "+CProtMgr::Unregister");
    HRESULT hr = NOERROR;

    TransAssert((pCF && pszProtocol));
    CLock lck(_mxs);

    if (pCF && pszProtocol)
    {
        char szStr[ULPROTOCOLLEN];
        W2A(pszProtocol, szStr, ULPROTOCOLLEN);
        ATOM atom = AddAtom(szStr);
        CNodeData *pNode = _pNextNode;
        CNodeData *pPrevNode = NULL;

        while (pNode)
        {
            if (pNode->_pCFProt == pCF && pNode->_atom == atom)
            {
                // found the node

                if (pPrevNode)
                {
                    pPrevNode->_pNextNode = pNode->_pNextNode;
                }
                else
                {
                    // remove first node
                    _pNextNode = pNode->_pNextNode;
                    pPrevNode = pNode->_pNextNode;
                }
                _cElements--;
                delete pNode;
                pNode = NULL;
            }
            else
            {
                pPrevNode = pNode;
                pNode = pNode->_pNextNode;
            }

        }

        //no previous node - the first
        if (pPrevNode == NULL)
        {
            _pNextNode = 0;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog1(tagCProtMgr, this, "-CProtMgr::Unregister (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

DWORD IsKnownHandler(LPCWSTR wzHandler);
CLSID *GetKnownHandlerClsID(DWORD dwID);

//+---------------------------------------------------------------------------
//
//  Method:     CProtMgr::FindFirstCF
//
//  Synopsis:
//
//  Arguments:  [pszProt] --
//              [ppUnk] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-16-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgr::FindFirstCF(LPCWSTR pszProt, IClassFactory **ppUnk, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgr::FindFirstCF",
                "this=%#x, %.80wq, %#x, %#x",
                this, pszProt, ppUnk, pclsid
                ));
                
    PerfDbgLog(tagCProtMgr, this, "+CProtMgr::FindFirstCF");
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    CNodeData *pNode;
    DWORD dwEl = 1;
    BOOL  fIsKnownHandler = FALSE;
    HRESULT hrGetClsId = NOERROR;

    CLock lck(_mxs);

    _pPosNode = 0;

    if (_cElements < 0)
    {
        _cElements = 0;
    }
    else if (_cElements > 0)
    {
        char szStr[ULPROTOCOLLEN];

        W2A(pszProt, szStr, ULPROTOCOLLEN);

        ATOM atom = FindAtom(szStr);

        if (atom)
        {
            pNode = _pNextNode;

            while (pNode && pNode->_atom != atom)
            {
                pNode = pNode->_pNextNode;
            }
            if (pNode)
            {
                *ppUnk = pNode->_pCFProt;
                if (*ppUnk)
                {
                    pNode->_pCFProt->AddRef();
                    *pclsid = pNode->_clsidProt;
                    hr = NOERROR;
                }
                else
                {
                    hr = INET_E_UNKNOWN_PROTOCOL;
                }
            }
        }
    }


    if( hr != NOERROR)
    {
        DWORD dwID = 0;
        dwID = IsKnownHandler(pszProt);
        if( dwID)
        {
            *pclsid = *GetKnownHandlerClsID(dwID);
            fIsKnownHandler = TRUE;
        }
        else
        {
            hrGetClsId = LookupClsIDFromReg(pszProt, pclsid, &dwEl);
        }
    }

    if (   (hr != NOERROR) && (hrGetClsId == NOERROR) )
    {
        IClassFactory *pCF = 0;
        hr = CoGetClassObject(*pclsid, CLSCTX_INPROC_SERVER,NULL,IID_IClassFactory, (void**)&pCF);
        if (hr == NOERROR)
        {
            *ppUnk = pCF;
            
            if(fIsKnownHandler)
            { 
                char szStr[ULPROTOCOLLEN];

                W2A(pszProt, szStr, ULPROTOCOLLEN);

                *ppUnk = pCF;

                ATOM atom = AddAtom(szStr);
                pNode = new CNodeData(atom, pCF, *pclsid);

                if (pNode)
                {
                    pNode->_pNextNode = _pNextNode;
                    _pNextNode = pNode;
                    _cElements++;
                }
                // no release of CF since it is given out
            }

        }
    }

    PerfDbgLog1(tagCProtMgr, this, "-CProtMgr::FindFirstCF (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CProtMgr::FindNextCF
//
//  Synopsis:
//
//  Arguments:  [pszProt] --
//              [ppUnk] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-16-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgr::FindNextCF(LPCWSTR pszProt, IClassFactory **ppUnk, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgr::FindNextCF",
                "this=%#x, %.80wq, %#x, %#x",
                this, pszProt, ppUnk, pclsid
                ));
                
    PerfDbgLog(tagCProtMgr, this, "+CProtMgr::FindNextCF");
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;

    TransAssert((FALSE));

    PerfDbgLog1(tagCProtMgr, this, "-CProtMgr::FindNextCF (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CProtMgr::LookupClsIDFromReg
//
//  Synopsis:
//
//  Arguments:  [pwzProt] --
//              [pclsid] --
//              [pcClsIds] --
//
//  Returns:
//
//  History:    11-20-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgr::LookupClsIDFromReg(LPCWSTR pwzProt, CLSID *pclsid, DWORD *pcClsIds, DWORD *pdwFlags, DWORD dwOpt)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgr::LookupClsIDFromReg",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x",
                this, pwzProt, pclsid, pcClsIds, pdwFlags, dwOpt
                ));
                
    PerfDbgLog1(tagCProtMgr, this, "+CProtMgr::LookupClsIDFromReg (pszProt:%ws)", pwzProt);
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;

    DWORD dwType;

    TransAssert((pwzProt && pclsid));

    if (pwzProt)
    {
        char pszProt[ULPROTOCOLLEN+1];

        W2A(pwzProt, pszProt, ULPROTOCOLLEN);
        pszProt[ULPROTOCOLLEN] = '\0';

        char szDelimiter = ':';

        LPSTR pszDel = StrChr(pszProt, szDelimiter);

        if (pszDel)
        {
            *pszDel = '\0';
        }

        DWORD dwLen = 256;
        char szProtocolKey[256];
        char szCLSID[256];

        strcpy(szProtocolKey, SZ_SH_PROTOCOLROOT);
        strcat(szProtocolKey, pszProt);

        char pszOptFlag[16];


        if(dwOpt)
        {
            wsprintf(pszOptFlag, "\\0x%08x", dwOpt);
            strcat(szProtocolKey, pszOptFlag); 
        }

        if (SHRegGetUSValue(
                    szProtocolKey, 
                    SZCLASS, 
                    NULL, 
                    (LPBYTE)szCLSID, 
                    &dwLen,
                    FALSE, 
                    NULL, 
                    0) == ERROR_SUCCESS)
        {
            hr = CLSIDFromStringA(szCLSID, pclsid);
            PerfDbgLog2(
                    tagCProtMgr, 
                    this, 
                    "API FOUND LookupProtocolClsIDFromReg(hr:%lx, ClsId:%s)", 
                    hr, 
                    szCLSID);
        }

    }

    PerfDbgLog1(tagCProtMgr, this, "-CProtMgr::LookupClsIDFromReg (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CProtMgrNameSpace::ShouldLookupRegistry
//
//  Synopsis:
//
//  Arguments:  [pszProt] --
//
//  Returns:    S_OK if registry should be looked up, S_FALSE if not. E_* if it encounters an error
//              of some sort. 
//
//  History:    11-16-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgrNameSpace::ShouldLookupRegistry(LPCWSTR pszProt)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgrNameSpace::ShouldLookupRegistry",
                "this=%#x, %.80wq",
                this, pszProt
                ));

    PerfDbgLog1(tagCProtMgr, this, "+CProtMgr::ShouldLookupRegistry (pszProt:%ws)", pszProt);
    HRESULT hr = E_FAIL;

    if (pszProt == NULL)
    {
        DEBUG_LEAVE(E_INVALIDARG);
        return E_INVALIDARG;
    }

 
    BOOL bFound = FALSE;
    for (CProtocolData *pCurrent = _pProtList ; pCurrent != NULL; pCurrent = pCurrent->GetNext())
    {
        // Found the protocol.
        if (0 == StrCmpICW(pszProt, pCurrent->GetProtocol()))
        {
            bFound = TRUE;
            break;
        }    
    }

    if (bFound)
    {
        hr = S_FALSE;
    }
    else
    {
        // Append to list.                  
        CProtocolData *pProtNew = new CProtocolData;
        if (pProtNew != NULL)
        {
            if (pProtNew->Init(pszProt, _pProtList))
            {
                _pProtList = pProtNew;
                hr = S_OK;
            }
            else 
            {
                // only way init can fail today is if we are out of memory
                delete pProtNew;
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;   
        }
    }

    PerfDbgLog1(tagCProtMgr, this, "-CProtMgr::ShouldLookupRegistry (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

                                  
//+---------------------------------------------------------------------------
//
//  Method:     CProtMgrNameSpace::FindFirstCF
//
//  Synopsis:
//
//  Arguments:  [pszProt] --
//              [ppUnk] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-16-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgrNameSpace::FindFirstCF(LPCWSTR pszProt, IClassFactory **ppUnk, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgrNameSpace::FindFirstCF",
                "this=%#x, %.80wq, %#x, %#x",
                this, pszProt, ppUnk, pclsid
                ));
                
    PerfDbgLog1(tagCProtMgr, this, "+CProtMgrNameSpace::FindFirstCF (pszProt:%ws)", pszProt);
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;

    CLock lck(_mxs);

    _pPosNode = 0;

    //
    // check the registered protocols first
    //
    if (_cElements > 0)
    {
        char szStr[ULPROTOCOLLEN];
        W2A(pszProt, szStr, ULPROTOCOLLEN);
        ATOM atom = FindAtom(szStr);

        if (atom)
        {
            _pPosNode = _pNextNode;

            while (_pPosNode && _pPosNode->_atom != atom)
            {
                _pPosNode = _pPosNode->_pNextNode;
            }
        }

    }
    
    //
    // look up the registry once
    //
    if (   (!_pPosNode)
        && (ShouldLookupRegistry(pszProt) == S_OK))
    {
        // BUG-WORK: 64 plugable namespace are max!
        CLSID rgclsid[64];
        DWORD dwEl = 64;

        if ((hr = LookupClsIDFromReg(pszProt, rgclsid, &dwEl)) == NOERROR)
        {
            char szStr[ULPROTOCOLLEN];

            W2A(pszProt, szStr, ULPROTOCOLLEN);

            ATOM atom = AddAtom(szStr);

            for (DWORD i = 0; i < dwEl; i++)
            {
                CLSID *pclsid = &rgclsid[i];
                CNodeData *pNodeIns = new CNodeData(atom, NULL, *pclsid);

                if (pNodeIns)
                {
                    pNodeIns->_pNextNode = _pNextNode;
                    _pNextNode = pNodeIns;
                    _cElements++;
                }

                if (!_pPosNode)
                {
                    _pPosNode = pNodeIns;
                }
            }

        }
    }
    /*
    else if (_cElements > 0)
    {
        char szStr[ULPROTOCOLLEN];
        W2A(pszProt, szStr, ULPROTOCOLLEN);
        ATOM atom = FindAtom(szStr);

        if (atom)
        {
            _pPosNode = _pNextNode;

            while (_pPosNode && _pPosNode->_atom != atom)
            {
                _pPosNode = _pPosNode->_pNextNode;
            }
        }

    }
    */

    if (_pPosNode)
    {
        *pclsid = _pPosNode->_clsidProt;

        if (_pPosNode->_pCFProt == NULL)
        {
            IClassFactory *pCF = 0;
            hr = CoGetClassObject(*pclsid, CLSCTX_INPROC_SERVER,NULL,IID_IClassFactory, (void**)&pCF);
            if (hr == NOERROR)
            {
                *ppUnk = pCF;//make sure we don't cache the class factory.
            }
        }
        else
        {
            *ppUnk = _pPosNode->_pCFProt;
            _pPosNode->_pCFProt->AddRef();
            hr = NOERROR;
        }
        //advance to the next node for further findnextcf calls
        _pPosNode = _pPosNode->_pNextNode;
    }

    PerfDbgLog1(tagCProtMgr, this, "-CProtMgrNameSpace::FindFirstCF (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CProtMgrNameSpace::FindNextCF
//
//  Synopsis:
//
//  Arguments:  [pszProt] --
//              [ppUnk] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-16-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgrNameSpace::FindNextCF(LPCWSTR pszProt, IClassFactory **ppUnk, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgrNameSpace::FindNextCF",
                "this=%#x, %.80wq, %#x, %#x",
                this, pszProt, ppUnk, pclsid
                ));
                
    PerfDbgLog(tagCProtMgr, this, "+CProtMgrNameSpace::FindNextCF");
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    CLock lck(_mxs);

    if (_cElements > 0 && _pPosNode)
    {
        char szStr[ULPROTOCOLLEN];
        W2A(pszProt, szStr, ULPROTOCOLLEN);

        ATOM atom = FindAtom(szStr);

        if (atom)
        {
            do
            {
                // find next matching node
                while (_pPosNode && _pPosNode->_atom != atom)
                {
                    _pPosNode = _pPosNode->_pNextNode;
                }

                if (_pPosNode)
                {
                    IClassFactory *pCF = 0;
                    *pclsid = _pPosNode->_clsidProt;

                    if (_pPosNode->_pCFProt == NULL)
                    {
                        hr = CoGetClassObject(*pclsid, CLSCTX_INPROC_SERVER,NULL,IID_IClassFactory, (void**)&pCF);
                        if (hr == NOERROR)
                        {
                            *ppUnk = pCF;//make sure we don't cache the class factory.
                        }
                    }
                    else
                    {
                        *ppUnk = _pPosNode->_pCFProt;
                        _pPosNode->_pCFProt->AddRef();
                        hr = NOERROR;
                    }
                    //advance to the next node for further findnextcf calls
                    _pPosNode = _pPosNode->_pNextNode;
                }

            } while (hr != NOERROR && _pPosNode);
        }
    }

    PerfDbgLog1(tagCProtMgr, this, "-CProtMgrNameSpace::FindNextCF (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CProtMgrNameSpace::LookupClsIDFromReg
//
//  Synopsis:
//
//  Arguments:  [pszProt] --
//              [ppclsid] --
//              [pcClsIds] --
//
//  Returns:
//
//  History:    11-20-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgrNameSpace::LookupClsIDFromReg(LPCWSTR pwzProt, CLSID *ppclsid, DWORD *pcClsIds, DWORD *pdwFlags, DWORD dwOpt)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgrNameSpace::LookupClsIDFromReg",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x",
                this, pwzProt, ppclsid, pcClsIds, pdwFlags, dwOpt
                ));
                
    PerfDbgLog1(tagCProtMgr, this, "+CProtMgrNameSpace::LookupClsIDFromReg (pwzProt:%ws)", pwzProt);
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    DWORD dwType;
    DWORD cFound = 0;
    HKEY hNameSpaceKey = NULL;

    TransAssert((pwzProt && ppclsid));

    char pszProt[ULPROTOCOLLEN];

    W2A(pwzProt, pszProt, ULPROTOCOLLEN);

    char szDelimiter = ':';

    LPSTR pszDel = StrChr(pszProt, szDelimiter);

    if (pszDel)
    {
        *pszDel = '\0';
    }


    #define LENNAMEMAX 256
    DWORD dwLen = LENNAMEMAX;
    DWORD dwLenName = LENNAMEMAX;
    char szNameSpaceKey[LENNAMEMAX];
    char szName[LENNAMEMAX];

    strcpy(szNameSpaceKey, SZNAMESPACEROOT);

    LPSTR pszKey = szNameSpaceKey + strlen(szNameSpaceKey);

    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szNameSpaceKey, 0, KEY_READ | KEY_QUERY_VALUE, &hNameSpaceKey) != ERROR_SUCCESS)
    {
        TransAssert((hNameSpaceKey == NULL));
    }

    if (hNameSpaceKey)
    {
        HKEY hProtKey = NULL;
        DWORD dwIndex = 0;
        DWORD dwCheck = 2;

        do
        {
            *pszKey = '\0';
            LPSTR pszKeyProt = pszKey;

            if (dwCheck == 2)
            {
                strcat(pszKeyProt, pszProt);
            }
            else if (dwCheck == 1)
            {
                strcat(pszKeyProt, SZALL);
            }
            else
            {
                TransAssert((FALSE));
            }
            strcat(pszKeyProt, "\\");


            if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szNameSpaceKey, 0, KEY_READ | KEY_QUERY_VALUE, &hProtKey) != ERROR_SUCCESS)
            {
                hProtKey = 0;
            }
            dwCheck--;


            if (hProtKey)
            {
                DWORD dwResult;
                dwLenName = LENNAMEMAX;
                LPSTR pszName = szNameSpaceKey + strlen(szNameSpaceKey);
                dwIndex = 0;

                // enum all sub keys
                while (   (dwResult = (RegEnumKeyEx(hProtKey, dwIndex, szName, &dwLenName, 0, 0, 0, 0)) == ERROR_SUCCESS)
                       && (cFound < *pcClsIds)
                    )
                {
                    BOOL fFound = FALSE;
                    HKEY hNameKey = NULL;
                    *pszName = '\0';
                    strcat(pszName, szName);

                    // open the Name-Space Handler root + protocols
                    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szNameSpaceKey, 0, KEY_QUERY_VALUE, &hNameKey) == ERROR_SUCCESS)
                    {
                        DWORD dwLenClass = LENNAMEMAX;
                        char szClass[LENNAMEMAX];
                        // get the class id
                        if (RegQueryValueEx(hNameKey, SZCLASS, NULL, &dwType, (LPBYTE)szClass, &dwLenClass) == ERROR_SUCCESS)
                        {
                            hr = CLSIDFromStringA(szClass, (ppclsid + cFound));
                            if (hr == NOERROR)
                            {
                                cFound++;
                            }

                            DbgLog2(tagCProtMgr, this, "LookupNameSpaceClsIDFromReg(hr:%lx, ClsId:%s) >FOUND<", hr, szClass);
                        }
                        RegCloseKey(hNameKey);

                    }

                    dwIndex++;
                    dwLenName = LENNAMEMAX;
                }
                RegCloseKey(hProtKey);
            }

        } while (dwCheck);

        RegCloseKey(hNameSpaceKey);
    }

    if (cFound)
    {
        *pcClsIds = cFound;
        hr = NOERROR;
    }
    
    PerfDbgLog1(tagCProtMgr, this, "-CProtMgrNameSpace::LookupClsIDFromReg (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CProtMgrMimeHandler::LookupClsIDFromReg
//
//  Synopsis:
//
//  Arguments:  [pwzMime] --
//              [pclsid] --
//              [pcClsIds] --
//
//  Returns:
//
//  History:    11-20-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgrMimeHandler::LookupClsIDFromReg(LPCWSTR pwzMime, CLSID *pclsid, DWORD *pcClsIds, DWORD *pdwFlags, DWORD dwOpt)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgrNameSpace::LookupClsIDFromReg",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x",
                this, pwzMime, pclsid, pcClsIds, pdwFlags, dwOpt
                ));
                
    PerfDbgLog1(tagCProtMgr, this, "+CProtMgrMimeHandler::LookupClsIDFromReg (pwzMime:%ws)", pwzMime);
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;

    HKEY hMimeKey = NULL;
    DWORD dwError;
    DWORD dwType;
    char szValue[256];
    DWORD dwValueLen = 256;
    char szKey[SZMIMESIZE_MAX + 256];

    TransAssert((pwzMime));

    char szStr[ULPROTOCOLLEN+1];
    W2A(pwzMime, szStr, ULPROTOCOLLEN);
    szStr[ULPROTOCOLLEN] = 0;

    strcpy(szKey, SZ_SH_FILTERROOT);
    strcat(szKey, szStr);

    if (SHRegGetUSValue(
                    szKey, 
                    SZCLASS, 
                    NULL, 
                    (LPBYTE)szValue, 
                    &dwValueLen,
                    FALSE, 
                    NULL, 
                    0) == ERROR_SUCCESS)
    {
            hr = CLSIDFromStringA(szValue, pclsid);
            PerfDbgLog2(
                    tagCProtMgr, 
                    this, 
                    "API FOUND LookupFilterClsIDFromReg(hr:%lx, ClsId:%s)", 
                    hr, 
                    szValue);
    }


    // there are some machine incorrectly installed text/html and point to 
    // PlugProt.dll and urlmon.dll. so if we find out the ksy is point to
    // these dll, we still return error, otherwise (the key might be 
    // installed by 3rd party) we uses the key.
    // const GUID CLSID_MimeHandlerTest1   = {0x79eaca02, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}};
    if(    !wcsicmp(pwzMime, L"text/html") 
        && IsEqualGUID(*pclsid ,CLSID_ClassInstallFilter )  
      )
    {
        hr = INET_E_UNKNOWN_PROTOCOL;
        *pclsid = CLSID_NULL;
    }

    PerfDbgLog1(tagCProtMgr, this, "-CProtMgrMimeHandler::LookupClsIDFromReg (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\transmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       transmgr.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-02-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>

PerfDbgTag(tagCTransMgr, "Urlmon", "Log CTransactionMgr", DEB_TRANSMGR);
DbgTag(tagCTransMgrErr,  "Urlmon", "Log CTransMgr Errors", DEB_TRANSMGR|DEB_ERROR);

extern HINSTANCE g_hInst;
LRESULT CALLBACK TransactionWndProc(HWND hWnd, UINT msg,WPARAM wParam, LPARAM lParam);

#define szURLMonClassName "URL Moniker Notification Window"
static BOOL g_fWndClassRegistered = FALSE;
CMutexSem g_mxsTransMgr;

URLMON_TS* GetTS(DWORD);
HRESULT    AddTSToList(URLMON_TS*);

//+---------------------------------------------------------------------------
//
//  Function:   GetThreadTransactionMgr
//
//  Synopsis:
//
//  Arguments:  [fCreate] --
//
//  Returns:
//
//  History:    1-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransactionMgr * GetThreadTransactionMgr(BOOL fCreate)
{
    DEBUG_ENTER((DBG_TRANSMGR,
                Pointer,
                "GetThreadTransactionMgr",
                "%B",
                fCreate
                ));
                
    PerfDbgLog(tagCTransMgr, NULL, "+GetThreadTransactionMgr");
    // only one thread should be here
    CLock lck(g_mxsMedia);

    HRESULT hr = NOERROR;
    CTransactionMgr *pCTMgr = NULL;

    CUrlMkTls tls(hr);
    if (hr == NOERROR)
    {
        pCTMgr = tls->pCTransMgr;

        if ((pCTMgr == NULL) && fCreate)
        {
            // the transaction mgr has an refcount of 1
            tls->pCTransMgr = pCTMgr = new CTransactionMgr;
        }
    }

    PerfDbgLog1(tagCTransMgr, NULL, "-GetThreadTransactionMgr (pCTMgr:%lx)", pCTMgr);

    DEBUG_LEAVE(pCTMgr);
    return pCTMgr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetTransactionMgr
//
//  Synopsis:
//
//  Arguments:  [fCreate] --
//
//  Returns:
//
//  History:    12-06-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransactionMgr * GetTransactionMgr(BOOL fCreate)
{
    DEBUG_ENTER((DBG_TRANSMGR,
                Pointer,
                "GetTransactionMgr",
                "%B",
                fCreate
                ));
                
    CTransactionMgr* pCTransMgr = GetThreadTransactionMgr(fCreate);

    DEBUG_LEAVE(pCTransMgr);
    return pCTransMgr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterUrlMkWndClass
//
//  Synopsis:   register the Url Moniker window class on demand
//
//  Arguments:  (none)
//
//  Returns:    return FALSE if class could not be registered
//
//  History:    12-02-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL RegisterUrlMkWndClass()
{
    DEBUG_ENTER((DBG_TRANSMGR,
                Bool,
                "RegisterUrlMkWndClass",
                NULL
                ));
                
    // only one thread should be here
    CLock lck(g_mxsMedia);

    if (g_fWndClassRegistered == FALSE)
    {
        // else register the window class
        WNDCLASS    wndclass;

        wndclass.style          = 0;
        wndclass.lpfnWndProc    = &TransactionWndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = g_hInst;
        wndclass.hIcon          = NULL;
        wndclass.hCursor        = NULL;;
        wndclass.hbrBackground  = (HBRUSH)NULL;
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = szURLMonClassName;

        // Register the window class
        if (!RegisterClass(&wndclass))
        {
            DWORD dwLastError = GetLastError();

            if(dwLastError == ERROR_CLASS_ALREADY_EXISTS)
            {
                g_fWndClassRegistered = TRUE;
            }
            else
            {
                DEBUG_PRINT(TRANSMGR, ERROR, ("RegisterUrlMkWndClass(): RegisterClass failed, GetLastError: %ld\n", dwLastError));
                TransAssert(FALSE);
            }
        }
        else
        {
            g_fWndClassRegistered = TRUE;
        }
    }

    DEBUG_LEAVE(g_fWndClassRegistered);
    return g_fWndClassRegistered;
}


//+---------------------------------------------------------------------------
//
//  Function:   UnregisterUrlMkWndClass
//
//  Synopsis:   unregisters the hidden windows class
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-16-1996   JohannP (Johann Posch)   Created
//
//  Notes:      called during process detach
//
//----------------------------------------------------------------------------
BOOL UnregisterUrlMkWndClass()
{
    DEBUG_ENTER((DBG_TRANSMGR,
                Bool,
                "UnregisterUrlMkWndClass",
                NULL
                ));
                
    if (g_fWndClassRegistered == TRUE)
    {
        // Register the window class
        if (UnregisterClass(szURLMonClassName,g_hInst))
        {
            g_fWndClassRegistered = FALSE;
        }
        else
        {
            DEBUG_PRINT(TRANSMGR, ERROR, ("UnregisterUrlMkWndClass(): UnregisterClass failed, GetLastError: %ld\n", GetLastError()));
        }
    }

    DEBUG_LEAVE(g_fWndClassRegistered);
    return g_fWndClassRegistered;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetThreadNotificationWnd
//
//  Synopsis:   return the notification for the current
//              the window is created if
//
//  Arguments:  [fCreate] --    TRUE if the window should be created
//
//  Returns:
//
//  History:    12-02-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
#ifndef HWND_MESSAGE
#define HWND_MESSAGE     ((HWND)-3)
#endif

extern BOOL  g_bNT5OrGreater;

HWND GetThreadNotificationWnd(BOOL fCreate)
{
    DEBUG_ENTER((DBG_TRANSMGR,
                Dword,
                "GetThreadNotificationWnd",
                "%B",
                fCreate
                ));
                
    HRESULT hr = NOERROR;
    HWND hwnd = NULL;

    DWORD tid = GetCurrentThreadId();
    URLMON_TS*  ts = NULL;

    ts = GetTS(tid);
    if( ts )
    {
        hwnd = ts->_hwndNotify;
        TransAssert((hwnd != NULL && "TS Corrupted!"));
    }   
    else
    {
        ts = new URLMON_TS;
        
        if( ts )
        { 
            if (   fCreate
                && (hwnd == NULL)
                && RegisterUrlMkWndClass() )
            {
                hwnd = CreateWindowEx(0, szURLMonClassName, NULL,
                                    0, 0, 0, 0, 0, 
                                    g_bNT5OrGreater ? HWND_MESSAGE : NULL, 
                                    NULL, g_hInst, NULL);

                TransAssert((hwnd != NULL && "can't create Notify window"));
                if (hwnd)
                {
                    ts->_dwTID = tid;
                    ts->_hwndNotify = hwnd;

                    AddTSToList(ts);
                }
            }
            else
            {
                delete ts;
            }
        }

    }
/**************************************************************************
    CUrlMkTls tls(hr);

    if (hr == NOERROR)
    {
        hwnd = tls->hwndUrlMkNotify;

        if (   fCreate
            && (hwnd == NULL)
            && RegisterUrlMkWndClass() )
        {
            hwnd = CreateWindowEx(0, szURLMonClassName, NULL,
                                    0, 0, 0, 0, 0, NULL, NULL, g_hInst, NULL);

            TransAssert((hwnd != NULL && "GetNotificationWnd: could not create window"));
            if (hwnd)
            {
                tls->hwndUrlMkNotify = hwnd;
                char achProgname[256];
                achProgname[0] = '\0';
                GetModuleFileNameA(NULL, achProgname, sizeof(achProgname));
            }
        }
    }
***************************************************************************/

    DEBUG_LEAVE(hwnd);
    return hwnd;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransactionMgr::CTransactionMgr
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransactionMgr::CTransactionMgr() : CLifePtr()
{
    DEBUG_ENTER((DBG_TRANSMGR,
                None,
                "CTransactionMgr::CTransactionMgr",
                "this=%#x",
                this
                ));
                
    _pCTransFirst = NULL;
    _pCTransLast = NULL;

    DEBUG_LEAVE(0);
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransactionMgr::~CTransactionMgr
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransactionMgr::~CTransactionMgr()
{
    DEBUG_ENTER((DBG_TRANSMGR,
                None,
                "CTransactionMgr::~CTransactionMgr",
                "this=%#x",
                this
                ));
                
    // The list should be empty by the time it gets destroyed
    if (_pCTransFirst)
    {
        DbgLog1(tagCTransMgr, this, "CTransactionMgr::~CTransactionMgr (list not empty:%lx)", _pCTransFirst);
    }

    //TransAssert(( _pCTransFirst == NULL ));

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransactionMgr::AddTransaction
//
//  Synopsis:   Add an internet transaction to the linked list.
//
//  Arguments:  [pCTrans] --
//
//  Returns:
//
//  History:    12-12-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransactionMgr::AddTransaction(CTransaction *pCTrans)
{
    DEBUG_ENTER((DBG_TRANSMGR,
                Hresult,
                "CTransactionMgr::AddTransaction",
                "this=%#x, %#x",
                this, pCTrans
                ));
                
    PerfDbgLog(tagCTransMgr, this, "+CTransMgr::AddTransaction");
    TransAssert((pCTrans != NULL));
    

    TransAssert((pCTrans->GetNextTransaction() == NULL));

    pCTrans->SetNextTransaction(_pCTransFirst);
    _pCTransFirst = pCTrans;
    AddRef();

    PerfDbgLog1(tagCTransMgr, this, "-CTransMgr::AddTransaction(hr:%lx)", NOERROR);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransactionMgr::RemoveTransaction
//
//  Synopsis:   Removes a transaction from the linked list.  If the transaction
//              cannot be found, E_FAIL is returned.
//
//  Arguments:  [pCTrans] --
//
//  Returns:
//
//  History:    12-12-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransactionMgr::RemoveTransaction(CTransaction *pCTrans)
{
    DEBUG_ENTER((DBG_TRANSMGR,
                Hresult,
                "CTransactionMgr::RemoveTransaction",
                "this=%#x, %#x",
                this, pCTrans
                ));
                
    PerfDbgLog(tagCTransMgr, this, "+CTransMgr::RemoveTransaction");
    CLock lck(g_mxsTransMgr);
    CTransaction *pCTransPrev = NULL;
    CTransaction *pCTransTmp;
    HRESULT hr = E_FAIL;

    TransAssert((pCTrans != NULL));


    pCTransTmp = _pCTransFirst;

    TransAssert((pCTransTmp != NULL));

    // Search all the nodes in the linked list
    if (_pCTransFirst == pCTrans)
    {
        _pCTransFirst = _pCTransFirst->GetNextTransaction();
        hr = NOERROR;
        Release();
    }
    else while (pCTransTmp != NULL)
    {
        // If a match is found
        if (pCTransTmp == pCTrans)
        {
            // Remove it from the linked list
            if (pCTransPrev == NULL)
            {
                _pCTransFirst = pCTrans->GetNextTransaction();
            }
            else
            {
                pCTransPrev->SetNextTransaction(pCTrans->GetNextTransaction());
            }

            hr = NOERROR;
            Release();
        }

        pCTransPrev = pCTransTmp;
        pCTransTmp = pCTransTmp->GetNextTransaction();
    }

    TransAssert((hr == NOERROR));

    PerfDbgLog1(tagCTransMgr, this, "-CTransMgr::RemoveTransaction (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetTransactionObjects
//
//  Synopsis:
//
//  Arguments:  [pBndCtx] --
//              [wzUrl] --
//              [pUnkOuter] --
//              [ppUnk] --
//              [ppCTrans] --
//              [dwOption] --
//              [ppCTranSData] --
//
//  Returns:
//
//  History:    4-12-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetTransactionObjects(LPBC pBndCtx, LPCWSTR wzUrl, IUnknown *pUnkOuter, IUnknown **ppUnk, 
                              IOInetProtocol **ppCTrans, DWORD dwOption, CTransData **ppCTransData)
{
    DEBUG_ENTER((DBG_TRANSMGR,
                Hresult,
                "GetTransactionObjects",
                "%#x, %.80wq, %#x, %#x, %#x, %#x, %#x",
                pBndCtx, wzUrl, pUnkOuter, ppUnk, ppCTrans, dwOption, ppCTransData
                ));
                
    HRESULT hr = S_OK;
    PerfDbgLog(tagCTransMgr, NULL, "+GetTransactionObjects");
    TransAssert((ppCTrans != NULL));
    CTransaction *pCTransTmp = NULL;

    BOOL fFound = FALSE;
    CLock lck(g_mxsTransMgr);

    CBindCtx *pCBndCtx = NULL;

    if (pBndCtx)
    {
        hr = pBndCtx->QueryInterface(IID_IAsyncBindCtx, (void **) &pCBndCtx);

        if (hr == NOERROR)
        {
            TransAssert((pCBndCtx));
            hr = pCBndCtx->GetTransactionObjects(&pCTransTmp, ppCTransData);
            if (hr == NOERROR)
            {
                TransAssert((pCTransTmp));

                if (!pCTransTmp->IsApartmentThread())
                {
                    pCBndCtx->SetTransactionObject(NULL);
                }

                fFound = TRUE;
                hr = S_FALSE;
            }
        }

        if (hr != S_FALSE && hr != NOERROR)
        {
            CBinding *pCBdgBindToObject = NULL;
            hr = pBndCtx->GetObjectParam(SZ_BINDING, (IUnknown **)&pCBdgBindToObject);

            if (pCBdgBindToObject)
            {
                pCTransTmp = (CTransaction *) pCBdgBindToObject->GetOInetBinding();
                fFound =  pCTransTmp ? true : false;
                pCTransTmp->AddRef();
                pCBdgBindToObject->Release();
                DbgLog1(tagCTransMgr, NULL, "=== CTransMgr::GetTransaction Found Transaction:%lx", pCTransTmp);
            }
        }

    }

    if (!fFound)
    {
        CTransactionMgr *pCTransMgr = GetThreadTransactionMgr();

        if (!pCTransMgr)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            // create a new transaction add it to the list
            hr = CTransaction::Create(pCBndCtx, dwOption, 0, 0, &pCTransTmp);
            if (hr == NOERROR)
            {
                hr = pCTransTmp->QueryInterface(IID_IOInetProtocol, (void **) ppCTrans);

                if (hr == NOERROR)
                {
                    pCTransTmp->Release();
                    pCTransMgr->AddTransaction(pCTransTmp);
                }
                
                if (!pCBndCtx && pBndCtx)
                {
                    pBndCtx->QueryInterface(IID_IAsyncBindCtx, (void **) &pCBndCtx);
                }
                if (pCBndCtx)
                {
                    pCBndCtx->SetTransactionObject(pCTransTmp);
                }
            }
        }
    }
    else if (pCTransTmp)
    {
        DbgLog1(tagCTransMgr, NULL, "GetTransactionObjects Found existing transaction(%lx)", pCTransTmp);
        // return false to indicate found existing transaction
        hr = S_FALSE;
    }

    if (pCBndCtx)
    {
        pCBndCtx->Release();
    }

    *ppCTrans = pCTransTmp;

    if (*ppCTrans && ppCTransData && *ppCTransData)
    {
        hr = S_FALSE;
    }

    if( hr == S_FALSE && ppCTransData && !*ppCTransData )
    {
        hr = S_OK;
    }

    PerfDbgLog2(tagCTransMgr, NULL, "-API GetTransactionObjects (pCTrans:%lx; hr:%lx)", pCTransTmp, hr);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\urlhlink\sources.inc ===
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\urlmon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       urlmon.cxx
//
//  Contents:   contains URL moniker implementation
//
//  Classes:
//
//  Functions:
//
//  History:    12-11-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#ifndef unix
#include "..\iapp\curl.hxx"
#else
#include "../iapp/curl.hxx"
#endif /* unix */
#include "urlmk.hxx"

PerfDbgTag(tagCUrlMon, "Urlmon", "Log CUrlMon", DEB_URLMON);

BOOL IsOInetProtocol(IBindCtx *pbc, LPCWSTR wzProtocol);

// prototypes of helper functions (used by RelativePathTo)
CUrlMon *CreateEmptyPathUrlMon();
HRESULT HrCreateCUrlFromUrlStr(LPCWSTR pwzUrl, BOOL fParseUrl, CUrl **ppUrl);
HRESULT HrCreateCUrlFromUrlMon(LPMONIKER pmkUrl, BOOL fParseUrl, CUrl **ppUrl);
HRESULT HrGetRelativePath(LPSTR lpszBase, LPSTR lpszOther, DWORD dwProto, LPSTR lpszHost,LPSTR lpszRelPath);

// #define URLMON_RELPATHTO_PARSE_QUERY_PARAMS
#ifdef URLMON_RELPATHTO_PARSE_QUERY_PARAMS
// These are helper routines used by RelativePathTo to deal with the Query
// and Params sub-strings of a URL, according to rfc 1808.
// These routines are not enabled because ComposeWith does not deal with
// these sub-strings in any special way, and we want RelativePathTo to be
// compatible with ComposeWith.
void ParseUrlQuery(LPSTR pszURL, LPSTR *ppszQuery);
void ParseUrlParams(LPSTR pszURL, LPSTR *ppszParams);
void AddParamsAndQueryToRelPath(LPSTR szRelPath,
    LPSTR pszParamsBase, LPSTR pszParamsOther,
    LPSTR pszQueryBase, LPSTR pszQueryOther);
#endif // URLMON_RELPATHTO_PARSE_QUERY_PARAMS


// Macros for Double-Byte Character Support (DBCS)
#if 1
    // Beware of double evaluation
    #define IncLpch(sz)          ((sz)=CharNext((sz)))
    #define DecLpch(szStart, sz) ((sz)=CharPrev ((szStart),(sz)))
#else
    #define IncLpch(sz)         (++(sz))
    #define DecLpch(szStart,sz) (--(sz))
#endif


CUrlMon::CUrlMon(LPWSTR pszUrl) : _CRefs()
{
    DEBUG_ENTER((DBG_MONIKER,
                None,
                "CUrlMon::CUrlMon",
                "this=%#x",
                this
                ));
                
    _pwzUrl = pszUrl;
    DllAddRef();

    DEBUG_LEAVE(0);
}

CUrlMon::~CUrlMon()
{
    DEBUG_ENTER((DBG_MONIKER,
                None,
                "CUrlMon::~CUrlMon",
                "this=%#x",
                this
                ));

    if (_pwzUrl)
    {
        delete [] _pwzUrl;
    }
    DllRelease();

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    VDATEPTROUT(ppvObj, void *);
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::QueryInterface");

    if (   riid == IID_IUnknown
        || riid == IID_IMoniker
        || riid == IID_IAsyncMoniker
        || riid == IID_IPersist
        || riid == IID_IPersistStream)
    {
        *ppvObj = this;
    }
    else if (riid == IID_IROTData)
    {
        *ppvObj = (void*)(IROTData *) this;
    }
    else if (riid == IID_IMarshal)
    {
        *ppvObj = (void*) (IMarshal *) this;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    if (hr == NOERROR)
    {
        AddRef();
    }

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::QueryInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CUrlMon::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlMon::AddRef(void)
{
    DEBUG_ENTER((DBG_MONIKER,
                Dword,
                "CUrlMon::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    LONG lRet = ++_CRefs;

    PerfDbgLog1(tagCUrlMon, this, "CUrlMon::AddRef (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CUrlMon::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlMon::Release(void)
{
    DEBUG_ENTER((DBG_MONIKER,
                Dword,
                "CUrlMon::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::Release");

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        delete this;
    }

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::Release (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::GetClassID
//
//  Synopsis:
//
//  Arguments:  [pClassID] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::GetClassID(CLSID *pClassID)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IPersist::GetClassID",
                "this=%#x, %#x",
                this, pClassID
                ));
                
    VDATEPTRIN(pClassID, CLSID);
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::GetClassID");

    *pClassID = CLSID_StdURLMoniker;
    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::GetClassID (hr:%lx)", NOERROR);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::IsDirty
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::IsDirty()
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IPersistStream::IsDirty",
                "this=%#x",
                this
                ));
                

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::Load
//
//  Synopsis:
//
//  Arguments:  [pistm] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::Load(IStream *pistm)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IPersistStream::Load",
                "this=%#x, %#x",
                this, pistm
                ));
                
    VDATEIFACE(pistm);
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::Load");
    HRESULT hr = NOERROR;
    ULONG cbLen = 0;

    // Read in the new URL from the stream
    hr = pistm->Read(&cbLen, sizeof(ULONG), NULL);

    if ((hr == NOERROR) && (cbLen > 0))
    {
        LPWSTR wszUrlLocal = new WCHAR [cbLen / sizeof(WCHAR)];
        DbgLog2(tagCUrlMon, this, "=== CUrlMon::Load (cbBytes:%ld, cbLen:%ld)", cbLen,  cbLen / sizeof(WCHAR));

        if (wszUrlLocal)
        {
            hr = pistm->Read(wszUrlLocal, cbLen, NULL);
            DbgLog2(tagCUrlMon, this, "=== CUrlMon::Load (cbLen:%ld, hr:%lx)", cbLen, hr);

            if (hr == NOERROR)
            {
                // If we already had a URL, delete it
                if (_pwzUrl)
                {
                    delete [] _pwzUrl;
                }

                _pwzUrl = wszUrlLocal;
            }
            else
            {
                delete [] wszUrlLocal;
            }
        }
    }

    PerfDbgLog2(tagCUrlMon, this, "-CUrlMon::Load (hr:%lx, szUrl:%ws)", hr, _pwzUrl?_pwzUrl:L"");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::Save
//
//  Synopsis:
//
//  Arguments:  [pistm] --
//              [fClearDirty] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::Save(IStream *pistm, BOOL fClearDirty)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IPersistStream::Save",
                "this=%#x, %#x, %B",
                this, pistm, fClearDirty
                ));
                
    VDATEIFACE(pistm);
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::Save");
    UrlMkAssert((_pwzUrl));
    HRESULT hr = E_FAIL;

    if (_pwzUrl)
    {
        ULONG cbLen = (wcslen(_pwzUrl) + 1) * sizeof(WCHAR);
        DbgLog2(tagCUrlMon, this, "=== CUrlMon::Save (cbLen:%ld, cbLen:%ld)", cbLen, cbLen / sizeof(WCHAR));

        // Write the URL to the stream
        hr = pistm->Write(&cbLen, sizeof(ULONG), NULL);
        if (hr == NOERROR)
        {
            hr = pistm->Write(_pwzUrl, cbLen, NULL);
        }
    }

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::Save (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::GetSizeMax
//
//  Synopsis:
//
//  Arguments:  [pcbSize] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IPersistStream::GetSizeMax",
                "this=%#x, %#x",
                this, pcbSize
                ));
                
    VDATEPTROUT (pcbSize, ULONG);
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::GetSizeMax");

    UrlMkAssert((_pwzUrl));
    UrlMkAssert((pcbSize));

    // length of url
    ULISet32(*pcbSize, ((wcslen(_pwzUrl) + 1) * sizeof(WCHAR)) + sizeof(ULONG));

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::GetSizeMax (hr:%lx)", NOERROR);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::BindToObject
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [pmkToLeft] --
//              [riidRes] --
//              [ppvRes] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::BindToObject(IBindCtx *pbc, IMoniker *pmkToLeft,  REFIID riidRes, void **ppvRes)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::BindToObject",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, pbc, pmkToLeft, &riidRes, ppvRes
                ));
                
    VDATEPTROUT(ppvRes, LPVOID);
    VDATEIFACE(pbc);
    PerfDbgLog2(tagCUrlMon, this, "+CUrlMon::BindToObject (IBindCtx:%lx, pmkToLeft:%lx)", pbc, pmkToLeft);

    *ppvRes = NULL;
    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }

    HRESULT     hr;
    CLSID       clsid;
    BIND_OPTS   bindopts;
    CBinding    *pCBdg = NULL;
    CBSC        *pBSC = NULL;
    WCHAR       wzURL[MAX_URL_SIZE + 1];

    *ppvRes = NULL;

    // Step 1:  check if the object is runining
    //          if so QI for the requested interface
    //
    {
        IRunningObjectTable     *pROT = NULL;
        // check if the object is already running
        hr = IsRunningROT(pbc, pmkToLeft, &pROT);
        if (hr == NOERROR)
        {
            // object is running
            IUnknown *pUnk = NULL;

            // object is running
            // get the object and Qi for the requested interface
            hr = pROT->GetObject(this, &pUnk);
            if (SUCCEEDED(hr))
            {
                hr = pUnk->QueryInterface(riidRes, ppvRes);
                pUnk->Release();
            }

            pROT->Release();
            goto End;
        }
        else
        {
            if (pROT)
            {
                pROT->Release();
            }

            if (FAILED(hr))
            {
                // did not get ROT!!
                goto End;
            }
        }
    }

    // Step 2: get the bind options from the bind context
    bindopts.cbStruct = sizeof(BIND_OPTS);
    hr = pbc->GetBindOptions(&bindopts);
    if (FAILED(hr))
    {
        goto End;
    }

    // Step 3:  create a CBinding and releated objects and
    //          start a transaction


    hr = StartBinding(TRUE, pbc, pmkToLeft, riidRes, ppvRes);

End:

    PerfDbgLog2(tagCUrlMon, this, "-CUrlMon::BindToObject (hr:%lx, ppvobj:%lx)",
                    hr, (hr == S_OK) ? *ppvRes : NULL);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::BindToStorage
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [pmkToLeft] --
//              [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::BindToStorage(IBindCtx *pbc, IMoniker *pmkToLeft, REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::BindToStorage",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, pbc, pmkToLeft, &riid, ppvObj
                ));
                
    VDATEPTROUT(ppvObj, LPVOID);
    VDATEIFACE(pbc);
    PerfDbgLog2(tagCUrlMon, this, "+CUrlMon::BindToStorage (IBindCtx:%lx, pmkToLeft:%lx)", pbc, pmkToLeft);

    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }
    CBSC *pBSC = NULL;
    HRESULT       hr;
    BIND_OPTS     bindopts;
    CBinding      *pCBdg = NULL;
    FORMATETC     fetc;
    WCHAR         wzURL[MAX_URL_SIZE + 1];

    IID iidLocal = riid;

    *ppvObj = NULL;

    #if DBG==1
    {
        LPOLESTR pszStr;
        StringFromCLSID(riid, &pszStr);
        DbgLog2(tagCUrlMon, this, "CUrlMon::BindToStorage (szUrl:%ws)(iid:%ws)",
                GetUrl(), pszStr);
        delete pszStr;
    }
    #endif

    hr = StartBinding(FALSE, pbc, pmkToLeft, riid, ppvObj);

    PerfDbgLog2(tagCUrlMon, this, "-CUrlMon::BindToStorage (hr:%lx, ppvobj:%lx)",
        hr, (hr == S_OK) ? *ppvObj : NULL);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::StartBinding
//
//  Synopsis:   sets up the cbinding and starts the transaction
//
//  Arguments:  [fBindToObject] --
//              [pbc] --
//              [pmkToLeft] --
//              [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    8-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::StartBinding(BOOL fBindToObject, IBindCtx *pbc, IMoniker *pmkToLeft, REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::StartBinding",
                "this=%#x, %B, %#x, %#x, %#x, %#x",
                this, fBindToObject, pbc, pmkToLeft, &riid, ppvObj
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::StartBinding");

    HRESULT     hr = NOERROR;
    WCHAR       wzURL[MAX_URL_SIZE + 1];
    CBSC        *pBSC = NULL;
    CBinding    *pCBdg = NULL;
    BOOL        fUnknown = FALSE;

    do 
    {
        // No need to canonicalize URL here.  This should have already been done
        // by CreateURLMoniker.

        hr = ConstructURL(pbc, NULL, pmkToLeft, GetUrl(), wzURL, sizeof(wzURL),CU_NO_CANONICALIZE);

        if (hr != NOERROR)
        {
            break;
        }

        // moved to CBinding::StartBinding
        // BUG-WORK
        //if (!IsOInetProtocol(pbc, wzURL))
        //{
        //    hr = INET_E_UNKNOWN_PROTOCOL;
        //    break;
        //}

        // check if a BSC is registerted if not register our own one - for Office!
        IUnknown *pUnk = NULL;
        hr = GetObjectParam(pbc, REG_BSCB_HOLDER, IID_IBindStatusCallback, (IUnknown**)&pUnk);
        if ((hr == NOERROR) && pUnk)
        {
            // release - nothing to do
            pUnk->Release();
        }
        else
        {
            hr = NOERROR;
            if (fBindToObject)
            {
                pBSC = new CBSC(Medium_Unknown);
            }
            else
            {
                Medium medium = (riid == IID_IStorage) ? Medium_Storage : Medium_Stream;
                pBSC = new CBSC(medium);
                if (medium == Medium_Storage)
                {
                    fUnknown = TRUE;
                }

            }

            // no IBSC - create our own one and register 
            if (pBSC)
            {
                hr = RegisterBindStatusCallback(pbc, pBSC, 0, 0);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            
        }
        
        if (hr != NOERROR)
        {
            break;
        }
        // Create a CBinding object
        hr = CBinding::Create(NULL, wzURL, pbc, (fUnknown) ? IID_IUnknown : riid, fBindToObject, &pCBdg);

        if (hr != NOERROR)
        {
            break;
        }
        
        UrlMkAssert((pCBdg != NULL));

        if (fBindToObject)
        {
            pCBdg->SetMoniker(this);
        }

        {
            LPWSTR pwzExtra = NULL;
            // start the transaction now
            hr = pCBdg->StartBinding(wzURL, pbc, (fUnknown) ? IID_IUnknown : riid, fBindToObject, &pwzExtra, ppvObj);

            if (pwzExtra)
            {
                SetUrl(GetUrl(), pwzExtra);
            }
        }

        if( hr == INET_E_USE_EXTEND_BINDING )
        {
            // rosebud
            hr = NOERROR;

            // there is no need to return IBinding to client, se should
            // free it here.
            pCBdg->Release();
            break;
        }

        if (SUCCEEDED(hr))
        {
            if (pCBdg->IsAsyncTransaction() == FALSE)
            {
                hr = pCBdg->CompleteTransaction();
                if (SUCCEEDED(hr))
                {
                    // retrieve the requested object
                    if (pBSC)
                    {
                        hr = pBSC->GetRequestedObject(pbc, ppvObj);
                    }
                    else
                    {
                        hr = pCBdg->GetRequestedObject(pbc, (IUnknown **)ppvObj);
                    }
                }
            }
            else 
            {
                hr = pCBdg->GetRequestedObject(pbc, (IUnknown **)ppvObj);
            }
        }

        // in case the transaction could not be started,
        // the following release we terminate all releated objects
        pCBdg->Release();
    
        break;
    } while (TRUE);

    if (pBSC)
    {
        RevokeBindStatusCallback(pbc, pBSC);
        pBSC->Release();
    }

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::StartBinding (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::Reduce
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [dwReduceHowFar] --
//              [IMoniker] --
//              [ppmkReduced] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::Reduce(IBindCtx *pbc, DWORD dwReduceHowFar,
                            IMoniker **ppmkToLeft,IMoniker **ppmkReduced)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::Reduce",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, pbc, dwReduceHowFar, ppmkToLeft, ppmkReduced
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::Reduce");

    // There is nothing we can do to reduce our moniker
    *ppmkReduced = this;
    AddRef();

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::Reduce (hr:%lx)", MK_S_REDUCED_TO_SELF);

    DEBUG_LEAVE(MK_S_REDUCED_TO_SELF);
    return MK_S_REDUCED_TO_SELF;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::ComposeWith
//
//  Synopsis:
//
//  Arguments:  [pmkRight] --
//              [fOnlyIfNotGeneric] --
//              [ppmkComposite] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::ComposeWith(IMoniker *pmkRight, BOOL fOnlyIfNotGeneric, IMoniker **ppmkComposite)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::ComposeWith",
                "this=%#x, %#x, %B, %#x",
                this, pmkRight, fOnlyIfNotGeneric, ppmkComposite
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::ComposeWith");
    VDATEIFACE(pmkRight);
    VDATEPTROUT(ppmkComposite, LPMONIKER);
    HRESULT hr = NOERROR;
    DWORD   dwMnk = 0;
    LPWSTR  wzURLRelative = NULL;

    *ppmkComposite = NULL;

    pmkRight->IsSystemMoniker(&dwMnk);
    if (dwMnk == MKSYS_URLMONIKER)
    {
        hr = pmkRight->GetDisplayName(NULL, NULL, &wzURLRelative);
        if (hr == NOERROR)
        {
            hr = CreateURLMoniker(this, wzURLRelative, ppmkComposite);
        }
    }
    else if (fOnlyIfNotGeneric)
    {
        hr = MK_E_NEEDGENERIC;
    }
    else
    {
        hr = CreateGenericComposite(this, pmkRight, ppmkComposite);
    }
    if (wzURLRelative)
    {
        delete wzURLRelative;
    }

    PerfDbgLog(tagCUrlMon, this, "-CUrlMon::ComposeWith");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::Enum
//
//  Synopsis:
//
//  Arguments:  [fForward] --
//              [ppenumMoniker] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::Enum(BOOL fForward, IEnumMoniker **ppenumMoniker)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::Enum",
                "this=%#x, %B, %#x",
                this, fForward, ppenumMoniker
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::Enum");
    VDATEPTROUT(ppenumMoniker, LPENUMMONIKER);
    *ppenumMoniker = NULL;

    PerfDbgLog(tagCUrlMon, this, "-CUrlMon::Enum (hr:0)");

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::IsEqual
//
//  Synopsis:
//
//  Arguments:  [pMnkOther] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//          REVIEW: this code will not work cross process.  What is the
//          correct implementation?
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::IsEqual(IMoniker *pMnkOther)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::IsEqual",
                "this=%#x, %#x",
                this, pMnkOther
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::IsEqual");
    HRESULT hr = S_FALSE;
    VDATEIFACE(pMnkOther);

    // We only worry about URL monikers
    if (this == pMnkOther)
    {
        // same object
        hr = NOERROR;
    }
    else if (IsUrlMoniker(pMnkOther))
    {
        LPWSTR szDispName = NULL;
        // The other moniker is a URL moniker.
        // get and compare the display names
        hr = pMnkOther->GetDisplayName(NULL, NULL, &szDispName);
        // Compare the URL's
        if (hr == NOERROR)
        {
            UrlMkAssert((_pwzUrl));
            UrlMkAssert((szDispName));

            hr = wcscmp(_pwzUrl, szDispName) ? S_FALSE : NOERROR;
        }

        if (szDispName)
        {
            delete szDispName;
        }
    }

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::IsEqual (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::Hash
//
//  Synopsis:
//
//  Arguments:  [pdwHash] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//              9-02-95   AdriaanC (Adriaan Canter)
//                        Modified to use Pearson's Method
//
//  Notes:
//  32 bit hashing operator for IMoniker::Hash(DWORD*)
//
//  Method based upon "Fast Hashing of Variable Length Text Strings" ,
//  by Peter K. Pearson, Communications of the ACM,
//  June 1990 Vol. 33, Number 6. pp 677-680.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::Hash(DWORD* pdwHash)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::Hash",
                "this=%#x, %#x",
                this, pdwHash
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::Hash");
    UrlMkAssert((_pwzUrl != NULL));

    HRESULT hr = NOERROR;

    UCHAR c0, c1, c2, c3;
    UCHAR* idx = (UCHAR*) _pwzUrl;

    static UCHAR T[256] =
    {
      1, 14,110, 25, 97,174,132,119,138,170,125,118, 27,233,140, 51,
      87,197,177,107,234,169, 56, 68, 30,  7,173, 73,188, 40, 36, 65,
      49,213,104,190, 57,211,148,223, 48,115, 15,  2, 67,186,210, 28,
      12,181,103, 70, 22, 58, 75, 78,183,167,238,157,124,147,172,144,
      176,161,141, 86, 60, 66,128, 83,156,241, 79, 46,168,198, 41,254,
      178, 85,253,237,250,154,133, 88, 35,206, 95,116,252,192, 54,221,
      102,218,255,240, 82,106,158,201, 61,  3, 89,  9, 42,155,159, 93,
      166, 80, 50, 34,175,195,100, 99, 26,150, 16,145,  4, 33,  8,189,
      121, 64, 77, 72,208,245,130,122,143, 55,105,134, 29,164,185,194,
      193,239,101,242,  5,171,126, 11, 74, 59,137,228,108,191,232,139,
      6, 24, 81, 20,127, 17, 91, 92,251,151,225,207, 21, 98,113,112,
      84,226, 18,214,199,187, 13, 32, 94,220,224,212,247,204,196, 43,
      249,236, 45,244,111,182,153,136,129, 90,217,202, 19,165,231, 71,
      230,142, 96,227, 62,179,246,114,162, 53,160,215,205,180, 47,109,
      44, 38, 31,149,135,  0,216, 52, 63, 23, 37, 69, 39,117,146,184,
      163,200,222,235,248,243,219, 10,152,131,123,229,203, 76,120,209
      };

    c0 = T[*idx];
    c1 = T[*idx+1 % 256];
    c2 = T[*idx+2 % 256];
    c3 = T[*idx+3 % 256];

#ifndef unix
    while ((WCHAR) *(WCHAR*) ++idx != L'\0')
#else
    // We are trying to cast a UCHAR as a WCHAR in the windows code. We will need
    // to handle alignments correctly here, as we cant randomly cast
    // a UCHAR * to a WCHAR *. 
    WCHAR wend = 0;
    while (memcmp(++idx,&wend,sizeof(WCHAR)))
#endif /* unix */
    {
      c0 = T[c0^*idx]; c1 = T[c1^*idx];
      c2 = T[c2^*idx]; c3 = T[c3^*idx];
    }

    *(((UCHAR*) pdwHash)+0) = c0;
    *(((UCHAR*) pdwHash)+1) = c1;
    *(((UCHAR*) pdwHash)+2) = c2;
    *(((UCHAR*) pdwHash)+3) = c3;

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::Hash (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::IsRunning
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [pmkToLeft] --
//              [pmkNewlyRunning] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::IsRunning(IBindCtx *pbc, IMoniker *pmkToLeft, IMoniker *pmkNewlyRunning)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::IsRunning",
                "this=%#x, %#x, %#x, %#x",
                this, pbc, pmkToLeft, pmkNewlyRunning
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::IsRunning");
    HRESULT hr = NOERROR;
    VDATEIFACE(pbc);

    if (pmkToLeft)
        VDATEIFACE(pmkToLeft);
    if (pmkNewlyRunning)
        VDATEIFACE(pmkNewlyRunning);

    // This implementation was shamelessly stolen from the OLE sources.

    if (pmkToLeft == NULL)
    {
        if (pmkNewlyRunning != NULL)
        {
            hr = pmkNewlyRunning->IsEqual(this);

        }
        else
        {
            hr = IsRunningROT(pbc, NULL, NULL);
        }
    }
    else
    {
        UrlMkAssert((FALSE));
        hr = S_FALSE;
    }

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::IsRunning (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::GetTimeOfLastChange
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [pmkToLeft] --
//              [pFileTime] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::GetTimeOfLastChange(IBindCtx *pbc, IMoniker *pmkToLeft, FILETIME *pFileTime)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::GetTimeOfLastChange",
                "this=%#x, %#x, %#x, %#x",
                this, pbc, pmkToLeft, pFileTime
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::GetTimeOfLastChange");
    VDATEIFACE(pbc);
    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }
    VDATEPTROUT(pFileTime, FILETIME);

    HRESULT hr = MK_E_UNAVAILABLE;
    IRunningObjectTable *pROT;

    hr = pbc->GetRunningObjectTable(&pROT);

    if (SUCCEEDED(hr))
    {
        hr = pROT->GetTimeOfLastChange(this, pFileTime);
        pROT->Release();
    }
    else
    {
        hr = MK_E_UNAVAILABLE;
    }

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::GetTimeOfLastChange (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::Inverse
//
//  Synopsis:
//
//  Arguments:  [ppmk] --
//
//  Returns:
//
//  History:    1-16-96   JohannP (Johann Posch)   Created
//
//  Notes:     urlmon does not have aninverse
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::Inverse(IMoniker **ppmk)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::Inverse",
                "this=%#x, %#x",
                this, ppmk
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::Inverse");
    VDATEPTROUT(ppmk, LPMONIKER);

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::Inverse (hr:%lx)", MK_E_NOINVERSE);

    DEBUG_LEAVE(MK_E_NOINVERSE);
    return MK_E_NOINVERSE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::CommonPrefixWith
//
//  Synopsis:
//
//  Arguments:  [pmkOther] --
//              [ppmkPrefix] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::CommonPrefixWith(IMoniker *pmkOther, IMoniker **ppmkPrefix)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::CommonPrefixWith",
                "this=%#x, %#x, %#x",
                this, pmkOther, ppmkPrefix
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::CommonPrefixWith");
    HRESULT hr = E_NOTIMPL;
    VDATEPTROUT(ppmkPrefix, LPMONIKER);
    *ppmkPrefix = NULL;
    VDATEIFACE(pmkOther);

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::CommonPrefixWith (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::RelativePathTo
//
//  Synopsis:
//
//  Arguments:  [pmkOther] --
//              [ppmkRelPath] --
//
//  Returns:
//
//  History:    1-16-96   JohannP (Johann Posch)   Created
//              8-20-96   ClarG   (Clarence Glasse) Implemented
//
//  Notes: Code is based on composition algorithm in rfc 1808 (this code does
//         the reverse of that).
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::RelativePathTo(IMoniker *pmkOther, IMoniker **ppmkRelPath)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::RelativePathTo",
                "this=%#x, %#x, %#x",
                this, pmkOther, ppmkRelPath
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::RelativePathTo");
    HRESULT hr = NOERROR;
    VDATEPTROUT(ppmkRelPath, LPMONIKER);
    *ppmkRelPath = NULL;
    VDATEIFACE(pmkOther);

    CUrl *pUrlThis = NULL;
    CUrl *pUrlOther = NULL;
    LPSTR pch = NULL;
    LPSTR pszQueryThis = NULL;
    LPSTR pszQueryOther = NULL;
    LPSTR pszParamsThis = NULL;
    LPSTR pszParamsOther = NULL;

    char szRelPath[MAX_URL_SIZE + 1];

    if (!_pwzUrl)
    {
        hr = MK_E_NOTBINDABLE;
        goto End;
    }

    if (IsEqual(pmkOther) == S_OK)
    {
        // we are equal to pmkOther, so create an empty path URL moniker.
        if ((*ppmkRelPath = CreateEmptyPathUrlMon()) == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto End;
        }
        // CUrlmon has refcount of 1 now
    }
    else if (IsUrlMoniker(pmkOther))
    {
        if ((hr = HrCreateCUrlFromUrlMon(pmkOther, TRUE, &pUrlOther)) != NOERROR)
        {
            if (hr == MK_E_SYNTAX)
                hr = MK_E_NOTBINDABLE;
            goto End;
        }

        if ((hr = HrCreateCUrlFromUrlStr(_pwzUrl, TRUE, &pUrlThis)) != NOERROR)
        {
            if (hr == MK_E_SYNTAX)
                hr = MK_E_NOTBINDABLE;
            goto End;
        }

        // Each URL has been parsed into its separate components.
        // Now compute the relative path.
        if ((pUrlThis->_dwProto == DLD_PROTOCOL_NONE) ||
            (pUrlOther->_dwProto == DLD_PROTOCOL_NONE))
        {
            // Unrecognized protocol; return MK_S_HIM or MK_E_NOTBINDABLE
            if (pUrlThis->_pszProtocol[0] && pUrlOther->_pszProtocol[0])
            {
                *ppmkRelPath = pmkOther;
                pmkOther->AddRef();
                hr = MK_S_HIM;
            }
            else
            {
                hr = MK_E_NOTBINDABLE;
            }
            goto End;
        }

        // if the scheme and net_loc portion of the url are not equal,
        // return MK_S_HIM
        if ((pUrlThis->_dwProto != pUrlOther->_dwProto) ||
            (lstrcmpi(pUrlThis->_pszServerName, pUrlOther->_pszServerName) != 0) ||
            (pUrlThis->_ipPort != pUrlOther->_ipPort) ||
            (lstrcmpi(pUrlThis->_pszUserName, pUrlOther->_pszUserName) != 0) ||
            (lstrcmpi(pUrlThis->_pszPassword, pUrlOther->_pszPassword) != 0))
        {
            *ppmkRelPath = pmkOther;
            pmkOther->AddRef();
            hr = MK_S_HIM;
            goto End;
        }

#ifdef URLMON_RELPATHTO_PARSE_QUERY_PARAMS
        // parse the query and params info
        ParseUrlQuery(pUrlThis->_pszObject, &pszQueryThis);
        ParseUrlQuery(pUrlOther->_pszObject, &pszQueryOther);
        ParseUrlParams(pUrlThis->_pszObject, &pszParamsThis);
        ParseUrlParams(pUrlOther->_pszObject, &pszParamsOther);
#endif // URLMON_RELPATHTO_PARSE_QUERY_PARAMS

        // compute the relative path
        hr = HrGetRelativePath(
                pUrlThis->_pszObject, pUrlOther->_pszObject,
                pUrlThis->_dwProto, pUrlThis->_pszServerName, szRelPath);
        if (FAILED(hr))
            goto End;

#ifdef URLMON_RELPATHTO_PARSE_QUERY_PARAMS
        // append the appropriate query and params info
        AddParamsAndQueryToRelPath(
            szRelPath, pszParamsThis, pszParamsOther, pszQueryThis, pszQueryOther);
#endif // URLMON_RELPATHTO_PARSE_QUERY_PARAMS

        if (szRelPath[0])
        {
            HRESULT hr2 = NOERROR;
            WCHAR wzObjRel[MAX_URL_SIZE + 1];

            A2W(szRelPath, wzObjRel, MAX_URL_SIZE);
            hr2 = CreateURLMoniker(NULL, wzObjRel, ppmkRelPath);
            if (FAILED(hr2))
                hr = hr2;
        }
        else
        {
            *ppmkRelPath = CreateEmptyPathUrlMon();
            if (!(*ppmkRelPath))
                hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = MonikerRelativePathTo(this, pmkOther, ppmkRelPath, TRUE);
    }

End:
    if (pUrlThis)
        delete pUrlThis;
    if (pUrlOther)
        delete pUrlOther;
    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::RelativePathTo (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::GetDisplayName
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [pmkToLeft] --
//              [ppszDisplayName] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::GetDisplayName(IBindCtx *pbc, IMoniker *pmkToLeft, LPOLESTR *ppszDisplayName)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::GetDisplayName",
                "this=%#x, %#x, %#x, %#x",
                this, pbc, pmkToLeft, ppszDisplayName
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::GetDisplayName");
    HRESULT hr = NOERROR;
    VDATEPTROUT(ppszDisplayName, LPSTR);
    *ppszDisplayName = NULL;
    if (pbc)
    {
        VDATEIFACE(pbc);
    }
    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }

    *ppszDisplayName = OLESTRDuplicate(_pwzUrl);

    if (*ppszDisplayName == NULL)
    {
        hr = E_OUTOFMEMORY;
    }

    PerfDbgLog2(tagCUrlMon, this, "-CUrlMon::GetDisplayName (hr:%lx) [%ws]", hr, *ppszDisplayName ? *ppszDisplayName : L"");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::ParseDisplayName
//
//  Synopsis:
//
//  Arguments:  [IMoniker] --
//              [pmkToLeft] --
//              [ULONG] --
//              [IMoniker] --
//              [ppmkOut] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::ParseDisplayName(IBindCtx *pbc,IMoniker *pmkToLeft,
                LPOLESTR pozDisplayName,ULONG *pchEaten,IMoniker **ppmkOut)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::ParseDisplayName",
                "this=%#x, %#x, %#x, %#x, %#x, %#x",
                this, pbc, pmkToLeft, pozDisplayName, pchEaten, ppmkOut
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::ParseDisplayName");

    HRESULT hr;
    WCHAR wzURL[MAX_URL_SIZE + 1];
    VDATEPTROUT(ppmkOut, LPMONIKER);
    *ppmkOut = NULL;
    VDATEIFACE(pbc);
    if (pmkToLeft) VDATEIFACE(pmkToLeft);
    VDATEPTRIN(pozDisplayName, char);
    VDATEPTROUT(pchEaten, ULONG);

    hr = ConstructURL(pbc, this, pmkToLeft, pozDisplayName, wzURL,
            sizeof(wzURL), CU_CANONICALIZE);

    if (hr != NOERROR)
    {
        goto End;
    }

    if (!wcscmp(_pwzUrl, wzURL))
    {
        // Return ourselves if new URL is the same.

        *ppmkOut = this;
        AddRef();

        hr = NOERROR;
    }
    else
    {
        hr = CreateURLMoniker(NULL, wzURL, ppmkOut);
    }

    if (hr == NOERROR)
    {
        // We have eaten all the characters
        *pchEaten = wcslen(pozDisplayName);
    }

End:

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::ParseDisplayName (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::IsSystemMoniker
//
//  Synopsis:
//
//  Arguments:  [pdwMksys] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::IsSystemMoniker(DWORD *pdwMksys)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::IsSystemMoniker",
                "this=%#x, %#x",
                this, pdwMksys
                ));
                
    PerfDbgLog(tagCUrlMon, this, "CUrlMon::IsSystemMoniker");
    VDATEPTROUT(pdwMksys, DWORD);
    *pdwMksys = MKSYS_URLMONIKER;

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}


// Delete the URL string if we have one
void CUrlMon::DeleteUrl()
{
    DEBUG_ENTER((DBG_MONIKER,
                None,
                "CUrlMon::DeleteUrl",
                "this=%#x",
                this
                ));
                
    if (_pwzUrl)
        delete [] _pwzUrl;

    _pwzUrl = NULL;

    DEBUG_LEAVE(0);
}

HRESULT CUrlMon::SetUrl(LPWSTR pwzUrl, LPWSTR pwzExtra)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::SetUrl",
                "this=%#x, %.80wq, %.80wq",
                this, pwzUrl, pwzExtra
                ));
                
    int clen;
    HRESULT hr = NOERROR;

    TransAssert((pwzUrl));

    clen  = wcslen(pwzUrl) + 1;
    if (pwzExtra)
    {
        clen  += wcslen(pwzExtra);
    }
    LPWSTR pwzStr = (LPWSTR) new WCHAR [clen];
    if (pwzStr)
    {
        wcscpy(pwzStr, pwzUrl);
        if (pwzExtra)
        {
            wcscat(pwzStr, pwzExtra);
        }
        if (_pwzUrl)
        {
            delete [] _pwzUrl;
        }
        _pwzUrl = pwzStr;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    DEBUG_LEAVE(hr);
    return hr;
}


//    Helper function for IMoniker::IsRunning and BindToObject.
//    Return NOERROR if running, and S_FALSE if not.
//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::IsRunningROT
//
//  Synopsis:   Checks if the moniker is running
//
//  Arguments:  [pbc] --
//              [pmkToLeft] --
//              [ppROT] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CUrlMon::IsRunningROT(IBindCtx *pbc, IMoniker *pmkToLeft, IRunningObjectTable **ppROT)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IsRunningROT",
                "this=%#x, %#x, %#x, %#x",
                this, pbc, pmkToLeft, ppROT
                ));
                
    HRESULT hr;
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::IsRunningROT");
    IRunningObjectTable *pROT;

    hr = pbc->GetRunningObjectTable(&pROT);
    if (SUCCEEDED(hr))
    {
        hr = pROT->IsRunning(this);

        if (ppROT != NULL && SUCCEEDED(hr))
        {
            *ppROT = pROT;
        }
        else
        {
            pROT->Release();
        }
    }

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::IsRunningROT (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::IsUrlMoniker
//
//  Synopsis:   Checks if pMk is a URL moniker
//
//  Arguments:  [pMk] -- the moniker to be checked
//
//  Returns:    true if moniker is URL moniker
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CUrlMon::IsUrlMoniker(IMoniker *pMk)
{
    DEBUG_ENTER((DBG_MONIKER,
                Bool,
                "CUrlMon::IsUrlMoniker",
                "this=%#x, %#x",
                this, pMk
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::IsUrlMoniker");
    BOOL fRet = FALSE;

    if (pMk)
    {
        DWORD dwMnk = 0;
        pMk->IsSystemMoniker(&dwMnk);
        fRet = (dwMnk == MKSYS_URLMONIKER);
    }

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::IsUrlMoniker (fRet:%d)", fRet);

    DEBUG_LEAVE(fRet);
    return fRet;
}


// ********** Helper Functions **********
// These functions are used by RelativePathTo

//+---------------------------------------------------------------------------
//
//  Function: CreateEmptyPathUrlMon
//
//  Synopsis: Create a UrlMon with empty path "", such that composing it onto
//            a base UrlMon via IMoniker::ComposeWith will yield a moniker
//            equal to the base UrlMon.
//            We don't call CreateUrlMoniker(""), to do this because that will
//            return a UrlMon with path "/".  Composing such a moniker onto
//            a base UrlMon out everything after the host name.
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:   8-16-96   ClarG  (Clarence Glasse)          Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CUrlMon * CreateEmptyPathUrlMon()
{
    DEBUG_ENTER((DBG_MONIKER,
                Pointer,
                "CreateEmptyPathUrlMon",
                NULL
                ));
                
    PerfDbgLog(tagCUrlMon, NULL, "+CreateEmptyPathUrlMon");
    CUrlMon * pUMk = NULL;
    LPWSTR pwzUrlEmpty = NULL;

    // allocate empty string
    if ((pwzUrlEmpty = new WCHAR [1]) == NULL)
    {
        goto End;
    }
    pwzUrlEmpty[0] = 0;

    if ((pUMk = new CUrlMon(pwzUrlEmpty)) == NULL)
    {
        delete pwzUrlEmpty;
        goto End;
    }
    // pUMk has refcount of 1 now

End:
    PerfDbgLog1(tagCUrlMon, NULL, "-CreateEmptyPathUrlMon, pUMk:%lx", pUMk);

    DEBUG_LEAVE(pUMk);
    return pUMk;
}


//+---------------------------------------------------------------------------
//
//  Function: HrCreateCUrlFromUrlMon
//
//  Synopsis: Given a Url moniker pmkUrl, create a CUrl object.  Assumes that
//            pmkUrl is indeed a Url moniker.
//
//  Arguments:  [pmkUrl] -- Url moniker
//              [fParseUrl] -- if TRUE, parse the URL.
//              [ppUrl] -- returns created CUrl obj, which caller must delete
//                         when finished with it.
//
//  Returns: NOERROR is successful.
//
//  History:   8-16-96   ClarG  (Clarence Glasse)          Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT  HrCreateCUrlFromUrlMon(LPMONIKER pmkUrl, BOOL fParseUrl, CUrl **ppUrl)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "HrCreateCUrlFromUrlMon",
                "%#x, %B, %#x",
                pmkUrl, fParseUrl, ppUrl
                ));
                
    PerfDbgLog(tagCUrlMon, NULL, "+HrCreateCUrlFromUrlMon");
    UrlMkAssert((pmkUrl));
    UrlMkAssert((ppUrl));
    HRESULT hr = NOERROR;
    LPBC pbc = NULL;
    LPWSTR pwzUrl = NULL;

    if ((*ppUrl = new CUrl) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto End;
    }

    if( !(*ppUrl)->CUrlInitAll() )
    {
        hr = E_OUTOFMEMORY;
        goto End;
    }

    if ((hr = CreateBindCtx(0, &pbc)) != NOERROR)
    {
        goto End;
    }

    if ((hr = pmkUrl->GetDisplayName(pbc, NULL, &pwzUrl)) != NOERROR)
    {
        goto End;
    }


    W2A(pwzUrl, (*ppUrl)->_pszBaseURL, MAX_URL_SIZE);

    if (fParseUrl)
    {
        if (!(*ppUrl)->ParseUrl())
        {
            hr = MK_E_SYNTAX;
            goto End;
        }
    }

End:
    if (pbc)
        pbc->Release();
    if (pwzUrl)
        CoTaskMemFree(pwzUrl);

    if ((hr != NOERROR) && (*ppUrl != NULL))
    {
        delete *ppUrl;
        *ppUrl = NULL;
    }

    PerfDbgLog1(tagCUrlMon, NULL, "-HrCreateCUrlFromUrlMon (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function: HrCreateCUrlFromUrlStr
//
//  Synopsis: Given a Url string pwzUrl, create a CUrl object.
//
//  Arguments:  [pwzUrl] -- Url string
//              [fParseUrl] -- if TRUE, parse the URL.
//              [ppUrl] -- returns created CUrl obj, which caller must delete
//                         when finished with it.
//
//  Returns: NOERROR is successful.
//
//  History:   8-16-96   ClarG  (Clarence Glasse)          Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT  HrCreateCUrlFromUrlStr(LPCWSTR pwzUrl, BOOL fParseUrl, CUrl **ppUrl)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "HrCreateCUrlFromUrlStr",
                "%.80wq, %B, %#x",
                pwzUrl, fParseUrl, ppUrl
                ));
                
    PerfDbgLog(tagCUrlMon, NULL, "+HrCreateCUrlFromUrlStr");
    UrlMkAssert((pwzUrl));
    UrlMkAssert((ppUrl));
    HRESULT hr = NOERROR;

    if ((*ppUrl = new CUrl) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto End;
    }

    if( !(*ppUrl)->CUrlInitAll() )
    {
        hr = E_OUTOFMEMORY;
        goto End;
    }

    W2A(pwzUrl, (*ppUrl)->_pszBaseURL, MAX_URL_SIZE);

    if (fParseUrl)
    {
        if (!(*ppUrl)->ParseUrl())
        {
            hr = MK_E_SYNTAX;
            goto End;
        }
    }

End:
    if ((hr != NOERROR) && (*ppUrl != NULL))
    {
        delete *ppUrl;
        *ppUrl = NULL;
    }

    PerfDbgLog1(tagCUrlMon, NULL, "-HrCreateCUrlFromUrlStr (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function: IsSeparator
//
//  Synopsis: Return TRUE if ch is a file path or url path separator char.
//
//  Arguments:  [ch] -- the char in question
//                         when finished with it.
//
//  Returns: TRUE if ch is a separator char
//
//  History:   8-20-96   ClarG  (Clarence Glasse)          Created
//
//  Notes: This is taken from OLE2 file moniker code
//
//----------------------------------------------------------------------------
inline BOOL IsSeparator( char ch )
{
    DEBUG_ENTER((DBG_MONIKER,
                Bool,
                "IsSeparator",
                "%c",
                ch
                ));
                
    BOOL fRet = (ch == '\\' || ch == '/' || ch == ':');

    DEBUG_LEAVE(fRet);
    return fRet;
}


//+---------------------------------------------------------------------------
//
//  Function: CountSegments
//
//  Synopsis: Return the number of segments in file or url path pch.
//
//  Arguments:  [pch] -- the string in question.
//
//  Returns: number of segments in pch
//
//  History:   8-20-96   ClarG  (Clarence Glasse)          Created
//
//  Notes: This is taken from OLE2 file moniker code
//
//----------------------------------------------------------------------------
int CountSegments ( LPSTR pch )
{
    DEBUG_ENTER((DBG_MONIKER,
                Int,
                "CountSegments",
                "%.80q",
                pch
                ));
                
    PerfDbgLog(tagCUrlMon, NULL, "+CountSegments");
    //  counts the number of pieces in a path, after the first colon, if
    //  there is one

    int n = 0;
    LPSTR pch1;
    pch1 = pch;
    while (*pch1 != '\0' && *pch1 != ':') IncLpch(pch1);
    if (*pch1 == ':') pch = ++pch1;
    while (*pch != '\0')
    {
        while (*pch && IsSeparator(*pch)) pch++;
        if (*pch) n++;
        while (*pch && (!IsSeparator(*pch))) IncLpch(pch);
    }

    PerfDbgLog1(tagCUrlMon, NULL, "-CountSegments (n:%ld)", n);

    DEBUG_LEAVE(n);
    return n;
}


//+---------------------------------------------------------------------------
//
//  Function: HrGetRelativePath
//
//  Synopsis: Compute and return relative path from url path
//            lpszBase to url path lpszOther.
//
//  Arguments:  [lpszBase] -- the base path without the scheme and host info
//              [lpszOther] -- the target path without the scheme and host
//              [dwProto] -- DLD_PROTOCOL_XXX value, indicating the scheme
//                           of the urls.
//              [lpszHost] -- the host name for the urls
//              [lpszRelPath] -- buffer of size MAX_URL_SIZE that returns the
//                               relative path.
//
//  Returns: NOERROR, MK_S_HIM, MK_E_NOTBINDABLE, or some other hresult.
//
//  History:   8-20-96   ClarG  (Clarence Glasse)          Created
//
//  Notes: This is based on OLE2 file moniker code
//
//----------------------------------------------------------------------------
HRESULT HrGetRelativePath(
    LPSTR lpszBase, LPSTR lpszOther, DWORD dwProto, LPSTR lpszHost,
    LPSTR lpszRelPath)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "HrGetRelativePath",
                "%.80q, %.80q, %#x, %.80q, %.80q",
                lpszBase, lpszOther, dwProto, lpszHost, lpszRelPath
                ));
                
    PerfDbgLog(tagCUrlMon, NULL, "+HrGetRelativePath");
    HRESULT hr = NOERROR;
    LPSTR lpszRover;
    LPSTR lpszMarker;
    LPSTR lpch;
    LPSTR lpchStripBaseSav = NULL;
    char  ch1;
    char  ch2;
    char  chStripBaseSav;
    char  chNull = '\0';
    int i;
    int cAnti;

    lpszRelPath[0] = 0;

    // if neither lpszBase nor lpszRelPath look like absolute url or file
    // paths, return MK_E_NOTBINDALBE
    if (!lpszBase[0] || !lpszOther[0])
    {
        hr = MK_E_NOTBINDABLE;
        goto End;
    }

    if ((lpszBase[0] != '\\') && (lpszBase[0] != '/') && (lpszBase[1] != ':'))
    {
        hr = MK_E_NOTBINDABLE;
        goto End;
    }

    if ((lpszOther[0] != '\\') && (lpszOther[0] != '/') && (lpszOther[1] != ':'))
    {
        hr = MK_E_NOTBINDABLE;
        goto End;
    }

    if (lstrcmpi(lpszBase, lpszOther) == 0)
    {
        // if paths are equal, relative path is empty string
        lpszRelPath[0] = 0;
        hr = NOERROR;
        goto End;
    }

    // if base does not end in a separator, remove its last piece
    lpch = lpszBase + lstrlen(lpszBase);
    for( ; ((!(IsSeparator(*lpch))) && (lpch > lpszBase)); DecLpch(lpszBase, lpch) );
    if (IsSeparator(*lpch))
    {
        IncLpch(lpch);
        lpchStripBaseSav = lpch;
        chStripBaseSav = *lpch;
        *lpch = '\0';
    }

    lpszRover = lpszBase;
    lpszMarker = lpszRover;
    i = 0;
    lpszOther = lpszOther;

    while (*lpszRover != '\0')
    {
        while (*lpszRover && IsSeparator(*lpszRover)) lpszRover++;
        while (*lpszRover && !IsSeparator(*lpszRover)) IncLpch(lpszRover);
        //      the first part of the path is between m_szPath and
        //      lpszRover
        i = (int) (lpszRover - lpszBase);
        ch1 = *lpszRover;
        ch2 = *(lpszOther + i);
        *lpszRover = '\0';
        *(lpszOther + i) = '\0';

        if (lstrcmpi(lpszBase, lpszOther) == 0)
            lpszMarker = lpszRover;
        else
            lpszRover = &chNull;

        *(lpszBase + i) = ch1;
        *(lpszOther + i) = ch2;
    }

    //  common portion is from lpszBase to lpszMarker
    i = (int) (lpszMarker - lpszBase);
    if ((!lpszHost || !lpszHost[0]) && (i == 0))
    {
        lstrcpy(lpszRelPath, lpszOther);
        hr = MK_S_HIM;
        goto End;
    }

    lpszRover = lpszRelPath;
    while (IsSeparator(*(lpszOther+i))) i++;
    cAnti = CountSegments(lpszMarker);

    while (cAnti)
    {
        if (dwProto != DLD_PROTOCOL_FILE)
            lstrcpy(lpszRover, "../");
        else
            lstrcpy(lpszRover, "..\\");
        lpszRover += 3;
        cAnti--;
    }

    lstrcpy(lpszRover, lpszOther + i);

End:
    if (lpchStripBaseSav)
    {
        *lpchStripBaseSav = chStripBaseSav;
    }

    PerfDbgLog2(tagCUrlMon, NULL, "-HrGetRelativePath [%s], hr:%lx", lpszRelPath?lpszRelPath:"", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


#ifdef URLMON_RELPATHTO_PARSE_QUERY_PARAMS
//+---------------------------------------------------------------------------
//
//  Function: ParseUrlQuery
//
//  Synopsis: Parse the Query portion of a url
//
//  Arguments:  [pszURL] -- url to parse; the query portion is "removed" from
//                          pszURL when function returns.
//              [ppszQuery] -- returns pointer to query portion of URL
//
//  Returns: nothing
//
//  History:   8-20-96   ClarG  (Clarence Glasse)          Created
//
//  Notes: This is based on OLE2 file moniker code
//
//----------------------------------------------------------------------------
void ParseUrlQuery(LPSTR pszURL, LPSTR *ppszQuery)
{
    DEBUG_ENTER((DBG_MONIKER,
                None,
                "ParseUrlQuery",
                "%.80q, %#x",
                pszURL, ppszQuery
                ));
                
    PerfDbgLog(tagCUrlMon, NULL, "+ParseUrlQuery");
    LPSTR pch = NULL;

    *ppszQuery = NULL;

    for (pch = pszURL; *pch; IncLpch(pch))
    {
        if (*pch == '?')
        {
            *pch = '\0';
            pch++;
            if (*pch)
                *ppszQuery = pch;
            break;
        }
    }

    PerfDbgLog(tagCUrlMon, NULL, "-ParseUrlQuery");

    DEBUG_LEAVE(0);
}


//+---------------------------------------------------------------------------
//
//  Function: ParseUrlParams
//
//  Synopsis: Parse the Params portion of a url
//
//  Arguments:  [pszURL] -- url to parse; the params portion is "removed" from
//                          pszURL when function returns.
//              [ppszParams] -- returns pointer to params portion of URL
//
//  Returns: nothing
//
//  History:   8-20-96   ClarG  (Clarence Glasse)          Created
//
//  Notes: This is based on OLE2 file moniker code
//
//----------------------------------------------------------------------------
void ParseUrlParams(LPSTR pszURL, LPSTR *ppszParams)
{
    DEBUG_ENTER((DBG_MONIKER,
                None,
                "ParseUrlParams",
                "%.80q, %#x",
                pszURL, ppszParams
                ));
                
    PerfDbgLog(tagCUrlMon, NULL, "+ParseUrlParams");
    LPSTR pch = NULL;

    *ppszParams = NULL;

    for (pch = pszURL; *pch; IncLpch(pch))
    {
        if (*pch == ';')
        {
            *pch = '\0';
            pch++;
            if (*pch)
                *ppszParams = pch;
            break;
        }
    }

    PerfDbgLog(tagCUrlMon, NULL, "-ParseUrlParams");

    DEBUG_LEAVE(0);
}


//+---------------------------------------------------------------------------
//
//  Function: AddParamsAndQueryToRelPath
//
//  Synopsis: Given a computed relative URL path from a base to a target,
//            append the appropriate Params and Query info.
//
//  Arguments:  [szRelPath] -- computed relative path
//              [pszParamsBase] -- Params info of base URL
//              [pszParamsOther] -- Params info of target URL
//              [pszQueryBase] -- Query info of base URL
//              [pszQueryOther] -- Query info of target URL
//
//  Returns: nothing
//
//  History:   8-20-96   ClarG  (Clarence Glasse)          Created
//
//  Notes: This is based on OLE2 file moniker code
//
//----------------------------------------------------------------------------
void AddParamsAndQueryToRelPath(
    LPSTR szRelPath,
    LPSTR pszParamsBase, LPSTR pszParamsOther,
    LPSTR pszQueryBase, LPSTR pszQueryOther)
{
    DEBUG_ENTER((DBG_MONIKER,
                None,
                "AddParamsAndQueryToRelPath",
                "%.80q, %.80q, %.80q, %.80q, %.80q",
                szRelPath, pszParamsBase, pszParamsOther, pszQueryBase, pszQueryOther
                ));
                
    PerfDbgLog(tagCUrlMon, NULL, "+AddParamsAndQueryToRelPath");

    if (szRelPath[0])
    {
        if (pszParamsOther)
        {
            lstrcat(szRelPath, ";");
            lstrcat(szRelPath, pszParamsOther);
        }
        if (pszQueryOther)
        {
            lstrcat(szRelPath, "?");
            lstrcat(szRelPath, pszQueryOther);
        }
    }
    else
    {
        if (pszParamsOther &&
            (!pszParamsBase || (lstrcmpi(pszParamsOther, pszParamsBase) !=  0)))
        {
            lstrcat(szRelPath, ";");
            lstrcat(szRelPath, pszParamsOther);

            if (pszQueryOther)
            {
                lstrcat(szRelPath, "?");
                lstrcat(szRelPath, pszQueryOther);
            }
        }
        else if (pszQueryOther &&
                 (!pszQueryBase || (lstrcmpi(pszQueryOther, pszQueryBase) !=  0)))
        {
            lstrcat(szRelPath, "?");
            lstrcat(szRelPath, pszQueryOther);
        }
    }

    PerfDbgLog(tagCUrlMon, NULL, "-AddParamsAndQueryToRelPath");

    DEBUG_LEAVE(0);
}
#endif // URLMON_RELPATHTO_PARSE_QUERY_PARAMS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\transdat.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       transdata.cxx
//
//  Contents:   Contains the module which provide data passed on in OnDataAvailable
//
//  Classes:
//
//  Functions:
//
//  History:    12-07-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#ifndef unix
#include "..\stg\rostmdir.hxx"
#include "..\stg\rostmfil.hxx"
#else
#include "../stg/rostmdir.hxx"
#include "../stg/rostmfil.hxx"
#endif /* unix */

PerfDbgTag(tagCTransData,    "Urlmon", "Log CTransData",        DEB_DATA);
    DbgTag(tagCTransDataErr, "Urlmon", "Log CTransData Errors", DEB_DATA|DEB_ERROR);

HRESULT FindMediaType(LPCSTR pszType, CLIPFORMAT *cfType);
HRESULT FindMediaTypeW(LPCWSTR pwzType, CLIPFORMAT *cfType);

static LPSTR g_szCF_NULL = "*/*";

char  szContent[]           = "Content Type";
char  szClassID[]           = "CLSID";
char  szFlags[]             = "Flags";
char  szExtension[]         = "Extension";
char  szMimeKey[]           = "MIME\\Database\\Content Type\\";
const ULONG ulMimeKeyLen    = ((sizeof(szMimeKey)/sizeof(char))-1);

// The byte combination that identifies that a file is a storage of
// some kind
const BYTE SIGSTG[] = {0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1};
const BYTE CBSIGSTG = sizeof(SIGSTG);


#define CBSNIFFDATA_MAX 256

#ifdef DBG
char *szDataSinkName[] =
{
     "Unknown"
    ,"StreamNoCopyData"
    ,"File"
    ,"Storage"
    ,"StreamOnFile"
    ,"StreamBindToObject"
    ,"GenericStream"
};

#define GetDataSinkName(ds) szDataSinkName[ds]

#else

#define GetDataSinkName(ds) ""

#endif


//+---------------------------------------------------------------------------
//
//  Method:     CTransData::CTransData
//
//  Synopsis:
//
//  Arguments:  [pTrans] --
//              [DWORD] --
//              [dwSizeBuffer] --
//              [fBindToObject] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransData::CTransData(CTransaction *pTrans, LPBYTE pByte,DWORD dwSizeBuffer, BOOL fBindToObject) : _CRefs()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                None,
                "CTransData::CTransData",
                "this=%#x, %#x, %#x, %#x, %B",
                this, pTrans, pByte, dwSizeBuffer, fBindToObject
                ));
                
    _TransDataState = TransData_Initialized;
    _wzMime[0] = '\0';
    _wzFileName[0]= 0;
    _pwzUrl = 0;
    _pwzRedirectUrl = 0;
    _pStgMed = 0;
    _lpBuffer = pByte;
    _cbBufferSize = dwSizeBuffer;
    _cbDataSize = 0;
    _cbTotalBytesRead = 0;
    _cbReadReturn = 0;
    _cbBufferFilled = 0;
    _cbDataSniffMin = DATASNIFSIZE_MIN;
    _pEnumFE = 0;
    _pStgMed = NULL;
    _pProt = NULL;

    _fBindToObject = fBindToObject; //Flag changes on attachment.. Use sparingly.
    _fMimeTypeVerified = TRUE;
    _fDocFile = FALSE;
    _fInitialized = FALSE;
    _fRemoteReady = FALSE;
    _fCache = FALSE;
    _fLocked = FALSE;
    _fFileAsStmOnFile = FALSE;
    _fEOFOnSwitchSink = FALSE; 

    _hFile = NULL;
    _cbBytesReported = 0;
    _dwAttached = 0;
    _grfBindF  = 0;
    _grfBSC = 0;

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::~CTransData
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransData::~CTransData()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                None,
                "CTransData::~CTransData",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::~CTransData");

    if (_pwzUrl)
    {
        delete [] _pwzUrl;
    }

    if (_pwzRedirectUrl)
    {
        delete [] _pwzRedirectUrl;
    }
    
    if (_pProt)
    {
        if (_fLocked)
        {
            _pProt->UnlockRequest();
        }
        _pProt->Release();
        _pProt = NULL;
    }

    if (_pBndCtx)
    {
        _pBndCtx->Release();
    }

    if (_pStgMed)
    {
        TransAssert((   (_pStgMed->pUnkForRelease == NULL)
                     || (_pStgMed->pUnkForRelease == this)));

        if (_pStgMed->tymed == TYMED_ISTREAM)
        {
            _pStgMed->pstm->Release();
        }
        else if (_pStgMed->tymed == TYMED_FILE)
        {
            if (_pStgMed->lpszFileName)
            {
                delete _pStgMed->lpszFileName;
            }
        }
        else if (_pStgMed->tymed == TYMED_ISTORAGE)
        {
            _pStgMed->pstg->Release();
        }

        DbgLog1(tagCTransData, this, "=== CTransData::~CTransData: (pStgMed:%lx)", _pStgMed);
        delete _pStgMed;
        _pStgMed = NULL;
    }

    if (_hFile)
    {
        DbgLog1(tagCTransData, this, "=== CTransData::~CTransData (CloseHandle(%lx)", _hFile);
        CloseHandle(_hFile);
        _hFile = NULL;
    }

    if (_lpBuffer)
    {
        delete _lpBuffer;
    }

    PerfDbgLog(tagCTransData, this, "-CTransData::~CTransData");
    
    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    PerfDbgLog(tagCTransData, this, "+CTransData::QueryInterface");

    *ppvObj = NULL;
    if ((riid == IID_IUnknown) || (riid == IID_ITransactionData))
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::QueryInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CTransData::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTransData::AddRef(void)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Dword,
                "CTransData::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    LONG lRet = ++_CRefs;
    PerfDbgLog1(tagCTransData, this, "CTransData::AddRef (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CTransData::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTransData::Release(void)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Dword,
                "CTransData::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::Release");

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        delete this;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::Release (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::GetTransactionData
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [ppwzFilename] --
//              [ppwzMime] --
//              [pdwSizeTotal] --
//              [pdwSizeAvailable] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    9-09-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::GetTransactionData(LPCWSTR pwzUrl, LPOLESTR *ppwzFilename, LPOLESTR *ppwzMime,
                                            DWORD *pdwSizeTotal, DWORD *pdwSizeAvailable, DWORD  dwReserved)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::GetTransactionData",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x, %#x",
                this, pwzUrl, ppwzFilename, ppwzMime, pdwSizeTotal, pdwSizeAvailable, dwReserved
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::GetTransactionData");
    HRESULT hr = NOERROR;
    TransAssert((pwzUrl && ppwzFilename && ppwzMime && pdwSizeTotal && pdwSizeAvailable ));
    TransAssert((_wzFileName[0] != 0));


    if  (ppwzFilename && ppwzMime && pdwSizeTotal && pdwSizeAvailable)
    {
        LPWSTR pwzUrlLocal = GetUrl();
        TransAssert((pwzUrlLocal));

        DbgLog2(tagCTransData, this, "=== CTransData::GetTransactionData (pwzUrlLocal:%ws, pwzUrl:%ws)", pwzUrlLocal, pwzUrl);

        if (!wcscmp(pwzUrl, _pwzUrl) || (_pwzRedirectUrl && !wcscmp(pwzUrl, _pwzRedirectUrl)))
        {
            *ppwzFilename = OLESTRDuplicate(_wzFileName);

            *ppwzMime = OLESTRDuplicate(_wzMime);

            if (_cbDataSize)
            {
                *pdwSizeTotal  = _cbDataSize;
            }
            else
            {
                *pdwSizeTotal  = _cbTotalBytesRead;
            }
            *pdwSizeAvailable = _cbTotalBytesRead;

        }
        else
        {
            *ppwzFilename = 0;
            *ppwzMime = NULL;
            *pdwSizeTotal = 0;
            *pdwSizeAvailable = 0;
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog5(tagCTransData, this, "-CTransData::GetTransactionData (hr:%lx, Filename:%ws, Mime:%ws, _cbDataSize:%ld, _cbTotalBytesRead:%ld)",
        hr, XDBG(*ppwzFilename,L""), XDBG(*ppwzMime,L""), _cbDataSize, _cbTotalBytesRead);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::Create
//
//  Synopsis:   Set up the transaction data object.
//
//  Arguments:  [pTrans] -- pointer to transaction
//              [riid] --   riid the users passed in
//              [ppCTD] --  the transdata object passed back
//
//  Returns:
//
//  History:    1-18-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::Create(LPCWSTR pwUrl, DWORD grfBindF, REFIID riid, IBindCtx *pBndCtx,
                                BOOL fBindToObject, CTransData **ppCTD)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::Create",
                "%.80wq, %#x, %#x, %#x, %B, %#x",
                pwUrl, grfBindF, &riid, pBndCtx, fBindToObject, ppCTD
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog1(tagCTransData, NULL, "+CTransData::Create(fBindToObject:%d)", fBindToObject);
    CTransData *pCTData;

    LPBYTE   lpBuffer;
    ULONG    cbBufferSize;
    cbBufferSize = DNLD_BUFFER_SIZE;

    TransAssert((DATASNIFSIZEDOCFILE_MIN <= cbBufferSize));
    lpBuffer = (LPBYTE) new BYTE[cbBufferSize];
    pCTData = new CTransData(NULL,lpBuffer,cbBufferSize, fBindToObject);

    if (lpBuffer && pCTData)
    {
        *ppCTD = pCTData;
        pCTData->Initialize(pwUrl, grfBindF, riid, pBndCtx);

        // Try to get an IEnumFORMATETC pointer from the bind context
        //hr = GetObjectParam(pbc, REG_ENUMFORMATETC, IID_IEnumFORMATETC, (IUnknown**)&_pEnumFE);
    }
    else
    {
        if (pCTData)
        {
            delete pCTData;
        }
        else if (lpBuffer)
        {
            delete lpBuffer;
        }

        hr = E_OUTOFMEMORY;
        *ppCTD = 0;
    }

    PerfDbgLog2(tagCTransData, NULL, "-CTransData::Create (out:%lx,hr:%lx)", *ppCTD, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::Initialize
//
//  Synopsis:
//
//  Arguments:  [riid] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::Initialize(LPCWSTR pwzUrl, DWORD grfBindF, REFIID riid, IBindCtx *pBndCtx, BOOL fBindToObject)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::Initialize",
                "this=%#x, %.80wq, %#x, %#x, %#x, %B",
                this, pwzUrl, grfBindF, &riid, pBndCtx, fBindToObject
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::Initialize");
    HRESULT hr = NOERROR;

    if (_fInitialized == FALSE)
    {
        _ds = DataSink_Unknown;
        _formatetc.tymed = TYMED_NULL;
        _grfBindF = grfBindF;
        _pBndCtx = pBndCtx;
        _pBndCtx->AddRef();
        
        _pwzUrl = OLESTRDuplicate((LPWSTR)pwzUrl);
        if (!_pwzUrl) 
        {
            hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
        {
            if (_fBindToObject)
            {
                _formatetc.tymed = TYMED_ISTREAM;
                _ds = DataSink_Unknown;
            }
            else if (riid == IID_IUnknown)
            {
                // this is the BindToStorage
                _formatetc.tymed = TYMED_FILE;
                _ds = DataSink_File;
            }
            else if (riid == IID_IStream)
            {
                // We do not know yet which kind of stream
                // SetDataSink will determine this.

                _formatetc.tymed = TYMED_ISTREAM;
                _ds = DataSink_StreamOnFile;
            }
            else if (riid == IID_IStorage)
            {
                BIND_OPTS bindopts;
                bindopts.cbStruct = sizeof(BIND_OPTS);
                hr = pBndCtx->GetBindOptions(&bindopts);
                _grfMode = bindopts.grfMode;

                _formatetc.tymed = TYMED_ISTORAGE;
                _ds = DataSink_Storage;

            }
            else
            {
                // this call should fail
                hr = E_INVALIDARG;
                TransAssert((FALSE && "Unknown data sink for this request!"));
            }
        }
        
        if (SUCCEEDED(hr))
        {
            HRESULT hr1;
            ITransactionData *pCTransData = NULL;
            LPWSTR pwzFilename = NULL;
            LPWSTR pwzMime = NULL;

            hr1 = GetObjectParam(pBndCtx, SZ_TRANSACTIONDATA, IID_ITransactionData, (IUnknown **)&pCTransData);
            DbgLog2(tagCTransData, this, "=== CTransData::Initialize GetObjectParam: pbndctx:%lx, hr:%lx)", pBndCtx, hr1);

            if (SUCCEEDED(hr1))
            {
                TransAssert((pCTransData));
                hr1 = pCTransData->GetTransactionData(_pwzUrl,&pwzFilename, &pwzMime, &_cbDataSize, &_cbTotalBytesRead, 0);
                DbgLog5(tagCTransData, this, "=== CTransData::Initialize GetTransactionData (hr:%lx, Filename:%ws, Mime:%ws, _cbDataSize:%ld, _cbTotalBytesRead:%ld)", hr1, pwzFilename, pwzMime, _cbDataSize, _cbTotalBytesRead);
                pCTransData->Release();
            }


            if (SUCCEEDED(hr1) )
            {
                // set the url filename
                SetFileName(pwzFilename);
                if (pwzMime)
                {
                    SetMimeType(pwzMime);
                    _fMimeTypeVerified = TRUE;
                }
                _fRemoteReady = TRUE;

                if (pwzMime)
                {
                    delete pwzMime;
                }
                if (pwzFilename)
                {
                    delete pwzFilename;
                }
            }
        }
        _fInitialized = TRUE;
    }
    else
    {
        _dwAttached++;
        
        if (_pBndCtx)
        {
            _pBndCtx->Release();
        }

        _pBndCtx = pBndCtx;

        if (_pBndCtx)
        {
            _pBndCtx->AddRef();
        }

        // no set up the righte datasink
        if (fBindToObject)
        {
            _fBindToObject = TRUE;
            SwitchDataSink(DataSink_StreamBindToObject);
        }
        else if (riid == IID_IUnknown)
        {
            SwitchDataSink(DataSink_File);
        }
        else if (   (riid == IID_IStream)
                 && (grfBindF & BINDF_NEEDFILE))
        {
            SwitchDataSink(DataSink_StreamOnFile);
        }

    }

    PerfDbgLog3(tagCTransData, this, "-CTransData::Initialize (_formatetc.tymed:%ld, _ds:%lx, hr:%lx)", _formatetc.tymed,_ds, hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransData::PrepareThreadTransfer
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::PrepareThreadTransfer()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::PrepareThreadTransfer",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::PrepareThreadTransfer");
    HRESULT hr = NOERROR;

    if (_pBndCtx)
    {
        _pBndCtx->Release();
        _pBndCtx = NULL;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::PrepareThreadTransfer (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransData::GetDataSink
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DataSink CTransData::GetDataSink()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Pointer,
                "CTransData::GetDataSink",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::GetDataSink");
    DataSink dsRet = DataSink_Unknown;

    if (_ds == DataSink_Unknown)
    {
        DWORD dwBindF = GetBindFlags();

        if (   (dwBindF & BINDF_ASYNCSTORAGE)
            && (dwBindF & BINDF_PULLDATA)
            && (_formatetc.tymed == TYMED_ISTREAM))
        {
            dsRet = _ds = DataSink_StreamNoCopyData;
        }
    }
    else
    {
        dsRet = _ds;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::GetDataSink (dsRet:%lx)", dsRet);

    DEBUG_LEAVE(dsRet);
    return dsRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::SetDataSink
//
//  Synopsis:
//
//  Arguments:  [dwBindF] --
//
//  Returns:
//
//  History:    2-25-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DataSink CTransData::SetDataSink(DWORD dwBindF)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Pointer,
                "CTransData::SetDataSink",
                "this=%#x, %#x",
                this, dwBindF
                ));
                
    PerfDbgLog1(tagCTransData, this, "+CTransData::SetDataSink (_ds:%lx)", _ds);

    TransAssert((_formatetc.tymed != TYMED_NULL));
    _grfBindF = dwBindF;

    switch (_ds)
    {
    case DataSink_Unknown:
    {
        if (_fBindToObject)
        {
            TransAssert((_formatetc.tymed == TYMED_ISTREAM));
            _ds = DataSink_StreamBindToObject;
        }
    }
    break;
    case DataSink_File:
    {
        TransAssert((_formatetc.tymed == TYMED_FILE));

    }
    break;
    case DataSink_StreamOnFile:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
        if ((dwBindF & BINDF_ASYNCSTORAGE) && (dwBindF & BINDF_PULLDATA))  
        {
            _ds = DataSink_StreamNoCopyData;
        }
    }
    break;

    case DataSink_StreamBindToObject:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
        TransAssert((_fBindToObject == TRUE));

        if (IsObjectReady() == NOERROR)
        {
            // 
            // change it to file - stream on file will be opened
            //
            _ds = DataSink_StreamOnFile;
        }
        else if ((dwBindF & BINDF_ASYNCSTORAGE) && (dwBindF & BINDF_PULLDATA))
        {
            _ds = DataSink_StreamNoCopyData;
        }

    }
    break;

    case DataSink_Storage:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTORAGE));
    }
    break;

    case DataSink_GenericStream:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
    }
    break;

    default:
        TransAssert((FALSE && "CTransData::SetDataSink -- Invalid data location"));
    break;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::SetDataSink (_ds:%lx)", _ds);

    DEBUG_LEAVE(_ds);
    return _ds;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::SwitchDataSink
//
//  Synopsis:
//
//  Arguments:  [dwBindF] --
//
//  Returns:
//
//  History:    2-25-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DataSink CTransData::SwitchDataSink(DataSink dsNew)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Pointer,
                "CTransData::SwitchDataSink",
                "this=%#x, %#x",
                this, dsNew
                ));
                
    PerfDbgLog2(tagCTransData, this, "+CTransData::SwitchDataSink (_ds:%lx, dsNew:%lx)", _ds, dsNew);

    TransAssert((_ds != DataSink_Unknown));
    TransAssert((_formatetc.tymed != TYMED_NULL));
    HRESULT hr = NOERROR;

    switch (_ds)
    {
    case DataSink_File:
    {
        TransAssert((_formatetc.tymed == TYMED_FILE));
    }
    break;
    case DataSink_StreamOnFile:
    {
         TransAssert((_wzFileName[0] != 0));
         _formatetc.tymed = TYMED_ISTREAM;
    }
    break;

    case DataSink_GenericStream:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
    }
    break;

    case DataSink_StreamNoCopyData:
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
        if (   dsNew == DataSink_StreamOnFile
            || dsNew == DataSink_GenericStream
            || dsNew == DataSink_StreamBindToObject)
        {
            _ds = dsNew;
            DWORD dwNew = 0;
            hr = OnDataReceived(_grfBSC, 0, 0, &dwNew);
            if( hr == S_FALSE)
            {
                _fEOFOnSwitchSink = TRUE;
            }
        }

    break;

    case DataSink_StreamBindToObject:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
        TransAssert((_fBindToObject == TRUE));
        _ds = dsNew;
        if (_ds == DataSink_File)
        {
            _formatetc.tymed = TYMED_FILE;
            DWORD dwNew = 0;
            hr = OnDataReceived(_grfBSC, 0, 0, &dwNew);
            if( hr == S_FALSE)
            {
                _fEOFOnSwitchSink = TRUE;
            }
        }

    }
    break;

    case DataSink_Storage:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTORAGE));
    }
    break;

    default:
        TransAssert((FALSE && "CTransData::SwitchDataSink -- Invalid data location"));
    break;
    }

    PerfDbgLog2(tagCTransData, this, "-CTransData::SwitchDataSink (_ds:%lx, dsNew:%lx)", _ds, dsNew);

    DEBUG_LEAVE(_ds);
    return _ds;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::IsFileRequired()
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CTransData::IsFileRequired()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Bool,
                "CTransData::IsFileRequired",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::IsFileRequired()");
    BOOL fRet = FALSE;
    TransAssert((_ds != DataSink_Unknown));

    switch (_ds)
    {
    case DataSink_File:
    case DataSink_StreamOnFile:
        fRet = TRUE;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::IsFileRequired() (fRet:%d)", fRet);

    DEBUG_LEAVE(fRet);
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::GetData
//
//  Synopsis:
//
//  Arguments:  [ppformatetc] --
//              [ppStgMed] --
//              [grfBSCF] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::GetData(FORMATETC **ppformatetc, STGMEDIUM **ppStgMed, DWORD grfBSCF)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::GetData",
                "this=%#x, %#x, %#x, %#x",
                this, ppformatetc, ppStgMed, grfBSCF
                ));
                
    PerfDbgLog1(tagCTransData, this, "+CTransData::GetData (_ds:%ld)", _ds);
    HRESULT hr = INET_E_DATA_NOT_AVAILABLE;
    BOOL fNewStgMed = FALSE;
    DataSink ds;

    *ppStgMed = 0;
    *ppformatetc = 0;


    if (_pStgMed == NULL)
    {
        // first find the formatETC based on
        // clipformat and the EnumFormatETC
        FindFormatETC();

        _pStgMed = new STGMEDIUM;
        if (_pStgMed == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto End;
        }

        *ppformatetc = &_formatetc;

        _pStgMed->tymed = TYMED_NULL;
        _pStgMed->hGlobal = NULL;
        _pStgMed->pUnkForRelease = 0;
        _pStgMed->pstm = NULL;
        fNewStgMed = TRUE;

    }

    ds = _ds;
    if( _fFileAsStmOnFile && _ds == DataSink_File )
    {
        ds = DataSink_StreamOnFile;
    } 
    
    switch (ds)
    {
    case DataSink_File:
    {
        //TransAssert((   (grfBSCF & ~BSCF_LASTDATANOTIFICATION)
        //             || ((grfBSCF & BSCF_LASTDATANOTIFICATION) && (_formatetc.tymed == TYMED_FILE)) ));

        if (_wzFileName[0] != 0)
        {
            TransAssert((_wzFileName[0] != 0));
            if (_pStgMed->tymed == TYMED_FILE)
            {
                if (_pStgMed->lpszFileName == NULL)
                {
                    _pStgMed->lpszFileName = (LPWSTR) new WCHAR [wcslen(_wzFileName)+2];
                    if (_pStgMed->lpszFileName)
                    {
                        wcscpy(_pStgMed->lpszFileName, _wzFileName);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        goto End;
                    }
                }
            }
            else
            {
                ASSERT(_pStgMed->tymed == TYMED_NULL);
                
                _pStgMed->tymed = TYMED_FILE;
                _pStgMed->lpszFileName = (LPWSTR) new WCHAR [wcslen(_wzFileName)+2];
                if (_pStgMed->lpszFileName)
                {
                    wcscpy(_pStgMed->lpszFileName, _wzFileName);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    goto End;
                }
                
            }

            if (_pStgMed->pUnkForRelease == NULL)
            {
                _pStgMed->pUnkForRelease = this;
            }

            hr = NOERROR;
            DbgLog1(tagCTransData, this, "+CTransData::GetData -> TYMED_FILE: %ws", _wzFileName);
        }
        else
        {
            // filename is not available yet
            hr = INET_E_DATA_NOT_AVAILABLE;
        }
    }
    break;

    case DataSink_GenericStream:
    case DataSink_StreamBindToObject:
    case DataSink_StreamNoCopyData:
    {
        DbgLog1(tagCTransData, this, "=== CTransData::GetData (_ds:%lx)", _ds);
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));

        if (_pStgMed->tymed == TYMED_NULL)
        {
            CReadOnlyStreamDirect *pCRoStm = new CReadOnlyStreamDirect( this, _grfBindF);

            if (pCRoStm)
            {
                _pStgMed->tymed = TYMED_ISTREAM;
                _pStgMed->pstm = pCRoStm;
                _pStgMed->pUnkForRelease = this;
                hr = NOERROR;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            DbgLog1(tagCTransData, this, "+CTransData::GetData -> TYMED_ISTREAM: %lx", pCRoStm);
        }
        else
        {
            hr = NOERROR;
        }

        DbgLog2(tagCTransData, this, "=== CTransData::GetData (_ds:%lx,pstm:%lx)", _ds,_pStgMed->pstm);
        DbgLog2(tagCTransData, this, "=== (_cbBufferFilled:%ld, _cbBufferSize:%ld)", _cbBufferFilled,_cbBufferSize);

    }
    break;

    case DataSink_StreamOnFile:
    {
        DbgLog1(tagCTransData, this, "=== CTransData::GetData (_ds:%lx)", _ds);
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));

        if (_wzFileName[0] != 0)
        {
            if (_pStgMed->tymed == TYMED_NULL)
            {
                if( _pStgMed->pstm )
                {
                    //BUG-BUG : relying on undocumented behavior of ReleaseStgMedium..
                    // may or may not zero this out in future.
                    _pStgMed->tymed = TYMED_ISTREAM;
                    _pStgMed->pUnkForRelease = this;

                    // When pStm gets created, the ctor set the ref count
                    // to 1, so no need any additional AddRef.
                    //
                    // Here we are not create a new pStm, we need to do an
                    // AddRef on the pStm because 
                    // CBinding::OnDataNotification (the only caller of this)
                    // will call ReleaseStgMedia() which will call 
                    // _pStgMeg->pstm->Release()

                    _pStgMed->pstm->AddRef();

                    hr = NOERROR;
                }
                else
                {
                    char szTempFile[MAX_PATH];
                    CReadOnlyStreamFile *pCRoStm = NULL;
                    W2A(_wzFileName, szTempFile, MAX_PATH);

                    hr = CReadOnlyStreamFile::Create(szTempFile, &pCRoStm, _pwzUrl);

                    if (pCRoStm)
                    {
                        _pStgMed->tymed = TYMED_ISTREAM;
                        _pStgMed->pstm = pCRoStm;
                        _pStgMed->pUnkForRelease = this;
                        hr = NOERROR;
                    }
                    else
                    {
                        // filename is not available yet
                        hr = INET_E_DATA_NOT_AVAILABLE;
                    }

                    DbgLog2(tagCTransData, this, "+CTransData::GetData -> TYMED_ISTREAM: %lx (hr:%lx)", pCRoStm,hr);
                }

            }
            else
            {
                TransAssert((_pStgMed->tymed == TYMED_ISTREAM));
                hr = NOERROR;
            }
        }
        else
        {
            DbgLog(tagCTransDataErr, this, "+CTransData::GetData ->StreamOnFile: no filename!");

            // filename is not available yet
            hr = INET_E_DATA_NOT_AVAILABLE;
        }

    }
    break;

    case DataSink_Storage:
    {
        DbgLog2(tagCTransData, this, "=== CTransData::GetData (_ds:%lx, _wzFileName:%ws)", _ds, _wzFileName);
        TransAssert((_formatetc.tymed == TYMED_ISTORAGE));

        TransAssert((_wzFileName != NULL));

        if (_wzFileName[0] != 0)
        {
            if (_pStgMed->tymed == TYMED_NULL)
            {
                IStorage *pStg = NULL;

                hr = StgOpenStorage(_wzFileName, NULL, STGM_READ | STGM_SHARE_DENY_WRITE, NULL, 0, &pStg );
                DbgLog1(tagCTransData, this, "+CTransData::GetData -> TYMED_ISTORAGE: %ws", _wzFileName);

                if (pStg)
                {
                    _pStgMed->tymed = TYMED_ISTORAGE;
                    _pStgMed->pstg = pStg;
                    _pStgMed->pUnkForRelease = this;
                    hr = NOERROR;
                }

                DbgLog2(tagCTransData, this, "+CTransData::GetData -> TYMED_ISTORAGE: %lx (hr:%lx)", pStg,hr);
            }
            else
            {
                TransAssert((_pStgMed->tymed == TYMED_ISTORAGE));
                hr = NOERROR;
            }
        }
        // else return default error
    }
    break;

    default:
        // this needs to be implemented
        TransAssert((FALSE && "CTransData::GetData -- Invalid data location"));
    break;
    }

    if (SUCCEEDED(hr) && _pStgMed)
    {
        // this object was addref on punkforrelease
        *ppStgMed = _pStgMed;
        *ppformatetc = &_formatetc;

        // Use ourselves as the unknown for release, so that the temp file
        // doesn't get removed when ReleaseStgMedium() is called.  We need
        // to AddRef ourselves to balance the Release that will occur.

        if (_pStgMed->pUnkForRelease)
        {
            AddRef();
            if (   _pProt 
                && fNewStgMed
                && SUCCEEDED(_pProt->LockRequest(0)) )
            {
                    _fLocked = TRUE;
            }
        }

        hr = NOERROR;

        TransAssert((_pStgMed->pUnkForRelease != NULL));
    }

End:
    PerfDbgLog1(tagCTransData, this, "-CTransData::GetData (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::ReadHere
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [cbBuffer] --
//              [pdwRead] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::ReadHere(LPBYTE pBuffer, DWORD cbBuffer, DWORD *pdwRead)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::ReadHere",
                "this=%#x, %#x, %#x, %#x",
                this, pBuffer, cbBuffer, pdwRead
                ));
                
    PerfDbgLog2(tagCTransData, this, "+CTransData::ReadHere (_ds:%lx,cbBuffer:%ld)", _ds,cbBuffer);
    HRESULT hr = NOERROR;

    switch (_ds)
    {
    case DataSink_StreamNoCopyData:
    case DataSink_StreamBindToObject:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
        BOOL fRead = TRUE;
        DWORD dwCopy = 0;
        DWORD dwCopyNew = 0;

        if (_cbBufferFilled)
        {
            fRead = FALSE;

            // copy data form the local buffer to the provide buffer
            if (cbBuffer < _cbBufferFilled)
            {
                dwCopy = cbBuffer;
                memcpy(pBuffer, _lpBuffer, cbBuffer);
                // move the memory to the front
                memcpy(_lpBuffer, _lpBuffer + cbBuffer, _cbBufferFilled - cbBuffer);
                _cbBufferFilled -= cbBuffer;
                hr = S_OK;
            }
            else if (cbBuffer == _cbBufferFilled)
            {
                dwCopy = _cbBufferFilled;
                memcpy(pBuffer, _lpBuffer, _cbBufferFilled);
                _cbBufferFilled = 0;
                hr = S_OK;
            }
            else
            {
                //
                // user buffer is greater than what is available in
                //
                dwCopy = _cbBufferFilled;
                memcpy(pBuffer, _lpBuffer, _cbBufferFilled);
                _cbBufferFilled = 0;
                fRead = TRUE;
                hr = E_PENDING;
            }
        }

        // now read from the wire
        if ((_cbBufferFilled == 0) && (fRead == TRUE))
        {
            // read data from our buffer
            if (_TransDataState == TransData_ProtoTerminated)
            {
                // download completed
                hr = (dwCopy) ? S_OK : S_FALSE;
            }
            else if (pBuffer && cbBuffer)
            {
                hr = _pProt->Read(pBuffer + dwCopy, cbBuffer - dwCopy, &dwCopyNew);
                _cbTotalBytesRead += dwCopyNew;
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }

        if (pdwRead)
        {
            *pdwRead = dwCopy + dwCopyNew;

            if (*pdwRead && (hr != E_PENDING))
            // some data in buffer
            {
                hr = S_OK;
            }
        }
    }
    break;

    case DataSink_StreamOnFile:
    {
        DbgLog(tagCTransData, this, "=== CTransData::ReadHere (_ds:DataSink_StreamNoCopyData)");
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
        TransAssert((pdwRead != NULL));

        // read data from our buffer
        if (_TransDataState == TransData_ProtoTerminated)
        {
            // download completed
            hr = S_FALSE;
        }
        else if (pBuffer && cbBuffer)
        {
            hr = _pProt->Read(pBuffer, cbBuffer, pdwRead);
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    break;

    case DataSink_File:
    {
        TransAssert((_formatetc.tymed == TYMED_FILE));

    }
    break;

    default:
        // this needs to be implemented
        hr = E_FAIL;
        TransAssert((FALSE && "CTransData::ReadHere -- Invalid data location"));
    break;
    }

    TransAssert((   (   (hr == S_FALSE && *pdwRead == 0)
                     || (hr == S_OK && *pdwRead != 0)
                     || (hr == E_PENDING)
                     || (hr == E_INVALIDARG)
                     || (hr == INET_E_DATA_NOT_AVAILABLE)
                     || (hr == INET_E_DOWNLOAD_FAILURE)
                    )
                 && "CTransData::ReadHere -- Invalid return code"));


    PerfDbgLog3(tagCTransData, this, "-CTransData::ReadHere (hr:%lx,cbBuffer:%ld,pdwRead:%ld)", hr,cbBuffer,*pdwRead);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-30-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::Seek",
                "this=%#x, %#x, %#x, %#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::Seek");
    HRESULT hr;

    hr = _pProt->Seek(dlibMove, dwOrigin,plibNewPosition);

    PerfDbgLog1(tagCTransData, this, "-CTransData::Seek (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::GetReadBuffer
//
//  Synopsis:
//
//  Arguments:  [ppBuffer] --
//              [pcbBytes] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::GetReadBuffer(BYTE **ppBuffer, DWORD *pcbBytes)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::GetReadBuffer",
                "this=%#x, %#x, %#x",
                this, ppBuffer, pcbBytes
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::GetReadBuffer");
    HRESULT hr;

    TransAssert((_cbBufferSize >= _cbBufferFilled));

    *ppBuffer = _lpBuffer + _cbBufferFilled;
    *pcbBytes = _cbBufferSize - _cbBufferFilled;

    hr = ((_cbBufferSize - _cbBufferFilled) > 0) ? NOERROR : E_FAIL;

    PerfDbgLog3(tagCTransData, this, "-CTransData::GetReadBuffer (pBuffer:%lx,size:%ld,hr:%lx)",
        *ppBuffer, *pcbBytes, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::OnDataInBuffer
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [cbBytesAvailable] --
//              [dwBytesTotal] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::OnDataInBuffer(BYTE *pBuffer, DWORD cbBytesRead, DWORD dwBytesTotal)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::OnDataInBuffer",
                "this=%#x, %#x, %#x, %#x",
                this, pBuffer, cbBytesRead, dwBytesTotal
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::OnDataInBuffer");
    HRESULT hr = NOERROR;

    _cbTotalBytesRead += cbBytesRead;
    _cbBufferFilled += cbBytesRead;

    PerfDbgLog1(tagCTransData, this, "-CTransData::OnDataInBuffer (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::OnDataReceived
//
//  Synopsis:
//
//  Arguments:  [cbBytesAvailable] --
//              [dwBytesTotalRead] --
//              [dwTotalSize] --
//
//  Returns:
//
//  History:    2-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::OnDataReceived(DWORD grfBSC, DWORD cbBytesAvailable, DWORD dwTotalSize, DWORD *pcbNewAvailable)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::OnDataReceived",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, grfBSC, cbBytesAvailable, dwTotalSize, pcbNewAvailable
                ));
                
    PerfDbgLog4(tagCTransData, this, "+CTransData::OnDataReceived (_ds:%s, grfBSC:%lx,  cbBytesAvailable:%ld, _cbTotalBytesRead:%ld)",
        GetDataSinkName(_ds), grfBSC, cbBytesAvailable, _cbTotalBytesRead);
    HRESULT hr = NOERROR;

    *pcbNewAvailable = cbBytesAvailable;
    _grfBSC |= grfBSC;

    switch (_ds)
    {
    case DataSink_StreamNoCopyData:
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));

    case DataSink_StreamBindToObject:
    {
        DWORD dwNewData = 0;
        TransAssert((_pProt && _cbDataSniffMin));

        // _cbTotalBytesRead = # of bytes read so far
        if (_cbTotalBytesRead < _cbDataSniffMin)
        {
            // no bytes read so far
            TransAssert((_cbTotalBytesRead < _cbDataSniffMin));
            // read data into buffer and report progess
            hr = _pProt->Read(_lpBuffer + _cbBufferFilled, _cbBufferSize - _cbBufferFilled, &dwNewData);
            _cbTotalBytesRead += dwNewData;
            _cbBufferFilled += dwNewData;

            // now check if this is docfile
            // if so download at least 2k
            if (!_fDocFile && _cbBufferFilled && (IsDocFile(_lpBuffer, _cbBufferFilled) == S_OK))
            {
                _fDocFile = TRUE;
                _cbDataSniffMin =  (dwTotalSize && dwTotalSize < DATASNIFSIZEDOCFILE_MIN) ? dwTotalSize : DATASNIFSIZEDOCFILE_MIN;
            }

            if ((hr == E_PENDING) && (_cbTotalBytesRead < _cbDataSniffMin))
            {
                // do not report anything - wait until we get more data
                // a request is pending at this time
                // need more data to sniff properly
                hr  = S_NEEDMOREDATA;
            }
            else if (hr == NOERROR || hr == E_PENDING)
            {
                TransAssert((_cbTotalBytesRead != 0));

                // report the data we have in the buffer or
                // the available #
                DWORD cbBytesReport =  (cbBytesAvailable > _cbTotalBytesRead) ? cbBytesAvailable : _cbTotalBytesRead + 1;

                if (dwTotalSize && ((cbBytesReport > dwTotalSize)))
                {
                    cbBytesReport =  dwTotalSize;
                }

               *pcbNewAvailable = cbBytesReport;
            }
        }
    }

    break;


    case DataSink_File:
    case DataSink_Storage:
    case DataSink_StreamOnFile:
    {
        DWORD dwNewData = 0;

        TransAssert((_pProt));

        if (_cbTotalBytesRead < _cbDataSniffMin)
        {
            _cbDataSniffMin =  (dwTotalSize && dwTotalSize < DATASNIFSIZEDOCFILE_MIN) ? dwTotalSize : DATASNIFSIZEDOCFILE_MIN;

            // read data into buffer and report progess
            hr = _pProt->Read(_lpBuffer + _cbBufferFilled, _cbBufferSize - _cbBufferFilled, &dwNewData);

            _cbTotalBytesRead += dwNewData;
            _cbBufferFilled += dwNewData;

            if ((hr == E_PENDING) && (_cbTotalBytesRead < _cbDataSniffMin))
            {
                // do not report anything - wait until we get more data
                // a request is pending at this time
                // need more data to sniff properly
                hr  = S_NEEDMOREDATA;
            }
            else if (hr == NOERROR || hr == E_PENDING)
            {
                TransAssert((_cbTotalBytesRead != 0));
            }
            *pcbNewAvailable = _cbTotalBytesRead;
        }

        // Note: read until pending or eof and report progress
        //       this is important to keep the download going
        if (hr == NOERROR)
        {
            // reset the buffer - don't overwrite sniffing data
            _cbBufferFilled = (_fMimeTypeVerified) ? 0 : _cbDataSniffMin;
            
            // bugbug: need special flag which indicates not to read if fully available
            //if (!(grfBSC & BSCF_DATAFULLYAVAILABLE))
            
            if (1)
            {
                //read as much data until S_OK or E_PENDING or error
                do
                {
                    hr = _pProt->Read(_lpBuffer + _cbBufferFilled, _cbBufferSize - _cbBufferFilled, &dwNewData);
                    _cbTotalBytesRead += dwNewData;

                } while (hr == NOERROR);

                // report available data
                if (hr == NOERROR || hr == E_PENDING)
                {
                    TransAssert((_cbTotalBytesRead != 0));
                }
                *pcbNewAvailable = (cbBytesAvailable > _cbTotalBytesRead) ? _cbTotalBytesRead : _cbTotalBytesRead;
            }
            else
            {
                TransAssert((dwTotalSize == cbBytesAvailable));
                *pcbNewAvailable = dwTotalSize;
            }

        }
    }
    break;

    default:
        TransAssert((FALSE && "CTransData::OnDataReceived -- Invalid data location"));
    break;
    }

    // cbBytesAvailable might be off be 1
    //TransAssert((cbBytesAvailable <= *pcbNewAvailable));

    PerfDbgLog1(tagCTransData, this, "-CTransData::OnDataReceived (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransData::OnStart
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-23-96   JohannP (Johann Posch)   Created
//
//  Notes:      TransData does not keep CINet alive
//              and will NOT call delete on it!
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::OnStart(IOInetProtocol *pCINet)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::OnStart",
                "this=%#x, %#x",
                this, pCINet
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCTransData, this, "+CTransData::OnStart");
    TransAssert((pCINet != NULL));

    if (_pProt)
    {
        _pProt->Release();
        _pProt = NULL;
    }

    switch (_ds)
    {
    case DataSink_StreamBindToObject:
    case DataSink_StreamNoCopyData:
    case DataSink_StreamOnFile:
    case DataSink_GenericStream:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
        // this point is not addref by CTransData
        TransAssert((_pProt == NULL));
        _pProt = pCINet;
    }
    break;

    case DataSink_Storage:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTORAGE));
        // this point is not addref by CTransData
        TransAssert((_pProt == NULL));
        _pProt = pCINet;
    }
    break;


    case DataSink_File:
    {
        TransAssert((_formatetc.tymed == TYMED_FILE));
        // this point is not addref by CTransData
        TransAssert((_pProt == NULL));
        _pProt = pCINet;
    }
    break;

    default:
        TransAssert((FALSE && "Invalid data location"));
    break;
    }

    if (_pProt)
    {
        _pProt->AddRef();
    }
    else
    {
        TransAssert((FALSE));
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::OnStart (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransData::OnTerminate
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::OnTerminate()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::OnTerminate",
                "this=%#x",
                this
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCTransData, this, "+CTransData::OnTerminate");

    TransAssert((_TransDataState < TransData_ProtoTerminated));

    switch (_ds)
    {

    case DataSink_Storage:
    case DataSink_File:
    {
        TransAssert((_formatetc.tymed == TYMED_FILE) || (_formatetc.tymed == TYMED_ISTORAGE));
        DbgLog2(tagCTransData, this, ">>> CTransData::OnTerminate (hr:%lx, _wzTempFile:%ws)", hr, _wzFileName);
    }
    break;

    case DataSink_StreamBindToObject:
    case DataSink_StreamNoCopyData:
    case DataSink_StreamOnFile:
    case DataSink_GenericStream:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
        TransAssert((_pProt != NULL));
    }
    break;
    default:
        TransAssert((FALSE && "Invalid data location"));
    break;
    }

    if (_pBndCtx)
    {
        _pBndCtx->Release();
        _pBndCtx = NULL;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::OnTerminate (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::FindFormatETC
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::FindFormatETC()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::FindFormatETC",
                "this=%#x",
                this
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog1(tagCTransData, this, "+CTransData::FindFormatETC (_cbBufferFilled:%ld)", _cbBufferFilled);

    _formatetc.ptd = NULL;
    _formatetc.dwAspect = DVASPECT_CONTENT;
    _formatetc.lindex = -1;

    _formatetc.cfFormat = 0;
    TransAssert((   _formatetc.tymed == TYMED_ISTREAM
                 || _formatetc.tymed == TYMED_FILE
                 || _formatetc.tymed == TYMED_ISTORAGE ));

    LPCWSTR pwzStrOrg = GetMimeType();
    LPCWSTR pwzStr = pwzStrOrg;

    // If not already done so, attempt to
    // verify mime type by examining data.
    if (!_fMimeTypeVerified)
    {
        DWORD dwFlags = 0;
        DWORD dwSniffFlags = 0;
        DWORD cbLen = sizeof(dwFlags);
        LPWSTR pwzFileName = GetFileName();
        LPWSTR pwzStrOut = 0;



        // the buffer should contain data if the no mime
        TransAssert((    (_cbBufferFilled == 0 && (pwzStr || pwzFileName))
                     ||  ( _cbBufferFilled != 0) ));

        FindMimeFromData(NULL, pwzFileName,_lpBuffer, _cbBufferFilled, pwzStrOrg, dwSniffFlags,  &pwzStrOut, 0);

        if (pwzStrOut)
        {
            SetMimeType(pwzStrOut);
            pwzStr = GetMimeType();
        }
        
        delete [] pwzStrOut;
        _fMimeTypeVerified = TRUE;
    }

    // the new mime should never be NULL if we had a proposed mime
    TransAssert((   (pwzStrOrg && pwzStr)
                 || (pwzStrOrg == NULL)     ));

    if (pwzStr)
    {
        char szMime[SZMIMESIZE_MAX];
        W2A(pwzStr, szMime, SZMIMESIZE_MAX);

        CLIPFORMAT cfType;
        if (FindMediaTypeW(pwzStr,&cfType) != NOERROR)
        {
            _formatetc.cfFormat = (CLIPFORMAT) RegisterClipboardFormat(szMime);
        }
        else
        {
            _formatetc.cfFormat = cfType;
        }
    }
    else
    {
        _formatetc.cfFormat = CF_NULL;
    }

    // Check if the format that we got is one of the format that
    // is requested, and if so, use it
#ifdef UNUSED
    if (_pEnumFE)
    {
        FORMATETC FmtetcT;
        BOOL fDone = FALSE;

        _pEnumFE->Reset();

        while (!fDone && ((hr = _pEnumFE->Next(1, &FmtetcT,NULL)) == NOERROR))
        {
            TransAssert((SUCCEEDED(hr)));

            if (FmtetcT.cfFormat == _cfFormat)
            {
                _formatetc.cfFormat = _cfFormat;
            }
        }
    }
#endif //UNUSED

    PerfDbgLog3(tagCTransData, this, "-CTransData::FindFormatETC (hr:%lx, szStr:%ws, _formatetc.cfFormat:%lx)", hr, pwzStr?pwzStr:L"", _formatetc.cfFormat);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::GetAcceptStr
//
//  Synopsis:
//
//  Arguments:  [ppwzStr] --
//              [pcElements] --
//
//  Returns:
//
//  History:    3-29-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::GetAcceptStr(LPWSTR *ppwzStr, ULONG *pcElements)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::GetAcceptStr",
                "this=%#x, %#x, %#x",
                this, ppwzStr, pcElements
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCTransData, this, "+CTransData::GetAcceptStr");
    IEnumFORMATETC *pIEnumFE = NULL;

    TransAssert((ppwzStr));
    TransAssert((*pcElements > 0));

    CHAR pszUnknownName[MAX_PATH];
    ULONG cMimes = 0;
    
    *ppwzStr = 0;
    hr = GetObjectParam(_pBndCtx, REG_ENUMFORMATETC, IID_IEnumFORMATETC, (IUnknown**)&pIEnumFE);

    if (hr == NOERROR)
    {
        BOOL fCF_NULL = FALSE;
        #define ELEMENTS 10
        ULONG cElementsIn = ELEMENTS;
        ULONG cElements = 0;
        FORMATETC rgFormatEtc[ELEMENTS];


        pIEnumFE->Reset();
        // find # of elements
        do
        {
            ULONG cEl = 0;
            hr = pIEnumFE->Next(cElementsIn, rgFormatEtc ,&cEl);
            cElements += cEl;
        } while (hr == S_OK);

        UrlMkAssert((cElements > 0));

        if  (   (cElements > 0)
             && (hr == S_OK || hr == S_FALSE))
        {

            {
                ULONG cElementsOut = 0;
                pIEnumFE->Reset();
                do
                {
                    ULONG cEl = 0;
                    FORMATETC *pFmtEtc = rgFormatEtc;

                    hr = pIEnumFE->Next(cElementsIn, rgFormatEtc ,&cEl);                    
                    cElementsOut += cEl;
                    // (hr==S_FALSE) => (cElementsOut==cEl)
                    UrlMkAssert((!(hr==S_FALSE) || (cElementsOut == cElements)));

                    // On the last call to ->Next() enumerator, we get back an S_FALSE
                    // if the # of elements received (cEl) < asked for (cElementsIn)
                    if ((cElementsOut == cElements) && (hr == S_FALSE))
                        hr = S_OK;

                    for (ULONG i = 0; i < cEl; i++)
                    {
                        if( cMimes >=  (*pcElements - 1)  )
                        {
                            // exceeding the income array size, stop
                            break;
                        }


                        LPSTR szFormat = NULL;
                        CLIPFORMAT  cfFormat = (pFmtEtc + i)->cfFormat;
                        if (cfFormat == CF_NULL)
                        {
                            fCF_NULL = TRUE;
                        }
                        else
                        {
                            hr = FindMediaString(cfFormat, &szFormat);
                            if (hr != NOERROR || !szFormat)
                            {
                                // unknown cfFormat
                                if( GetClipboardFormatName(cfFormat, pszUnknownName, MAX_PATH))
                                {
                                    hr = NOERROR;
                                    szFormat = pszUnknownName;
                                } 
                                else
                                {
                                    // word97 will send out cfFormat=1
                                    // which associated to "" string
                                    hr = NOERROR;
                                }
                            }
                            if( szFormat )
                            {

                                *(ppwzStr + cMimes)= NULL; 
                                *(ppwzStr + cMimes) = DupA2W(szFormat);
                                if( *(ppwzStr + cMimes) )
                                {
                                    cMimes++;
                                } 
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                    break;
                                }
                            }
                        }
                    }

                } while ( (cElementsOut < cElements) && (hr == NOERROR) );

                // append the cf_null (*/*)
                if( hr == NOERROR && (fCF_NULL || (cMimes == 0)) )
                {
                    *(ppwzStr + cMimes) = DupA2W(g_szCF_NULL);
                    if( !*(ppwzStr + cMimes) )
                    {
                        hr = E_OUTOFMEMORY;
                    } 
                    else
                    { 
                        cMimes++;
                        hr = NOERROR;
                    }
                }

                if( hr == NOERROR )
                {
                    *(ppwzStr + cMimes) = NULL;
                }
            }
        }

        pIEnumFE->Release();
    }
    else
    {
        {
            *ppwzStr = DupA2W(g_szCF_NULL);
            if( *ppwzStr )
            {
                cMimes = 1;
                *(ppwzStr + 1) = NULL;
                hr = NOERROR;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    if( hr == NOERROR )
    {
        *pcElements = cMimes;
    }
    else
    {
        *pcElements = 0;
        if( cMimes >= 1 )
        {
            for( ULONG i = 0; i < cMimes; i ++)
            {
                delete [] *(ppwzStr + i);
            }
        }
        *ppwzStr = NULL;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::GetAcceptStr (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::GetAcceptMimes
//
//  Synopsis:
//
//  Arguments:  [ppStr] --
//
//  Returns:
//
//  History:    3-29-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::GetAcceptMimes(LPWSTR *ppwzStr, ULONG cel, ULONG *pcElements)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::GetAcceptMimes",
                "this=%#x, %#x, %#x, %#x",
                this, ppwzStr, cel, pcElements
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCTransData, this, "+CTransData::GetAcceptMimes");

    TransAssert((ppwzStr && pcElements && *pcElements));

    if (ppwzStr && pcElements)
    {
        if( *pcElements > 1 )
        {
            hr = GetAcceptStr( ppwzStr, pcElements );
        }
        else if( *pcElements == 1)
        {
            // zero terminated 
            *ppwzStr = NULL;
        }
        else
        {
            hr =  E_INVALIDARG;
        }
    }
    else
    {
        hr =  E_INVALIDARG;
    }
    PerfDbgLog1(tagCTransData, this, "-CTransData::GetAcceptMimes (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransData::SetClipFormat
//
//  Synopsis:
//
//  Arguments:  [cfFormat] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::SetClipFormat(CLIPFORMAT  cfFormat)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::SetClipFormat",
                "this=%#x, %#x",
                this, cfFormat
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCTransData, this, "+CTransData::SetClipFormat");

    _cfFormat = cfFormat;

    PerfDbgLog1(tagCTransData, this, "-CTransData::SetClipFormat (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::IsObjectReady
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::IsObjectReady(  )
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::IsObjectReady",
                "this=%#x",
                this
                ));
                
    HRESULT hr = E_FAIL;
    PerfDbgLog(tagCTransData, this, "+CTransData::IsObjectReady");

    // check size and
    if ((_cbDataSize != 0) && (_cbDataSize == _cbTotalBytesRead))
    {
        hr = NOERROR;
    }

    PerfDbgLog3(tagCTransData, this, "-CTransData::IsObjectReady (hr:%lx, _cbDataSize:%ld, _cbTotalBytesRead:%ld)", hr, _cbDataSize, _cbTotalBytesRead);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::InProgress
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::InProgress()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::InProgress",
                "this=%#x",
                this
                ));
                
    HRESULT hr = S_FALSE;
    PerfDbgLog(tagCTransData, this, "+CTransData::InProgress");

    if (_grfBSC & (BSCF_LASTDATANOTIFICATION | BSCF_FIRSTDATANOTIFICATION))
    {
        hr = S_FALSE;
    }
    else if (_cbTotalBytesRead == 0)
    {
        // check if some bits already in the buffer

        hr = S_OK;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::InProgress (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::GetFileName
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPWSTR CTransData::GetFileName()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Pointer,
                "CTransData::GetFileName",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::GetFileName");
    LPWSTR pwzFileName = NULL;

    //TransAssert((_wzFileName[0] != 0));

    if (_wzFileName[0] != 0)
    {
        pwzFileName = _wzFileName;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::GetFileName (szFile:%ws)", pwzFileName?pwzFileName:L"");

    DEBUG_LEAVE(pwzFileName);
    return pwzFileName;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::GetClassID
//
//  Synopsis:
//
//  Arguments:  [pclsid] --
//              [fReOpen] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::GetClassID(CLSID clsidIn, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::GetClassID",
                "this=%#x, %#x, %#x",
                this, clsidIn, pclsid
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::GetClassID");
    WCHAR wzMime[SZMIMESIZE_MAX];
    HRESULT hr;
    LPWSTR pwzTempFile = NULL;

    DWORD fIgnoreMimeClsid = GetBindFlags() & BINDF_IGNOREMIMECLSID;
    LPCWSTR pwzMime = GetMimeType();

    pwzTempFile = GetFileName();

    if (   (_cbBufferFilled != 0)
             && (_cbTotalBytesRead <= _cbBufferSize)
             && (IsDocFile(_lpBuffer, _cbBufferFilled) == S_OK))
    {
        _fDocFile = TRUE;
        _fMimeTypeVerified = TRUE;

        // Storage file (docfile) case
        // GetClassFileOrMime takes care of class mapping
        hr = GetClassFileOrMime2(_pBndCtx, pwzTempFile, _lpBuffer, _cbBufferFilled, pwzMime, 0, pclsid, fIgnoreMimeClsid);
        if (hr != NOERROR)
        {
            // S_FALSE means keep downloading
            hr = S_FALSE;
        }
    }
    else
    {
        if (!_fMimeTypeVerified)
        {
            DWORD dwFlags = 0;
            DWORD dwSniffFlags = 0;
            DWORD cbLen = sizeof(dwFlags);

            LPWSTR  pwzStr = 0;
            FindMimeFromData(NULL, pwzTempFile, _lpBuffer, _cbBufferFilled, pwzMime, dwSniffFlags,  &pwzStr, 0);
            if (pwzStr)
            {
                SetMimeType(pwzStr);
            }
            _fMimeTypeVerified = TRUE;
            delete [] pwzStr;
        }

        hr = GetClassFileOrMime2(_pBndCtx, pwzTempFile, NULL, 0, pwzMime, 0, pclsid, fIgnoreMimeClsid);
    }

    #if DBG==1
    if (hr == NOERROR)
    {
        LPOLESTR pszStr;
        StringFromCLSID(*pclsid, &pszStr);
        DbgLog2(tagCTransData, this, "CTransData::GetClassID (file:%ws)(class:%ws)",
            pwzTempFile, pszStr);
        delete pszStr;
    }
    #endif

    PerfDbgLog1(tagCTransData, this, "-CTransData::GetClassID (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::SetMimeType
//
//  Synopsis:
//
//  Arguments:  [pszMime] --
//
//  Returns:
//
//  History:    2-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::SetMimeType(LPCWSTR pwzMime)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::SetMimeType",
                "this=%#x, %.80wq",
                this, pwzMime
                ));
                
    PerfDbgLog2(tagCTransData, this, "+CTransData::SetMimeType (OldMime:%ws; MimeStr:%ws)", _wzMime?_wzMime:L"", pwzMime?pwzMime:L"");
    HRESULT hr = NOERROR;

    if (pwzMime)
    {

        #if DBG_XXX
        if (pwzMime)
        {
            if (   !wcscmp(_wzMime, CFWSTR_MIME_HTML)
                || !wcscmp(_wzMime, CFWSTR_MIME_TEXT))
            {
                if (   !wcscmp(pwzMime, CFWSTR_MIME_RAWDATA)
                    || !wcscmp(pwzMime,L"application/octet-stream"))
                {
                    DbgLog2(tagCTransDataErr, "=== SetMimeType: OldMime:%ws, NewMime:%ws",
                        _wzMime, pwzMime);
                    //TransAssert((FALSE));
                }
            }
        }

        if (_wzMime[0] != 0 && strcmp(_wzMime,pwzMime))
        {
            DbgLog2(tagTransDataErr, "=== SetMimeType: OldMime:%s, NewMime:%s",
                _wzMime, pwzMime);
        }

        #endif //DBG


        DWORD cLen = wcslen((LPWSTR)pwzMime);

        if (cLen >= SZMIMESIZE_MAX)
        {
            cLen = SZMIMESIZE_MAX - 1;
            wcsncpy(_wzMime, (LPWSTR)pwzMime, cLen);
            _wzMime[cLen] = 0;
        }
        else
        {
            wcscpy(_wzMime, (LPWSTR)pwzMime);
        }
    }
    else
    {
        DbgLog(tagCTransDataErr, this, "CTransData::SetMimeType ->invalid mime");
    }

    PerfDbgLog2(tagCTransData, this, "-CTransData::SetMimeType (hr:%lx, Mime:%ws)", hr,_wzMime?_wzMime:L"");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::SetFileName
//
//  Synopsis:
//
//  Arguments:  [szFile] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::SetFileName(LPWSTR pwzFile)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::SetFileName",
                "this=%#x, %.80wq",
                this, pwzFile
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::SetFileName");

    TransAssert((pwzFile));
    if(pwzFile)
    {
        wcscpy(_wzFileName, pwzFile);
    }

    PerfDbgLog2(tagCTransData, this, "-CTransData::SetFileName (_wzFileName:%ws, hr:%lx)", _wzFileName?_wzFileName:L"", NOERROR);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::GetMimeType
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    4-24-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPCWSTR CTransData::GetMimeType()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Pointer,
                "CTransData::GetMimeType",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::GetMimeType");
    LPWSTR pwzStr = NULL;

    if (_wzMime[0] != 0)
    {
        pwzStr = _wzMime;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::GetMimeType (pStr:%ws)", pwzStr?pwzStr:L"");

    DEBUG_LEAVE(pwzStr);
    return pwzStr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransData::OnEndofData()
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    7-30-97   DanpoZ(Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CTransData::OnEndofData()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                None,
                "CTransData::OnEndofData",
                "this=%#x",
                this
                ));
                
    PerfDbgLog1(tagCTransData, this, "+CTransData::OnEndofData(_ds:%ld)", _ds);
    BOOL fNewStgMed = FALSE;

    if (_pStgMed  && _ds == DataSink_StreamOnFile && _pStgMed->pstm )
    {
        ((CReadOnlyStreamFile*)(_pStgMed->pstm))->SetDataFullyAvailable();
    }

    PerfDbgLog(tagCTransData, this, "-CTransData::OnEndofData");

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\urlmarsh.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       urlmarsh.cxx
//
//  Contents:   CUrlMarshal methods implementations
//              to support custom marshaling
//
//  Classes:
//
//  Functions:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#include "urlmk.hxx"

PerfDbgTag(tagCUrlMarsh, "Urlmon", "Log CUrlMon Marshalling", DEB_URLMON);

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::CanMarshalIID
//
//  Synopsis:   Checks whether this object supports marshalling this IID.
//
//  Arguments:  [riid] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
inline BOOL CUrlMon::CanMarshalIID(REFIID riid)
{
    DEBUG_ENTER((DBG_MONIKER,
                Bool,
                "CUrlMon::CanMarshalIID",
                "this=%#x, %#x",
                this, &riid
                ));
                
    // keep this in sync with the QueryInterface
    BOOL fRet = (BOOL) (riid == IID_IMoniker);

    DEBUG_LEAVE(fRet);
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::ValidateMarshalParams
//
//  Synopsis:   Validates the standard set parameters that are passed into most
//              of the IMarshal methods
//
//  Arguments:  [riid] --
//              [pvInterface] --
//              [dwDestContext] --
//              [pvDestContext] --
//              [mshlflags] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CUrlMon::ValidateMarshalParams(REFIID riid,void *pvInterface,
                    DWORD dwDestContext,void *pvDestContext,DWORD mshlflags)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::ValidateMarshalParams",
                "this=%#x, %#x, %#x, %#x, %#x, %#x",
                this, &riid, pvInterface, dwDestContext, pvDestContext, mshlflags
                ));

    PerfDbgLog(tagCUrlMarsh, this, "+CUrlMon::ValidateMarshalParams");
    HRESULT hr = NOERROR;
 
    if (CanMarshalIID(riid))
    {
        UrlMkAssert((dwDestContext == MSHCTX_INPROC || dwDestContext == MSHCTX_LOCAL || dwDestContext == MSHCTX_NOSHAREDMEM));
        UrlMkAssert((mshlflags == MSHLFLAGS_NORMAL || mshlflags == MSHLFLAGS_TABLESTRONG));

        if (   (dwDestContext != MSHCTX_INPROC && dwDestContext != MSHCTX_LOCAL && dwDestContext != MSHCTX_NOSHAREDMEM)
            || (mshlflags != MSHLFLAGS_NORMAL && mshlflags != MSHLFLAGS_TABLESTRONG))
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    PerfDbgLog1(tagCUrlMarsh, this, "-CUrlMon::ValidateMarshalParams (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
// IMarshal methods
//
//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::GetUnmarshalClass
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [pvInterface] --
//              [dwDestContext] --
//              [pvDestContext] --
//              [mshlflags] --
//              [pCid] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::GetUnmarshalClass(REFIID riid,void *pvInterface,
        DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,CLSID *pCid)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMarshal::GetUnmarshalClass",
                "this=%#x, %#x, %#x, %#x, %#x, %#x, %#x",
                this, &riid, pvInterface, dwDestContext, pvDestContext, mshlflags, pCid
                ));
                
    HRESULT hr;
    PerfDbgLog(tagCUrlMarsh, this, "+CUrlMon::GetUnmarshalClass");

    hr = ValidateMarshalParams(riid, pvInterface, dwDestContext,pvDestContext, mshlflags);
    if (hr == NOERROR)
    {
        *pCid = (CLSID) CLSID_StdURLMoniker;
    }

    PerfDbgLog1(tagCUrlMarsh, this, "-CUrlMon::GetUnmarshalClass (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::GetMarshalSizeMax
//
//  Synopsis:
//
//  Arguments:  [void] --
//              [pvInterface] --
//              [dwDestContext] --
//              [pvDestContext] --
//              [mshlflags] --
//              [pSize] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::GetMarshalSizeMax(REFIID riid,void *pvInterface,
        DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,DWORD *pSize)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMarshal::GetMarshalSizeMax",
                "this=%#x, %#x, %#x, %#x, %#x, %#x, %#x",
                this, &riid, pvInterface, dwDestContext, pvDestContext, mshlflags, pSize
                ));
                
    HRESULT hr;
    PerfDbgLog(tagCUrlMarsh, this, "+CUrlMon::GetMarshalSizeMax");

    if (pSize == NULL)
    {
        hr = E_INVALIDARG;

    }
    else
    {

        hr = ValidateMarshalParams(riid, pvInterface, dwDestContext,pvDestContext, mshlflags);
        if (hr == NOERROR)
        {

            // size of url + extra info
            *pSize = (wcslen(_pwzUrl) + 1) * sizeof(WCHAR) + sizeof(ULONG);
            // Note: add state info

        }
    }

    PerfDbgLog1(tagCUrlMarsh, this, "-CUrlMon::GetMarshalSizeMax (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::MarshalInterface
//
//  Synopsis:
//
//  Arguments:  [REFIID] --
//              [riid] --
//              [DWORD] --
//              [void] --
//              [DWORD] --
//              [mshlflags] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::MarshalInterface(IStream *pistm,REFIID riid,
                                void *pvInterface,DWORD dwDestContext,
                                void *pvDestContext,DWORD mshlflags)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMarshal::MarshalInterface",
                "this=%#x, %#x, %#x, %#x, %#x, %#x, %#x",
                this, pistm, &riid, pvInterface, dwDestContext, pvDestContext, mshlflags
                ));
                
    HRESULT hr;
    PerfDbgLog(tagCUrlMarsh, this, "+CUrlMon::MarshalInterface");

    hr = ValidateMarshalParams(riid, pvInterface, dwDestContext,pvDestContext, mshlflags);
    if (hr == NOERROR)
    {
        hr = Save(pistm, FALSE);
    }

    PerfDbgLog1(tagCUrlMarsh, this, "-CUrlMon::MarshalInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::UnmarshalInterface
//
//  Synopsis:   Unmarshals an Urlmon interface out of a stream
//
//  Arguments:  [REFIID] --
//              [void] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::UnmarshalInterface(IStream *pistm,REFIID riid,void ** ppvObj)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMarshal::UnmarshalInterface",
                "this=%#x, %#x, %#x, %#x",
                this, pistm, &riid, ppvObj
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCUrlMarsh, this, "+CUrlMon::UnmarshalInterface");

    if (ppvObj == NULL)
    {
        hr = E_INVALIDARG;
    }
    else if (! CanMarshalIID(riid))
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    else
    {
        *ppvObj = NULL;

        hr = Load(pistm);

        // call QI to get the requested interface
        if (hr == NOERROR)
        {
            hr = QueryInterface(riid, ppvObj);
        }
    }

    PerfDbgLog1(tagCUrlMarsh, this, "-CUrlMon::UnmarshalInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CUrlMon::ReleaseMarshalData(IStream *pStm)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMarshal::ReleaseMarshalData",
                "this=%#x, %#x",
                this, pStm
                ));
                
    PerfDbgLog(tagCUrlMarsh, this, "+CUrlMon::ReleaseMarshalData");
    PerfDbgLog1(tagCUrlMarsh, this, "-CUrlMon::ReleaseMarshalData (hr:%lx)", NOERROR);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

STDMETHODIMP CUrlMon::DisconnectObject(DWORD dwReserved)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMarshal::DisconnectObject",
                "this=%#x, %#x",
                this, dwReserved
                ));
                
    PerfDbgLog(tagCUrlMarsh, this, "+CUrlMon::DisconnectObject");
    PerfDbgLog1(tagCUrlMarsh, this, "-CUrlMon::DisconnectObject (hr:%lx)", NOERROR);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::GetComparisonData
//
//  Synopsis:
//
//  Arguments:  [pbData] --
//              [cbMax] --
//              [pcbData] --
//
//  Returns:
//
//  History:    1-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::GetComparisonData(byte *pbData, ULONG cbMax, ULONG *pcbData)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IROTData::GetComparisonData",
                "this=%#x, %#x, %#x, %#x",
                this, pbData, cbMax, pcbData
                ));
                
    PerfDbgLog(tagCUrlMarsh, this, "+CUrlMon::GetComparisonData");
    HRESULT hr = NOERROR;

    if (pbData == NULL || pcbData == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {

        UrlMkAssert((_pwzUrl != NULL));

        *pcbData = (wcslen(_pwzUrl) + 1)  * sizeof(WCHAR);
        if (*pcbData > cbMax)
        {
            hr = E_FAIL;
        }
        else
        {
            wcscpy((WCHAR*)pbData,_pwzUrl);
        }
    }

    PerfDbgLog1(tagCUrlMarsh, this, "-CUrlMon::GetComparisonData (hr:%lx)", hr);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\urlhlink\hlinkez.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       hlinkez.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//              5-15-96   Ramesh G -  Major modifications
//              5-17-96   Ramesh G -  Added Frames support
//                        Ramesh G -  Modified variable names to Hungarian Notation
//              6-19-96   Ramesh G -  Modifications
//              7-25-96   Ramesh G -  Modifications
//                              8-05-96   Ramesh G -  Merged HlinkSimple...String() and Moniker()
//                                                                        HlinkSimpleNavigateToString() creates the moniker
//                                                                        and calls HlinkSimpleNavigateToMoniker()
//----------------------------------------------------------------------------
#define USE_SYSTEM_URL_MONIKER
#define INITGUID
#define STR_SIZE        20

#include "hlink.h"
#include "ocidl.h"
#include "docobj.h"
#include "exdisp.h"
#include "shellapi.h"
#include "servprov.h"
#include "urlhlink.h"
#include "htiface.h"
#include "wininet.h"
#include <shlwapi.h>
#include <shlwapip.h>
#include <mshtml.h>
#include "mshtmdid.h"
#include <delaydll.h>
#include "sdll.hxx"

#ifndef GUID_NULL
struct __declspec(uuid("00000000-0000-0000-0000-000000000000")) GUID_NULL;
#define GUID_NULL __uuidof(struct GUID_NULL)
#endif

class HLinkDll
{
public:
    HLinkDll();
        HRESULT HlinkCreateFromMoniker(
                                IMoniker* pmkSource,
                                LPCWSTR szLocation,
                                LPCWSTR szFriendlyName,
                                IHlinkSite* phlSite,
                                DWORD dwSiteData,
                                IUnknown* punkOuter,
                                REFIID riid,
                                void** ppv);
private:

    BOOL LoadFunc( LPCSTR lpProcName, FARPROC & fp );
    typedef HRESULT (STDAPICALLTYPE * LPFNHlinkCreateFromMoniker)(
                                IMoniker* pmkSource,
                                LPCWSTR szLocation,
                                LPCWSTR szFriendlyName,
                                IHlinkSite* phlSite,
                                DWORD dwSiteData,
                                IUnknown* punkOuter,
                                REFIID riid,
                                void** ppv);
    LPFNHlinkCreateFromMoniker m_lpfnHlinkCreateFromMoniker;

    HMODULE m_hmodule;
    BOOL    m_error;

};

inline HRESULT HLinkDll::HlinkCreateFromMoniker(
                                IMoniker* pmkSource,
                                LPCWSTR szLocation,
                                LPCWSTR szFriendlyName,
                                IHlinkSite* phlSite,
                                DWORD dwSiteData,
                                IUnknown* punkOuter,
                                REFIID riid,
                                void** ppv)
{

    if( !LoadFunc("HlinkCreateFromMoniker",*(FARPROC*)&m_lpfnHlinkCreateFromMoniker) )
        return(E_FAIL);

     return m_lpfnHlinkCreateFromMoniker(
                                pmkSource,
                                szLocation,
                                szFriendlyName,
                                phlSite,
                                dwSiteData,
                                punkOuter,
                                riid,
                                ppv);
}


HLinkDll::HLinkDll()
{
    m_hmodule = 0;
    m_error = 0;
    m_lpfnHlinkCreateFromMoniker = 0;
}

#if 0
HLinkDll::~HLinkDll()
{
    if( m_hmodule )
        ::FreeLibrary( m_hmodule );
}
#endif

BOOL HLinkDll::LoadFunc( LPCSTR lpProcName, FARPROC & fp )
{
    if( m_error )
        return(0);

    if( fp )
        return(1);

    if( !m_hmodule )
    {
        m_hmodule = ::LoadLibrary( "HLINK.DLL" );

        if( !m_hmodule )
        {
           m_error = 1;
           return(0);
        }

    }

    fp = ::GetProcAddress( m_hmodule, lpProcName );

    return( fp != 0 );
}

static HLinkDll hlink;


//////////////////
static int wclen(LPCWSTR szStr)
{
    int cbStr=0;
    if(szStr!=NULL)
        while(szStr[cbStr]!=NULL)
            ++cbStr;

    return cbStr;
}

////////////////////////////

static HRESULT GetAnInterface
(
    IUnknown    *   punk,
    const IID &     riid,
    void **         pout,

    BOOL            bCheckServiceProvider,
    const IID &     siid,
    const IID &     siid_riid,
    void **         sout
)
{
    IOleObject *      oleObj    = 0;
    IOleClientSite *  oleSite   = 0;
    IOleContainer *   container = 0;
    IUnknown *        service   = 0;

    HRESULT           hr = E_FAIL;

    // Initialize passed in interface pointers: calling code assumes NULL for failure
    if(pout)
            *pout = NULL;
    if(sout)
            *sout = NULL;

    if(punk)
            hr = punk->QueryInterface( IID_IOleObject, (void **)&oleObj );

    // BUBUG: I think this returns a wrong hr if QS fails but the QI passes - jp
    while( SUCCEEDED(hr) && oleObj )
    {
            if( oleSite )
            {
                    //oleSite->Release();
                    oleSite = 0;
            }

            hr = oleObj->GetClientSite(&oleSite);

            if( FAILED(hr) || !oleSite)
                    break;

            if( bCheckServiceProvider)
            {
                    IServiceProvider * servProv;

                    hr = oleSite->QueryInterface( IID_IServiceProvider, (void**)&servProv);

                    if( SUCCEEDED(hr) )
                    {
                            hr = servProv->QueryService
                                                                    (
                                                                            siid,
                                                                            siid_riid,
                                                                            (void **)&service
                                                                    );

                            servProv->Release();
                    }

                    if( SUCCEEDED(hr) )
                    {
                            bCheckServiceProvider = FALSE;

                            hr = service->QueryInterface( riid, pout );
                    }

                    if( SUCCEEDED(hr) )
                            break;

            }

            if( container )
            {
                    container->Release();
                    container = 0;
            }

            hr = oleSite->GetContainer( &container );

            if( FAILED(hr) )
                    break;

            hr = container->QueryInterface( riid, pout );

            if( SUCCEEDED(hr) )
                    break;

            oleObj->Release();
            oleObj = 0;

            hr = container->QueryInterface( IID_IOleObject, (void**)&oleObj );

    }

    if( oleSite )
    {
        oleSite->Release();
        oleSite = 0;
    }

    if( oleObj )
        oleObj->Release();

    if( container )
        container->Release();

    if( service )
    {
        if (sout)
            *sout = service;
        else
            service->Release();
    }

    return( hr );
}

//
//  GetUrlScheme() returns one of the URL_SCHEME_* constants as
//  defined in shlwapip.h
//  example "http://foo" returns URL_SCHEME_HTTP
//
static DWORD GetUrlSchemeW(IN LPCWSTR pcszUrl)
{
    if(pcszUrl)
    {
        PARSEDURLW pu;
        pu.cbSize = sizeof(pu);
        if(SUCCEEDED(ParseURLW(pcszUrl, &pu)))
            return pu.nScheme;
    }
    return URL_SCHEME_INVALID;
}

//
//  GetUrlScheme() returns one of the URL_SCHEME_* constants as
//  defined in shlwapip.h
//  example "http://foo" returns URL_SCHEME_HTTP
//
static DWORD GetUrlSchemeA(IN LPCSTR pcszUrl)
{
    if(pcszUrl)
    {
        PARSEDURLA pu;
        pu.cbSize = sizeof(pu);
        if(SUCCEEDED(ParseURLA(pcszUrl, &pu)))
            return pu.nScheme;
    }
    return URL_SCHEME_INVALID;
}

HRESULT DoUrlShellExecuteA(LPCSTR pszUrl)
{
    CShellDll sdll;
    HINSTANCE hInst = NULL;

    if(S_OK == sdll.Init())
    {
        UINT uProt = GetUrlSchemeA(pszUrl);

        switch (uProt)
        {
            case URL_SCHEME_HTTP:
            case URL_SCHEME_HTTPS:
            case URL_SCHEME_FTP:
            case URL_SCHEME_FILE:
                hInst = sdll.ShellExecute(
                    NULL, NULL, pszUrl, 
                    NULL, NULL, SW_SHOWNORMAL );
                break;

            //  Non-standard protocols go here:
            default:
                hInst = sdll.ShellExecute(
                    NULL, "open", "iexplore.exe", 
                    pszUrl, NULL, SW_SHOWNORMAL );
        }
    }

    return ((ULONG_PTR)hInst > 32) ? S_OK : E_FAIL;
}



BOOL IsSpecialUrl(WCHAR *pchURL)
{
    UINT      uProt;
    uProt = GetUrlSchemeW(pchURL);
    return (URL_SCHEME_JAVASCRIPT == uProt || 
            URL_SCHEME_VBSCRIPT == uProt ||
            URL_SCHEME_ABOUT == uProt);
}

HRESULT WrapSpecialUrlFlat(LPWSTR pszUrl, DWORD cchUrl)
{
    HRESULT     hr = S_OK;

    if (IsSpecialUrl(pszUrl))
    {
        //
        // If this is javascript:, vbscript: or about:, append the
        // url of this document so that on the other side we can
        // decide whether or not to allow script execution.
        //

        // QFE 2735 (Georgi XDomain): [alanau]
        //
        // If the special URL contains an %00 sequence, then it will be converted to a Null char when
        // encoded.  This will effectively truncate the Security ID.  For now, simply disallow this
        // sequence, and display a "Permission Denied" script error.
        //
        if (StrStrW(pszUrl, L"%00"))
        {
            hr = E_ACCESSDENIED;
        }
        else
        {
            // munge the url in place
            //

            // someone could put in a string like this:
            //     %2501 OR %252501 OR %25252501
            // which, depending on the number of decoding steps, will bypass security
            // so, just keep decoding while there are %s and the string is getting shorter
            int nPreviousLen = 0;
            while ( (nPreviousLen != lstrlenW(pszUrl)) && (StrChrW(pszUrl, L'%')))
            {
                nPreviousLen = lstrlenW(pszUrl);
                int nNumPercents;
                int nNumPrevPercents = 0;

                // Reduce the URL
                //
                for (;;)
                {
                    // Count the % signs.
                    //
                    nNumPercents = 0;

                    WCHAR *pch = pszUrl;
                    while (pch = StrChrW(pch, L'%'))
                    {
                        pch++;
                        nNumPercents++;
                    }

                    // If the number of % signs has changed, we've reduced the URL one iteration.
                    //
                    if (nNumPercents != nNumPrevPercents)
                    {
                        WCHAR szBuf[INTERNET_MAX_URL_LENGTH];
                        DWORD dwSize;

                        // Encode the URL 
                        hr = CoInternetParseUrl(pszUrl, 
                            PARSE_ENCODE, 
                            0,
                            szBuf,
                            INTERNET_MAX_URL_LENGTH,
                            &dwSize,
                            0);

                        StrCpyNW(pszUrl, szBuf, cchUrl);

                        nNumPrevPercents = nNumPercents;
                    }
                    else
                    {
                        // The URL is fully reduced.  Break out of loop.
                        //
                        break;
                    }
                }
            }

            // Now scan for '\1' characters.
            //
            if (StrChrW(pszUrl, L'\1'))
            {
                // If there are '\1' characters, we can't guarantee the safety.  Put up "Permission Denied".
                //
                hr = E_ACCESSDENIED;
            }
        }
    }

    return hr;
}


static HRESULT GetAMoniker
(
     IUnknown *                         pUnk,
     LPCWSTR                            szTarget,
     IMoniker * *                       ppMoniker
)
{
   HRESULT hr;
   IBindHost * pBindHost = 0;

   hr = GetAnInterface
       (
           pUnk,
           IID_IBindHost,
           (void**)&pBindHost,
           TRUE,
           IID_IBindHost,
           IID_IBindHost,
           NULL
       );

   if( pBindHost )
   {
      hr = pBindHost->CreateMoniker((LPWSTR)szTarget,NULL,ppMoniker,0);
          pBindHost->Release();
   }
   else
      hr = ::CreateURLMoniker(0,szTarget,ppMoniker);

   return(hr);
}


STDAPI HlinkSimpleNavigateToString
(
    /* [in] */ LPCWSTR  szTarget,      // required - target document - null if local jump w/in doc
    /* [in] */ LPCWSTR  szLocation,    // optional, for navigation into middle of a doc
    /* [in] */ LPCWSTR  szTargetFrame,   // optional, for targeting frame-sets
    /* [in] */ IUnknown *pUnk,         // required - we'll search this for other necessary interfaces
    /* [in] */ IBindCtx *pBndctx,          // optional. caller may register an IBSC in this
    /* [in] */ IBindStatusCallback * pBscb,
    /* [in] */ DWORD    grfHLNF,       // flags (TBD - HadiP needs to define this correctly?)
    /* [in] */ DWORD    dwReserved     // for future use, must be NULL
)
{
    IWebBrowserApp  *pExplorer = 0;
    IHlinkFrame     *pHlframe  = 0;
    ITargetFrame    *pTargetFrame = 0;
        IMoniker            *pMoniker = 0;

    HRESULT         hr = S_OK;

    if ( szTarget && *szTarget )
        hr = GetAMoniker( pUnk, szTarget, &pMoniker );

        if ( SUCCEEDED(hr) )
                hr = HlinkSimpleNavigateToMoniker (
                           pMoniker,
                           szLocation,
                           szTargetFrame,
                           pUnk,
                           pBndctx,
                           pBscb,
                           grfHLNF,
                           dwReserved );

        if ( pMoniker )
                pMoniker->Release();

    return( hr );

}

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

BOOL AccessAllowed(LPCWSTR pwszURL1, LPCWSTR pwszURL2)
{
    BOOL fRet = FALSE;
    IInternetSecurityManager *pSecMgr = NULL;

    if (pwszURL1 && pwszURL2)
    {
        if (StrCmpW(pwszURL1, pwszURL2) == 0)
        {
            // No need to check if URLs are the same
            fRet = TRUE;
        }
        else if (SUCCEEDED(CoCreateInstance(CLSID_InternetSecurityManager, 
                                            NULL, 
                                            CLSCTX_INPROC_SERVER,
                                            IID_IInternetSecurityManager, 
                                            (void **)&pSecMgr)))
        {
            BYTE reqSid[MAX_SIZE_SECURITY_ID], docSid[MAX_SIZE_SECURITY_ID];
            DWORD cbReqSid = ARRAYSIZE(reqSid);
            DWORD cbDocSid = ARRAYSIZE(docSid);

            if (   SUCCEEDED(pSecMgr->GetSecurityId(pwszURL1, reqSid, &cbReqSid, 0))
                && SUCCEEDED(pSecMgr->GetSecurityId(pwszURL2, docSid, &cbDocSid, 0))
                && (cbReqSid == cbDocSid)
                && (memcmp(reqSid, docSid, cbReqSid) == 0))                    
            {
                fRet = TRUE;
            }
            pSecMgr->Release();
        }
    }
    return fRet;
}

BOOL AccessAllowed(ITargetFrame* pSrcFrame, IHlinkFrame* pTargetFrame)
{
    IDispatch*          pdisp[2] = {0};
    IServiceProvider*   pIsp[2] = {0};
    DISPPARAMS          dp;
    VARIANT             VarUrl[2];
    UINT                uiErr;
    BOOL                fRet = FALSE;
    HRESULT             hr;
    int                 idx;

    if(!pTargetFrame || !pSrcFrame)
    {        
        goto cleanup;
    }

    hr = pTargetFrame->QueryInterface(IID_IServiceProvider, (LPVOID *)&pIsp[0]);

    if(hr)
        goto cleanup;

    hr = pSrcFrame->QueryInterface(IID_IServiceProvider, (LPVOID *)&pIsp[1]);

    if(hr)
        goto cleanup;

    VariantInit(&VarUrl[0]);
    VariantInit(&VarUrl[1]);

    for (idx = 0; idx < 2; idx++)
    {
        hr = pIsp[idx]->QueryService(IID_IHTMLWindow2, IID_IDispatch, (LPVOID *)&pdisp[idx]);

        if(hr)
        {
            hr = pIsp[idx]->QueryService(IID_IWebBrowserApp, IID_IDispatch, (LPVOID *)&pdisp[idx]);
        }

        if(hr)
            goto cleanup;

        ZeroMemory((PVOID)&dp, sizeof(dp));

        hr = pdisp[idx]->Invoke(
                    DISPID_SECURITYCTX, 
                    IID_NULL, 
                    LOCALE_SYSTEM_DEFAULT, 
                    DISPATCH_PROPERTYGET,
                    &dp, 
                    &VarUrl[idx], 
                    NULL, 
                    &uiErr);
    
        if(hr)
            goto cleanup;

        if (V_VT(&VarUrl[idx]) != VT_BSTR || !V_BSTR(&VarUrl[idx]))
        {
            goto cleanup;
        }

        if (hr)
            goto cleanup;
    }

    fRet = AccessAllowed(V_BSTR(&VarUrl[0]), V_BSTR(&VarUrl[1]));

cleanup:
    for (idx = 0; idx < 2; idx++)
    {
        if(pdisp[idx])
            pdisp[idx]->Release();
        if(pIsp[idx])
            pIsp[idx]->Release();

        VariantClear(&VarUrl[idx]);
    }
    return fRet;
}



STDAPI HlinkSimpleNavigateToMoniker
(
    /* [in] */ IMoniker *pmkTarget,    // required - target document - (may be null if local jump w/in doc)
    /* [in] */ LPCWSTR  szLocation,    // optional, for navigation into middle of a doc
    /* [in] */ LPCWSTR  szTargetFrame, // optional, for targeting frame-sets
    /* [in] */ IUnknown *pUnk,         // required - we'll search this for other necessary interfaces
    /* [in] */ IBindCtx *pBndctx,      // optional. caller may register an IBSC in this
    /* [in] */ IBindStatusCallback * pBscb,
    /* [in] */ DWORD    grfHLNF,       // flags
    /* [in] */ DWORD    dwReserved     // for future use, must be NULL
)
{
    IWebBrowserApp * pExplorer = 0;
    IHlinkFrame *   pHlframe  = 0;
    ITargetFrame *  pTargetFrameSrc = 0;
    CShellDll       sdll;
    LPWSTR pszUrl = NULL;

    HRESULT         hr, htemp;

    if (pmkTarget == NULL)
    {
         if (szLocation &&  *szLocation)
         {
              grfHLNF |= HLNF_INTERNALJUMP;
              hr = S_OK;
         }
         else
              return E_INVALIDARG; //no location specified for internal jump
    }
    else
    {
        DWORD dwId;

        if (SUCCEEDED(pmkTarget->IsSystemMoniker(&dwId)) &&
            MKSYS_URLMONIKER == dwId)
        {

            if (SUCCEEDED(pmkTarget->GetDisplayName(NULL, NULL, &pszUrl)))
            {
                HRESULT hrSecure = WrapSpecialUrlFlat(pszUrl, lstrlenW(pszUrl) + 1);
                

                if (FAILED(hrSecure))
                {
                    CoTaskMemFree(pszUrl);
                    return hrSecure;
                }
            }
        }
    }

    if (pUnk)
        hr = GetAnInterface
              (
               pUnk,
               IID_IWebBrowserApp,
               (void**)&pExplorer,
               TRUE,
               IID_IHlinkFrame,
               IID_IHlinkFrame,
               (void**)&pHlframe
              );

    IHlink * pLink = 0;

    hr = hlink.HlinkCreateFromMoniker
              (
               pmkTarget,
               szLocation,
               L"TheName",
               0, // hlsite,
               0, NULL,
               IID_IHlink,
               (void**)&pLink
              );

    if (SUCCEEDED(hr) && pHlframe)
    {
        BOOL fAccessAllowed = TRUE;

         if (szTargetFrame && *szTargetFrame)
         {
              long len = (lstrlenW(szTargetFrame) + 1) * sizeof(char);
              char szTargetFrameName[STR_SIZE+1];
              len  = (len > STR_SIZE) ? STR_SIZE : len;
              WideCharToMultiByte(CP_ACP, 0, szTargetFrame, -1, (LPSTR)szTargetFrameName, len, NULL, NULL);
              if (lstrcmpi(szTargetFrameName,"_blank") == 0)
                  grfHLNF |= HLNF_OPENINNEWWINDOW;
              else
              {
                  htemp = GetAnInterface
                           (
                             pUnk,
                             IID_ITargetFrame,
                             (void**)&pTargetFrameSrc,
                             TRUE,
                             IID_ITargetFrame,
                             IID_ITargetFrame,
                             NULL
                            );
                  IUnknown *punkTargetFrame = 0;
                  if (SUCCEEDED(htemp))
                      htemp = pTargetFrameSrc->FindFrame(szTargetFrame,
                                                pHlframe,
                                                FINDFRAME_JUSTTESTEXISTENCE,
                                                &punkTargetFrame);
                  IHlinkFrame *pTargetHlinkFrame = 0;
                  if (punkTargetFrame)
                  {
                      IServiceProvider *pIsp = 0;

                      //      Get the IHlinkFrame for the target'ed frame and the source.
                      htemp = punkTargetFrame->QueryInterface(IID_IServiceProvider, (LPVOID *)&pIsp);
                      if (pIsp != NULL)
                      {
                          // NOTE: SID_SHLinkFrame should be the guidService
                          htemp = pIsp->QueryService(IID_IWebBrowserApp, IID_IHlinkFrame, (LPVOID*) &pTargetHlinkFrame);
                          pIsp->Release();
                      }

                      fAccessAllowed = (!IsSpecialUrl(pszUrl) ||
                                        AccessAllowed(pTargetFrameSrc, pTargetHlinkFrame));
                  }
                  else
                  {
                    grfHLNF |= HLNF_OPENINNEWWINDOW;
                  }
                  if (punkTargetFrame)
                      punkTargetFrame->Release();

                  if (pTargetFrameSrc)
                      pTargetFrameSrc->Release();


                  if (pTargetHlinkFrame)
                  {
                      pHlframe->Release();
                      pHlframe = pTargetHlinkFrame;
                  }
              }
         }

         if(!fAccessAllowed)
         {
             hr = E_ACCESSDENIED;
             goto exit;
         }

         hr = pHlframe->Navigate(grfHLNF,
                         pBndctx,
                         pBscb,
                         pLink);
    }
    else
        hr = E_FAIL;


    if ( FAILED(hr) && pHlframe)
    {       // Navigation through pHlframe failed, we will retrieve the
            // corresponding IWebBrowserApp interface and try navigation.
            if (pExplorer)
            {
                    pExplorer->Release();
                    pExplorer = 0;
            }
            pHlframe->QueryInterface(IID_IWebBrowserApp, (void **)&pExplorer);
    }

    if (FAILED(hr) && pExplorer && pmkTarget)
    {
        LPOLESTR szTarget;
        hr = pmkTarget->GetDisplayName(pBndctx,NULL,&szTarget);

            if (SUCCEEDED(hr))
                    hr = pExplorer->Navigate(
                            szTarget,
                            0,
                            0,
                            0,
                            0);

            CoTaskMemFree(szTarget);
    }

// pExplorer->Navigate  ShellExecute's
// We need not ShellExecute when pExplorer is not NULL

    if (FAILED(hr) && !pExplorer && pmkTarget)
    {
       // Our container does not support hyperlinking. We need to shell execute
       // explorer and go to the link.

       // We need to translate the string to ANSI
        CHAR szPath[MAX_PATH];
        DWORD cchPath = MAX_PATH;
        LPOLESTR szTarget;
        pmkTarget->GetDisplayName(pBndctx,NULL,&szTarget);
        int cbStr = 2 * wclen(szTarget + 1);
        
        char *pszAnsiTarget = new char[cbStr];
        if( !pszAnsiTarget )
            goto cleanup;

        // ASSERT(pszAnsiTarget)


        WideCharToMultiByte(CP_ACP, 0, szTarget, -1, pszAnsiTarget, cbStr, 0, 0);
        pszAnsiTarget[cbStr-1] = '\0';


        if(SUCCEEDED(PathCreateFromUrl(pszAnsiTarget, szPath, &cchPath, 0)))
        {
            HANDLE hFile = CreateFile(szPath,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

            if (INVALID_HANDLE_VALUE != hFile)
            {
                CloseHandle(hFile);
                hr = DoUrlShellExecuteA(szPath);
            }
            else
                hr = E_FAIL;
        }
        else
        {
            hr = DoUrlShellExecuteA((LPCTSTR)pszAnsiTarget);
        }
cleanup:
        if( pszAnsiTarget )
            delete[] pszAnsiTarget;

        CoTaskMemFree(szTarget);
    }

exit:

    if (pExplorer)
        pExplorer->Release();
    if (pHlframe)
        pHlframe->Release();
    if (pLink)
        pLink->Release();
    if(pszUrl)
        CoTaskMemFree(pszUrl);


    return( hr );
}

//////////////////////////////////////////////////////////////////////////
//
//    HlinkGoBack
//
STDAPI HlinkGoBack(IUnknown *pUnk)
{
   IWebBrowserApp *     pExplorer = 0;
   IHlinkFrame *        pHlframe  = 0;
   HRESULT              hr;


   hr = GetAnInterface
         (
          pUnk,
          IID_IWebBrowserApp,
          (void**)&pExplorer,
          TRUE,
          IID_IHlinkFrame,
          IID_IHlinkFrame,
          (void**)&pHlframe
         );

   if ( SUCCEEDED(hr) )
        hr = pHlframe->Navigate(HLNF_NAVIGATINGBACK, 0, 0, 0);

   if ( FAILED(hr) && pExplorer )
        hr = pExplorer->GoBack();

   if ( pExplorer )
            pExplorer->Release();

   if ( pHlframe )
            pHlframe->Release();

   return (hr);
}

//////////////////////////////////////////////////////////////////////////
//
//    HlinkGoForward
//
//////////////////////////////////////////////////////////////////////////

STDAPI HlinkGoForward(IUnknown *pUnk)
{
   IWebBrowserApp *     pExplorer = 0;
   IHlinkFrame *        pHlframe  = 0;
   HRESULT              hr;

   hr = GetAnInterface
         (
          pUnk,
          IID_IWebBrowserApp,
          (void**)&pExplorer,
          TRUE,
          IID_IHlinkFrame,
          IID_IHlinkFrame,
          (void**)&pHlframe
         );

   if (SUCCEEDED(hr))
       hr = pHlframe->Navigate(HLNF_NAVIGATINGFORWARD, 0, 0, 0);

   if ( FAILED(hr) && pExplorer )
       hr = pExplorer->GoForward();

   if ( pExplorer )
           pExplorer->Release();

   if ( pHlframe )
           pHlframe->Release();

   return (hr);
}

//////////////////////////////////////////////////////////////////////////
//
//    HlinkNavigateString
//
//////////////////////////////////////////////////////////////////////////

STDAPI HlinkNavigateString(IUnknown *pUnk, LPCWSTR szTarget)
{
   HRESULT  hr;

   hr = HlinkSimpleNavigateToString(szTarget, NULL, NULL, pUnk, NULL, 0, 0, 0);

   return (hr);
}

//////////////////////////////////////////////////////////////////////////
//
//    HlinkNavigateMoniker
//
//////////////////////////////////////////////////////////////////////////

STDAPI HlinkNavigateMoniker(IUnknown *pUnk, IMoniker *pmkTarget)
{
   HRESULT  hr;

   hr = HlinkSimpleNavigateToMoniker(pmkTarget, NULL, NULL, pUnk, NULL,NULL, 0, 0);

   return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\urlhlink\idispids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995 - 1996 Microsoft Corporation. All Rights Reserved.
//
//  File: idispids.h
//
//--------------------------------------------------------------------------

#define DISPID_READYSTATE               (-525)
#define DISPID_READYSTATECHANGE         (-609)
#define DISPID_AMBIENT_TRANSFERPRIORITY (-728)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\urlhlink\memcmp.c ===
/***
*memcmp.c - compare two blocks of memory
*
*       Copyright (c) 1985-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines memcmp() - compare two memory blocks lexically and
*       find their order.
*
*******************************************************************************/

//#include "cruntime.h"
#include <string.h>

#ifdef _MSC_VER
#pragma function(memcmp)
#endif  /* _MSC_VER */

/***
*int memcmp(buf1, buf2, count) - compare memory for lexical order
*
*Purpose:
*       Compares count bytes of memory starting at buf1 and buf2
*       and find if equal or which one is first in lexical order.
*
*Entry:
*       void *buf1, *buf2 - pointers to memory sections to compare
*       size_t count - length of sections to compare
*
*Exit:
*       returns < 0 if buf1 < buf2
*       returns  0  if buf1 == buf2
*       returns > 0 if buf1 > buf2
*
*Exceptions:
*
*******************************************************************************/

int __cdecl memcmp (
        const void * buf1,
        const void * buf2,
        size_t count
        )
{
        if (!count)
                return(0);

        while ( --count && *(char *)buf1 == *(char *)buf2 ) {
                buf1 = (char *)buf1 + 1;
                buf2 = (char *)buf2 + 1;
        }

        return( *((unsigned char *)buf1) - *((unsigned char *)buf2) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\urlhlink\urlhlink.h ===
#pragma message("MESSAGE: include urlmon.h stead of urlhlink.h")
#include "urlmon.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\urlhlink\memcpy.c ===
/***
*memcpy.c - contains memcpy routine
*
*       Copyright (c) 1988-1993, Microsoft Corporation. All right reserved.
*
*Purpose:
*       memcpy() copies a source memory buffer to a destination buffer.
*       Overlapping buffers are not treated specially, so propogation may occur.
*
*******************************************************************************/

//#include "cruntime.h"
#include <string.h>

#ifdef _MSC_VER
#pragma function(memcpy)
#endif  /* _MSC_VER */

/***
*memcpy - Copy source buffer to destination buffer
*
*Purpose:
*       memcpy() copies a source memory buffer to a destination memory buffer.
*       This routine does NOT recognize overlapping buffers, and thus can lead
*       to propogation.
*
*       For cases where propogation must be avoided, memmove() must be used.
*
*Entry:
*       void *dst = pointer to destination buffer
*       const void *src = pointer to source buffer
*       size_t count = number of bytes to copy
*
*Exit:
*       Returns a pointer to the destination buffer
*
*Exceptions:
*******************************************************************************/

void * __cdecl memcpy (
        void * dst,
        const void * src,
        size_t count
        )
{
        void * ret = dst;

#if defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC)
        {
        extern void RtlMoveMemory( void *, const void *, size_t count );

        RtlMoveMemory( dst, src, count );
        }
#else  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */
        /*
         * copy from lower addresses to higher addresses
         */
        while (count--) {
                *(char *)dst = *(char *)src;
                dst = (char *)dst + 1;
                src = (char *)src + 1;
        }
#endif  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */

        return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\urlhlink\urlostrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       URLOSTRM.CXX
//
//  Contents:   Public interface and implementation of the URL
//              Open Stream APIs
//
//  Classes:    many (see below)
//
//  Functions:
//
//  History:    04-22-96    VictorS         Created
//              05-16-96    Jobi            Modified
//              06-06-96    Jobi            Modified
//              07-05-96    Ramesh          Modified
//----------------------------------------------------------------------------
#ifndef unix
// For some reaon on unix this causes NOERROR compile errors
#include "winerror.h"
#endif /* unix */
#include "ocidl.h"
#include "servprov.h"
#include "tchar.h"
#include "wininet.h"
#include "urlmki.h"
#include "urlhlink.h"
#include <shlwapi.h>
#include <shlwapip.h>

#define URLOSTRM_DONOT_NOTIFY_ONDATA    0xFF
#define URLOSTRM_NOTIFY_ONDATA            0x00

//----------------------------------------------------------//
//                                                          //
//  This file can never be compiled with the _UNICODE or    //
//  UNICODE macros defined.                                 //
//                                                          //
//----------------------------------------------------------//

//----------------------------------------------------------//
//  MACROS
//----------------------------------------------------------//

    // These macros can go away when macros and implementation of
    // the InetSDK has settled down...

#define IS_E_PENDING(x)  (x == E_PENDING)
#define LPUOSCALLBACK LPBINDSTATUSCALLBACK
#define PUMPREAD(strm) \
            { \
                DWORD dwSize = 0; \
                char * x = new char[20]; \
                hr = strm->Read(x, 20, &dwSize ); \
                if( !IS_E_PENDING(hr) && (dwSize != 0) ) \
                { \
                DPRINTF( ("Data on the over read! %d\n", dwSize) ); \
                } \
                delete x; \
            }

#define HANDLE_ABORT(hr) \
            { if( hr == E_ABORT) \
              { m_bInAbort = 1; \
                if( m_binding ) \
                    m_binding->Abort(); \
                 return(E_ABORT); \
               } \
            }

#define CHECK_MEMORY(ptr) \
            { if( !ptr ) \
              { DPRINTF( ("Failed to alloc memory") ); \
                m_bInAbort = 1; \
                if( m_binding ) \
                    m_binding->Abort(); \
                 return(E_OUTOFMEMORY); \
               } \
            }



    //
    //  Refcount helper
    //

    // Standardized COM Ref counting. ASSUMES that class has a ULONG
    // data member called 'm_ref'.

#define IMPLEMENT_REFCOUNT(clsname) \
        STDMETHOD_(ULONG, AddRef)() \
        {   CHECK_INTERFACE(this); \
            DPRINTF( ("(%#08x) " #clsname "::Addref %d\n", this, m_ref+1) );\
            return(++m_ref); }\
        STDMETHOD_(ULONG, Release)()\
            { CHECK_INTERFACE(this); \
            DPRINTF( ( "(%#08x) " #clsname "::Release : %d\n", this, m_ref-1) );\
            if( !--m_ref )\
            { delete this; return 0; }\
          return m_ref;\
        }



//----------------------------------------------------------
//
//  DEBUG MACROS
//
//----------------------------------------------------------

#ifdef _DEBUG

    // Check the validity of a pointer - use this for all allocated memory

#define CHECK_POINTER(val) \
            if (!(val) || IsBadWritePtr((void *)(val), sizeof(void *))) \
             { DPRINTF( ("BAD POINTER: %s!\n", #val ) ); \
              return E_POINTER; }

    // Check the validity of an interface pointer. Use this for all pointers
    // to C++ objects that are supposed to have vtables.

#define CHECK_INTERFACE(val) \
            if (!(val) || IsBadWritePtr((void *)(val), sizeof(void *)) \
                  || IsBadCodePtr( FARPROC( *((DWORD **)val)) ) ) \
            { DPRINTF( ("BAD INTERFACE: %s!\n", #val ) ); \
               return E_POINTER; }

    // Simple assert. Map this to whatever general
    // framework assert you want.

#define UOSASSERT(x) { if(!(x)) dprintf( "Assert in URLOSTRM API: %s\n", #x ); }

#define DUOS            OutputDebugString( "URLOSTRM API: " );
#define DPRINTF(x)          DUOS dprintf x ;

#ifndef CHECK_METHOD
#define CHECK_METHOD( m, args ) DUOS dprintf( "(%#08x) %s(", this, #m ); dprintf args ; dprintf(")\n");
#endif

#ifndef MEMPRINTF
#define MEMPRINTF(x) DPRINTF(x)
#endif

void dprintf( char * format, ... )
{
    char out[1024];
    va_list marker;
    va_start(marker, format);
    wvsprintf(out, format, marker);
    va_end(marker);
    OutputDebugString( out );
}


#else
#define CHECK_POINTER(x)
#define CHECK_INTERFACE(x)
#define CHECK_METHOD( m, args )
#define UOSASSERT(x)
#define DPRINTF(x)
#define MEMPRINTF(x)
#endif

//----------------------------------------------------------
//
//      Local heap stuff
//
//----------------------------------------------------------

    // Keeping this here makes this code portable to any .dll
static HANDLE   g_hHeap;

#ifdef _DEBUG
    // Uncomment the line below for Debug spew of memory stuff
//#define MONITER_MEMALLOC 1
#endif

#ifdef _DEBUG
static void * _cdecl
operator new( size_t size )
{
    if( !g_hHeap )
        g_hHeap = ::GetProcessHeap();

    // Heap alloc is the fastest gun in the west
    // for the type of allocations we do here.
    void * p = HeapAlloc(g_hHeap, 0, size);

    MEMPRINTF( ("operator new(%d) returns(%#08X)\n",size, DWORD(p)) );

    return(p);
}

static void _cdecl
operator delete ( void *ptr)
{
    MEMPRINTF( ("operator delete(%#08X)\n", DWORD(ptr) ) );

    HeapFree(g_hHeap, 0, ptr);
}
#endif


//----------------------------------------------------------
//
//      class CBuffer
//
//----------------------------------------------------------


//  Generic CBuffer class for quick and dirty mem allocs.
//  Caller must check return results.

class CBuffer
{
  public:
    CBuffer(ULONG cBytes);
    ~CBuffer();

    void *GetBuffer();

  private:
    void *      m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char        m_szTmpBuf[120];
    unsigned    m_fHeapAlloc:1;
};

inline
CBuffer::CBuffer(ULONG cBytes)
{
   if( !g_hHeap )
        g_hHeap = ::GetProcessHeap();

   m_pBuf = (cBytes <= 120) ? m_szTmpBuf : HeapAlloc(g_hHeap, 0, cBytes);
   m_fHeapAlloc = (cBytes > 120);
}

inline
CBuffer::~CBuffer()
{
    if (m_pBuf && m_fHeapAlloc) HeapFree(g_hHeap, 0, m_pBuf);
}

inline
void * CBuffer::GetBuffer()
{
    return m_pBuf;
}

//=--------------------------------------------------------------------------=
//
//  String ANSI <-> WIDE helper macros
//
//  This stuff stolen from marcwan...
//
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
//=--------------------------------------------------------------------------=

#define MAKE_WIDE(ptrname) \
    long __l##ptrname = (lstrlen(ptrname) + 1) * sizeof(WCHAR); \
    CBuffer __CBuffer##ptrname(__l##ptrname); \
    CHECK_POINTER(__CBuffer##ptrname.GetBuffer()); \
    if( !__CBuffer##ptrname.GetBuffer()) \
        return( E_OUTOFMEMORY ); \
    MultiByteToWideChar(CP_ACP, 0, ptrname, -1, \
        (LPWSTR)__CBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR __w##ptrname = (LPWSTR)__CBuffer##ptrname.GetBuffer()

#define WIDE_NAME(ptrname) __w##ptrname

#define MAKE_ANSI(ptrname) \
    long __l##ptrname = (lstrlenW(ptrname)*2 + 1) * sizeof(char); \
    CBuffer __CBuffer##ptrname(__l##ptrname); \
    CHECK_POINTER(__CBuffer##ptrname.GetBuffer()); \
    if( !__CBuffer##ptrname.GetBuffer()) \
        return( E_OUTOFMEMORY ); \
    WideCharToMultiByte(CP_ACP, 0, ptrname, -1, \
        (LPSTR)__CBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR __a##ptrname = (LPSTR)__CBuffer##ptrname.GetBuffer()

#define ANSI_NAME(ptrname) __a##ptrname


//----------------------------------------------------------
//
//      Misc helper functions
//
//----------------------------------------------------------

// These registry functions are here for support of backdoor
// flags and screamer features.

static HRESULT
GetRegDword( HKEY mainkey, LPCTSTR subkey, LPCTSTR valueName, DWORD * result )
{
    HKEY    hkey = 0;
    DWORD       dwDisposition;

    LONG dwResult = RegCreateKeyEx(
                         mainkey, subkey,
                        0, // DWORD  Reserved,  // reserved
                        0, // LPTSTR  lpClass,  // address of class string
                        REG_OPTION_NON_VOLATILE, // DWORD  dwOptions,   // special options flag
                        KEY_ALL_ACCESS, // REGSAM  samDesired,  // desired security access
                        0, // LPSECURITY_ATTRIBUTES  lpSecurityAttributes,      // address of key security structure
                        &hkey, // PHKEY  phkResult,     // address of buffer for opened handle
                        &dwDisposition // LPDWORD  lpdwDisposition      // address of disposition value buffer
                       );

    HRESULT hr = dwResult == ERROR_SUCCESS ? NOERROR : E_FAIL;

    if( SUCCEEDED(hr) )
    {
        DWORD dwType;
        DWORD dwSize = sizeof(DWORD);
        DWORD dwSavedResult = *result;

        dwResult = RegQueryValueEx(
                        hkey,   // handle of key to query
                        valueName,
                        0, // LPDWORD  lpReserved,      // reserved
                        &dwType, // LPDWORD  lpType,    // address of buffer for value type
                        (LPBYTE)result, // LPBYTE  lpData,      // address of data buffer
                        &dwSize // LPDWORD  lpcbData    // address of data buffer size
                        );

        hr = dwResult == ERROR_SUCCESS ? NOERROR : E_FAIL;

        if( FAILED(hr) )
            *result = dwSavedResult;
    }

    if( hkey )
        RegCloseKey(hkey);

    return(hr);
}


static HRESULT
GetDLMRegDWord( LPCTSTR valueName, DWORD * result  )
{
    return(GetRegDword( HKEY_LOCAL_MACHINE,
                        _TEXT("Software\\Microsoft\\DownloadManager"),
                        valueName,
                        result ) );
}


static HRESULT
MyCreateFile( LPCWSTR filename, HANDLE & hfile )
{
    // BUGBUG: in retrospect this should be a ansi function
    // not a wide string one.

    HRESULT hr = NOERROR;

/**********
    MAKE_ANSI( filename );

    hfile = ::CreateFileA(
                          ANSI_NAME(filename), // LPCTSTR  lpFileName,    // pointer to name of the file
                          GENERIC_WRITE, // DWORD  dwDesiredAccess,       // access (read-write) mode
                          0, // DWORD  dwShareMode,       // share mode
                          0, // LPSECURITY_ATTRIBUTES  lpSecurityAttributes,      // pointer to security descriptor
                          CREATE_ALWAYS, // DWORD  dwCreationDistribution,        // how to create
                          FILE_ATTRIBUTE_NORMAL, //DWORD  dwFlagsAndAttributes,   // file attributes
                          0  // HANDLE  hTemplateFile   // handle to file with attributes to copy
                         );
*************/
    hfile = CreateFileWrapW(
                filename, 
                GENERIC_WRITE, 
                0, 
                0, 
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                0
        );

    // Our code likes HRESULT style error handling

    if( hfile == INVALID_HANDLE_VALUE )
        hr = MK_E_CANTOPENFILE;

    return(hr);
}



//----------------------------------------------------------
//
//      BindStatusCallback base class
//
//----------------------------------------------------------

//
//  This is the base class for the download objects. It implements
// the url mon callback interface (IBindStatusCallback) and
// IServiceProvider -- which it delegates to the caller's IBSCB.
//


    // State flags

class CBaseBSCB :   public IBindStatusCallbackMsg,
                    public IServiceProvider
{
public:

    CBaseBSCB( IUnknown * caller, DWORD bscof, LPUOSCALLBACK callback );
    virtual ~CBaseBSCB();

    STDMETHOD(KickOffDownload)( LPCWSTR szURL );

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);

    IMPLEMENT_REFCOUNT(CBaseBSCB);

    // IBindStatusCallback

    STDMETHODIMP OnStartBinding(
         DWORD grfBSCOption,
         IBinding  *pib);

    STDMETHODIMP GetPriority(
         LONG  *pnPriority);

    STDMETHODIMP OnLowResource(
         DWORD reserved);

    STDMETHODIMP OnProgress(
         ULONG ulProgress,
         ULONG ulProgressMax,
         ULONG ulStatusCode,
         LPCWSTR szStatusText);

    STDMETHODIMP OnDataAvailable(
         DWORD       grfBSCF,
         DWORD       dwSize,
         FORMATETC  *pformatetc,
         STGMEDIUM  *pstgmed);

    STDMETHODIMP OnStopBinding(
         HRESULT hresult,
         LPCWSTR szError);

    STDMETHODIMP GetBindInfo(
         DWORD  *grfBINDF,
         BINDINFO  *pbindinfo);

    STDMETHODIMP OnObjectAvailable(
         REFIID riid,
         IUnknown  *punk);

    STDMETHODIMP MessagePending(
        DWORD  dwPendingType,
        DWORD  dwPendingRecursion,
        DWORD  dwReserved);

    // IServiceProvider

    STDMETHODIMP QueryService(
            REFGUID rsid,
            REFIID iid,
            void **ppvObj);


    //  Local methods

    void    Abort();
    BOOL    IsAborted();
    BOOL    DownloadDone();
    HRESULT FinalResult();
    void    SetEncodingFlags( ULONG flags );

    IUnknown * Caller();

    // I guess at one point I thought it would be cool
    // to make all of these inlines and isolated from
    // the core functionality.

    HRESULT SignalOnData( DWORD flags, ULONG size, FORMATETC  *pformatetc);
    HRESULT SignalOnProgress( ULONG status, ULONG size, ULONG maxSize, LPCWSTR msg );
    HRESULT SignalOnStopBinding( HRESULT hr, LPCWSTR msg );

    HRESULT SignalOnStartBinding( DWORD grfBSCOption, IBinding  *pib);
    HRESULT SignalOnGetPriority(LONG*);
    HRESULT SignalOnLowResource(DWORD);
    HRESULT SignalGetBindInfo(DWORD  *grfBINDF,BINDINFO  *pbindinfo);

    virtual void    Neutralize();

    ULONG               m_ref;
    LPUOSCALLBACK       m_callback;
    IUnknown *          m_caller;
    IBinding *          m_binding;
    IServiceProvider *  m_callbackServiceProvider;
    IBindStatusCallbackMsg *_pBSCBMsg;
    BOOL                m_bInAbort : 1;
    BOOL                m_bInCache : 1;
    BOOL                m_bCheckedForServiceProvider : 1;
    DWORD               m_readSoFar;
    HRESULT             m_finalResult;

    // See notes above about IStream usage

    IStream *           m_UserStream;

    ULONG               m_maxSize;
    DWORD               m_bscoFlags;
    UINT                m_encoding;
    char                m_szCacheFileName[MAX_PATH];
};


    /*---------------------*/
    /*  INLINES            */
    /*---------------------*/

inline void     CBaseBSCB::Abort()      { m_bInAbort = 1; }
inline BOOL     CBaseBSCB::IsAborted()  { return(m_bInAbort); }
inline HRESULT  CBaseBSCB::FinalResult(){ return( m_finalResult ); }
inline IUnknown*CBaseBSCB::Caller()     { return( m_caller ); }
inline void     CBaseBSCB::SetEncodingFlags( ULONG flags ) { m_encoding = flags; }

inline HRESULT
CBaseBSCB::SignalOnData( DWORD flags, ULONG size, FORMATETC  *pformatetc )
{
        HRESULT hr=NOERROR;

        if(m_bscoFlags!=URLOSTRM_NOTIFY_ONDATA)
        return(hr);

        STGMEDIUM stg;

        stg.tymed = TYMED_ISTREAM;
        stg.pstm  = m_UserStream;
        stg.pUnkForRelease = NULL;

        if(m_callback)
                hr=m_callback->OnDataAvailable(flags,size,pformatetc,&stg);

        return(hr);
}

inline HRESULT
CBaseBSCB::SignalOnProgress( ULONG status, ULONG size, ULONG maxSize, LPCWSTR msg )
{
    if( !m_callback )
        return(NOERROR);

    if( size && !maxSize )
        maxSize = size;

    if( maxSize > m_maxSize )
        m_maxSize = maxSize;

    HRESULT hr = m_callback->OnProgress( size, m_maxSize, status, msg );

    return(hr);
}


inline HRESULT
CBaseBSCB::SignalOnStopBinding( HRESULT hres, LPCWSTR msg )
{
    if( !m_callback )
        return(NOERROR);

    HRESULT hr = m_callback->OnStopBinding( hres, msg );

    return(hr);
}



inline HRESULT
CBaseBSCB::SignalOnStartBinding( DWORD grfBSCOption, IBinding  *pib)
{
    if( !m_callback )
        return(NOERROR);
    return( m_callback->OnStartBinding(grfBSCOption,pib) );
}


inline HRESULT
CBaseBSCB:: SignalOnGetPriority(LONG* lng)
{
    if( !m_callback )
        return(E_NOTIMPL);
    return(m_callback->GetPriority(lng));
}

inline HRESULT
CBaseBSCB:: SignalOnLowResource(DWORD dw)
{
    if( !m_callback )
        return( NOERROR );
    return( m_callback->OnLowResource(dw) );
}

inline HRESULT
CBaseBSCB::SignalGetBindInfo(DWORD *grfBINDF, BINDINFO * pbindinfo)
{
    if( !m_callback )
        return(E_NOTIMPL);
    return( m_callback->GetBindInfo(grfBINDF, pbindinfo) );
}


    /*---------------------*/
    /*  OUT-OF-LINES       */
    /*---------------------*/


// Do nothing CTOR
CBaseBSCB::CBaseBSCB
(
    IUnknown *      caller,
    DWORD               bscof,
    LPUOSCALLBACK       callback
)
{
    m_binding       = 0;
    m_ref               = 0;
    m_bInAbort      = 0;
    m_bCheckedForServiceProvider = 0;
    m_bInCache      = 0;
    m_readSoFar     = 0;
    m_UserStream    = 0;
    m_encoding      = 0;
    m_bscoFlags    = bscof;
    m_callbackServiceProvider = 0;
    m_szCacheFileName[0] = NULL;
        m_finalResult   = S_OK;

    _pBSCBMsg = 0;

    if( (m_callback = callback) != 0 )
        m_callback->AddRef();

    if( (m_caller = caller) != 0 )
        caller->AddRef();
}

// Cleanup just call Neutralize();
CBaseBSCB::~CBaseBSCB()
{
    Neutralize();
}

void
CBaseBSCB::Neutralize()
{
    if( m_binding )
    {
        m_binding->Release();
        m_binding = 0;
    }
    if( m_caller )
    {
        m_caller->Release();
        m_caller = 0;
    }
    if( m_callback )
    {
        m_callback->Release();
        m_callback = 0;
    }
    if( m_callbackServiceProvider )
    {
        m_callbackServiceProvider->Release();
        m_callbackServiceProvider = 0;
    }
    if( m_UserStream )
    {
        m_UserStream->Release();
        m_UserStream = 0;
    }
    if (_pBSCBMsg)
    {
        _pBSCBMsg->Release();
    }
}

// IUnknown::QueryInterface
STDMETHODIMP
CBaseBSCB::QueryInterface
(
    const GUID &iid,
    void **     ppv
)
{
    CHECK_METHOD(CBaseBSCB::QueryInterface, ("") );

    if (iid==IID_IUnknown || iid==IID_IBindStatusCallback)
    {
        *ppv =(IBindStatusCallback*)this;
        AddRef();
        return(NOERROR);
    }


    if( iid==IID_IServiceProvider)
    {
        *ppv =(IServiceProvider*)this;
        AddRef();
        return(NOERROR);
    }

    if (iid==IID_IBindStatusCallbackMsg)
    {
        *ppv =(IBindStatusCallbackMsg*)this;
        AddRef();
        return(NOERROR);
    }


    return( E_NOINTERFACE );
}

// IServiceProvider::QueryService
STDMETHODIMP
CBaseBSCB::QueryService
(
    REFGUID rsid,
    REFIID iid,
    void **ppvObj
)
{
    CHECK_METHOD(CBaseBSCB::QueryService, ("") );

    HRESULT hr = E_NOINTERFACE;

    if (iid==IID_IBindStatusCallback)
    {
        *ppvObj =(IBindStatusCallbackMsg*)this;
        AddRef();
        return(NOERROR);
    }


    if( m_callback )
        hr = m_callback->QueryInterface( iid, ppvObj );

    if( FAILED(hr) && !m_callbackServiceProvider && !m_bCheckedForServiceProvider )
    {
       m_bCheckedForServiceProvider = 1;

       if( m_callback )
       {
            hr = m_callback->QueryInterface
                                (
                                  IID_IServiceProvider,
                                  (void**)&m_callbackServiceProvider
                                );
       }

        if( SUCCEEDED(hr) && m_callbackServiceProvider )
            hr = m_callbackServiceProvider->QueryService(rsid,iid,ppvObj);
        else
            hr = E_NOINTERFACE; // BUGBUG: what's that error code again?
    }

    HANDLE_ABORT(hr);

    return( hr );
}


// IBindStatusCallback::OnStartBinding
STDMETHODIMP
CBaseBSCB::OnStartBinding
(
    DWORD       grfBSCOption,
    IBinding   *pib
)
{
    CHECK_METHOD(CBaseBSCB::OnStartBinding, ("flags: %#08x, IBinding: %#08x",grfBSCOption,pib) );

    CHECK_INTERFACE(pib);

    HRESULT hr = SignalOnStartBinding(grfBSCOption,pib);

    // smooth over user's e_not_implemented for when we
    // return to urlmon

    if( hr == E_NOTIMPL )
        hr = NOERROR;
    else
        HANDLE_ABORT(hr);

    if( SUCCEEDED(hr) )
    {
        pib->AddRef();
        m_binding = pib;
    }

    return( hr );
}


// IBindStatusCallback::GetPriority
STDMETHODIMP
CBaseBSCB::GetPriority
(
    LONG  *pnPriority
)
{
    CHECK_METHOD(CBaseBSCB::GetPriority, ("pnPriority: %#08x", pnPriority) );
    CHECK_POINTER(pnPriority);

    if (!pnPriority)
        return E_POINTER;

    HRESULT hr = SignalOnGetPriority(pnPriority);

    if( hr == E_NOTIMPL )
    {
        // only override if caller doesn't implement.
        *pnPriority = NORMAL_PRIORITY_CLASS;
        hr = NOERROR;
    }
    else
    {
        HANDLE_ABORT(hr);
    }

    return( hr );

}


// IBindStatusCallback::OnLowResource
STDMETHODIMP
CBaseBSCB::OnLowResource( DWORD rsv)
{
    CHECK_METHOD(CBaseBSCB::OnLowResource, ("resv: %#08x",rsv) );

    HRESULT hr = SignalOnLowResource(rsv);

    // Keep downloading...

    if( hr == E_NOTIMPL )
        hr = NOERROR;
    else
        HANDLE_ABORT(hr);

    return( hr );
}


// IBindStatusCallback::OnStopBinding
STDMETHODIMP
CBaseBSCB::OnStopBinding
(
    HRESULT hresult,
    LPCWSTR szError
)
{
    CHECK_METHOD(CBaseBSCB::OnStopBinding, ("%#08X %ws", hresult, szError ? szError : L"[no error]" )  );

    // Store the hresult so we can return it to caller in the
    // blocking/sync case.

    HRESULT hr = SignalOnStopBinding( m_finalResult = hresult, szError );

    if( m_binding )
    {
        m_binding->Release();
        m_binding = 0;
    }

    if( hr == E_NOTIMPL )
        hr = NOERROR;
    else
        HANDLE_ABORT(hr);

    return( hr );
}


// IBindStatusCallback::GetBindInfo

STDMETHODIMP
CBaseBSCB::GetBindInfo
(
    DWORD  *    grfBINDF,
    BINDINFO*   pbindinfo
)
{
    CHECK_METHOD(CBaseBSCB::GetBindInfo, ("grfBINDF: %#08x, pbinfinfo ",grfBINDF) );

    CHECK_POINTER(grfBINDF);
    CHECK_POINTER(pbindinfo);

    *grfBINDF = 0;

    HRESULT hr = SignalGetBindInfo(grfBINDF,pbindinfo);

    if( SUCCEEDED(hr) || (hr == E_NOTIMPL) )
    {
        // Let the derived class choose the bind flags

        if(m_encoding)
        {
            *grfBINDF |= m_encoding;
            pbindinfo->grfBindInfoF |= m_encoding;
        }

        hr = NOERROR;
    }

    HANDLE_ABORT(hr);

    return( hr );
}


// IBindStatusCallback::OnObjectAvailable
STDMETHODIMP
CBaseBSCB::OnObjectAvailable
(
    REFIID riid,
    IUnknown  *punk
)
{
    // This should never be called
    CHECK_METHOD(CBaseBSCB::OnObjectAvailable, ("!") );
    UOSASSERT(0 && "This should never be called");
    return(NOERROR);
}

STDMETHODIMP
CBaseBSCB::OnProgress
(
    ULONG ulProgress,
    ULONG ulProgressMax,
    ULONG ulStatusCode,
    LPCWSTR szStatusText
)
{
    CHECK_METHOD(CBaseBSCB::OnProgress, ("!") );

    // URL moniker has a habit of passing ZERO
    // into ulProgressMax. So.. let's at least
    // pass in the amount we have so far...

    m_maxSize = ulProgressMax ? ulProgressMax : ulProgress;

    // This is useful information for the IStream implementation


    if( ulStatusCode == BINDSTATUS_USINGCACHEDCOPY )
        m_bInCache = TRUE;

    HRESULT hr;

    hr = SignalOnProgress( ulStatusCode, ulProgress, ulProgressMax, szStatusText );

    if( hr == E_NOTIMPL )
        hr = NOERROR;
    else
        HANDLE_ABORT(hr);

    return( hr );
}

// IBindStatusCallback::OnDataAvailable.

STDMETHODIMP
CBaseBSCB::OnDataAvailable
(
    DWORD           grfBSCF,
    DWORD           dwSize,
    FORMATETC  *pformatetc,
    STGMEDIUM  *pstgmed
)
{
    CHECK_METHOD(CBaseBSCB::OnDataAvailable,
                                ("Flags: %x, dwSize: %d", grfBSCF, dwSize) );

    HRESULT hr = NOERROR;

    // N.B Assumption here is that the pstgmed->pstm will always be the same

     if( !m_UserStream )
     {
            // We need to bump the refcount every time we
            // copy and store the pointer.

        m_UserStream = pstgmed->pstm;
        m_UserStream->AddRef();
     }

     if (*m_szCacheFileName == NULL)
     {
         STATSTG statstg;
         DWORD dwVal = 0;

         if (m_UserStream->Stat(&statstg,dwVal) == S_OK)
         {
             if (0==WideCharToMultiByte(  CP_ACP, 0, statstg.pwcsName, lstrlenW(statstg.pwcsName)+1, m_szCacheFileName,
                         MAX_PATH, NULL, NULL))
             {
                   m_szCacheFileName[0] = NULL;
             }
             if (statstg.pwcsName)
             {
                 CoTaskMemFree(statstg.pwcsName);
                 statstg.pwcsName = NULL;
             }
         }
         else
            m_szCacheFileName[0] = NULL;
     }

    hr = SignalOnData( grfBSCF, dwSize, pformatetc );

    // Tell the blocking state machine we are have data.
    // ClearState( WAITING_FOR_DATA );

    if( hr == E_NOTIMPL )
        hr = NOERROR;
    else
        HANDLE_ABORT(hr);

    return( hr );
}

// IBindStatusCallback::MessagePending.

STDMETHODIMP CBaseBSCB::MessagePending(DWORD  dwPendingType, DWORD  dwPendingRecursion, DWORD  dwReserved)
{
    MSG msg;
    HRESULT hr = NOERROR;

    if (m_callback && !_pBSCBMsg)
    {
        hr = m_callback->QueryInterface(IID_IBindStatusCallbackMsg, (void **) &_pBSCBMsg);
    }

    if (_pBSCBMsg && hr == NOERROR )
    {
        hr = _pBSCBMsg->MessagePending(dwPendingType, dwPendingRecursion, dwReserved );
    }

    return hr;
}

HRESULT
CBaseBSCB::KickOffDownload( LPCWSTR szURL )
{
    HRESULT                 hr;
    IOleObject *        pOleObject = 0;
    IServiceProvider *  pServiceProvider = 0;
    BOOL                bUseCaller = (Caller() != 0);
    IMoniker *          pmkr = 0;
    IBindCtx *          pBndCtx = 0;

    CHECK_POINTER(szURL);
    UOSASSERT(*szURL);


    IStream * pstrm = 0;

    // Don't bother if we don't have a caller...

    if( bUseCaller )
    {
        // By convention the we give the caller first crack at service
        // provider. The assumption here is that if they implement it
        // they have the decency to forward QS's to their container.

        hr = Caller()->QueryInterface( IID_IServiceProvider,
                                        (void**)&pServiceProvider );

        if( FAILED(hr) )
        {
            // Ok, now try the 'slow way' : maybe the object is an 'OLE' object
            // that knows about it's client site:

            hr = Caller()->QueryInterface( IID_IOleObject, (void**)&pOleObject );

            if( SUCCEEDED(hr) )
            {
                IOleClientSite * pClientSite = 0;

                hr = pOleObject->GetClientSite(&pClientSite);

                if( SUCCEEDED(hr) )
                {
                    // Now see if we have a service provider at that site
                    hr = pClientSite->QueryInterface
                                            ( IID_IServiceProvider,
                                            (void**)&pServiceProvider );
                }

                if( pClientSite )
                    pClientSite->Release();
            }
            else
            {
                // Ok, it's not an OLE object, maybe it's one of these
                // new fangled 'ObjectWithSites':

                IObjectWithSite * pObjWithSite = 0;

                hr = Caller()->QueryInterface( IID_IObjectWithSite,
                                                    (void**)&pObjWithSite );

                if( SUCCEEDED(hr) )
                {
                    // Now see if we have a service provider at that site

                    hr = pObjWithSite->GetSite(IID_IServiceProvider,
                                                (void**)&pServiceProvider);
                }

                if( pObjWithSite )
                    pObjWithSite->Release();

            }
            if( pOleObject )
                pOleObject->Release();

        }

        // BUGBUG: In the code above we stop looking at one level up --
        //  this may be too harsh and we should loop on client sites
        // until we get to the top...

        if( !pServiceProvider )
            hr = E_UNEXPECTED;

        IBindHost * pBindHost = 0;

        // Ok, we have a service provider, let's see if BindHost is
        // available. (Here there is some upward delegation going on
        // via service provider).

        if( SUCCEEDED(hr) )
            hr = pServiceProvider->QueryService( SID_SBindHost, IID_IBindHost,
                                                        (void**)&pBindHost );

        if( pServiceProvider )
            pServiceProvider->Release();

        pmkr = 0;

        if( pBindHost )
        {
            // This allows the container to actually drive the download
            // by creating it's own moniker.

            hr = pBindHost->CreateMoniker( LPOLESTR(szURL),NULL, &pmkr,0 );



            if( SUCCEEDED(hr) )
            {
                // This allows containers to hook the download for
                // doing progress and aborting

                hr = pBindHost->MonikerBindToStorage(pmkr, NULL, this, IID_IStream,(void**)&pstrm);
            }

            pBindHost->Release();
        }
        else
        {
            bUseCaller = 0;
        }
    }

    if( !bUseCaller )
    {
        // If you are here, then either the caller didn't pass
        // a 'caller' pointer or the caller is not in a BindHost
        // friendly environment.

        hr = ::CreateURLMoniker( 0, szURL, &pmkr );

        if( SUCCEEDED(hr) )
            hr = ::CreateBindCtx( 0, &pBndCtx );

                if( SUCCEEDED(hr) )
                {
                // Register US (not the caller) as the callback. This allows
        // us to hook all notfiications from URL moniker and filter
        // and manipulate to our satifisfaction.
                         hr = ::RegisterBindStatusCallback( pBndCtx, this, 0, 0L );
                }

            if( SUCCEEDED(hr) )
                {
                        hr = pmkr->BindToStorage( pBndCtx, NULL, IID_IStream, (void**)&pstrm );

                        // Smooth out the error code
                if( IS_E_PENDING(hr) )
                            hr = S_OK;
                }

    }

    if( pstrm )
        pstrm->Release();

    if( pmkr )
        pmkr->Release();

    if( pBndCtx )
        pBndCtx->Release();

    return(hr);
}



//----------------------------------------------------------
//
//      CPullDownload
//
//----------------------------------------------------------

// placeholder for covering the URL moniker anomolies

class CPullDownload : public CBaseBSCB
{
public:
    CPullDownload( IUnknown * caller, DWORD bscof, LPUOSCALLBACK callback );
    STDMETHODIMP GetBindInfo(
         DWORD  *grfBINDF,
         BINDINFO  *pbindinfo);
};

inline
CPullDownload::CPullDownload( IUnknown * caller, DWORD bscof, LPUOSCALLBACK callback )
    : CBaseBSCB(caller,bscof,callback)
{
}

STDMETHODIMP
CPullDownload::GetBindInfo
(
        DWORD  *        grfBINDF,
    BINDINFO  * pbindinfo
)
{
    // pointers are validated in base class

    HRESULT hr = CBaseBSCB::GetBindInfo( grfBINDF, pbindinfo );

    if( SUCCEEDED(hr))
    {
        if (*grfBINDF & BINDF_ENFORCERESTRICTED)
            *grfBINDF = BINDF_ASYNCSTORAGE | BINDF_PULLDATA | BINDF_ASYNCHRONOUS | BINDF_ENFORCERESTRICTED;
        else
            *grfBINDF = BINDF_ASYNCSTORAGE | BINDF_PULLDATA | BINDF_ASYNCHRONOUS;
    }

    return(hr);
}
//----------------------------------------------------------
//
//      Push Stream API
//
//----------------------------------------------------------

//
// Class used for implementing push model downloading when used
// in combination with the CStream object.
//
//  The general design for is this class pumps a
//  CBitBucket object with bits and the CStream object makes
//  those bits available to the caller for reading.
//

class CPushDownload : public CBaseBSCB
{
public:
    CPushDownload( IUnknown * caller, DWORD bscof, LPUOSCALLBACK callback );
    ~CPushDownload();
    STDMETHODIMP GetBindInfo(
         DWORD  *grfBINDF,
         BINDINFO  *pbindinfo);
protected:

    // CBaseBSCB

    virtual void  Neutralize();


    // IBindStatusCallback

    STDMETHODIMP OnDataAvailable
    (
         DWORD          grfBSCF,
         DWORD          dwSize,
         FORMATETC *    pFmtetc,
         STGMEDIUM *    pstgmed
    ) ;

private:
    HRESULT CleanupPush();
};


CPushDownload::CPushDownload( IUnknown * caller, DWORD bscof, LPUOSCALLBACK callback )
    : CBaseBSCB(caller,bscof, callback)
{
}

CPushDownload::~CPushDownload()
{
    CleanupPush();
}

void
CPushDownload::Neutralize()
{
    // We have to do special cleanup.

    CleanupPush();

    CBaseBSCB::Neutralize();
}

HRESULT
CPushDownload::CleanupPush()
{
    return(NOERROR);
}

STDMETHODIMP
CPushDownload::OnDataAvailable
(
     DWORD              grfBSCF,
     DWORD              dwSize,
     FORMATETC *    pFmtetc,
     STGMEDIUM *    pstgmed
)
{
    HRESULT hr = NOERROR;

    if( SUCCEEDED(hr) &&  pstgmed->pstm )
    {

        m_UserStream = pstgmed->pstm;

        // Add ref again because we are copying and storing the ptr

        m_UserStream->AddRef();

    }

    if( SUCCEEDED(hr) || IS_E_PENDING(hr) )
        hr = CBaseBSCB::OnDataAvailable(grfBSCF,dwSize,pFmtetc,pstgmed);

    return(hr);
}

STDMETHODIMP
CPushDownload::GetBindInfo
(
        DWORD  *        grfBINDF,
    BINDINFO  * pbindinfo
)
{

    HRESULT hr = CBaseBSCB::GetBindInfo( grfBINDF, pbindinfo );

    // PushDownload can not be ASYNC
    if (*grfBINDF & BINDF_ENFORCERESTRICTED)
        *grfBINDF = BINDF_ENFORCERESTRICTED;
    else
        *grfBINDF = 0;

    return(hr);
}
//----------------------------------------------------------
//
//      Block Stream API
//
//----------------------------------------------------------

class CBlockDownload : public CPushDownload
{
public:
    CBlockDownload( IUnknown * caller, DWORD bscof, LPUOSCALLBACK callback );
    ~CBlockDownload();
    STDMETHODIMP GetBindInfo(
         DWORD  *grfBINDF,
         BINDINFO  *pbindinfo);
    HRESULT GetStream( IStream ** ppStream );
};


inline
CBlockDownload::CBlockDownload( IUnknown * caller, DWORD bscof, LPUOSCALLBACK callback )
    : CPushDownload(caller,bscof, callback)
{

}

template <class T> inline
HRESULT CheckThis( T * AThisPtr )
{
    CHECK_INTERFACE(AThisPtr);
    return(NOERROR);
}

CBlockDownload::~CBlockDownload()
{
    CheckThis(this);
}

HRESULT
CBlockDownload::GetStream( IStream ** ppStream )
{
    // REMEMBER: If you get this pointer and return it
    // to caller YOU MUST add ref it before handing
    // it back via an API

    HRESULT hr = E_FAIL;

    if( m_UserStream )
    {
        *ppStream = m_UserStream;
        hr = S_OK;
    }

    return( hr );
}

STDMETHODIMP
CBlockDownload::GetBindInfo
(
    DWORD      * grfBINDF,
    BINDINFO  * pbindinfo
)
{
    HRESULT hr = CBaseBSCB::GetBindInfo( grfBINDF, pbindinfo );

    return(hr);
}
//----------------------------------------------------------
//
//      Download to file
//
//----------------------------------------------------------

//
// This class implements the File downloading code. It reads from the
// stream from urlmon and writes every buffer directly to disk.
//

class CFileDownload : public CBaseBSCB
{
public:
        CFileDownload( IUnknown * caller, DWORD bscof, LPUOSCALLBACK callback, LPCWSTR szFileName=0);
        ~CFileDownload();
    void SetFileName(LPCWSTR);

    STDMETHODIMP OnDataAvailable(
             DWORD grfBSCF,
             DWORD dwSize,
             FORMATETC  *pformatetc,
             STGMEDIUM  *pstgmed);

    STDMETHODIMP GetBindInfo(
             DWORD  *grfBINDF,
             BINDINFO  *pbindinfo);

    STDMETHOD(KickOffDownload)( LPCWSTR szURL );

    virtual void Neutralize();

private:
    HRESULT Cleanup();

    unsigned char * m_buffer;
    unsigned long   m_bufsize;
    HANDLE          m_file;
    LPCWSTR         m_filename;
    ULONG           m_okFromCache;

};

inline void
CFileDownload::SetFileName(LPCWSTR newFileName)
{
    // ASSUMES Calls to this class are synchronous

    m_filename = newFileName;
}


CFileDownload::CFileDownload
(
        IUnknown *              caller,
        DWORD                   bscof,
        LPUOSCALLBACK            callback,
        LPCWSTR                 szFileName
)
        : CBaseBSCB(caller, bscof, callback)
{
        m_buffer   = 0;
        m_bufsize  = 0;
        m_file     = INVALID_HANDLE_VALUE;
        m_filename = szFileName;

        m_okFromCache = 0;
}

CFileDownload::~CFileDownload()
{
        Cleanup();
}

STDMETHODIMP
CFileDownload::KickOffDownload( LPCWSTR szURL )
{
    // MAGIC: registry flag determines whether we
    // nuke this guy from the cache or not

    GetDLMRegDWord( _TEXT("CacheOk"), &m_okFromCache );
    return( CBaseBSCB::KickOffDownload(szURL) );
}

HRESULT CFileDownload::Cleanup()
{
        if( m_buffer )
        {
                delete m_buffer;
                m_buffer = 0;
        }

        if( m_file != INVALID_HANDLE_VALUE )
        {
                CloseHandle(m_file);
                m_file = INVALID_HANDLE_VALUE;
        }

        return(NOERROR);
}

STDMETHODIMP
CFileDownload::GetBindInfo
(
        DWORD     * grfBINDF,
        BINDINFO  * pbindinfo
)
{

    HRESULT hr = CBaseBSCB::GetBindInfo( grfBINDF, pbindinfo );

    if( SUCCEEDED(hr) && !m_okFromCache )
    {
        if (*grfBINDF & BINDF_ENFORCERESTRICTED)
            *grfBINDF = BINDF_ENFORCERESTRICTED | BINDF_PULLDATA;
        else
            *grfBINDF =  BINDF_PULLDATA;
    }
    
    return(hr);
}


STDMETHODIMP
CFileDownload::OnDataAvailable
(
    DWORD       grfBSCF,
    DWORD       dwSize,
    FORMATETC  *pformatetc,
    STGMEDIUM  *pstgmed
)
{
    // Pointers are validated in base class

    HRESULT hr = CBaseBSCB::OnDataAvailable(grfBSCF,dwSize,pformatetc,pstgmed);

    if( FAILED(hr) || (dwSize == m_readSoFar) )
        return(hr);

    if( (m_file == INVALID_HANDLE_VALUE)  && dwSize )
    {
        CHECK_POINTER(m_filename);

        hr = MyCreateFile(m_filename,m_file);

        if( FAILED(hr) )
            hr = E_ABORT;
    }

    HANDLE_ABORT(hr);

    UOSASSERT( (m_file != INVALID_HANDLE_VALUE) );

    // Only allocate a read buffer if the one we have is not
    // big enough.

    if( m_buffer && (m_bufsize < (dwSize- m_readSoFar+1)) )
    {
        delete m_buffer;
        m_buffer = 0;
        m_bufsize=0;
    }

    if( !m_buffer )
    {
        m_bufsize=dwSize- m_readSoFar+1;
        DPRINTF( ("Allocating read buffer %d\n",m_bufsize) );
        m_buffer = new unsigned char [(dwSize- m_readSoFar+1)];
    }

    CHECK_MEMORY(m_buffer);

    DWORD dwReadThisMuch = dwSize - m_readSoFar;
    DWORD dwActual       = 0;
    DWORD dwCurrentRead  = 0;

    unsigned char * temp = m_buffer;
    do
    {
        hr = m_UserStream->Read(temp,dwReadThisMuch,&dwActual);
        dwCurrentRead += dwActual;
        dwReadThisMuch -= dwActual;
        temp += dwActual;

    }
    while (!(hr == S_FALSE || hr == E_PENDING) && SUCCEEDED(hr));

    if( dwCurrentRead )
    {
        m_readSoFar += (dwReadThisMuch = dwCurrentRead);

        BOOL bWriteOk = ::WriteFile(
                            m_file, // HANDLE  hFile,    // handle to file to write to
                            m_buffer, // LPCVOID  lpBuffer,    // pointer to data to write to file
                            dwReadThisMuch,        // DWORD  nNumberOfBytesToWrite,    // number of bytes to write
                            &dwActual,    // pointer to number of bytes written
                            0 ); // LPOVERLAPPED  lpOverlapped     // addr. of structure needed for overlapped

        if( !bWriteOk )
            hr = E_FAIL;
    }

    // PUMPREAD(pstgmed->pstm);

    if (grfBSCF & BSCF_LASTDATANOTIFICATION)
    {
        CloseHandle(m_file);
        m_file = INVALID_HANDLE_VALUE;
    }

    return( hr );
}
void
CFileDownload::Neutralize()
{
    // We have to do special cleanup.

    Cleanup();

    CBaseBSCB::Neutralize();
}


//----------------------------------------------------------
//
//      Download to Cache file
//  Implementation of the CCacheFileDownload
//
//----------------------------------------------------------
// This class downloads the file to the cache and returns the cache file name
class CCacheFileDownload : public CBaseBSCB
{
public:
        CCacheFileDownload( IUnknown * caller, DWORD bscof, LPUOSCALLBACK callback, LPCWSTR szFileName=0);
        ~CCacheFileDownload();

    STDMETHODIMP OnDataAvailable(
             DWORD grfBSCF,
             DWORD dwSize,
             FORMATETC  *pformatetc,
             STGMEDIUM  *pstgmed);

    STDMETHODIMP GetBindInfo(
             DWORD  *grfBINDF,
             BINDINFO  *pbindinfo);

    STDMETHOD(KickOffDownload)( LPCWSTR szURL );
private:
        DWORD m_readSoFar;
};

CCacheFileDownload::CCacheFileDownload
(
        IUnknown *              caller,
        DWORD                   bscof,
        LPUOSCALLBACK   callback,
        LPCWSTR                 szFileName
)
        : CBaseBSCB(caller, bscof, callback)
{
        m_readSoFar=0;
}

CCacheFileDownload::~CCacheFileDownload()
{
//      Cleanup();
}

STDMETHODIMP
CCacheFileDownload::KickOffDownload( LPCWSTR szURL )
{
    return( CBaseBSCB::KickOffDownload(szURL) );
}

STDMETHODIMP
CCacheFileDownload::GetBindInfo
(
    DWORD     * grfBINDF,
    BINDINFO  * pbindinfo
)
{
    HRESULT hr = CBaseBSCB::GetBindInfo( grfBINDF, pbindinfo );
    *grfBINDF &= ~BINDF_ASYNCHRONOUS; //to fix MSN 5.0 bug 103719.
    return(hr);
}


#define READBLOCKSIZE 8192

STDMETHODIMP
CCacheFileDownload::OnDataAvailable
(
    DWORD       grfBSCF,
    DWORD       dwSize,
    FORMATETC  *pformatetc,
    STGMEDIUM  *pstgmed
)
{
    // Pointers are validated in base class
    HRESULT hr = CBaseBSCB::OnDataAvailable(grfBSCF,dwSize,pformatetc,pstgmed);

    if( FAILED(hr) || (dwSize == m_readSoFar) )
        return(hr);

    IStream * pstm = pstgmed->pstm;
    if (pstm && dwSize > m_readSoFar)
    {
        DWORD dwToRead = dwSize - m_readSoFar;
        DWORD dwActuallyRead = 1; //initialize to force it into loop
        char* lp = NULL;
   
        lp = new char[READBLOCKSIZE+1];
            
        CHECK_MEMORY(lp);

        while (dwActuallyRead)
        {
            dwActuallyRead=0;
            hr = pstm->Read(lp, READBLOCKSIZE, &dwActuallyRead);

            if(hr!=S_OK && hr!=E_PENDING)  // If Read Fails then return Error
                break;
                
            m_readSoFar += dwActuallyRead;
        }
        delete lp;
    }
    return (hr);
}



STDAPI
URLOpenPullStreamW
(
    LPUNKNOWN                   caller,
    LPCWSTR                     szURL,
    DWORD                       dwReserved,
    LPUOSCALLBACK               callback
)
{
    CHECK_POINTER(szURL);

    HRESULT hr;

    CPullDownload * download = new CPullDownload(caller,URLOSTRM_NOTIFY_ONDATA,callback);

    CHECK_POINTER(download);

    if( !download )
        hr = E_OUTOFMEMORY;
    else
    {
        download->SetEncodingFlags(dwReserved);
        hr = download->KickOffDownload(szURL);
    }

    return(hr);
}

STDAPI
URLDownloadToFileW
(
    LPUNKNOWN            caller,
    LPCWSTR             szURL,
    LPCWSTR             szFileName,
    DWORD               dwReserved,
    LPUOSCALLBACK       callback
)
{
    CHECK_POINTER(szURL);
        HRESULT hr;


    CFileDownload * strm = new CFileDownload(caller,URLOSTRM_DONOT_NOTIFY_ONDATA,callback,szFileName);

    CHECK_POINTER(strm);


    if( !strm )
        hr = E_OUTOFMEMORY;
    else
        {
        strm->AddRef(); // So that we have valid handle even after OnStopBinding()
        strm->SetEncodingFlags(dwReserved);
        hr = strm->KickOffDownload(szURL);
        }

    if (strm)
        strm->Release();
    return(hr);
}


extern void DoThreadCleanup(BOOL bInThreadDetach);
extern BOOL  g_bNT5OrGreater;

STDAPI
URLDownloadToCacheFileW
(
    LPUNKNOWN            caller,
    LPCWSTR             szURL,
    LPWSTR              szFileName,
    DWORD               dwBufLength,
    DWORD               dwReserved,
    LPUOSCALLBACK       callback
)
{
        CHECK_POINTER(szURL);

        HRESULT hr=S_OK;

        BOOL fFileURL = FALSE;

        if (dwBufLength <= 0)
        {
            hr = E_OUTOFMEMORY; // Buffer length invalid
            return hr;
        }

        //
        // 1,2, and 3 are reserved for the constants
        // URLOSTRM_USECACHE, CACHEONLY and GETNEWESTVERSION constants
        // For Compatibility with previous versions
        //
        dwBufLength = (dwBufLength < 4) ? MAX_PATH : dwBufLength;
        szFileName[0] = NULL;
        // For Cache calls
        MAKE_ANSI(szURL);


        CCacheFileDownload * strm = new CCacheFileDownload(caller,dwBufLength,callback,szFileName);

        CHECK_POINTER(strm);

        if( !strm )
        {
             hr = E_OUTOFMEMORY;
        }
        else
        {
             strm->AddRef(); // So that we have valid handle even after OnStopBinding()
             strm->SetEncodingFlags(dwReserved);
             hr = strm->KickOffDownload(szURL);
        }

        if(SUCCEEDED(hr))
        {
            if (*strm->m_szCacheFileName)
            {
                // If it is a file URL we have to convert it to WIN32 file
                CHAR szPath[MAX_PATH];
                DWORD cchPath = MAX_PATH;

                if(SUCCEEDED(PathCreateFromUrl(strm->m_szCacheFileName, szPath, &cchPath, 0)))
                {
                    fFileURL = TRUE;
                    //  url should now look like a DOS path
                    if (0==MultiByteToWideChar(CP_ACP, 0, 
                                    szPath,-1,
                                    szFileName, dwBufLength))
                    {
                        hr = E_OUTOFMEMORY;
                        szFileName[0] = NULL;
                    }
                    else
                        hr=S_OK;
                }
                if (!fFileURL)
                {
                    if (0==MultiByteToWideChar(CP_ACP, 0, strm->m_szCacheFileName,
                               lstrlen(strm->m_szCacheFileName)+1,
                               szFileName, dwBufLength))
                    {
                         hr = E_OUTOFMEMORY;
                         szFileName[0] = NULL;
                    }
                    else
                         hr=S_OK;
                }
            }
            else
                hr = E_FAIL;
        }

        if (strm)
            strm->Release();

        // WinSE QFE #3411
        // At a minimum, we may need to cleanup the notification hwnd created
        // because this thread can become unresponsive if a broadcast message
        // is sent and the client app isn't pumping messages on this thread.
        // We'll go ahead an do a full tls cleanup.

        // If this is NOT NT5 or greater, then our notification window is not a message window.
        // Clean up our thread data if no other activity on this thread.
        //
        if (!g_bNT5OrGreater)
        {
            DoThreadCleanup(FALSE);
        }

        return(hr);
}


STDAPI
URLOpenBlockingStreamW
(
    LPUNKNOWN            caller,
    LPCWSTR             szURL,
    LPSTREAM*            ppStream,
    DWORD               dwReserved,
    LPUOSCALLBACK       callback
)
{
    CHECK_POINTER(szURL);
    CHECK_POINTER(ppStream);
    HRESULT hr;

    if (!ppStream)
        return E_INVALIDARG;
        
    CBlockDownload * strm = new CBlockDownload(caller,URLOSTRM_DONOT_NOTIFY_ONDATA,callback);

    CHECK_POINTER(strm);
    if( !strm )
        hr = E_OUTOFMEMORY;
    else
    {
        strm->AddRef();
        strm->SetEncodingFlags(dwReserved);
        hr = strm->KickOffDownload(szURL);
    }


    if( SUCCEEDED(hr) )
    {
        hr = strm->GetStream(ppStream);

        // We add ref this pointer because we are handing
        // it back to the user

        if( SUCCEEDED(hr) )
           (*ppStream)->AddRef();
    }

    if (strm)
        strm->Release();

    return(hr);
}


STDAPI
URLOpenStreamW
(
    LPUNKNOWN            caller,
    LPCWSTR             szURL,
    DWORD               dwReserved,
    LPUOSCALLBACK       callback
)
{
    CHECK_POINTER(szURL);
        HRESULT hr;


    CPushDownload * strm = new CPushDownload(caller,URLOSTRM_NOTIFY_ONDATA,callback);

    CHECK_POINTER(strm);

    if( !strm )
        hr = E_OUTOFMEMORY;
    else
    {
        strm->SetEncodingFlags(dwReserved);
        hr = strm->KickOffDownload(szURL);
    }

    return(hr);
}


//
//   ANSI VERSION OF PUBLIC API
//

STDAPI
URLOpenPullStreamA
(
    LPUNKNOWN                    caller,
    LPCSTR                      szURL,
    DWORD                       dwReserved,
    LPUOSCALLBACK               callback
)
{
    MAKE_WIDE(szURL);

    return( URLOpenPullStreamW(caller, WIDE_NAME(szURL), dwReserved, callback) );
}

STDAPI
URLDownloadToFileA
(
    LPUNKNOWN            caller,
    LPCSTR              szURL,
    LPCSTR              szFileName,
    DWORD               dwReserved,
    LPUOSCALLBACK       callback
)
{
    MAKE_WIDE(szURL);
    MAKE_WIDE(szFileName);

    return( URLDownloadToFileW( caller, WIDE_NAME(szURL), WIDE_NAME(szFileName),dwReserved, callback ) );
}

STDAPI
URLDownloadToCacheFileA
(
    LPUNKNOWN            caller,
    LPCSTR              szURL,
    LPSTR               szFileName,
    DWORD               dwBufLength,
    DWORD               dwReserved,
    LPUOSCALLBACK       callback
)
{
        HRESULT hr=E_OUTOFMEMORY;

        if (dwBufLength <= 0)
            return hr;

        MAKE_WIDE(szURL);
        LPWSTR lpwszfilename= new WCHAR[MAX_PATH];

        if (lpwszfilename!=NULL)
        {
                hr=URLDownloadToCacheFileW( caller, WIDE_NAME(szURL), lpwszfilename, MAX_PATH, dwReserved, callback );

                if (SUCCEEDED(hr))
                {
                        // Convert to ANSI.
                        dwBufLength = (dwBufLength < 4) ? MAX_PATH : dwBufLength;
                        if (0==WideCharToMultiByte(     CP_ACP, 0, lpwszfilename, lstrlenW(lpwszfilename)+1,szFileName,
                                                                                dwBufLength, NULL, NULL))
                        {
                                hr = E_OUTOFMEMORY;
                                szFileName[0] = NULL;
                        }
                }
                else
                    szFileName[0] = NULL;
        delete[] lpwszfilename;
        }
        return(hr);
}

STDAPI
URLOpenBlockingStreamA
(
    LPUNKNOWN            caller,
    LPCSTR              szURL,
    LPSTREAM*            ppStream,
    DWORD               dwReserved,
    LPUOSCALLBACK       callback
)
{
    MAKE_WIDE(szURL);

    return( URLOpenBlockingStreamW(caller,WIDE_NAME(szURL),ppStream,dwReserved,callback) );
}


STDAPI
URLOpenStreamA
(
    LPUNKNOWN            caller,
    LPCSTR              szURL,
    DWORD               dwReserved,
    LPUOSCALLBACK       callback
)
{
    MAKE_WIDE(szURL);

    return( URLOpenStreamW(caller,WIDE_NAME(szURL),dwReserved,callback) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\urlhlink\daytona\makefile.inc ===
obj\*\urlhlink.def: urlhlink.src

!IF $(386)
!IF "$(LINKONLY)"!=""
#MAPSYM=$(_WINBASE)\dev\tools\common\mapsym.exe -nologo
MAPSYM=mapsym.exe -nologo

!IF EXIST($(TARGETPATH)\i386\urlhlink.map)
# generate the sym file from the map file
urlhlink.sym:      $(TARGETPATH)\i386\urlhlink.map
        $(MAPSYM) -o $(TARGETPATH)\i386\urlhlink.sym $(TARGETPATH)\i386\urlhlink.map
        binplace -R $(_NTTREE) $(TARGETPATH)\i386\urlhlink.sym
        binplace -R $(_NTTREE) $(TARGETPATH)\i386\urlhlink.map
!else
# generate the sym file from the dll with coff symbols
urlhlink.sym:      $(TARGETPATH)\i386\urlhlink.lib
        $(MAPSYM) -o $(TARGETPATH)\i386\urlhlink.sym $(TARGETPATH)\i386\urlhlink.map
        binplace -R $(_NTTREE) $(TARGETPATH)\i386\urlhlink.sym
        binplace -R $(_NTTREE) $(TARGETPATH)\i386\urlhlink.map
!endif
!else
urlhlink.sym:      $(TARGETPATH)\i386\urlhlink.map
        echo Only build sym file during link phase.
!endif

!endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\urltrack\trkapia.cxx ===
// 
// Pei-Hwa Lin (peiwhal), July 25, 1997
//

#include "urltrk.h"

#define TRACK_FLAGS (TRACK_OFFLINE_CACHE_ENTRY | TRACK_ONLINE_CACHE_ENTRY)

#ifdef unix
extern "C"
#endif /* unix */
BOOL WINAPI
IsLoggingEnabledA
(
    IN LPCSTR  pszUrl
)
{
    CHAR        szCanonicalUrl[INTERNET_MAX_URL_LENGTH];
    DWORD       dwSize = INTERNET_MAX_URL_LENGTH;
    BOOL        fTrack = FALSE;
    ULONG       dwTrack;

    // canonicalize URL
    InternetCanonicalizeUrlA(pszUrl, szCanonicalUrl, &dwSize, ICU_DECODE);
 
    dwTrack = _IsLoggingEnabled(szCanonicalUrl);
      
    fTrack = (dwTrack & TRACK_FLAGS);
    SetLastError(0);
    return fTrack;

}


BOOL WINAPI
WriteHitLogging
(
    IN LPHIT_LOGGING_INFO lpLogInfo
)
{
    CHAR        szCanonicalUrl[INTERNET_MAX_URL_LENGTH];
    DWORD       dwSize = INTERNET_MAX_URL_LENGTH;
    BOOL        bRet = FALSE;
    BOOL        foffline;
    ULONG       dwTrack; 
    MY_LOGGING_INFO  mLi;

    if (!lpLogInfo->lpszLoggedUrlName)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return bRet;
    }

    // canonicalize URL
    InternetCanonicalizeUrlA(lpLogInfo->lpszLoggedUrlName, szCanonicalUrl, &dwSize, ICU_DECODE);
 
    // don't log if it's disalbed at first place
    dwTrack = _IsLoggingEnabled(szCanonicalUrl);

    foffline = IsGlobalOffline();
    if (dwTrack & TRACK_FLAGS)
    {
        if (((dwTrack & TRACK_OFFLINE_CACHE_ENTRY) && foffline) ||
            ((dwTrack & TRACK_ONLINE_CACHE_ENTRY) && !foffline))
        {
            mLi.pLogInfo = lpLogInfo;
            mLi.fOffLine = foffline;
            bRet = _WriteHitLogging(&mLi);
        }
    }
    else
    {
        SetLastError(0);
        bRet = TRUE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\urltrack\urltrk.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       urltrack.h
//
//  Contents:   precompiled header file for the urltrack directory
//
//  Classes:
//
//  Functions:
//
//  History:    07-25-97   PeihwaL   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <windowsx.h>
#include <ole2.h>               // to get IStream for image.c
#define DISALLOW_Assert
#include <debug.h>
#include <winerror.h>
#include <winnlsp.h>
#include <wininet.h>
#include <winineti.h>
#include <urlmon.h>

typedef struct _MY_LOGGING_INFO {
   LPHIT_LOGGING_INFO   pLogInfo;
   BOOL                 fuseCache;
   BOOL                 fOffLine;
} MY_LOGGING_INFO, * LPMY_LOGGING_INFO;


ULONG _IsLoggingEnabled(LPCSTR  pszUrl);
BOOL  _WriteHitLogging(LPMY_LOGGING_INFO pLogInfo);

BOOL   IsGlobalOffline(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\urltrack\trkapiw.cxx ===
// 
// Pei-Hwa Lin (peiwhal), July 17, 1997
//

#include "urltrk.h"

#ifdef unix
extern "C"
#endif /* unix */
BOOL WINAPI
IsLoggingEnabledW
(
    IN LPCWSTR  pwszUrl
)
{
    DWORD       cbSize;
    LPSTR       lpUrl = NULL;
    BOOL        bRet = FALSE;

    if (pwszUrl == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return bRet;
    }

    cbSize = lstrlenW(pwszUrl) + sizeof(WCHAR);
    lpUrl = (LPSTR)LocalAlloc(LPTR, cbSize);
    if (!lpUrl)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return bRet;
    }

    int i=WideCharToMultiByte(CP_ACP, 0, pwszUrl, -1, lpUrl,
                    cbSize, NULL, NULL);
    if (!i)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        LocalFree(lpUrl);
        return bRet;
    }

    bRet = IsLoggingEnabledA(lpUrl);
    LocalFree(lpUrl);
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\urltrack\util.cxx ===
/*-------------------------------------------------------*/
//Copyright (c) 1997  Microsoft Corporation
//
//    Util.cpp
//
//Author:
//
//
//Environment:
//
//    User Mode - Win32
//
//Revision History:
/*-------------------------------------------------------*/

#include "urltrk.h"
#include <inetreg.h>

const CHAR c_szLogFormat[] = "hh':'mm':'ss";
const CHAR c_szMode[] = "U";       // unknown
const CHAR c_szLogContainerA[] = "Log";

#define MY_CACHE_ENTRY_INFO_SIZE    512
#define MY_MAX_STRING_LEN           512

BOOL   ConvertToPrefixedURL(LPCSTR lpszUrl, LPSTR *lplpPrefixedUrl);
LPINTERNET_CACHE_ENTRY_INFOA QueryCacheEntry(LPCSTR lpUrl);
HANDLE GetLogFile(LPCSTR lpUrl, LPINTERNET_CACHE_ENTRY_INFOA pce, LPSTR lpFile);
LPSTR GetLogString(LPMY_LOGGING_INFO lpLogInfo);


ULONG _IsLoggingEnabled(LPCSTR  pszUrl)
{
    LPINTERNET_CACHE_ENTRY_INFOA pce;
    LPSTR   lpPfxUrl = NULL;
    ULONG   dwTrack;

    //
    ConvertToPrefixedURL(pszUrl, &lpPfxUrl);
    if (!lpPfxUrl)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    pce = QueryCacheEntry(lpPfxUrl);
    if (!pce)
    {
        GlobalFree(lpPfxUrl);
        SetLastError(ERROR_FILE_NOT_FOUND);
        return 0;
    }

    dwTrack = pce->CacheEntryType;
    GlobalFree(pce);
    GlobalFree(lpPfxUrl);
    return dwTrack; 
}

BOOL _WriteHitLogging(LPMY_LOGGING_INFO pmLi)
{
    LPSTR   lpLogString = NULL;
    LPSTR   lpPfxUrl = NULL;
    LPINTERNET_CACHE_ENTRY_INFOA pce = NULL;
    HANDLE  hFile;
    CHAR    lpFile[MAX_PATH];
    DWORD   dwWritten = 0;
    BOOL    fuseCache;
    BOOL    bRet = FALSE;

    //
    ConvertToPrefixedURL(pmLi->pLogInfo->lpszLoggedUrlName, &lpPfxUrl);
    if (!lpPfxUrl)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return bRet;
    }

    pce = QueryCacheEntry(lpPfxUrl);
    if (!pce)
    {
        GlobalFree(lpPfxUrl);
        SetLastError(ERROR_FILE_NOT_FOUND);
        return bRet;
    }

    hFile = GetLogFile(lpPfxUrl, pce, &lpFile[0]);
    if (hFile == NULL)
    {
        GlobalFree(lpPfxUrl);
        GlobalFree(pce);
        SetLastError(ERROR_FILE_NOT_FOUND);
        return bRet;
    }
    
    pmLi->fuseCache = GetUrlCacheEntryInfoExA(pmLi->pLogInfo->lpszLoggedUrlName, NULL, NULL, NULL, NULL, NULL, 0);
    lpLogString = GetLogString(pmLi);
    if (!lpLogString)
    {
        GlobalFree(lpPfxUrl);
        GlobalFree(pce);
        CloseHandle(hFile);
        return bRet; 
    }

    bRet = WriteFile(hFile, lpLogString, lstrlenA(lpLogString), &dwWritten, NULL);
       
    CloseHandle(hFile);
    GlobalFree(lpLogString);
    
    // commit change to cache
    if(bRet)
    {
        bRet = CommitUrlCacheEntry(lpPfxUrl, 
                lpFile,    //
                pce->ExpireTime,                    //ExpireTime
                pce->LastModifiedTime,              //LastModifiedTime
                pce->CacheEntryType,
                NULL,                               //lpHeaderInfo
                0,                                  //dwHeaderSize
                NULL,                               //lpszFileExtension
                0);                              //reserved
    }
    
    // free pce
    GlobalFree(pce);
    GlobalFree(lpPfxUrl);

    return bRet;
}


BOOL IsGlobalOffline(void)
{
    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;
#ifdef _SBS_
    HMODULE hModuleHandle = GetModuleHandleA("sbswinet.dll");
#else
    HMODULE hModuleHandle = GetModuleHandleA("wininet.dll");
#endif // _SBS_

    if(!hModuleHandle)
        return FALSE;

    if(InternetQueryOptionA(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState,
        &dwSize))
    {
        if(dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }

    return fRet;
}

//
// Helper Functions
//
LPSTR GetLogString(LPMY_LOGGING_INFO pmLi)
{
    FILETIME   ftIn, ftOut;
    ULARGE_INTEGER ulIn, ulOut, ulTotal;
    SYSTEMTIME  stIn, stOut;
    LPSTR      lpData = NULL;
    CHAR       pTimeIn[10], pTimeOut[10];
              
    lpData = (LPSTR)GlobalAlloc(LPTR, lstrlenA(pmLi->pLogInfo->lpszExtendedInfo)+MY_MAX_STRING_LEN);
    if (!lpData)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    // calculate delta of time
    SystemTimeToFileTime(&(pmLi->pLogInfo->StartTime), &ftIn);
    SystemTimeToFileTime(&(pmLi->pLogInfo->EndTime), &ftOut);

	ulIn.LowPart = ftIn.dwLowDateTime;
	ulIn.HighPart = ftIn.dwHighDateTime;
	ulOut.LowPart = ftOut.dwLowDateTime;
	ulOut.HighPart = ftOut.dwHighDateTime;
#ifndef unix
	ulTotal.QuadPart = ulOut.QuadPart - ulIn.QuadPart;
#else
        U_QUAD_PART(ulTotal) = U_QUAD_PART(ulOut) - U_QUAD_PART(ulIn);
#endif /* unix */    
    ftOut.dwLowDateTime = ulTotal.LowPart;
    ftOut.dwHighDateTime = ulTotal.HighPart;
    FileTimeToSystemTime(&ftOut, &stOut);
    stIn = pmLi->pLogInfo->StartTime;

    // log string: timeEnter+Duration
    GetTimeFormat(LOCALE_SYSTEM_DEFAULT, TIME_FORCE24HOURFORMAT, &stIn, c_szLogFormat, pTimeIn, 10);
    GetTimeFormat(LOCALE_SYSTEM_DEFAULT, TIME_FORCE24HOURFORMAT, &stOut, c_szLogFormat, pTimeOut, 10);

    if (!pmLi->pLogInfo->lpszExtendedInfo)
    {
        wsprintf(lpData, "%s %d %.2d-%.2d-%d %s %s\r\n", c_szMode, 
                                pmLi->fuseCache, 
                                stIn.wMonth, stIn.wDay, stIn.wYear,
                                pTimeIn, pTimeOut);
    }
    else
    {
        wsprintf(lpData, "%s %d %.2d-%.2d-%d %s %s %s\r\n", c_szMode, 
                                pmLi->fuseCache, 
                                stIn.wMonth, stIn.wDay, stIn.wYear,
                                pTimeIn, pTimeOut,
                                pmLi->pLogInfo->lpszExtendedInfo);
    }

    return lpData;
}


LPSTR ReadTrackingPrefix(void)
{
    LPSTR  lpPfx = NULL;

    DWORD   cbPfx = 0;
    struct {
        INTERNET_CACHE_CONTAINER_INFOA cInfo;
        CHAR  szBuffer[MAX_PATH+INTERNET_MAX_URL_LENGTH+1];
    } ContainerInfo;
    DWORD   dwModified, dwContainer;
    HANDLE  hEnum;
  
    dwContainer = sizeof(ContainerInfo);
    hEnum = FindFirstUrlCacheContainerA(&dwModified,
                                       &ContainerInfo.cInfo,
                                       &dwContainer,
                                       0);

    if (hEnum)
    {

        for (;;)
        {
            if (!lstrcmpiA(ContainerInfo.cInfo.lpszName, c_szLogContainerA))
            {
                if (ContainerInfo.cInfo.lpszCachePrefix[0])
                {
                    DWORD cb = lstrlenA(ContainerInfo.cInfo.lpszCachePrefix)+sizeof(CHAR);
                    lpPfx = (LPSTR)GlobalAlloc(LPTR, cb);
                    if (!lpPfx)
                    {
                        SetLastError(ERROR_OUTOFMEMORY);
                        break;
                    }

                    lstrcpynA(lpPfx, ContainerInfo.cInfo.lpszCachePrefix, cb);
                }				
                break;
            }

            dwContainer = sizeof(ContainerInfo);
            if (!FindNextUrlCacheContainerA(hEnum, &ContainerInfo.cInfo, &dwContainer))
            {
                if (GetLastError() == ERROR_NO_MORE_ITEMS)
                    break;
            }

        }

        FindCloseUrlCache(hEnum);
    }
   
    return lpPfx;
}


// caller must free lplpPrefixedUrl
BOOL 
ConvertToPrefixedURL(LPCSTR lpszUrl, LPSTR *lplpPrefixedUrl)
{
    BOOL    bret = FALSE;
    LPTSTR  lpPfx = NULL;

    if (!lpszUrl)
        return bret;

    lpPfx = ReadTrackingPrefix();
    if (lpPfx)
    {
        *lplpPrefixedUrl = (LPSTR)GlobalAlloc(LPTR, lstrlenA(lpszUrl)+lstrlenA(lpPfx)+1);
        if (*lplpPrefixedUrl)
        {
            wsprintf(*lplpPrefixedUrl, "%s%s", lpPfx, lpszUrl);
            bret = TRUE;
        }

        GlobalFree(lpPfx);
    }

    return bret;
}

LPINTERNET_CACHE_ENTRY_INFOA
QueryCacheEntry(LPCSTR lpUrl)
{
    // get cache entry info
    LPINTERNET_CACHE_ENTRY_INFOA   lpCE = NULL;
    DWORD    dwEntrySize;
    BOOL     bret = FALSE;

    lpCE = (LPINTERNET_CACHE_ENTRY_INFOA)GlobalAlloc(LPTR, MY_CACHE_ENTRY_INFO_SIZE);
    if (lpCE)
    {
        dwEntrySize = MY_CACHE_ENTRY_INFO_SIZE;

        while (!(bret = GetUrlCacheEntryInfoA(lpUrl, lpCE, &dwEntrySize)))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                GlobalFree(lpCE);

                lpCE = (LPINTERNET_CACHE_ENTRY_INFOA)GlobalAlloc(LPTR, dwEntrySize);
                if (!lpCE)
                    break;
            }
            else
                break;
        }
    }

    if (!bret && lpCE)
    {
        GlobalFree(lpCE);
        lpCE = NULL;
        SetLastError(ERROR_FILE_NOT_FOUND);
    }

    return lpCE;

}

HANDLE GetLogFile(LPCSTR lpUrl, LPINTERNET_CACHE_ENTRY_INFOA pce, LPSTR lpFile)
{
    HANDLE  hFile = NULL;    

    // work around -- begin
    if (!CreateUrlCacheEntry(lpUrl, 512, "log", lpFile, 0))
        return NULL;
    
    if (pce->lpszLocalFileName)
    {
        if (!CopyFile(pce->lpszLocalFileName, lpFile, FALSE))
            return NULL;

        DeleteFile(pce->lpszLocalFileName);
    }
    // work around -- end

    hFile = CreateFile(lpFile,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,  // | FILE_FLAG_SEQUENTIAL_SCAN,  
            NULL);
    
    if (hFile == INVALID_HANDLE_VALUE)
        return NULL;        

    // move file pointer to end
    if (0xFFFFFFFF == SetFilePointer(hFile, 0, 0, FILE_END))
    {
        CloseHandle(hFile);
        hFile = NULL;
    }
    
    return hFile;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\afxplex_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXPLEX_H__
#define __AFXPLEX_H__

#ifndef __AFX_H__
//        #include <afx.h>
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef AFX_COLL_SEG
#pragma code_seg(AFX_COLL_SEG)
#endif

struct CPlex     // warning variable length structure
{
        CPlex* pNext;
#if (_AFX_PACKING >= 8)
        DWORD dwReserved[1];    // align on 8 byte boundary
#endif
        // BYTE data[maxNum*elementSize];

        void* data() { return this+1; }

        static CPlex* PASCAL Create(CPlex*& head, UINT nMax, UINT cbElement);
                        // like 'calloc' but no zero fill
                        // may throw memory exceptions

        void FreeDataChain();       // free this one and links
};

#ifdef AFX_COLL_SEG
#pragma code_seg()
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#endif //__AFXPLEX_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\assert2.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       assert.cxx
//
//  Functions:  FnAssert
//              DbgDllSetSiftObject
//
//  History:     4-Jan-94   CraigWi     Created
//              16-Jun-94   t-ChriPi    Added DbgDllSetSiftObject
//
//----------------------------------------------------------------------------
#ifdef unix
#include <windows.h>
#endif /* unix */
#include <ole2.h>


STDAPI_(void) Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage);

//+-------------------------------------------------------------------
//
//  Function:   FnAssert, public
//
//  Synopsis:   Prints a message and optionally stops the program
//
//  Effects:    Simply maps to Win4AssertEx for now.
//
//  History:     4-Jan-94   CraigWi     Created for Win32 OLE2.
//
//--------------------------------------------------------------------

STDAPI FnAssert( LPSTR lpstrExpr, LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine )
{
#if DBG == 1
    char szMessage[1024];

    if (lpstrMsg == NULL)
        lstrcpyA(szMessage, lpstrExpr);
    else
        wsprintfA(szMessage, "%s; %s", lpstrExpr, lpstrMsg);

    Win4AssertEx(lpstrFileName, iLine, szMessage);
#endif
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\afxtempl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXTEMPL_H__
#define __AFXTEMPL_H__

#ifndef __AFXPLEX_H__
//#include <afxplex_.h>
//#include "..\utils\afxplex_.h"
#endif

#ifdef unix
#include <mainwin.h>
#endif /* unix */

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _DEBUG
static char _szAfxTempl[] = "afxtempl.h";
#undef THIS_FILE
#define THIS_FILE _szAfxTempl
#endif

#ifndef ALL_WARNINGS
#pragma warning(disable: 4114)
#endif

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)
/*
use our new for now
#ifdef new
#undef new
#define _REDEF_NEW
#endif

#ifndef _INC_NEW
        #include <new.h>
#endif
*/
template<class TYPE>
inline void AFXAPI ConstructElements(TYPE* pElements, int nCount)
{
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));

        // first do bit-wise zero initialization
        memset((void*)pElements, 0, nCount * sizeof(TYPE));

        // then call the constructor(s)
        for (; nCount--; pElements++)
        {
        }
}

template<class TYPE>
inline void AFXAPI DestructElements(TYPE* pElements, int nCount)
{
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));

        // call the destructor(s)
        for (; nCount--; pElements++)
                pElements->~TYPE();
}

template<class TYPE>
inline void AFXAPI CopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pDest, nCount * sizeof(TYPE)));
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pSrc, nCount * sizeof(TYPE)));

        // default is element-copy using assignment
        while (nCount--)
                *pDest++ = *pSrc;
}

template<class TYPE>
void AFXAPI SerializeElements(CArchive& ar, TYPE* pElements, int nCount)
{
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));

        // default is bit-wise read/write
        if (ar.IsStoring())
                ar.Write((void*)pElements, nCount * sizeof(TYPE));
        else
                ar.Read((void*)pElements, nCount * sizeof(TYPE));
}

#ifdef _DEBUG
#ifndef unix
template<class TYPE>
void AFXAPI DumpElements(CDumpContext& dc, const TYPE* pElements, int nCount)
{
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));
        &dc; // not used
        pElements;  // not used
        nCount; // not used

        // default does nothing
}
#endif /* unix */
#endif

template<class TYPE, class ARG_TYPE>
BOOL AFXAPI CompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
        ASSERT(AfxIsValidAddress(pElement1, sizeof(TYPE)));
        ASSERT(AfxIsValidAddress(pElement2, sizeof(ARG_TYPE)));

        return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT AFXAPI HashKey(ARG_KEY key)
{
        // default identity hash - works for most primitive values
        return PtrToUlong((void*)(DWORD_PTR)key) >> 4;
}

// special versions for CString
template<>
void AFXAPI ConstructElements(CString* pElements, int nCount);
template<>
void AFXAPI DestructElements(CString* pElements, int nCount);
template<>
void AFXAPI CopyElements(CString* pDest, const CString* pSrc, int nCount);
template<>
void AFXAPI SerializeElements(CArchive& ar, CString* pElements, int nCount);
template<>
UINT AFXAPI HashKey(LPCTSTR key);

// forward declarations
class COleVariant;
struct tagVARIANT;

// special versions for COleVariant
/*
void AFXAPI ConstructElements(COleVariant* pElements, int nCount);
void AFXAPI DestructElements(COleVariant* pElements, int nCount);
void AFXAPI CopyElements(COleVariant* pDest, const COleVariant* pSrc, int nCount);
void AFXAPI SerializeElements(CArchive& ar, COleVariant* pElements, int nCount);
void AFXAPI DumpElements(CDumpContext& dc, COleVariant* pElements, int nCount);
UINT AFXAPI HashKey(const struct tagVARIANT& var);
*/

// special versions for guids
//void AFXAPI ConstructElements(GUID* pElements, int nCount);
//void AFXAPI DestructElements(GUID* pElements, int nCount);
//void AFXAPI CopyElements(GUID* pDest, const GUID* pSrc, int nCount);
//void AFXAPI SerializeElements(CArchive& ar, GUID* pElements, int nCount);
//UINT AFXAPI HashKey(GUID key);

template<>
inline UINT AFXAPI HashKey(GUID Key)
{
   UINT hash = 0;
   BYTE FAR* lpb = (BYTE FAR*)&Key;
   UINT cbKey = sizeof(GUID);

   while (cbKey-- != 0)
        hash = 257 * hash + *lpb++;

   return hash;
}

template<>
inline UINT AFXAPI HashKey(SYSTEMTIME Key)
{
   UINT hash = 0;
   BYTE FAR* lpb = (BYTE FAR*)&Key;
   UINT cbKey = sizeof(SYSTEMTIME);

   while (cbKey-- != 0)
        hash = 257 * hash + *lpb++;

   return hash;
}
/*
inline UINT AFXAPI HashKey(IXY Key)
{
   UINT hash = 0;
   BYTE FAR* lpb = (BYTE FAR*)&Key;
   UINT cbKey = sizeof(IXY);

   while (cbKey-- != 0)
        hash = 257 * hash + *lpb++;

   return hash;
}
*/



//#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CArray : public CObject
{
public:
// Construction
        CArray();

// Attributes
        int GetSize() const;
        int GetUpperBound() const;
        void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
        // Clean up
        void FreeExtra();
        void RemoveAll();

        // Accessing elements
        TYPE GetAt(int nIndex) const;
        void SetAt(int nIndex, ARG_TYPE newElement);
        TYPE& ElementAt(int nIndex);

        // Direct Access to the element data (may return NULL)
        const TYPE* GetData() const;
        TYPE* GetData();

        // Potentially growing the array
        void SetAtGrow(int nIndex, ARG_TYPE newElement);
        int Add(ARG_TYPE newElement);
        int Append(const CArray& src);
        void Copy(const CArray& src);

        // overloaded operator helpers
        TYPE operator[](int nIndex) const;
        TYPE& operator[](int nIndex);

        // Operations that move elements around
        void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
        void RemoveAt(int nIndex, int nCount = 1);
        void InsertAt(int nStartIndex, CArray* pNewArray);

// Implementation
protected:
        TYPE* m_pData;   // the actual array of data
        int m_nSize;     // # of elements (upperBound - 1)
        int m_nMaxSize;  // max allocated
        int m_nGrowBy;   // grow amount

public:
        ~CArray();
        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetSize() const
        { return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetUpperBound() const
        { return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::RemoveAll()
        { SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
        { ASSERT(nIndex >= 0 && nIndex < m_nSize);
                return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
        { ASSERT(nIndex >= 0 && nIndex < m_nSize);
                m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
        { ASSERT(nIndex >= 0 && nIndex < m_nSize);
                return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
        { return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CArray<TYPE, ARG_TYPE>::GetData()
        { return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
        { int nIndex = m_nSize;
                SetAtGrow(nIndex, newElement);
                return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
        { return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::operator[](int nIndex)
        { return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::CArray()
{
        m_pData = NULL;
        m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::~CArray()
{
        ASSERT_VALID(this);

        if (m_pData != NULL)
        {
                DestructElements(m_pData, m_nSize);
                delete[] (BYTE*)m_pData;
        }
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
        ASSERT_VALID(this);
        ASSERT(nNewSize >= 0);

        if (nGrowBy != -1)
                m_nGrowBy = nGrowBy;  // set new size

        if (nNewSize == 0)
        {
                // shrink to nothing
                if (m_pData != NULL)
                {
                        DestructElements(m_pData, m_nSize);
                        delete[] (BYTE*)m_pData;
                        m_pData = NULL;
                }
                m_nSize = m_nMaxSize = 0;
        }
        else if (m_pData == NULL)
        {
                // create one with exact size
#ifdef SIZE_T_MAX
                ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
#endif
                m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
                ConstructElements(m_pData, nNewSize);
                m_nSize = m_nMaxSize = nNewSize;
        }
        else if (nNewSize <= m_nMaxSize)
        {
                // it fits
                if (nNewSize > m_nSize)
                {
                        // initialize the new elements
                        ConstructElements(&m_pData[m_nSize], nNewSize-m_nSize);
                }
                else if (m_nSize > nNewSize)
                {
                        // destroy the old elements
                        DestructElements(&m_pData[nNewSize], m_nSize-nNewSize);
                }
                m_nSize = nNewSize;
        }
        else
        {
                // otherwise, grow array
                int nGrowBy = m_nGrowBy;
                if (nGrowBy == 0)
                {
                        // heuristically determine growth when nGrowBy == 0
                        //  (this avoids heap fragmentation in many situations)
                        nGrowBy = m_nSize / 8;
                        nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
                }
                int nNewMax;
                if (nNewSize < m_nMaxSize + nGrowBy)
                        nNewMax = m_nMaxSize + nGrowBy;  // granularity
                else
                        nNewMax = nNewSize;  // no slush

                ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
#ifdef SIZE_T_MAX
                ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
                TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

                // copy new data from old
                memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

                // construct remaining elements
                ASSERT(nNewSize > m_nSize);
                ConstructElements(&pNewData[m_nSize], nNewSize-m_nSize);

                // get rid of old stuff (note: no destructors called)
                delete[] (BYTE*)m_pData;
                m_pData = pNewData;
                m_nSize = nNewSize;
                m_nMaxSize = nNewMax;
        }
}

template<class TYPE, class ARG_TYPE>
int CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
{
        ASSERT_VALID(this);
        ASSERT(this != &src);   // cannot append to itself

        int nOldSize = m_nSize;
        SetSize(m_nSize + src.m_nSize);
        CopyElements(m_pData + nOldSize, src.m_pData, src.m_nSize);
        return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
{
        ASSERT_VALID(this);
        ASSERT(this != &src);   // cannot append to itself

        SetSize(src.m_nSize);
        CopyElements(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::FreeExtra()
{
        ASSERT_VALID(this);

        if (m_nSize != m_nMaxSize)
        {
                // shrink to desired size
#ifdef SIZE_T_MAX
                ASSERT(m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
                TYPE* pNewData = NULL;
                if (m_nSize != 0)
                {
                        pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
                        // copy new data from old
                        memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
                }

                // get rid of old stuff (note: no destructors called)
                delete[] (BYTE*)m_pData;
                m_pData = pNewData;
                m_nMaxSize = m_nSize;
        }
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
        ASSERT_VALID(this);
        ASSERT(nIndex >= 0);

        if (nIndex >= m_nSize)
                SetSize(nIndex+1, -1);
        m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
        ASSERT_VALID(this);
        ASSERT(nIndex >= 0);    // will expand to meet need
        ASSERT(nCount > 0);     // zero or negative size not allowed

        if (nIndex >= m_nSize)
        {
                // adding after the end of the array
                SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
        }
        else
        {
                // inserting in the middle of the array
                int nOldSize = m_nSize;
                SetSize(m_nSize + nCount, -1);  // grow it to new size
                // destroy intial data before copying over it
                DestructElements(&m_pData[nOldSize], nCount);
                // shift old data up to fill gap
                memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
                        (nOldSize-nIndex) * sizeof(TYPE));

                // re-init slots we copied from
                ConstructElements(&m_pData[nIndex], nCount);
        }

        // insert new value in the gap
        ASSERT(nIndex + nCount <= m_nSize);
        while (nCount--)
                m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
        ASSERT_VALID(this);
        ASSERT(nIndex >= 0);
        ASSERT(nCount >= 0);
        ASSERT(nIndex + nCount <= m_nSize);

        // just remove a range
        int nMoveCount = m_nSize - (nIndex + nCount);
        DestructElements(&m_pData[nIndex], nCount);
        if (nMoveCount)
                memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
                        nMoveCount * sizeof(TYPE));
        m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CArray* pNewArray)
{
        ASSERT_VALID(this);
        ASSERT(pNewArray != NULL);
        ASSERT_VALID(pNewArray);
        ASSERT(nStartIndex >= 0);

        if (pNewArray->GetSize() > 0)
        {
                InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
                for (int i = 0; i < pNewArray->GetSize(); i++)
                        SetAt(nStartIndex + i, pNewArray->GetAt(i));
        }
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
{
        ASSERT_VALID(this);
#ifndef unix
        // UNIX found decl commented out in coll.hxx
        CObject::Serialize(ar);
#else
	MwBugCheck();
#endif /* unix */
#ifndef unix
        if (ar.IsStoring())
        {
                ar.WriteCount(m_nSize);
        }
        else
        {
                DWORD nOldSize = ar.ReadCount();
                SetSize(nOldSize, -1);
        }
        SerializeElements(ar, m_pData, m_nSize);
#endif /* unix */
}

#ifdef _DEBUG
#ifndef unix
template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
{
        CObject::Dump(dc);

        dc << "with " << m_nSize << " elements";
        if (dc.GetDepth() > 0)
        {
                dc << "\n";
                DumpElements(dc, m_pData, m_nSize);
        }

        dc << "\n";
}
#endif /* unix */

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::AssertValid() const
{
        CObject::AssertValid();

        if (m_pData == NULL)
        {
                ASSERT(m_nSize == 0);
                ASSERT(m_nMaxSize == 0);
        }
        else
        {
                ASSERT(m_nSize >= 0);
                ASSERT(m_nMaxSize >= 0);
                ASSERT(m_nSize <= m_nMaxSize);
                ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE)));
        }
}
#endif //_DEBUG

#define _LIST_DEFINED_

#ifndef _LIST_DEFINED_

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CList : public CObject
{
protected:
        struct CNode
        {
                CNode* pNext;
                CNode* pPrev;
                TYPE data;
        };
public:
// Construction
        CList(int nBlockSize = 10);

// Attributes (head and tail)
        // count of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // peek at head or tail
        TYPE& GetHead();
        TYPE GetHead() const;
        TYPE& GetTail();
        TYPE GetTail() const;

// Operations
        // get head or tail (and remove it) - don't call on empty list !
        TYPE RemoveHead();
        TYPE RemoveTail();

        // add before head or after tail
        POSITION AddHead(ARG_TYPE newElement);
        POSITION AddTail(ARG_TYPE newElement);

        // add another list of elements before head or after tail
        void AddHead(CList* pNewList);
        void AddTail(CList* pNewList);

        // remove all elements
        void RemoveAll();

        // iteration
        POSITION GetHeadPosition() const;
        POSITION GetTailPosition() const;
        TYPE& GetNext(POSITION& rPosition); // return *Position++
        TYPE GetNext(POSITION& rPosition) const; // return *Position++
        TYPE& GetPrev(POSITION& rPosition); // return *Position--
        TYPE GetPrev(POSITION& rPosition) const; // return *Position--

        // getting/modifying an element at a given position
        TYPE& GetAt(POSITION position);
        TYPE GetAt(POSITION position) const;
        void SetAt(POSITION pos, ARG_TYPE newElement);
        void RemoveAt(POSITION position);

        // inserting before or after a given position
        POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
        POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

        // helper functions (note: O(n) speed)
        POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
                // defaults to starting at the HEAD, return NULL if not found
        POSITION FindIndex(int nIndex) const;
                // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
        CNode* m_pNodeHead;
        CNode* m_pNodeTail;
        int m_nCount;
        CNode* m_pNodeFree;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CNode* NewNode(CNode*, CNode*);
        void FreeNode(CNode*);

public:
        ~CList();
        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif
};


/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CList<TYPE, ARG_TYPE>::GetCount() const
        { return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
        { return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetHead()
        { ASSERT(m_pNodeHead != NULL);
                return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetHead() const
        { ASSERT(m_pNodeHead != NULL);
                return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetTail()
        { ASSERT(m_pNodeTail != NULL);
                return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetTail() const
        { ASSERT(m_pNodeTail != NULL);
                return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
        { return (POSITION) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
        { return (POSITION) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
        { CNode* pNode = (CNode*) rPosition;
                ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                rPosition = (POSITION) pNode->pNext;
                return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
        { CNode* pNode = (CNode*) rPosition;
                ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                rPosition = (POSITION) pNode->pNext;
                return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
        { CNode* pNode = (CNode*) rPosition;
                ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                rPosition = (POSITION) pNode->pPrev;
                return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
        { CNode* pNode = (CNode*) rPosition;
                ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                rPosition = (POSITION) pNode->pPrev;
                return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
        { CNode* pNode = (CNode*) position;
                ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
        { CNode* pNode = (CNode*) position;
                ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
        { CNode* pNode = (CNode*) pos;
                ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                pNode->data = newElement; }

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CList(int nBlockSize)
{
        ASSERT(nBlockSize > 0);

        m_nCount = 0;
        m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
        m_pBlocks = NULL;
        m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAll()
{
        ASSERT_VALID(this);

        // destroy elements
        CNode* pNode;
        for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
                DestructElements(&pNode->data, 1);

        m_nCount = 0;
        m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
        m_pBlocks->FreeDataChain();
        m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::~CList()
{
        RemoveAll();
        ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
typename CList<TYPE, ARG_TYPE>::CNode*
CList<TYPE, ARG_TYPE>::NewNode(CNode* pPrev, CNode* pNext)
{
        if (m_pNodeFree == NULL)
        {
                // add another block
                CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
                                 sizeof(CNode));

                // chain them into free list
                CNode* pNode = (CNode*) pNewBlock->data();
                // free in reverse order to make it easier to debug
                pNode += m_nBlockSize - 1;
                for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
                {
                        pNode->pNext = m_pNodeFree;
                        m_pNodeFree = pNode;
                }
        }
        ASSERT(m_pNodeFree != NULL);  // we must have something

        CList::CNode* pNode = m_pNodeFree;
        m_pNodeFree = m_pNodeFree->pNext;
        pNode->pPrev = pPrev;
        pNode->pNext = pNext;
        m_nCount++;
        ASSERT(m_nCount > 0);  // make sure we don't overflow

        ConstructElements(&pNode->data, 1);
        return pNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::FreeNode(CNode* pNode)
{
        DestructElements(&pNode->data, 1);
        pNode->pNext = m_pNodeFree;
        m_pNodeFree = pNode;
        m_nCount--;
        ASSERT(m_nCount >= 0);  // make sure we don't underflow

        // if no more elements, cleanup completely
        if (m_nCount == 0)
                RemoveAll();
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
        ASSERT_VALID(this);

        CNode* pNewNode = NewNode(NULL, m_pNodeHead);
        pNewNode->data = newElement;
        if (m_pNodeHead != NULL)
                m_pNodeHead->pPrev = pNewNode;
        else
                m_pNodeTail = pNewNode;
        m_pNodeHead = pNewNode;
        return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
        ASSERT_VALID(this);

        CNode* pNewNode = NewNode(m_pNodeTail, NULL);
        pNewNode->data = newElement;
        if (m_pNodeTail != NULL)
                m_pNodeTail->pNext = pNewNode;
        else
                m_pNodeHead = pNewNode;
        m_pNodeTail = pNewNode;
        return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
{
        ASSERT_VALID(this);

        ASSERT(pNewList != NULL);
        ASSERT_VALID(pNewList);

        // add a list of same elements to head (maintain order)
        POSITION pos = pNewList->GetTailPosition();
        while (pos != NULL)
                AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
{
        ASSERT_VALID(this);
        ASSERT(pNewList != NULL);
        ASSERT_VALID(pNewList);

        // add a list of same elements
        POSITION pos = pNewList->GetHeadPosition();
        while (pos != NULL)
                AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
{
        ASSERT_VALID(this);
        ASSERT(m_pNodeHead != NULL);  // don't call on empty list !!!
        ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));

        CNode* pOldNode = m_pNodeHead;
        TYPE returnValue = pOldNode->data;

        m_pNodeHead = pOldNode->pNext;
        if (m_pNodeHead != NULL)
                m_pNodeHead->pPrev = NULL;
        else
                m_pNodeTail = NULL;
        FreeNode(pOldNode);
        return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
{
        ASSERT_VALID(this);
        ASSERT(m_pNodeTail != NULL);  // don't call on empty list !!!
        ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));

        CNode* pOldNode = m_pNodeTail;
        TYPE returnValue = pOldNode->data;

        m_pNodeTail = pOldNode->pPrev;
        if (m_pNodeTail != NULL)
                m_pNodeTail->pNext = NULL;
        else
                m_pNodeHead = NULL;
        FreeNode(pOldNode);
        return returnValue;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
{
        ASSERT_VALID(this);

        if (position == NULL)
                return AddHead(newElement); // insert before nothing -> head of the list

        // Insert it before position
        CNode* pOldNode = (CNode*) position;
        CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
        pNewNode->data = newElement;

        if (pOldNode->pPrev != NULL)
        {
                ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
                pOldNode->pPrev->pNext = pNewNode;
        }
        else
        {
                ASSERT(pOldNode == m_pNodeHead);
                m_pNodeHead = pNewNode;
        }
        pOldNode->pPrev = pNewNode;
        return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
{
        ASSERT_VALID(this);

        if (position == NULL)
                return AddTail(newElement); // insert after nothing -> tail of the list

        // Insert it before position
        CNode* pOldNode = (CNode*) position;
        ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
        CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
        pNewNode->data = newElement;

        if (pOldNode->pNext != NULL)
        {
                ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
                pOldNode->pNext->pPrev = pNewNode;
        }
        else
        {
                ASSERT(pOldNode == m_pNodeTail);
                m_pNodeTail = pNewNode;
        }
        pOldNode->pNext = pNewNode;
        return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
{
        ASSERT_VALID(this);

        CNode* pOldNode = (CNode*) position;
        ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));

        // remove pOldNode from list
        if (pOldNode == m_pNodeHead)
        {
                m_pNodeHead = pOldNode->pNext;
        }
        else
        {
                ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
                pOldNode->pPrev->pNext = pOldNode->pNext;
        }
        if (pOldNode == m_pNodeTail)
        {
                m_pNodeTail = pOldNode->pPrev;
        }
        else
        {
                ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
                pOldNode->pNext->pPrev = pOldNode->pPrev;
        }
        FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
        ASSERT_VALID(this);
        ASSERT(nIndex >= 0);

        if (nIndex >= m_nCount)
                return NULL;  // went too far

        CNode* pNode = m_pNodeHead;
        while (nIndex--)
        {
                ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                pNode = pNode->pNext;
        }
        return (POSITION) pNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
{
        ASSERT_VALID(this);

        CNode* pNode = (CNode*) startAfter;
        if (pNode == NULL)
        {
                pNode = m_pNodeHead;  // start at head
        }
        else
        {
                ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                pNode = pNode->pNext;  // start after the one specified
        }

        for (; pNode != NULL; pNode = pNode->pNext)
                if (CompareElements(&pNode->data, &searchValue))
                        return (POSITION)pNode;
        return NULL;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
{
        ASSERT_VALID(this);
#ifndef unix
        // UNIX found decl commented out in coll.hxx
        CObject::Serialize(ar);
#else
	MwBugCheck();
#endif /* unix */
#ifndef unix
        if (ar.IsStoring())
        {
                ar.WriteCount(m_nCount);
                for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
                {
                        ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
                        SerializeElements(ar, &pNode->data, 1);
                }
        }
        else
        {
                DWORD nNewCount = ar.ReadCount();
                TYPE newData;
                while (nNewCount--)
                {
                        SerializeElements(ar, &newData, 1);
                        AddTail(newData);
                }
        }
#endif /* unix */
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
{
        CObject::Dump(dc);

        dc << "with " << m_nCount << " elements";
        if (dc.GetDepth() > 0)
        {
                POSITION pos = GetHeadPosition();
                while (pos != NULL)
                {
                        dc << "\n";
                        DumpElements(dc, &((CList*)this)->GetNext(pos), 1);
                }
        }

        dc << "\n";
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AssertValid() const
{
        CObject::AssertValid();

        if (m_nCount == 0)
        {
                // empty list
                ASSERT(m_pNodeHead == NULL);
                ASSERT(m_pNodeTail == NULL);
        }
        else
        {
                // non-empty list
                ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
                ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
        }
}
#endif //_DEBUG
#endif //LIST_DEFINED

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CMap : public CObject
{
#ifndef unix
protected:
#else
  // If this was not made public we get complier warnings
    // that CMap<T,...>::CAssoc is not accessible from file scope
    // which means functions cant return CNode pointers
public:
#endif /* unix */
        // Association
        struct CAssoc
        {
                CAssoc* pNext;
                UINT nHashValue;  // needed for efficient iteration
                KEY key;
                VALUE value;
        };
public:
// Construction
        CMap(int nBlockSize = 10);

// Attributes
        // number of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // Lookup
        BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
        // Lookup and add if not there
        VALUE& operator[](ARG_KEY key);

        // add a new (key, value) pair
        void SetAt(ARG_KEY key, ARG_VALUE newValue);

        // removing existing (key, ?) pair
        BOOL RemoveKey(ARG_KEY key);
        void RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const;
        void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;

        // advanced features for derived classes
        UINT GetHashTableSize() const;
        void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
        CAssoc** m_pHashTable;
        UINT m_nHashTableSize;
        int m_nCount;
        CAssoc* m_pFreeList;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CAssoc* NewAssoc();
        void FreeAssoc(CAssoc*);
        CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
        ~CMap();
        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
        { return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
        { return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
        { (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
        { return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
        { return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(int nBlockSize)
{
        ASSERT(nBlockSize > 0);

        m_pHashTable = NULL;
        m_nHashTableSize = 17;  // default size
        m_nCount = 0;
        m_pFreeList = NULL;
        m_pBlocks = NULL;
        m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
        UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
        ASSERT_VALID(this);
        ASSERT(m_nCount == 0);
        ASSERT(nHashSize > 0);

        if (m_pHashTable != NULL)
        {
                // free hash table
                delete[] m_pHashTable;
                m_pHashTable = NULL;
        }

        if (bAllocNow)
        {
                m_pHashTable = new CAssoc* [nHashSize];
                memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
        }
        m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
        ASSERT_VALID(this);

        if (m_pHashTable != NULL)
        {
                // destroy elements (values and keys)
                for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
                {
                        CAssoc* pAssoc;
                        for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
                          pAssoc = pAssoc->pNext)
                        {
                                DestructElements(&pAssoc->value, 1);
                                DestructElements(&pAssoc->key, 1);
                        }
                }

            // free hash table
            delete[] m_pHashTable;
            m_pHashTable = NULL;
        }

        m_nCount = 0;
        m_pFreeList = NULL;
        if (m_pBlocks)
        {
            m_pBlocks->FreeDataChain();
            m_pBlocks = NULL;
        }
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
{
    if (m_nCount)
    {
        RemoveAll();
    }
    ASSERT(m_nCount == 0);
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
        if (m_pFreeList == NULL)
        {
                // add another block
                CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
                // chain them into free list
                CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
                // free in reverse order to make it easier to debug
                pAssoc += m_nBlockSize - 1;
                for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
                {
                        pAssoc->pNext = m_pFreeList;
                        m_pFreeList = pAssoc;
                }
        }
        ASSERT(m_pFreeList != NULL);  // we must have something

        CMap::CAssoc* pAssoc = m_pFreeList;
        m_pFreeList = m_pFreeList->pNext;
        m_nCount++;
        ASSERT(m_nCount > 0);  // make sure we don't overflow
        ConstructElements(&pAssoc->key, 1);
        ConstructElements(&pAssoc->value, 1);   // special construct values
        return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CAssoc* pAssoc)
{
        DestructElements(&pAssoc->value, 1);
        DestructElements(&pAssoc->key, 1);
        pAssoc->pNext = m_pFreeList;
        m_pFreeList = pAssoc;
        m_nCount--;
        ASSERT(m_nCount >= 0);  // make sure we don't underflow

        // if no more elements, cleanup completely
        if (m_nCount == 0)
                RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
        nHash = HashKey(key) % m_nHashTableSize;

        if (m_pHashTable == NULL)
                return NULL;

        // see if it exists
        CAssoc* pAssoc;
        for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
        {
                if (CompareElements(&pAssoc->key, &key))
                        return pAssoc;
        }
        return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
        ASSERT_VALID(this);

        UINT nHash;
        CAssoc* pAssoc = GetAssocAt(key, nHash);
        if (pAssoc == NULL)
                return FALSE;  // not in map

        rValue = pAssoc->value;
        return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
        ASSERT_VALID(this);

        UINT nHash;
        CAssoc* pAssoc;
        if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
        {
                if (m_pHashTable == NULL)
                        InitHashTable(m_nHashTableSize);

                // it doesn't exist, add a new Association
                pAssoc = NewAssoc();
                pAssoc->nHashValue = nHash;
                pAssoc->key = key;
                // 'pAssoc->value' is a constructed object, nothing more

                // put into hash table
                pAssoc->pNext = m_pHashTable[nHash];
                m_pHashTable[nHash] = pAssoc;
        }
        return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
        ASSERT_VALID(this);

        if (m_pHashTable == NULL)
                return FALSE;  // nothing in the table

        CAssoc** ppAssocPrev;
        ppAssocPrev = &m_pHashTable[HashKey(key) % m_nHashTableSize];

        CAssoc* pAssoc;
        for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
        {
                if (CompareElements(&pAssoc->key, &key))
                {
                        // remove it
                        *ppAssocPrev = pAssoc->pNext;  // remove from list
                        FreeAssoc(pAssoc);
                        return TRUE;
                }
                ppAssocPrev = &pAssoc->pNext;
        }
        return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(POSITION& rNextPosition,
        KEY& rKey, VALUE& rValue) const
{
        ASSERT_VALID(this);
        ASSERT(m_pHashTable != NULL);  // never call on empty map

        CAssoc* pAssocRet = (CAssoc*)rNextPosition;
        ASSERT(pAssocRet != NULL);

        if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
        {
                // find the first association
                for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
                        if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
                                break;
                ASSERT(pAssocRet != NULL);  // must find something
        }

        // find next association
        ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
        CAssoc* pAssocNext;
        if ((pAssocNext = pAssocRet->pNext) == NULL)
        {
                // go to next bucket
                for (UINT nBucket = pAssocRet->nHashValue + 1;
                  nBucket < m_nHashTableSize; nBucket++)
                        if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
                                break;
        }

        rNextPosition = (POSITION) pAssocNext;

        // fill in return data
        rKey = pAssocRet->key;
        rValue = pAssocRet->value;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Serialize(CArchive& ar)
{
        ASSERT_VALID(this);
#ifndef unix
        // UNIX found dedcl commented out in coll.hxx
        CObject::Serialize(ar);
#endif /* unix */

        if (ar.IsStoring())
        {
                ar.WriteCount(m_nCount);
                if (m_nCount == 0)
                        return;  // nothing more to do

                ASSERT(m_pHashTable != NULL);
                for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
                {
                        CAssoc* pAssoc;
                        for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
                          pAssoc = pAssoc->pNext)
                        {
                                SerializeElements(ar, &pAssoc->key, 1);
                                SerializeElements(ar, &pAssoc->value, 1);
                        }
                }
        }
        else
        {
                DWORD nNewCount = ar.ReadCount();
                KEY newKey;
                VALUE newValue;
                while (nNewCount--)
                {
                        SerializeElements(ar, &newKey, 1);
                        SerializeElements(ar, &newValue, 1);
                        SetAt(newKey, newValue);
                }
        }
}

#ifdef _DEBUG
#ifndef unix
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Dump(CDumpContext& dc) const
{
        CObject::Dump(dc);

        dc << "with " << m_nCount << " elements";
        if (dc.GetDepth() > 0)
        {
                // Dump in format "[key] -> value"
                KEY key;
                VALUE val;

                POSITION pos = GetStartPosition();
                while (pos != NULL)
                {
                        GetNextAssoc(pos, key, val);
                        dc << "\n\t[";
                        DumpElements(dc, &key, 1);
                        dc << "] = ";
                        DumpElements(dc, &val, 1);
                }
        }

        dc << "\n";
}
#endif /* unix */

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::AssertValid() const
{
        CObject::AssertValid();

        ASSERT(m_nHashTableSize > 0);
        ASSERT(m_nCount == 0 || m_pHashTable != NULL);
                // non-empty map should have hash table
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrArray<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrArray : public BASE_CLASS
{
public:
        // Accessing elements
        TYPE GetAt(int nIndex) const
                { return (TYPE)BASE_CLASS::GetAt(nIndex); }
        TYPE& ElementAt(int nIndex)
                { return (TYPE&)BASE_CLASS::ElementAt(nIndex); }
        void SetAt(int nIndex, TYPE ptr)
                { BASE_CLASS::SetAt(nIndex, ptr); }

        // Potentially growing the array
        void SetAtGrow(int nIndex, TYPE newElement)
           { BASE_CLASS::SetAtGrow(nIndex, newElement); }
        int Add(TYPE newElement)
           { return BASE_CLASS::Add(newElement); }
        int Append(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
           { return BASE_CLASS::Append(src); }
        void Copy(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
                { BASE_CLASS::Copy(src); }

        // Operations that move elements around
        void InsertAt(int nIndex, TYPE newElement, int nCount = 1)
                { BASE_CLASS::InsertAt(nIndex, newElement, nCount); }
        void InsertAt(int nStartIndex, CTypedPtrArray<BASE_CLASS, TYPE>* pNewArray)
           { BASE_CLASS::InsertAt(nStartIndex, pNewArray); }

        // overloaded operator helpers
        TYPE operator[](int nIndex) const
                { return (TYPE)BASE_CLASS::operator[](nIndex); }
        TYPE& operator[](int nIndex)
                { return (TYPE&)BASE_CLASS::operator[](nIndex); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrList<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrList : public BASE_CLASS
{
public:
// Construction
        CTypedPtrList(int nBlockSize = 10)
                : BASE_CLASS(nBlockSize) { }

        // peek at head or tail
        TYPE& GetHead()
                { return (TYPE&)BASE_CLASS::GetHead(); }
        TYPE GetHead() const
                { return (TYPE)BASE_CLASS::GetHead(); }
        TYPE& GetTail()
                { return (TYPE&)BASE_CLASS::GetTail(); }
        TYPE GetTail() const
                { return (TYPE)BASE_CLASS::GetTail(); }

        // get head or tail (and remove it) - don't call on empty list!
        TYPE RemoveHead()
                { return (TYPE)BASE_CLASS::RemoveHead(); }
        TYPE RemoveTail()
                { return (TYPE)BASE_CLASS::RemoveTail(); }

        // add before head or after tail
        POSITION AddHead(TYPE newElement)
                { return BASE_CLASS::AddHead(newElement); }
        POSITION AddTail(TYPE newElement)
                { return BASE_CLASS::AddTail(newElement); }

        // add another list of elements before head or after tail
        void AddHead(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
                { BASE_CLASS::AddHead(pNewList); }
        void AddTail(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
                { BASE_CLASS::AddTail(pNewList); }

        // iteration
        TYPE& GetNext(POSITION& rPosition)
                { return (TYPE&)BASE_CLASS::GetNext(rPosition); }
        TYPE GetNext(POSITION& rPosition) const
                { return (TYPE)BASE_CLASS::GetNext(rPosition); }
        TYPE& GetPrev(POSITION& rPosition)
                { return (TYPE&)BASE_CLASS::GetPrev(rPosition); }
        TYPE GetPrev(POSITION& rPosition) const
                { return (TYPE)BASE_CLASS::GetPrev(rPosition); }

        // getting/modifying an element at a given position
        TYPE& GetAt(POSITION position)
                { return (TYPE&)BASE_CLASS::GetAt(position); }
        TYPE GetAt(POSITION position) const
                { return (TYPE)BASE_CLASS::GetAt(position); }
        void SetAt(POSITION pos, TYPE newElement)
                { BASE_CLASS::SetAt(pos, newElement); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrMap<BASE_CLASS, KEY, VALUE>

template<class BASE_CLASS, class KEY, class VALUE>
class CTypedPtrMap : public BASE_CLASS
{
public:

// Construction
        CTypedPtrMap(int nBlockSize = 10)
                : BASE_CLASS(nBlockSize) { }

        // Lookup
        BOOL Lookup(typename BASE_CLASS::BASE_ARG_KEY key, VALUE& rValue) const
                { return BASE_CLASS::Lookup(key, (BASE_CLASS::BASE_VALUE&)rValue); }

        // Lookup and add if not there
        VALUE& operator[](typename BASE_CLASS::BASE_ARG_KEY key)
                { return (VALUE&)BASE_CLASS::operator[](key); }

        // add a new key (key, value) pair
        void SetAt(KEY key, VALUE newValue)
                { BASE_CLASS::SetAt(key, newValue); }

        // removing existing (key, ?) pair
        BOOL RemoveKey(KEY key)
                { return BASE_CLASS::RemoveKey(key); }

        // iteration
        void GetNextAssoc(POSITION& rPosition, KEY& rKey, VALUE& rValue) const
                { BASE_CLASS::GetNextAssoc(rPosition, (BASE_CLASS::BASE_KEY&)rKey,
                        (BASE_CLASS::BASE_VALUE&)rValue); }
};

/////////////////////////////////////////////////////////////////////////////

#undef THIS_FILE
#define THIS_FILE __FILE__

#undef new
#ifdef _REDEF_NEW
#define new DEBUG_NEW
#undef _REDEF_NEW
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif //__AFXTEMPL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\afxcoll.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXCOLL_H__
#define __AFXCOLL_H__
/*
#ifndef __AFX_H__
        #include <afx.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif
*/
/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

//CObject
        // Arrays
        class CByteArray;           // array of BYTE
        class CWordArray;           // array of WORD
        class CDWordArray;          // array of DWORD
        class CUIntArray;           // array of UINT
        class CPtrArray;            // array of void*
        class CObArray;             // array of CObject*

        // Lists
        class CPtrList;             // list of void*
        class CObList;              // list of CObject*

        // Maps (aka Dictionaries)
        class CMapWordToOb;         // map from WORD to CObject*
        class CMapWordToPtr;        // map from WORD to void*
        class CMapPtrToWord;        // map from void* to WORD
        class CMapPtrToPtr;         // map from void* to void*

        // Special String variants
        class CStringArray;         // array of CStrings
        class CStringList;          // list of CStrings
        class CMapStringToPtr;      // map from CString to void*
        class CMapStringToOb;       // map from CString to CObject*
        class CMapStringToString;   // map from CString to CString

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

////////////////////////////////////////////////////////////////////////////

class CByteArray : public CObject
{

        DECLARE_SERIAL(CByteArray)
public:

// Construction
        CByteArray();

// Attributes
        int GetSize() const;
        int GetUpperBound() const;
        void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
        // Clean up
        void FreeExtra();
        void RemoveAll();

        // Accessing elements
        BYTE GetAt(int nIndex) const;
        void SetAt(int nIndex, BYTE newElement);
        BYTE& ElementAt(int nIndex);

        // Direct Access to the element data (may return NULL)
        const BYTE* GetData() const;
        BYTE* GetData();

        // Potentially growing the array
        void SetAtGrow(int nIndex, BYTE newElement);
        int Add(BYTE newElement);
        int Append(const CByteArray& src);
        void Copy(const CByteArray& src);

        // overloaded operator helpers
        BYTE operator[](int nIndex) const;
        BYTE& operator[](int nIndex);

        // Operations that move elements around
        void InsertAt(int nIndex, BYTE newElement, int nCount = 1);
        void RemoveAt(int nIndex, int nCount = 1);
        void InsertAt(int nStartIndex, CByteArray* pNewArray);

// Implementation
protected:
        BYTE* m_pData;   // the actual array of data
        int m_nSize;     // # of elements (upperBound - 1)
        int m_nMaxSize;  // max allocated
        int m_nGrowBy;   // grow amount

public:
        ~CByteArray();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for class templates
        typedef BYTE BASE_TYPE;
        typedef BYTE BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CWordArray : public CObject
{

        DECLARE_SERIAL(CWordArray)
public:

// Construction
        CWordArray();

// Attributes
        int GetSize() const;
        int GetUpperBound() const;
        void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
        // Clean up
        void FreeExtra();
        void RemoveAll();

        // Accessing elements
        WORD GetAt(int nIndex) const;
        void SetAt(int nIndex, WORD newElement);
        WORD& ElementAt(int nIndex);

        // Direct Access to the element data (may return NULL)
        const WORD* GetData() const;
        WORD* GetData();

        // Potentially growing the array
        void SetAtGrow(int nIndex, WORD newElement);
        int Add(WORD newElement);
        int Append(const CWordArray& src);
        void Copy(const CWordArray& src);

        // overloaded operator helpers
        WORD operator[](int nIndex) const;
        WORD& operator[](int nIndex);

        // Operations that move elements around
        void InsertAt(int nIndex, WORD newElement, int nCount = 1);
        void RemoveAt(int nIndex, int nCount = 1);
        void InsertAt(int nStartIndex, CWordArray* pNewArray);

// Implementation
protected:
        WORD* m_pData;   // the actual array of data
        int m_nSize;     // # of elements (upperBound - 1)
        int m_nMaxSize;  // max allocated
        int m_nGrowBy;   // grow amount

public:
        ~CWordArray();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for class templates
        typedef WORD BASE_TYPE;
        typedef WORD BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CDWordArray : public CObject
{

        DECLARE_SERIAL(CDWordArray)
public:

// Construction
        CDWordArray();

// Attributes
        int GetSize() const;
        int GetUpperBound() const;
        void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
        // Clean up
        void FreeExtra();
        void RemoveAll();

        // Accessing elements
        DWORD GetAt(int nIndex) const;
        void SetAt(int nIndex, DWORD newElement);
        DWORD& ElementAt(int nIndex);

        // Direct Access to the element data (may return NULL)
        const DWORD* GetData() const;
        DWORD* GetData();

        // Potentially growing the array
        void SetAtGrow(int nIndex, DWORD newElement);
        int Add(DWORD newElement);
        int Append(const CDWordArray& src);
        void Copy(const CDWordArray& src);

        // overloaded operator helpers
        DWORD operator[](int nIndex) const;
        DWORD& operator[](int nIndex);

        // Operations that move elements around
        void InsertAt(int nIndex, DWORD newElement, int nCount = 1);
        void RemoveAt(int nIndex, int nCount = 1);
        void InsertAt(int nStartIndex, CDWordArray* pNewArray);

// Implementation
protected:
        DWORD* m_pData;   // the actual array of data
        int m_nSize;     // # of elements (upperBound - 1)
        int m_nMaxSize;  // max allocated
        int m_nGrowBy;   // grow amount

public:
        ~CDWordArray();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for class templates
        typedef DWORD BASE_TYPE;
        typedef DWORD BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CUIntArray : public CObject
{

        DECLARE_DYNAMIC(CUIntArray)
public:

// Construction
        CUIntArray();

// Attributes
        int GetSize() const;
        int GetUpperBound() const;
        void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
        // Clean up
        void FreeExtra();
        void RemoveAll();

        // Accessing elements
        UINT GetAt(int nIndex) const;
        void SetAt(int nIndex, UINT newElement);
        UINT& ElementAt(int nIndex);

        // Direct Access to the element data (may return NULL)
        const UINT* GetData() const;
        UINT* GetData();

        // Potentially growing the array
        void SetAtGrow(int nIndex, UINT newElement);
        int Add(UINT newElement);
        int Append(const CUIntArray& src);
        void Copy(const CUIntArray& src);

        // overloaded operator helpers
        UINT operator[](int nIndex) const;
        UINT& operator[](int nIndex);

        // Operations that move elements around
        void InsertAt(int nIndex, UINT newElement, int nCount = 1);
        void RemoveAt(int nIndex, int nCount = 1);
        void InsertAt(int nStartIndex, CUIntArray* pNewArray);

// Implementation
protected:
        UINT* m_pData;   // the actual array of data
        int m_nSize;     // # of elements (upperBound - 1)
        int m_nMaxSize;  // max allocated
        int m_nGrowBy;   // grow amount

public:
        ~CUIntArray();
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for class templates
        typedef UINT BASE_TYPE;
        typedef UINT BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CPtrArray : public CObject
{

        DECLARE_DYNAMIC(CPtrArray)
public:

// Construction
        CPtrArray();

// Attributes
        int GetSize() const;
        int GetUpperBound() const;
        void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
        // Clean up
        void FreeExtra();
        void RemoveAll();

        // Accessing elements
        void* GetAt(int nIndex) const;
        void SetAt(int nIndex, void* newElement);
        void*& ElementAt(int nIndex);

        // Direct Access to the element data (may return NULL)
        const void** GetData() const;
        void** GetData();

        // Potentially growing the array
        void SetAtGrow(int nIndex, void* newElement);
        int Add(void* newElement);
        int Append(const CPtrArray& src);
        void Copy(const CPtrArray& src);

        // overloaded operator helpers
        void* operator[](int nIndex) const;
        void*& operator[](int nIndex);

        // Operations that move elements around
        void InsertAt(int nIndex, void* newElement, int nCount = 1);
        void RemoveAt(int nIndex, int nCount = 1);
        void InsertAt(int nStartIndex, CPtrArray* pNewArray);

// Implementation
protected:
        void** m_pData;   // the actual array of data
        int m_nSize;     // # of elements (upperBound - 1)
        int m_nMaxSize;  // max allocated
        int m_nGrowBy;   // grow amount

public:
        ~CPtrArray();
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for class templates
        typedef void* BASE_TYPE;
        typedef void* BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CObArray : public CObject
{

        DECLARE_SERIAL(CObArray)
public:

// Construction
        CObArray();

// Attributes
        int GetSize() const;
        int GetUpperBound() const;
        void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
        // Clean up
        void FreeExtra();
        void RemoveAll();

        // Accessing elements
        CObject* GetAt(int nIndex) const;
        void SetAt(int nIndex, CObject* newElement);
        CObject*& ElementAt(int nIndex);

        // Direct Access to the element data (may return NULL)
        const CObject** GetData() const;
        CObject** GetData();

        // Potentially growing the array
        void SetAtGrow(int nIndex, CObject* newElement);
        int Add(CObject* newElement);
        int Append(const CObArray& src);
        void Copy(const CObArray& src);

        // overloaded operator helpers
        CObject* operator[](int nIndex) const;
        CObject*& operator[](int nIndex);

        // Operations that move elements around
        void InsertAt(int nIndex, CObject* newElement, int nCount = 1);
        void RemoveAt(int nIndex, int nCount = 1);
        void InsertAt(int nStartIndex, CObArray* pNewArray);

// Implementation
protected:
        CObject** m_pData;   // the actual array of data
        int m_nSize;     // # of elements (upperBound - 1)
        int m_nMaxSize;  // max allocated
        int m_nGrowBy;   // grow amount

public:
        ~CObArray();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for class templates
        typedef CObject* BASE_TYPE;
        typedef CObject* BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CStringArray : public CObject
{

        DECLARE_SERIAL(CStringArray)
public:

// Construction
        CStringArray();

// Attributes
        int GetSize() const;
        int GetUpperBound() const;
        void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
        // Clean up
        void FreeExtra();
        void RemoveAll();

        // Accessing elements
        CString GetAt(int nIndex) const;
        void SetAt(int nIndex, LPCTSTR newElement);
        CString& ElementAt(int nIndex);

        // Direct Access to the element data (may return NULL)
        const CString* GetData() const;
        CString* GetData();

        // Potentially growing the array
        void SetAtGrow(int nIndex, LPCTSTR newElement);
        int Add(LPCTSTR newElement);
        int Append(const CStringArray& src);
        void Copy(const CStringArray& src);

        // overloaded operator helpers
        CString operator[](int nIndex) const;
        CString& operator[](int nIndex);

        // Operations that move elements around
        void InsertAt(int nIndex, LPCTSTR newElement, int nCount = 1);
        void RemoveAt(int nIndex, int nCount = 1);
        void InsertAt(int nStartIndex, CStringArray* pNewArray);

// Implementation
protected:
        CString* m_pData;   // the actual array of data
        int m_nSize;     // # of elements (upperBound - 1)
        int m_nMaxSize;  // max allocated
        int m_nGrowBy;   // grow amount

public:
        ~CStringArray();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for class templates
        typedef CString BASE_TYPE;
        typedef LPCTSTR BASE_ARG_TYPE;
};


/////////////////////////////////////////////////////////////////////////////

class CPtrList : public CObject
{

        DECLARE_DYNAMIC(CPtrList)

protected:
        struct CNode
        {
                CNode* pNext;
                CNode* pPrev;
                void* data;
        };
public:

// Construction
        CPtrList(int nBlockSize = 10);

// Attributes (head and tail)
        // count of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // peek at head or tail
        void*& GetHead();
        void* GetHead() const;
        void*& GetTail();
        void* GetTail() const;

// Operations
        // get head or tail (and remove it) - don't call on empty list!
        void* RemoveHead();
        void* RemoveTail();

        // add before head or after tail
        POSITION AddHead(void* newElement);
        POSITION AddTail(void* newElement);

        // add another list of elements before head or after tail
        void AddHead(CPtrList* pNewList);
        void AddTail(CPtrList* pNewList);

        // remove all elements
        void RemoveAll();

        // iteration
        POSITION GetHeadPosition() const;
        POSITION GetTailPosition() const;
        void*& GetNext(POSITION& rPosition); // return *Position++
        void* GetNext(POSITION& rPosition) const; // return *Position++
        void*& GetPrev(POSITION& rPosition); // return *Position--
        void* GetPrev(POSITION& rPosition) const; // return *Position--

        // getting/modifying an element at a given position
        void*& GetAt(POSITION position);
        void* GetAt(POSITION position) const;
        void SetAt(POSITION pos, void* newElement);
        void RemoveAt(POSITION position);

        // inserting before or after a given position
        POSITION InsertBefore(POSITION position, void* newElement);
        POSITION InsertAfter(POSITION position, void* newElement);

        // helper functions (note: O(n) speed)
        POSITION Find(void* searchValue, POSITION startAfter = NULL) const;
                                                // defaults to starting at the HEAD
                                                // return NULL if not found
        POSITION FindIndex(int nIndex) const;
                                                // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
        CNode* m_pNodeHead;
        CNode* m_pNodeTail;
        int m_nCount;
        CNode* m_pNodeFree;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CNode* NewNode(CNode*, CNode*);
        void FreeNode(CNode*);

public:
        ~CPtrList();
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif
        // local typedefs for class templates
        typedef void* BASE_TYPE;
        typedef void* BASE_ARG_TYPE;
};


/////////////////////////////////////////////////////////////////////////////

class CObList : public CObject
{

        DECLARE_SERIAL(CObList)

protected:
        struct CNode
        {
                CNode* pNext;
                CNode* pPrev;
                CObject* data;
        };
public:

// Construction
        CObList(int nBlockSize = 10);

// Attributes (head and tail)
        // count of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // peek at head or tail
        CObject*& GetHead();
        CObject* GetHead() const;
        CObject*& GetTail();
        CObject* GetTail() const;

// Operations
        // get head or tail (and remove it) - don't call on empty list!
        CObject* RemoveHead();
        CObject* RemoveTail();

        // add before head or after tail
        POSITION AddHead(CObject* newElement);
        POSITION AddTail(CObject* newElement);

        // add another list of elements before head or after tail
        void AddHead(CObList* pNewList);
        void AddTail(CObList* pNewList);

        // remove all elements
        void RemoveAll();

        // iteration
        POSITION GetHeadPosition() const;
        POSITION GetTailPosition() const;
        CObject*& GetNext(POSITION& rPosition); // return *Position++
        CObject* GetNext(POSITION& rPosition) const; // return *Position++
        CObject*& GetPrev(POSITION& rPosition); // return *Position--
        CObject* GetPrev(POSITION& rPosition) const; // return *Position--

        // getting/modifying an element at a given position
        CObject*& GetAt(POSITION position);
        CObject* GetAt(POSITION position) const;
        void SetAt(POSITION pos, CObject* newElement);
        void RemoveAt(POSITION position);

        // inserting before or after a given position
        POSITION InsertBefore(POSITION position, CObject* newElement);
        POSITION InsertAfter(POSITION position, CObject* newElement);

        // helper functions (note: O(n) speed)
        POSITION Find(CObject* searchValue, POSITION startAfter = NULL) const;
                                                // defaults to starting at the HEAD
                                                // return NULL if not found
        POSITION FindIndex(int nIndex) const;
                                                // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
        CNode* m_pNodeHead;
        CNode* m_pNodeTail;
        int m_nCount;
        CNode* m_pNodeFree;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CNode* NewNode(CNode*, CNode*);
        void FreeNode(CNode*);

public:
        ~CObList();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif
        // local typedefs for class templates
        typedef CObject* BASE_TYPE;
        typedef CObject* BASE_ARG_TYPE;
};


/////////////////////////////////////////////////////////////////////////////

class CStringList : public CObject
{

        DECLARE_SERIAL(CStringList)

protected:
        struct CNode
        {
                CNode* pNext;
                CNode* pPrev;
                CString data;
        };
public:

// Construction
        CStringList(int nBlockSize = 10);

// Attributes (head and tail)
        // count of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // peek at head or tail
        CString& GetHead();
        CString GetHead() const;
        CString& GetTail();
        CString GetTail() const;

// Operations
        // get head or tail (and remove it) - don't call on empty list!
        CString RemoveHead();
        CString RemoveTail();

        // add before head or after tail
        POSITION AddHead(LPCTSTR newElement);
        POSITION AddTail(LPCTSTR newElement);

        // add another list of elements before head or after tail
        void AddHead(CStringList* pNewList);
        void AddTail(CStringList* pNewList);

        // remove all elements
        void RemoveAll();

        // iteration
        POSITION GetHeadPosition() const;
        POSITION GetTailPosition() const;
        CString& GetNext(POSITION& rPosition); // return *Position++
        CString GetNext(POSITION& rPosition) const; // return *Position++
        CString& GetPrev(POSITION& rPosition); // return *Position--
        CString GetPrev(POSITION& rPosition) const; // return *Position--

        // getting/modifying an element at a given position
        CString& GetAt(POSITION position);
        CString GetAt(POSITION position) const;
        void SetAt(POSITION pos, LPCTSTR newElement);
        void RemoveAt(POSITION position);

        // inserting before or after a given position
        POSITION InsertBefore(POSITION position, LPCTSTR newElement);
        POSITION InsertAfter(POSITION position, LPCTSTR newElement);

        // helper functions (note: O(n) speed)
        POSITION Find(LPCTSTR searchValue, POSITION startAfter = NULL) const;
                                                // defaults to starting at the HEAD
                                                // return NULL if not found
        POSITION FindIndex(int nIndex) const;
                                                // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
        CNode* m_pNodeHead;
        CNode* m_pNodeTail;
        int m_nCount;
        CNode* m_pNodeFree;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CNode* NewNode(CNode*, CNode*);
        void FreeNode(CNode*);

public:
        ~CStringList();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif
        // local typedefs for class templates
        typedef CString BASE_TYPE;
        typedef LPCTSTR BASE_ARG_TYPE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapWordToPtr : public CObject
{

        DECLARE_DYNAMIC(CMapWordToPtr)
protected:
        // Association
        struct CAssoc
        {
                CAssoc* pNext;

                WORD key;
                void* value;
        };

public:

// Construction
        CMapWordToPtr(int nBlockSize = 10);

// Attributes
        // number of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // Lookup
        BOOL Lookup(WORD key, void*& rValue) const;

// Operations
        // Lookup and add if not there
        void*& operator[](WORD key);

        // add a new (key, value) pair
        void SetAt(WORD key, void* newValue);

        // removing existing (key, ?) pair
        BOOL RemoveKey(WORD key);
        void RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const;
        void GetNextAssoc(POSITION& rNextPosition, WORD& rKey, void*& rValue) const;

        // advanced features for derived classes
        UINT GetHashTableSize() const;
        void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
        // Routine used to user-provided hash keys
        UINT HashKey(WORD key) const;

// Implementation
protected:
        CAssoc** m_pHashTable;
        UINT m_nHashTableSize;
        int m_nCount;
        CAssoc* m_pFreeList;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CAssoc* NewAssoc();
        void FreeAssoc(CAssoc*);
        CAssoc* GetAssocAt(WORD, UINT&) const;

public:
        ~CMapWordToPtr();
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif


protected:
        // local typedefs for CTypedPtrMap class template
        typedef WORD BASE_KEY;
        typedef WORD BASE_ARG_KEY;
        typedef void* BASE_VALUE;
        typedef void* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapPtrToWord : public CObject
{

        DECLARE_DYNAMIC(CMapPtrToWord)
protected:
        // Association
        struct CAssoc
        {
                CAssoc* pNext;

                void* key;
                WORD value;
        };

public:

// Construction
        CMapPtrToWord(int nBlockSize = 10);

// Attributes
        // number of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // Lookup
        BOOL Lookup(void* key, WORD& rValue) const;

// Operations
        // Lookup and add if not there
        WORD& operator[](void* key);

        // add a new (key, value) pair
        void SetAt(void* key, WORD newValue);

        // removing existing (key, ?) pair
        BOOL RemoveKey(void* key);
        void RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const;
        void GetNextAssoc(POSITION& rNextPosition, void*& rKey, WORD& rValue) const;

        // advanced features for derived classes
        UINT GetHashTableSize() const;
        void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
        // Routine used to user-provided hash keys
        UINT HashKey(void* key) const;

// Implementation
protected:
        CAssoc** m_pHashTable;
        UINT m_nHashTableSize;
        int m_nCount;
        CAssoc* m_pFreeList;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CAssoc* NewAssoc();
        void FreeAssoc(CAssoc*);
        CAssoc* GetAssocAt(void*, UINT&) const;

public:
        ~CMapPtrToWord();
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif


protected:
        // local typedefs for CTypedPtrMap class template
        typedef void* BASE_KEY;
        typedef void* BASE_ARG_KEY;
        typedef WORD BASE_VALUE;
        typedef WORD BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapPtrToPtr : public CObject
{

        DECLARE_DYNAMIC(CMapPtrToPtr)
protected:
        // Association
        struct CAssoc
        {
                CAssoc* pNext;

                void* key;
                void* value;
        };

public:

// Construction
        CMapPtrToPtr(int nBlockSize = 10);

// Attributes
        // number of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // Lookup
        BOOL Lookup(void* key, void*& rValue) const;

// Operations
        // Lookup and add if not there
        void*& operator[](void* key);

        // add a new (key, value) pair
        void SetAt(void* key, void* newValue);

        // removing existing (key, ?) pair
        BOOL RemoveKey(void* key);
        void RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const;
        void GetNextAssoc(POSITION& rNextPosition, void*& rKey, void*& rValue) const;

        // advanced features for derived classes
        UINT GetHashTableSize() const;
        void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
        // Routine used to user-provided hash keys
        UINT HashKey(void* key) const;

// Implementation
protected:
        CAssoc** m_pHashTable;
        UINT m_nHashTableSize;
        int m_nCount;
        CAssoc* m_pFreeList;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CAssoc* NewAssoc();
        void FreeAssoc(CAssoc*);
        CAssoc* GetAssocAt(void*, UINT&) const;

public:
        ~CMapPtrToPtr();
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

        void* GetValueAt(void* key) const;


protected:
        // local typedefs for CTypedPtrMap class template
        typedef void* BASE_KEY;
        typedef void* BASE_ARG_KEY;
        typedef void* BASE_VALUE;
        typedef void* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapWordToOb : public CObject
{

        DECLARE_SERIAL(CMapWordToOb)
protected:
        // Association
        struct CAssoc
        {
                CAssoc* pNext;

                WORD key;
                CObject* value;
        };

public:

// Construction
        CMapWordToOb(int nBlockSize = 10);

// Attributes
        // number of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // Lookup
        BOOL Lookup(WORD key, CObject*& rValue) const;

// Operations
        // Lookup and add if not there
        CObject*& operator[](WORD key);

        // add a new (key, value) pair
        void SetAt(WORD key, CObject* newValue);

        // removing existing (key, ?) pair
        BOOL RemoveKey(WORD key);
        void RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const;
        void GetNextAssoc(POSITION& rNextPosition, WORD& rKey, CObject*& rValue) const;

        // advanced features for derived classes
        UINT GetHashTableSize() const;
        void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
        // Routine used to user-provided hash keys
        UINT HashKey(WORD key) const;

// Implementation
protected:
        CAssoc** m_pHashTable;
        UINT m_nHashTableSize;
        int m_nCount;
        CAssoc* m_pFreeList;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CAssoc* NewAssoc();
        void FreeAssoc(CAssoc*);
        CAssoc* GetAssocAt(WORD, UINT&) const;

public:
        ~CMapWordToOb();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif


protected:
        // local typedefs for CTypedPtrMap class template
        typedef WORD BASE_KEY;
        typedef WORD BASE_ARG_KEY;
        typedef CObject* BASE_VALUE;
        typedef CObject* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapStringToPtr : public CObject
{

        DECLARE_DYNAMIC(CMapStringToPtr)
protected:
        // Association
        struct CAssoc
        {
                CAssoc* pNext;
                UINT nHashValue;  // needed for efficient iteration
                CString key;
                void* value;
        };

public:

// Construction
        CMapStringToPtr(int nBlockSize = 10);

// Attributes
        // number of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // Lookup
        BOOL Lookup(LPCTSTR key, void*& rValue) const;
        BOOL LookupKey(LPCTSTR key, LPCTSTR& rKey) const;

// Operations
        // Lookup and add if not there
        void*& operator[](LPCTSTR key);

        // add a new (key, value) pair
        void SetAt(LPCTSTR key, void* newValue);

        // removing existing (key, ?) pair
        BOOL RemoveKey(LPCTSTR key);
        void RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const;
        void GetNextAssoc(POSITION& rNextPosition, CString& rKey, void*& rValue) const;

        // advanced features for derived classes
        UINT GetHashTableSize() const;
        void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
        // Routine used to user-provided hash keys
        UINT HashKey(LPCTSTR key) const;

// Implementation
protected:
        CAssoc** m_pHashTable;
        UINT m_nHashTableSize;
        int m_nCount;
        CAssoc* m_pFreeList;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CAssoc* NewAssoc();
        void FreeAssoc(CAssoc*);
        CAssoc* GetAssocAt(LPCTSTR, UINT&) const;

public:
        ~CMapStringToPtr();
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for CTypedPtrMap class template
        typedef CString BASE_KEY;
        typedef LPCTSTR BASE_ARG_KEY;
        typedef void* BASE_VALUE;
        typedef void* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapStringToOb : public CObject
{

        DECLARE_SERIAL(CMapStringToOb)
protected:
        // Association
        struct CAssoc
        {
                CAssoc* pNext;
                UINT nHashValue;  // needed for efficient iteration
                CString key;
                CObject* value;
        };

public:

// Construction
        CMapStringToOb(int nBlockSize = 10);

// Attributes
        // number of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // Lookup
        BOOL Lookup(LPCTSTR key, CObject*& rValue) const;
        BOOL LookupKey(LPCTSTR key, LPCTSTR& rKey) const;

// Operations
        // Lookup and add if not there
        CObject*& operator[](LPCTSTR key);

        // add a new (key, value) pair
        void SetAt(LPCTSTR key, CObject* newValue);

        // removing existing (key, ?) pair
        BOOL RemoveKey(LPCTSTR key);
        void RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const;
        void GetNextAssoc(POSITION& rNextPosition, CString& rKey, CObject*& rValue) const;

        // advanced features for derived classes
        UINT GetHashTableSize() const;
        void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
        // Routine used to user-provided hash keys
        UINT HashKey(LPCTSTR key) const;

// Implementation
protected:
        CAssoc** m_pHashTable;
        UINT m_nHashTableSize;
        int m_nCount;
        CAssoc* m_pFreeList;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CAssoc* NewAssoc();
        void FreeAssoc(CAssoc*);
        CAssoc* GetAssocAt(LPCTSTR, UINT&) const;

public:
        ~CMapStringToOb();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for CTypedPtrMap class template
        typedef CString BASE_KEY;
        typedef LPCTSTR BASE_ARG_KEY;
        typedef CObject* BASE_VALUE;
        typedef CObject* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapStringToString : public CObject
{

        DECLARE_SERIAL(CMapStringToString)
protected:
        // Association
        struct CAssoc
        {
                CAssoc* pNext;
                UINT nHashValue;  // needed for efficient iteration
                CString key;
                CString value;
        };

public:

// Construction
        CMapStringToString(int nBlockSize = 10);

// Attributes
        // number of elements
        int GetCount() const;
        BOOL IsEmpty() const;

        // Lookup
        BOOL Lookup(LPCTSTR key, CString& rValue) const;
        BOOL LookupKey(LPCTSTR key, LPCTSTR& rKey) const;

// Operations
        // Lookup and add if not there
        CString& operator[](LPCTSTR key);

        // add a new (key, value) pair
        void SetAt(LPCTSTR key, LPCTSTR newValue);

        // removing existing (key, ?) pair
        BOOL RemoveKey(LPCTSTR key);
        void RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const;
        void GetNextAssoc(POSITION& rNextPosition, CString& rKey, CString& rValue) const;

        // advanced features for derived classes
        UINT GetHashTableSize() const;
        void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
        // Routine used to user-provided hash keys
        UINT HashKey(LPCTSTR key) const;

// Implementation
protected:
        CAssoc** m_pHashTable;
        UINT m_nHashTableSize;
        int m_nCount;
        CAssoc* m_pFreeList;
        struct CPlex* m_pBlocks;
        int m_nBlockSize;

        CAssoc* NewAssoc();
        void FreeAssoc(CAssoc*);
        CAssoc* GetAssocAt(LPCTSTR, UINT&) const;

public:
        ~CMapStringToString();

        void Serialize(CArchive&);
#ifdef _DEBUG
        void Dump(CDumpContext&) const;
        void AssertValid() const;
#endif

protected:
        // local typedefs for CTypedPtrMap class template
        typedef CString BASE_KEY;
        typedef LPCTSTR BASE_ARG_KEY;
        typedef CString BASE_VALUE;
        typedef LPCTSTR BASE_ARG_VALUE;
};

/////////////////////////////////////////////////////////////////////////////
// Special include for Win32s compatibility
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifndef __AFXSTATE_H__
        #include <afxstat_.h>   // for MFC private state structures
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ENABLE_INLINES
#define _AFXCOLL_INLINE inline
#include <afxcoll.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif //!__AFXCOLL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\assert.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines for idsmgr.dll
//
//  Functions:  Assert
//              PopUpError
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//              30-Sep-93   KyleP       DEVL obsolete
//
//----------------------------------------------------------------------------

#pragma hdrstop

#include "urlmon.hxx"
//
// This one file **always** uses debugging options
//

#if DBG == 1

// needed for CT TOM assert events trapping
#include <assert.hxx>

#include <stdarg.h>
#include <stdio.h>


# include <dprintf.h>            // w4printf, w4dprintf prototypes
# include <debnot.h>
# ifdef FLAT
#   include <sem.hxx>
#   include <dllsem.hxx>
# endif // FLAT

extern "C"
{

# ifdef FLAT
#  undef FAR
#  undef NEAR
# else
#  define MessageBoxA MessageBox
# endif

# include <windows.h>
}
#ifdef _CHICAGO_
int WINAPI SSMessageBox(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption, UINT uType);
#endif // _CHICAGO_


extern BOOL gfService = FALSE;

unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
ULONG Win4AssertLevel = 0;

//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void __cdecl
_asdprintf(
    char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   _Win4Assert, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//  History:    12-Jul-91       AlexT   Created.
//              05-Sep-91       AlexT   Catch Throws and Catches
//              19-Oct-92       HoiV    Added events for TOM
//
//----------------------------------------------------------------------------


STDAPI_(void) Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
#if defined( FLAT )
    //
    // This code is for the CT Lab only.  When running in the lab,
    // all assert popups will be trapped and notifications will
    // be sent to the manager.  If running in the office (non-lab
    // mode), the event CTTOMTrapAssertEvent will not exist and
    // consequently, no event will be pulsed.
    //

    HANDLE hTrapAssertEvent,
           hThreadStartEvent;

    if (hTrapAssertEvent = OpenEvent(EVENT_ALL_ACCESS,
                                     FALSE,
                                     CAIRO_CT_TOM_TRAP_ASSERT_EVENT))
    {
        SetEvent(hTrapAssertEvent);

        //
        // This event is to allow TOM Manager time to perform
        // a CallBack to the dispatcher.
        //
        if (hThreadStartEvent = OpenEvent(EVENT_ALL_ACCESS,
                                          FALSE,
                                          CAIRO_CT_TOM_THREAD_START_EVENT))
        {
            //
            // Wait until it's ok to popup or until timed-out
            //
            WaitForSingleObject(hThreadStartEvent, TWO_MINUTES);
        }
    }
#endif

    if (Win4AssertLevel & ASSRT_MESSAGE)
    {
# ifdef FLAT
        DWORD tid = GetCurrentThreadId();

        _asdprintf("%s File: %s Line: %u, thread id %d\n",
                   szMessage, szFile, iLine, tid);
# else  // FLAT
        _asdprintf("%s File: %s Line: %u\n", szMessage, szFile, iLine);
# endif // FLAT
    }

    if (Win4AssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
#ifdef FLAT
            DebugBreak();
#else
#ifndef unix
            DebugBreak();
#endif /* unix */
#endif
        }
    }
    else if (Win4AssertLevel & ASSRT_BREAK)
    {
#ifdef FLAT
        DebugBreak();
#else
#ifndef unix
        DebugBreak();
#endif /* unix */
#endif
    }

}


//+------------------------------------------------------------
// Function:    SetWin4InfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4InfoLevel;
    Win4InfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoMask(
    unsigned long ulNewMask)
{
    unsigned long ul;

    ul = Win4InfoMask;
    Win4InfoMask = ulNewMask;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4AssertLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4AssertLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4AssertLevel;
    Win4AssertLevel = ulNewLevel;
    return(ul);
}

//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

STDAPI_(int) PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile)
{

    int id;
    static char szAssertCaption[128];
    static char szModuleName[128];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char * pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = StrRChr(szModuleName, NULL, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }

    wsprintf(szAssertCaption,"Process: %s File: %s line %u, thread id %d.%d",
        pszModuleName, szFile, iLine, pid, tid);


    DWORD dwMessageFlags = MB_SETFOREGROUND | MB_TASKMODAL |
                           MB_ICONEXCLAMATION | MB_OKCANCEL;

#ifndef _CHICAGO_
                     //  Since this code is also used by SCM.EXE, we pass
                     //  in the following flag which causes Service pop ups
                     //  to appear on the desktop correctly

    if (gfService)
    {
        dwMessageFlags |= MB_SERVICE_NOTIFICATION | MB_DEFAULT_DESKTOP_ONLY;
    }

    id = MessageBoxA(NULL,(char *) szMsg, (LPSTR) szAssertCaption,
                     dwMessageFlags);

# ifdef _CAIRO_
    // Other processes which are services also use this code, but they
    //  have no access to set gfService, so if the above failed with an
    //  access denied error (meaning no access to the default desktop)
    //  retry as a service popup. Also, remember that we are a service
    //  so we don't waste attempts later.
    if ( !gfService && !id
         && (GetLastError() == ERROR_ACCESS_DENIED) )
    {
        gfService = TRUE;
        dwMessageFlags |= MB_SERVICE_NOTIFICATION | MB_DEFAULT_DESKTOP_ONLY;
        id = MessageBoxA(NULL,(char *) szMsg, (LPSTR) szAssertCaption,
                         dwMessageFlags);
    }
# endif

#else
    id = SSMessageBox(NULL, (char *) szMsg, (LPSTR) szAssertCaption,
                     dwMessageFlags);

#endif

    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).  Oh well.

    return id;
}

//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

//
// This semaphore is *outside* vdprintf because the compiler isn't smart
// enough to serialize access for construction if it's function-local and
// protected by a guard variable.
//
//    KyleP - 20 May, 1993
//

static CMutexSem mxs;

STDAPI_(void) vdprintf(
    unsigned long ulCompMask,
    char const   *pszComp,
    char const   *ppszfmt,
    va_list       pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {
#if defined( FLAT )
        mxs.Request();
        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((Win4InfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
#endif // FLAT
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
#ifdef FLAT
#if defined(_CHICAGO_)
                //
                //  Hex Process/Thread ID's are better for Chicago since both
                //  are memory addresses.
                //
                w4dprintf( "%08x.%08x> ", pid, tid );
#else
                w4dprintf( "%d.%03d> ", pid, tid );
#endif
#endif // FLAT
                w4dprintf("%s: ", pszComp);
            }
            w4vdprintf(ppszfmt, pargs);
        }

#if defined( FLAT )
        if (Win4InfoLevel & DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4printf( "%03d> ", tid );
                w4printf("%s: ", pszComp);
            }
            w4vprintf(ppszfmt, pargs);
        }

        mxs.Release();
#endif // FLAT
    }
}

#else

int assertDontUseThisName(void)
{
    return 1;
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\bindutil.cxx ===
// Microsoft Corporation 1997
//
// This file contains methods for copying and releasing STGMEDIUMs and BINDINFOs
// (which contains a STGMEDIUM).
//
// Created: 8-15-97 t-gpease 
//

#include <urlmon.hxx>

#undef  URLMONOFFSETOF
#define URLMONOFFSETOF(t,f)   ((DWORD_PTR)(&((t*)0)->f))

//
// This function clears the BINDINFO structure. 
//
//- The "cbSize" will not be clear and will be the same as it 
// was pasted in. This is by design so that you can reuse the 
// BINDINFO (eg copy another BINDINFO into it). 
//
//- It does NOT release the memory that the BINDINFO oocupies 
// (this could be on the stack). 
//
//- It does properly release items that the BINDINFO might be 
// pointing to.
//
STDAPI_(void)
ReleaseBindInfo(BINDINFO * pbindinfo)
{
    if ( !pbindinfo)
        return;

    DWORD cb = pbindinfo->cbSize;

    UrlMkAssert( cb && 
        "CopyBindInfo(): cbSize of the BINDINFO is ZERO. We need the cbSize to be set before calling us.");
    if(!cb )
        return; // we don't know which structure it is, so don't touch it.

    if (cb >= URLMONOFFSETOF(BINDINFO, dwReserved) && pbindinfo->pUnk)
    {
        pbindinfo->pUnk->Release();
    }

    // Orginal BINDINFO no need to check size
    if (pbindinfo->szExtraInfo)
    {
        delete [] pbindinfo->szExtraInfo;
    }

    // Orginal BINDINFO no need to check size
    if (pbindinfo->szCustomVerb)
    {
        delete [] pbindinfo->szCustomVerb;
    }

    // Orginal BINDINFO no need to check size
    ReleaseStgMedium(&pbindinfo->stgmedData);

    // set this to zero so other function will not try to use the BINDINFO
    ZeroMemory(pbindinfo, cb);
    pbindinfo->cbSize = cb;  // but keep this intact

    return;
}

//
// This function copies STGMEDIUM stuctures.
//
//- Users need to allocate the memory that the STGMEDIUM Dest will be copied
// into.
//
//- If anything goes wrong, we return the proper HRESULT and STGMEDIUM.will
// have been zero-ed.
//
STDAPI
CopyStgMedium(const STGMEDIUM * pcstgmedSrc,
                 STGMEDIUM * pstgmedDest)
{
    HRESULT         hr = S_OK;

    if ( !pcstgmedSrc || !pstgmedDest )
        return E_POINTER;

    ZeroMemory(pstgmedDest, sizeof(*pstgmedDest));

    switch (pcstgmedSrc->tymed)
    {

    case TYMED_HGLOBAL:
        {
            void *          pvDest;
            const void *    pcvSrc;
            DWORD_PTR       dwcbLen;
            HGLOBAL         hGlobalDest;

            if (!pcstgmedSrc->hGlobal)
                break;  // nothing to do

            hr = E_OUTOFMEMORY;
            pcvSrc = GlobalLock(pcstgmedSrc->hGlobal);
            if (!pcvSrc)
                goto Cleanup;

            dwcbLen = GlobalSize(pcstgmedSrc->hGlobal);
            // We can't do the following line:
            // hGlobalDest = GlobalAlloc((GMEM_MOVEABLE | GMEM_SHARE), dwcbLen);
            // because we hand out the bindinfo.stgmedData.hglobal to callers
            // that do NOT lock it and use the handle instead of the pointer.
            hGlobalDest = GlobalAlloc(GMEM_FIXED | GMEM_SHARE, dwcbLen);
            if (!hGlobalDest)
            {
                GlobalUnlock(pcstgmedSrc->hGlobal);
                goto Cleanup;
            }


            pvDest = GlobalLock(hGlobalDest);
            if (!pvDest)
            {
                GlobalFree(hGlobalDest);
                GlobalUnlock(pcstgmedSrc->hGlobal);
                goto Cleanup;
            }

            UrlMkAssert(dwcbLen>>32 == 0);
            memcpy(pvDest, pcvSrc, (unsigned long)dwcbLen);

            pstgmedDest->hGlobal = hGlobalDest;

            GlobalUnlock(hGlobalDest);
            GlobalUnlock(pcstgmedSrc->hGlobal);
            hr = S_OK;
        }
        break;

    case TYMED_FILE:
        {
            if (!pcstgmedSrc->lpszFileName)
                break; // nothing to do

            hr = E_OUTOFMEMORY;

            LPWSTR lpwstr = OLESTRDuplicate(pcstgmedSrc->lpszFileName);
            if (!lpwstr)
                goto Cleanup;

            pstgmedDest->lpszFileName = lpwstr;

            hr = S_OK;
        }
        break;

    case TYMED_ISTREAM:
        {
            pstgmedDest->pstm = pcstgmedSrc->pstm;
            if ( pstgmedDest->pstm )
                pstgmedDest->pstm->AddRef();
        }
        break;

    case TYMED_ISTORAGE:
        {
            pstgmedDest->pstg = pcstgmedSrc->pstg;
            if ( pstgmedDest->pstg )
                pstgmedDest->pstg->AddRef();
        }
        break;

    default:
        UrlMkAssert( !"CloneStgMedium has encountered a TYMED it doesn't know how to copy." );
        // fall thru and copy it.

    case TYMED_NULL: // blindly copy
    case TYMED_GDI:  // Just copy...
        memcpy(pstgmedDest, pcstgmedSrc, sizeof(*pstgmedDest));
        break;
    }

    // Common things that can be copied if we get to this point.
    pstgmedDest->tymed = pcstgmedSrc->tymed;
    pstgmedDest->pUnkForRelease = pcstgmedSrc->pUnkForRelease;
    if (pstgmedDest->pUnkForRelease)
        (pstgmedDest->pUnkForRelease)->AddRef();

Cleanup:
    return hr;
}

//
// This function copies BINDINFO structures.
//
// NOTE: IE4 added properties to the BINDINFO structure. This function
//       works with both versions. If the structure is extended in the
//       future, it will blindly copy the additional properties in the 
//       structure.
//
//- Users need to allocate the memory that the BINDINFO Dest will be copied
//  into.
//
//- Users also need to set the "cbSize" of the BINDINFO Dest to 
//  the sizeof(BINDINFO) before calling (see NOTE above).
//
//- If there is a "cbSize" conflict between the Src and the Dest, we will:
//  1) Src->cbSize = Dest->cbSize, normal copy.
//  2) Src->cbSize > Dest->cbSize, copy as much info about the Src into
//     the Dest as will fit.
//  3) Src->cbSize < Dest->cbSize, copy the Src into the Dest, Zero the
//     remaining unfilled portion of the Dest.
//
//- We don't not copy the securityattribute. We clear this value of the
//  BINDINFO Dest.
//
//- If anything goes wrong, we return the proper HRESULT and clear the
//  the BINDINFO structure using ReleaseBindInfo() (below).
//  NOTE: If "cbSize" of the Dest is ZERO, we don't do anything.
//
STDAPI
CopyBindInfo( const BINDINFO * pcbiSrc,
                BINDINFO *pbiDest )
{
/****** 8-15-97 t-gpease
Current structure at the time of writing... from URLMON.H
typedef struct tagBINDINFO {
    ULONG cbSize;
    LPWSTR szExtraInfo;
    STGMEDIUM stgmedData;
    DWORD grfBindInfoF;
    DWORD dwBindVerb;
    LPWSTR szCustomVerb;
    DWORD cbstgmedData;
// new part below this line //
    DWORD dwOptions;
    DWORD dwOptionsFlags;
    DWORD dwCodePage;
    SECURITY_ATTRIBUTES securityAttributes;
    IID iid;
    IUnknown __RPC_FAR *pUnk;
    DWORD dwReserved;
} BINDINFO;

Anything bigger than this we will blindly copy.the size of cbSize
*******/

    // NOTE: hr will an error until just before the Cleanup label.
    HRESULT hr    = E_INVALIDARG;  
    DWORD   cbSrc;
    DWORD   cbDst;

    if (!pcbiSrc || !pbiDest)
        return E_POINTER;

    cbSrc = pcbiSrc->cbSize;
    cbDst = pbiDest->cbSize;
    
    UrlMkAssert( cbSrc &&
        "CopyBindInfo(): cbSize of the source is ZERO. You must set the cbSize.");
    UrlMkAssert( cbDst &&
        "CopyBindInfo(): cbSize of the destination is ZERO. It needs to be set to the size of the BINDINFO before calling us.");
    if (!cbSrc || !cbDst)
        goto Abort;   // nothing to do or can do.

    // Copy those bytes in common, zero the rest if any
    memcpy(pbiDest, pcbiSrc, min(cbSrc, cbDst));
    pbiDest->cbSize = cbDst; // always keep this intact

    if (cbDst > cbSrc)
    {
        ZeroMemory((BYTE *)pbiDest + cbSrc, cbDst - cbSrc);
    }

    if (cbDst >= URLMONOFFSETOF(BINDINFO, dwReserved))
    {
        ZeroMemory(&pbiDest->securityAttributes, sizeof(SECURITY_ATTRIBUTES));
    }

    if (pcbiSrc->pUnk && cbDst >= URLMONOFFSETOF(BINDINFO, dwReserved))
    {
        pbiDest->pUnk->AddRef();
    }

    // NULL these anything fails we don't want to free the Sources resources.
    pbiDest->szExtraInfo  = NULL;
    pbiDest->szCustomVerb = NULL;    
    
    // Original BINDINFO no need to check size
    hr = CopyStgMedium( &pcbiSrc->stgmedData, &pbiDest->stgmedData );
    if (hr)
        goto Cleanup;

    // Original BINDINFO no need to check size
    if (pcbiSrc->szExtraInfo)
    {
        LPWSTR lpwstr = OLESTRDuplicate(pcbiSrc->szExtraInfo);
        if (!lpwstr)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pbiDest->szExtraInfo= lpwstr;
    }

    // Original BINDINFO no need to check size
    if (pcbiSrc->szCustomVerb)
    {
        LPWSTR lpwstr = OLESTRDuplicate(pcbiSrc->szCustomVerb);
        if (!lpwstr)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pbiDest->szCustomVerb= lpwstr;
    }

Cleanup:
    if (hr)
    {
        // This will set pbiDest members to zero so other function will not 
        // try to use the new BINDINFO.
        ReleaseBindInfo( pbiDest );
    }

Abort:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\assert3.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines for idsmgr.dll
//
//  Functions:  Assert
//              PopUpError
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//              30-Sep-93   KyleP       DEVL obsolete
//
//----------------------------------------------------------------------------

#pragma hdrstop

//
// This one file **always** uses debugging options
//

#if DBG == 1

// needed for CT TOM assert events trapping
#include <assert.hxx>

#include <stdarg.h>
#include <stdio.h>


# include <dprintf.h>            // w4printf, w4dprintf prototypes
# include <debnot.h>
# ifdef FLAT
#   include <sem.hxx>
#   include <dllsem.hxx>
# endif // FLAT

extern "C"
{

# ifdef FLAT
#  undef FAR
#  undef NEAR
# else
#  define MessageBoxA MessageBox
# endif

# include <windows.h>
}
#ifdef _CHICAGO_
int WINAPI SSMessageBox(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption, UINT uType);
#endif // _CHICAGO_


extern BOOL gfService = FALSE;

unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
unsigned long Win4AssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;

//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void _CRTAPI1
_asdprintf(
    char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   _Win4Assert, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//  History:    12-Jul-91       AlexT   Created.
//              05-Sep-91       AlexT   Catch Throws and Catches
//              19-Oct-92       HoiV    Added events for TOM
//
//----------------------------------------------------------------------------


STDAPI_(void) Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
#if defined( FLAT )
    //
    // This code is for the CT Lab only.  When running in the lab,
    // all assert popups will be trapped and notifications will
    // be sent to the manager.  If running in the office (non-lab
    // mode), the event CTTOMTrapAssertEvent will not exist and
    // consequently, no event will be pulsed.
    //

    HANDLE hTrapAssertEvent,
           hThreadStartEvent;

    if (hTrapAssertEvent = OpenEvent(EVENT_ALL_ACCESS,
                                     FALSE,
                                     CAIRO_CT_TOM_TRAP_ASSERT_EVENT))
    {
        SetEvent(hTrapAssertEvent);

        //
        // This event is to allow TOM Manager time to perform
        // a CallBack to the dispatcher.
        //
        if (hThreadStartEvent = OpenEvent(EVENT_ALL_ACCESS,
                                          FALSE,
                                          CAIRO_CT_TOM_THREAD_START_EVENT))
        {
            //
            // Wait until it's ok to popup or until timed-out
            //
            WaitForSingleObject(hThreadStartEvent, TWO_MINUTES);
        }
    }
#endif

    if (Win4AssertLevel & ASSRT_MESSAGE)
    {
# ifdef FLAT
        DWORD tid = GetCurrentThreadId();

        _asdprintf("%s File: %s Line: %u, thread id %d\n",
                   szMessage, szFile, iLine, tid);
# else  // FLAT
        _asdprintf("%s File: %s Line: %u\n", szMessage, szFile, iLine);
# endif // FLAT
    }

    if (Win4AssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (Win4AssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }

}


//+------------------------------------------------------------
// Function:    SetWin4InfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4InfoLevel;
    Win4InfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoMask(
    unsigned long ulNewMask)
{
    unsigned long ul;

    ul = Win4InfoMask;
    Win4InfoMask = ulNewMask;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4AssertLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4AssertLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4AssertLevel;
    Win4AssertLevel = ulNewLevel;
    return(ul);
}

//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

STDAPI_(int) PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile)
{

    int id;
    static char szAssertCaption[128];
    static char szModuleName[128];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char * pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }

    sprintf(szAssertCaption,"Process: %s File: %s line %u, thread id %d.%d",
        pszModuleName, szFile, iLine, pid, tid);


    DWORD dwMessageFlags = MB_SETFOREGROUND | MB_TASKMODAL |
                           MB_ICONEXCLAMATION | MB_OKCANCEL;

#ifndef _CHICAGO_
                     //  Since this code is also used by SCM.EXE, we pass
                     //  in the following flag which causes Service pop ups
                     //  to appear on the desktop correctly

    if (gfService)
    {
        dwMessageFlags |= MB_SERVICE_NOTIFICATION | MB_DEFAULT_DESKTOP_ONLY;
    }

    id = MessageBoxA(NULL,(char *) szMsg, (LPSTR) szAssertCaption,
                     dwMessageFlags);

# ifdef _CAIRO_
    // Other processes which are services also use this code, but they
    //  have no access to set gfService, so if the above failed with an
    //  access denied error (meaning no access to the default desktop)
    //  retry as a service popup. Also, remember that we are a service
    //  so we don't waste attempts later.
    if ( !gfService && !id
         && (GetLastError() == ERROR_ACCESS_DENIED) )
    {
        gfService = TRUE;
        dwMessageFlags |= MB_SERVICE_NOTIFICATION | MB_DEFAULT_DESKTOP_ONLY;
        id = MessageBoxA(NULL,(char *) szMsg, (LPSTR) szAssertCaption,
                         dwMessageFlags);
    }
# endif

#else
    id = SSMessageBox(NULL, (char *) szMsg, (LPSTR) szAssertCaption,
                     dwMessageFlags);

#endif

    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).  Oh well.

    return id;
}

//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

//
// This semaphore is *outside* vdprintf because the compiler isn't smart
// enough to serialize access for construction if it's function-local and
// protected by a guard variable.
//
//    KyleP - 20 May, 1993
//

static CMutexSem mxs;

STDAPI_(void) vdprintf(
    unsigned long ulCompMask,
    char const   *pszComp,
    char const   *ppszfmt,
    va_list       pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {
#if defined( FLAT )
        mxs.Request();
        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((Win4InfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
#endif // FLAT
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
#ifdef FLAT
#if defined(_CHICAGO_)
                //
                //  Hex Process/Thread ID's are better for Chicago since both
                //  are memory addresses.
                //
                w4dprintf( "%08x.%08x> ", pid, tid );
#else
                w4dprintf( "%d.%03d> ", pid, tid );
#endif
#endif // FLAT
                w4dprintf("%s: ", pszComp);
            }
            w4vdprintf(ppszfmt, pargs);
        }

#if defined( FLAT )
        if (Win4InfoLevel & DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4printf( "%03d> ", tid );
                w4printf("%s: ", pszComp);
            }
            w4vprintf(ppszfmt, pargs);
        }

        mxs.Release();
#endif // FLAT
    }
}

#else

int assertDontUseThisName(void)
{
    return 1;
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\coll.cxx ===
#include <urlint.h>
#include <map_kv.h>
#include "coll.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\ccompapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       ccompapi.cxx
//
//  Contents:   common compobj API Worker routines used by com, stg, scm etc
//
//  Classes:
//
//  Functions:
//
//  History:    31-Dec-93   ErikGav     Chicago port
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <ole2sp.h>
#include <ole2com.h>


NAME_SEG(CompApi)
ASSERTDATA

static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                8, 9, '-', 10, 11, 12, 13, 14, 15 };

static const WCHAR wszDigits[] = L"0123456789ABCDEF";


//+-------------------------------------------------------------------------
//
//  Function:   wStringFromGUID2     (internal)
//
//  Synopsis:   converts GUID into {...} form without leading identifier;
//
//  Arguments:  [rguid] - the guid to convert
//              [lpszy] - buffer to hold the results
//              [cbMax] - sizeof the buffer
//
//  Returns:    amount of data copied to lpsz if successful
//              0 if buffer too small.
//
//--------------------------------------------------------------------------
INTERNAL_(int)  wStringFromGUID2(REFGUID rguid, LPWSTR lpsz, int cbMax)
{
    int i;
    LPWSTR p = lpsz;

    const BYTE * pBytes = (const BYTE *) &rguid;

    *p++ = L'{';

    for (i = 0; i < sizeof(GuidMap); i++)
    {
        if (GuidMap[i] == '-')
        {
            *p++ = L'-';
        }
        else
        {
            *p++ = wszDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *p++ = wszDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
        }
    }
    *p++ = L'}';
    *p   = L'\0';

    return GUIDSTR_MAX;
}

#ifdef _CHICAGO_

static const CHAR szDigits[] = "0123456789ABCDEF";
//+-------------------------------------------------------------------------
//
//  Function:   wStringFromGUID2A     (internal)
//
//  Synopsis:   Ansi version of wStringFromGUID2 (for Win95 Optimizations)
//
//  Arguments:  [rguid] - the guid to convert
//              [lpszy] - buffer to hold the results
//              [cbMax] - sizeof the buffer
//
//  Returns:    amount of data copied to lpsz if successful
//              0 if buffer too small.
//
//--------------------------------------------------------------------------

INTERNAL_(int) wStringFromGUID2A(REFGUID rguid, LPSTR lpsz, int cbMax)  // internal
{
    int i;
    LPSTR p = lpsz;

    const BYTE * pBytes = (const BYTE *) &rguid;

    *p++ = '{';

    for (i = 0; i < sizeof(GuidMap); i++)
    {
        if (GuidMap[i] == '-')
        {
            *p++ = '-';
        }
        else
        {
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
        }
    }
    *p++ = '}';
    *p   = '\0';

    return GUIDSTR_MAX;
}
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\coletime.cxx ===
#include <urlint.h>
#include <map_kv.h>
#include "coll.hxx"
#include "coletime.hxx"
#include <math.h>


/////////////////////////////////////////////////////////////////////////////
// COleDateTime class HELPER definitions

// Verifies will fail if the needed buffer size is too large
#define MAX_TIME_BUFFER_SIZE    128         // matches that in timecore.cpp
#define MIN_DATE                (-657434L)  // about year 100
#define MAX_DATE                2958465L    // about year 9999

// Half a second, expressed in days
#define HALF_SECOND  (1.0/172800.0)

// One-based array of days in year at month start
static int rgMonthDays[13] =
{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};

static BOOL OleDateFromTm(WORD wYear, WORD wMonth, WORD wDay,
                          WORD wHour, WORD wMinute, WORD wSecond, DATE& dtDest);
static BOOL TmFromOleDate(DATE dtSrc, struct tm& tmDest);
static void TmConvertToStandardFormat(struct tm& tmSrc);
static double DoubleFromDate(DATE dt);
static DATE DateFromDouble(double dbl);

/////////////////////////////////////////////////////////////////////////////
// COleDateTime class

COleDateTime PASCAL COleDateTime::GetCurrentTime()
{
    return COleDateTime(::time(NULL));
}

int COleDateTime::GetYear() const
{
    struct tm tmTemp;

    if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
        return tmTemp.tm_year;
    else
        return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetMonth() const
{
    struct tm tmTemp;

    if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
        return tmTemp.tm_mon;
    else
        return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetDay() const
{
    struct tm tmTemp;

    if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
        return tmTemp.tm_mday;
    else
        return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetHour() const
{
    struct tm tmTemp;

    if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
        return tmTemp.tm_hour;
    else
        return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetMinute() const
{
    struct tm tmTemp;

    if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
        return tmTemp.tm_min;
    else
        return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetSecond() const
{
    struct tm tmTemp;

    if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
        return tmTemp.tm_sec;
    else
        return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetDayOfWeek() const
{
    struct tm tmTemp;

    if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
        return tmTemp.tm_wday;
    else
        return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetDayOfYear() const
{
    struct tm tmTemp;

    if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
        return tmTemp.tm_yday;
    else
        return AFX_OLE_DATETIME_ERROR;
}

#ifdef _not_this_
const COleDateTime& COleDateTime::operator=(const VARIANT& varSrc)
{
    if (varSrc.vt != VT_DATE)
    {
        TRY
        {
            COleVariant varTemp(varSrc);
            varTemp.ChangeType(VT_DATE);
            m_dt = varTemp.date;
            SetStatus(valid);
        }
        // Catch COleException from ChangeType, but not CMemoryException
        CATCH(COleException, e)
        {
            // Not able to convert VARIANT to DATE
            DELETE_EXCEPTION(e);
            m_dt = 0;
            SetStatus(invalid);
        }
        END_CATCH
    }
    else
    {
        m_dt = varSrc.date;
        SetStatus(valid);
    }

    return *this;
}
#endif //_not_this_

const COleDateTime& COleDateTime::operator=(DATE dtSrc)
{
    m_dt = dtSrc;
    SetStatus(valid);

    return *this;
}

const COleDateTime& COleDateTime::operator=(const time_t& timeSrc)
{
    // Convert time_t to struct tm
    tm *ptm = localtime(&timeSrc);

    if (ptm != NULL)
    {
        m_status = OleDateFromTm((WORD)ptm->tm_year + 1900,
                                 (WORD)(ptm->tm_mon + 1), (WORD)ptm->tm_mday,
                                 (WORD)ptm->tm_hour, (WORD)ptm->tm_min,
                                 (WORD)ptm->tm_sec, m_dt) ? valid : invalid;
    }
    else
    {
        // Local time must have failed (timsSrc before 1/1/70 12am)
        SetStatus(invalid);
        ASSERT(FALSE);
    }

    return *this;
}

const COleDateTime& COleDateTime::operator=(const SYSTEMTIME& systimeSrc)
{
    m_status = OleDateFromTm(systimeSrc.wYear, systimeSrc.wMonth,
                             systimeSrc.wDay, systimeSrc.wHour, systimeSrc.wMinute,
                             systimeSrc.wSecond, m_dt) ? valid : invalid;

    return *this;
}

const COleDateTime& COleDateTime::operator=(const FILETIME& filetimeSrc)
{
    // Assume UTC FILETIME, so convert to LOCALTIME
    FILETIME filetimeLocal;
    if (!FileTimeToLocalFileTime( &filetimeSrc, &filetimeLocal))
    {
#ifdef _DEBUG
        DWORD dwError = GetLastError();
        TRACE1("\nFileTimeToLocalFileTime failed. Error = %lu.\n\t", dwError);
#endif // _DEBUG
        m_status = invalid;
    }
    else
    {
        // Take advantage of SYSTEMTIME -> FILETIME conversion
        SYSTEMTIME systime;
        m_status = FileTimeToSystemTime(&filetimeLocal, &systime) ?
                   valid : invalid;

        // At this point systime should always be valid, but...
        if (GetStatus() == valid)
        {
            m_status = OleDateFromTm(systime.wYear, systime.wMonth,
                                     systime.wDay, systime.wHour, systime.wMinute,
                                     systime.wSecond, m_dt) ? valid : invalid;
        }
    }

    return *this;
}

BOOL COleDateTime::operator<(const COleDateTime& date) const
{
    ASSERT(GetStatus() == valid);
    ASSERT(date.GetStatus() == valid);

    // Handle negative dates
    return DoubleFromDate(m_dt) < DoubleFromDate(date.m_dt);
}

BOOL COleDateTime::operator>(const COleDateTime& date) const
{   ASSERT(GetStatus() == valid);
    ASSERT(date.GetStatus() == valid);

    // Handle negative dates
    return DoubleFromDate(m_dt) > DoubleFromDate(date.m_dt);
}

BOOL COleDateTime::operator<=(const COleDateTime& date) const
{
    ASSERT(GetStatus() == valid);
    ASSERT(date.GetStatus() == valid);

    // Handle negative dates
    return DoubleFromDate(m_dt) <= DoubleFromDate(date.m_dt);
}

BOOL COleDateTime::operator>=(const COleDateTime& date) const
{
    ASSERT(GetStatus() == valid);
    ASSERT(date.GetStatus() == valid);

    // Handle negative dates
    return DoubleFromDate(m_dt) >= DoubleFromDate(date.m_dt);
}

COleDateTime COleDateTime::operator+(const COleDateTimeSpan& dateSpan) const
{
    COleDateTime dateResult;    // Initializes m_status to valid

    // If either operand NULL, result NULL
    if (GetStatus() == null || dateSpan.GetStatus() == null)
    {
        dateResult.SetStatus(null);
        return dateResult;
    }

    // If either operand invalid, result invalid
    if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
    {
        dateResult.SetStatus(invalid);
        return dateResult;
    }

    // Compute the actual date difference by adding underlying dates
    dateResult = DateFromDouble(DoubleFromDate(m_dt) + dateSpan.m_span);

    // Validate within range
    dateResult.CheckRange();

    return dateResult;
}

COleDateTime COleDateTime::operator-(const COleDateTimeSpan& dateSpan) const
{
    COleDateTime dateResult;    // Initializes m_status to valid

    // If either operand NULL, result NULL
    if (GetStatus() == null || dateSpan.GetStatus() == null)
    {
        dateResult.SetStatus(null);
        return dateResult;
    }

    // If either operand invalid, result invalid
    if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
    {
        dateResult.SetStatus(invalid);
        return dateResult;
    }

    // Compute the actual date difference by subtracting underlying dates
    dateResult = DateFromDouble(DoubleFromDate(m_dt) - dateSpan.m_span);

    // Validate within range
    dateResult.CheckRange();

    return dateResult;
}

COleDateTimeSpan COleDateTime::operator-(const COleDateTime& date) const
{
    COleDateTimeSpan spanResult;

    // If either operand NULL, result NULL
    if (GetStatus() == null || date.GetStatus() == null)
    {
        spanResult.SetStatus(COleDateTimeSpan::null);
        return spanResult;
    }

    // If either operand invalid, result invalid
    if (GetStatus() == invalid || date.GetStatus() == invalid)
    {
        spanResult.SetStatus(COleDateTimeSpan::invalid);
        return spanResult;
    }

    // Return result (span can't be invalid, so don't check range)
    return DoubleFromDate(m_dt) - DoubleFromDate(date.m_dt);
}

BOOL COleDateTime::SetDateTime(int nYear, int nMonth, int nDay,
                               int nHour, int nMin, int nSec)
{
    return m_status = OleDateFromTm((WORD)nYear, (WORD)nMonth,
                                    (WORD)nDay, (WORD)nHour, (WORD)nMin, (WORD)nSec, m_dt) ?
                      valid : invalid;
}

#ifdef _not_yet_
BOOL COleDateTime::ParseDateTime(LPCTSTR lpszDate, DWORD dwFlags, LCID lcid)
{
    USES_CONVERSION;
    CString strDate = lpszDate;

    SCODE sc;
    if (FAILED(sc = VarDateFromStr((LPOLESTR)T2COLE(strDate), lcid,
                                   dwFlags, &m_dt)))
    {
        if (sc == DISP_E_TYPEMISMATCH)
        {
            // Can't convert string to date, set 0 and invalidate
            m_dt = 0;
            SetStatus(invalid);
            return FALSE;
        }
        else if (sc == DISP_E_OVERFLOW)
        {
            // Can't convert string to date, set -1 and invalidate
            m_dt = -1;
            SetStatus(invalid);
            return FALSE;
        }
        else
        {
            TRACE0("\nCOleDateTime VarDateFromStr call failed.\n\t");
            if (sc == E_OUTOFMEMORY)
                AfxThrowMemoryException();
            else
                AfxThrowOleException(sc);
        }
    }

    SetStatus(valid);
    return TRUE;
}

CString COleDateTime::Format(DWORD dwFlags, LCID lcid) const
{
    USES_CONVERSION;
    CString strDate;

    // If null, return empty string
    if (GetStatus() == null)
        return strDate;

    // If invalid, return DateTime resource string
    if (GetStatus() == invalid)
    {
        VERIFY(strDate.LoadString(AFX_IDS_INVALID_DATETIME));
        return strDate;
    }

    COleVariant var;
    // Don't need to trap error. Should not fail due to type mismatch
    CheckError(VarBstrFromDate(m_dt, lcid, dwFlags, &V_BSTR(&var)));
    var.vt = VT_BSTR;
    return OLE2CT(V_BSTR(&var));
}
#endif //_not_yet_

CString COleDateTime::Format(LPCTSTR pFormat) const
{
    CString strDate;
    struct tm tmTemp;

    // If null, return empty string
    if (GetStatus() == null)
        return strDate;

    // If invalid, return DateTime resource string
    if (GetStatus() == invalid || !TmFromOleDate(m_dt, tmTemp))
    {
        //VERIFY(strDate.LoadString(AFX_IDS_INVALID_DATETIME));
        return strDate;
    }

    // Convert tm from afx internal format to standard format
    TmConvertToStandardFormat(tmTemp);

    // Fill in the buffer, disregard return value as it's not necessary
    LPTSTR lpszTemp = strDate.GetBufferSetLength(MAX_TIME_BUFFER_SIZE);
    _tcsftime(lpszTemp, strDate.GetLength(), pFormat, &tmTemp);
    strDate.ReleaseBuffer();

    return strDate;
}

CString COleDateTime::Format(UINT nFormatID) const
{
    CString strFormat;
    //VERIFY(strFormat.LoadString(nFormatID) != 0);
    return Format(strFormat);
}

void COleDateTime::CheckRange()
{
    if (m_dt > MAX_DATE || m_dt < MIN_DATE) // about year 100 to about 9999
        SetStatus(invalid);
}

// serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleDateTime dateSrc)
{
    dc << "\nCOleDateTime Object:";
    dc << "\n\tm_status = " << (long)dateSrc.m_status;

    COleVariant var(dateSrc);
    var.ChangeType(VT_BSTR);

    return dc << "\n\tdate = " << (LPCTSTR)var.bstrVal;
}
#endif // _DEBUG

#ifdef _not_yet_
CArchive& AFXAPI operator<<(CArchive& ar, COleDateTime dateSrc)
{
    ar << (long)dateSrc.m_status;
    return ar << dateSrc.m_dt;
}

CArchive& AFXAPI operator>>(CArchive& ar, COleDateTime& dateSrc)
{
    ar >> (long&)dateSrc.m_status;
    return ar >> dateSrc.m_dt;
}
#endif //_not_yet_

/////////////////////////////////////////////////////////////////////////////
// COleDateTimeSpan class helpers

#define MAX_DAYS_IN_SPAN    3615897L

/////////////////////////////////////////////////////////////////////////////
// COleDateTimeSpan class
long COleDateTimeSpan::GetHours() const
{
    ASSERT(GetStatus() == valid);

    double dblTemp;

    // Truncate days and scale up
    dblTemp = modf(m_span, &dblTemp);
    return (long)(dblTemp * 24);
}

long COleDateTimeSpan::GetMinutes() const
{
    ASSERT(GetStatus() == valid);

    double dblTemp;

    // Truncate hours and scale up
    dblTemp = modf(m_span * 24, &dblTemp);
    return (long)(dblTemp * 60);
}

long COleDateTimeSpan::GetSeconds() const
{
    ASSERT(GetStatus() == valid);

    double dblTemp;

    // Truncate minutes and scale up
    dblTemp = modf(m_span * 24 * 60, &dblTemp);
    return (long)(dblTemp * 60);
}

const COleDateTimeSpan& COleDateTimeSpan::operator=(double dblSpanSrc)
{
    m_span = dblSpanSrc;
    SetStatus(valid);
    return *this;
}

const COleDateTimeSpan& COleDateTimeSpan::operator=(const COleDateTimeSpan& dateSpanSrc)
{
    m_span = dateSpanSrc.m_span;
    m_status = dateSpanSrc.m_status;
    return *this;
}

COleDateTimeSpan COleDateTimeSpan::operator+(const COleDateTimeSpan& dateSpan) const
{
    COleDateTimeSpan dateSpanTemp;

    // If either operand Null, result Null
    if (GetStatus() == null || dateSpan.GetStatus() == null)
    {
        dateSpanTemp.SetStatus(null);
        return dateSpanTemp;
    }

    // If either operand Invalid, result Invalid
    if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
    {
        dateSpanTemp.SetStatus(invalid);
        return dateSpanTemp;
    }

    // Add spans and validate within legal range
    dateSpanTemp.m_span = m_span + dateSpan.m_span;
    dateSpanTemp.CheckRange();

    return dateSpanTemp;
}

COleDateTimeSpan COleDateTimeSpan::operator-(const COleDateTimeSpan& dateSpan) const
{
    COleDateTimeSpan dateSpanTemp;

    // If either operand Null, result Null
    if (GetStatus() == null || dateSpan.GetStatus() == null)
    {
        dateSpanTemp.SetStatus(null);
        return dateSpanTemp;
    }

    // If either operand Invalid, result Invalid
    if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
    {
        dateSpanTemp.SetStatus(invalid);
        return dateSpanTemp;
    }

    // Subtract spans and validate within legal range
    dateSpanTemp.m_span = m_span - dateSpan.m_span;
    dateSpanTemp.CheckRange();

    return dateSpanTemp;
}

void COleDateTimeSpan::SetDateTimeSpan(
                                      long lDays, int nHours, int nMins, int nSecs)
{
    // Set date span by breaking into fractional days (all input ranges valid)
    m_span = lDays + ((double)nHours)/24 + ((double)nMins)/(24*60) +
             ((double)nSecs)/(24*60*60);

    SetStatus(valid);
}

CString COleDateTimeSpan::Format(LPCTSTR pFormat) const
{
    CString strSpan;
    struct tm tmTemp;

    // If null, return empty string
    if (GetStatus() == null)
        return strSpan;

    // If invalid, return DateTimeSpan resource string
    if (GetStatus() == invalid || !TmFromOleDate(m_span, tmTemp))
    {
        //VERIFY(strSpan.LoadString(AFX_IDS_INVALID_DATETIMESPAN));
        return strSpan;
    }

    // Convert tm from afx internal format to standard format
    TmConvertToStandardFormat(tmTemp);

    // Fill in the buffer, disregard return value as it's not necessary
    LPTSTR lpszTemp = strSpan.GetBufferSetLength(MAX_TIME_BUFFER_SIZE);
    _tcsftime(lpszTemp, strSpan.GetLength(), pFormat, &tmTemp);
    strSpan.ReleaseBuffer();

    return strSpan;
}

CString COleDateTimeSpan::Format(UINT nFormatID) const
{
    CString strFormat;
    //VERIFY(strFormat.LoadString(nFormatID) != 0);
    return Format(strFormat);
}

void COleDateTimeSpan::CheckRange()
{
    if (m_span < -MAX_DAYS_IN_SPAN || m_span > MAX_DAYS_IN_SPAN)
        SetStatus(invalid);
}

// serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleDateTimeSpan dateSpanSrc)
{
    dc << "\nCOleDateTimeSpan Object:";
    dc << "\n\tm_status = " << (long)dateSpanSrc.m_status;

    COleVariant var(dateSpanSrc.m_span);
    var.ChangeType(VT_BSTR);

    return dc << "\n\tdateSpan = " << (LPCTSTR)var.bstrVal;
}
#endif // _DEBUG

#ifdef _not_yet_
CArchive& AFXAPI operator<<(CArchive& ar, COleDateTimeSpan dateSpanSrc)
{
    ar << (long)dateSpanSrc.m_status;
    return ar << dateSpanSrc.m_span;
}

CArchive& AFXAPI operator>>(CArchive& ar, COleDateTimeSpan& dateSpanSrc)
{
    ar >> (long&)dateSpanSrc.m_status;
    return ar >> dateSpanSrc.m_span;
}
#endif //_not_yet_

/////////////////////////////////////////////////////////////////////////////
// COleDateTime class HELPERS - implementation

BOOL OleDateFromTm(WORD wYear, WORD wMonth, WORD wDay,
                   WORD wHour, WORD wMinute, WORD wSecond, DATE& dtDest)
{
    // Validate year and month (ignore day of week and milliseconds)
    if (wYear > 9999 || wMonth < 1 || wMonth > 12)
        return FALSE;

    //  Check for leap year and set the number of days in the month
    BOOL bLeapYear = ((wYear & 3) == 0) &&
                     ((wYear % 100) != 0 || (wYear % 400) == 0);

    int nDaysInMonth =
    rgMonthDays[wMonth] - rgMonthDays[wMonth-1] +
    ((bLeapYear && wDay == 29 && wMonth == 2) ? 1 : 0);

    // Finish validating the date
    if (wDay < 1 || wDay > nDaysInMonth ||
        wHour > 23 || wMinute > 59 ||
        wSecond > 59)
    {
        return FALSE;
    }

    // Cache the date in days and time in fractional days
    long nDate;
    double dblTime;

    //It is a valid date; make Jan 1, 1AD be 1
    nDate = wYear*365L + wYear/4 - wYear/100 + wYear/400 +
            rgMonthDays[wMonth-1] + wDay;

    //  If leap year and it's before March, subtract 1:
    if (wMonth <= 2 && bLeapYear)
        --nDate;

    //  Offset so that 12/30/1899 is 0
    nDate -= 693959L;

    dblTime = (((long)wHour * 3600L) +  // hrs in seconds
               ((long)wMinute * 60L) +  // mins in seconds
               ((long)wSecond)) / 86400.;

    dtDest = (double) nDate + ((nDate >= 0) ? dblTime : -dblTime);

    return TRUE;
}

BOOL TmFromOleDate(DATE dtSrc, struct tm& tmDest)
{
    // The legal range does not actually span year 0 to 9999.
    if (dtSrc > MAX_DATE || dtSrc < MIN_DATE) // about year 100 to about 9999
        return FALSE;

    long nDays;             // Number of days since Dec. 30, 1899
    long nDaysAbsolute;     // Number of days since 1/1/0
    long nSecsInDay;        // Time in seconds since midnight
    long nMinutesInDay;     // Minutes in day

    long n400Years;         // Number of 400 year increments since 1/1/0
    long n400Century;       // Century within 400 year block (0,1,2 or 3)
    long n4Years;           // Number of 4 year increments since 1/1/0
    long n4Day;             // Day within 4 year block
    //  (0 is 1/1/yr1, 1460 is 12/31/yr4)
    long n4Yr;              // Year within 4 year block (0,1,2 or 3)
    BOOL bLeap4 = TRUE;     // TRUE if 4 year block includes leap year

    double dblDate = dtSrc; // tempory serial date

    // If a valid date, then this conversion should not overflow
    nDays = (long)dblDate;

    // Round to the second
    dblDate += ((dtSrc > 0.0) ? HALF_SECOND : -HALF_SECOND);

    nDaysAbsolute = (long)dblDate + 693959L; // Add days from 1/1/0 to 12/30/1899

    dblDate = fabs(dblDate);
    nSecsInDay = (long)((dblDate - floor(dblDate)) * 86400.);

    // Calculate the day of week (sun=1, mon=2...)
    //   -1 because 1/1/0 is Sat.  +1 because we want 1-based
    tmDest.tm_wday = (int)((nDaysAbsolute - 1) % 7L) + 1;

    // Leap years every 4 yrs except centuries not multiples of 400.
    n400Years = (long)(nDaysAbsolute / 146097L);

    // Set nDaysAbsolute to day within 400-year block
    nDaysAbsolute %= 146097L;

    // -1 because first century has extra day
    n400Century = (long)((nDaysAbsolute - 1) / 36524L);

    // Non-leap century
    if (n400Century != 0)
    {
        // Set nDaysAbsolute to day within century
        nDaysAbsolute = (nDaysAbsolute - 1) % 36524L;

        // +1 because 1st 4 year increment has 1460 days
        n4Years = (long)((nDaysAbsolute + 1) / 1461L);

        if (n4Years != 0)
            n4Day = (long)((nDaysAbsolute + 1) % 1461L);
        else
        {
            bLeap4 = FALSE;
            n4Day = (long)nDaysAbsolute;
        }
    }
    else
    {
        // Leap century - not special case!
        n4Years = (long)(nDaysAbsolute / 1461L);
        n4Day = (long)(nDaysAbsolute % 1461L);
    }

    if (bLeap4)
    {
        // -1 because first year has 366 days
        n4Yr = (n4Day - 1) / 365;

        if (n4Yr != 0)
            n4Day = (n4Day - 1) % 365;
    }
    else
    {
        n4Yr = n4Day / 365;
        n4Day %= 365;
    }

    // n4Day is now 0-based day of year. Save 1-based day of year, year number
    tmDest.tm_yday = (int)n4Day + 1;
    tmDest.tm_year = n400Years * 400 + n400Century * 100 + n4Years * 4 + n4Yr;

    // Handle leap year: before, on, and after Feb. 29.
    if (n4Yr == 0 && bLeap4)
    {
        // Leap Year
        if (n4Day == 59)
        {
            /* Feb. 29 */
            tmDest.tm_mon = 2;
            tmDest.tm_mday = 29;
            goto DoTime;
        }

        // Pretend it's not a leap year for month/day comp.
        if (n4Day >= 60)
            --n4Day;
    }

    // Make n4DaY a 1-based day of non-leap year and compute
    //  month/day for everything but Feb. 29.
    ++n4Day;

    // Month number always >= n/32, so save some loop time */
    for (tmDest.tm_mon = (n4Day >> 5) + 1;
        n4Day > rgMonthDays[tmDest.tm_mon]; tmDest.tm_mon++);

    tmDest.tm_mday = (int)(n4Day - rgMonthDays[tmDest.tm_mon-1]);

    DoTime:
    if (nSecsInDay == 0)
        tmDest.tm_hour = tmDest.tm_min = tmDest.tm_sec = 0;
    else
    {
        tmDest.tm_sec = (int)nSecsInDay % 60L;
        nMinutesInDay = nSecsInDay / 60L;
        tmDest.tm_min = (int)nMinutesInDay % 60;
        tmDest.tm_hour = (int)nMinutesInDay / 60;
    }

    return TRUE;
}

void TmConvertToStandardFormat(struct tm& tmSrc)
{
    // Convert afx internal tm to format expected by runtimes (_tcsftime, etc)
    tmSrc.tm_year -= 1900;  // year is based on 1900
    tmSrc.tm_mon -= 1;      // month of year is 0-based
    tmSrc.tm_wday -= 1;     // day of week is 0-based
    tmSrc.tm_yday -= 1;     // day of year is 0-based
}

double DoubleFromDate(DATE dt)
{
    // No problem if positive
    if (dt >= 0)
        return dt;

    // If negative, must convert since negative dates not continuous
    // (examples: -1.25 to -.75, -1.50 to -.50, -1.75 to -.25)
    double temp = ceil(dt);
    return temp - (dt - temp);
}

DATE DateFromDouble(double dbl)
{
    // No problem if positive
    if (dbl >= 0)
        return dbl;

    // If negative, must convert since negative dates not continuous
    // (examples: -.75 to -1.25, -.50 to -1.50, -.25 to -1.75)
    double temp = floor(dbl); // dbl is now whole part
    return temp + (temp - dbl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\cvar.cxx ===
#include <malloc.h>
#include <urlint.h>
#include <map_kv.h>
#include "coll.hxx"
#ifndef unix
#include "COleTime.hxx"
#else
#include "coletime.hxx"
#endif /* unix */
#include "cvar.hxx"

//void * _cdecl operator new(size_t sizeEl, ULONG cEl);
void * _cdecl operator new(size_t sizeEl, COleVariant *pCVar);

void * _cdecl operator new(size_t sizeEl, COleVariant *pCVar)
{
    return  0;
}

/*
struct AFX_EXCEPTION_LINK
{
#ifdef _AFX_OLD_EXCEPTIONS
        union
        {
                _AFX_JUMPBUF m_jumpBuf;
                struct
                {
                        void (PASCAL* pfnCleanup)(AFX_EXCEPTION_LINK* pLink);
                        void* pvData;       // extra data follows
                } m_callback;       // callback for cleanup (nType != 0)
        };
        UINT m_nType;               // 0 for setjmp, !=0 for user extension
#endif //!_AFX_OLD_EXCEPTIONS

        AFX_EXCEPTION_LINK* m_pLinkPrev;    // previous top, next in handler chain
        CException* m_pException;   // current exception (NULL in TRY block)

        AFX_EXCEPTION_LINK();       // for initialization and linking
        ~AFX_EXCEPTION_LINK()       // for cleanup and unlinking
                { AfxTryCleanup(); };
};
*/
#define TRY { AFX_EXCEPTION_LINK _afxExceptionLink; try {

#define CATCH(class, e) } catch (class* e) \
        { ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); \
                _afxExceptionLink.m_pException = e;

#define AND_CATCH(class, e) } catch (class* e) \
        { ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); \
                _afxExceptionLink.m_pException = e;

#define END_CATCH } }


#define THROW(e) throw e
#define THROW_LAST() (AfxThrowLastCleanup(), throw)

// Advanced macros for smaller code
#define CATCH_ALL(e) } catch (CException* e) \
        { { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); \
                _afxExceptionLink.m_pException = e;

#define AND_CATCH_ALL(e) } catch (CException* e) \
        { { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); \
                _afxExceptionLink.m_pException = e;

#define END_CATCH_ALL } } }

#define END_TRY } catch (CException* e) \
        { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); \
                _afxExceptionLink.m_pException = e; } }

#define AFX_OLE_FALSE 0
#define AFX_OLE_TRUE (-1)

#ifndef _DEBUG
#define USES_CONVERSION int _convert; _convert
#else
#define USES_CONVERSION int _convert = 0;
#endif

#ifdef _DEBUG
#define UNUSED(x)
#else
#define UNUSED(x) x
#endif
#define UNUSED_ALWAYS(x) x


/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers

LPWSTR AFXAPI AfxA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars);
LPSTR AFXAPI AfxW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars);

#define A2CW(lpa) (\
        ((LPCSTR)lpa == NULL) ? NULL : (\
                _convert = (lstrlenA(lpa)+1),\
                (LPCWSTR)AfxA2WHelper((LPWSTR) alloca(_convert*2), lpa, _convert)\
        )\
)

#define A2W(lpa) (\
        ((LPCSTR)lpa == NULL) ? NULL : (\
                _convert = (lstrlenA(lpa)+1),\
                AfxA2WHelper((LPWSTR) alloca(_convert*2), lpa, _convert)\
        )\
)

#define W2CA(lpw) (\
        ((LPCWSTR)lpw == NULL) ? NULL : (\
                _convert = (wcslen(lpw)+1)*2,\
                (LPCSTR)AfxW2AHelper((LPSTR) alloca(_convert), lpw, _convert)\
        )\
)

#define W2A(lpw) (\
        ((LPCWSTR)lpw == NULL) ? NULL : (\
                _convert = (wcslen(lpw)+1)*2,\
                AfxW2AHelper((LPSTR) alloca(_convert), lpw, _convert)\
        )\
)


#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
        #define DEVMODEOLE DEVMODEW
        #define LPDEVMODEOLE LPDEVMODEW
        #define TEXTMETRICOLE TEXTMETRICW
        #define LPTEXTMETRICOLE LPTEXTMETRICW
        inline size_t ocslen(LPCOLESTR x) { return wcslen(x); }
        inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return wcscpy(dest, src); }
        inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; }
        inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; }
        inline LPOLESTR T2OLE(LPTSTR lp) { return lp; }
        inline LPTSTR OLE2T(LPOLESTR lp) { return lp; }
        inline LPOLESTR TASKSTRINGT2OLE(LPOLESTR lp) { return lp; }
        inline LPTSTR TASKSTRINGOLE2T(LPOLESTR lp) { return lp; }
        inline LPDEVMODEW DEVMODEOLE2T(LPDEVMODEOLE lp) { return lp; }
        inline LPDEVMODEOLE DEVMODET2OLE(LPDEVMODEW lp) { return lp; }
        inline LPTEXTMETRICW TEXTMETRICOLE2T(LPTEXTMETRICOLE lp) { return lp; }
        inline LPTEXTMETRICOLE TEXTMETRICT2OLE(LPTEXTMETRICW lp) { return lp; }
        inline BSTR BSTR2TBSTR(BSTR bstr) { return bstr;}
#elif defined(OLE2ANSI)
// in these cases the default (TCHAR) is the same as OLECHAR
        #define DEVMODEOLE DEVMODEA
        #define LPDEVMODEOLE LPDEVMODEA
        #define TEXTMETRICOLE TEXTMETRICA
        #define LPTEXTMETRICOLE LPTEXTMETRICA
        inline size_t ocslen(LPCOLESTR x) { return lstrlenA(x); }
        inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return lstrcpyA(dest, src); }
        inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; }
        inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; }
        inline LPOLESTR T2OLE(LPTSTR lp) { return lp; }
        inline LPTSTR OLE2T(LPOLESTR lp) { return lp; }
        inline LPOLESTR TASKSTRINGT2OLE(LPOLESTR lp) { return lp; }
        inline LPTSTR TASKSTRINGOLE2T(LPOLESTR lp) { return lp; }
        inline LPDEVMODE DEVMODEOLE2T(LPDEVMODEOLE lp) { return lp; }
        inline LPDEVMODEOLE DEVMODET2OLE(LPDEVMODE lp) { return lp; }
        inline LPTEXTMETRIC TEXTMETRICOLE2T(LPTEXTMETRICOLE lp) { return lp; }
        inline LPTEXTMETRICOLE TEXTMETRICT2OLE(LPTEXTMETRIC lp) { return lp; }
        inline BSTR BSTR2TBSTR(BSTR bstr) { return bstr; }
#else
        #define DEVMODEOLE DEVMODEW
        #define LPDEVMODEOLE LPDEVMODEW
        #define TEXTMETRICOLE TEXTMETRICW
        #define LPTEXTMETRICOLE LPTEXTMETRICW
        inline size_t ocslen(LPCOLESTR x) { return wcslen(x); }
        inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return wcscpy(dest, src); }
        #define T2COLE(lpa) A2CW(lpa)
        #define T2OLE(lpa) A2W(lpa)
        #define OLE2CT(lpo) W2CA(lpo)
        #define OLE2T(lpo) W2A(lpo)
        #define TASKSTRINGT2OLE(lpa)    AfxTaskStringA2W(lpa)
        #define TASKSTRINGOLE2T(lpo) AfxTaskStringW2A(lpo)
        #define DEVMODEOLE2T(lpo) DEVMODEW2A(lpo)
        #define DEVMODET2OLE(lpa) DEVMODEA2W(lpa)
        #define TEXTMETRICOLE2T(lptmw) TEXTMETRICW2A(lptmw)
        #define TEXTMETRICT2OLE(lptma) TEXTMETRICA2W(lptma)
        #define BSTR2TBSTR(bstr) AfxBSTR2ABSTR(bstr)
#endif

#ifdef OLE2ANSI
        #define W2OLE W2A
        #define W2COLE W2CA
        #define OLE2W A2W
        #define OLE2CW A2CW
        inline LPOLESTR A2OLE(LPSTR lp) { return lp; }
        inline LPCOLESTR A2COLE(LPCSTR lp) { return lp; }
        inline LPSTR OLE2A(LPOLESTR lp) { return lp; }
        inline LPCSTR OLE2CA(LPCOLESTR lp) { return lp; }
#else
        #define A2OLE A2W
        #define A2COLE A2CW
        #define OLE2A W2A
        #define OLE2CA W2CA
        inline LPOLESTR W2OLE(LPWSTR lp) { return lp; }
        inline LPCOLESTR W2COLE(LPCWSTR lp) { return lp; }
        inline LPWSTR OLE2W(LPOLESTR lp) { return lp; }
        inline LPCWSTR OLE2CW(LPCOLESTR lp) { return lp; }
#endif

/////////////////////////////////////////////////////////////////////////////
// helpers

static void PASCAL CheckError(SCODE sc);
static BOOL PASCAL CompareSafeArrays(SAFEARRAY* parray1, SAFEARRAY* parray2);
static void PASCAL CreateOneDimArray(VARIANT& varSrc, DWORD dwSize);
static void PASCAL CopyBinaryData(SAFEARRAY* parray,
        const void* pSrc, DWORD dwSize);

/////////////////////////////////////////////////////////////////////////////
// COleVariant class

COleVariant::COleVariant(const VARIANT& varSrc)
{
        AfxVariantInit(this);
        CheckError(::VariantCopy(this, (LPVARIANT)&varSrc));
}

COleVariant::COleVariant(LPCVARIANT pSrc)
{
        AfxVariantInit(this);
        CheckError(::VariantCopy(this, (LPVARIANT)pSrc));
}

COleVariant::COleVariant(const COleVariant& varSrc)
{
        AfxVariantInit(this);
        CheckError(::VariantCopy(this, (LPVARIANT)&varSrc));
}

COleVariant::COleVariant(LPCTSTR lpszSrc, VARTYPE vtSrc)
{
        USES_CONVERSION;
        ASSERT(vtSrc == VT_BSTR || vtSrc == VT_BSTRT);
        UNUSED(vtSrc);

        vt = VT_BSTR;
        bstrVal = NULL;

        if (lpszSrc != NULL)
        {
#ifndef _UNICODE
                if (vtSrc == VT_BSTRT)
                {
                        int nLen = lstrlen(lpszSrc);
                        bstrVal = ::SysAllocStringByteLen(lpszSrc, nLen);
                }
                else
#endif
                {
                        bstrVal = ::SysAllocString(T2COLE(lpszSrc));
                }

                /*
                BUGBUG:
                if (bstrVal == NULL)
                        AfxThrowMemoryException();
                */
        }
}

void COleVariant::SetString(LPCTSTR lpszSrc, VARTYPE vtSrc)
{
        USES_CONVERSION;
        ASSERT(vtSrc == VT_BSTR || vtSrc == VT_BSTRT);
        UNUSED(vtSrc);

        // Free up previous VARIANT
        Clear();

        vt = VT_BSTR;
        bstrVal = NULL;

        if (lpszSrc != NULL)
        {
#ifndef _UNICODE
                if (vtSrc == VT_BSTRT)
                {
                        int nLen = lstrlen(lpszSrc);
                        bstrVal = ::SysAllocStringByteLen(lpszSrc, nLen);
                }
                else
#endif
                {
                        bstrVal = ::SysAllocString(T2COLE(lpszSrc));
                }

                /*
                BUGBUG:
                if (bstrVal == NULL)
                        AfxThrowMemoryException();
                */
        }
}

COleVariant::COleVariant(short nSrc, VARTYPE vtSrc)
{
        ASSERT(vtSrc == VT_I2 || vtSrc == VT_BOOL);

        if (vtSrc == VT_BOOL)
        {
                vt = VT_BOOL;
                if (nSrc == FALSE)
                        V_BOOL(this) = AFX_OLE_FALSE;
                else
                        V_BOOL(this) = AFX_OLE_TRUE;
        }
        else
        {
                vt = VT_I2;
                iVal = nSrc;
        }
}

COleVariant::COleVariant(long lSrc, VARTYPE vtSrc)
{
        ASSERT(vtSrc == VT_I4 || vtSrc == VT_ERROR || vtSrc == VT_BOOL);

        if (vtSrc == VT_ERROR)
        {
                vt = VT_ERROR;
                scode = lSrc;
        }
        else if (vtSrc == VT_BOOL)
        {
                vt = VT_BOOL;
                if (lSrc == FALSE)
                        V_BOOL(this) = AFX_OLE_FALSE;
                else
                        V_BOOL(this) = AFX_OLE_TRUE;
        }
        else
        {
                vt = VT_I4;
                lVal = lSrc;
        }
}

// Operations
void COleVariant::Clear()
{
        VERIFY(::VariantClear(this) == NOERROR);
}

void COleVariant::ChangeType(VARTYPE vartype, LPVARIANT pSrc)
{
        // If pSrc is NULL, convert type in place
        if (pSrc == NULL)
                pSrc = this;
        if (pSrc != this || vartype != vt)
                CheckError(::VariantChangeType(this, pSrc, 0, vartype));
}

void COleVariant::Attach(VARIANT& varSrc)
{
        // Free up previous VARIANT
        Clear();

        // give control of data to COleVariant
        memcpy(this, &varSrc, sizeof(varSrc));
        varSrc.vt = VT_EMPTY;
}

VARIANT COleVariant::Detach()
{
        VARIANT varResult = *this;
        vt = VT_EMPTY;
        return varResult;
}

// Literal comparison. Types and values must match.
BOOL COleVariant::operator==(const VARIANT& var) const
{
        if (&var == this)
                return TRUE;

        // Variants not equal if types don't match
        if (var.vt != vt)
                return FALSE;

        // Check type specific values
        switch (vt)
        {
        case VT_EMPTY:
        case VT_NULL:
                return TRUE;

        case VT_BOOL:
                return V_BOOL(&var) == V_BOOL(this);

        case VT_UI1:
                return var.bVal == bVal;

        case VT_I2:
                return var.iVal == iVal;

        case VT_I4:
                return var.lVal == lVal;

        case VT_CY:
                return (var.cyVal.Hi == cyVal.Hi && var.cyVal.Lo == cyVal.Lo);

        case VT_R4:
                return var.fltVal == fltVal;

        case VT_R8:
                return var.dblVal == dblVal;

        case VT_DATE:
                return var.date == date;

        case VT_BSTR:
                return SysStringByteLen(var.bstrVal) == SysStringByteLen(bstrVal) &&
                        memcmp(var.bstrVal, bstrVal, SysStringByteLen(bstrVal)) == 0;

        case VT_ERROR:
                return var.scode == scode;

        case VT_DISPATCH:
        case VT_UNKNOWN:
                return var.punkVal == punkVal;

        default:
                if (vt & VT_ARRAY && !(vt & VT_BYREF))
                        return CompareSafeArrays(var.parray, parray);
                else
                        ASSERT(FALSE);  // VT_BYREF not supported
                // fall through
        }

        return FALSE;
}

const COleVariant& COleVariant::operator=(const VARIANT& varSrc)
{
        CheckError(::VariantCopy(this, (LPVARIANT)&varSrc));
        return *this;
}

const COleVariant& COleVariant::operator=(LPCVARIANT pSrc)
{
        CheckError(::VariantCopy(this, (LPVARIANT)pSrc));
        return *this;
}

const COleVariant& COleVariant::operator=(const COleVariant& varSrc)
{
        CheckError(::VariantCopy(this, (LPVARIANT)&varSrc));
        return *this;
}

const COleVariant& COleVariant::operator=(const LPCTSTR lpszSrc)
{
        USES_CONVERSION;
        // Free up previous VARIANT
        Clear();

        vt = VT_BSTR;
        if (lpszSrc == NULL)
                bstrVal = NULL;
        else
        {
                bstrVal = ::SysAllocString(T2COLE(lpszSrc));
                /*
                BUGBUG:
                if (bstrVal == NULL)
                        AfxThrowMemoryException();
                */
        }
        return *this;
}

const COleVariant& COleVariant::operator=(const CString& strSrc)
{
        USES_CONVERSION;
        // Free up previous VARIANT
        Clear();

        vt = VT_BSTR;
        bstrVal = ::SysAllocString(T2COLE(strSrc));
        /*
        BUGBUG:
        if (bstrVal == NULL)
                AfxThrowMemoryException();
        */

        return *this;
}

const COleVariant& COleVariant::operator=(BYTE nSrc)
{
        // Free up previous VARIANT if necessary
        if (vt != VT_UI1)
        {
                Clear();
                vt = VT_UI1;
        }

        bVal = nSrc;
        return *this;
}

const COleVariant& COleVariant::operator=(short nSrc)
{
        if (vt == VT_I2)
                iVal = nSrc;
        else if (vt == VT_BOOL)
        {
                if (nSrc == FALSE)
                        V_BOOL(this) = AFX_OLE_FALSE;
                else
                        V_BOOL(this) = AFX_OLE_TRUE;
        }
        else
        {
                // Free up previous VARIANT
                Clear();
                vt = VT_I2;
                iVal = nSrc;
        }

        return *this;
}

const COleVariant& COleVariant::operator=(long lSrc)
{
        if (vt == VT_I4)
                lVal = lSrc;
        else if (vt == VT_ERROR)
                scode = lSrc;
        else if (vt == VT_BOOL)
        {
                if (lSrc == FALSE)
                        V_BOOL(this) = AFX_OLE_FALSE;
                else
                        V_BOOL(this) = AFX_OLE_TRUE;
        }
        else
        {
                // Free up previous VARIANT
                Clear();
                vt = VT_I4;
                lVal = lSrc;
        }

        return *this;
}

/*
const COleVariant& COleVariant::operator=(const COleCurrency& curSrc)
{
        // Free up previous VARIANT if necessary
        if (vt != VT_CY)
        {
                Clear();
                vt = VT_CY;
        }

        cyVal = curSrc.m_cur;
        return *this;
}
*/
const COleVariant& COleVariant::operator=(float fltSrc)
{
        // Free up previous VARIANT if necessary
        if (vt != VT_R4)
        {
                Clear();
                vt = VT_R4;
        }

        fltVal = fltSrc;
        return *this;
}

const COleVariant& COleVariant::operator=(double dblSrc)
{
        // Free up previous VARIANT if necessary
        if (vt != VT_R8)
        {
                Clear();
                vt = VT_R8;
        }

        dblVal = dblSrc;
        return *this;
}

const COleVariant& COleVariant::operator=(const COleDateTime& dateSrc)
{
        // Free up previous VARIANT if necessary
        if (vt != VT_DATE)
        {
                Clear();
                vt = VT_DATE;
        }

        date = dateSrc.m_dt;
        return *this;
}
/*
const COleVariant& COleVariant::operator=(const CByteArray& arrSrc)
{
        int nSize = arrSrc.GetSize();

        // Set the correct type and make sure SafeArray can hold data
        CreateOneDimArray(*this, (DWORD)nSize);

        // Copy the data into the SafeArray
        CopyBinaryData(parray, arrSrc.GetData(), (DWORD)nSize);

        return *this;
}
const COleVariant& COleVariant::operator=(const CLongBinary& lbSrc)
{
        // Set the correct type and make sure SafeArray can hold data
        CreateOneDimArray(*this, lbSrc.m_dwDataLength);

        // Copy the data into the SafeArray
        BYTE* pData = (BYTE*)::GlobalLock(lbSrc.m_hData);
        CopyBinaryData(parray, pData, lbSrc.m_dwDataLength);
        ::GlobalUnlock(lbSrc.m_hData);

        return *this;
}
*/

void AFXAPI AfxVariantInit(LPVARIANT pVar)
{
        memset(pVar, 0, sizeof(*pVar));
}

/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
CDumpContext& AFXAPI operator <<(CDumpContext& dc, COleVariant varSrc)
{
        LPCVARIANT pSrc = (LPCVARIANT)varSrc;

        dc << "\nCOleVariant Object:";
        dc << "\n\t vt = " << pSrc->vt;

        // No support for VT_BYREF & VT_ARRAY
        if (pSrc->vt & VT_BYREF || pSrc->vt & VT_ARRAY)
                return dc;

        switch (pSrc->vt)
        {
        case VT_BOOL:
                return dc << "\n\t VT_BOOL = " << V_BOOL(pSrc);

        case VT_UI1:
                return dc << "\n\t bVal = " << pSrc->bVal;

        case VT_I2:
                return dc << "\n\t iVal = " << pSrc->iVal;

        case VT_I4:
                return dc << "\n\t lVal = " << pSrc->lVal;

        case VT_CY:
                {
                        COleVariant var(varSrc);
                        var.ChangeType(VT_BSTR);
                        return dc << "\n\t cyVal = " << (LPCTSTR)var.bstrVal;
                }

        case VT_R4:
                return dc << "\n\t fltVal = " << pSrc->fltVal;

        case VT_R8:
                return dc << "\n\t dblVal = " << pSrc->dblVal;

        case VT_DATE:
                {
                        COleVariant var(varSrc);
                        var.ChangeType(VT_BSTR);
                        return dc << "\n\t date = " << (LPCTSTR)var.bstrVal;
                }

        case VT_BSTR:
                return dc << "\n\t bstrVal = " << (LPCTSTR)pSrc->bstrVal;

        case VT_ERROR:
                return dc << "\n\t scode = " << pSrc->scode;

        case VT_DISPATCH:
        case VT_UNKNOWN:
                return dc << "\n\t punkVal = " << pSrc->punkVal;

        case VT_EMPTY:
        case VT_NULL:
                return dc;

        default:
                ASSERT(FALSE);
                return dc;
        }
}
#endif // _DEBUG


#ifdef _with_archive_
CArchive& AFXAPI operator<<(CArchive& ar, COleVariant varSrc)
{
        LPCVARIANT pSrc = (LPCVARIANT)varSrc;

        ar << pSrc->vt;

        // No support for VT_BYREF & VT_ARRAY
        if (pSrc->vt & VT_BYREF || pSrc->vt & VT_ARRAY)
                return ar;

        switch (pSrc->vt)
        {
        case VT_BOOL:
                return ar << (WORD)V_BOOL(pSrc);

        case VT_UI1:
                return ar << pSrc->bVal;

        case VT_I2:
                return ar << (WORD)pSrc->iVal;

        case VT_I4:
                return ar << pSrc->lVal;

        case VT_CY:
                ar << pSrc->cyVal.Lo;
                return ar << pSrc->cyVal.Hi;

        case VT_R4:
                return ar << pSrc->fltVal;

        case VT_R8:
                return ar << pSrc->dblVal;

        case VT_DATE:
                return ar << pSrc->date;

        case VT_BSTR:
                {
                        DWORD nLen = SysStringByteLen(pSrc->bstrVal);
                        ar << nLen;
                        if (nLen > 0)
                                ar.Write(pSrc->bstrVal, nLen * sizeof(BYTE));

                        return ar;
                }

        case VT_ERROR:
                return ar << pSrc->scode;

#ifdef _WITH_PUNK_
        case VT_DISPATCH:
        case VT_UNKNOWN:
                {
                        LPPERSISTSTREAM pPersistStream;
                        //BUGBUG
                        //CArchiveStream stm(&ar);

                        // QI for IPersistStream or IPeristStreamInit
                        SCODE sc = pSrc->punkVal->QueryInterface(
                                IID_IPersistStream, (void**)&pPersistStream);
//#ifndef _AFX_NO_OCC_SUPPORT
#ifdef _AFX_OCC_SUPPORT
                        if (FAILED(sc))
                                sc = pSrc->punkVal->QueryInterface(
                                        IID_IPersistStreamInit, (void**)&pPersistStream);
#endif
                        CheckError(sc);

                        TRY
                        {
                                // Get and archive the CLSID (GUID)
                                CLSID clsid;
                                CheckError(pPersistStream->GetClassID(&clsid));
                                ar << clsid.Data1;
                                ar << clsid.Data2;
                                ar << clsid.Data3;
                                ar.Write(&clsid.Data4[0], sizeof clsid.Data4);

                                // Always assume object is dirty
                                CheckError(pPersistStream->Save(&stm, TRUE));
                        }
                        CATCH_ALL(e)
                        {
                                pPersistStream->Release();
                                THROW_LAST();
                        }
                        END_CATCH_ALL
                        pPersistStream->Release();
                }
                return ar;
#endif //_WITH_PUNK_

        case VT_EMPTY:
        case VT_NULL:
                // do nothing
                return ar;

        default:
                ASSERT(FALSE);
                return ar;
        }
}

CArchive& AFXAPI operator>>(CArchive& ar, COleVariant& varSrc)
{
        LPVARIANT pSrc = &varSrc;

        // Free up current data if necessary
        if (pSrc->vt != VT_EMPTY)
                VariantClear(pSrc);
        ar >> pSrc->vt;

        // No support for VT_BYREF & VT_ARRAY
        if (pSrc->vt & VT_BYREF || pSrc->vt & VT_ARRAY)
                return ar;

        switch (pSrc->vt)
        {
        case VT_BOOL:
                return ar >> (WORD&)V_BOOL(pSrc);

        case VT_UI1:
                return ar >> pSrc->bVal;

        case VT_I2:
                return ar >> (WORD&)pSrc->iVal;

        case VT_I4:
                return ar >> pSrc->lVal;

        case VT_CY:
                ar >> pSrc->cyVal.Lo;
                return ar >> pSrc->cyVal.Hi;

        case VT_R4:
                return ar >> pSrc->fltVal;

        case VT_R8:
                return ar >> pSrc->dblVal;

        case VT_DATE:
                return ar >> pSrc->date;

        case VT_BSTR:
                {
                        DWORD nLen;
                        ar >> nLen;
                        if (nLen > 0)
                        {
                                pSrc->bstrVal = SysAllocStringByteLen(NULL, nLen);
                                //BUGBUG:
                                //if (pSrc->bstrVal == NULL)
                                //        AfxThrowMemoryException();

                                ar.Read(pSrc->bstrVal, nLen * sizeof(BYTE));
                        }
                        else
                                pSrc->bstrVal = NULL;

                        return ar;
                }
                break;

        case VT_ERROR:
                return ar >> pSrc->scode;

#ifdef _WITH_PUNK_
        case VT_DISPATCH:
        case VT_UNKNOWN:
                {
                        LPPERSISTSTREAM pPersistStream = NULL;
                        CArchiveStream stm(&ar);

                        // Retrieve the CLSID (GUID) and create an instance
                        CLSID clsid;
                        ar >> clsid.Data1;
                        ar >> clsid.Data2;
                        ar >> clsid.Data3;
                        ar.Read(&clsid.Data4[0], sizeof clsid.Data4);

                        // Create the object
                        SCODE sc = CoCreateInstance(clsid, NULL, CLSCTX_ALL | CLSCTX_REMOTE_SERVER,
                                pSrc->vt == VT_UNKNOWN ? IID_IUnknown : IID_IDispatch,
                                (void**)&pSrc->punkVal);
                        if (sc == E_INVALIDARG)
                        {
                                // may not support CLSCTX_REMOTE_SERVER, so try without
                                sc = CoCreateInstance(clsid, NULL,
                                        CLSCTX_ALL & ~CLSCTX_REMOTE_SERVER,
                                        pSrc->vt == VT_UNKNOWN ? IID_IUnknown : IID_IDispatch,
                                        (void**)&pSrc->punkVal);
                        }
                        CheckError(sc);

                        TRY
                        {
                                // QI for IPersistStream or IPeristStreamInit
                                sc = pSrc->punkVal->QueryInterface(
                                        IID_IPersistStream, (void**)&pPersistStream);
#ifndef _AFX_NO_OCC_SUPPORT
                                if (FAILED(sc))
                                        sc = pSrc->punkVal->QueryInterface(
                                                IID_IPersistStreamInit, (void**)&pPersistStream);
#endif
                                CheckError(sc);

                                // Always assumes object is dirty
                                CheckError(pPersistStream->Load(&stm));
                        }
                        CATCH_ALL(e)
                        {
                                // Clean up
                                if (pPersistStream != NULL)
                                        pPersistStream->Release();

                                pSrc->punkVal->Release();
                                THROW_LAST();
                        }
                        END_CATCH_ALL

                        pPersistStream->Release();
                }
                return ar;
#endif //_WITH_PUNK_

        case VT_EMPTY:
        case VT_NULL:
                // do nothing
                return ar;

        default:
                ASSERT(FALSE);
                return ar;
        }
}
#endif //_with_archive_

/////////////////////////////////////////////////////////////////////////////
// COleVariant Helpers

template<>
void AFXAPI ConstructElements(COleVariant* pElements, int nCount)
{
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pElements, nCount * sizeof(COleVariant)));

        for (; nCount--; ++pElements)
                new(pElements) COleVariant;
}

template<>
void AFXAPI DestructElements(COleVariant* pElements, int nCount)
{
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pElements, nCount * sizeof(COleVariant)));

        for (; nCount--; ++pElements)
                pElements->~COleVariant();
}

template<>
void AFXAPI CopyElements(COleVariant* pDest, const COleVariant* pSrc, int nCount)
{
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pDest, nCount * sizeof(COleVariant)));
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pSrc, nCount * sizeof(COleVariant)));

        for (; nCount--; ++pDest, ++pSrc)
                *pDest = *pSrc;
}

#ifdef _with_archive_
template<>
void AFXAPI SerializeElements(CArchive& ar, COleVariant* pElements, int nCount)
{
        ASSERT(nCount == 0 ||
                AfxIsValidAddress(pElements, nCount * sizeof(COleVariant)));

        if (ar.IsStoring())
        {
                for (; nCount--; ++pElements)
                        ar << *pElements;
        }
        else
        {
                for (; nCount--; ++pElements)
                        ar >> *pElements;
        }
}
#endif //_with_archive_

#ifdef _DEBUG
template<>
void AFXAPI DumpElements(CDumpContext& dc, COleVariant* pElements, int nCount)
{
        for (; nCount--; ++pElements)
                dc << *pElements;
}
#endif // _DEBUG

template<>
UINT AFXAPI HashKey(const struct tagVARIANT& var)
{
        switch (var.vt)
        {
        case VT_EMPTY:
        case VT_NULL:
                return 0;
        case VT_I2:
                return HashKey((DWORD)var.iVal);
        case VT_I4:
                return HashKey((DWORD)var.lVal);
        case VT_R4:
                return (UINT)(var.fltVal / 16);
        case VT_R8:
        case VT_CY:
                return (UINT)(var.dblVal / 16);
        case VT_BOOL:
                return HashKey((DWORD)V_BOOL(&var));
        case VT_ERROR:
                return HashKey((DWORD)var.scode);
        case VT_DATE:
                return (UINT)(var.date / 16);
        case VT_BSTR:
                return HashKey(var.bstrVal);
        case VT_DISPATCH:
        case VT_UNKNOWN:
                return HashKey((DWORD_PTR)var.punkVal);

        default:
                // No support for VT_BYREF & VT_ARRAY
                ASSERT(FALSE);

                // Fall through
        }

        return 0;
}

static void PASCAL CheckError(SCODE sc)
{
        if (FAILED(sc))
        {
            /*
            BUGBUG:
                if (sc == E_OUTOFMEMORY)
                        AfxThrowMemoryException();
                else
                        AfxThrowOleException(sc);
            */
        }
}
static BOOL PASCAL CompareSafeArrays(SAFEARRAY* parray1, SAFEARRAY* parray2)
{
    return FALSE;
}

#ifdef _CURRENCY_ALSO_
static BOOL PASCAL CompareSafeArrays(SAFEARRAY* parray1, SAFEARRAY* parray2)
{
        BOOL bCompare = FALSE;

        // If one is NULL they must both be NULL to compare
        if (parray1 == NULL || parray2 == NULL)
        {
                return parray1 == parray2;
        }

        // Dimension must match and if 0, then arrays compare
        DWORD dwDim1 = ::SafeArrayGetDim(parray1);
        DWORD dwDim2 = ::SafeArrayGetDim(parray2);
        if (dwDim1 != dwDim2)
                return FALSE;
        else if (dwDim1 == 0)
                return TRUE;

        // Element size must match
        DWORD dwSize1 = ::SafeArrayGetElemsize(parray1);
        DWORD dwSize2 = ::SafeArrayGetElemsize(parray2);
        if (dwSize1 != dwSize2)
                return FALSE;

        long* pLBound1 = NULL;
        long* pLBound2 = NULL;
        long* pUBound1 = NULL;
        long* pUBound2 = NULL;

        void* pData1 = NULL;
        void* pData2 = NULL;

        TRY
        {
                // Bounds must match
                pLBound1 = new long[dwDim1];
                pLBound2 = new long[dwDim2];
                pUBound1 = new long[dwDim1];
                pUBound2 = new long[dwDim2];

                size_t nTotalElements = 1;

                // Get and compare bounds
                for (DWORD dwIndex = 0; dwIndex < dwDim1; dwIndex++)
                {
                        CheckError(::SafeArrayGetLBound(
                                parray1, dwIndex+1, &pLBound1[dwIndex]));
                        CheckError(::SafeArrayGetLBound(
                                parray2, dwIndex+1, &pLBound2[dwIndex]));
                        CheckError(::SafeArrayGetUBound(
                                parray1, dwIndex+1, &pUBound1[dwIndex]));
                        CheckError(::SafeArrayGetUBound(
                                parray2, dwIndex+1, &pUBound2[dwIndex]));

                        // Check the magnitude of each bound
                        if (pUBound1[dwIndex] - pLBound1[dwIndex] !=
                                pUBound2[dwIndex] - pLBound2[dwIndex])
                        {
                                delete[] pLBound1;
                                delete[] pLBound2;
                                delete[] pUBound1;
                                delete[] pUBound2;

                                return FALSE;
                        }

                        // Increment the element count
                        nTotalElements *= pUBound1[dwIndex] - pLBound1[dwIndex] + 1;
                }

                // Access the data
                CheckError(::SafeArrayAccessData(parray1, &pData1));
                CheckError(::SafeArrayAccessData(parray2, &pData2));

                // Calculate the number of bytes of data and compare
                size_t nSize = nTotalElements * dwSize1;
                int nOffset = memcmp(pData1, pData2, nSize);
                bCompare = nOffset == 0;

                // Release the array locks
                CheckError(::SafeArrayUnaccessData(parray1));
                CheckError(::SafeArrayUnaccessData(parray2));
        }
        CATCH_ALL(e)
        {
                // Clean up bounds arrays
                delete[] pLBound1;
                delete[] pLBound2;
                delete[] pUBound1;
                delete[] pUBound2;

                // Release the array locks
                if (pData1 != NULL)
                        CheckError(::SafeArrayUnaccessData(parray1));
                if (pData2 != NULL)
                        CheckError(::SafeArrayUnaccessData(parray2));

                THROW_LAST();
        }
        END_CATCH_ALL

        // Clean up bounds arrays
        delete[] pLBound1;
        delete[] pLBound2;
        delete[] pUBound1;
        delete[] pUBound2;

        return bCompare;
}

static void PASCAL CreateOneDimArray(VARIANT& varSrc, DWORD dwSize)
{
        UINT nDim;

        // Clear VARIANT and re-create SafeArray if necessary
        if (varSrc.vt != (VT_UI1 | VT_ARRAY) ||
                (nDim = ::SafeArrayGetDim(varSrc.parray)) != 1)
        {
                VERIFY(::VariantClear(&varSrc) == NOERROR);
                varSrc.vt = VT_UI1 | VT_ARRAY;

                SAFEARRAYBOUND bound;
                bound.cElements = dwSize;
                bound.lLbound = 0;
                varSrc.parray = ::SafeArrayCreate(VT_UI1, 1, &bound);
                if (varSrc.parray == NULL)
                        AfxThrowMemoryException();
        }
        else
        {
                // Must redimension array if necessary
                long lLower, lUpper;
                CheckError(::SafeArrayGetLBound(varSrc.parray, 1, &lLower));
                CheckError(::SafeArrayGetUBound(varSrc.parray, 1, &lUpper));

                // Upper bound should always be greater than lower bound
                long lSize = lUpper - lLower;
                if (lSize < 0)
                {
                        ASSERT(FALSE);
                        lSize = 0;

                }

                if ((DWORD)lSize != dwSize)
                {
                        SAFEARRAYBOUND bound;
                        bound.cElements = dwSize;
                        bound.lLbound = lLower;
                        CheckError(::SafeArrayRedim(varSrc.parray, &bound));
                }
        }
}

static void PASCAL CopyBinaryData(SAFEARRAY* parray, const void* pvSrc, DWORD dwSize)
{
        // Access the data, copy it and unaccess it.
        void* pDest;
        CheckError(::SafeArrayAccessData(parray, &pDest));
        memcpy(pDest, pvSrc, dwSize);
        CheckError(::SafeArrayUnaccessData(parray));
}

/////////////////////////////////////////////////////////////////////////////
// COleCurrency class helpers

// Return the highest order bit composing dwTarget in wBit
#define HI_BIT(dwTarget, wBit) \
        do \
        { \
                if (dwTarget != 0) \
                        for (wBit = 32; (dwTarget & (0x00000001 << wBit-1)) == 0; wBit--);\
                else \
                        wBit = 0; \
        } while (0)

// Left shift an (assumed unsigned) currency by wBits
#define LSHIFT_UCUR(cur, wBits) \
        do \
        { \
                for (WORD wTempBits = wBits; wTempBits > 0; wTempBits--) \
                { \
                        cur.m_cur.Hi = ((DWORD)cur.m_cur.Hi << 1); \
                        cur.m_cur.Hi |= (cur.m_cur.Lo & 0x80000000) >> 31; \
                        cur.m_cur.Lo = cur.m_cur.Lo << 1; \
                } \
        } while (0)

// Right shift an (assumed unsigned) currency by wBits
#define RSHIFT_UCUR(cur, wBits) \
        do \
        { \
                for (WORD wTempBits = wBits; wTempBits > 0; wTempBits--) \
                { \
                        cur.m_cur.Lo = cur.m_cur.Lo >> 1; \
                        cur.m_cur.Lo |= (cur.m_cur.Hi & 0x00000001) << 31; \
                        cur.m_cur.Hi = ((DWORD)cur.m_cur.Hi >> 1); \
                } \
        } while (0)

/////////////////////////////////////////////////////////////////////////////
// COleCurrency class (internally currency is 8-byte int scaled by 10,000)

COleCurrency::COleCurrency(long nUnits, long nFractionalUnits)
{
        SetCurrency(nUnits, nFractionalUnits);
        SetStatus(valid);
}

const COleCurrency& COleCurrency::operator=(CURRENCY cySrc)
{
        m_cur = cySrc;
        SetStatus(valid);
        return *this;
}

const COleCurrency& COleCurrency::operator=(const COleCurrency& curSrc)
{
        m_cur = curSrc.m_cur;
        m_status = curSrc.m_status;
        return *this;
}

const COleCurrency& COleCurrency::operator=(const VARIANT& varSrc)
{
        if (varSrc.vt != VT_CY)
        {
                TRY
                {
                        COleVariant varTemp(varSrc);
                        varTemp.ChangeType(VT_CY);
                        m_cur = varTemp.cyVal;
                        SetStatus(valid);
                }
                // Catch COleException from ChangeType, but not CMemoryException
                CATCH(COleException, e)
                {
                        // Not able to convert VARIANT to CURRENCY
                        m_cur.Hi = 0;
                        m_cur.Lo = 0;
                        SetStatus(invalid);
                        DELETE_EXCEPTION(e);
                }
                END_CATCH
        }
        else
        {
                m_cur = varSrc.cyVal;
                SetStatus(valid);
        }

        return *this;
}

BOOL COleCurrency::operator<(const COleCurrency& cur) const
{
        ASSERT(GetStatus() == valid);
        ASSERT(cur.GetStatus() == valid);

        return((m_cur.Hi == cur.m_cur.Hi) ?
                (m_cur.Lo < cur.m_cur.Lo) : (m_cur.Hi < cur.m_cur.Hi));
}

BOOL COleCurrency::operator>(const COleCurrency& cur) const
{
        ASSERT(GetStatus() == valid);
        ASSERT(cur.GetStatus() == valid);

        return((m_cur.Hi == cur.m_cur.Hi) ?
                (m_cur.Lo > cur.m_cur.Lo) : (m_cur.Hi > cur.m_cur.Hi));
}

BOOL COleCurrency::operator<=(const COleCurrency& cur) const
{
        ASSERT(GetStatus() == valid);
        ASSERT(cur.GetStatus() == valid);

        return((m_cur.Hi == cur.m_cur.Hi) ?
                (m_cur.Lo <= cur.m_cur.Lo) : (m_cur.Hi < cur.m_cur.Hi));
}

BOOL COleCurrency::operator>=(const COleCurrency& cur) const
{
        ASSERT(GetStatus() == valid);
        ASSERT(cur.GetStatus() == valid);

        return((m_cur.Hi == cur.m_cur.Hi) ?
                (m_cur.Lo >= cur.m_cur.Lo) : (m_cur.Hi > cur.m_cur.Hi));
}

COleCurrency COleCurrency::operator+(const COleCurrency& cur) const
{
        COleCurrency curResult;

        // If either operand Null, result Null
        if (GetStatus() == null || cur.GetStatus() == null)
        {
                curResult.SetStatus(null);
                return curResult;
        }

        // If either operand Invalid, result Invalid
        if (GetStatus() == invalid || cur.GetStatus() == invalid)
        {
                curResult.SetStatus(invalid);
                return curResult;
        }

        // Add separate CURRENCY components
        curResult.m_cur.Hi = m_cur.Hi + cur.m_cur.Hi;
        curResult.m_cur.Lo = m_cur.Lo + cur.m_cur.Lo;

        // Increment Hi if Lo overflows
        if (m_cur.Lo > curResult.m_cur.Lo)
                curResult.m_cur.Hi++;

        // Overflow if operands same sign and result sign different
        if (!((m_cur.Hi ^ cur.m_cur.Hi) & 0x80000000) &&
                ((m_cur.Hi ^ curResult.m_cur.Hi) & 0x80000000))
        {
                curResult.SetStatus(invalid);
        }

        return curResult;
}

COleCurrency COleCurrency::operator-(const COleCurrency& cur) const
{
        COleCurrency curResult;

        // If either operand Null, result Null
        if (GetStatus() == null || cur.GetStatus() == null)
        {
                curResult.SetStatus(null);
                return curResult;
        }

        // If either operand Invalid, result Invalid
        if (GetStatus() == invalid || cur.GetStatus() == invalid)
        {
                curResult.SetStatus(invalid);
                return curResult;
        }

        // Subtract separate CURRENCY components
        curResult.m_cur.Hi = m_cur.Hi - cur.m_cur.Hi;
        curResult.m_cur.Lo = m_cur.Lo - cur.m_cur.Lo;

        // Decrement Hi if Lo overflows
        if (m_cur.Lo < curResult.m_cur.Lo)
                curResult.m_cur.Hi--;

        // Overflow if operands not same sign and result not same sign
        if (((m_cur.Hi ^ cur.m_cur.Hi) & 0x80000000) &&
                ((m_cur.Hi ^ curResult.m_cur.Hi) & 0x80000000))
        {
                curResult.SetStatus(invalid);
        }

        return curResult;
}

COleCurrency COleCurrency::operator-() const
{
        // If operand not Valid, just return
        if (!GetStatus() == valid)
                return *this;

        COleCurrency curResult;

        // Negating MIN_CURRENCY,will set invalid
        if (m_cur.Hi == 0x80000000 && m_cur.Lo == 0x00000000)
        {
                curResult.SetStatus(invalid);
        }

        curResult.m_cur.Hi = ~m_cur.Hi;
        curResult.m_cur.Lo = -(long)m_cur.Lo;

        // If cy was -1 make sure Hi correctly set
        if (curResult.m_cur.Lo == 0)
                curResult.m_cur.Hi++;

        return curResult;
}

COleCurrency COleCurrency::operator*(long nOperand) const
{
        // If operand not Valid, just return
        if (!GetStatus() == valid)
                return *this;

        COleCurrency curResult(m_cur);
        DWORD nTempOp;

        // Return now if one operand is 0 (optimization)
        if ((m_cur.Hi == 0x00000000 && m_cur.Lo == 0x00000000) || nOperand == 0)
        {
                curResult.m_cur.Hi = 0;
                curResult.m_cur.Lo = 0;
                return curResult;
        }

        // Handle only valid case of multiplying MIN_CURRENCY
        if (m_cur.Hi == 0x80000000 && m_cur.Lo == 0x00000000 && nOperand == 1)
                return curResult;

        // Compute absolute values.
        if (m_cur.Hi < 0)
                curResult = -curResult;

        nTempOp = labs(nOperand);

        // Check for overflow
        if (curResult.m_cur.Hi != 0)
        {
                WORD wHiBitCur, wHiBitOp;
                HI_BIT(curResult.m_cur.Hi, wHiBitCur);
                HI_BIT(nTempOp, wHiBitOp);

                // 63-bit limit on result. (n bits)*(m bits) = (n+m-1) bits.
                if (wHiBitCur + wHiBitOp - 1 > 63)
                {
                        // Overflow!
                        curResult.SetStatus(invalid);

                        // Set to maximum negative value
                        curResult.m_cur.Hi = 0x80000000;
                        curResult.m_cur.Lo = 0x00000000;

                        return curResult;
                }
        }

        // Break up into WORDs
        WORD wCy4, wCy3, wCy2, wCy1, wL2, wL1;

        wCy4 = HIWORD(curResult.m_cur.Hi);
        wCy3 = LOWORD(curResult.m_cur.Hi);
        wCy2 = HIWORD(curResult.m_cur.Lo);
        wCy1 = LOWORD(curResult.m_cur.Lo);

        wL2 = HIWORD(nTempOp);
        wL1 = LOWORD(nTempOp);

        // Multiply each set of WORDs
        DWORD dwRes11, dwRes12, dwRes21, dwRes22;
        DWORD dwRes31, dwRes32, dwRes41;  // Don't need dwRes42

        dwRes11 = wCy1 * wL1;
        dwRes12 = wCy1 * wL2;
        dwRes21 = wCy2 * wL1;
        dwRes22 = wCy2 * wL2;

        dwRes31 = wCy3 * wL1;
        dwRes32 = wCy3 * wL2;
        dwRes41 = wCy4 * wL1;

        // Add up low order pieces
        dwRes11 += dwRes12<<16;
        curResult.m_cur.Lo = dwRes11 + (dwRes21<<16);

        // Check if carry required
        if (dwRes11 < dwRes12<<16 || (DWORD)curResult.m_cur.Lo < dwRes11)
                curResult.m_cur.Hi = 1;
        else
                curResult.m_cur.Hi = 0;

        // Add up the high order pieces
        curResult.m_cur.Hi += dwRes31 + (dwRes32<<16) + (dwRes41<<16) +
                dwRes22 + (dwRes12>>16) + (dwRes21>>16);

        // Compute result sign
        if ((m_cur.Hi ^ nOperand) & 0x80000000)
                curResult = -curResult;

        return curResult;
}

COleCurrency COleCurrency::operator/(long nOperand) const
{
        // If operand not Valid, just return
        if (!GetStatus() == valid)
                return *this;

        COleCurrency curTemp(m_cur);
        DWORD nTempOp;

        // Check for divide by 0
        if (nOperand == 0)
        {
                curTemp.SetStatus(invalid);

                // Set to maximum negative value
                curTemp.m_cur.Hi = 0x80000000;
                curTemp.m_cur.Lo = 0x00000000;

                return curTemp;
        }

        // Compute absolute values
        if (curTemp.m_cur.Hi < 0)
                curTemp = -curTemp;

        nTempOp = labs(nOperand);

        // Optimization - division is simple if Hi == 0
        if (curTemp.m_cur.Hi == 0x0000)
        {
                curTemp.m_cur.Lo = m_cur.Lo / nTempOp;

                // Compute result sign
                if ((m_cur.Hi ^ nOperand) & 0x80000000)
                        curTemp = -curTemp;

                return curTemp;
        }

        // Now curTemp represents remainder
        COleCurrency curResult; // Initializes to zero
        COleCurrency curTempResult;
        COleCurrency curOperand;

        curOperand.m_cur.Lo = nTempOp;

        WORD wHiBitRem;
        WORD wScaleOp;

        // Quit if remainder can be truncated
        while (curTemp >= curOperand)
        {
                // Scale up and divide Hi portion
                HI_BIT(curTemp.m_cur.Hi, wHiBitRem);

                if (wHiBitRem != 0)
                        wHiBitRem += 32;
                else
                        HI_BIT(curTemp.m_cur.Lo, wHiBitRem);

                WORD wShift = (WORD)(64 - wHiBitRem);
                LSHIFT_UCUR(curTemp, wShift);

                // If Operand bigger than Hi it must be scaled
                wScaleOp = (WORD)((nTempOp > (DWORD)curTemp.m_cur.Hi) ? 1 : 0);

                // Perform synthetic division
                curTempResult.m_cur.Hi =
                        (DWORD)curTemp.m_cur.Hi / (nTempOp >> wScaleOp);

                // Scale back to get correct result and remainder
                RSHIFT_UCUR(curTemp, wShift);
                wShift = (WORD)(wShift - wScaleOp);
                RSHIFT_UCUR(curTempResult, wShift);

                // Now calculate result and remainder
                curResult += curTempResult;
                curTemp -= curTempResult * nTempOp;
        }

        // Compute result sign
        if ((m_cur.Hi ^ nOperand) & 0x80000000)
                curResult = -curResult;

        return curResult;
}

void COleCurrency::SetCurrency(long nUnits, long nFractionalUnits)
{
        COleCurrency curUnits;              // Initializes to 0
        COleCurrency curFractionalUnits;    // Initializes to 0

        // Set temp currency value to Units (need to multiply by 10,000)
        curUnits.m_cur.Lo = (DWORD)labs(nUnits);
        curUnits = curUnits * 10000;
        if (nUnits < 0)
                curUnits = -curUnits;

        curFractionalUnits.m_cur.Lo = (DWORD)labs(nFractionalUnits);
        if (nFractionalUnits < 0)
                curFractionalUnits = -curFractionalUnits;

        // Now add together Units and FractionalUnits
        *this = curUnits + curFractionalUnits;

        SetStatus(valid);
}

BOOL COleCurrency::ParseCurrency(LPCTSTR lpszCurrency,
        DWORD dwFlags,  LCID lcid)
{
        USES_CONVERSION;
        CString strCurrency = lpszCurrency;

        SCODE sc;
        if ( FAILED(sc = VarCyFromStr((LPOLESTR)T2COLE(strCurrency),
                lcid, dwFlags, &m_cur)))
        {
                if (sc == DISP_E_TYPEMISMATCH)
                {
                        // Can't convert string to CURRENCY, set 0 & invalid
                        m_cur.Hi = 0x00000000;
                        m_cur.Lo = 0x00000000;
                        SetStatus(invalid);
                        return FALSE;
                }
                else if (sc == DISP_E_OVERFLOW)
                {
                        // Can't convert string to CURRENCY, set max neg & invalid
                        m_cur.Hi = 0x80000000;
                        m_cur.Lo = 0x00000000;
                        SetStatus(invalid);
                        return FALSE;
                }
                else
                {
                        TRACE0("\nCOleCurrency VarCyFromStr call failed.\n\t");
                        if (sc == E_OUTOFMEMORY)
                                AfxThrowMemoryException();
                        else
                                AfxThrowOleException(sc);
                }
        }

        SetStatus(valid);
        return TRUE;
}

CString COleCurrency::Format(DWORD dwFlags, LCID lcid) const
{
        USES_CONVERSION;
        CString strCur;

        // If null, return empty string
        if (GetStatus() == null)
                return strCur;

        // If invalid, return Currency resource string
        if (GetStatus() == invalid)
        {
                VERIFY(strCur.LoadString(AFX_IDS_INVALID_CURRENCY));
                return strCur;
        }

        COleVariant var;
        // Don't need to trap error. Should not fail due to type mismatch
        CheckError(VarBstrFromCy(m_cur, lcid, dwFlags, &V_BSTR(&var)));
        var.vt = VT_BSTR;
        return OLE2CT(V_BSTR(&var));
}


// serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleCurrency curSrc)
{
        dc << "\nCOleCurrency Object:";
        dc << "\n\tm_status = " << (long)curSrc.m_status;

        COleVariant var(curSrc);
        var.ChangeType(VT_CY);
        return dc << "\n\tCurrency = " << (LPCTSTR)var.bstrVal;
}
#endif // _DEBUG

#ifdef _with_archive_
CArchive& AFXAPI operator<<(CArchive& ar, COleCurrency curSrc)
{
        ar << (long)curSrc.m_status;
        ar << curSrc.m_cur.Hi;
        return ar << curSrc.m_cur.Lo;
}

CArchive& AFXAPI operator>>(CArchive& ar, COleCurrency& curSrc)
{
        ar >> (long&)curSrc.m_status;
        ar >> curSrc.m_cur.Hi;
        return ar >> curSrc.m_cur.Lo;
}
#endif //_with_archive_


/////////////////////////////////////////////////////////////////////////////
// COleDateTime class HELPER definitions

// Verifies will fail if the needed buffer size is too large
#define MAX_TIME_BUFFER_SIZE    128         // matches that in timecore.cpp
#define MIN_DATE                (-657434L)  // about year 100
#define MAX_DATE                2958465L    // about year 9999

// Half a second, expressed in days
#define HALF_SECOND  (1.0/172800.0)

// One-based array of days in year at month start
static int rgMonthDays[13] =
        {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};

static BOOL OleDateFromTm(WORD wYear, WORD wMonth, WORD wDay,
        WORD wHour, WORD wMinute, WORD wSecond, DATE& dtDest);
static BOOL TmFromOleDate(DATE dtSrc, struct tm& tmDest);
static void TmConvertToStandardFormat(struct tm& tmSrc);
static double DoubleFromDate(DATE dt);
static DATE DateFromDouble(double dbl);

/////////////////////////////////////////////////////////////////////////////
// COleDateTime class

COleDateTime PASCAL COleDateTime::GetCurrentTime()
{
        return COleDateTime(::time(NULL));
}

int COleDateTime::GetYear() const
{
        struct tm tmTemp;

        if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
                return tmTemp.tm_year;
        else
                return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetMonth() const
{
        struct tm tmTemp;

        if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
                return tmTemp.tm_mon;
        else
                return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetDay() const
{
        struct tm tmTemp;

        if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
                return tmTemp.tm_mday;
        else
                return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetHour() const
{
        struct tm tmTemp;

        if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
                return tmTemp.tm_hour;
        else
                return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetMinute() const
{
        struct tm tmTemp;

        if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
                return tmTemp.tm_min;
        else
                return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetSecond() const
{
        struct tm tmTemp;

        if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
                return tmTemp.tm_sec;
        else
                return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetDayOfWeek() const
{
        struct tm tmTemp;

        if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
                return tmTemp.tm_wday;
        else
                return AFX_OLE_DATETIME_ERROR;
}

int COleDateTime::GetDayOfYear() const
{
        struct tm tmTemp;

        if (GetStatus() == valid && TmFromOleDate(m_dt, tmTemp))
                return tmTemp.tm_yday;
        else
                return AFX_OLE_DATETIME_ERROR;
}

const COleDateTime& COleDateTime::operator=(const VARIANT& varSrc)
{
        if (varSrc.vt != VT_DATE)
        {
                TRY
                {
                        COleVariant varTemp(varSrc);
                        varTemp.ChangeType(VT_DATE);
                        m_dt = varTemp.date;
                        SetStatus(valid);
                }
                // Catch COleException from ChangeType, but not CMemoryException
                CATCH(COleException, e)
                {
                        // Not able to convert VARIANT to DATE
                        DELETE_EXCEPTION(e);
                        m_dt = 0;
                        SetStatus(invalid);
                }
                END_CATCH
        }
        else
        {
                m_dt = varSrc.date;
                SetStatus(valid);
        }

        return *this;
}

const COleDateTime& COleDateTime::operator=(DATE dtSrc)
{
        m_dt = dtSrc;
        SetStatus(valid);

        return *this;
}

const COleDateTime& COleDateTime::operator=(const time_t& timeSrc)
{
        // Convert time_t to struct tm
        tm *ptm = localtime(&timeSrc);

        if (ptm != NULL)
        {
                m_status = OleDateFromTm((WORD)ptm->tm_year + 1900,
                        (WORD)(ptm->tm_mon + 1), (WORD)ptm->tm_mday,
                        (WORD)ptm->tm_hour, (WORD)ptm->tm_min,
                        (WORD)ptm->tm_sec, m_dt) ? valid : invalid;
        }
        else
        {
                // Local time must have failed (timsSrc before 1/1/70 12am)
                SetStatus(invalid);
                ASSERT(FALSE);
        }

        return *this;
}

const COleDateTime& COleDateTime::operator=(const SYSTEMTIME& systimeSrc)
{
        m_status = OleDateFromTm(systimeSrc.wYear, systimeSrc.wMonth,
                systimeSrc.wDay, systimeSrc.wHour, systimeSrc.wMinute,
                systimeSrc.wSecond, m_dt) ? valid : invalid;

        return *this;
}

const COleDateTime& COleDateTime::operator=(const FILETIME& filetimeSrc)
{
        // Assume UTC FILETIME, so convert to LOCALTIME
        FILETIME filetimeLocal;
        if (!FileTimeToLocalFileTime( &filetimeSrc, &filetimeLocal))
        {
#ifdef _DEBUG
                DWORD dwError = GetLastError();
                TRACE1("\nFileTimeToLocalFileTime failed. Error = %lu.\n\t", dwError);
#endif // _DEBUG
                m_status = invalid;
        }
        else
        {
                // Take advantage of SYSTEMTIME -> FILETIME conversion
                SYSTEMTIME systime;
                m_status = FileTimeToSystemTime(&filetimeLocal, &systime) ?
                        valid : invalid;

                // At this point systime should always be valid, but...
                if (GetStatus() == valid)
                {
                        m_status = OleDateFromTm(systime.wYear, systime.wMonth,
                                systime.wDay, systime.wHour, systime.wMinute,
                                systime.wSecond, m_dt) ? valid : invalid;
                }
        }

        return *this;
}

BOOL COleDateTime::operator<(const COleDateTime& date) const
{
        ASSERT(GetStatus() == valid);
        ASSERT(date.GetStatus() == valid);

        // Handle negative dates
        return DoubleFromDate(m_dt) < DoubleFromDate(date.m_dt);
}

BOOL COleDateTime::operator>(const COleDateTime& date) const
{   ASSERT(GetStatus() == valid);
        ASSERT(date.GetStatus() == valid);

        // Handle negative dates
        return DoubleFromDate(m_dt) > DoubleFromDate(date.m_dt);
}

BOOL COleDateTime::operator<=(const COleDateTime& date) const
{
        ASSERT(GetStatus() == valid);
        ASSERT(date.GetStatus() == valid);

        // Handle negative dates
        return DoubleFromDate(m_dt) <= DoubleFromDate(date.m_dt);
}

BOOL COleDateTime::operator>=(const COleDateTime& date) const
{
        ASSERT(GetStatus() == valid);
        ASSERT(date.GetStatus() == valid);

        // Handle negative dates
        return DoubleFromDate(m_dt) >= DoubleFromDate(date.m_dt);
}

COleDateTime COleDateTime::operator+(const COleDateTimeSpan& dateSpan) const
{
        COleDateTime dateResult;    // Initializes m_status to valid

        // If either operand NULL, result NULL
        if (GetStatus() == null || dateSpan.GetStatus() == null)
        {
                dateResult.SetStatus(null);
                return dateResult;
        }

        // If either operand invalid, result invalid
        if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
        {
                dateResult.SetStatus(invalid);
                return dateResult;
        }

        // Compute the actual date difference by adding underlying dates
        dateResult = DateFromDouble(DoubleFromDate(m_dt) + dateSpan.m_span);

        // Validate within range
        dateResult.CheckRange();

        return dateResult;
}

COleDateTime COleDateTime::operator-(const COleDateTimeSpan& dateSpan) const
{
        COleDateTime dateResult;    // Initializes m_status to valid

        // If either operand NULL, result NULL
        if (GetStatus() == null || dateSpan.GetStatus() == null)
        {
                dateResult.SetStatus(null);
                return dateResult;
        }

        // If either operand invalid, result invalid
        if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
        {
                dateResult.SetStatus(invalid);
                return dateResult;
        }

        // Compute the actual date difference by subtracting underlying dates
        dateResult = DateFromDouble(DoubleFromDate(m_dt) - dateSpan.m_span);

        // Validate within range
        dateResult.CheckRange();

        return dateResult;
}

COleDateTimeSpan COleDateTime::operator-(const COleDateTime& date) const
{
        COleDateTimeSpan spanResult;

        // If either operand NULL, result NULL
        if (GetStatus() == null || date.GetStatus() == null)
        {
                spanResult.SetStatus(COleDateTimeSpan::null);
                return spanResult;
        }

        // If either operand invalid, result invalid
        if (GetStatus() == invalid || date.GetStatus() == invalid)
        {
                spanResult.SetStatus(COleDateTimeSpan::invalid);
                return spanResult;
        }

        // Return result (span can't be invalid, so don't check range)
        return DoubleFromDate(m_dt) - DoubleFromDate(date.m_dt);
}

BOOL COleDateTime::SetDateTime(int nYear, int nMonth, int nDay,
        int nHour, int nMin, int nSec)
{
        return m_status = OleDateFromTm((WORD)nYear, (WORD)nMonth,
                (WORD)nDay, (WORD)nHour, (WORD)nMin, (WORD)nSec, m_dt) ?
                valid : invalid;
}

BOOL COleDateTime::ParseDateTime(LPCTSTR lpszDate, DWORD dwFlags, LCID lcid)
{
        USES_CONVERSION;
        CString strDate = lpszDate;

        SCODE sc;
        if (FAILED(sc = VarDateFromStr((LPOLESTR)T2COLE(strDate), lcid,
                dwFlags, &m_dt)))
        {
                if (sc == DISP_E_TYPEMISMATCH)
                {
                        // Can't convert string to date, set 0 and invalidate
                        m_dt = 0;
                        SetStatus(invalid);
                        return FALSE;
                }
                else if (sc == DISP_E_OVERFLOW)
                {
                        // Can't convert string to date, set -1 and invalidate
                        m_dt = -1;
                        SetStatus(invalid);
                        return FALSE;
                }
                else
                {
                        TRACE0("\nCOleDateTime VarDateFromStr call failed.\n\t");
                        if (sc == E_OUTOFMEMORY)
                                AfxThrowMemoryException();
                        else
                                AfxThrowOleException(sc);
                }
        }

        SetStatus(valid);
        return TRUE;
}

CString COleDateTime::Format(DWORD dwFlags, LCID lcid) const
{
        USES_CONVERSION;
        CString strDate;

        // If null, return empty string
        if (GetStatus() == null)
                return strDate;

        // If invalid, return DateTime resource string
        if (GetStatus() == invalid)
        {
                VERIFY(strDate.LoadString(AFX_IDS_INVALID_DATETIME));
                return strDate;
        }

        COleVariant var;
        // Don't need to trap error. Should not fail due to type mismatch
        CheckError(VarBstrFromDate(m_dt, lcid, dwFlags, &V_BSTR(&var)));
        var.vt = VT_BSTR;
        return OLE2CT(V_BSTR(&var));
}

CString COleDateTime::Format(LPCTSTR pFormat) const
{
        CString strDate;
        struct tm tmTemp;

        // If null, return empty string
        if (GetStatus() == null)
                return strDate;

        // If invalid, return DateTime resource string
        if (GetStatus() == invalid || !TmFromOleDate(m_dt, tmTemp))
        {
                VERIFY(strDate.LoadString(AFX_IDS_INVALID_DATETIME));
                return strDate;
        }

        // Convert tm from afx internal format to standard format
        TmConvertToStandardFormat(tmTemp);

        // Fill in the buffer, disregard return value as it's not necessary
        LPTSTR lpszTemp = strDate.GetBufferSetLength(MAX_TIME_BUFFER_SIZE);
        _tcsftime(lpszTemp, strDate.GetLength(), pFormat, &tmTemp);
        strDate.ReleaseBuffer();

        return strDate;
}

CString COleDateTime::Format(UINT nFormatID) const
{
        CString strFormat;
        VERIFY(strFormat.LoadString(nFormatID) != 0);
        return Format(strFormat);
}

void COleDateTime::CheckRange()
{
        if (m_dt > MAX_DATE || m_dt < MIN_DATE) // about year 100 to about 9999
                SetStatus(invalid);
}

// serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleDateTime dateSrc)
{
        dc << "\nCOleDateTime Object:";
        dc << "\n\tm_status = " << (long)dateSrc.m_status;

        COleVariant var(dateSrc);
        var.ChangeType(VT_BSTR);

        return dc << "\n\tdate = " << (LPCTSTR)var.bstrVal;
}
#endif // _DEBUG

#ifdef _with_archive_
CArchive& AFXAPI operator<<(CArchive& ar, COleDateTime dateSrc)
{
        ar << (long)dateSrc.m_status;
        return ar << dateSrc.m_dt;
}

CArchive& AFXAPI operator>>(CArchive& ar, COleDateTime& dateSrc)
{
        ar >> (long&)dateSrc.m_status;
        return ar >> dateSrc.m_dt;
}
#endif //_with_archive_

/////////////////////////////////////////////////////////////////////////////
// COleDateTimeSpan class helpers

#define MAX_DAYS_IN_SPAN    3615897L

/////////////////////////////////////////////////////////////////////////////
// COleDateTimeSpan class
long COleDateTimeSpan::GetHours() const
{
        ASSERT(GetStatus() == valid);

        double dblTemp;

        // Truncate days and scale up
        dblTemp = modf(m_span, &dblTemp);
        return (long)(dblTemp * 24);
}

long COleDateTimeSpan::GetMinutes() const
{
        ASSERT(GetStatus() == valid);

        double dblTemp;

        // Truncate hours and scale up
        dblTemp = modf(m_span * 24, &dblTemp);
        return (long)(dblTemp * 60);
}

long COleDateTimeSpan::GetSeconds() const
{
        ASSERT(GetStatus() == valid);

        double dblTemp;

        // Truncate minutes and scale up
        dblTemp = modf(m_span * 24 * 60, &dblTemp);
        return (long)(dblTemp * 60);
}

const COleDateTimeSpan& COleDateTimeSpan::operator=(double dblSpanSrc)
{
        m_span = dblSpanSrc;
        SetStatus(valid);
        return *this;
}

const COleDateTimeSpan& COleDateTimeSpan::operator=(const COleDateTimeSpan& dateSpanSrc)
{
        m_span = dateSpanSrc.m_span;
        m_status = dateSpanSrc.m_status;
        return *this;
}

COleDateTimeSpan COleDateTimeSpan::operator+(const COleDateTimeSpan& dateSpan) const
{
        COleDateTimeSpan dateSpanTemp;

        // If either operand Null, result Null
        if (GetStatus() == null || dateSpan.GetStatus() == null)
        {
                dateSpanTemp.SetStatus(null);
                return dateSpanTemp;
        }

        // If either operand Invalid, result Invalid
        if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
        {
                dateSpanTemp.SetStatus(invalid);
                return dateSpanTemp;
        }

        // Add spans and validate within legal range
        dateSpanTemp.m_span = m_span + dateSpan.m_span;
        dateSpanTemp.CheckRange();

        return dateSpanTemp;
}

COleDateTimeSpan COleDateTimeSpan::operator-(const COleDateTimeSpan& dateSpan) const
{
        COleDateTimeSpan dateSpanTemp;

        // If either operand Null, result Null
        if (GetStatus() == null || dateSpan.GetStatus() == null)
        {
                dateSpanTemp.SetStatus(null);
                return dateSpanTemp;
        }

        // If either operand Invalid, result Invalid
        if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
        {
                dateSpanTemp.SetStatus(invalid);
                return dateSpanTemp;
        }

        // Subtract spans and validate within legal range
        dateSpanTemp.m_span = m_span - dateSpan.m_span;
        dateSpanTemp.CheckRange();

        return dateSpanTemp;
}

void COleDateTimeSpan::SetDateTimeSpan(
        long lDays, int nHours, int nMins, int nSecs)
{
        // Set date span by breaking into fractional days (all input ranges valid)
        m_span = lDays + ((double)nHours)/24 + ((double)nMins)/(24*60) +
                ((double)nSecs)/(24*60*60);

        SetStatus(valid);
}

CString COleDateTimeSpan::Format(LPCTSTR pFormat) const
{
        CString strSpan;
        struct tm tmTemp;

        // If null, return empty string
        if (GetStatus() == null)
                return strSpan;

        // If invalid, return DateTimeSpan resource string
        if (GetStatus() == invalid || !TmFromOleDate(m_span, tmTemp))
        {
                VERIFY(strSpan.LoadString(AFX_IDS_INVALID_DATETIMESPAN));
                return strSpan;
        }

        // Convert tm from afx internal format to standard format
        TmConvertToStandardFormat(tmTemp);

        // Fill in the buffer, disregard return value as it's not necessary
        LPTSTR lpszTemp = strSpan.GetBufferSetLength(MAX_TIME_BUFFER_SIZE);
        _tcsftime(lpszTemp, strSpan.GetLength(), pFormat, &tmTemp);
        strSpan.ReleaseBuffer();

        return strSpan;
}

CString COleDateTimeSpan::Format(UINT nFormatID) const
{
        CString strFormat;
        VERIFY(strFormat.LoadString(nFormatID) != 0);
        return Format(strFormat);
}

void COleDateTimeSpan::CheckRange()
{
        if(m_span < -MAX_DAYS_IN_SPAN || m_span > MAX_DAYS_IN_SPAN)
                SetStatus(invalid);
}

// serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleDateTimeSpan dateSpanSrc)
{
        dc << "\nCOleDateTimeSpan Object:";
        dc << "\n\tm_status = " << (long)dateSpanSrc.m_status;

        COleVariant var(dateSpanSrc.m_span);
        var.ChangeType(VT_BSTR);

        return dc << "\n\tdateSpan = " << (LPCTSTR)var.bstrVal;
}
#endif // _DEBUG

#ifdef _with_archive_
CArchive& AFXAPI operator<<(CArchive& ar, COleDateTimeSpan dateSpanSrc)
{
        ar << (long)dateSpanSrc.m_status;
        return ar << dateSpanSrc.m_span;
}

CArchive& AFXAPI operator>>(CArchive& ar, COleDateTimeSpan& dateSpanSrc)
{
        ar >> (long&)dateSpanSrc.m_status;
        return ar >> dateSpanSrc.m_span;
}
#endif //_with_archive_

/////////////////////////////////////////////////////////////////////////////
// COleDateTime class HELPERS - implementation

BOOL OleDateFromTm(WORD wYear, WORD wMonth, WORD wDay,
        WORD wHour, WORD wMinute, WORD wSecond, DATE& dtDest)
{
        // Validate year and month (ignore day of week and milliseconds)
        if (wYear > 9999 || wMonth < 1 || wMonth > 12)
                return FALSE;

        //  Check for leap year and set the number of days in the month
        BOOL bLeapYear = ((wYear & 3) == 0) &&
                ((wYear % 100) != 0 || (wYear % 400) == 0);

        int nDaysInMonth =
                rgMonthDays[wMonth] - rgMonthDays[wMonth-1] +
                ((bLeapYear && wDay == 29 && wMonth == 2) ? 1 : 0);

        // Finish validating the date
        if (wDay < 1 || wDay > nDaysInMonth ||
                wHour > 23 || wMinute > 59 ||
                wSecond > 59)
        {
                return FALSE;
        }

        // Cache the date in days and time in fractional days
        long nDate;
        double dblTime;

        //It is a valid date; make Jan 1, 1AD be 1
        nDate = wYear*365L + wYear/4 - wYear/100 + wYear/400 +
                rgMonthDays[wMonth-1] + wDay;

        //  If leap year and it's before March, subtract 1:
        if (wMonth <= 2 && bLeapYear)
                --nDate;

        //  Offset so that 12/30/1899 is 0
        nDate -= 693959L;

        dblTime = (((long)wHour * 3600L) +  // hrs in seconds
                ((long)wMinute * 60L) +  // mins in seconds
                ((long)wSecond)) / 86400.;

        dtDest = (double) nDate + ((nDate >= 0) ? dblTime : -dblTime);

        return TRUE;
}

BOOL TmFromOleDate(DATE dtSrc, struct tm& tmDest)
{
        // The legal range does not actually span year 0 to 9999.
        if (dtSrc > MAX_DATE || dtSrc < MIN_DATE) // about year 100 to about 9999
                return FALSE;

        long nDays;             // Number of days since Dec. 30, 1899
        long nDaysAbsolute;     // Number of days since 1/1/0
        long nSecsInDay;        // Time in seconds since midnight
        long nMinutesInDay;     // Minutes in day

        long n400Years;         // Number of 400 year increments since 1/1/0
        long n400Century;       // Century within 400 year block (0,1,2 or 3)
        long n4Years;           // Number of 4 year increments since 1/1/0
        long n4Day;             // Day within 4 year block
                                                        //  (0 is 1/1/yr1, 1460 is 12/31/yr4)
        long n4Yr;              // Year within 4 year block (0,1,2 or 3)
        BOOL bLeap4 = TRUE;     // TRUE if 4 year block includes leap year

        double dblDate = dtSrc; // tempory serial date

        // If a valid date, then this conversion should not overflow
        nDays = (long)dblDate;

        // Round to the second
        dblDate += ((dtSrc > 0.0) ? HALF_SECOND : -HALF_SECOND);

        nDaysAbsolute = (long)dblDate + 693959L; // Add days from 1/1/0 to 12/30/1899

        dblDate = fabs(dblDate);
        nSecsInDay = (long)((dblDate - floor(dblDate)) * 86400.);

        // Calculate the day of week (sun=1, mon=2...)
        //   -1 because 1/1/0 is Sat.  +1 because we want 1-based
        tmDest.tm_wday = (int)((nDaysAbsolute - 1) % 7L) + 1;

        // Leap years every 4 yrs except centuries not multiples of 400.
        n400Years = (long)(nDaysAbsolute / 146097L);

        // Set nDaysAbsolute to day within 400-year block
        nDaysAbsolute %= 146097L;

        // -1 because first century has extra day
        n400Century = (long)((nDaysAbsolute - 1) / 36524L);

        // Non-leap century
        if (n400Century != 0)
        {
                // Set nDaysAbsolute to day within century
                nDaysAbsolute = (nDaysAbsolute - 1) % 36524L;

                // +1 because 1st 4 year increment has 1460 days
                n4Years = (long)((nDaysAbsolute + 1) / 1461L);

                if (n4Years != 0)
                        n4Day = (long)((nDaysAbsolute + 1) % 1461L);
                else
                {
                        bLeap4 = FALSE;
                        n4Day = (long)nDaysAbsolute;
                }
        }
        else
        {
                // Leap century - not special case!
                n4Years = (long)(nDaysAbsolute / 1461L);
                n4Day = (long)(nDaysAbsolute % 1461L);
        }

        if (bLeap4)
        {
                // -1 because first year has 366 days
                n4Yr = (n4Day - 1) / 365;

                if (n4Yr != 0)
                        n4Day = (n4Day - 1) % 365;
        }
        else
        {
                n4Yr = n4Day / 365;
                n4Day %= 365;
        }

        // n4Day is now 0-based day of year. Save 1-based day of year, year number
        tmDest.tm_yday = (int)n4Day + 1;
        tmDest.tm_year = n400Years * 400 + n400Century * 100 + n4Years * 4 + n4Yr;

        // Handle leap year: before, on, and after Feb. 29.
        if (n4Yr == 0 && bLeap4)
        {
                // Leap Year
                if (n4Day == 59)
                {
                        /* Feb. 29 */
                        tmDest.tm_mon = 2;
                        tmDest.tm_mday = 29;
                        goto DoTime;
                }

                // Pretend it's not a leap year for month/day comp.
                if (n4Day >= 60)
                        --n4Day;
        }

        // Make n4DaY a 1-based day of non-leap year and compute
        //  month/day for everything but Feb. 29.
        ++n4Day;

        // Month number always >= n/32, so save some loop time */
        for (tmDest.tm_mon = (n4Day >> 5) + 1;
                n4Day > rgMonthDays[tmDest.tm_mon]; tmDest.tm_mon++);

        tmDest.tm_mday = (int)(n4Day - rgMonthDays[tmDest.tm_mon-1]);

DoTime:
        if (nSecsInDay == 0)
                tmDest.tm_hour = tmDest.tm_min = tmDest.tm_sec = 0;
        else
        {
                tmDest.tm_sec = (int)nSecsInDay % 60L;
                nMinutesInDay = nSecsInDay / 60L;
                tmDest.tm_min = (int)nMinutesInDay % 60;
                tmDest.tm_hour = (int)nMinutesInDay / 60;
        }

        return TRUE;
}

void TmConvertToStandardFormat(struct tm& tmSrc)
{
        // Convert afx internal tm to format expected by runtimes (_tcsftime, etc)
        tmSrc.tm_year -= 1900;  // year is based on 1900
        tmSrc.tm_mon -= 1;      // month of year is 0-based
        tmSrc.tm_wday -= 1;     // day of week is 0-based
        tmSrc.tm_yday -= 1;     // day of year is 0-based
}

double DoubleFromDate(DATE dt)
{
        // No problem if positive
        if (dt >= 0)
                return dt;

        // If negative, must convert since negative dates not continuous
        // (examples: -1.25 to -.75, -1.50 to -.50, -1.75 to -.25)
        double temp = ceil(dt);
        return temp - (dt - temp);
}

DATE DateFromDouble(double dbl)
{
        // No problem if positive
        if (dbl >= 0)
                return dbl;

        // If negative, must convert since negative dates not continuous
        // (examples: -.75 to -1.25, -.50 to -1.50, -.25 to -1.75)
        double temp = floor(dbl); // dbl is now whole part
        return temp + (temp - dbl);
}

/////////////////////////////////////////////////////////////////////////////
// COleSafeArray class
COleSafeArray::COleSafeArray(const SAFEARRAY& saSrc, VARTYPE vtSrc)
{
        AfxSafeArrayInit(this);
        vt = vtSrc | VT_ARRAY;
        CheckError(::SafeArrayCopy((LPSAFEARRAY)&saSrc, &parray));
        m_dwDims = GetDim();
        m_dwElementSize = GetElemSize();
}

COleSafeArray::COleSafeArray(LPCSAFEARRAY pSrc, VARTYPE vtSrc)
{
        AfxSafeArrayInit(this);
        vt = vtSrc | VT_ARRAY;
        CheckError(::SafeArrayCopy((LPSAFEARRAY)pSrc, &parray));
        m_dwDims = GetDim();
        m_dwElementSize = GetElemSize();
}

COleSafeArray::COleSafeArray(const COleSafeArray& saSrc)
{
        AfxSafeArrayInit(this);
        *this = saSrc;
        m_dwDims = GetDim();
        m_dwElementSize = GetElemSize();
}

COleSafeArray::COleSafeArray(const VARIANT& varSrc)
{
        AfxSafeArrayInit(this);
        *this = varSrc;
        m_dwDims = GetDim();
        m_dwElementSize = GetElemSize();
}

COleSafeArray::COleSafeArray(LPCVARIANT pSrc)
{
        AfxSafeArrayInit(this);
        *this = pSrc;
        m_dwDims = GetDim();
        m_dwElementSize = GetElemSize();
}

// Operations
void COleSafeArray::Attach(VARIANT& varSrc)
{
        ASSERT(varSrc.vt & VT_ARRAY);

        // Free up previous safe array if necessary
        Clear();

        // give control of data to COleSafeArray
        memcpy(this, &varSrc, sizeof(varSrc));
        varSrc.vt = VT_EMPTY;
}

VARIANT COleSafeArray::Detach()
{
        VARIANT varResult = *this;
        vt = VT_EMPTY;
        return varResult;
}

// Assignment operators
COleSafeArray& COleSafeArray::operator=(const COleSafeArray& saSrc)
{
        ASSERT(saSrc.vt & VT_ARRAY);

        CheckError(::VariantCopy(this, (LPVARIANT)&saSrc));
        return *this;
}

COleSafeArray& COleSafeArray::operator=(const VARIANT& varSrc)
{
        ASSERT(varSrc.vt & VT_ARRAY);

        CheckError(::VariantCopy(this, (LPVARIANT)&varSrc));
        return *this;
}

COleSafeArray& COleSafeArray::operator=(LPCVARIANT pSrc)
{
        ASSERT(pSrc->vt & VT_ARRAY);

        CheckError(::VariantCopy(this, (LPVARIANT)pSrc));
        return *this;
}

COleSafeArray& COleSafeArray::operator=(const COleVariant& varSrc)
{
        ASSERT(varSrc.vt & VT_ARRAY);

        CheckError(::VariantCopy(this, (LPVARIANT)&varSrc));
        return *this;
}

// Comparison operators
BOOL COleSafeArray::operator==(const SAFEARRAY& saSrc) const
{
        return CompareSafeArrays(parray, (LPSAFEARRAY)&saSrc);
}

BOOL COleSafeArray::operator==(LPCSAFEARRAY pSrc) const
{
        return CompareSafeArrays(parray, (LPSAFEARRAY)pSrc);
}

BOOL COleSafeArray::operator==(const COleSafeArray& saSrc) const
{
        if (vt != saSrc.vt)
                return FALSE;

        return CompareSafeArrays(parray, saSrc.parray);
}

BOOL COleSafeArray::operator==(const VARIANT& varSrc) const
{
        if (vt != varSrc.vt)
                return FALSE;

        return CompareSafeArrays(parray, varSrc.parray);
}

BOOL COleSafeArray::operator==(LPCVARIANT pSrc) const
{
        if (vt != pSrc->vt)
                return FALSE;

        return CompareSafeArrays(parray, pSrc->parray);
}

BOOL COleSafeArray::operator==(const COleVariant& varSrc) const
{
        if (vt != varSrc.vt)
                return FALSE;

        return CompareSafeArrays(parray, varSrc.parray);
}

void COleSafeArray::CreateOneDim(VARTYPE vtSrc, DWORD dwElements,
        void* pvSrcData, long nLBound)
{
        ASSERT(dwElements > 0);

        // Setup the bounds and create the array
        SAFEARRAYBOUND rgsabound;
        rgsabound.cElements = dwElements;
        rgsabound.lLbound = nLBound;
        Create(vtSrc, 1, &rgsabound);

        // Copy over the data if neccessary
        if (pvSrcData != NULL)
        {
                void* pvDestData;
                AccessData(&pvDestData);
                memcpy(pvDestData, pvSrcData, GetElemSize() * dwElements);
                UnaccessData();
        }
}

DWORD COleSafeArray::GetOneDimSize()
{
        ASSERT(GetDim() == 1);

        long nUBound, nLBound;

        GetUBound(1, &nUBound);
        GetLBound(1, &nLBound);

        return nUBound + 1 - nLBound;
}

void COleSafeArray::ResizeOneDim(DWORD dwElements)
{
        ASSERT(GetDim() == 1);

        SAFEARRAYBOUND rgsabound;

        rgsabound.cElements = dwElements;
        rgsabound.lLbound = 0;

        Redim(&rgsabound);
}

void COleSafeArray::Create(VARTYPE vtSrc, DWORD dwDims, DWORD* rgElements)
{
        ASSERT(rgElements != NULL);

        // Allocate and fill proxy array of bounds (with lower bound of zero)
        SAFEARRAYBOUND* rgsaBounds = new SAFEARRAYBOUND[dwDims];

        for (DWORD dwIndex = 0; dwIndex < dwDims; dwIndex++)
        {
                // Assume lower bound is 0 and fill in element count
                rgsaBounds[dwIndex].lLbound = 0;
                rgsaBounds[dwIndex].cElements = rgElements[dwIndex];
        }

        TRY
        {
                Create(vtSrc, dwDims, rgsaBounds);
        }
        CATCH_ALL(e)
        {
                // Must free up memory
                delete [] rgsaBounds;
                THROW_LAST();
        }
        END_CATCH_ALL

        delete [] rgsaBounds;
}

void COleSafeArray::Create(VARTYPE vtSrc, DWORD dwDims, SAFEARRAYBOUND* rgsabound)
{
        ASSERT(dwDims > 0);
        ASSERT(rgsabound != NULL);

        // Validate the VARTYPE for SafeArrayCreate call
        ASSERT(!(vtSrc & VT_ARRAY));
        ASSERT(!(vtSrc & VT_BYREF));
        ASSERT(!(vtSrc & VT_VECTOR));
        ASSERT(vtSrc != VT_EMPTY);
        ASSERT(vtSrc != VT_NULL);

        // Free up old safe array if necessary
        Clear();

        parray = ::SafeArrayCreate(vtSrc, dwDims, rgsabound);

        if (parray == NULL)
                AfxThrowMemoryException();

        vt = unsigned short(vtSrc | VT_ARRAY);
        m_dwDims = dwDims;
        m_dwElementSize = GetElemSize();
}

void COleSafeArray::AccessData(void** ppvData)
{
        CheckError(::SafeArrayAccessData(parray, ppvData));
}

void COleSafeArray::UnaccessData()
{
        CheckError(::SafeArrayUnaccessData(parray));
}

void COleSafeArray::AllocData()
{
        CheckError(::SafeArrayAllocData(parray));
}

void COleSafeArray::AllocDescriptor(DWORD dwDims)
{
        CheckError(::SafeArrayAllocDescriptor(dwDims, &parray));
}

void COleSafeArray::Copy(LPSAFEARRAY* ppsa)
{
        CheckError(::SafeArrayCopy(parray, ppsa));
}

void COleSafeArray::GetLBound(DWORD dwDim, long* pLbound)
{
        CheckError(::SafeArrayGetLBound(parray, dwDim, pLbound));
}

void COleSafeArray::GetUBound(DWORD dwDim, long* pUbound)
{
        CheckError(::SafeArrayGetUBound(parray, dwDim, pUbound));
}

void COleSafeArray::GetElement(long* rgIndices, void* pvData)
{
        CheckError(::SafeArrayGetElement(parray, rgIndices, pvData));
}

void COleSafeArray::PtrOfIndex(long* rgIndices, void** ppvData)
{
        CheckError(::SafeArrayPtrOfIndex(parray, rgIndices, ppvData));
}

void COleSafeArray::PutElement(long* rgIndices, void* pvData)
{
        CheckError(::SafeArrayPutElement(parray, rgIndices, pvData));
}

void COleSafeArray::Redim(SAFEARRAYBOUND* psaboundNew)
{
        CheckError(::SafeArrayRedim(parray, psaboundNew));
}

void COleSafeArray::Lock()
{
        CheckError(::SafeArrayLock(parray));
}

void COleSafeArray::Unlock()
{
        CheckError(::SafeArrayUnlock(parray));
}

void COleSafeArray::Destroy()
{
        CheckError(::SafeArrayDestroy(parray));
}

void COleSafeArray::DestroyData()
{
        CheckError(::SafeArrayDestroyData(parray));
}

void COleSafeArray::DestroyDescriptor()
{
        CheckError(::SafeArrayDestroyDescriptor(parray));
}

///////////////////////////////////////////////////////////////////////////////
// COleSafeArray Helpers
void AFXAPI AfxSafeArrayInit(COleSafeArray* psa)
{
        memset(psa, 0, sizeof(*psa));
}

/////////////////////////////////////////////////////////////////////////////
// Simple field formatting to text item - see dlgdata.cpp for base types
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, COleDateTime& value)
{
        HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
        if (pDX->m_bSaveAndValidate)
        {
                int nLen = ::GetWindowTextLength(hWndCtrl);
                CString strTemp;

                ::GetWindowText(hWndCtrl, strTemp.GetBufferSetLength(nLen), nLen+1);
                strTemp.ReleaseBuffer();

                if (!value.ParseDateTime(strTemp))  // throws exception
                {
                        // Can't convert string to datetime
                        AfxMessageBox(AFX_IDP_PARSE_DATETIME);
                        pDX->Fail();    // throws exception
                }
        }
        else
        {
                CString strTemp = value.Format();
                AfxSetWindowText(hWndCtrl, strTemp);
        }
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, COleCurrency& value)
{
        HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
        if (pDX->m_bSaveAndValidate)
        {
                int nLen = ::GetWindowTextLength(hWndCtrl);
                CString strTemp;

                ::GetWindowText(hWndCtrl, strTemp.GetBufferSetLength(nLen), nLen+1);
                strTemp.ReleaseBuffer();

                if (!value.ParseCurrency(strTemp))  // throws exception
                {
                        // Can't convert string to currency
                        AfxMessageBox(AFX_IDP_PARSE_CURRENCY);
                        pDX->Fail();    // throws exception
                }
        }
        else
        {
                CString strTemp = value.Format();
                AfxSetWindowText(hWndCtrl, strTemp);
        }
}

/////////////////////////////////////////////////////////////////////////////
#endif //_CURRENCY_ALSO_

//+---------------------------------------------------------------------------
//
//  Method:     COleVariant::Save
//
//  Synopsis:   saves a variant to a stream
//
//  Arguments:  [pStm] --
//              [fClearDirty] --
//
//  Returns:
//
//  History:    1-15-1997   JohannP (Johann Posch)   Created
//
//  Notes:      BUGBUG:NOT COMPLETE!
//
//----------------------------------------------------------------------------
HRESULT COleVariant::Save(IStream *pStm, BOOL fClearDirty)
{
    LPVARIANT pSrc = (LPVARIANT)this;
    HRESULT hr = NOERROR;
    ULONG cbSaved;
    COleVariant CVar;

    if (pSrc->vt & VT_BYREF || pSrc->vt & VT_ARRAY)
    {
        // No support for VT_BYREF & VT_ARRAY
        pSrc = (LPVARIANT)&CVar;
    }

    // write the variant
    hr = pStm->Write(pSrc, sizeof(VARIANT), &cbSaved);
    TransAssert(( sizeof(VARIANT) == cbSaved));
    if (hr == NOERROR)
    {
        switch (pSrc->vt)
        {
        case VT_DISPATCH:
            TransAssert((FALSE));
            hr = E_FAIL;
            break;

        case VT_UNKNOWN:
            {
                ULONG cbInterface = 0;
                IUnknown *pUnk = pSrc->punkVal;
                
                hr = CoGetMarshalSizeMax(&cbInterface, IID_IUnknown, pUnk, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);

                if (hr == S_OK)
                {   
                    // write the size of 
                    hr = pStm->Write(&cbInterface, sizeof(ULONG), &cbSaved);
                    // need to marshal table strong
                    hr = CoMarshalInterface(pStm, IID_IUnknown, pUnk, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);
                }

            }
            break;
            

        default:
        case VT_EMPTY:
        case VT_NULL:
            // do nothing
            break;

        case VT_BSTR:
            {
                DWORD nLen = SysStringByteLen(pSrc->bstrVal);
                hr = pStm->Write(&nLen, sizeof(DWORD), &cbSaved);
                if (   (hr == NOERROR)
                    && (nLen > 0))
                {
                    hr = pStm->Write(pSrc->bstrVal, nLen * sizeof(BYTE), &cbSaved);
                }
            }
            break;


    #ifdef _unused_
        case VT_BOOL:
            hr = pStm->Write((WORD)V_BOOL(pSrc), sizeof(WORD), &cbSaved);
            break;

        case VT_UI1:
            hr = pStm->Write(pSrc->bVal, sizeof(WORD), &cbSaved);
            break;

        case VT_I2:
            hr = pStm->Write((WORD)pSrc->iVal, sizeof(WORD), &cbSaved);
            break;

        case VT_I4:
            hr = pStm->Write(pSrc->lVal, sizeof(DWORD), &cbSaved);
            break;

        case VT_CY:
            hr = pStm->Write(pSrc->cyVal.Lo, sizeof(WORD), &cbSaved);
            hr = pStm->Write(pSrc->cyVal.Hi, sizeof(WORD), &cbSaved);
            break;

        case VT_R4:
            hr = pStm->Write(pSrc->fltVal, sizeof(WORD), &cbSaved);
            break;

        case VT_R8:
            hr = pStm->Write(pSrc->dblVal, sizeof(DOUBLE), &cbSaved);
            break;

        case VT_DATE:
            hr = pStm->Write(pSrc->date;
            break;

        case VT_ERROR:
            hr = pStm->Write(pSrc->scode;
            break;
    #endif //_unused_
        }
    }


    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COleVariant::Load
//
//  Synopsis:   loads a variant from a stream
//
//  Arguments:  [pStm] --
//
//  Returns:
//
//  History:    1-15-1997   JohannP (Johann Posch)   Created
//
//  Notes:      BUGBUG:NOT COMPLETE!
//
//----------------------------------------------------------------------------
HRESULT COleVariant::Load(IStream *pStm)
{
    LPVARIANT pSrc = (LPVARIANT)this;
    HRESULT hr = NOERROR;
    ULONG cbSaved;
    COleVariant CVar;

    // Read the variant
    hr = pStm->Read(pSrc, sizeof(VARIANT), &cbSaved);
    TransAssert(( sizeof(VARIANT) == cbSaved));

    if (pSrc->vt & VT_BYREF || pSrc->vt & VT_ARRAY)
    {
        // No support for VT_BYREF & VT_ARRAY
        pSrc = (LPVARIANT)&CVar;
    }

    if (hr == NOERROR)
    {
        switch (pSrc->vt)
        {
        case VT_DISPATCH:
            TransAssert((FALSE));
            hr = E_FAIL;
            break;


        case VT_UNKNOWN:
            {
                ULONG cbInterface = 0;
                IUnknown *pUnk = 0;
                
                // write the size of 
                hr = pStm->Read(&cbInterface, sizeof(ULONG), &cbSaved);

                if (   (hr == S_OK)
                    && cbInterface)
                {

                    hr = CoUnmarshalInterface(pStm, IID_IUnknown, (void **) &pUnk);
                    if(hr == S_OK)
                    {
                        pSrc->punkVal = pUnk;
                    }
                    else
                    {
                        pSrc->punkVal = 0;
                    }
                }
                else
                {
                    pSrc->punkVal = 0;
                }
                hr = NOERROR;
            }
            break;


        default:
        case VT_EMPTY:
        case VT_NULL:
            // do nothing
            break;

        case VT_BSTR:
            {
                DWORD nLen = 0;
                hr = pStm->Read(&nLen, sizeof(DWORD), &cbSaved);

                if (nLen > 0)
                {
                    pSrc->bstrVal = SysAllocStringByteLen(NULL, nLen);

                    if (pSrc->bstrVal)
                    {
                        hr = pStm->Read(pSrc->bstrVal, nLen * sizeof(BYTE), &cbSaved);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            break;


    #ifdef _unused_
        case VT_BOOL:
            hr = pStm->Read((WORD)V_BOOL(pSrc), sizeof(WORD), &cbSaved);
            break;

        case VT_UI1:
            hr = pStm->Read(pSrc->bVal, sizeof(WORD), &cbSaved);
            break;

        case VT_I2:
            hr = pStm->Read((WORD)pSrc->iVal, sizeof(WORD), &cbSaved);
            break;

        case VT_I4:
            hr = pStm->Read(pSrc->lVal, sizeof(DWORD), &cbSaved);
            break;

        case VT_CY:
            hr = pStm->Read(pSrc->cyVal.Lo, sizeof(WORD), &cbSaved);
            hr = pStm->Read(pSrc->cyVal.Hi, sizeof(WORD), &cbSaved);
            break;

        case VT_R4:
            hr = pStm->Read(pSrc->fltVal, sizeof(WORD), &cbSaved);
            break;

        case VT_R8:
            hr = pStm->Read(pSrc->dblVal, sizeof(DOUBLE), &cbSaved);
            break;

        case VT_DATE:
            hr = pStm->Read(pSrc->date;
            break;

        case VT_ERROR:
            hr = pStm->Read(pSrc->scode;
            break;
    #endif //_unused_
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\dprintf.c ===
/***
*dprintf.c - print formatted to debug port
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4dprintf() - print formatted data to debug port
*	defines w4vdprintf() - print formatted output to debug port, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#include "dprintf.h"		// function prototypes

#define _W4DPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\ctime.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFX.H

#ifdef _AFX_INLINE

// CTime and CTimeSpan
_AFX_INLINE CTimeSpan::CTimeSpan()
        { }
_AFX_INLINE CTimeSpan::CTimeSpan(time_t time)
        { m_timeSpan = time; }
_AFX_INLINE CTimeSpan::CTimeSpan(LONG lDays, int nHours, int nMins, int nSecs)
        { m_timeSpan = nSecs + 60* (nMins + 60* (nHours + 24* lDays)); }
_AFX_INLINE CTimeSpan::CTimeSpan(const CTimeSpan& timeSpanSrc)
        { m_timeSpan = timeSpanSrc.m_timeSpan; }
_AFX_INLINE const CTimeSpan& CTimeSpan::operator=(const CTimeSpan& timeSpanSrc)
        { m_timeSpan = timeSpanSrc.m_timeSpan; return *this; }
_AFX_INLINE LONG CTimeSpan::GetDays() const
        { return (LONG)(m_timeSpan / (24*3600L)); }
_AFX_INLINE LONG CTimeSpan::GetTotalHours() const
        { return (LONG)(m_timeSpan/3600); }
_AFX_INLINE int CTimeSpan::GetHours() const
        { return (int)(GetTotalHours() - GetDays()*24); }
_AFX_INLINE LONG CTimeSpan::GetTotalMinutes() const
        { return (LONG)(m_timeSpan/60); }
_AFX_INLINE int CTimeSpan::GetMinutes() const
        { return (int)(GetTotalMinutes() - GetTotalHours()*60); }
_AFX_INLINE LONG_PTR CTimeSpan::GetTotalSeconds() const
        { return m_timeSpan; }
_AFX_INLINE int CTimeSpan::GetSeconds() const
        { return (int)(GetTotalSeconds() - GetTotalMinutes()*60); }
_AFX_INLINE CTimeSpan CTimeSpan::operator-(CTimeSpan timeSpan) const
        { return CTimeSpan(m_timeSpan - timeSpan.m_timeSpan); }
_AFX_INLINE CTimeSpan CTimeSpan::operator+(CTimeSpan timeSpan) const
        { return CTimeSpan(m_timeSpan + timeSpan.m_timeSpan); }
_AFX_INLINE const CTimeSpan& CTimeSpan::operator+=(CTimeSpan timeSpan)
        { m_timeSpan += timeSpan.m_timeSpan; return *this; }
_AFX_INLINE const CTimeSpan& CTimeSpan::operator-=(CTimeSpan timeSpan)
        { m_timeSpan -= timeSpan.m_timeSpan; return *this; }
_AFX_INLINE BOOL CTimeSpan::operator==(CTimeSpan timeSpan) const
        { return m_timeSpan == timeSpan.m_timeSpan; }
_AFX_INLINE BOOL CTimeSpan::operator!=(CTimeSpan timeSpan) const
        { return m_timeSpan != timeSpan.m_timeSpan; }
_AFX_INLINE BOOL CTimeSpan::operator<(CTimeSpan timeSpan) const
        { return m_timeSpan < timeSpan.m_timeSpan; }
_AFX_INLINE BOOL CTimeSpan::operator>(CTimeSpan timeSpan) const
        { return m_timeSpan > timeSpan.m_timeSpan; }
_AFX_INLINE BOOL CTimeSpan::operator<=(CTimeSpan timeSpan) const
        { return m_timeSpan <= timeSpan.m_timeSpan; }
_AFX_INLINE BOOL CTimeSpan::operator>=(CTimeSpan timeSpan) const
        { return m_timeSpan >= timeSpan.m_timeSpan; }


_AFX_INLINE CTime::CTime()
        { }
_AFX_INLINE CTime::CTime(time_t time)
        { m_time = time; }
_AFX_INLINE CTime::CTime(const CTime& timeSrc)
        { m_time = timeSrc.m_time; }
_AFX_INLINE const CTime& CTime::operator=(const CTime& timeSrc)
        { m_time = timeSrc.m_time; return *this; }
_AFX_INLINE const CTime& CTime::operator=(time_t t)
        { m_time = t; return *this; }
_AFX_INLINE time_t CTime::GetTime() const
        { return m_time; }
_AFX_INLINE int CTime::GetYear() const
        { return (GetLocalTm(NULL)->tm_year) + 1900; }
_AFX_INLINE int CTime::GetMonth() const
        { return GetLocalTm(NULL)->tm_mon + 1; }
_AFX_INLINE int CTime::GetDay() const
        { return GetLocalTm(NULL)->tm_mday; }
_AFX_INLINE int CTime::GetHour() const
        { return GetLocalTm(NULL)->tm_hour; }
_AFX_INLINE int CTime::GetMinute() const
        { return GetLocalTm(NULL)->tm_min; }
_AFX_INLINE int CTime::GetSecond() const
        { return GetLocalTm(NULL)->tm_sec; }
_AFX_INLINE int CTime::GetDayOfWeek() const
        { return GetLocalTm(NULL)->tm_wday + 1; }
_AFX_INLINE CTimeSpan CTime::operator-(CTime time) const
        { return CTimeSpan(m_time - time.m_time); }
_AFX_INLINE CTime CTime::operator-(CTimeSpan timeSpan) const
        { return CTime(m_time - timeSpan.m_timeSpan); }
_AFX_INLINE CTime CTime::operator+(CTimeSpan timeSpan) const
        { return CTime(m_time + timeSpan.m_timeSpan); }
_AFX_INLINE const CTime& CTime::operator+=(CTimeSpan timeSpan)
        { m_time += timeSpan.m_timeSpan; return *this; }
_AFX_INLINE const CTime& CTime::operator-=(CTimeSpan timeSpan)
        { m_time -= timeSpan.m_timeSpan; return *this; }
_AFX_INLINE BOOL CTime::operator==(CTime time) const
        { return m_time == time.m_time; }
_AFX_INLINE BOOL CTime::operator!=(CTime time) const
        { return m_time != time.m_time; }
_AFX_INLINE BOOL CTime::operator<(CTime time) const
        { return m_time < time.m_time; }
_AFX_INLINE BOOL CTime::operator>(CTime time) const
        { return m_time > time.m_time; }
_AFX_INLINE BOOL CTime::operator<=(CTime time) const
        { return m_time <= time.m_time; }
_AFX_INLINE BOOL CTime::operator>=(CTime time) const
        { return m_time >= time.m_time; }

/////////////////////////////////////////////////////////////////////////////
#endif //_AFX_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\eqguid.cxx ===
#include  <windows.h>
#include  <ole2.h>
#include  <stdlib.h>

#ifndef _SYS_GUID_OPERATORS_
//+-------------------------------------------------------------------------
//
//  Function:	IsEqualGUID  (public)
//
//  Synopsis:	compares two guids for equality
//
//  Arguments:	[guid1]	- the first guid
//		[guid2] - the second guid to compare the first one with
//
//  Returns:	TRUE if equal, FALSE if not.
//
//--------------------------------------------------------------------------

extern "C" BOOL  __stdcall IsEqualGUID(GUID &guid1, GUID &guid2)
{
    return !memcmp((void *)&guid1,(void *)&guid2,sizeof(GUID));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\debug.h ===
//+----------------------------------------------------------------------------
//
//	File:
//		debug.h
//
//	Contents:
//		macros and declarations for debug support--all are appropriately
//		defined to nothing when not doing debug build
//
//	Classes:
//
//	Functions:
//
//	History:
//		12/30/93 - ChrisWe - added file prologue; defined _DEBUG when
//			DBG==1; added "const" to ASSERTDATA macro
//
//-----------------------------------------------------------------------------


#ifndef _DEBUG_H_
#define _DEBUG_H_

#include <debnot.h>

#ifndef RC_INVOKED
#ifdef _DEBUG
#define DBGSTATE " Debug is on"
#else
#define DBGSTATE " Debug is off"
#endif
#endif  /* RC_INVOKED */

#ifndef _CAIRO_
#include <ole2dbg.h>
#endif

//these are bogus APIs (they do nothing)
STDAPI_(BOOL) ValidateAllObjects( BOOL fSuspicious );
STDAPI_(void) DumpAllObjects( void );

#ifdef _DEBUG
BOOL InstallHooks(void);
BOOL UnInstallHooks(void);

#undef ASSERTDATA
#define ASSERTDATA

#undef AssertSz
#define AssertSz(a,b) ((a) ? NOERROR : FnAssert(#a, b, __FILE__, __LINE__))
#undef Puts
#define Puts(s) OutputDebugString(TEXT(s))

#else   //  !_DEBUG

#define ASSERTDATA
#define AssertSz(a, b) ((void)0)
#define Puts(s) ((void)0)

#endif  //  _DEBUG


// special Assert for asserts below (since the expression is so large)
// REVIEW, shouldn't these be in the debug.h file?
#ifdef _DEBUG
#define AssertOut(a, b) { if (!(a)) FnAssert(szCheckOutParam, b, __FILE__, __LINE__); }
#else
#define AssertOut(a, b) ((void)0)
#endif

#define AssertOutPtrParam(hr, p) \
	AssertOut(SUCCEEDED(hr) && IsValidPtrIn(p, sizeof(OLECHAR)) || \
	FAILED(hr) && (p) == NULL, \
	szBadOutParam)

#define AssertOutPtrIface(hr, p) \
	AssertOut(SUCCEEDED(hr) && IsValidInterface(p) || \
	FAILED(hr) && (p) == NULL, \
	szBadOutIface)

#define AssertOutPtrFailed(p) \
	AssertOut((p) == NULL, \
	szNonNULLOutPtr)

#define AssertOutStgmedium(hr, pstgm) \
	AssertOut(SUCCEEDED(hr) && (pstgm)->tymed != TYMED_NULL || \
	FAILED(hr) && (pstgm)->tymed == TYMED_NULL, \
	szBadOutStgm)


// assert data for above assert out macros; once per dll
// Note that since these are only used in asserts, we leave them as ANSI
#define ASSERTOUTDATA \
    char szCheckOutParam[] = "check out param"; \
    char szBadOutParam[] = "Out pointer param conventions not followed"; \
    char szBadOutIface[] = "Out pointer interface conventions not followed"; \
    char szNonNULLOutPtr[] = "Out pointer not NULL on error"; \
    char szBadOutStgm[] = "Out stgmed param conventions not followed";

extern char szCheckOutParam[];
extern char szBadOutParam[];
extern char szBadOutIface[];
extern char szNonNULLOutPtr[];
extern char szBadOutStgm[];


#ifdef __cplusplus

interface IDebugStream;

/*
 *  Class CBool wraps boolean values in such a way that they are
 *  readily distinguishable fron integers by the compiler so we can
 *  overload the stream << operator.
 */

class FAR CBool
{
    BOOL value;
public:
    CBool (BOOL& b) {value = b;}
    operator BOOL( void ) { return value; }
};


/*
 *  Class CHwnd wraps HWND values in such a way that they are
 *  readily distinguishable from UINTS by the compiler so we can
 *  overload the stream << operator
 */

class FAR CHwnd
{
	HWND m_hwnd;
	public:
		CHwnd (HWND hwnd) {m_hwnd = hwnd; }
		operator HWND( void ) {return m_hwnd;}
};

/*
 * Class CAtom wraps ATOM values in such a way that they are
 *  readily distinguishable from UINTS by the compiler so we can
 *  overload the stream << operator
 */

class FAR CAtom
{
	ATOM m_atom;
	public:
		CAtom (ATOM atom) {m_atom = atom; }
		operator ATOM( void ) {return m_atom; }
};

/*
 *  IDebugStream is a stream to be used for debug output.  One
 *  implementation uses the OutputDebugString function of Windows.
 *
 *  The style is modeled on that of AT&T streams, and so uses
 *  overloaded operators.  You can write to a stream in the
 *  following ways:
 *
 *    *pdbstm << pUnk;  // calls the IDebug::Dump function to
 *                      display the object, if IDebug is supported.
 *    int n;
 *    *pdbstm << n;     // writes n in decimal
 *
-
 *    *pdbstm << sz;    // writes a string
 *
 *    CBool b(TRUE);
 *    *pdbstm << b;     // writes True or False
 *
 *    void FAR * pv;
 *    *pdbstm << pv;    // writes the address pv in hex
 *
 *    TCHAR ch;
 *    *pdbstm << ch;    // writes the character
 *
 *    ATOM atom;
 *    *pdbstm << CAtom(atom);	// writes the string extracted from the atom
 *
 *    HWND hwnd;
 *    *pdbstm << CHwnd(hwnd);  // writes the info about a window handle
 *
 *  These can be chained together, as such (somewhat artificial
 *  example):
 *
 *    REFCLSID rclsid;
 *    pUnk->GetClass(&rclsid);
 *    *pdbstm << rclsid << " at " << (void FAR *)pUnk <<':' << pUnk;
 *
 *  This produces something like:
 *
 *    CFoo at A7360008: <description of object>
 *
 *  The other useful feature is the Indent and UnIndent functions
 *  which allow an object to print some information, indent, print
 *  the info on its member objects, and unindent.  This gives
 *  nicely formatted output.
 *
 *  WARNING:  do not (while implementing Dump) write
 *
 *    *pdbstm << pUnkOuter
 *
 *  since this will do a QueryInterface for IDebug, and start
 *  recursing!  It is acceptable to write
 *
 *    *pdbstm << (VOID FAR *)pUnkOuter
 *
 *  as this will simply write the address of pUnkOuter.
 *
 */


interface IDebugStream : public IUnknown
{
    STDMETHOD_(IDebugStream&, operator << ) ( IUnknown FAR * pDebug ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( REFCLSID rclsid ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( int n ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( long l ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( ULONG l ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( LPCTSTR sz ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( TCHAR ch ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( void FAR * pv ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CBool b ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CHwnd hwnd ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CAtom atom ) = 0;
    STDMETHOD_(IDebugStream&, Tab )( void ) = 0;
    STDMETHOD_(IDebugStream&, Indent )( void ) = 0;
    STDMETHOD_(IDebugStream&, UnIndent )( void ) = 0;
    STDMETHOD_(IDebugStream&, Return )( void ) = 0;
    STDMETHOD_(IDebugStream&, LF )( void ) = 0;
};

STDAPI_(IDebugStream FAR*) MakeDebugStream( short margin=70, short tabsize=4, BOOL fHeader=1);


interface IDebug
{
    STDMETHOD_(void, Dump )( IDebugStream FAR * pdbstm ) = 0;
    STDMETHOD_(BOOL, IsValid )( BOOL fSuspicious = FALSE ) = 0;

#ifdef NEVER
    __export IDebug(void);
    __export ~IDebug(void);
private:

#ifdef _DEBUG
    IDebug FAR * pIDPrev;
    IDebug FAR * pIDNext;

    friend void STDAPICALLTYPE DumpAllObjects( void );
    friend BOOL STDAPICALLTYPE ValidateAllObjects( BOOL fSuspicious );
#endif // _DEBUG
#endif // NEVER
};

/*************************************************************************
** The following functions can be used to log debug messages to a file
**    and simutaneously write them to the dbwin debug window.
**    The CDebugStream implementation automatically writes to a debug
**    log file called "debug.log" in the current working directory.
**    NOTE: The functions are only intended for C programmers. C++
**    programmers should use the "MakeDebugStream" instead.
*************************************************************************/

// Open a log file.
STDAPI_(HFILE) DbgLogOpen(LPCTSTR lpszFile, LPCTSTR lpszMode);

// Close the log file.
STDAPI_(void) DbgLogClose(HFILE fh);

// Write to debug log and debug window (used with cvw.exe or dbwin.exe).
STDAPI_(void) DbgLogOutputDebugString(HFILE fh, LPCTSTR lpsz);

// Write to debug log only.
STDAPI_(void) DbgLogWrite(HFILE fh, LPCTSTR lpsz);

// Write the current Date and Time to the log file.
STDAPI_(void) DbgLogTimeStamp(HFILE fh, LPCTSTR lpsz);

// Write a banner separater to the log to separate sections.
STDAPI_(void) DbgLogWriteBanner(HFILE fh, LPCTSTR lpsz);




/*
 *  STDDEBDECL macro - helper for debug declaration
 *
 */

#ifdef _DEBUG

        #define STDDEBDECL(ignore, classname ) implement CDebug:public IDebug { public: \
            CDebug( C##classname FAR * p##classname ) { m_p##classname = p##classname;} \
            ~CDebug(void) {} \
            STDMETHOD_(void, Dump)(IDebugStream FAR * pdbstm ); \
            STDMETHOD_(BOOL, IsValid)(BOOL fSuspicious ); \
            private: C##classname FAR* m_p##classname; }; \
            DECLARE_NC(C##classname, CDebug) \
            CDebug m_Debug;

    #define CONSTRUCT_DEBUG m_Debug(this),

#else //        _DEBUG

//      no debugging
#define STDDEBDECL(cclassname,classname)
#define CONSTRUCT_DEBUG

#endif  //      _DEBUG

#endif // __cplusplus

#endif // !_DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\output.c ===
/***
*output.c - printf style output to a struct w4io
*
*   Copyright (c) 1989-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the code that does all the work for the
*   printf family of functions.  It should not be called directly, only
*   by the *printf functions.  We don't make any assumtions about the
*   sizes of ints, longs, shorts, or long doubles, but if types do overlap, we
*   also try to be efficient.  We do assume that pointers are the same size
*   as either ints or longs.
*
*Revision History:
*   06-01-89  PHG   Module created
*   08-28-89  JCR   Added cast to get rid of warning (no object changes)
*   02-15-90  GJF   Fixed copyright
*   10-03-90  WHB   Defined LOCAL(x) to "static x" for local procedures
*   06-05-95  SVA   Added support for printing GUIDs.
*
*******************************************************************************/

#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <stdarg.h>
#include <basetsd.h>
#include "wchar.h"
#include "w4io.h"


/* this macro defines a function which is private and as fast as possible: */
/* for example, in C 6.0, it might be static _fastcall <type>. */
#define LOCAL(x) static x            // 100390--WHB

#define NOFLOATS                        // Win 4 doesn't need floating point

/* int/long/short/pointer sizes */

/* the following should be set depending on the sizes of various types */
// FLAT or LARGE model is assumed
#ifdef FLAT
#  define LONG_IS_INT        1       /* 1 means long is same size as int */
#  define SHORT_IS_INT       0       /* 1 means short is same size as int */
#ifdef _WIN64
#  define PTR_IS_INT         0       /* 1 means ptr is same size as int */
#else  // !_WIN64
#  define PTR_IS_INT         1       /* 1 means ptr is same size as int */
#endif // !_WIN64
#  define PTR_IS_LONG        0       /* 1 means ptr is same size as long */
#else // LARGE model
#  define LONG_IS_INT        0       /* 1 means long is same size as int */
#  define SHORT_IS_INT       1       /* 1 means short is same size as int */
#  define PTR_IS_INT         0       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        1       /* 1 means ptr is same size as long */
#endif
#define LONGDOUBLE_IS_DOUBLE 0       /* 1 means long double is same as double */

#if LONG_IS_INT
    #define get_long_arg(x) (long)get_int_arg(x)
#endif

#if PTR_IS_INT
    #define get_ptr_arg(x) (void *)get_int_arg(x)
#elif PTR_IS_LONG
    #define get_ptr_arg(x) (void *)get_long_arg(x)
#elif _WIN64
    #define get_ptr_arg(x) (void *)get_int64_arg(x)
#else 
    #error Size of pointer must be same as size of int or long
#endif

#ifndef NOFLOATS
/* These are "fake" double and long doubles to fool the compiler,
   so we don't drag in floating point. */
typedef struct {
    char x[sizeof(double)];
} DOUBLE;
typedef struct {
    char x[sizeof(long double)];
} LONGDOUBLE;
#endif


/* CONSTANTS */

//#define BUFFERSIZE CVTBUFSIZE     /* buffer size for maximum double conv */
#define BUFFERSIZE 20

/* flag definitions */
#define FL_SIGN       0x0001      /* put plus or minus in front */
#define FL_SIGNSP     0x0002      /* put space or minus in front */
#define FL_LEFT       0x0004      /* left justify */
#define FL_LEADZERO   0x0008      /* pad with leading zeros */
#define FL_LONG       0x0010      /* long value given */
#define FL_SHORT      0x0020      /* short value given */
#define FL_SIGNED     0x0040      /* signed data given */
#define FL_ALTERNATE  0x0080      /* alternate form requested */
#define FL_NEGATIVE   0x0100      /* value is negative */
#define FL_FORCEOCTAL 0x0200      /* force leading '0' for octals */
#define FL_LONGDOUBLE 0x0400      /* long double value given */
#define FL_WIDE       0x0800      /* wide character/string given */
#define FL_PTR64      0x1000      /* wide character/string given */

#ifdef _WIN64
#define FL_PTR        FL_PTR64
#else  // !_WIN64
#define FL_PTR        FL_LONG     /* as the processing specified originally... */
#endif // !_WIN64

/* state definitions */
enum STATE {
    ST_NORMAL,              /* normal state; outputting literal chars */
    ST_PERCENT,             /* just read '%' */
    ST_FLAG,                /* just read flag character */
    ST_WIDTH,               /* just read width specifier */
    ST_DOT,                 /* just read '.' */
    ST_PRECIS,              /* just read precision specifier */
    ST_SIZE,                /* just read size specifier */
    ST_TYPE                 /* just read type specifier */
};
#define NUMSTATES (ST_TYPE + 1)

/* character type values */
enum CHARTYPE {
    CH_OTHER,               /* character with no special meaning */
    CH_PERCENT,             /* '%' */
    CH_DOT,                 /* '.' */
    CH_STAR,                /* '*' */
    CH_ZERO,                /* '0' */
    CH_DIGIT,               /* '1'..'9' */
    CH_FLAG,                /* ' ', '+', '-', '#' */
    CH_SIZE,                /* 'h', 'l', 'L', 'N', 'F' */
    CH_TYPE                 /* type specifying character */
};

/* static data (read only, since we are re-entrant) */
char *nullstring = "(null)";    /* string to print on null ptr */

/* The state table.  This table is actually two tables combined into one. */
/* The lower nybble of each byte gives the character class of any         */
/* character; while the uper nybble of the byte gives the next state      */
/* to enter.  See the macros below the table for details.                 */
/*                                                                        */
/* The table is generated by maketab.c -- use the maketab program to make */
/* changes.                                                               */

/* Brief description of the table, since I can't find maketab.c - t-stevan     */
/* Each entry in form 0xYZ. Here Z is a character class used in the macro      */
/* find_char_class defined below. The character classes are defined in the     */
/* CHARTYPE enum. For example, 'I' maps to CH_TYPE. To find a particular entry */
/* Subtract the ASCI value for the space char from the character, and that is  */
/* the index to look up. The Y value is holds state transition information.    */
/* It is used in the macro find_next_state. */  
static char lookuptable[] = {
    0x06, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00,
    0x10, 0x00, 0x03, 0x06, 0x00, 0x06, 0x02, 0x10,
    0x04, 0x45, 0x45, 0x45, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x35, 0x30, 0x00, 0x50, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x28, 0x38, 0x50, 0x58, 0x07, 0x08,
    0x00, 0x38, 0x30, 0x30, 0x57, 0x50, 0x07, 0x00,
    0x00, 0x20, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00,
    0x00, 0x70, 0x70, 0x78, 0x78, 0x78, 0x78, 0x08,
    0x07, 0x08, 0x00, 0x00, 0x07, 0x00, 0x08, 0x08,
    0x08, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x07,
    0x08
};

#define find_char_class(c)              \
        ((c) < ' ' || (c) > 'x' ?       \
            CH_OTHER                    \
        :                               \
            lookuptable[(c)-' '] & 0xF)

#define find_next_state(class, state)   \
        (lookuptable[(class) * NUMSTATES + (state)] >> 4)

#ifdef _WIN64
LOCAL(__int64) get_int64_arg(va_list *pargptr);
#endif 

#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr);
#endif
LOCAL(int) get_int_arg(va_list *pargptr);
LOCAL(void) writestring(char *string,
                        int len,
                        struct w4io *f,
                        int *pcchwritten,
                        int fwide);

#ifndef NOFLOATS
/* extern float convert routines */
typedef int (* PFI)();
extern PFI _cfltcvt_tab[5];
#define _cfltcvt(a,b,c,d,e) (*_cfltcvt_tab[0])(a,b,c,d,e)
#define _cropzeros(a)       (*_cfltcvt_tab[1])(a)
#define _fassign(a,b,c)     (*_cfltcvt_tab[2])(a,b,c)
#define _forcdecpt(a)       (*_cfltcvt_tab[3])(a)
#define _positive(a)        (*_cfltcvt_tab[4])(a)
#define _cldcvt(a,b,c,d,e)  (*_cfltcvt_tab[5])(a,b,c,d,e)
#endif

/* Defines for printing out GUIDs */
#ifndef GUID_DEFINED
#define GUID_DEFINED
			/* size is 16 */
typedef struct  _GUID
    {
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[ 8 ];
    }	GUID;

#endif // !GUID_DEFINED

#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED

/* This is actually one less than the normal GUIDSTR_MAX */
/* Because we don't tag on a NULL byte */
#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 /* + 1 */)

/* Make sure our buffer size is big enough to hold a GUID */
#if BUFFERSIZE < GUIDSTR_MAX
#undef BUFFERSIZE
#define BUFFERSIZE GUIDSTR_MAX
#endif

/* Function used to write a GUID to a string */
int StrFromGUID(REFGUID rguid, char * lpsz, int cbMax);

/***
*int w4iooutput(f, format, argptr)
*
*Purpose:
*   Output performs printf style output onto a stream.  It is called by
*   printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to so the dirty
*   work.  In multi-thread situations, w4iooutput assumes that the given
*   stream is already locked.
*
*   Algorithm:
*       The format string is parsed by using a finite state automaton
*       based on the current state and the current character read from
*       the format string.  Thus, looping is on a per-character basis,
*       not a per conversion specifier basis.  Once the format specififying
*       character is read, output is performed.
*
*Entry:
*   struct w4io *f   - stream for output
*   char *format   - printf style format string
*   va_list argptr - pointer to list of subsidiary arguments
*
*Exit:
*   Returns the number of characters written, or -1 if an output error
*   occurs.
*
*Exceptions:
*
*Notes: 
*       FIXFIX - This code does not handle I64 for __int64 and derived types.
*       FIXFIX - This code does not handle I64 10byte floats.
*       FIXFIX - This code has to be tested for IA64 8byte floats.
*
*******************************************************************************/

int _cdecl w4iooutput(struct w4io *f, const char *format, va_list argptr)
{
    int hexadd;         /* offset to add to number to get 'a'..'f' */
    char ch;            /* character just read */
    wchar_t wc;         /* wide character temp */
    wchar_t *pwc;       /* wide character temp pointer */
    int flags;          /* flag word -- see #defines above for flag values */
    enum STATE state;   /* current state */
    enum CHARTYPE chclass; /* class of current character */
    int radix;          /* current conversion radix */
    int charsout;       /* characters currently written so far, -1 = IO error */
    int fldwidth;       /* selected field with -- 0 means default */
    int fwide;
    int precision = -1;      /* selected precision -- -1 means default */
    char prefix[2];     /* numeric prefix -- up to two characters */
    int prefixlen;      /* length of prefix -- 0 means no prefix */
    int capexp;         /* non-zero = 'E' exponent signifiet, zero = 'e' */
    int no_output;      /* non-zero = prodcue no output for this specifier */
    char *text;         /* pointer text to be printed, not zero terminated */
    int textlen;        /* length of the text to be printed */
    char buffer[BUFFERSIZE];    /* buffer for conversions */

    charsout = 0;               /* no characters written yet */
    state = ST_NORMAL;          /* starting state */

    /* main loop -- loop while format character exist and no I/O errors */
    while ((ch = *format++) != '\0' && charsout >= 0) {
        chclass = find_char_class(ch);  /* find character class */
        state = find_next_state(chclass, state); /* find next state */

        /* execute code for each state */
        switch (state) {

        case ST_NORMAL:
            /* normal state -- just write character */
            f->writechar(ch, 1, f, &charsout);
            break;

        case ST_PERCENT:
            /* set default value of conversion parameters */
            prefixlen = fldwidth = no_output = capexp = 0;
            flags = 0;
            precision = -1;
            fwide = 0;
            break;

        case ST_FLAG:
            /* set flag based on which flag character */
            switch (ch) {
            case '-':
                flags |= FL_LEFT;       /* '-' => left justify */
                break;
            case '+':
                flags |= FL_SIGN;       /* '+' => force sign indicator */
                break;
            case ' ':
                flags |= FL_SIGNSP;     /* ' ' => force sign or space */
                break;
            case '#':
                flags |= FL_ALTERNATE;  /* '#' => alternate form */
                break;
            case '0':
                flags |= FL_LEADZERO;   /* '0' => pad with leading zeros */
                break;
            }
            break;

        case ST_WIDTH:
            /* update width value */
            if (ch == '*') {
                /* get width from arg list */
                fldwidth = get_int_arg(&argptr);
                if (fldwidth < 0) {
                    /* ANSI says neg fld width means '-' flag and pos width */
                    flags |= FL_LEFT;
                    fldwidth = -fldwidth;
                }
            }
            else {
                /* add digit to current field width */
                fldwidth = fldwidth * 10 + (ch - '0');
            }
            break;

        case ST_DOT:
            /* zero the precision, since dot with no number means 0
               not default, according to ANSI */
            precision = 0;
            break;

        case ST_PRECIS:
            /* update precison value */
            if (ch == '*') {
                /* get precision from arg list */
                precision = get_int_arg(&argptr);
                if (precision < 0)
                    precision = -1;     /* neg precision means default */
            }
            else {
                /* add digit to current precision */
                precision = precision * 10 + (ch - '0');
            }
            break;

        case ST_SIZE:
            /* just read a size specifier, set the flags based on it */
            switch (ch) {
#if !LONG_IS_INT
            case 'l':
                flags |= FL_LONG;   /* 'l' => long int */
                break;
#endif

#if !LONGDOUBLE_IS_DOUBLE
            case 'L':
                flags |= FL_LONGDOUBLE; /* 'L' => long double */
                break;
#endif

#if !SHORT_IS_INT
            case 'h':
                flags |= FL_SHORT;  /* 'h' => short int */
                break;
#endif
            case 'w':
                flags |= FL_WIDE;   /* 'w' => wide character */
                break;
            }
            break;

        case ST_TYPE:
            /* we have finally read the actual type character, so we       */
            /* now format and "print" the output.  We use a big switch     */
            /* statement that sets 'text' to point to the text that should */
            /* be printed, and 'textlen' to the length of this text.       */
            /* Common code later on takes care of justifying it and        */
            /* other miscellaneous chores.  Note that cases share code,    */
            /* in particular, all integer formatting is doen in one place. */
            /* Look at those funky goto statements!                        */

            switch (ch) {

            case 'c': {
                /* print a single character specified by int argument */
                wc = (wchar_t) get_int_arg(&argptr);    /* get char to print */
                * (wchar_t *) buffer = wc;
                text = buffer;
                textlen = 1;        /* print just a single character */
            }
            break;

            case 'S': {
                /* print a Counted String   */

                struct string {
                    short Length;
                    short MaximumLength;
                    char *Buffer;
                } *pstr;

                pstr = get_ptr_arg(&argptr);
                if (pstr == NULL || pstr->Buffer == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    textlen = strlen(text);
                    flags &= ~FL_WIDE;
                } else {
                    text = pstr->Buffer;
                    /* The length field is a count of bytes, not characters. */
                    if (flags & FL_WIDE)
                        textlen = pstr->Length / sizeof( wchar_t );
                    else
                        textlen = pstr->Length;
                    if (precision != -1)
                        textlen = min( textlen, precision );
                }

            }
            break;

            case 's': {
                /* print a string --                            */
                /* ANSI rules on how much of string to print:   */
                /*   all if precision is default,               */
                /*   min(precision, length) if precision given. */
                /* prints '(null)' if a null string is passed   */

                int i;
                char *p;       /* temps */

                text = get_ptr_arg(&argptr);
                if (text == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    flags &= ~FL_WIDE;
                }

                /* At this point it is tempting to use strlen(), but */
                /* if a precision is specified, we're not allowed to */
                /* scan past there, because there might be no null   */
                /* at all.  Thus, we must do our own scan.           */

                i = (precision == -1) ? INT_MAX : precision;

                /* scan for null upto i characters */
                if (flags & FL_WIDE) {
                    pwc = (wchar_t *) text;
                    while (i-- && (wc = *pwc) && (wc & 0x00ff)) {
                        ++pwc;
                        if (wc & 0xff00) {      // if high byte set,
                            break;              // error will be indicated
                        }
                    }
                    textlen = (int) (pwc - (wchar_t*)text);  /* length of string */
                } else {
                    p = text;
                    while (i-- && *p) {
                        ++p;
                    }
                    textlen = (int) (p - text);    /* length of the string */
                }
            }
            break;

            /* print a GUID */
            case 'I':
            {
                void *p;        /* temp */

                p = get_ptr_arg(&argptr);

			    if (p == NULL) 
			    {
			   		/* null ptr passed, use special string */
			   		text = nullstring;
					textlen = strlen(nullstring);
				}
				else
               	{
               		textlen = StrFromGUID(p, buffer, BUFFERSIZE); 
               		text = buffer;
				}
            }
            break;

            case 'n': {
                /* write count of characters seen so far into */
                /* short/int/long thru ptr read from args */

                void *p;            /* temp */

                p = get_ptr_arg(&argptr);

                /* store chars out into short/long/int depending on flags */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    *(long *)p = charsout;
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT)
                    *(short *)p = (short) charsout;
                else
#endif
                    *(int *)p = charsout;

                no_output = 1;              /* force no output */
            }
            break;

#ifndef NOFLOATS
            case 'E':
            case 'G':
                capexp = 1;                 /* capitalize exponent */
                ch += 'a' - 'A';            /* convert format char to lower */
                /* DROP THROUGH */
            case 'e':
            case 'f':
            case 'g':   {
                /* floating point conversion -- we call cfltcvt routines */
                /* to do the work for us.                                */
                flags |= FL_SIGNED;         /* floating point is signed conversion */
                text = buffer;              /* put result in buffer */
                flags &= ~FL_WIDE;          /* 8 bit string */

                /* compute the precision value */
                if (precision < 0)
                    precision = 6;      /* default precision: 6 */
                else if (precision == 0 && ch == 'g')
                    precision = 1;      /* ANSI specified */

#if !LONGDOUBLE_IS_DOUBLE
                /* do the conversion */
                if (flags & FL_LONGDOUBLE) {
                    _cldcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, LONGDOUBLE);
                }
                else
#endif
                {
                    _cfltcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, DOUBLE);
                }

                /* '#' and precision == 0 means force a decimal point */
                if ((flags & FL_ALTERNATE) && precision == 0)
                    _forcdecpt(text);

                /* 'g' format means crop zero unless '#' given */
                if (ch == 'g' && !(flags & FL_ALTERNATE))
                    _cropzeros(text);

                /* check if result was negative, save '-' for later */
                /* and point to positive part (this is for '0' padding) */
                if (*text == '-') {
                    flags |= FL_NEGATIVE;
                    ++text;
                }

                textlen = strlen(text);     /* compute length of text */
            }
            break;
#endif // NOFLOATS

            case 'd':
            case 'i':
                /* signed decimal output */
                flags |= FL_SIGNED;
                radix = 10;
                goto COMMON_INT;

            case 'u':
                radix = 10;
                goto COMMON_INT;

            case 'p':
                /* write a pointer */
                /* this is like an integer or long for Win32, __int64 for Win64 */
                /* except we force precision to pad with zeros and */
                /* output in big hex. */

                precision = 2 * sizeof(void *);     /* number of hex digits needed */
#if !PTR_IS_INT
                flags |= FL_PTR;       /* assume we're converting a long in the Win32 case */
#endif
                /* DROP THROUGH to hex formatting */

            case 'C':
            case 'X':
                /* unsigned upper hex output */
                hexadd = 'A' - '9' - 1;     /* set hexadd for uppercase hex */
                goto COMMON_HEX;

            case 'x':
                /* unsigned lower hex output */
                hexadd = 'a' - '9' - 1;     /* set hexadd for lowercase hex */
                /* DROP THROUGH TO COMMON_HEX */

            COMMON_HEX:
                radix = 16;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means '0x' prefix */
                    prefix[0] = '0';
                    prefix[1] = (char)('x' - 'a' + '9' + 1 + hexadd);   /* 'x' or 'X' */
                    prefixlen = 2;
                }
                goto COMMON_INT;

            case 'o':
                /* unsigned octal output */
                radix = 8;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means force a leading 0 */
                    flags |= FL_FORCEOCTAL;
                }
                /* DROP THROUGH to COMMON_INT */

            COMMON_INT: {
                /* This is the general integer formatting routine. */
                /* Basically, we get an argument, make it positive */
                /* if necessary, and convert it according to the */
                /* correct radix, setting text and textlen */
                /* appropriately. */

                ULONG_PTR number;   /* number to convert */
                int digit;          /* ascii value of digit */
                LONG_PTR l;         /* temp long value */

                /* 1. read argument into l, sign extend as needed */

#if !LONG_IS_INT
                if (flags & FL_LONG)
                    l = get_long_arg(&argptr);
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT) {
                    if (flags & FL_SIGNED)
                        l = (short) get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned short) get_int_arg(&argptr);    /* zero-extend*/
                }
                else
#endif

#ifdef _WIN64
// Sundown: if get_int64_arg() could be defined all the time, 
//          this 'ifdef _WIN64' could be removed.

                if (flags & FL_PTR64) {
                   l = get_int64_arg(&argptr); 
                }
                else 
#endif // _WIN64

                {
                    if (flags & FL_SIGNED)
                        l = get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned int) get_int_arg(&argptr);    /* zero-extend*/
                }

                /* 2. check for negative; copy into number */
                if ( (flags & FL_SIGNED) && l < 0) {
                    number = -l;
                    flags |= FL_NEGATIVE;   /* remember negative sign */
                }
                else {
                    number = l;
                }

                /* 3. check precision value for default; non-default */
                /*    turns off 0 flag, according to ANSI. */
                if (precision < 0)
                    precision = 1;              /* default precision */
                else
                    flags &= ~FL_LEADZERO;

                /* 4. Check if data is 0; if so, turn off hex prefix */
                if (number == 0)
                    prefixlen = 0;

                /* 5. Convert data to ASCII -- note if precision is zero */
                /*    and number is zero, we get no digits at all.       */

                text = &buffer[BUFFERSIZE-1];   // last digit at end of buffer
                flags &= ~FL_WIDE;              // 8 bit characters

                while (precision-- > 0 || number != 0) {
                    digit = (int)(number % radix) + '0';
                    number /= radix;            /* reduce number */
                    if (digit > '9') {
                        /* a hex digit, make it a letter */
                        digit += hexadd;
                    }
                    *text-- = (char)digit;      /* store the digit */
                }

                textlen = (int) (&buffer[BUFFERSIZE-1] - text); /* compute length of number */
                ++text;         /* text points to first digit now */


                /* 6. Force a leading zero if FORCEOCTAL flag set */
                if ((flags & FL_FORCEOCTAL) && (text[0] != '0' || textlen == 0)) {
                    *--text = '0';
                    ++textlen;          /* add a zero */
                }
            }
            break;
            }

            /* At this point, we have done the specific conversion, and */
            /* 'text' points to text to print; 'textlen' is length.  Now we */
            /* justify it, put on prefixes, leading zeros, and then */
            /* print it. */

            if (!no_output) {
                int padding;    /* amount of padding, negative means zero */

                if (flags & FL_SIGNED) {
                    if (flags & FL_NEGATIVE) {
                        /* prefix is a '-' */
                        prefix[0] = '-';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGN) {
                        /* prefix is '+' */
                        prefix[0] = '+';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGNSP) {
                        /* prefix is ' ' */
                        prefix[0] = ' ';
                        prefixlen = 1;
                    }
                }

                /* calculate amount of padding -- might be negative, */
                /* but this will just mean zero */
                padding = fldwidth - textlen - prefixlen;

                /* put out the padding, prefix, and text, in the correct order */

                if (!(flags & (FL_LEFT | FL_LEADZERO))) {
                    /* pad on left with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* write prefix */
                writestring(prefix, prefixlen, f, &charsout, 0);

                if ((flags & FL_LEADZERO) && !(flags & FL_LEFT)) {
                    /* write leading zeros */
                    f->writechar('0', padding, f, &charsout);
                }

                /* write text */
                writestring(text, textlen, f, &charsout, flags & FL_WIDE);

                if (flags & FL_LEFT) {
                    /* pad on right with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* we're done! */
            }
            break;
        }
    }

    return charsout;        /* return value = number of characters written */
}


/***
*int get_int_arg(va_list pargptr)
*
*Purpose:
*   Gets an int argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the integer argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(int) get_int_arg(va_list *pargptr)
{
    return va_arg(*pargptr, int);
}

/***
*long get_long_arg(va_list pargptr)
*
*Purpose:
*   Gets an long argument off the given argument list and updates pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the long argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/


#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr)
{
    return va_arg(*pargptr, long);
}
#endif

#ifdef _WIN64
LOCAL(__int64) get_int64_arg (
    va_list *pargptr
    )
{
    return va_arg(*pargptr, __int64);
}
#endif

/***
*void writestring(char *string, int len, struct w4io *f, int *pcchwritten, int fwide)
*
*Purpose:
*   Writes a string of the given length to the given file.  If no error occurs,
*   then *pcchwritten is incremented by len; otherwise, *pcchwritten is set
*   to -1.  If len is negative, it is treated as zero.
*
*Entry:
*   char *string     - string to write (NOT null-terminated)
*   int len          - length of string
*   struct w4io *f   - file to write to
*   int *pcchwritten - pointer to integer to update with total chars written
*   int fwide        - wide character flag
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(void) writestring(
        char *string,
        int len,
        struct w4io *f,
        int *pcchwritten,
        int fwide)
{
    wchar_t *pwc;

    //printf("string: str=%.*s, len=%d, cch=%d, f=%d\n", len, string, len, *pcchwritten, fwide);
    if (fwide) {
        pwc = (wchar_t *) string;
        while (len-- > 0) {
            if (*pwc & 0xff00) {
                f->writechar('^', 1, f, pcchwritten);
            }
            f->writechar((char) *pwc++, 1, f, pcchwritten);
        }
    } else {
        while (len-- > 0) {
            f->writechar(*string++, 1, f, pcchwritten);
        }
    }
}


const wchar_t a_wcDigits[] = L"0123456789ABCDEF";

//+---------------------------------------------------------------------------
//
//  Function:   FormatHexNum
//
//  Synopsis:   Given a value, and a count of characters, translate
//		the value into a hex string. This is the ANSI version
//
//  Arguments:  [ulValue] -- Value to convert
//		[chChars] -- Number of characters to format
//		[pchStr] -- Pointer to output buffer
//
//  Requires:   pwcStr must be valid for chChars
//
//  History:    5-31-95   t-stevan  Copied and Modified for use in debug output function
//
//  Notes:
//
//----------------------------------------------------------------------------
void FormatHexNum( unsigned long ulValue, unsigned long chChars, char *pchStr)
{
	while(chChars--)
	{
		pchStr[chChars] = (char) a_wcDigits[ulValue & 0xF];
		ulValue = ulValue >> 4;
	}
}

//+-------------------------------------------------------------------------
//
//  Function:   StrFromGUID     (private)
//
//  Synopsis:   Converts a GUID into a string (duh!)
//
//  Arguments:  [rguid] - the guid to convert
//              [lpszy] - buffer to hold the results
//              [cbMax] - sizeof the buffer
//
//  Returns:    amount of data copied to lpsz if successful
//              0 if buffer too small.
//
//--------------------------------------------------------------------------

int StrFromGUID(REFGUID rguid, char * lpsz, int cbMax)  // internal
{
    if (cbMax < GUIDSTR_MAX)
	return 0;


//   Make the GUID into"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",

    *lpsz++ = '{';
    FormatHexNum( rguid->Data1, 8 , lpsz);
    lpsz += 8;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data2, 4 , lpsz);
    lpsz += 4;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data3, 4 , lpsz);
    lpsz += 4;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data4[0], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[1], 2 , lpsz);
    lpsz += 2;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data4[2], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[3], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[4], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[5], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[6], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[7], 2 , lpsz);
    lpsz += 2;

    *lpsz++ = '}';
    /* We don't want to tag on a NULL char because we don't need to print one out *\
    /* *lpsz = 0; */


    return GUIDSTR_MAX;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\dprintf.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       dprintf.h
//
//  Contents:   Debugging output routine function prototypes
//
//  Functions:  w4printf
//              w4vprintf
//              w4dprintf
//              w4vdprintf
//              
//  History:    18-Oct-91   vich        Created
//      
//----------------------------------------------------------------------------

#include <stdarg.h>
#ifdef unix
#include <windows.h>
#endif /* unix */
#ifdef __cplusplus
extern "C" {
#endif

#ifdef WIN32
int _cdecl w4printf(const char *format, ...);
int _cdecl w4vprintf(const char *format, va_list arglist);
#endif

int _cdecl w4dprintf(const char *format, ...);
int _cdecl w4vdprintf(const char *format, va_list arglist);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\printf.c ===
/***
*printf.c - print formatted to stdout
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4printf() - print formatted data to stdout
*	defines w4vprintf() - print formatted output to stdout, get data
*			      from an argument ptr instead of explicit args.
*******************************************************************************/

#ifdef FLAT
#include "dprintf.h"		// function prototypes

#define _W4PRINTF_
#include "printf.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\proto.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	proto.h
//
//  Contents:	File used to spoof idl generated h files. Used by NT1x and
//		Chicago builds.
//
//  History:	10-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------

#include    <ole2.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\stdafx.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\inetdbg.cxx ===
/*++

Module Name:

    inetdbg.cxx

Abstract:

    Debugging functions for internet DLL

Author:

    Venkatraman Kudallur (venkatk)
    ( Ripped off from wininet )
    
Revision History:

    3-10-2000 venkatk
    Created
--*/

// !!!!!!!!!!!!!!!!!!!!!!!!!!!
/* Exchanging the order of these 2 gives following error:
    Linking Executable - dll\daytona\objd\i386\urlmon.dll for i386
dll\daytona\utils.lib(inetdbg.obj) : error LNK2001: unresolved external 
symbol "
int __cdecl _sprintf(char *,char *,char *)" (?_sprintf@@YAHPAD00@Z)
dll\daytona\objd\i386\urlmon.dll() : error LNK1120: 1 unresolved externals
dll\daytona\binplace() : error BNP0000: Unable to place file objd\i386\urlmon.
dll - exiting.
 */
 // !!!!!!!!!!!!!!!!!!!!!!!!!! Why?

#include <urlint.h>
#include "rprintf.h"
#include "registry.h"
#include "tls.h"
#include <imagehlp.h>
#include <wininet.h>  //only for InternetVersionInfo!
#include <ieverp.h>  //for version strings
 
#ifdef ENABLE_DEBUG

//from macros.h
#define PRIVATE
#define PUBLIC

//from util.cxx

DWORD
GetTickCountWrap()
{
#ifdef DEBUG_GETTICKCOUNT
    static BOOL fInit = FALSE;
    static DWORD dwDelta = 0;
    static DWORD dwBasis = 0;

    if (!fInit)
    {
        HKEY clientKey;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"),
                                 0, // reserved
                                 KEY_QUERY_VALUE,
                                 &clientKey))
        {
            DWORD dwSize = sizeof(dwDelta);
            RegQueryValueEx(clientKey, "RollOverDelta", NULL, NULL, (LPBYTE)&dwDelta, &dwSize);
        }
        dwBasis = GetTickCount();
        fInit = TRUE;
    }
    DWORD dwResult = GetTickCount() - dwBasis + dwDelta;
    return dwResult;
#else
    return GetTickCount();
#endif
}


//forward declaration
BOOL
InternetDebugGetLocalTime(
    OUT SYSTEMTIME * pstLocalTime,
    OUT DWORD      * pdwMicroSec
);

//from debugmem.h
#if defined(USE_DEBUG_MEMORY)
    //no debugmem capabilities yet.
    #define ALLOCATOR(Flags, Size) \
        LocalAlloc(Flags, Size)
    #define DEALLOCATOR(hLocal) \
        LocalFree(hLocal)
#else //Retail
    #if USE_PRIVATE_HEAP_IN_RETAIL
        #error no other memory allocation schemes defined
    #else
        #ifndef WININET_UNIX_PRVATE_ALLOCATOR
            #define ALLOCATOR(Flags, Size) \
                LocalAlloc(Flags, Size)
            #define DEALLOCATOR(hLocal) \
                LocalFree(hLocal)
        #else
            HLOCAL IEUnixLocalAlloc(UINT wFlags, UINT wBytes);
            HLOCAL IEUnixLocalFree(HLOCAL hMem);

            #define ALLOCATOR(Flags, Size)\
                IEUnixLocalAlloc(Flags, Size)
            #define DEALLOCATOR(hLocal)\
                IEUnixLocalFree(hLocal)
        #endif //WININET_UNIX_PRVATE_ALLOCATOR
    #endif //USE_PRIVATE_HEAP_IN_RETAIL
#endif //defined(USE_DEBUG_MEMORY)

//from debugmem.h
#define ALLOCATE_ZERO_MEMORY(Size) \
    ALLOCATE_MEMORY(LPTR, (Size))
#define ALLOCATE_MEMORY(Flags, Size) \
    ALLOCATOR((UINT)(Flags), (UINT)(Size))
#define FREE_MEMORY(hLocal) \
    DEALLOCATOR((HLOCAL)(hLocal))

//from macros.h
#define NEW(object) \
    (object FAR *)ALLOCATE_ZERO_MEMORY(sizeof(object))
#define DEL(object) \
    FREE_MEMORY(object)

//from Nttypes.h
#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )

#define INTERNET_SETTINGS_KEY       "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"

//from globals.cxx
#if !defined(VER_PRODUCTBUILD)
#define VER_PRODUCTBUILD    0
#endif

PRIVATE DWORD InternetBuildNumber = VER_PRODUCTBUILD;

#if !defined(VER_PRODUCTVERSION_STRING)
#define VER_PRODUCTVERSION_STRING  " "
#endif

#if !defined(URLMON_MAJOR_VERSION)
#define URLMON_MAJOR_VERSION   1
#endif

#if !defined(URLMON_MINOR_VERSION)
#define URLMON_MINOR_VERSION   2
#endif

PRIVATE INTERNET_VERSION_INFO InternetVersionInfo = {
    URLMON_MAJOR_VERSION,
    URLMON_MINOR_VERSION
};

#if 0
#endif //0

//
// private manifests
//
#define SWITCH_VARIABLE_NAME        "UrlmonDebugging"
#define CONTROL_VARIABLE_NAME       "UrlmonControl"
#define CATEGORY_VARIABLE_NAME      "UrlmonCategory"
#define ERROR_VARIABLE_NAME         "UrlmonError"
#define BREAK_VARIABLE_NAME         "UrlmonBreak"
#define DEFAULT_LOG_VARIABLE_NAME   "UrlmonLog"
#define CHECK_LIST_VARIABLE_NAME    "UrlmonCheckSerializedList"
#define LOG_FILE_VARIABLE_NAME      "UrlmonLogFile"
#define INDENT_VARIABLE_NAME        "UrlmonLogIndent"
#define NO_PID_IN_LOG_FILENAME      "UrlmonNoPidInLogFilename"
#define NO_EXCEPTION_HANDLER        "UrlmonNoExceptionHandler"

#define DEFAULT_LOG_FILE_NAME       "URLMON.LOG"

#define ENVIRONMENT_VARIABLE_BUFFER_LENGTH  80

#define PRINTF_STACK_BUFFER_LENGTH  4096

//
// private macros
//

#define CASE_OF(constant)   case constant: return # constant

//
// private prototypes
//

PRIVATE
VOID
InternetDebugPrintString(
    IN LPSTR String
    );

PRIVATE
VOID
InternetGetDebugVariableString(
    IN LPSTR lpszVariableName,
    OUT LPSTR lpszVariable,
    IN DWORD dwVariableLen
    );

PRIVATE
LPSTR
ExtractFileName(
    IN LPSTR Module,
    OUT LPSTR Buf
    );

PRIVATE
LPSTR
SetDebugPrefix(
    IN LPSTR Buffer
    );

//
//
// these variables are employed in macros, so must be public
//

PUBLIC DWORD InternetDebugErrorLevel = DBG_ERROR;
PUBLIC DWORD InternetDebugControlFlags = DBG_NO_DEBUG;
PUBLIC DWORD InternetDebugCategoryFlags = 0;
PUBLIC DWORD InternetDebugBreakFlags = 0;

//
// these variables are only accessed in this module, so can be private
//

PRIVATE int InternetDebugIndentIncrement = 2;
PRIVATE HANDLE InternetDebugFileHandle = INVALID_HANDLE_VALUE;
PRIVATE char InternetDebugFilename[MAX_PATH + 1] = DEFAULT_LOG_FILE_NAME;
PRIVATE BOOL InternetDebugEnabled = TRUE;
PRIVATE DWORD InternetDebugStartTime = 0;

extern "C" {
#if defined(UNIX) && defined(ux10)
/* Temporary fix for Apogee Compiler bug on HP only */
extern BOOL fCheckEntryOnList;
#else
BOOL fCheckEntryOnList;
#endif /* UNIX */
}

//
// high frequency performance counter globals
//

PRIVATE LONGLONG ftInit;  // initial local time
PRIVATE LONGLONG pcInit;  // initial perf counter
PRIVATE LONGLONG pcFreq;  // perf counter frequency

//
// functions
//


VOID
InternetDebugInitialize(
    VOID
    )

/*++

Routine Description:

    reads environment INETDBG flags and opens debug log file if required

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // ensure registry key open
    //

    OpenInternetSettingsKey();

    //
    // record the starting tick count for cumulative deltas
    //

    InternetDebugStartTime = GetTickCountWrap();

    if (QueryPerformanceFrequency ((LARGE_INTEGER *) &pcFreq) && pcFreq) {

        QueryPerformanceCounter ((LARGE_INTEGER *) &pcInit);
        SYSTEMTIME st;
        GetLocalTime (&st);
        SystemTimeToFileTime (&st, (FILETIME *) &ftInit);
    }

    // check see if there are any debug variable overrides in the environment
    // or the registry. If "UrlmonLog=<!0>" is set then we use the flags that
    // are most commonly used to generate URLMON.LOG, with no console or
    // debugger output. We allow the other variables to be overridden
    //

    BOOL defaultDebugVariables = FALSE;

    InternetGetDebugVariable(DEFAULT_LOG_VARIABLE_NAME, (LPDWORD)&defaultDebugVariables);
    if (defaultDebugVariables) {
        InternetDebugEnabled = TRUE;
        InternetDebugControlFlags = INTERNET_DEBUG_CONTROL_DEFAULT;
        InternetDebugCategoryFlags = INTERNET_DEBUG_CATEGORY_DEFAULT;
        InternetDebugErrorLevel = INTERNET_DEBUG_ERROR_LEVEL_DEFAULT;
        InternetDebugBreakFlags = 0;
    }
    InternetGetDebugVariable(SWITCH_VARIABLE_NAME, (LPDWORD)&InternetDebugEnabled);
    InternetGetDebugVariable(CONTROL_VARIABLE_NAME, &InternetDebugControlFlags);
    InternetGetDebugVariable(CATEGORY_VARIABLE_NAME, &InternetDebugCategoryFlags);
    InternetGetDebugVariable(ERROR_VARIABLE_NAME, &InternetDebugErrorLevel);
    InternetGetDebugVariable(BREAK_VARIABLE_NAME, &InternetDebugBreakFlags);
    InternetGetDebugVariable(CHECK_LIST_VARIABLE_NAME, (LPDWORD)&fCheckEntryOnList);
    InternetGetDebugVariable(INDENT_VARIABLE_NAME, (LPDWORD)&InternetDebugIndentIncrement);
    InternetGetDebugVariableString(LOG_FILE_VARIABLE_NAME,
                                   InternetDebugFilename,
                                   sizeof(InternetDebugFilename)
                                   );
                                   
    DWORD InternetNoPidInLogFilename=0;
    InternetGetDebugVariable(NO_PID_IN_LOG_FILENAME, &InternetNoPidInLogFilename);

    if (!InternetNoPidInLogFilename)
    {
        char szFullPathName[MAX_PATH + 1];
        LPSTR szExecutableName;

        if (GetModuleFileName(NULL, szFullPathName, sizeof(szFullPathName))) 
        {
            szExecutableName = strrchr(szFullPathName, '\\');
            if (szExecutableName != NULL)
                ++szExecutableName;
            else
                szExecutableName = szFullPathName;
        } 
        else
            szExecutableName = "";

        DWORD cbFilenameLen = strlen(InternetDebugFilename);
        //                          ".xxxxx.yyy.#########.LOG" 
        DWORD cbProcessInfoLenMax = 1 + strlen(szExecutableName) + 1 + 9 + 1 + 3;

        if (cbProcessInfoLenMax < sizeof(InternetDebugFilename))
            wsprintf(InternetDebugFilename+cbFilenameLen, ".%s.%u.LOG", 
                szExecutableName,
                GetCurrentProcessId());
    };

    if ((InternetDebugIndentIncrement < 0) || (InternetDebugIndentIncrement > 32)) {
        InternetDebugIndentIncrement = 2;
    }

    //
    // quit now if debugging is disabled
    //

    if (!InternetDebugEnabled) {
        InternetDebugControlFlags |= (DBG_NO_DEBUG | DBG_NO_DATA_DUMP);
        return;
    }

    //
    // if we want to write debug output to file, open URLMON.LOG in the current
    // directory. Open it in text mode, for write-only (by this process)
    //

    if (InternetDebugControlFlags & DBG_TO_FILE) {
        if (!InternetReopenDebugFile(InternetDebugFilename)) {
            InternetDebugControlFlags &= ~DBG_TO_FILE;
        }
    }
}


VOID
InternetDebugTerminate(
    VOID
    )

/*++

Routine Description:

    Performs any required debug termination

Arguments:

    None.

Return Value:

    None.

--*/

{
    //moved into this function bcos we don't this only for debugging.
    CloseInternetSettingsKey();
 
    if (InternetDebugControlFlags & DBG_TO_FILE) {
        InternetCloseDebugFile();
    }
    InternetDebugControlFlags = DBG_NO_DEBUG;
}

BOOL
InternetOpenDebugFile(
    VOID
    )

/*++

Routine Description:

    Opens debug filename if not already open. Use InternetDebugFilename

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - file was opened

        FALSE   - file not opened (already open or error)

--*/

{
    if (InternetDebugFileHandle == INVALID_HANDLE_VALUE) {
        InternetDebugFileHandle = CreateFile(
            InternetDebugFilename,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,  // lpSecurityAttributes
            (InternetDebugControlFlags & DBG_APPEND_FILE)
                ? OPEN_ALWAYS
                : CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL
            | FILE_FLAG_SEQUENTIAL_SCAN
            | ((InternetDebugControlFlags & DBG_FLUSH_OUTPUT)
                ? FILE_FLAG_WRITE_THROUGH
                : 0),
            NULL
            );
        return InternetDebugFileHandle != INVALID_HANDLE_VALUE;
    }
    return FALSE;
}


BOOL
InternetReopenDebugFile(
    IN LPSTR Filename
    )

/*++

Routine Description:

    (Re)opens a debug log file. Closes the current one if it is open

Arguments:

    Filename    - new file to open

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        InternetCloseDebugFile();
    }
    if (Filename && *Filename) {
        InternetDebugFileHandle = CreateFile(
            Filename,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,  // lpSecurityAttributes
            (InternetDebugControlFlags & DBG_APPEND_FILE)
                ? OPEN_ALWAYS
                : CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL
            | FILE_FLAG_SEQUENTIAL_SCAN
            | ((InternetDebugControlFlags & DBG_FLUSH_OUTPUT)
                ? FILE_FLAG_WRITE_THROUGH
                : 0),
            NULL
            );

        //
        // put our start info in the log file. Mainly useful when we're
        // appending to the file
        //

        if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {

            SYSTEMTIME currentTime;
            char filespec[MAX_PATH + 1];
            LPSTR filename;

            if (GetModuleFileName(NULL, filespec, sizeof(filespec))) {
                filename = strrchr(filespec, '\\');
                if (filename != NULL) {
                    ++filename;
                } else {
                    filename = filespec;
                }
            } else {
                filename = "";
            }

            InternetDebugGetLocalTime(&currentTime, NULL);

            InternetDebugPrintf("\n"
                                ">>>> Urlmon Version %d.%d Build %s.%d " __DATE__ " " __TIME__ "\n"
                                ">>>> Process %s [%d (%#x)] started at %02d:%02d:%02d.%03d %02d/%02d/%d\n",
                                InternetVersionInfo.dwMajorVersion,
                                InternetVersionInfo.dwMinorVersion,
                                VER_PRODUCTVERSION_STRING,
                                InternetBuildNumber,
                                filename,
                                GetCurrentProcessId(),
                                GetCurrentProcessId(),
                                currentTime.wHour,
                                currentTime.wMinute,
                                currentTime.wSecond,
                                currentTime.wMilliseconds,
                                currentTime.wMonth,
                                currentTime.wDay,
                                currentTime.wYear
                                );

            InternetDebugPrintf(">>>> Command line = %q\n", GetCommandLine());

            InternetDebugPrintf("\n"
                                "     InternetDebugErrorLevel      = %s [%d]\n"
                                "     InternetDebugControlFlags    = %#08x\n"
                                "     InternetDebugCategoryFlags   = %#08x\n"
                                "     InternetDebugBreakFlags      = %#08x\n"
                                "     InternetDebugIndentIncrement = %d\n"
                                "\n",
                                (InternetDebugErrorLevel == DBG_INFO)       ? "Info"
                                : (InternetDebugErrorLevel == DBG_WARNING)  ? "Warning"
                                : (InternetDebugErrorLevel == DBG_ERROR)    ? "Error"
                                : (InternetDebugErrorLevel == DBG_FATAL)    ? "Fatal"
                                : (InternetDebugErrorLevel == DBG_ALWAYS)   ? "Always"
                                : "?",
                                InternetDebugErrorLevel,
                                InternetDebugControlFlags,
                                InternetDebugCategoryFlags,
                                InternetDebugBreakFlags,
                                InternetDebugIndentIncrement
                                );
            return TRUE;
        }
    }
    return FALSE;
}


VOID
InternetCloseDebugFile(
    VOID
    )

/*++

Routine Description:

    Closes the current debug log file

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        if (InternetDebugControlFlags & DBG_FLUSH_OUTPUT) {
            InternetFlushDebugFile();
        }
        CloseHandle(InternetDebugFileHandle);
        InternetDebugFileHandle = INVALID_HANDLE_VALUE;
    }
}


VOID
InternetFlushDebugFile(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        FlushFileBuffers(InternetDebugFileHandle);
    }
}


VOID
InternetDebugSetControlFlags(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Sets debug control flags

Arguments:

    dwFlags - flags to set

Return Value:

    None.

--*/

{
    InternetDebugControlFlags |= dwFlags;
}


VOID
InternetDebugResetControlFlags(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Resets debug control flags

Arguments:

    dwFlags - flags to reset

Return Value:

    None.

--*/

{
    InternetDebugControlFlags &= ~dwFlags;
}


VOID
InternetDebugEnter(
    IN DWORD Category,
    IN DEBUG_FUNCTION_RETURN_TYPE ReturnType,
    IN LPCSTR Function,
    IN LPCSTR ParameterList OPTIONAL,
    IN ...
    )

/*++

Routine Description:

    Creates an INTERNET_DEBUG_RECORD for the current function and adds it to
    the per-thread (debug) call-tree

Arguments:

    Category        - category flags, e.g. DBG_FTP

    ReturnType      - type of data it returns

    Function        - name of the function. Must be global, static string

    ParameterList   - string describing parameters to function, or NULL if none

    ...             - parameters to function

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    HRESULT hr = S_OK;

    CUrlMkTls tls(hr); // hr passed by reference!
    if (FAILED(hr))
        return;

    LPDEBUG_URLMON_FUNC_RECORD pCurrentFunction;
    pCurrentFunction = NEW(DEBUG_URLMON_FUNC_RECORD);

    pCurrentFunction->Stack = tls->Stack;
    pCurrentFunction->Category = Category;
    pCurrentFunction->ReturnType = ReturnType;
    pCurrentFunction->Function = Function;
    pCurrentFunction->LastTime = GetTickCountWrap();
    tls->Stack = pCurrentFunction;
    ++tls->CallDepth;

    //
    // if the function's category (FTP, GOPHER, HTTP) is selected in the
    // category flags, then we dump the function entry information
    //

    if (InternetDebugCategoryFlags & Category) {

        char buf[4096];
        LPSTR bufptr;

        bufptr = buf;
        bufptr += rsprintf(bufptr, "%s(", Function);
        __try
        {
            if (ARGUMENT_PRESENT(ParameterList)) {

                va_list parms;

                va_start(parms, ParameterList);
                bufptr += _sprintf(bufptr, (char*)ParameterList, parms);
                va_end(parms);
            }
            rsprintf(bufptr, ")\n");
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            if (((DWORD(bufptr-buf) < (sizeof("*********Exception occured!!\n")+1)))
                && (bufptr>buf))
                wsprintf(bufptr, "*********Exception occured!!\n");
            else
                wsprintf(buf, "*********Exception occured!!\n");
        }
        InternetDebugPrintString(buf);

        //
        // only increase the indentation if we will display debug information
        // for this category
        //

        tls->IndentIncrement += InternetDebugIndentIncrement;
    }
}


VOID
InternetDebugLeave(
    IN DWORD_PTR Variable,
    IN LPCSTR Filename,
    IN DWORD LineNumber
    )

/*++

Routine Description:

    Destroys the INTERNET_DEBUG_RECORD for the current function and dumps info
    about what the function is returning, if requested to do so

Arguments:

    Variable    - variable containing value being returned by function

    Filename    - name of file where DEBUG_LEAVE() invoked

    LineNumber  - and line number in Filename

Return Value:

    None.

--*/

{
    LPSTR format;
    LPSTR errstr;
    BOOL noVar;
    char formatBuf[128];
    DWORD lastError;
    char hexnumBuf[15];

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    //
    // seems that something in this path can nuke the last error, so we must
    // refresh it
    //

    lastError = GetLastError();

    HRESULT hr = S_OK;

    CUrlMkTls tls(hr); // hr passed by reference!
    if (FAILED(hr))
        return;

    LPDEBUG_URLMON_FUNC_RECORD pCurrentFunction = tls->Stack;

    if (!pCurrentFunction) {
        return;
    }

    //
    // we are about to output a diagnostic message to the debug log, debugger,
    // or console. First check that we are required to display messages at
    // this level. The level for function ENTER and LEAVE is INFO
    //

    {

        //
        // only display the string and reduce the indent if we are requested
        // for information about this category
        //

        errstr = NULL;
        noVar = FALSE;
        if (InternetDebugCategoryFlags & pCurrentFunction->Category) {
            switch (pCurrentFunction->ReturnType) {
            case None:
                format = "%s() returning VOID";
                noVar = TRUE;
                break;

            case Bool:
                Variable = (DWORD_PTR)(Variable ? "TRUE" : "FALSE");

                //
                // *** FALL THROUGH ***
                //

            case String:
                format = "%s() returning %s";
                break;

            case Int:
                format = "%s() returning %d";
                break;

            case Dword:
                format = "%s() returning %u";
                break;

            case Hresult:
                format = "%s() returning %u";
                errstr = InternetMapError((DWORD)Variable);
                if (errstr != NULL) {
                    if (*errstr == '?') {
                        rsprintf(hexnumBuf, "%#x", Variable);
                        errstr = hexnumBuf;
                        format = "%s() returning %u [?] (%s)";
                    } else {
                        format = "%s() returning %u [%s]";
                    }
                }
                break;
            
            case Handle:
            case Pointer:
                if (Variable == 0) {
                    format = "%s() returning NULL";
                    noVar = TRUE;
                } else {
                    if (pCurrentFunction->ReturnType == Handle) {
                        format = "%s() returning handle %#x";
                    } else {
                        format = "%s() returning %#x";
                    }
                }
                break;

            default:

                INET_ASSERT(FALSE);

                break;
            }

            tls->IndentIncrement -= InternetDebugIndentIncrement;
            if (tls->IndentIncrement < 0) {
                tls->IndentIncrement = 0;
            }

            //
            // add line number info, if requested
            //

            strcpy(formatBuf, format);
            if (!(InternetDebugControlFlags & DBG_NO_LINE_NUMBER)) {
                strcat(formatBuf, " (line %d)");
            }
            strcat(formatBuf, "\n");

            //
            // output an empty line if we are required to separate API calls in
            // the log. Only do this if this is an API level function, and it
            // is the top-level function
            //

            if ((InternetDebugControlFlags & DBG_SEPARATE_APIS)
            && (pCurrentFunction->Stack == NULL)) {
                strcat(formatBuf, "\n");
            }

            //
            // dump the line, depending on requirements and number of arguments
            //

            if (noVar) {
                InternetDebugPrint(formatBuf,
                                   pCurrentFunction->Function,
                                   LineNumber
                                   );
            } else if (errstr != NULL) {
                InternetDebugPrint(formatBuf,
                                   pCurrentFunction->Function,
                                   Variable,
                                   errstr,
                                   LineNumber
                                   );
            } else {
                InternetDebugPrint(formatBuf,
                                   pCurrentFunction->Function,
                                   Variable,
                                   LineNumber
                                   );
            }
/*
            //
            // output an empty line if we are required to separate API calls in
            // the log. Only do this if this is an API level function, and it
            // is the top-level function
            //

            if ((InternetDebugControlFlags & DBG_SEPARATE_APIS)
            && (pCurrentFunction->Stack == NULL)) {

                //
                // don't call InternetDebugPrint - we don't need timing, thread,
                // level etc. information just for the separator
                //

                InternetDebugOut("\n", FALSE);
            }
*/
        }
    }

    //
    // regardless of whether we are outputting debug info for this category,
    // remove the debug record and reduce the call-depth
    //

    --tls->CallDepth;
    tls->Stack = pCurrentFunction->Stack;

    DEL(pCurrentFunction);

    //
    // refresh the last error, in case it was nuked
    //

    SetLastError(lastError);
}


VOID
InternetDebugError(
    IN DWORD Error
    )

/*++

Routine Description:

    Used to display that a function is returning an error. We try to display a
    symbolic name for the error too (as when we are returning a DWORD from a
    function, using DEBUG_LEAVE)

    Displays a string of the form:

        Foo() returning error 87 [ERROR_INVALID_PARAMETER]

Arguments:

    Error   - the error code

Return Value:

    None.

--*/

{
    LPSTR errstr;
    DWORD lastError;
    char hexnumBuf[15];

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }
    
    //
    // seems that something in this path can nuke the last error, so we must
    // refresh it
    //

    lastError = GetLastError();
    
    HRESULT hr = S_OK;

    CUrlMkTls tls(hr); // hr passed by reference!
    if (FAILED(hr))
        return;

    LPDEBUG_URLMON_FUNC_RECORD pCurrentFunction = tls->Stack;

    if (pCurrentFunction == NULL) {
        return;
    }

    errstr = InternetMapError(Error);
    if ((errstr == NULL) || (*errstr == '?')) {
        rsprintf(hexnumBuf, "%#x", Error);
        errstr = hexnumBuf;
    }
    InternetDebugPrint("%s() returning %d [%s]\n",
                       pCurrentFunction->Function,
                       Error,
                       errstr
                       );

    //
    // refresh the last error, in case it was nuked
    //

    SetLastError(lastError);
}


VOID
InternetDebugPrint(
    IN LPSTR Format,
    ...
    )

/*++

Routine Description:

    Internet equivalent of printf()

Arguments:

    Format  - printf format string

    ...     - any extra args

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;

    bufptr = SetDebugPrefix(buf);
    if (bufptr == NULL) {
        return;
    }

    //
    // now append the string that the DEBUG_PRINT originally gave us
    //

    va_list list;

    va_start(list, Format);
    _sprintf(bufptr, Format, list);
    va_end(list);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugPrintValist(
    IN LPSTR Format,
    va_list list
    )

/*++

Routine Description:

    Internet equivalent of printf(), but takes valist as the args

Arguments:

    Format  - printf format string

    list    - stack frame of variable arguments

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;

    bufptr = SetDebugPrefix(buf);
    if (bufptr == NULL) {
        return;
    }

    _sprintf(bufptr, Format, list);

    InternetDebugOut(buf, FALSE);
}


PRIVATE
VOID
InternetDebugPrintString(
    IN LPSTR String
    )

/*++

Routine Description:

    Same as InternetDebugPrint(), except we perform no expansion on the string

Arguments:

    String  - already formatted string (may contain %s)

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;

    bufptr = SetDebugPrefix(buf);
    if (bufptr == NULL) {
        return;
    }

    //
    // now append the string that the DEBUG_PRINT originally gave us
    //

    strcpy(bufptr, String);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugPrintf(
    IN LPSTR Format,
    IN ...
    )

/*++

Routine Description:

    Same as InternetDebugPrint(), but we don't access the per-thread info
    (because we may not have any)

Arguments:

    Format  - printf format string

    ...     - any extra args


Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    va_list list;
    char buf[PRINTF_STACK_BUFFER_LENGTH];

    va_start(list, Format);
    _sprintf(buf, Format, list);
    va_end(list);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugOut(
    IN LPSTR Buffer,
    IN BOOL Assert
    )

/*++

Routine Description:

    Writes a string somewhere - to the debug log file, to the console, or via
    the debugger, or any combination

Arguments:

    Buffer  - pointer to formatted buffer to write

    Assert  - TRUE if this function is being called from InternetAssert(), in
              which case we *always* write to the debugger. Of course, there
              may be no debugger attached, in which case no action is taken

Return Value:

    None.

--*/

{
    int buflen;
    DWORD written;

    buflen = strlen(Buffer);
    if ((InternetDebugControlFlags & DBG_TO_FILE)
    && (InternetDebugFileHandle != INVALID_HANDLE_VALUE)) {
        WriteFile(InternetDebugFileHandle, Buffer, buflen, &written, NULL);
        if (InternetDebugControlFlags & DBG_FLUSH_OUTPUT) {
            InternetFlushDebugFile();
        }
    }

    if (InternetDebugControlFlags & DBG_TO_CONSOLE) {
        WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),
                     Buffer,
                     buflen,
                     &written,
                     0
                     );
    }

    if (Assert || (InternetDebugControlFlags & DBG_TO_DEBUGGER)) {
        OutputDebugString(Buffer);
    }
}


VOID
InternetDebugDump(
    IN LPSTR Text,
    IN LPBYTE Address,
    IN DWORD Size
    )

/*++

Routine Description:

    Dumps Size bytes at Address, in the time-honoured debug tradition

Arguments:

    Text    - to display before dumping data

    Address - start of buffer

    Size    - number of bytes

Return Value:

    None.

--*/

{
    //
    // if flags say no data dumps then quit
    //

    if (InternetDebugControlFlags & (DBG_NO_DEBUG | DBG_NO_DATA_DUMP)) {
        return;
    }

    //
    // display the introduction text, if any
    //

    if (Text) {
        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrint(Text);
        } else {
            InternetDebugOut(Text, FALSE);
        }
    }

    char buf[128];

    //
    // display a line telling us how much data there is, if requested to
    //

    if (InternetDebugControlFlags & DBG_DUMP_LENGTH) {
        rsprintf(buf, "%d (%#x) bytes @ %#x\n", Size, Size, Address);
        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrintString(buf);
        } else {
            InternetDebugOut(buf, FALSE);
        }
    }

    //
    // dump out the data, debug style
    //

    while (Size) {

        int len = InternetDebugDumpFormat(Address, Size, sizeof(BYTE), buf);

        //
        // if we are to indent the data to the current level, then display the
        // buffer via InternetDebugPrint() which will apply all the thread id,
        // indentation, and other options selected, else just display the data
        // via InternetDebugOut(), which will simply send it to the output media
        //

        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrintString(buf);
        } else {
            InternetDebugOut(buf, FALSE);
        }

        Address += len;
        Size -= len;
    }
}


DWORD
InternetDebugDumpFormat(
    IN LPBYTE Address,
    IN DWORD Size,
    IN DWORD ElementSize,
    OUT LPSTR Buffer
    )

/*++

Routine Description:

    Formats Size bytes at Address, in the time-honoured debug tradition, for
    data dump purposes

Arguments:

    Address     - start of buffer

    Size        - number of bytes

    ElementSize - size of each word element in bytes

    Buffer      - pointer to output buffer, assumed to be large enough

Return Value:

    DWORD   - number of bytes formatted

--*/

{
    //
    // we (currently) only understand DWORD, WORD and BYTE dumps
    //

    if ((ElementSize != sizeof(DWORD)) && (ElementSize != sizeof(WORD))) {
        ElementSize = sizeof(BYTE);
    }

    static char spaces[] = "                                               ";    // 15 * 3 + 2
    int i, len;

    len = min(Size, 16);
    rsprintf(Buffer, "%08x  ", Address);

    //
    // dump the hex representation of each character or word - up to 16 per line
    //

    DWORD offset = 10;

    for (i = 0; i < len; i += ElementSize) {

        DWORD value;
        LPSTR formatString;

        switch (ElementSize) {
        case 4:
            formatString = "%08x ";
            value = *(LPDWORD)&Address[i];
            break;

        case 2:
            formatString = "%04x ";
            value = *(LPWORD)&Address[i] & 0xffff;
            break;

        default:
            formatString = ((i & 15) == 7) ? "%02.2x-" : "%02.2x ";
            value = Address[i] & 0xff;
            break;
        }
        rsprintf(&Buffer[offset], formatString, value);
        offset += ElementSize * 2 + 1;
    }

    //
    // write as many spaces as required to tab to ASCII field
    //

    memcpy(&Buffer[offset], spaces, (16 - len) * 3 + 2);
    offset += (16 - len) * 3 + 2;

    //
    // dump ASCII representation of each character
    //

    for (i = 0; i < len; ++i) {

        char ch;

        ch = Address[i];
        Buffer[offset + i] =  ((ch < 32) || (ch > 127)) ? '.' : ch;
    }

    Buffer[offset + i++] = '\r';
    Buffer[offset + i++] = '\n';
    Buffer[offset + i] = '\0';

    return len;
}


VOID
InternetAssert(
    IN LPSTR Assertion,
    IN LPSTR FileName,
    IN DWORD LineNumber
    )

/*++

Routine Description:

    displays assertion message at debugger and raised breakpoint exception

Arguments:

    Assertion   - string describing assertion which failed

    FileName    - module where assertion failure occurred

    LineNumber  - at this line number

Return Value:

    None.

--*/

{
    char buffer[512];

    rsprintf(buffer,
             "\n"
             "*** Urlmon Assertion failed: %s\n"
             "*** Source file: %s\n"
             "*** Source line: %d\n"
             "*** Thread %08x\n"
             "\n",
             Assertion,
             FileName,
             LineNumber,
             GetCurrentThreadId()
             );
    InternetDebugOut(buffer, TRUE);

    //
    // break to the debugger, unless it is requested that we don't
    //

    if (!(InternetDebugControlFlags & DBG_NO_ASSERT_BREAK)) {
        DebugBreak();
    }
}


VOID
InternetGetDebugVariable(
    IN LPSTR lpszVariableName,
    OUT LPDWORD lpdwVariable
    )

/*++

Routine Description:

    Get debug variable. First examine environment, then registry

Arguments:

    lpszVariableName    - variable name

    lpdwVariable        - returned variable

Return Value:

    None.

--*/

{
    DWORD len;
    char varbuf[ENVIRONMENT_VARIABLE_BUFFER_LENGTH];

    //
    // get the debug variables first from the environment, then - if not there -
    // from the registry
    //

    len = GetEnvironmentVariable(lpszVariableName, varbuf, sizeof(varbuf));
    if (len && len < sizeof(varbuf)) {
        *lpdwVariable = (DWORD)strtoul(varbuf, NULL, 0);
    } else {
        InternetReadRegistryDword(lpszVariableName, lpdwVariable);
    }
}



PRIVATE
VOID
InternetGetDebugVariableString(
    IN LPSTR lpszVariableName,
    OUT LPSTR lpszVariable,
    IN DWORD dwVariableLen
    )

/*++

Routine Description:

    Get debug variable string. First examine environment, then registry

Arguments:

    lpszVariableName    - variable name

    lpszVariable        - returned string variable

    dwVariableLen       - size of buffer

Return Value:

    None.

--*/

{
    if (GetEnvironmentVariable(lpszVariableName, lpszVariable, dwVariableLen) == 0) {

        char buf[MAX_PATH + 1];
        DWORD len = min(sizeof(buf), dwVariableLen);

        if (InternetReadRegistryString(lpszVariableName, buf, &len) == ERROR_SUCCESS) {
            memcpy(lpszVariable, buf, len + 1);
        }
    }
}

LPSTR
InternetMapError(
    IN DWORD Error
    )

/*++

Routine Description:

    Map error code to string. Try to get all errors that might ever be returned
    by an Internet function

Arguments:

    Error   - code to map

Return Value:

    LPSTR - pointer to symbolic error name

--*/

{
    switch (Error) {

    //
    // WINERROR errors
    //

    CASE_OF(ERROR_SUCCESS);
    CASE_OF(S_FALSE);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    //CASE_OF(WAIT_ABANDONED_0);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);
    //CASE_OF(STILL_ACTIVE);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);

    default:
        return "?";
    }
}

//
// private functions
//


PRIVATE
LPSTR
ExtractFileName(
    IN LPSTR Module,
    OUT LPSTR Buf
    )
{
    LPSTR filename;
    LPSTR extension;
    int   len;

    filename = strrchr(Module, '\\');
    extension = strrchr(Module, '.');
    if (filename) {
        ++filename;
    } else {
        filename = Module;
    }
    if (!extension) {
        extension = filename + strlen(filename);
    }
    len = (int) (extension - filename);
    memcpy(Buf, filename, len);
    Buf[len] = '\0';
    return Buf;
}


PRIVATE
LPSTR
SetDebugPrefix(
    IN LPSTR Buffer
    )
{
    HRESULT hr = S_OK;

    CUrlMkTls tls(hr); // hr passed by reference!
    if (FAILED(hr))
        return NULL;

    LPDEBUG_URLMON_FUNC_RECORD pCurrentFunction = tls->Stack;

    if (!pCurrentFunction) {
        return NULL;
    }

    if (InternetDebugControlFlags & DBG_ENTRY_TIME) {
        if (InternetDebugControlFlags & (DBG_DELTA_TIME | DBG_CUMULATIVE_TIME))
        {

            DWORD ticks;
            DWORD ticksNow;

            ticksNow = GetTickCountWrap();
            ticks = ticksNow -  ((InternetDebugControlFlags & DBG_CUMULATIVE_TIME)
                                    ? InternetDebugStartTime
                                    : pCurrentFunction->LastTime);

            Buffer += rsprintf(Buffer,
                               "% 5d.%3d ",
                               ticks / 1000,
                               ticks % 1000
                               );
            if (InternetDebugControlFlags & DBG_DELTA_TIME) {
                pCurrentFunction->LastTime = ticksNow;
            }
        } else {

            SYSTEMTIME timeNow;

            InternetDebugGetLocalTime(&timeNow, NULL);

            Buffer += rsprintf(Buffer,
                               "%02d:%02d:%02d.%03d ",
                               timeNow.wHour,
                               timeNow.wMinute,
                               timeNow.wSecond,
                               timeNow.wMilliseconds
                               );
        }
    }

/*
    if (InternetDebugControlFlags & DBG_LEVEL_INDICATOR) {
        Buffer += rsprintf(Buffer, );
    }
*/

    if (InternetDebugControlFlags & DBG_THREAD_INFO) {

        //
        // thread id
        //

        Buffer += rsprintf(Buffer, "%08x", tls->ThreadId);

        //
        // INTERNET_THREAD_INFO address
        //

        if (InternetDebugControlFlags & DBG_THREAD_INFO_ADR) {
            Buffer += rsprintf(Buffer, ":%08x", tls);
        }

        *Buffer++ = ' ';
    }

    if (InternetDebugControlFlags & DBG_CALL_DEPTH) {
        Buffer += rsprintf(Buffer, "%03d ", tls->CallDepth);
    }

    for (int i = 0; i < tls->IndentIncrement; ++i) {
        *Buffer++ = ' ';
    }

    //
    // if we are not debugging the category - i.e we got here via a requirement
    // to display an error, or we are in a function that does not have a
    // DEBUG_ENTER - then prefix the string with the current function name
    // (obviously misleading if the function doesn't have a DEBUG_ENTER)
    //

    if (pCurrentFunction != NULL) {
        if (!(pCurrentFunction->Category & InternetDebugCategoryFlags)) {
            Buffer += rsprintf(Buffer, "%s(): ", pCurrentFunction->Function);
        }
    }

    return Buffer;
}

int dprintf(char * format, ...) {

    va_list args;
    char buf[PRINTF_STACK_BUFFER_LENGTH];
    int n;

    va_start(args, format);
    n = _sprintf(buf, format, args);
    va_end(args);
    OutputDebugString(buf);

    return n;
}


LPSTR
SourceFilename(
    LPSTR Filespec
    )
{
    if (!Filespec) {
        return "?";
    }

    LPSTR p;

    if (p = strrchr(Filespec, '\\')) {

        //
        // we want e.g. common\debugmem.cxx, but get
        // common\..\win32\debugmem.cxx. Bah!
        //

        //LPSTR q;
        //
        //if (q = strrchr(p - 1, '\\')) {
        //    p = q;
        //}
    }
    return p ? p + 1 : Filespec;
}


typedef BOOL (* SYMINITIALIZE)(HANDLE, LPSTR, BOOL);
typedef BOOL (* SYMLOADMODULE)(HANDLE, HANDLE, PSTR, PSTR, DWORD, DWORD);
typedef BOOL (* SYMGETSYMFROMADDR)(HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL);
typedef BOOL (* SYMCLEANUP)(HANDLE);

PRIVATE HMODULE hSymLib = NULL;
PRIVATE SYMINITIALIZE pSymInitialize = NULL;
PRIVATE SYMLOADMODULE pSymLoadModule = NULL;
PRIVATE SYMGETSYMFROMADDR pSymGetSymFromAddr = NULL;
PRIVATE SYMCLEANUP pSymCleanup = NULL;


VOID
InitSymLib(
    VOID
    )
{
    if (hSymLib == NULL) {
        hSymLib = LoadLibrary("IMAGEHLP.DLL");
        if (hSymLib != NULL) {
            pSymInitialize = (SYMINITIALIZE)GetProcAddress(hSymLib,
                                                           "SymInitialize"
                                                           );
            pSymLoadModule = (SYMLOADMODULE)GetProcAddress(hSymLib,
                                                           "SymLoadModule"
                                                           );
            pSymGetSymFromAddr = (SYMGETSYMFROMADDR)GetProcAddress(hSymLib,
                                                                   "SymGetSymFromAddr"
                                                                   );
            pSymCleanup = (SYMCLEANUP)GetProcAddress(hSymLib,
                                                     "SymCleanup"
                                                     );
            if (!pSymInitialize
            || !pSymLoadModule
            || !pSymGetSymFromAddr
            || !pSymCleanup) {
                FreeLibrary(hSymLib);
                hSymLib = NULL;
                pSymInitialize = NULL;
                pSymLoadModule = NULL;
                pSymGetSymFromAddr = NULL;
                pSymCleanup = NULL;
                return;
            }
        }
        pSymInitialize(GetCurrentProcess(), NULL, FALSE);
        //SymInitialize(GetCurrentProcess(), NULL, TRUE);
        pSymLoadModule(GetCurrentProcess(), NULL, "URLMON.DLL", "URLMON", 0, 0);
    }
}


VOID
TermSymLib(
    VOID
    )
{
    if (pSymCleanup) {
        pSymCleanup(GetCurrentProcess());
        FreeLibrary(hSymLib);
    }
}


LPSTR
GetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    )
{
    *Offset = Address;
    if (!pSymGetSymFromAddr) {
        return "";
    }

    //
    // BUGBUG - only one caller at a time please
    //

    static char symBuf[512];

    //((PIMAGEHLP_SYMBOL)symBuf)->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
    ((PIMAGEHLP_SYMBOL)symBuf)->SizeOfStruct = sizeof(symBuf);
    ((PIMAGEHLP_SYMBOL)symBuf)->MaxNameLength = sizeof(symBuf) - sizeof(IMAGEHLP_SYMBOL);
    if (!pSymGetSymFromAddr(GetCurrentProcess(),
                            Address,
                            Offset,
                            (PIMAGEHLP_SYMBOL)symBuf)) {
        ((PIMAGEHLP_SYMBOL)symBuf)->Name[0] = '\0';
    }
    return ((PIMAGEHLP_SYMBOL)symBuf)->Name;
}


#if defined(i386)

VOID
x86SleazeCallStack(
    OUT LPVOID * lplpvStack,
    IN DWORD dwStackCount,
    IN LPVOID * Ebp
    )

/*++

Routine Description:

    Similar to x86SleazeCallersAddress but gathers a variable number of return
    addresses. We assume all functions have stack frame

Arguments:

    lplpvStack      - pointer to returned array of caller's addresses

    dwStackCount    - number of elements in lplpvStack

    Ebp             - starting Ebp if not 0, else use current stack

Return Value:

    None.

--*/

{
    DWORD my_esp;

    _asm mov my_esp, esp;

    __try {
        if (Ebp == 0) {
            Ebp = (LPVOID *)(&lplpvStack - 2);
        }
        while (dwStackCount--) {
            if (((DWORD)Ebp > my_esp + 0x10000) || ((DWORD)Ebp < my_esp - 0x10000)) {
                break;
            }
            *lplpvStack++ = *(Ebp + 1);
            Ebp = (LPVOID *)*Ebp;
            if (((DWORD)Ebp <= 0x10000)
            || ((DWORD)Ebp >= 0x80000000)
            || ((DWORD)Ebp & 3)
            || ((DWORD)Ebp > my_esp + 0x10000)
            || ((DWORD)Ebp < my_esp - 0x10000)) {
                break;
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
}


VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    )

/*++

Routine Description:

    This is a sleazy function that reads return addresses out of the stack/
    frame pointer (ebp). We pluck out the return address of the function
    that called THE FUNCTION THAT CALLED THIS FUNCTION, and the caller of
    that function. Returning the return address of the function that called
    this function is not interesting to that caller (almost worthy of Sir
    Humphrey Appleby isn't it?)

    Assumes:

        my ebp  =>  | caller's ebp |
                    | caller's eip |
                    | arg #1       | (pCaller)
                    | arg #2       | (pCallersCaller

Arguments:

    pCaller         - place where we return addres of function that called
                      the function that called this function
    pCallersCaller  - place where we return caller of above

Return Value:

    None.

--*/

{

    //
    // this only works on x86 and only if not fpo functions!
    //

    LPVOID* ebp;

    ebp = (PVOID*)&pCaller - 2; // told you it was sleazy
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCaller = *(ebp + 1);
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCallersCaller = *(ebp + 1);
}

#endif // defined(i386)


BOOL
InternetDebugGetLocalTime(
    OUT SYSTEMTIME * pstLocalTime,
    OUT DWORD      * pdwMicroSec
)
{
#ifndef ENABLE_DEBUG
    // QUICK HACK TO KEEP THINGS CLEAN AND STILL MEASURE WITH HIGH PERFORMANCE
    // COUNTER

    static BOOL pcTested = FALSE;
    static LONGLONG ftInit;  // initial local time
    static LONGLONG pcInit;  // initial perf counter
    static LONGLONG pcFreq;  // perf counter frequency

    if (!pcTested)
    {
        pcTested = TRUE;
        if (QueryPerformanceFrequency ((LARGE_INTEGER *) &pcFreq) && pcFreq)
        {
            QueryPerformanceCounter ((LARGE_INTEGER *) &pcInit);
            SYSTEMTIME st;
            GetLocalTime (&st);
            SystemTimeToFileTime (&st, (FILETIME *) &ftInit);
        }
    }

    if (!pcFreq)
        GetLocalTime (pstLocalTime);
    else
    {
        LONGLONG pcCurrent, ftCurrent;
        QueryPerformanceCounter ((LARGE_INTEGER *) &pcCurrent);
        ftCurrent = ftInit + ((10000000 * (pcCurrent - pcInit)) / pcFreq);
        FileTimeToSystemTime ((FILETIME *) &ftCurrent, pstLocalTime);
    }

    return TRUE;
#else
    if (!pcFreq)
        GetLocalTime (pstLocalTime);
    else
    {
        LONGLONG pcCurrent, ftCurrent;
        QueryPerformanceCounter ((LARGE_INTEGER *) &pcCurrent);
        ftCurrent = ftInit + ((10000000 * (pcCurrent - pcInit)) / pcFreq);
        FileTimeToSystemTime ((FILETIME *) &ftCurrent, pstLocalTime);
    }

    return TRUE;
#endif // ENABLE_DEBUG
}

#endif // ENABLE_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\registry.cxx ===
/*++

Module Name:

    registry.cxx

Abstract:

    Functions to read/write registry parameters

Author:

    Venkatraman Kudallur (venkatk)

Revision History:

    3-10-2000 venkatk
        Created

--*/

#ifdef ENABLE_DEBUG

#include <urlint.h>
#include "registry.h"

//
// manifests
//

#define INTERNET_CLIENT_KEY         "Internet Settings"
#define SYSTEM_INI_FILE_NAME        "SYSTEM.INI"
#define NETWORK_SECTION_NAME        "Network"
#define COMPUTER_NAME_VALUE         "ComputerName"
#define PROFILE_INT_BUFFER_LENGTH   128

#define MIME_TO_FILE_EXTENSION_KEY  "MIME\\Database\\Content Type\\"
#define EXTENSION_VALUE             "Extension"

//
// macros
//

#define INTERNET_SETTINGS_KEY       "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
#define INTERNET_CACHE_SETTINGS_KEY "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0\\Cache"

//from macros.h
#define PRIVATE
#define PUBLIC

#define ARRAY_ELEMENTS(array) \
    (sizeof(array)/sizeof(array[0]))
//from defaults.h
#define DEFAULT_EMAIL_NAME              "user@domain"
//from wininet.w
#define ERROR_INTERNET_BAD_REGISTRY_PARAMETER    12022

PRIVATE
BOOL
IsPlatformWinNT()
{
    OSVERSIONINFO osVersionInfo;
    BOOL fRet = FALSE;
    
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osVersionInfo))
        fRet = (VER_PLATFORM_WIN32_NT == osVersionInfo.dwPlatformId);
    return fRet;
}

//
// private prototypes
//

PRIVATE
DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

PRIVATE
DWORD
InternetReadRegistryStringKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    );

PRIVATE
DWORD
ReadRegistryOemString(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPSTR String,
    IN OUT LPDWORD Length
    );


PRIVATE
DWORD
WriteRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    );
//
// private data
//

PRIVATE HKEY hKeyInternetSettings = NULL;

//
// functions
//


DWORD
OpenInternetSettingsKey(
    VOID
    )

/*++

Routine Description:

    Opens registry key for Internet Settings branch

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    if (hKeyInternetSettings == NULL) {

        DWORD dwDisposition;

        REGCREATEKEYEX(HKEY_CURRENT_USER,
                       INTERNET_SETTINGS_KEY,
                       0,     // reserved
                       NULL,  // class
                       0,     // options
                       KEY_READ | KEY_WRITE,
                       NULL,  // security attributes
                       &hKeyInternetSettings,
                       &dwDisposition
                       );
    }

    return ERROR_SUCCESS;
}


DWORD
CloseInternetSettingsKey(
    VOID
    )

/*++

Routine Description:

    Closes Internet Settings registry key

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DWORD error = ERROR_SUCCESS;

    if (hKeyInternetSettings != NULL) {
        error = REGCLOSEKEY(hKeyInternetSettings);
        hKeyInternetSettings = NULL;
    }

    return error;
}



DWORD
GetMyEmailName(
    OUT LPSTR EmailName,
    IN OUT LPDWORD Length
    )

/*++

Routine Description:

    Retrieve the user's email name from the appropriate place in the registry

Arguments:

    EmailName   - place to store email name

    Length      - IN: length of EmailName
                  OUT: returned length of EmailName (in characters, minus
                       trailing NUL)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_FILE_NOT_FOUND
                  ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "GetMyEmailName",
                 "%#x, %#x [%d]",
                 EmailName,
                 Length,
                 *Length
                 ));

    DWORD error;

    //
    // for the EmailName, we first try HKEY_CURRENT_USER. If that fails then we
    // try the same branch of the HKEY_LOCAL_MACHINE tree. If that fails,
    // invent something
    //

    static HKEY KeysToTry[2] = {HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE};
    int i;

    //
    // in the event we cannot find EmailName in both HKEY_CURRENT_USER and
    // HKEY_LOCAL_MACHINE trees, then we return this default
    //

    static char DefaultEmailName[] = DEFAULT_EMAIL_NAME;

    for (i = 0; i < ARRAY_ELEMENTS(KeysToTry); ++i) {
        error = InternetReadRegistryStringKey(KeysToTry[i],
                                              "EmailName",
                                              EmailName,
                                              Length
                                              );
        if (error == ERROR_SUCCESS) {
            break;
        }
    }
    if (error != ERROR_SUCCESS) {
        if (IsPlatformWinNT()) {

            //
            // only NT supports GetUserName()
            //

            if (GetUserName(EmailName, Length)) {

                //
                // we return the length as if the result from strlen/wcslen
                //

                *Length -= sizeof(char);

                DEBUG_PRINT(REGISTRY,
                            INFO,
                            ("GetUserName() returns %q\n",
                            EmailName
                            ));

                error = ERROR_SUCCESS;
            } else {

                //
                // BUGBUG - what's the required length?
                //

                error = GetLastError();
            }
        } else {

            //
            // Win95 & Win32s: have to do something different
            //

        }

        //
        // if we still don't have an email name, we use an internal default
        //

        if (error != ERROR_SUCCESS) {

            DEBUG_PRINT(REGISTRY,
                        ERROR,
                        ("Cannot find EmailName: using default (%s)\n",
                        DefaultEmailName
                        ));

            if (*Length >= sizeof(DEFAULT_EMAIL_NAME)) {
                memcpy(EmailName, DefaultEmailName, sizeof(DEFAULT_EMAIL_NAME));

                //
                // success - returned length as if from strlen()
                //

                *Length = sizeof(DEFAULT_EMAIL_NAME) - 1;
                error = ERROR_SUCCESS;
            } else {

                //
                // failure - returned length is the required buffer size
                //

                *Length = sizeof(DEFAULT_EMAIL_NAME);
                error = ERROR_INSUFFICIENT_BUFFER;
            }
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


PUBLIC
DWORD
InternetDeleteRegistryValue(
    IN LPSTR ParameterName
    )

/*++

Routine Description:

    Delets an entry from a the Internet Client registry key if the platform
    is NT/Win95.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DWORD error;

    DEBUG_ENTER((DBG_REGISTRY,
                Dword,
                "InternetDeleteRegistryValue",
                "%q",
                ParameterName
                ));


    HKEY clientKey;

    //
    // open the registry key containing the Internet client values (this is
    // in the same place on NT and Win95)
    //

    error = REGOPENKEYEX(HKEY_CURRENT_USER,
                         INTERNET_SETTINGS_KEY,
                         0, // reserved
                         KEY_ALL_ACCESS,
                         &clientKey
                         );


    if (error == ERROR_SUCCESS) {

        error = RegDeleteValue(clientKey,
                               ParameterName
                               );

        REGCLOSEKEY(clientKey);
    }


    DEBUG_LEAVE(error);

    return error;
}




DWORD
InternetReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = InternetReadRegistryDwordKey(HKEY_CURRENT_USER,
                                               ParameterName,
                                               ParameterValue
                                               );

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetCacheReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetCacheReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey;

    error = REGOPENKEYEX(HKEY_CURRENT_USER,
                         INTERNET_CACHE_SETTINGS_KEY,
                         0, // reserved
                         KEY_QUERY_VALUE,
                         &clientKey
                         );

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryDword(clientKey,
                                  ParameterName,
                                  ParameterValue
                                  );
        REGCLOSEKEY(clientKey);
    }

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a single DWORD from to the Internet Client registry key if the platform
    is NT/Win95, otherwise it fails.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - value to store in registry.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetWriteRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;

    if (hKeyInternetSettings != NULL) {
        error = WriteRegistryDword(hKeyInternetSettings,
                                   ParameterName,
                                   ParameterValue
                                   );
    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetWriteRegistryDword(%q): value = %d (%#x)\n",
                ParameterName,
                ParameterValue,
                ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetReadRegistryString(
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    )

/*++

Routine Description:

    Reads a string from the Internet Client registry key on NT/Win95, or reads
    the corresponding value from SYSTEM.INI on a Win32s platform

Arguments:

    ParameterName   - name of value parameter within key (e.g. EmailName)

    ParameterValue  - pointer to string buffer for returned string

    ParameterLength - IN: number of bytes in ParameterValue
                      OUT: number of bytes in string (excluding trailing '\0')

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryString",
                 "%q, %x, %x [%d]",
                 ParameterName,
                 ParameterValue,
                 ParameterLength,
                 *ParameterLength
                 ));

    DWORD error = InternetReadRegistryStringKey(HKEY_CURRENT_USER,
                                                ParameterName,
                                                ParameterValue,
                                                ParameterLength
                                                );

    DEBUG_LEAVE(error);

    return error;
}


PUBLIC
DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s.

    Does not modify the *ParameterValue if the registry variable cannot be read

Arguments:

    ParameterKey    - root registry key (e.g. HKEY_CURRENT_USER)

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryDwordKey",
                 "%s, %q, %x",
                 (ParameterKey == HKEY_LOCAL_MACHINE)
                    ? "HKEY_LOCAL_MACHINE"
                    : (ParameterKey == HKEY_CURRENT_USER)
                        ? "HKEY_CURRENT_USER"
                        : "???",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey = hKeyInternetSettings;

    if (ParameterKey != HKEY_CURRENT_USER) {
        error = REGOPENKEYEX(ParameterKey,
                             INTERNET_SETTINGS_KEY,
                             0, // reserved
                             KEY_QUERY_VALUE,
                             &clientKey
                             );
    } else if (clientKey == NULL) {
        error = ERROR_PATH_NOT_FOUND;
    }

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryDword(clientKey,
                                  ParameterName,
                                  ParameterValue
                                  );
        if (clientKey != hKeyInternetSettings) {
            REGCLOSEKEY(clientKey);
        }
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetReadRegistryDwordKey(%q): value = %d (%#x)\n",
                ParameterName,
                *ParameterValue,
                *ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
InternetReadRegistryStringKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    )

/*++

Routine Description:

    Reads a string from the Internet Client registry key on NT/Win95, or reads
    the corresponding value from SYSTEM.INI on a Win32s platform

Arguments:

    ParameterKey    - root registry key (e.g. HKEY_LOCAL_MACHINE)

    ParameterName   - name of value parameter within key (e.g. EmailName)

    ParameterValue  - pointer to string buffer for returned string

    ParameterLength - IN: number of bytes in ParameterValue
                      OUT: number of bytes in string (excluding trailing '\0')

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryStringKey",
                 "%s (%x), %q, %x, %x [%d]",
                 (ParameterKey == HKEY_LOCAL_MACHINE)
                    ? "HKEY_LOCAL_MACHINE"
                    : (ParameterKey == HKEY_CURRENT_USER)
                        ? "HKEY_CURRENT_USER"
                        : "???",
                 ParameterKey,
                 ParameterName,
                 ParameterValue,
                 ParameterLength,
                 *ParameterLength
                 ));

    //
    // zero-terminate the string
    //

    if (*ParameterLength > 0) {
        *ParameterValue = '\0';
    }

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey = hKeyInternetSettings;

    if (ParameterKey != HKEY_CURRENT_USER) {
        error = REGOPENKEYEX(ParameterKey,
                             INTERNET_SETTINGS_KEY,
                             0, // reserved
                             KEY_QUERY_VALUE,
                             &clientKey
                             );
    } else if (clientKey == NULL) {
        error = ERROR_PATH_NOT_FOUND;
    }

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryOemString(clientKey,
                                      ParameterName,
                                      ParameterValue,
                                      ParameterLength
                                      );
        if (clientKey != hKeyInternetSettings) {
            REGCLOSEKEY(clientKey);
        }
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetReadRegistryStringKey(%q): value = %q\n",
                ParameterName,
                ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
ReadRegistryOemString(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPSTR String,
    IN OUT LPDWORD Length
    )

/*++

Routine Description:

    Reads a string out of the registry as an OEM string

Arguments:

    Key             - open registry key where to read value from

    ParameterName   - name of registry value to read

    String          - place to put it

    Length          - IN: length of String buffer in characters
                      OUT: length of String in characters, as if returned from
                      strlen()

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_FILE_NOT_FOUND
                    Couldn't find the parameter

                  ERROR_PATH_NOT_FOUND
                    Couldn't find the parameter

                  ERROR_INTERNET_BAD_REGISTRY_PARAMETER
                    Inconsistent registry contents

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "ReadRegistryOemString",
                 "%#x, %q, %#x, %#x [%d]",
                 Key,
                 ParameterName,
                 String,
                 Length,
                 *Length
                 ));

    LONG error;
    DWORD valueType;
    LPSTR str;
    DWORD valueLength;

    //
    // first, get the length of the string
    //

    valueLength = *Length;
    error = RegQueryValueEx(Key,
                            ParameterName,
                            NULL, // reserved
                            &valueType,
                            (LPBYTE)String,
                            &valueLength
                            );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // we only support REG_SZ (single string) values in this function
    //

    if (valueType != REG_SZ) {
        error = ERROR_INTERNET_BAD_REGISTRY_PARAMETER;
        goto quit;
    }

    //
    // if 1 or 0 chars returned then the string is empty
    //

    if (valueLength <= sizeof(char)) {
        error = ERROR_PATH_NOT_FOUND;
        goto quit;
    }

    //
    // convert the ANSI string to OEM character set in place. According to Win
    // help, this always succeeds
    //

    CharToOem(String, String);

    //
    // return the length as if returned from strlen() (i.e. drop the '\0')
    //

    *Length = valueLength - sizeof(char);

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("ReadRegistryOemString(%q) returning %q (%d chars)\n",
                ParameterName,
                String,
                *Length
                ));

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ReadRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a DWORD parameter from the registry

    Won't modify *ParameterValue unless a valid value is read from the registry

Arguments:

    Key             - handle of open registry key where parameter resides

    ParameterName   - name of DWORD parameter to read

    ParameterValue  - returned DWORD parameter read from registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                    One of the following occurred:
                        - the parameter is not in the specified registry key
                        - the parameter is the wrong type
                        - the parameter is the wrong size

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "ReadRegistryDword",
                 "%x, %q, %x",
                 Key,
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;
    DWORD valueLength;
    DWORD valueType;
    DWORD value;

    valueLength = sizeof(*ParameterValue);
    error = (DWORD)RegQueryValueEx(Key,
                                   ParameterName,
                                   NULL, // reserved
                                   &valueType,
                                   (LPBYTE)&value,
                                   &valueLength
                                   );

    //
    // if the size or type aren't correct then return an error, else only if
    // success was returned do we modify *ParameterValue
    //

    if (error == ERROR_SUCCESS) {
        if (((valueType != REG_DWORD)
        && (valueType != REG_BINARY))
        || (valueLength != sizeof(DWORD))) {

            DEBUG_PRINT(REGISTRY,
                        ERROR,
                        ("valueType = %d, valueLength = %d\n",
                        valueType,
                        valueLength
                        ));

            error = ERROR_PATH_NOT_FOUND;
        } else {
            *ParameterValue = value;
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
WriteRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a DWORD parameter from the registry

    Will write ParameterValue to the key.

Arguments:

    Key             - handle of open registry key where parameter resides

    ParameterName   - name of DWORD parameter to write

    ParameterValue  - DWORD parameter to write from registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                    One of the following occurred:
                        - the parameter is not in the specified registry key
                        - the parameter is the wrong type
                        - the parameter is the wrong size

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "WriteRegistryDword",
                 "%x, %q, %x",
                 Key,
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;
    DWORD valueLength;
    DWORD valueType;
    DWORD value;

    valueLength = sizeof(ParameterValue);
    valueType   = REG_DWORD;
    value       = ParameterValue;

    error = (DWORD)RegSetValueEx(Key,
                                 ParameterName,
                                 NULL, // reserved
                                 valueType,
                                 (LPBYTE)&value,
                                 valueLength
                                 );

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("added: valueType = %d, valueLength = %d\n",
                valueType,
                valueLength
                ));

    DEBUG_LEAVE(error);

    return error;
}

#if INET_DEBUG

typedef struct {
    LIST_ENTRY entry;
    HKEY hkey;
    char * file;
    int line;
    char name[1];
} DBGREGKEYINFO;

#if 0
SERIALIZED_LIST DbgRegKeyList;
#endif

VOID DbgRegKey_Init(VOID) {
 #if 0
    InitializeSerializedList(&DbgRegKeyList);
 #endif
}

VOID DbgRegKey_Terminate(VOID) {
 #if 0
    TerminateSerializedList(&DbgRegKeyList);
 #endif
}

void regkey_add(const char * name, HKEY hkey, char * file, int line) {
 #if 0
    if (!name) {
        name = "";
    }

    int len = lstrlen(name);
    DBGREGKEYINFO * p = (DBGREGKEYINFO *)ALLOCATE_FIXED_MEMORY(sizeof(DBGREGKEYINFO) + len);

    if (p) {
        memcpy(p->name, name, len + 1);
        p->line = line;
        p->file = file;
        p->hkey = hkey;
        InsertAtHeadOfSerializedList(&DbgRegKeyList, &p->entry);
    }
 #endif
}

void regkey_remove(HKEY hkey) {
 #if 0
    LockSerializedList(&DbgRegKeyList);

    DBGREGKEYINFO * p = (DBGREGKEYINFO *)HeadOfSerializedList(&DbgRegKeyList);
    while (p != (DBGREGKEYINFO *)SlSelf(&DbgRegKeyList)) {
        if (p->hkey == hkey) {
            RemoveFromSerializedList(&DbgRegKeyList, (PLIST_ENTRY)p);
            FREE_MEMORY(p);
            break;
        }
        p = (DBGREGKEYINFO *)p->entry.Flink;
    }
    UnlockSerializedList(&DbgRegKeyList);
 #endif
}

#undef NEW_STRING
#define NEW_STRING(str) (str)
char * regkey_name(HKEY hkey, const char * subname) {
    switch ((INT_PTR)hkey) {
    case (INT_PTR)HKEY_CLASSES_ROOT:
        return NEW_STRING("HKEY_CLASSES_ROOT");

    case (INT_PTR)HKEY_CURRENT_USER:
        return NEW_STRING("HKEY_CURRENT_USER");

    case (INT_PTR)HKEY_LOCAL_MACHINE:
        return NEW_STRING("HKEY_LOCAL_MACHINE");

    case (INT_PTR)HKEY_USERS:
        return NEW_STRING("HKEY_USERS");

    case (INT_PTR)HKEY_PERFORMANCE_DATA:
        return NEW_STRING("HKEY_PERFORMANCE_DATA");

    case (INT_PTR)HKEY_CURRENT_CONFIG:
        return NEW_STRING("HKEY_CURRENT_CONFIG");

    case (INT_PTR)HKEY_DYN_DATA:
        return NEW_STRING("HKEY_DYN_DATA");
    }

    char * name = NULL;
  #if 0
    LockSerializedList(&DbgRegKeyList);

    DBGREGKEYINFO * p = (DBGREGKEYINFO *)HeadOfSerializedList(&DbgRegKeyList);

    while (p != (DBGREGKEYINFO *)SlSelf(&DbgRegKeyList)) {
        if (p->hkey == hkey) {

            int len = lstrlen(p->name);
            int slen = lstrlen(subname);

            name = (char *)ALLOCATE_FIXED_MEMORY(len + 1 + slen + 1);
            if (name) {
                memcpy(name, p->name, len);
                name[len] = '\\';
                memcpy(name + len + 1, subname, slen + 1);
            }
            break;
        }
        p = (DBGREGKEYINFO *)p->entry.Flink;
    }
    UnlockSerializedList(&DbgRegKeyList);
  #endif
    return name;
}

void regkey_freename(char * name) {
 #if 0
    if (name) {
        FREE_MEMORY(name);
    }
 #endif
}

LONG
DbgRegOpenKey(
    IN HKEY hKey,
    IN LPCTSTR lpszSubKey,
    OUT PHKEY phkResult,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpszSubKey);
    LONG rc = RegOpenKey(hKey, lpszSubKey, phkResult);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegOpenKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpSubKey);
    LONG rc = RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegCreateKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD Reserved,
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpSubKey);
    LONG rc = RegCreateKeyEx(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegCloseKey(
    IN HKEY hKey
    )
{
    LONG rc = RegCloseKey(hKey);

    if (rc == 0) {
        regkey_remove(hKey);
    }
    return rc;
}

#endif // INET_DEBUG
#endif // ENABLE_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\registry.h ===
/*++

Module Name:

    registry.h

Abstract:

    Prototypes, etc., for registry.c

Author:

    Venkatraman Kudallur (venkatk)
    ( Ripped off from wininet )
    
Revision History:

    3-10-2000 venkatk
        Created

--*/

#ifndef _REGISTRY_H_
#define _REGISTRY_H_ 1

#if defined(__cplusplus)
extern "C" {
#endif

#ifdef ENABLE_DEBUG

#define INTERNET_POLICY_KEY         "SOFTWARE\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"

//
// prototypes
//

DWORD
OpenInternetSettingsKey(
    VOID
    );

DWORD
CloseInternetSettingsKey(
    VOID
    );

DWORD
GetMyEmailName(
    OUT LPSTR EmailName,
    IN OUT LPDWORD Length
    );

DWORD
GetMyDomainName(
    OUT LPSTR DomainName,
    IN OUT LPDWORD Length
    );

BOOL
GetFileExtensionFromMimeType(
    IN LPCSTR  lpszMimeType,
    IN DWORD   dwMimeLen,
    IN LPSTR   lpszFileExtension,
    IN OUT LPDWORD lpdwLen
    );

DWORD
InternetDeleteRegistryValue(
    IN LPSTR ParameterName
    );

DWORD
InternetReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );


DWORD
InternetCacheReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

DWORD
InternetWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    );

DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

DWORD
InternetReadRegistryString(
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    );

DWORD
ReadRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );


DWORD
InternetWriteRegistryString(
    IN LPCSTR ParameterName,
    IN LPSTR ParameterValue
    );

DWORD
CreateMimeExclusionTableForCache(VOID);

DWORD
CreateHeaderExclusionTableForCache(VOID);

VOID
DestroyMimeExclusionTableForCache(VOID);

VOID
DestroyHeaderExclusionTableForCache(VOID);

#endif //ENABLE_DEBUG

#if INET_DEBUG

VOID
DbgRegKey_Init(
    VOID
    );

VOID
DbgRegKey_Terminate(
    VOID
    );

LONG
DbgRegOpenKey(
    IN HKEY hKey,
    IN LPCTSTR lpszSubKey,
    OUT PHKEY phkResult,
    char * file,
    int line
    );

LONG
DbgRegOpenKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult,
    char * file,
    int line
    );

LONG
DbgRegCreateKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD Reserved,
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition,
    char * file,
    int line
    );

LONG
DbgRegCloseKey(
    IN HKEY hKey
    );

#define INITIALIZE_DEBUG_REGKEY() \
    DbgRegKey_Init()

#define TERMINATE_DEBUG_REGKEY() \
    DbgRegKey_Terminate()

#define REGOPENKEY(a, b, c) \
    DbgRegOpenKey((a), (b), (c), __FILE__, __LINE__)

#define REGOPENKEYEX(a, b, c, d, e) \
    DbgRegOpenKeyEx((a), (b), (c), (d), (e), __FILE__, __LINE__)

#define REGCREATEKEYEX(a, b, c, d, e, f, g, h, i) \
    DbgRegCreateKeyEx((a), (b), (c), (d), (e), (f), (g), (h), (i), __FILE__, __LINE__)

#define REGCLOSEKEY(a) \
    DbgRegCloseKey(a)

#else

#define INITIALIZE_DEBUG_REGKEY() \
    /* NOTHING */

#define TERMINATE_DEBUG_REGKEY() \
    /* NOTHING */

#define REGOPENKEY(a, b, c) \
    RegOpenKey((a), (b), (c))

#define REGOPENKEYEX(a, b, c, d, e) \
    RegOpenKeyEx((a), (b), (c), (d), (e))

#define REGCREATEKEYEX(a, b, c, d, e, f, g, h, i) \
    RegCreateKeyEx((a), (b), (c), (d), (e), (f), (g), (h), (i))

#define REGCLOSEKEY(a) \
    RegCloseKey(a)

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif

#endif // _REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\printf.h ===
/***
*printf.h - print formatted
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines w4*printf() - print formatted data
*       defines w4v*printf() - print formatted output, get data from an
*                              argument ptr instead of explicit args.
*
*Revision History:
*       09-02-83  RN    original sprintf
*       06-17-85  TC    rewrote to use new varargs macros, and to be vsprintf
*       04-13-87  JCR   added const to declaration
*       11-07-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-13-88  JCR   Fake _iob entry is now static so that other routines
*                       can assume _iob entries are in DGROUP.
*       08-25-88  GJF   Define MAXSTR to be INT_MAX (from LIMITS.H).
*       06-06-89  JCR   386 mthread support
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 WIN32
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*
*******************************************************************************/

#include <windows.h>
#include <wchar.h>
#include <stdarg.h>
#include <limits.h>
#include "w4io.h"

#if defined(_W4PRINTF_)
    static INT_PTR  fh;
//    extern long GetStdHandle(long);
//    extern void WriteFile(long fh, char *s, long cch, long * pcchret, long);
#   define _PRINTF_
#elif defined(_W4DPRINTF_)
#   define _pwritechar  _dwritechar
#   define _pflushbuf   _dflushbuf
#   define w4printf     w4dprintf
#   define w4vprintf    w4vdprintf
#   define _PRINTF_
#elif defined(_W4SPRINTF_)
#   define _pwritechar  _swritechar
#   define w4printf     w4sprintf
#   define w4vprintf    w4vsprintf
#elif defined(_W4WCSPRINTF_)
#   define _TCHAR_      wchar_t
#   define _PBUF_       pwcbuf
#   define _PSTART_     pwcstart
#   define w4printf     w4wcsprintf
#   define w4vprintf    w4vwcsprintf
#   define _pwritechar  _wwritechar
#else
#   error configuration problem
#endif

#ifndef _TCHAR_
#  define _TCHAR_       char
#  define _PBUF_        pchbuf
#  define _PSTART_      pchstart
#endif


#ifdef _PRINTF_
#   ifdef WIN32
#     undef  OutputDebugString
#     define OutputDebugString OutputDebugStringA
#   else
      extern void _pascal OutputDebugString(char *);
#   endif
    int _cdecl _pflushbuf(struct w4io *f);
#   define SPR(a)
#   define MAXSTR       128
#else
#   define SPR(a)       a,
#   define MAXSTR       INT_MAX
#endif

void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten);
int _cdecl w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist);


/***
*int w4printf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data using the format string to
*       format data and getting as many arguments as called for
*       Sets up a w4io so file i/o operations can be used.
*       w4iooutput does the real work here
*
*Entry:
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/


int _cdecl
w4printf(SPR(_TCHAR_ *string) const char *format, ...)
/*
 * 'PRINT', 'F'ormatted
 */
{
    va_list arglist;

    va_start(arglist, format);
    return(w4vprintf(SPR(string) format, arglist));
}


/***
*int w4vprintf(format, arglist) - print formatted data from arg ptr
*
*Purpose:
*       Prints formatted data, but gets data from an argument pointer.
*       Sets up a w4io so file i/o operations can be used, make string look
*       like a huge buffer to it, but _flsbuf will refuse to flush it if it
*       fills up. Appends '\0' to make it a true string.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *format    - format string, describes format of data
*       va_list arglist - varargs argument pointer
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/

int _cdecl
w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist)
/*
 * 'V'ariable argument 'PRINT', 'F'ormatted
 */
{
    struct w4io outfile;
    register int retval;
#ifdef _PRINTF_
    char string[MAXSTR + 1];            // leave room for null termination
#else
    int dummy = 0;
#endif

#ifdef _W4PRINTF_
    long ldummy;

    if (fh == 0 || fh == -1)
    {
        ldummy = -11;                   // C7 bug workaround
        if ((fh = (INT_PTR)GetStdHandle(ldummy)) == 0 || fh == -1)
        {
            OutputDebugString("GetStdHandle in " __FILE__ " failed\n");
            return(-1);
        }
    }
#endif

    outfile._PBUF_ = outfile._PSTART_ = string;
    outfile.cchleft = MAXSTR;
    outfile.writechar = _pwritechar;

    retval = w4iooutput(&outfile, format, arglist);

#ifdef _PRINTF_
    if (_pflushbuf(&outfile) == -1) {
        return(-1);
    }
#else
    _pwritechar('\0', 1, &outfile, &dummy);
#endif
    return(retval);
}


void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten)
{
    //printf("  char: ch=%c, cnt=%d, cch=%d\n", ch, num, *pcchwritten);
    while (num-- > 0) {
#ifdef _PRINTF_
        if (f->cchleft < 2 && _pflushbuf(f) == -1) {
            *pcchwritten = -1;
            return;
        }
#endif
#ifdef _W4DPRINTF_
#  ifndef WIN32
        if (ch == '\n')
        {
            *f->_PBUF_++ = '\r';
            f->cchleft--;
            (*pcchwritten)++;
        }
#  endif
#endif
        *f->_PBUF_++ = (char) ch;
        f->cchleft--;
        (*pcchwritten)++;
    }
}


#ifdef _PRINTF_
int _cdecl _pflushbuf(struct w4io *f)
{
    int cch;

    if (cch = (int)(f->pchbuf - f->pchstart))
    {
#ifdef _W4DPRINTF_
        *f->pchbuf = '\0';              // null terminate
        OutputDebugString(f->pchstart);
#else
        long cchret;

        //*f->pchbuf = '\0';            // null terminate
        //printf("%d chars: \"%s\"\n", cch, f->pchstart);
        WriteFile((HANDLE)fh, f->pchstart, cch, &cchret, 0);
        if (cch != cchret)
        {
            OutputDebugString("WriteFile in " __FILE__ " failed\n");
            return(-1);
        }
#endif
        f->pchbuf -= cch;               // reset pointer
        f->cchleft += cch;              // reset count
    }
    return(0);
}
#endif // _PRINTF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\rprintf.h ===
/*++

Module Name:

    rprintf.h

Author:

    Venkatraman Kudallur (venkatk) 
    ( Ripped off from wininet )
        
Revision History:

    3-10-2000 venkatk
    Created

--*/

#ifndef _RPRINTF_H_
#define _RPRINTF_H_ 1

#ifdef UNUSED
// UNUSED - causes unneed crt bloat
int cdecl rprintf(char*, ...);
#endif

#include <stdarg.h>

int cdecl rsprintf(char*, char*, ...);
int cdecl _sprintf(char*, char*, va_list);

#define SPRINTF rsprintf
#define PRINTF  rprintf

#define RPRINTF_INCLUDED

#endif //_RPRINTF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\rprintf.cxx ===
/*++

Module Name:

    rprintf.cxx

Abstract:

    Contents:
        rprintf     limited re-entrant version of printf
        rsprintf    limited re-entrant version of sprintf
        _sprintf    routine which does the work

Author:

    Venkatraman Kudallur (venkatk)
    ( Ripped off from wininet )

Revision History:

    3-10-2000 venkatk
        Created

--*/

#ifdef ENABLE_DEBUG

#include <urlint.h>
#include "rprintf.h"

//from macros.h
#define PRIVATE
#define PUBLIC

//
// defines for flags word
//

#define F_SPACES        0x00000001  // prefix field with spaces
#define F_ZEROES        0x00000002  // prefix field with zeroes
#define F_MINUS         0x00000004  // field is left justified
#define F_HASH          0x00000008  // hex field is prefixed with 0x/0X
#define F_XUPPER        0x00000010  // hex field has upper case letters
#define F_LONG          0x00000020  // long int/hex/oct prefix
#define F_PLUS          0x00000040  // prefix +'ve signed number with +
#define F_DOT           0x00000080  // separator for field and precision
#define F_NEAR          0x00000100  // far pointer has near prefix
#define F_FAR           0x00000200  // near pointer has far prefix
#define F_SREPLICATE    0x00000400  // this field replicated
#define F_EREPLICATE    0x00000800  // end of replications
#define F_UNICODE       0x00001000  // string is wide character (%ws/%wq)
#define F_QUOTING       0x00002000  // strings enclosed in double quotes
#define F_ELLIPSE       0x00004000  // a sized, quoted string ends in "..."

#define BUFFER_SIZE     1024

//
// minimum field widths for various ASCII representations of numbers
//

#define MIN_BIN_WIDTH   16          // minimum field width in btoa
#define MIN_HEX_WIDTH   8           // minimum field width in xtoa
#define MIN_INT_WIDTH   10          // minimum field width in itoa
#define MIN_LHEX_WIDTH  8           // minimum field width in long xtoa
#define MIN_LINT_WIDTH  10          // minimum field width in long itoa
#define MIN_LOCT_WIDTH  11          // minimum field width in long otoa
#define MIN_OCT_WIDTH   11          // minimum field width in otoa
#define MIN_UINT_WIDTH  10          // minimum field width in utoa

//
// character defines
//

#define EOSTR           '\0'
#define CR              '\x0d'
#define LF              '\x0a'

#if !defined(min)

#define min(a, b)   ((a)<(b)) ? (a) : (b)

#endif

PRIVATE int     _atoi(char**);
PRIVATE void    convert(char**, ULONG_PTR, int, int, unsigned, char(*)(ULONG_PTR*));
PRIVATE char    btoa(ULONG_PTR *);
PRIVATE char    otoa(ULONG_PTR *);
PRIVATE char    utoa(ULONG_PTR *);
PRIVATE char    xtoa(ULONG_PTR *);
PRIVATE char    Xasc(ULONG_PTR *);

/***    rprintf - a re-entrant cut-down version of printf. Understands usual
 *                  printf format characters introduced by '%' plus one or
 *                  two additions
 *
 *      ENTRY   format  - pointer to buffer containing format string defining
 *                        the output. As per usual printf the arguments to
 *                        fill in the blanks in the format string are on the
 *                        the stack after the format string
 *
 *              <args>  - arguments on stack, size and type determined from
 *                        the format string
 *
 *      EXIT    format string used to convert arguments (if any) and print
 *              the results to stdout.
 *              The number of character copied is the value returned
 */

#ifdef UNUSED
int cdecl rprintf(char* format, ...) {

    int charsPrinted = 0;
    char buffer[BUFFER_SIZE];
    DWORD nwritten;
    va_list args;

    /* print the output into  buffer then print the formatted buffer to the
     * screen
     */

    va_start(args, format);
    charsPrinted = _sprintf(buffer, format, args);
    va_end(args);

    WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),
                              buffer,
                              charsPrinted,
                              &nwritten,
                              0
                              );
    return nwritten;
}
#endif

/***    rsprintf - a re-entrant cut-down version of sprintf. See rprintf for
 *                  details
 *
 *      ENTRY   buffer  - pointer to the buffer which will receive the
 *                        formatted output
 *
 *              format  - pointer to buffer which defines the formatted
 *                        output. Consists of normal printing characters
 *                        and printf-style format characters (see rprintf)
 *
 *      EXIT    characters from format string and arguments converted to
 *              character format based on format string are copied into the
 *              buffer
 *              The number of character copied is the value returned
 */

int cdecl rsprintf(char* buffer, char* format, ...) {

    va_list args;
    int n;

    va_start(args, format);
    n = _sprintf(buffer, format, args);
    va_end(args);
    return n;
}

/***    _sprintf - performs the sprintf function. Receives an extra parameter
 *                  on the stack which is the pointer to the variable argument
 *                  list of rprintf and rsprintf
 *
 *      ENTRY   buffer  - pointer to buffer which will receive the output
 *
 *              format  - pointer to the format string
 *
 *              args    - variable argument list which will be used to fill in
 *                        the escape sequences in the format string
 *
 *      EXIT    The characters in the format string are used to convert the
 *              arguments and copy them to the buffer.
 *              The number of character copied is the value returned
 */

int cdecl _sprintf(char* buffer, char* format, va_list args) {

    char*       original = buffer;
    int         FieldWidth;
    int         FieldPrecision;
    int         FieldLen;
    BOOL        SubDone;
    int         StrLen;
    int         i;
    DWORD       flags;
    int         replications;

    while (*format) {
        switch ((unsigned)*format) {
        case '\n':

            //
            // convert line-feed to carriage-return, line-feed. But only if the
            // format string doesn't already contain a carriage-return directly
            // before the line-feed! This way we can make multiple calls into
            // this function, with the same buffer, and only once expand the
            // line-feed
            //

            if (*(buffer - 1) != CR) {
                *buffer++ = CR;
            }
            *buffer++ = LF;
            break;

        case '%':
            SubDone = FALSE;
            flags = 0;
            FieldWidth = 0;
            FieldPrecision = 0;
            replications = 1;   /* default replication is 1 */
            while (!SubDone) {
                switch ((unsigned)*++format) {
                case '%':
                    *buffer++ = '%';
                    SubDone = TRUE;
                    break;

                case ' ':
                    flags |= F_SPACES;
                    break;

                case '#':
                    flags |= F_HASH;
                    break;

                case '-':
                    flags |= F_MINUS;
                    break;

                case '+':
                    flags |= F_PLUS;
                    break;

                case '.':
                    flags |= F_DOT;
                    break;

                case '*':
                    if (flags & F_DOT) {
                        FieldPrecision = va_arg(args, int);
                    } else {
                        FieldWidth = va_arg(args, int);
                    }
                    break;

                case '@':
                    replications = _atoi(&format);
                    break;

                case '[':
                    flags |= F_SREPLICATE;
                    break;

                case ']':
                    flags |= F_EREPLICATE;
                    break;

                case '0':
                    /* if this is leading zero then caller wants
                     * zero prefixed number of given width (%04x)
                     */
                    if (!(flags & F_ZEROES)) {
                        flags |= F_ZEROES;
                        break;
                    }

                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    if (flags & F_DOT) {
                        FieldPrecision = _atoi(&format);
                    } else {
                        FieldWidth = _atoi(&format);
                    }
                    break;

                case 'b':

                    //
                    // Binary representation
                    //

                    while (replications--) {
                        convert(&buffer,
                                va_arg(args, unsigned int),
                                (FieldWidth) ? FieldWidth : MIN_BIN_WIDTH,
                                MIN_BIN_WIDTH,
                                flags,
                                btoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'B':

                    //
                    // Boolean representation
                    //

                    if (va_arg(args, BOOL)) {
                        *buffer++ = 'T';
                        *buffer++ = 'R';
                        *buffer++ = 'U';
                        *buffer++ = 'E';
                    } else {
                        *buffer++ = 'F';
                        *buffer++ = 'A';
                        *buffer++ = 'L';
                        *buffer++ = 'S';
                        *buffer++ = 'E';
                    }
                    SubDone = TRUE;
                    break;

                case 'c':

                    //
                    // assume that a character is the size of the
                    // width of the stack which in turn has the same
                    // width as an integer
                    //

                    --FieldWidth;
                    while (replications--) {
                        for (i = 0; i < FieldWidth; i++) {
                            *buffer++ = ' ';
                        }
                        *buffer++ = (char) va_arg(args, int);
                    }
                    SubDone = TRUE;
                    break;

                case 'd':
                case 'i':
                    while (replications--) {

                        long l;

                        l = (flags & F_LONG) ? va_arg(args, long) : (long)va_arg(args, int);
                        if (l < 0) {
                            *buffer++ = '-';
                            if (flags & F_LONG) {
                                l = -(long)l;
                            } else {
                                l = -(int)l;
                            }
                        } else if (flags & F_PLUS) {
                            *buffer++ = '+';
                        }
                        convert(&buffer,
                                l,
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LINT_WIDTH : MIN_INT_WIDTH,
                                flags,
                                utoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'e':
                    /* not currently handled */
                    break;

                case 'f':
                    /* not currently handled */
                    break;

                case 'F':
                    flags |= F_FAR;
                    break;

                case 'g':
                case 'G':
                    /* not currently handled */
                    break;

                case 'h':
                    /* not currently handled */
                    break;

                case 'l':
                    flags |= F_LONG;
                    break;

                case 'L':
                    /* not currently handled */
                    break;

                case 'n':
                    *(va_arg(args, int*))  = (int)(buffer - original);
                    SubDone = TRUE;
                    break;

                case 'N':
                    flags |= F_NEAR;
                    break;

                case 'o':
                    while (replications--) {
                        convert(&buffer,
                                (flags & F_LONG) ? va_arg(args, unsigned long) : (unsigned long)va_arg(args, unsigned),
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LOCT_WIDTH : MIN_OCT_WIDTH,
                                flags,
                                otoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'p':
                    while (replications--) {

                        void* p;

                        if (!(flags & F_NEAR)) {
                            convert(&buffer,
                                    (ULONG_PTR) va_arg(args, char near *),
                                    MIN_HEX_WIDTH,
                                    MIN_HEX_WIDTH,
                                    flags | F_XUPPER,
                                    Xasc
                                    );
                            *buffer++ = ':';
                        }
                        convert(&buffer,
                                (ULONG_PTR)va_arg(args, unsigned),
                                MIN_HEX_WIDTH,
                                MIN_HEX_WIDTH,
                                flags | F_XUPPER,
                                Xasc
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'Q':       // quoted unicode string
                    flags |= F_UNICODE;
                    // *** FALL THROUGH ***

                case 'q':
                    *buffer++ = '"';
                    flags |= F_QUOTING;

                    //
                    // *** FALL THROUGH ***
                    //

                case 's':
                    while (replications--) {

                        char* s;

                        s = va_arg(args, char*);
                        if (s != NULL) {

                            // darrenmi 2/24/00 Note that if the string has a field precision,
                            // it's not always null terminated!! Don't depend on it being psz
                            // and stop when we hit our max length.
                            StrLen = 0;

                            if (flags & F_UNICODE) {
                                WCHAR   *pWork = (LPWSTR)s;
                                while((!FieldPrecision || StrLen < FieldPrecision) && *pWork)
                                {
                                    pWork++;
                                    StrLen++;
                                }
                            } else {
                                CHAR    *pWork = s;
                                while((!FieldPrecision || StrLen < FieldPrecision) && *pWork)
                                {
                                    pWork++;
                                    StrLen++;
                                }
                            }

                            FieldLen = (FieldPrecision)
                                        ? min(StrLen, FieldPrecision)
                                        : StrLen
                                        ;
                            if ((flags & F_QUOTING) && (FieldPrecision > 3) && (FieldLen == FieldPrecision)) {
                                FieldLen -= 3;
                                flags |= F_ELLIPSE;
                            }

                            for (i = 0; i < (FieldWidth - FieldLen); i++) {
                                *buffer++ = ' ';
                            }

                            if (flags & F_UNICODE) {

                                char wbuf[4096];
                                int wi;

                                WideCharToMultiByte(CP_ACP, 0,
                                        (LPWSTR)s, -1,
                                        wbuf, 4096,
                                        NULL, NULL);

                                for (wi = 0; wbuf[wi] && FieldLen; ++wi) {
                                    *buffer = wbuf[wi];

                                    //
                                    // if this is a quoted string, and it contains
                                    // \r and/or \n, then we reverse-convert these
                                    // characters, since we don't want then to
                                    // break the string. Do the same for \t
                                    //

                                    if (flags & F_QUOTING) {

                                        char ch;

                                        ch = *buffer;
                                        if ((ch == '\r') || (ch == '\n') || (ch == '\t')) {
                                            *buffer++ = '\\';
                                            *buffer = (ch == '\r')
                                                        ? 'r'
                                                        : (ch == '\n')
                                                            ? 'n'
                                                            : 't'
                                                            ;
                                        }
                                    }
                                    ++buffer;
                                    --FieldLen;
                                }
                            } else {
                                while (*s && FieldLen) {
                                    *buffer = *s++;

                                    //
                                    // if this is a quoted string, and it contains
                                    // \r and/or \n, then we reverse-convert these
                                    // characters, since we don't want then to
                                    // break the string. Do the same for \t
                                    //

                                    if (flags & F_QUOTING) {

                                        char ch;

                                        ch = *buffer;
                                        if ((ch == '\r') || (ch == '\n') || (ch == '\t')) {
                                            *buffer++ = '\\';
                                            *buffer = (ch == '\r')
                                                        ? 'r'
                                                        : (ch == '\n')
                                                            ? 'n'
                                                            : 't'
                                                            ;
                                        }
                                    }
                                    ++buffer;
                                    --FieldLen;
                                }
                            }
                            if (flags & F_ELLIPSE) {
                                *buffer++ = '.';
                                *buffer++ = '.';
                                *buffer++ = '.';
                            }
                        } else if (!(flags & F_QUOTING)) {
                            *buffer++ = '(';
                            *buffer++ = 'n';
                            *buffer++ = 'u';
                            *buffer++ = 'l';
                            *buffer++ = 'l';
                            *buffer++ = ')';
                        }
                    }
                    if (flags & F_QUOTING) {
                        *buffer++ = '"';
                    }
                    SubDone = TRUE;
                    break;

                case 'S':
                    break;

                case 'u':
                    while (replications--) {
                        convert(&buffer,
                                va_arg(args, unsigned),
                                FieldWidth,
                                MIN_UINT_WIDTH,
                                flags,
                                utoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'w':
                    flags |= F_UNICODE;
                    break;

                case 'X':
                    flags |= F_XUPPER;

                    //
                    // *** FALL THROUGH ***
                    //

                case 'x':
                    while (replications--) {
                        if (flags & F_HASH) {
                            *buffer++ = '0';
                            *buffer++ = (flags & F_XUPPER) ? (char)'X' : (char)'x';
                        }
                        convert(&buffer,
                                (flags & F_LONG) ? va_arg(args, unsigned long) : va_arg(args, unsigned),
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LHEX_WIDTH : MIN_HEX_WIDTH,
                                flags,
                                (flags & F_XUPPER) ? Xasc : xtoa
                                );
                    }
                    SubDone = TRUE;
                    break;
                } /* switch <%-specifier> */
            }
            break;

        default:
            *buffer++ = *format;
        } /* switch <character> */
        ++format;
    } /* while */
    *buffer = EOSTR;
    return (int)(buffer - original);
}

/***    _atoi - ascii to integer conversion used to get the field width out
 *              of the format string
 *
 *      ENTRY   p - pointer to pointer to format string
 *
 *      EXIT    returns the number found in the prefix string as a (16-bit)
 *              int format string pointer is updated past the field width
 */

PRIVATE
int _atoi(char** p) {

    int n = 0;
    int i = 5;

    while ((**p >= '0' && **p <= '9') && i--) {
        n = n*10+((int)(*(*p)++)-(int)'0');
    }

    /* put the format pointer back one since the major loop tests *++format */

    --*p;
    return n;
}

/***    convert - convert number to representation defined by procedure
 *
 *      ENTRY   buffer  - pointer to buffer to receive conversion
 *              n       - number to convert
 *              width   - user defined field width
 *              mwidth  - minimum width for representation
 *              flags   - flags controlling conversion
 *              proc    - pointer to conversion routine
 *
 *      EXIT    buffer is updated to point past the number representation
 *              just put into it
 */

PRIVATE
void
convert(
    char** buffer,
    ULONG_PTR n,
    int width,
    int mwidth,
    unsigned flags,
    char (*proc)(ULONG_PTR*)
    )
{
    char    numarray[33];
    int     MinWidth;
    int     i;

    MinWidth = (width < mwidth) ? mwidth : width;
    i = MinWidth;
    do {
        numarray[--i] = (*proc)(&n);
    } while (n);
    while (width > MinWidth-i) {
        numarray[--i] = (char)((flags & F_SPACES) ? ' ' : '0');
    }
    while (i < MinWidth) {
        *(*buffer)++ = numarray[i++];
    }
}

/***    btoa - return next (least significant) char in a binary to ASCII
 *              conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char btoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)(*pn&1)+'0';
    *pn >>= 1;
    return rch;
}

/***    otoa - return next (least significant) char in an octal to ASCII
 *              conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char otoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)'0'+(char)(*pn&7);
    *pn >>= 3;
    return rch;
}

/***    utoa - return next (least significant) char in an unsigned int to
 *              ASCII conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char utoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)'0'+(char)(*pn%10);
    *pn /= 10;
    return rch;
}

/***    xtoa - return next (least significant) char in a hexadecimal to
 *              ASCII conversion. Returns lower case hex characters
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char xtoa(ULONG_PTR *pn) {

    ULONG_PTR   n = *pn & 0x000f;
    char        rch = 	(n <= 9)
                        ? (char)n+'0'
                        : (char)n+'0'+('a'-'9'-1);

    *pn >>= 4;
    return rch;
}

/***    Xasc - return next (least significant) char in a hexadecimal to
 *              ASCII conversion. Returns upper case hex characters
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char Xasc(ULONG_PTR *pn) {

    ULONG_PTR   n = *pn & 0x000f;
    char        rch = 	(n <= 9)
                        ? (char)n+'0'
                        : (char)n+'0'+('A'-'9'-1);

    *pn >>= 4;
    return rch;
}
#endif // ENABLE_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\valid.h ===
#if DBG==1 && defined(WIN32) && !defined(_CHICAGO_)
#define VDATEHEAP() if( !HeapValidate(GetProcessHeap(),0,0)){ DebugBreak();}
#else
#define VDATEHEAP()
#endif  //  DBG==1 && defined(WIN32) && !defined(_CHICAGO_)

#define IsValidPtrIn(pv,cb)  ((pv == NULL) || !IsBadReadPtr ((pv),(cb)))
#define IsValidPtrOut(pv,cb) (!IsBadWritePtr((pv),(cb)))

STDAPI_(BOOL) IsValidInterface( void FAR* pv );


#if DBG==1
// for performance, do not do in retail builds
STDAPI_(BOOL) IsValidIid( REFIID riid );
#else
#define IsValidIid(x) (TRUE)
#endif

#ifdef _DEBUG

//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", __FILE__, __LINE__), retval)
#define VOID_VDATEPTRIN( pv, TYPE ) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    FnAssert(#pv,"Invalid in ptr", __FILE__, __LINE__); return; }

//** POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv, "Invalid in ptr", __FILE__, __LINE__), ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv, "Invalid in ptr", __FILE__, __LINE__), retval); \
         goto label; }
#define VOID_VDATEPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { FnAssert(#pv, "Invalid in ptr", __FILE__, __LINE__); goto label; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTROUT( pv, TYPE, retval ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__), retval)

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTROUT_LABEL( pv, TYPE, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEPTROUT_LABEL( pv, TYPE, retval, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__),retval); \
         goto label; }

//** INTERFACE validation macro:
#define GEN_VDATEIFACE( pv, retval ) \
        if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__), retval)
#define VDATEIFACE( pv ) \
        if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) \
        if (!IsValidInterface(pv)) {\
    FnAssert(#pv,"Invalid interface", __FILE__, __LINE__); return; }

//** INTERFACE validation macros for single entry/single exit functions
//** uses a goto instead of return
#define GEN_VDATEIFACE_LABEL( pv, retval, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__),retval); \
         goto label; }
#define VDATEIFACE_LABEL( pv, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define VOID_VDATEIFACE_LABEL( pv, label ) \
        if (!IsValidInterface(pv)) {\
        FnAssert(#pv,"Invalid interface", __FILE__, __LINE__); goto label; }

//** INTERFACE ID validation macro:
// Only do this in debug build
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (FnAssert(#iid,"Invalid iid", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) {\
    FnAssert(#iid,"Invalid iid", __FILE__, __LINE__); return retval; }

//** INTERFACE ID validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEIID_LABEL( iid, label, retVar ) if (!IsValidIid( iid )) \
        {retVar = (FnAssert(#iid,"Invalid iid", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEIID_LABEL( iid, retval, label, retVar ) if (!IsValidIid( iid )) {\
        FnAssert(#iid,"Invalid iid", __FILE__, __LINE__); retVar = retval;  goto label; }
#else



//  --assertless macros for non-debug case
//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    return; }

//** POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = retval; \
         goto label; }
#define VOID_VDATEPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { goto label; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))

#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (retval)

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTROUT_LABEL( pv, TYPE, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEPTROUT_LABEL( pv, TYPE, retval, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = retval; \
         goto label; }

//** INTERFACE validation macro:
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return;
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (retval)

//** INTERFACE validation macros for single entry/single exit functions
//** uses a goto instead of return
#define GEN_VDATEIFACE_LABEL( pv, retval, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = retval; \
         goto label; }
#define VDATEIFACE_LABEL( pv, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define VOID_VDATEIFACE_LABEL( pv, label ) \
        if (!IsValidInterface(pv)) {\
         goto label; }

//** INTERFACE ID validation macro:
// do not do in retail build. This code USED to call a bogus version of
// IsValidIID that did no work. Now we are faster and no less stable than before.
#define VDATEIID( iid )             ((void)0)
#define GEN_VDATEIID( iid, retval ) ((void)0);

//** INTERFACE ID validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEIID_LABEL( iid, label, retVar ) if (!IsValidIid( iid )) \
        {retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEIID_LABEL( iid, retval, label, retVar ) if (!IsValidIid( iid )) {\
        retVar = retval;  goto label; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\sprintf.c ===
/***
*sprintf.c - print formatted to string
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4sprintf() - print formatted data to string
*	defines w4vsprintf() - print formatted output to a string, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#define _W4SPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\strcore.cxx ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include <urlint.h>
#include <map_kv.h>
#include "coll.hxx"

/*
#include "stdafx.h"

#ifdef AFX_CORE1_SEG
#pragma code_seg(AFX_CORE1_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW
*/

// The following macros are used on data declarations/definitions
//  (they are redefined for extension DLLs and the shared MFC DLL)
#define AFX_DATA
#define AFX_DATADEF

// used when building the "core" MFC42.DLL
#ifndef AFX_CORE_DATA
        #define AFX_CORE_DATA
        #define AFX_CORE_DATADEF
#endif

// used when building the MFC/OLE support MFCO42.DLL
#ifndef AFX_OLE_DATA
        #define AFX_OLE_DATA
        #define AFX_OLE_DATADEF
#endif

#define TRACE1(x,a)
//int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);
// conversion helpers
int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// afxChNil is left for backward compatibility
AFX_DATADEF TCHAR afxChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int rgInitData[] = { -1, 0, 0, 0 };
static AFX_DATADEF CStringData* afxDataNil = (CStringData*)&rgInitData;
static LPCTSTR afxPchNil = (LPCTSTR)(((BYTE*)&rgInitData)+sizeof(CStringData));
// special function to make afxEmptyString work even during initialization
const CString& AFXAPI AfxGetEmptyString()
        { return *(CString*)&afxPchNil; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CString::CString()
{
        Init();
}

CString::CString(const CString& stringSrc)
{
        ASSERT(stringSrc.GetData()->nRefs != 0);
        if (stringSrc.GetData()->nRefs >= 0)
        {
                ASSERT(stringSrc.GetData() != afxDataNil);
                m_pchData = stringSrc.m_pchData;
                InterlockedIncrement(&GetData()->nRefs);
        }
        else
        {
                Init();
                *this = stringSrc.m_pchData;
        }
}

void CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
        ASSERT(nLen >= 0);
        ASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

        if (nLen == 0)
                Init();
        else
        {
                CStringData* pData =
                        (CStringData*)new BYTE[sizeof(CStringData) + (nLen+1)*sizeof(TCHAR)];
                pData->nRefs = 1;
                pData->data()[nLen] = '\0';
                pData->nDataLength = nLen;
                pData->nAllocLength = nLen;
                m_pchData = pData->data();
        }
}

void CString::Release()
{
        if (GetData() != afxDataNil)
        {
                ASSERT(GetData()->nRefs != 0);
                if (InterlockedDecrement(&GetData()->nRefs) <= 0)
                        delete[] (BYTE*)GetData();
                Init();
        }
}

void PASCAL CString::Release(CStringData* pData)
{
        if (pData != afxDataNil)
        {
                ASSERT(pData->nRefs != 0);
                if (InterlockedDecrement(&pData->nRefs) <= 0)
                        delete[] (BYTE*)pData;
        }
}

void CString::Empty()
{
        if (GetData()->nDataLength == 0)
                return;
        if (GetData()->nRefs >= 0)
                Release();
        else
                *this = &afxChNil;
        ASSERT(GetData()->nDataLength == 0);
        ASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

void CString::CopyBeforeWrite()
{
        if (GetData()->nRefs > 1)
        {
                CStringData* pData = GetData();
                Release();
                AllocBuffer(pData->nDataLength);
                memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
        }
        ASSERT(GetData()->nRefs <= 1);
}

void CString::AllocBeforeWrite(int nLen)
{
        if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
        {
                Release();
                AllocBuffer(nLen);
        }
        ASSERT(GetData()->nRefs <= 1);
}

CString::~CString()
//  free any attached data
{
        if (GetData() != afxDataNil)
        {
                if (InterlockedDecrement(&GetData()->nRefs) <= 0)
                        delete[] (BYTE*)GetData();
        }
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
         int nExtraLen) const
{
        // will clone the data attached to this string
        // allocating 'nExtraLen' characters
        // Places results in uninitialized string 'dest'
        // Will copy the part or all of original data to start of new string

        int nNewLen = nCopyLen + nExtraLen;
        if (nNewLen == 0)
        {
                dest.Init();
        }
        else
        {
                dest.AllocBuffer(nNewLen);
                memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
        }
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(LPCTSTR lpsz)
{
        Init();
        if (lpsz != NULL && (DWORD_PTR)lpsz <= 0xFFFF)
        {
                UINT nID = PtrToUlong(lpsz) & 0xFFFF;
                //if (!LoadString(nID))
                //        TRACE1("Warning: implicit LoadString(%u) failed\n", nID);
        }
        else
        {
                int nLen = SafeStrlen(lpsz);
                if (nLen != 0)
                {
                        AllocBuffer(nLen);
                        memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
                }
        }
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CString::CString(LPCSTR lpsz)
{
        Init();
        int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
        if (nSrcLen != 0)
        {
                AllocBuffer(nSrcLen);
                _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
                ReleaseBuffer();
        }
}
#else //_UNICODE
CString::CString(LPCWSTR lpsz)
{
        Init();
        int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
        if (nSrcLen != 0)
        {
                AllocBuffer(nSrcLen*2);
                _wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
                ReleaseBuffer();
        }
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Diagnostic support

#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, const CString& string)
{
        dc << string.m_pchData;
        return dc;
}
#endif //_DEBUG

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
        AllocBeforeWrite(nSrcLen);
        memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
        GetData()->nDataLength = nSrcLen;
        m_pchData[nSrcLen] = '\0';
}

const CString& CString::operator=(const CString& stringSrc)
{
        if (m_pchData != stringSrc.m_pchData)
        {
                if ((GetData()->nRefs < 0 && GetData() != afxDataNil) ||
                        stringSrc.GetData()->nRefs < 0)
                {
                        // actual copy necessary since one of the strings is locked
                        AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
                }
                else
                {
                        // can just copy references around
                        Release();
                        ASSERT(stringSrc.GetData() != afxDataNil);
                        m_pchData = stringSrc.m_pchData;
                        InterlockedIncrement(&GetData()->nRefs);
                }
        }
        return *this;
}

const CString& CString::operator=(LPCTSTR lpsz)
{
        ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
        AssignCopy(SafeStrlen(lpsz), lpsz);
        return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef _UNICODE
const CString& CString::operator=(LPCSTR lpsz)
{
        int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
        AllocBeforeWrite(nSrcLen);
        _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        ReleaseBuffer();
        return *this;
}
#else //!_UNICODE
const CString& CString::operator=(LPCWSTR lpsz)
{
        int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
        AllocBeforeWrite(nSrcLen*2);
        _wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
        ReleaseBuffer();
        return *this;
}
#endif  //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = TCHAR, LPCTSTR
//          CString + ?
//          ? + CString

void CString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
        int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

        int nNewLen = nSrc1Len + nSrc2Len;
        if (nNewLen != 0)
        {
                AllocBuffer(nNewLen);
                memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
                memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
        }
}

CString AFXAPI operator+(const CString& string1, const CString& string2)
{
        CString s;
        s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
                string2.GetData()->nDataLength, string2.m_pchData);
        return s;
}

CString AFXAPI operator+(const CString& string, LPCTSTR lpsz)
{
        ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
        CString s;
        s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
                CString::SafeStrlen(lpsz), lpsz);
        return s;
}

CString AFXAPI operator+(LPCTSTR lpsz, const CString& string)
{
        ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
        CString s;
        s.ConcatCopy(CString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
                string.m_pchData);
        return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
        //  -- the main routine for += operators

        // concatenating an empty string is a no-op!
        if (nSrcLen == 0)
                return;

        // if the buffer is too small, or we have a width mis-match, just
        //   allocate a new buffer (slow but sure)
        if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
        {
                // we have to grow the buffer, use the ConcatCopy routine
                CStringData* pOldData = GetData();
                ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
                ASSERT(pOldData != NULL);
                CString::Release(pOldData);
        }
        else
        {
                // fast concatenation when buffer big enough
                memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
                GetData()->nDataLength += nSrcLen;
                ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
                m_pchData[GetData()->nDataLength] = '\0';
        }
}

const CString& CString::operator+=(LPCTSTR lpsz)
{
        ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
        ConcatInPlace(SafeStrlen(lpsz), lpsz);
        return *this;
}

const CString& CString::operator+=(TCHAR ch)
{
        ConcatInPlace(1, &ch);
        return *this;
}

const CString& CString::operator+=(const CString& string)
{
        ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
        return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CString::GetBuffer(int nMinBufLength)
{
        ASSERT(nMinBufLength >= 0);

        if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
        {
                // we have to grow the buffer
                CStringData* pOldData = GetData();
                int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
                if (nMinBufLength < nOldLen)
                        nMinBufLength = nOldLen;
                AllocBuffer(nMinBufLength);
                memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
                GetData()->nDataLength = nOldLen;
                CString::Release(pOldData);
        }
        ASSERT(GetData()->nRefs <= 1);

        // return a pointer to the character storage for this string
        ASSERT(m_pchData != NULL);
        return m_pchData;
}

void CString::ReleaseBuffer(int nNewLength)
{
        CopyBeforeWrite();  // just in case GetBuffer was not called

        if (nNewLength == -1)
                nNewLength = lstrlen(m_pchData); // zero terminated

        ASSERT(nNewLength <= GetData()->nAllocLength);
        GetData()->nDataLength = nNewLength;
        m_pchData[nNewLength] = '\0';
}

LPTSTR CString::GetBufferSetLength(int nNewLength)
{
        ASSERT(nNewLength >= 0);

        GetBuffer(nNewLength);
        GetData()->nDataLength = nNewLength;
        m_pchData[nNewLength] = '\0';
        return m_pchData;
}

void CString::FreeExtra()
{
        ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
        if (GetData()->nDataLength != GetData()->nAllocLength)
        {
                CStringData* pOldData = GetData();
                AllocBuffer(GetData()->nDataLength);
                memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
                ASSERT(m_pchData[GetData()->nDataLength] == '\0');
                CString::Release(pOldData);
        }
        ASSERT(GetData() != NULL);
}

LPTSTR CString::LockBuffer()
{
        LPTSTR lpsz = GetBuffer(0);
        GetData()->nRefs = -1;
        return lpsz;
}

void CString::UnlockBuffer()
{
        ASSERT(GetData()->nRefs == -1);
        if (GetData() != afxDataNil)
                GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

#ifdef unused
int CString::Find(TCHAR ch) const
{
        // find first single character
        LPTSTR lpsz = _tcschr(m_pchData, (_TUCHAR)ch);

        // return -1 if not found and index otherwise
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CString::FindOneOf(LPCTSTR lpszCharSet) const
{
        ASSERT(AfxIsValidString(lpszCharSet, FALSE));
        LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}
void CString::MakeReverse()
{
        CopyBeforeWrite();
        _tcsrev(m_pchData);
}
#endif //unused

void CString::MakeUpper()
{
        CopyBeforeWrite();
        ::CharUpper(m_pchData);
}

void CString::MakeLower()
{
        CopyBeforeWrite();
        ::CharLower(m_pchData);
}


void CString::SetAt(int nIndex, TCHAR ch)
{
        ASSERT(nIndex >= 0);
        ASSERT(nIndex < GetData()->nDataLength);

        CopyBeforeWrite();
        m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
void CString::AnsiToOem()
{
        CopyBeforeWrite();
        ::AnsiToOem(m_pchData, m_pchData);
}
void CString::OemToAnsi()
{
        CopyBeforeWrite();
        #pragma prefast(suppress:56, "We don't hit this piece of code in the current codebase")
        ::OemToAnsi(m_pchData, m_pchData);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// CString conversion helpers (these use the current system locale)

int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
        if (count == 0 && mbstr != NULL)
                return 0;

        int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
                mbstr, count, NULL, NULL);
        ASSERT(mbstr == NULL || result <= (int)count);
        if (result > 0)
                mbstr[result-1] = 0;
        return result;
}

int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
        if (count == 0 && wcstr != NULL)
                return 0;

        int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
                wcstr, count);
        ASSERT(wcstr == NULL || result <= (int)count);
        if (result > 0)
                wcstr[result-1] = 0;
        return result;
}

LPWSTR AFXAPI AfxA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
        if (lpa == NULL)
                return NULL;
        ASSERT(lpw != NULL);
        // verify that no illegal character present
        // since lpw was allocated based on the size of lpa
        // don't worry about the number of chars
        lpw[0] = '\0';
        VERIFY(MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars));
        return lpw;
}

LPSTR AFXAPI AfxW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
        if (lpw == NULL)
                return NULL;
        ASSERT(lpa != NULL);
        // verify that no illegal character present
        // since lpa was allocated based on the size of lpw
        // don't worry about the number of chars
        lpa[0] = '\0';
        VERIFY(WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL));
        return lpa;
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\timecore.cxx ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include <urlint.h>
#include <map_kv.h>
#include "coll.hxx"
#include "ctime.hxx"

/*
#include "stdafx.h"

#ifdef AFX_AUX_SEG
#pragma code_seg(AFX_AUX_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
*/


/////////////////////////////////////////////////////////////////////////////
// CTime - absolute time

CTime::CTime(int nYear, int nMonth, int nDay, int nHour, int nMin, int nSec, int nDST)
{
    struct tm atm;
    atm.tm_sec = nSec;
    atm.tm_min = nMin;
    atm.tm_hour = nHour;
    ASSERT(nDay >= 1 && nDay <= 31);
    atm.tm_mday = nDay;
    ASSERT(nMonth >= 1 && nMonth <= 12);
    atm.tm_mon = nMonth - 1;        // tm_mon is 0 based
    ASSERT(nYear >= 1900);
    atm.tm_year = nYear - 1900;     // tm_year is 1900 based
    atm.tm_isdst = nDST;
    m_time = mktime(&atm);
    ASSERT(m_time != -1);       // indicates an illegal input time
}

CTime::CTime(WORD wDosDate, WORD wDosTime, int nDST)
{
    struct tm atm;
    atm.tm_sec = (wDosTime & ~0xFFE0) << 1;
    atm.tm_min = (wDosTime & ~0xF800) >> 5;
    atm.tm_hour = wDosTime >> 11;

    atm.tm_mday = wDosDate & ~0xFFE0;
    atm.tm_mon = ((wDosDate & ~0xFE00) >> 5) - 1;
    atm.tm_year = (wDosDate >> 9) + 80;
    atm.tm_isdst = nDST;
    m_time = mktime(&atm);
    ASSERT(m_time != -1);       // indicates an illegal input time
}

CTime::CTime(const SYSTEMTIME& sysTime, int nDST)
{
    if (sysTime.wYear < 1900)
    {
        time_t time0 = 0L;
        CTime timeT(time0);
        *this = timeT;
    }
    else
    {
        CTime timeT(
                   (int)sysTime.wYear, (int)sysTime.wMonth, (int)sysTime.wDay,
                   (int)sysTime.wHour, (int)sysTime.wMinute, (int)sysTime.wSecond,
                   nDST);
        *this = timeT;
    }
}

CTime::CTime(const FILETIME& fileTime, int nDST)
{
    // first convert file time (UTC time) to local time
    FILETIME localTime;
    if (!FileTimeToLocalFileTime(&fileTime, &localTime))
    {
        m_time = 0;
        return;
    }

    // then convert that time to system time
    SYSTEMTIME sysTime;
    if (!FileTimeToSystemTime(&localTime, &sysTime))
    {
        m_time = 0;
        return;
    }

    // then convert the system time to a time_t (C-runtime local time)
    CTime timeT(sysTime, nDST);
    *this = timeT;
}

CTime PASCAL CTime::GetCurrentTime()
// return the current system time
{
    return CTime(::time(NULL));
}

struct tm* CTime::GetGmtTm(struct tm* ptm) const
{
    if (ptm != NULL)
    {
        *ptm = *gmtime(&m_time);
        return ptm;
    }
    else
        return gmtime(&m_time);
}

struct tm* CTime::GetLocalTm(struct tm* ptm) const
{
    if (ptm != NULL)
    {
        struct tm* ptmTemp = localtime(&m_time);
        if (ptmTemp == NULL)
            return NULL;    // indicates the m_time was not initialized!

        *ptm = *ptmTemp;
        return ptm;
    }
    else
        return localtime(&m_time);
}

#ifdef _DEBUG
CDumpContext& AFXAPI operator <<(CDumpContext& dc, CTime time)
{
    char* psz = ctime(&time.m_time);
    if ((psz == NULL) || (time.m_time == 0))
        return dc << "CTime(invalid #" << time.m_time << ")";

    // format it
    psz[24] = '\0';         // nuke newline
    return dc << "CTime(\"" << psz << "\")";
}
#endif

CArchive& AFXAPI operator <<(CArchive& ar, CTime time)
{
    //return ar << (DWORD) time.m_time;
    ASSERT(FALSE);
    return ar;
}

CArchive& AFXAPI operator >>(CArchive& ar, CTime& rtime)
{
    //return ar >> (DWORD&) rtime.m_time;
    ASSERT(FALSE);
    return ar;
}

/////////////////////////////////////////////////////////////////////////////
// CTimeSpan - relative time

#ifdef _DEBUG
CDumpContext& AFXAPI operator <<(CDumpContext& dc, CTimeSpan timeSpan)
{
    return dc << "CTimeSpan(" << timeSpan.GetDays() << " days, " <<
    timeSpan.GetHours() << " hours, " <<
    timeSpan.GetMinutes() << " minutes and " <<
    timeSpan.GetSeconds() << " seconds)";
}
#endif

CArchive& AFXAPI operator <<(CArchive& ar, CTimeSpan timeSpan)
{
    //return ar << (DWORD) timeSpan.m_timeSpan;
    ASSERT(FALSE);
    return ar;
}

CArchive& AFXAPI operator >>(CArchive& ar, CTimeSpan& rtimeSpan)
{
    //return ar >> (DWORD&) rtimeSpan.m_timeSpan;
    ASSERT(FALSE);
    return ar;
}


/////////////////////////////////////////////////////////////////////////////
// String formatting

#define maxTimeBufferSize       128
// Verifies will fail if the needed buffer size is too large

#ifdef _UNICODE
#endif

CString CTimeSpan::Format(LPCTSTR pFormat) const
// formatting timespans is a little trickier than formatting CTimes
//  * we are only interested in relative time formats, ie. it is illegal
//      to format anything dealing with absolute time (i.e. years, months,
//         day of week, day of year, timezones, ...)
//  * the only valid formats:
//      %D - # of days -- NEW !!!
//      %H - hour in 24 hour format
//      %M - minute (0-59)
//      %S - seconds (0-59)
//      %% - percent sign
{
    TCHAR szBuffer[maxTimeBufferSize];
    TCHAR ch;
    LPTSTR pch = szBuffer;

    while ((ch = *pFormat++) != '\0')
    {
        ASSERT(pch < &szBuffer[maxTimeBufferSize]);
        if (ch == '%')
        {
            switch (ch = *pFormat++)
            {
            default:
                ASSERT(FALSE);      // probably a bad format character
            case '%':
                *pch++ = ch;
                break;
            case 'D':
                pch += wsprintf(pch, _T("%ld"), GetDays());
                break;
            case 'H':
                pch += wsprintf(pch, _T("%02d"), GetHours());
                break;
            case 'M':
                pch += wsprintf(pch, _T("%02d"), GetMinutes());
                break;
            case 'S':
                pch += wsprintf(pch, _T("%02d"), GetSeconds());
                break;
            }
        }
        else
        {
            *pch++ = ch;
            if (_istlead(ch))
            {
                ASSERT(pch < &szBuffer[maxTimeBufferSize]);
                *pch++ = *pFormat++;
            }
        }
    }

    *pch = '\0';
    return szBuffer;
}


CString CTime::Format(LPCTSTR pFormat) const
// formatting timespans is a little trickier than formatting CTimes
//  * we are only interested in relative time formats, ie. it is illegal
//      to format anything dealing with absolute time (i.e. years, months,
//         day of week, day of year, timezones, ...)
//  * the only valid formats:
//      %D - # of days -- NEW !!!
//      %H - hour in 24 hour format
//      %M - minute (0-59)
//      %S - seconds (0-59)
//      %% - percent sign
{
    TCHAR szBuffer[maxTimeBufferSize];
    TCHAR ch;
    LPTSTR pch = szBuffer;

    while ((ch = *pFormat++) != '\0')
    {
        ASSERT(pch < &szBuffer[maxTimeBufferSize]);
        if (ch == '%')
        {
            switch (ch = *pFormat++)
            {
            default:
                ASSERT(FALSE);      // probably a bad format character
            case '%':
                *pch++ = ch;
                break;
            case 'D':
                pch += wsprintf(pch, _T("%ld"), GetDay());
                break;
            case 'H':
                pch += wsprintf(pch, _T("%02d"), GetHour());
                break;
            case 'M':
                pch += wsprintf(pch, _T("%02d"), GetMinute());
                break;
            case 'S':
                pch += wsprintf(pch, _T("%02d"), GetSecond());
                break;
            }
        }
        else
        {
            *pch++ = ch;
            if (_istlead(ch))
            {
                ASSERT(pch < &szBuffer[maxTimeBufferSize]);
                *pch++ = *pFormat++;
            }
        }
    }

    *pch = '\0';
    return szBuffer;
}



#ifdef _ALL_CTIME_FORMATS_
CString CTimeSpan::Format(UINT nFormatID) const
{
    CString strFormat;
    VERIFY(strFormat.LoadString(nFormatID) != 0);
    return Format(strFormat);
}

CString CTime::Format(LPCTSTR pFormat) const
{
    TCHAR szBuffer[maxTimeBufferSize];

    struct tm* ptmTemp = localtime(&m_time);
    if (ptmTemp == NULL ||
        !_tcsftime(szBuffer, _countof(szBuffer), pFormat, ptmTemp))
        szBuffer[0] = '\0';
    return szBuffer;
}

CString CTime::FormatGmt(LPCTSTR pFormat) const
{
    TCHAR szBuffer[maxTimeBufferSize];

    struct tm* ptmTemp = gmtime(&m_time);
    if (ptmTemp == NULL ||
        !_tcsftime(szBuffer, _countof(szBuffer), pFormat, ptmTemp))
        szBuffer[0] = '\0';
    return szBuffer;
}

CString CTime::Format(UINT nFormatID) const
{
    CString strFormat;
    VERIFY(strFormat.LoadString(nFormatID) != 0);
    return Format(strFormat);
}

CString CTime::FormatGmt(UINT nFormatID) const
{
    CString strFormat;
    VERIFY(strFormat.LoadString(nFormatID) != 0);
    return FormatGmt(strFormat);
}

    #ifdef _UNICODE
// These functions are provided for compatibility with MFC 3.x
CString CTime::Format(LPCSTR pFormat) const
{
    CString strFormat(pFormat);
    return Format((LPCTSTR)strFormat);
}

CString CTime::FormatGmt(LPCSTR pFormat) const
{
    CString strFormat(pFormat);
    return FormatGmt((LPCTSTR)strFormat);
}

CString CTimeSpan::Format(LPCSTR pFormat) const
{
    CString strFormat = pFormat;
    return Format((LPCTSTR)strFormat);
}
    #endif //_ALL_CTIME_FORMATS_
#endif // _UNICODE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\wsprintf.c ===
/***
*sprintf.c - print formatted to string
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4wcsprintf() - print formatted data to wide character string
*	defines w4vwcsprintf() - print formatted output to a wide character
*				 string, get data from argument ptr instead
*				 of explicit args.
*******************************************************************************/

#define _W4WCSPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\wreg.cxx ===
#include <urlmon.hxx>
#include "wreg.hxx"

#define DEB_REG DEB_ERROR

CRegistryA g_Reg;
CRegistryA *g_vpReg = &g_Reg;

//+---------------------------------------------------------------------------
//
//  Method:     CRegistryW::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CRegistryW::QueryInterface( REFIID riid, void **ppv )
{
    HRESULT     hr = NOERROR;

    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::QueryInterface (%lx, %p)\n", this, riid, ppv));

    if ((riid == IID_IUnknown) || (riid == IID_IRegistryW))
    {
        *ppv = (void FAR *)this;
        AddRef();
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::QueryInterface (%lx)[%p]\n", this, hr, *ppv));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRegistryW::AddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRegistryW::AddRef( void )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::AddRef\n", this));

    LONG lRet = _CRefs++;

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::AddRef (%ld)\n", this, lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRegistryW::Release
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRegistryW::Release( void )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::Release\n", this));

    LONG lRet = --_CRefs;
    if (_CRefs == 0)
    {
        delete this;
    }
    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::Release (%ld)\n", this, lRet));
    return lRet;
}

// can this method be supported
STDMETHODIMP_(LONG) CRegistryW::ConnectRegistry (
     LPWSTR lpMachineName,
     HKEY hKey,
     IRegistryW **ppReg
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::ConnectRegistry\n", this));
    HKEY hKeyLoc = 0;

    LONG lRet;

    lRet  = RegConnectRegistryW(lpMachineName, hKey, &hKeyLoc);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::ConnectRegistry (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryW::CloseKey (
     HKEY hKey
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::CloseKey\n", this));
    LONG lRet = 0;
    lRet = RegCloseKey( hKey );

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::CloseKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::CreateKey (
     HKEY hKey,
     LPCWSTR lpSubKey,
     PHKEY phkResult
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::CreateKey\n", this));
    LONG lRet = 0;

    lRet = RegCreateKeyW(hKey, lpSubKey, phkResult);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::CreateKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::CreateKeyEx (
     HKEY hKey,
     LPCWSTR lpSubKey,
     DWORD Reserved,
     LPWSTR lpClass,
     DWORD dwOptions,
     REGSAM samDesired,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes,
     PHKEY phkResult,
     LPDWORD lpdwDisposition
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::CreateKeyEx\n", this));
    LONG lRet = 0;
    lRet = RegCreateKeyExW (
             hKey,
             lpSubKey,
             Reserved,
             lpClass,
             dwOptions,
             samDesired,
             lpSecurityAttributes,
             phkResult,
             lpdwDisposition
            );

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::CreateKeyEx (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::DeleteKey (
     HKEY hKey,
     LPCWSTR lpSubKey
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::DeleteKey\n", this));
    LONG lRet = 0;

    lRet = RegDeleteKeyW(hKey, lpSubKey);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::DeleteKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::DeleteValue (
     HKEY hKey,
     LPCWSTR lpValueName
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::DeleteValue\n", this));
    LONG lRet = 0;

    lRet = RegDeleteValueW(hKey, lpValueName);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::DeleteValue (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryW::EnumKey (
     HKEY hKey,
     DWORD dwIndex,
     LPWSTR lpName,
     DWORD cbName
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::EnumKey\n", this));
    LONG lRet = 0;

    lRet = RegEnumKeyW (hKey, dwIndex, lpName, cbName);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::EnumKey (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryW::EnumKeyEx (
     HKEY hKey,
     DWORD dwIndex,
     LPWSTR lpName,
     LPDWORD lpcbName,
     LPDWORD lpReserved,
     LPWSTR lpClass,
     LPDWORD lpcbClass,
     PFILETIME lpftLastWriteTime
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::EnumKeyEx\n", this));
    LONG lRet = 0;

    lRet = RegEnumKeyExW(hKey,dwIndex,lpName,lpcbName,lpReserved,
                 lpClass,lpcbClass,lpftLastWriteTime);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::EnumKeyEx (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::EnumValue (
     HKEY hKey,
     DWORD dwIndex,
     LPWSTR lpValueName,
     LPDWORD lpcbValueName,
     LPDWORD lpReserved,
     LPDWORD lpType,
     LPBYTE lpData,
     LPDWORD lpcbData
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::EnumValue\n", this));
    LONG lRet = 0;
    lRet = RegEnumValueW(hKey,dwIndex,lpValueName,
                lpcbValueName,lpReserved,lpType,lpData,lpcbData);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::EnumValue (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryW::FlushKey (HKEY hKey)
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::FlushKey\n", this));
    LONG lRet = 0;

    lRet = RegFlushKey(hKey);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::FlushKey (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryW::GetKeySecurity (
     HKEY hKey,
     SECURITY_INFORMATION SecurityInformation,
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     LPDWORD lpcbSecurityDescriptor)
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::GetKeySecurity\n", this));
    LONG lRet = 0;

    lRet = RegGetKeySecurity (hKey,SecurityInformation, pSecurityDescriptor,lpcbSecurityDescriptor);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::GetKeySecurity (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::LoadKey (
     HKEY  hKey,
     LPCWSTR  lpSubKey,
     LPCWSTR  lpFile
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::LoadKey\n", this));
    LONG lRet = 0;

    lRet = RegLoadKeyW(hKey, lpSubKey, lpFile);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::LoadKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::NotifyChangeKeyValue (
     HKEY hKey,
     BOOL bWatchSubtree,
     DWORD dwNotifyFilter,
     HANDLE hEvent,
     BOOL fAsynchronus
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::NotifyChangeKeyValue\n", this));
    LONG lRet = 0;

    lRet = RegNotifyChangeKeyValue(hKey, bWatchSubtree, dwNotifyFilter, hEvent,fAsynchronus);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::NotifyChangeKeyValue (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::OpenKey (
     HKEY hKey,
     LPCWSTR lpSubKey,
     PHKEY phkResult
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::OpenKey\n", this));
    LONG lRet = 0;

    lRet =  RegOpenKeyW(hKey, lpSubKey, phkResult);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::OpenKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::OpenKeyEx (
     HKEY hKey,
     LPCWSTR lpSubKey,
     DWORD ulOptions,
     REGSAM samDesired,
     PHKEY phkResult
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::OpenKeyEx\n", this));
    LONG lRet = 0;

    lRet = RegOpenKeyExW(hKey,lpSubKey,ulOptions,samDesired,phkResult);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::OpenKeyEx (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryW::QueryInfoKey (
     HKEY    hKey,
     LPWSTR  lpClass,
     LPDWORD lpcbClass,
     LPDWORD lpReserved,
     LPDWORD lpcSubKeys,
     LPDWORD lpcbMaxSubKeyLen,
     LPDWORD lpcbMaxClassLen,
     LPDWORD lpcValues,
     LPDWORD lpcbMaxValueNameLen,
     LPDWORD lpcbMaxValueLen,
     LPDWORD lpcbSecurityDescriptor,
     PFILETIME lpftLastWriteTime
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::QueryInfoKey\n", this));
    LONG lRet = 0;

    lRet = RegQueryInfoKeyW (
         hKey,
         lpClass,
         lpcbClass,
         lpReserved,
         lpcSubKeys,
         lpcbMaxSubKeyLen,
         lpcbMaxClassLen,
         lpcValues,
         lpcbMaxValueNameLen,
         lpcbMaxValueLen,
         lpcbSecurityDescriptor,
         lpftLastWriteTime);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::QueryInfoKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::QueryValue (
     HKEY hKey,
     LPCWSTR lpSubKey,
     LPWSTR lpValue,
     LONG   *lpcbValue
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::QueryValue\n", this));
    LONG lRet = 0;

    lRet = RegQueryValueW(hKey,lpSubKey,lpValue,lpcbValue);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::QueryValue (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::QueryMultipleValues (
     HKEY hKey,
     PVALENTXW val_list,
     DWORD num_vals,
     LPWSTR lpValueBuf,
     LPDWORD ldwTotsize
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::QueryMultipleValues\n", this));
    LONG lRet = 0;

    lRet = RegQueryMultipleValuesW(hKey,(PVALENTW) val_list, num_vals, lpValueBuf, ldwTotsize);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::QueryMultipleValues (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::QueryValueEx (
     HKEY hKey,
     LPCWSTR lpValueName,
     LPDWORD lpReserved,
     LPDWORD lpType,
     LPBYTE lpData,
     LPDWORD lpcbData
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::QueryValueEx\n", this));
    LONG lRet = 0;

    lRet = RegQueryValueExW(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::QueryValueEx (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::ReplaceKey (
     HKEY     hKey,
     LPCWSTR  lpSubKey,
     LPCWSTR  lpNewFile,
     LPCWSTR  lpOldFile
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::ReplaceKey\n", this));
    LONG lRet = 0;

    lRet = RegReplaceKeyW(hKey, lpSubKey, lpNewFile, lpOldFile);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::ReplaceKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::RestoreKey (
     HKEY hKey,
     LPCWSTR lpFile,
     DWORD   dwFlags
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::RestoreKey\n", this));
    LONG lRet = 0;

    lRet = RegRestoreKeyW(hKey, lpFile, dwFlags);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::RestoreKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::SaveKey (
     HKEY hKey,
     LPCWSTR lpFile,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::SaveKey\n", this));
    LONG lRet = 0;

    lRet = RegSaveKeyW(hKey, lpFile, lpSecurityAttributes);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::SaveKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::SetKeySecurity (
     HKEY hKey,
     SECURITY_INFORMATION SecurityInformation,
     PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::SetKeySecurity\n", this));
    LONG lRet = 0;

    lRet = RegSetKeySecurity(hKey, SecurityInformation, pSecurityDescriptor);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::SetKeySecurity (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::SetValue (
     HKEY hKey,
     LPCWSTR lpSubKey,
     DWORD dwType,
     LPCWSTR lpData,
     DWORD cbData
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::SetValue\n", this));
    LONG lRet = 0;

    lRet = RegSetValueW(hKey, lpSubKey, dwType,lpData, cbData );

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::SetValue (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::SetValueEx (
     HKEY hKey,
     LPCWSTR lpValueName,
     DWORD Reserved,
     DWORD dwType,
     const BYTE* lpData,
     DWORD cbData
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::SetValueEx\n", this));
    LONG lRet = 0;

    lRet = RegSetValueExW(hKey, lpValueName, Reserved, dwType,lpData, cbData);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::SetValueEx (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryW::UnLoadKey (
     HKEY hKey,
     LPCWSTR lpSubKey
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryW::UnLoadKey\n", this));
    LONG lRet = 0;

    lRet = RegUnLoadKeyW(hKey, lpSubKey);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryW::UnLoadKey (%ld)\n", this, lRet));
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Method:     CRegistryW::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CRegistryA::QueryInterface( REFIID riid, void **ppv )
{
    HRESULT     hr = NOERROR;

    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::QueryInterface (%lx, %p)\n", this, riid, ppv));

    if ((riid == IID_IUnknown) || (riid == IID_IRegistryA))
    {
        *ppv = (void FAR *)this;
        AddRef();
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::QueryInterface (%lx)[%p]\n", this, hr, *ppv));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRegistryA::AddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRegistryA::AddRef( void )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::AddRef\n", this));

    LONG lRet = _CRefs++;

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::AddRef (%ld)\n", this, lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRegistryA::Release
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRegistryA::Release( void )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::Release\n", this));

    LONG lRet = --_CRefs;
    if (_CRefs == 0)
    {
        delete this;
    }
    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::Release (%ld)\n", this, lRet));
    return lRet;
}

// can this method be supported
STDMETHODIMP_(LONG) CRegistryA::ConnectRegistry (
     LPSTR lpMachineName,
     HKEY hKey,
     IRegistryA **ppReg
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::ConnectRegistry\n", this));
    HKEY hKeyLoc = 0;

    LONG lRet;

    lRet  = RegConnectRegistryA(lpMachineName, hKey, &hKeyLoc);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::ConnectRegistry (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryA::CloseKey (
     HKEY hKey
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::CloseKey\n", this));
    LONG lRet = 0;
    lRet = RegCloseKey( hKey );

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::CloseKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::CreateKey (
     HKEY hKey,
     LPCSTR lpSubKey,
     PHKEY phkResult
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::CreateKey\n", this));
    LONG lRet = 0;

    lRet = RegCreateKeyA(hKey, lpSubKey, phkResult);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::CreateKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::CreateKeyEx (
     HKEY hKey,
     LPCSTR lpSubKey,
     DWORD Reserved,
     LPSTR lpClass,
     DWORD dwOptions,
     REGSAM samDesired,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes,
     PHKEY phkResult,
     LPDWORD lpdwDisposition
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::CreateKeyEx\n", this));
    LONG lRet = 0;
    lRet = RegCreateKeyExA (
             hKey,
             lpSubKey,
             Reserved,
             lpClass,
             dwOptions,
             samDesired,
             lpSecurityAttributes,
             phkResult,
             lpdwDisposition
            );

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::CreateKeyEx (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::DeleteKey (
     HKEY hKey,
     LPCSTR lpSubKey
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::DeleteKey\n", this));
    LONG lRet = 0;

    lRet = RegDeleteKeyA(hKey, lpSubKey);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::DeleteKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::DeleteValue (
     HKEY hKey,
     LPCSTR lpValueName
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::DeleteValue\n", this));
    LONG lRet = 0;

    lRet = RegDeleteValueA(hKey, lpValueName);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::DeleteValue (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryA::EnumKey (
     HKEY hKey,
     DWORD dwIndex,
     LPSTR lpName,
     DWORD cbName
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::EnumKey\n", this));
    LONG lRet = 0;

    lRet = RegEnumKeyA (hKey, dwIndex, lpName, cbName);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::EnumKey (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryA::EnumKeyEx (
     HKEY hKey,
     DWORD dwIndex,
     LPSTR lpName,
     LPDWORD lpcbName,
     LPDWORD lpReserved,
     LPSTR lpClass,
     LPDWORD lpcbClass,
     PFILETIME lpftLastWriteTime
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::EnumKeyEx\n", this));
    LONG lRet = 0;

    lRet = RegEnumKeyExA(hKey,dwIndex,lpName,lpcbName,lpReserved,
                 lpClass,lpcbClass,lpftLastWriteTime);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::EnumKeyEx (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::EnumValue (
     HKEY hKey,
     DWORD dwIndex,
     LPSTR lpValueName,
     LPDWORD lpcbValueName,
     LPDWORD lpReserved,
     LPDWORD lpType,
     LPBYTE lpData,
     LPDWORD lpcbData
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::EnumValue\n", this));
    LONG lRet = 0;
    lRet = RegEnumValueA(hKey,dwIndex,lpValueName,
                lpcbValueName,lpReserved,lpType,lpData,lpcbData);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::EnumValue (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryA::FlushKey (HKEY hKey)
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::FlushKey\n", this));
    LONG lRet = 0;

    lRet = RegFlushKey(hKey);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::FlushKey (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryA::GetKeySecurity (
     HKEY hKey,
     SECURITY_INFORMATION SecurityInformation,
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     LPDWORD lpcbSecurityDescriptor)
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::GetKeySecurity\n", this));
    LONG lRet = 0;

    lRet = RegGetKeySecurity (hKey,SecurityInformation, pSecurityDescriptor,lpcbSecurityDescriptor);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::GetKeySecurity (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::LoadKey (
     HKEY  hKey,
     LPCSTR  lpSubKey,
     LPCSTR  lpFile
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::LoadKey\n", this));
    LONG lRet = 0;

    lRet = RegLoadKeyA(hKey, lpSubKey, lpFile);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::LoadKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::NotifyChangeKeyValue (
     HKEY hKey,
     BOOL bWatchSubtree,
     DWORD dwNotifyFilter,
     HANDLE hEvent,
     BOOL fAsynchronus
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::NotifyChangeKeyValue\n", this));
    LONG lRet = 0;

    lRet = RegNotifyChangeKeyValue(hKey, bWatchSubtree, dwNotifyFilter, hEvent,fAsynchronus);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::NotifyChangeKeyValue (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::OpenKey (
     HKEY hKey,
     LPCSTR lpSubKey,
     PHKEY phkResult
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::OpenKey (lpSubKey:%s)\n", this,lpSubKey));
    LONG lRet = 0;

    lRet =  RegOpenKeyA(hKey, lpSubKey, phkResult);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::OpenKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::OpenKeyEx (
     HKEY hKey,
     LPCSTR lpSubKey,
     DWORD ulOptions,
     REGSAM samDesired,
     PHKEY phkResult
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::OpenKeyEx\n", this));
    LONG lRet = 0;

    lRet = RegOpenKeyExA(hKey,lpSubKey,ulOptions,samDesired,phkResult);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::OpenKeyEx (%ld)\n", this, lRet));
    return lRet;
}


STDMETHODIMP_(LONG) CRegistryA::QueryInfoKey (
     HKEY    hKey,
     LPSTR  lpClass,
     LPDWORD lpcbClass,
     LPDWORD lpReserved,
     LPDWORD lpcSubKeys,
     LPDWORD lpcbMaxSubKeyLen,
     LPDWORD lpcbMaxClassLen,
     LPDWORD lpcValues,
     LPDWORD lpcbMaxValueNameLen,
     LPDWORD lpcbMaxValueLen,
     LPDWORD lpcbSecurityDescriptor,
     PFILETIME lpftLastWriteTime
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::QueryInfoKey\n", this));
    LONG lRet = 0;

    lRet = RegQueryInfoKeyA (
         hKey,
         lpClass,
         lpcbClass,
         lpReserved,
         lpcSubKeys,
         lpcbMaxSubKeyLen,
         lpcbMaxClassLen,
         lpcValues,
         lpcbMaxValueNameLen,
         lpcbMaxValueLen,
         lpcbSecurityDescriptor,
         lpftLastWriteTime);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::QueryInfoKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::QueryValue (
     HKEY hKey,
     LPCSTR lpSubKey,
     LPSTR lpValue,
     LONG   *lpcbValue
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::QueryValue (szValue:%s)\n", this,lpSubKey));
    LONG lRet = 0;

    lRet = RegQueryValueA(hKey,lpSubKey,lpValue,lpcbValue);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::QueryValue (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::QueryMultipleValues (
     HKEY hKey,
     PVALENTXA val_list,
     DWORD num_vals,
     LPSTR lpValueBuf,
     LPDWORD ldwTotsize
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::QueryMultipleValues\n", this));
    LONG lRet = 0;

    lRet = RegQueryMultipleValuesA(hKey,(PVALENTA) val_list, num_vals, lpValueBuf, ldwTotsize);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::QueryMultipleValues (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::QueryValueEx (
     HKEY hKey,
     LPCSTR lpValueName,
     LPDWORD lpReserved,
     LPDWORD lpType,
     LPBYTE lpData,
     LPDWORD lpcbData
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::QueryValueEx\n", this));
    LONG lRet = 0;

    lRet = RegQueryValueExA(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::QueryValueEx (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::ReplaceKey (
     HKEY     hKey,
     LPCSTR  lpSubKey,
     LPCSTR  lpNewFile,
     LPCSTR  lpOldFile
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::ReplaceKey\n", this));
    LONG lRet = 0;

    lRet = RegReplaceKeyA(hKey, lpSubKey, lpNewFile, lpOldFile);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::ReplaceKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::RestoreKey (
     HKEY hKey,
     LPCSTR lpFile,
     DWORD   dwFlags
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::RestoreKey\n", this));
    LONG lRet = 0;

    lRet = RegRestoreKeyA(hKey, lpFile, dwFlags);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::RestoreKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::SaveKey (
     HKEY hKey,
     LPCSTR lpFile,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::SaveKey\n", this));
    LONG lRet = 0;

    lRet = RegSaveKeyA(hKey, lpFile, lpSecurityAttributes);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::SaveKey (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::SetKeySecurity (
     HKEY hKey,
     SECURITY_INFORMATION SecurityInformation,
     PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::SetKeySecurity\n", this));
    LONG lRet = 0;

    lRet = RegSetKeySecurity(hKey, SecurityInformation, pSecurityDescriptor);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::SetKeySecurity (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::SetValue (
     HKEY hKey,
     LPCSTR lpSubKey,
     DWORD dwType,
     LPCSTR lpData,
     DWORD cbData
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::SetValue\n", this));
    LONG lRet = 0;

    lRet = RegSetValueA(hKey, lpSubKey, dwType,lpData, cbData );

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::SetValue (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::SetValueEx (
     HKEY hKey,
     LPCSTR lpValueName,
     DWORD Reserved,
     DWORD dwType,
     const BYTE* lpData,
     DWORD cbData
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::SetValueEx\n", this));
    LONG lRet = 0;

    lRet = RegSetValueExA(hKey, lpValueName, Reserved, dwType,lpData, cbData);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::SetValueEx (%ld)\n", this, lRet));
    return lRet;
}

STDMETHODIMP_(LONG) CRegistryA::UnLoadKey (
     HKEY hKey,
     LPCSTR lpSubKey
    )
{
    UrlMkDebugOut((DEB_REG, "%p _IN CRegistryA::UnLoadKey\n", this));
    LONG lRet = 0;

    lRet = RegUnLoadKeyA(hKey, lpSubKey);

    UrlMkDebugOut((DEB_REG, "%p OUT CRegistryA::UnLoadKey (%ld)\n", this, lRet));
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\valid.cxx ===
#include <ole2.h>

#include "valid.h"
#include "debug.h"

#if 1
// we cannot turn this off until we remove from the export list!
#undef IsValidPtrIn
#undef IsValidPtrOut

// BUGBUG: The following two functions are MACRO's in 2.01 code
// but we need them for now because we only run with a storage
// that uses ole232.dll. When we get rid of this these may die.

STDAPI_(BOOL) IsValidPtrIn( const void FAR* pv, UINT cb )
{                                                                                               //      NULL is acceptable
        if (pv && IsBadReadPtr(pv,cb))
        {
//              AssertSz(FALSE, "Invalid in pointer");
                return FALSE;
        }
        return TRUE;
}



STDAPI_(BOOL) IsValidPtrOut( void FAR* pv, UINT cb )
                                                                                //      NULL is not acceptable
{
        if (IsBadWritePtr(pv,cb))
        {
//              AssertSz(FALSE, "Invalid out pointer");
                return FALSE;
        }
        return TRUE;
}
#endif


STDAPI_(BOOL) IsValidInterface( void FAR* pv )
{
//
// There is nothing to do about it on UNIX.
//
#ifndef UNIX
        DWORD_PTR FAR*          pVtbl;
        BYTE FAR*               pFcn;
        volatile BYTE   bInstr;
        int                             i;

        __try {
                pVtbl = *(DWORD_PTR FAR* FAR*)pv;           // pVtbl now points to beginning of vtable

#if DBG==1
                for (i=0;i<3;++i)                                       // loop through qi,addref,rel
#else
                i=1;                                                            // in retail, just do AddRef
#endif
                {
                        pFcn = *(BYTE FAR* FAR*) &pVtbl[i];     // pFcn now points to beginning of QI,Addref, or Release
#if DBG==1
                        if (IsBadCodePtr((FARPROC FAR)pFcn)) {
                                return FALSE;
                        }
#endif
                        bInstr = *(BYTE FAR*) pFcn;             // get 1st byte of 1st instruction
                }

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
                return FALSE;
        }
#endif /* !unix */

        return TRUE;
}


// #if DBG==1
// we cannot remove IsValidIID fcn until we remove from export list!

// This function is NOT called in retail builds.
// Its former implementation always returned TRUE thus doing NO validation.
// It now validates in debug build and is not called in retail build

#if DBG==0
#ifdef IsValidIid
#undef IsValidIid
STDAPI_(BOOL) IsValidIid( REFIID iid );
#endif
#endif

STDAPI_(BOOL) IsValidIid( REFIID iid )
{
#if DBG==1
        if (IsBadReadPtr((void*) &iid, 16)) {
                AssertSz(FALSE, "Invalid iid");
                return FALSE;
        }
#endif
        return TRUE;
}
// #endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\w4io.h ===
/***
*w4io.h - fake FILE structure for Win 4 printf/sprintf/debug printf support
*
*/

#ifdef unix
#include <windows.h>
#endif /* unix */

#if defined(M_I386) || defined(WIN32)
#  ifndef WIN32
#    define WIN32
#  endif
#elif !defined(M_I86LM)
#  error Must be FLAT or LARGE model.
#endif

#ifndef NULL
#  define NULL 0
#endif

struct w4io
{
    union
    {
        struct
        {
            wchar_t *_pwcbuf;   // wchar_t output buffer
            wchar_t *_pwcstart;
        } wc;
        struct
        {
            char *_pchbuf;      // char output buffer
            char *_pchstart;
        } ch;
    } buf ;
    unsigned int cchleft;       // output buffer character count
    void (_cdecl *writechar)(int ch,
                             int num,
                             struct w4io *f,
                             int *pcchwritten);
};

#define pwcbuf          buf.wc._pwcbuf
#define pwcstart        buf.wc._pwcstart
#define pchbuf          buf.ch._pchbuf
#define pchstart        buf.ch._pchstart

#define REG1 register
#define REG2 register

/* prototypes */
int _cdecl w4iooutput(struct w4io *stream, const char *format, va_list argptr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\uuid\makefile.inc ===
LIBDIR=$(SDK_LIB_DEST)
LIBFILE=$(TARGET_DIRECTORY)\uuidmon3.lib


$(LIBDIR)\chicago\$(LIBFILE) : $(LIBDIR)\$(LIBFILE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\utils\transhlp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       transhlp.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-05-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>

HMODULE g_hLibMlang = NULL;


//+---------------------------------------------------------------------------
//
//  Function:   SzW2ADynamic
//
//  Synopsis:   Convert Unicode string wzFrom to Ansi, and return the Ansi string.
//              The Ansi string will be written into szTo (whose size is cchTo bytes) if
//              szTo is nonNull AND it is large enough to hold the Ansi string.
//              If this is not the case, the Ansi string is dynamically allocated.
//              If 'fTaskMalloc', allocation is done thru IMalloc, otherwise it is done
//              thru new.
//
//  Arguments:  [wzFrom] --
//              [szTo] --
//              [cchTo] --
//              [fTaskMalloc] --
//
//  Returns:    If error returns NULL, otherwise returns
//              pointer to Ansi string (if different from szTo, it must be freed via
//              delete or IMalloc, as appropriate).
//
//  History:    x-xx-xx   Clarg                    Created
//              2-25-96   JohannP (Johann Posch)   Modified
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR SzW2ADynamic(LPCWSTR wzFrom, LPSTR szTo, int cchTo, BOOL fTaskMalloc)
{
    int cchRequired;
    char *pszT = NULL;

    cchRequired = WideCharToMultiByte(CP_ACP, 0, wzFrom, -1, NULL, 0, NULL, NULL);
    cchRequired++;
    TransAssert((cchRequired > 0));

    if (szTo && cchTo && (cchTo >= cchRequired))
    {
        // szTo has enough space
        pszT = szTo;
    }
    else
    {
        // szTo is not large enough; dynamically allocate the buffer
        if (fTaskMalloc)
        {
            pszT = (char*)CoTaskMemAlloc(sizeof(char) * cchRequired);
        }
        else
        {
            pszT = new char[cchRequired];
        }
        if (!pszT)
        {
            return NULL;
        }
    }

    if (!WideCharToMultiByte(CP_ACP, 0, wzFrom, -1, pszT, cchRequired, NULL, NULL))
    {
        //TransAssert((0));
        if (pszT != szTo)
        {
            (fTaskMalloc ? CoTaskMemFree(pszT) : delete pszT);
        }
        pszT = NULL;
    }

    return pszT;
}

//+---------------------------------------------------------------------------
//
//  Function:   WzA2WDynamic
//
//  Synopsis:   Convert Ansi string szFrom to Unicode, and return the Unicode string.
//              The Unicode string will be written into wzTo (whose size is cwchTo bytes)
//              if wzTo is nonNull AND it is large enough to hold the Unicode string.
//              If this is not the case, the Unicode string is dynamically allocated.
//              If 'fTaskMalloc', allocation is done thru IMalloc, otherwise it is done
//              thru new.
//
//  Arguments:  [szFrom] --
//              [wzTo] --
//              [cwchTo] --
//              [fTaskMalloc] --
//
//  Returns:    If error returns NULL, otherwise returns
//              pointer to Unicode string (if different from wzTo, it must be freed via
//              delete or IMalloc, as appropriate).
//
//  History:    x-xx-xx   Clarg                    Created
//              2-25-96   JohannP (Johann Posch)   modified
//
//  Notes:
//
//----------------------------------------------------------------------------
LPWSTR WzA2WDynamic(LPCSTR szFrom, LPWSTR wzTo, int cwchTo, BOOL fTaskMalloc)
{
    int cwchRequired;
    WCHAR *pwzT = NULL;

    cwchRequired = MultiByteToWideChar(CP_ACP, 0, szFrom, -1, NULL, 0);
    cwchRequired++;
    TransAssert((cwchRequired > 0));

    if (wzTo && cwchTo && (cwchTo >= cwchRequired))
    {
        // wzTo has enough space
        pwzT = wzTo;
    }
    else
    {
        // wzTo is not large enough; dynamically allocate the buffer
        if (fTaskMalloc)
        {
            pwzT = (WCHAR*)CoTaskMemAlloc(sizeof(WCHAR) * cwchRequired);
        }
        else
        {
            pwzT = new WCHAR[cwchRequired];
        }

        if (!pwzT)
        {
            return NULL;
        }
    }

    if (!MultiByteToWideChar(CP_ACP, 0, szFrom, -1, pwzT, cwchRequired))
    {
        //Assert(0);
        if (pwzT != wzTo)
        {
            (fTaskMalloc ? CoTaskMemFree(pwzT) : delete pwzT);
        }

        pwzT = NULL;
    }

    return pwzT;
}

//+---------------------------------------------------------------------------
//
//  Function:   OLESTRDuplicate
//
//  Synopsis:
//
//  Arguments:  [ws] --
//
//  Returns:
//
//  History:    2-25-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPWSTR OLESTRDuplicate(LPCWSTR ws)
{
    DWORD cLen;
    LPWSTR wsNew = NULL;

    if (ws)
    {
        wsNew = (LPWSTR) new  WCHAR [wcslen(ws) + 1];
        if (wsNew)
        {
            wcscpy(wsNew, ws);
        }
    }

    return wsNew;
}


//+-------------------------------------------------------------------------
//
//  Function:   WideCharToMultiByteWithMlang
//
//  Synopsis:   Convert Unicode string wzFrom to Ansi by uring MLANG, 
//
//  History:    5-29-97   DanpoZ (Danpo Zhang)     Created
//
//  Notes:
//
//--------------------------------------------------------------------------
void WideCharToMultiByteWithMlang(
    LPCWSTR lpwszWide,
    LPSTR   lpszAnsi,
    int     cchAnsi,
    DWORD   dwCodePage)
{
    INT cchOut;
    INT cchIn = wcslen(lpwszWide);
    HRESULT hr = NOERROR;

    typedef HRESULT (WINAPI * pfnMLANGW2A)(
        LPDWORD, DWORD, LPCWSTR, LPINT, LPSTR, LPINT);

    static pfnMLANGW2A pfnConvertINetUnicodeToMultiByte = NULL;

    if(!g_hLibMlang)
    {
        g_hLibMlang = LoadLibraryA("mlang.dll");
        if(!g_hLibMlang)
        {
            goto End;
        }
    }

    if (!pfnConvertINetUnicodeToMultiByte)
    {
        pfnConvertINetUnicodeToMultiByte= (pfnMLANGW2A)GetProcAddress(
            g_hLibMlang, "ConvertINetUnicodeToMultiByte");
        if (!pfnConvertINetUnicodeToMultiByte)
        {
            goto End;
        }
    }
        

    // first call to get the lenth of the Multi-Byte string 
    hr = pfnConvertINetUnicodeToMultiByte(
        NULL, dwCodePage, lpwszWide, &cchIn, NULL, &cchOut);

    if( !FAILED(hr) && cchOut <= cchAnsi )
    {
        hr = pfnConvertINetUnicodeToMultiByte(
            NULL, dwCodePage, lpwszWide, &cchIn, lpszAnsi, &cchOut);
    }

End:;
    
}

DWORD StrLenMultiByteWithMlang(
    LPCWSTR lpwszWide,
    DWORD   dwCodePage)
{
    INT cchOut;
    INT cchIn = wcslen(lpwszWide);
    HRESULT hr = NOERROR;

    typedef HRESULT (WINAPI * pfnMLANGW2A)(
        LPDWORD, DWORD, LPCWSTR, LPINT, LPSTR, LPINT);

    static pfnMLANGW2A pfnConvertINetUnicodeToMultiByte = NULL;

    if(!g_hLibMlang)
    {
        g_hLibMlang = LoadLibraryA("mlang.dll");
        if(!g_hLibMlang)
        {
            goto Error;
        }
    }

    if (!pfnConvertINetUnicodeToMultiByte)
    {
        pfnConvertINetUnicodeToMultiByte= (pfnMLANGW2A)GetProcAddress(
            g_hLibMlang, "ConvertINetUnicodeToMultiByte");
        if (!pfnConvertINetUnicodeToMultiByte)
        {
            goto Error;
        }
    }
        

    // first call to get the lenth of the Multi-Byte string 
    hr = pfnConvertINetUnicodeToMultiByte(
        NULL, dwCodePage, lpwszWide, &cchIn, NULL, &cchOut);

    if( !FAILED(hr) )
    {
        return cchOut;
    }

Error:
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\uuid\guids.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       GUIDS.C
//
//  Contents:   Defines GUIDS used in this DLL.
//
//  Classes:
//
//  Functions:
//
//  History:    11-02-95   JoeS (Joe Souza)     Created
//
//----------------------------------------------------------------------------
//#include <urlint.h>


#ifdef __cplusplus
extern "C" {
#endif

// CLSIDs of the classes implemented in this dll
//DEFINE_GUID(CLSID_URLMoniker, 0x79eac9e0, 0xbaf9, 0x11ce, 0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);


#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} GUID;
#endif // GUID_DEFINED

const GUID CLSID_StdURLMoniker =
{
    0x79eac9e0, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b }
};
const GUID CLSID_StdURLProtocol =
{
    0x79eac9e1, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};
const GUID CLSID_HttpProtocol =
{
    0x79eac9e2, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};
const GUID CLSID_FtpProtocol =
{
    0x79eac9e3, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};
const GUID CLSID_GopherProtocol =
{
    0x79eac9e4, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};
const GUID CLSID_HttpSProtocol =
{
    0x79eac9e5, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};
const GUID CLSID_FileProtocol =
{
    0x79eac9e6, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};

const GUID CLSID_MkProtocol =
{
    0x79eac9e7, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};

const GUID CLSID_PSUrlMonProxy =
{
    0x79eac9f1, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};

const GUID IID_IAsyncMoniker =
{
    0x79eac9d3, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};

const GUID CLSID_PluginHost =
{
    0x25336920, 0x03F9, 0x11cf, {0x8F, 0xD0, 0x00, 0xAA, 0x00, 0x68, 0x6F, 0x13}
}


#ifdef __cplusplus
}
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\wcheckcb\status.cxx ===
#include "Status.h"
#include "..\\inc\\urlmon.hxx"

#define TIMEOUT 600000 // 10 minutes

/******************************************************************************

    Constructor and destructor and helper functions

******************************************************************************/

CSilentCodeDLSink::CSilentCodeDLSink()
{
    m_cRef = 1;
    m_pBinding = NULL;
    m_hOnStopBindingEvt = CreateEvent(NULL, TRUE, FALSE, NULL);
    m_fAbort = FALSE;
}

CSilentCodeDLSink::~CSilentCodeDLSink()
{
    if(m_hOnStopBindingEvt)
		CloseHandle(m_hOnStopBindingEvt);	
}

VOID CSilentCodeDLSink::Abort()
{
    m_fAbort = TRUE;
}

HRESULT CSilentCodeDLSink::WaitTillNotified()
{
    if (m_hOnStopBindingEvt == NULL)
        return E_FAIL;

    HRESULT hr = E_FAIL;
    DWORD dwResult = 0;
    const DWORD MORE_INPUT = WAIT_OBJECT_0 + 1;
    MSG msg;

    // Test state of event
    dwResult = WaitForSingleObject(m_hOnStopBindingEvt, 0);
    if (dwResult == WAIT_FAILED)
        return HRESULT_FROM_WIN32(GetLastError());

    // Note that MsgWaitForMultipleObjects doesn't return 
    // if there was previously unread input of the specified 
    // type in the queue. It only wakes up when input arrives. 

    for (dwResult = MORE_INPUT; dwResult == MORE_INPUT; ) 
    {
        if (dwResult == MORE_INPUT)
        {
            // more input in queue
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
        else if (dwResult == WAIT_OBJECT_0)
        {
            // event has been signaled
            hr = S_OK;
        }
        else if (dwResult == 0xFFFFFFFF)
        {
            // error has occurred
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            // timeout or wait abondaned
            hr = E_FAIL;
        }
        
        dwResult = MsgWaitForMultipleObjects(
                                  1, &m_hOnStopBindingEvt, 
                                  FALSE, TIMEOUT, QS_ALLINPUT);
    }

    if (FAILED(hr))
        Abort();

    return hr;
}

/******************************************************************************

    IUnknown Methods

******************************************************************************/

STDMETHODIMP CSilentCodeDLSink::QueryInterface(REFIID riid, void **ppv)
{
   *ppv = NULL;

    if (riid == IID_IUnknown || riid == IID_IBindStatusCallback)
	{
        *ppv = (IBindStatusCallback*)this;
	}
	else if (riid == IID_ICodeInstall)
	{
		*ppv = (ICodeInstall*)this;
	}
	else if (riid == IID_IWindowForBindingUI)
	{
		*ppv = (IWindowForBindingUI*)this;
	}

	if (*ppv != NULL)
	{
	    ((IUnknown*)*ppv)->AddRef();
    	return S_OK;
	}

	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSilentCodeDLSink::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CSilentCodeDLSink::Release()
{
    if (--m_cRef)
        return m_cRef;

    delete this;
    return 0;   
}

/******************************************************************************

    IBindStatusCallback Methods

******************************************************************************/

STDMETHODIMP CSilentCodeDLSink::OnStartBinding(DWORD grfBSCOption, IBinding *pib)
{
	if (m_pBinding != NULL)
        m_pBinding->Release();

    m_pBinding = pib;
	if (m_pBinding != NULL)
        m_pBinding->AddRef();

	if (m_fAbort)
		m_pBinding->Abort();

    return S_OK;
}

STDMETHODIMP CSilentCodeDLSink::GetPriority(LONG *pnPriority)
{
	if (m_fAbort)
		m_pBinding->Abort();

    return S_OK;
}

STDMETHODIMP CSilentCodeDLSink::OnLowResource(DWORD reserved)
{
	if (m_fAbort)
		m_pBinding->Abort();

    return S_OK;
}

STDMETHODIMP CSilentCodeDLSink::OnProgress(
                                    ULONG ulProgress,
                                    ULONG ulProgressMax,
                                    ULONG ulStatusCode,
                                    LPCWSTR szStatusText)
{
	if (m_fAbort)
		m_pBinding->Abort();

    return S_OK;
}

STDMETHODIMP CSilentCodeDLSink::OnStopBinding(
                                    HRESULT hresult, 
                                    LPCWSTR szError)
{
	if (m_pBinding)
    {
        m_pBinding->Release();
	    m_pBinding = NULL;
    }

    if(m_hOnStopBindingEvt)
		SetEvent(m_hOnStopBindingEvt);

    return S_OK;
}

STDMETHODIMP CSilentCodeDLSink::GetBindInfo(
                                    DWORD* pgrfBINDF, 
                                    BINDINFO* pbindInfo)
{
    if (!pgrfBINDF || !pbindInfo || !pbindInfo->cbSize)
        return E_INVALIDARG;

    *pgrfBINDF = BINDF_ASYNCHRONOUS|BINDF_SILENTOPERATION;

    // clear BINDINFO but keep its size
    DWORD cbSize = pbindInfo->cbSize;
    ZeroMemory( pbindInfo, cbSize );
    pbindInfo->cbSize = cbSize;

    return S_OK;
}

STDMETHODIMP CSilentCodeDLSink::OnDataAvailable(
                                        DWORD grfBSCF, 
                                        DWORD dwSize,
                                        FORMATETC *pformatetc,
                                        STGMEDIUM *pstgmed)
{
	if (m_fAbort)
		m_pBinding->Abort();

    return S_OK;
}

STDMETHODIMP CSilentCodeDLSink::OnObjectAvailable(
                                            REFIID riid,
                                            IUnknown *punk)
{
    return S_OK;
}

/******************************************************************************

    ICodeInstall Methods

******************************************************************************/

STDMETHODIMP CSilentCodeDLSink::GetWindow(
                                    REFGUID rguidReason, 
                                    HWND *phwnd)
{
    *phwnd = (HWND)INVALID_HANDLE_VALUE;

	if (m_fAbort)
		m_pBinding->Abort();

    return S_FALSE;
}

STDMETHODIMP CSilentCodeDLSink::OnCodeInstallProblem(
                                           ULONG ulStatusCode, 
                                           LPCWSTR szDestination, 
                                           LPCWSTR szSource, 
                                           DWORD dwReserved)
{
	switch (ulStatusCode)
	{
		case CIP_ACCESS_DENIED:
		case CIP_DISK_FULL:
			return E_ABORT;

		case CIP_OLDER_VERSION_EXISTS:
			return S_OK; // always update

		case CIP_NEWER_VERSION_EXISTS:
			return S_FALSE; // don't update

		case CIP_NAME_CONFLICT:
			return E_ABORT;

		case CIP_EXE_SELF_REGISTERATION_TIMEOUT:
			return S_OK;

		case CIP_TRUST_VERIFICATION_COMPONENT_MISSING:
			return E_ABORT; 

		case CIP_UNSAFE_TO_ABORT:
			return S_OK;

		default:
			return E_ABORT;
    }

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\wcheckcb\status.h ===
#ifndef __SILENT_BINDSTATUS__
#define __SILENT_BINDSTATUS__

#include <urlmki.h>

class CSilentCodeDLSink : public IBindStatusCallback, 
                          public ICodeInstall
{
public:
    CSilentCodeDLSink();
    ~CSilentCodeDLSink();

    // Helper function
    HRESULT WaitTillNotified();
    VOID Abort();

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IBindStatusCallback
    STDMETHODIMP OnStartBinding(
        /* [in] */ DWORD grfBSCOption,
        /* [in] */ IBinding *pib);
    STDMETHODIMP GetPriority(
        /* [out] */ LONG *pnPriority);
    STDMETHODIMP OnLowResource(
        /* [in] */ DWORD reserved);
    STDMETHODIMP OnProgress(
        /* [in] */ ULONG ulProgress,
        /* [in] */ ULONG ulProgressMax,
        /* [in] */ ULONG ulStatusCode,
        /* [in] */ LPCWSTR szStatusText);
    STDMETHODIMP OnStopBinding(
        /* [in] */ HRESULT hresult,
        /* [in] */ LPCWSTR szError);
    STDMETHODIMP GetBindInfo(
        /* [out] */ DWORD *grfBINDINFOF,
        /* [unique][out][in] */ BINDINFO *pbindinfo);
    STDMETHODIMP OnDataAvailable(
        /* [in] */ DWORD grfBSCF,
        /* [in] */ DWORD dwSize,
        /* [in] */ FORMATETC *pformatetc,
        /* [in] */ STGMEDIUM *pstgmed);
    STDMETHODIMP OnObjectAvailable(
        /* [in] */ REFIID riid,
        /* [iid_is][in] */ IUnknown *punk);

    // ICodeInstall methods
    STDMETHODIMP GetWindow(
                    REFGUID rguidReason,
        /* [out] */ HWND *phwnd);
    STDMETHODIMP OnCodeInstallProblem(
                   ULONG ulStatusCode, 
                   LPCWSTR szDestination, 
                   LPCWSTR szSource, 
                   DWORD dwReserved);

protected:

    BOOL            m_fAbort;
    DWORD           m_cRef;
    IBinding*       m_pBinding;
    HANDLE			m_hOnStopBindingEvt;	// Handle to manual reset events
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\wcheckcb\factory.cxx ===
#include "..\\inc\\urlint.h"
#include "..\\inc\\wcheckcb.h"
#include "..\\inc\\debug.h"

// createion method
STDMETHODIMP CreateCallbackClassFactory(IClassFactory** ppCF)
{
    *ppCF = (IClassFactory*)new CCallbackObjFactory;
    
    if (*ppCF == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

// constructor
CCallbackObjFactory::CCallbackObjFactory()
{
    DllAddRef();
    m_cRef = 1;
    m_cLocks = 0;
}

// destructor
CCallbackObjFactory::~CCallbackObjFactory()
{
    Assert(m_cRef == 0 && m_cLocks == 0);
    DllRelease();
}


/******************************************************************************
    IUnknown methods
******************************************************************************/

STDMETHODIMP CCallbackObjFactory::QueryInterface(REFIID iid, void** ppvObject)
{
    *ppvObject = NULL;

    if (iid == IID_IUnknown || iid == IID_IClassFactory)
    {
        *ppvObject = (void*)this;
        ((LPUNKNOWN)*ppvObject)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CCallbackObjFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CCallbackObjFactory::Release(void)
{
    if (--m_cRef)
        return m_cRef;

    delete this;
    return 0;
}


/******************************************************************************
    IClassFactory methods
******************************************************************************/

STDMETHODIMP CCallbackObjFactory::CreateInstance(
                                          LPUNKNOWN pUnkOuter, 
                                          REFIID riid, 
                                          LPVOID* ppv)
{
    *ppv = NULL;
    HRESULT hr = S_OK;

    if (pUnkOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    CControlRefreshCallback *pCRC = new CControlRefreshCallback;
    if (pCRC == NULL)
        return E_OUTOFMEMORY;

    hr = pCRC->QueryInterface(riid, ppv);
    pCRC->Release();

    return hr;
}

STDMETHODIMP CCallbackObjFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\zones\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef REZ  // Mac resource compiler (mrc) defines REZ
#define RC_INVOKED
#endif

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// Tab Control styles
#ifndef TCS_MULTILINE // new in later versions of Win32
#define TCS_MULTILINE       0x0200
#endif

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0xFFFFL


// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
	// -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#ifdef _MAC
#define AFX_IDS_ABOUT                   0xF010
#endif
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2A0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2A0
#define AFX_IDP_DAO_DFX_BIND                    0xF2A1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2A2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2A3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2A4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2A5

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723
#ifdef _MAC
#define AFX_IDD_PREVIEW_SHORTTOOLBAR    30731
#endif

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\zones\regzone.h ===
//  File:       regzone.h
//
//  Contents:   Registry management for a single zone. 
//
//  Classes:    CRegZone
//
//  Functions:
//
//  History: 
//
//----------------------------------------------------------------------------

#ifndef _REGZONE_H_
#define _REGZONE_H_

// Constants corresponding to the registry.
#define MAX_REG_ZONE_CACHE      20
#define URLZONE_INVALID         URLZONE_USER_MAX+1

#define MAX_ZONE_NAME           240
#define MAX_ZONE_PATH           256    // This is "Standard\\ZoneName"
#define MAX_VALUE_NAME          256

#define ZONEID_INVALID          0xFFFFFFFF
#define URLZONE_FINDCACHEENTRY  0xFFFFFFFF

// There are two registry keys under which the information is copied. 
// One of them is "Zones" which holds the actual information and the other
// one is "TemplatePolicies" which holds the high medium and low policies. 
// This enumeration indicates which part of the registry to read. 

enum REGZONEUSE { REGZONEUSEZONES, REGZONEUSETEMPLATE };

class CRegZone 
{
public:
    CRegZone();
    // Seperate init function to allow for failure on return. 
    BOOL Init(LPCTSTR lpStr, BOOL bCreate = TRUE, REGZONEUSE regZoneUse = REGZONEUSEZONES, BOOL bSystem = TRUE);

    ~CRegZone();

    // Attributes
    DWORD GetZoneId() const  { return m_dwZoneId; }
    LPTSTR GetZoneName() const { return m_lpZoneName; }

    // Returns NULL terminated string, free using CoTaskFree
    STDMETHODIMP  GetZoneAttributes (ZONEATTRIBUTES& zoneAttrib);
    STDMETHODIMP  SetZoneAttributes (const ZONEATTRIBUTES& zoneAttrib);

    STDMETHODIMP  GetActionPolicy (DWORD dwAction, URLZONEREG urlZone, DWORD& dwPolicy) const;
    STDMETHODIMP  SetActionPolicy (DWORD dwAction, URLZONEREG urlZone, DWORD dwPolicy);

    STDMETHODIMP  GetCustomPolicy (REFGUID guid, URLZONEREG urlZone, BYTE** ppByte, DWORD *pcb) const; 
    STDMETHODIMP  SetCustomPolicy (REFGUID guid, URLZONEREG urlZone, BYTE* pByte, DWORD cb);

    STDMETHODIMP  CopyTemplatePolicies(DWORD dwTemplateIndex);

    BOOL  UpdateZoneMapFlags( );

    // Should we display this zone in the UI. 
    // Note that Zones not displayed in UI are not included in the zone enumeration.
    inline BOOL IsUIZone() const;
   
protected:
    inline IsValid() const { return (m_dwZoneId != ZONEID_INVALID); }
    inline BOOL UseHKLM(URLZONEREG urlZoneReg) const;
 
    // Helper functions
    inline BOOL IsHardCodedZone() const { return FALSE; }
    inline BOOL GetHardCodedZonePolicy(DWORD dwAction, DWORD& dwPolicy) const;


    inline BOOL  QueryTemplatePolicyIndex(CRegKey& regKey, LPCTSTR psz, LPDWORD pdw) const;
    inline BOOL  SetTemplatePolicyIndex(CRegKey& regKey, LPCTSTR psz, DWORD dw);
        
    static BOOL     IsAttributeName(LPCTSTR psz);
    static LPCTSTR  GetTemplateNameFromIndex ( URLTEMPLATE urlTemplateIndex);
    inline static BOOL     IsValidTemplateIndex( DWORD dwTemplateIndex ); 
    static BOOL     GetAggregateAction(DWORD dwAction, LPDWORD dwAggregateAction);
    static void     KludgeMapAggregatePolicy(DWORD dwAction, LPDWORD pdwAction);
    static VOID     IncrementGlobalCounter( );

// Methods/members to support caching
protected:

    class CRegZoneCache {
    public:
        CRegZoneCache(void);
        ~CRegZoneCache(void);

        BOOL Lookup(DWORD dwZone, LPTSTR lpZonePath, DWORD dwAction, BOOL fUseHKLM, DWORD *pdwPolicy);
        void Add(DWORD dwZone, DWORD dwAction, BOOL fUseHKLM, DWORD dwPolicy, int iEntry = URLZONE_FINDCACHEENTRY);
        void Flush(void);

        static VOID IncrementGlobalCounter( );

    protected:

        // Counters to flag cross-process cache invalidation.
        DWORD         m_dwPrevCounter ; // Global counter so we can correctly invalidate the cache if 
                                        // user changes options.
        static HANDLE s_hMutexCounter;  // mutex controlling access to shared memory counter.
 
        BOOL IsCounterEqual() const;
        VOID SetToCurrentCounter();

        // The body of the cache is this array of cache entries.
        // Cross-thread access control for the array is by critical section.

        CRITICAL_SECTION m_csectZoneCache; // assumes only one, static instance of the cache 


        struct CRegZoneCacheEntry {
            CRegZoneCacheEntry(void) :
                m_dwZone(ZONEID_INVALID),
                m_dwAction(0),
                m_fUseHKLM(FALSE),
                m_dwPolicy(0) {};
            ~CRegZoneCacheEntry(void) { Flush(); };

            void Set(DWORD dwZone, DWORD dwAction, BOOL fUseHKLM, DWORD dwPolicy);
            void Flush(void);
            
            DWORD      m_dwZone;
            DWORD      m_dwAction;
            BOOL       m_fUseHKLM;
            DWORD      m_dwPolicy;
        }; // CRegZoneCacheEntry

        CRegZoneCacheEntry   m_arzce[MAX_REG_ZONE_CACHE];
        int                  m_iAdd;

        BOOL FindCacheEntry(DWORD dwZone, DWORD dwAction, BOOL fUseHKLM, int& riEntry ); // must be called under critical section.

    }; // CRegZoneCache

    static CRegZoneCache s_rzcache;

private:

    DWORD  m_dwZoneId;
    DWORD  m_dwZoneFlags;
    LPTSTR m_lpZoneName;
    LPTSTR m_lpZonePath;

    BOOL m_bHKLMOnly;
    BOOL m_bStandard;         
    BOOL m_bZoneLockOut;         // Is the whole zone locked out. 
    REGZONEUSE m_regZoneUse;
};

typedef CRegZone *LPREGZONE;

BOOL CRegZone::UseHKLM(URLZONEREG urlZoneReg) const
{
    BOOL bReturn;

    switch(urlZoneReg)
    {
        case URLZONEREG_HKLM:
            bReturn = TRUE;
            break;
        case URLZONEREG_HKCU:
            bReturn = FALSE;
            break;
        case URLZONEREG_DEFAULT:
            bReturn = m_bHKLMOnly;
            break;
        default:
            TransAssert(FALSE);
    }

    return bReturn;
}

BOOL CRegZone::IsValidTemplateIndex(DWORD dwTemplateIndex)
{
    BOOL bReturn = FALSE;

    switch (dwTemplateIndex)    
    {
        case URLTEMPLATE_CUSTOM:
        case URLTEMPLATE_LOW:
        case URLTEMPLATE_MEDLOW:
        case URLTEMPLATE_MEDIUM:
        case URLTEMPLATE_HIGH:
            bReturn = TRUE;
            break;
    }
    return bReturn;
}

BOOL CRegZone::QueryTemplatePolicyIndex(CRegKey& regKey, LPCTSTR psz, LPDWORD pdw) const
{
    LONG lRet;

    lRet = regKey.QueryValue(pdw, psz);

    if (NO_ERROR != lRet)
    {
        *pdw = URLTEMPLATE_CUSTOM;
    }
    else if (*pdw < URLTEMPLATE_PREDEFINED_MIN || *pdw > URLTEMPLATE_PREDEFINED_MAX)
    {
        // Invalid value, just return back default.
        *pdw = URLTEMPLATE_CUSTOM;
    }

    return TRUE;
}

BOOL CRegZone::SetTemplatePolicyIndex(CRegKey& regKey, LPCTSTR psz, DWORD dwIndex)
{   
    // Write this only if it is a valid template index. 
    if (IsValidTemplateIndex(dwIndex))
    {
        if (regKey.SetValue(dwIndex, psz) == NO_ERROR)
            return TRUE;
    }
    else 
    {
        TransAssert(FALSE); 
    }

    return FALSE;
}


BOOL CRegZone::GetHardCodedZonePolicy(DWORD dwAction, DWORD& dwPolicy) const
{
    TransAssert(IsHardCodedZone());

    if (!IsHardCodedZone())
        return FALSE;

    switch(dwAction)
    {
        case URLACTION_JAVA_PERMISSIONS:
            dwPolicy = URLPOLICY_JAVA_HIGH;
            break;
        case URLACTION_CREDENTIALS_USE:
            dwPolicy = URLPOLICY_CREDENTIALS_SILENT_LOGON_OK;
            break;
        case URLACTION_AUTHENTICATE_CLIENT:
            dwPolicy = URLPOLICY_AUTHENTICATE_CLEARTEXT_OK;
            break; 
        case URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY:
            dwPolicy = URLPOLICY_QUERY;
            break;          
        default:
            dwPolicy = 0;
            break;
    }

    return TRUE;
}

BOOL CRegZone::IsUIZone() const
{
    return (m_dwZoneFlags & ZAFLAGS_NO_UI) ? FALSE : TRUE;
}

// This is the class that maintains the list of the RegZones currently in action

class CRegZoneContainer
{
public:

    CRegZoneContainer();
    ~CRegZoneContainer();

public:
    BOOL Attach(BOOL bUseHKLM, REGZONEUSE regZoneUse = REGZONEUSEZONES);
    BOOL Detach();
    BOOL SelfHeal(BOOL bUseHKLM);

    CRegZone * GetRegZoneByName(LPCTSTR lpszZoneName) const;
    CRegZone * GetRegZoneById(DWORD dwZoneId) const;
    DWORD  GetZoneCount() const { return m_cZones; };

    STDMETHODIMP CreateZoneEnumerator(DWORD *pdwEnum, DWORD *pdwCount);
    STDMETHODIMP GetZoneAt(DWORD dwEnum, DWORD dwIndex, DWORD *pdwZone);
    STDMETHODIMP DestroyZoneEnumerator(DWORD dwEnum);

protected:
   // Used internally only.
   struct CRegListElem {
        CRegListElem * next;
        CRegZone     * pRegZone;
        DWORD   dwZoneIndex;
    };

    struct CZoneEnumList {
        DWORD dwEnum;   // Cookie indicating which enum this corresponds to.
        CZoneEnumList * next;
    };

    CZoneEnumList * m_pZoneEnumList;
    DWORD m_dwNextEnum;

    // Is this enumerator a valid enumerator.
    BOOL VerifyZoneEnum(DWORD dwEnum) const;

private:

    CRegZone**  m_ppRegZones;        // Array of RegZones.
    DWORD       m_cZones;             // # of Zones.
    BOOL        m_bHKLMOnly;
    CRITICAL_SECTION m_csect;
};
                                    
#endif  // _REGZONE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\wcheckcb\wcheckcb.cxx ===
#include <urlmon.h>
#include <htmlguid.h>
#include <ocidl.h>
#include "..\\inc\\urlint.h"
#include "..\\inc\\wcheckcb.h"
#include "..\\inc\\debug.h"
#include "..\\download\\cdl.h"
#include "Status.h"

// {5DFE9E81-46E4-11d0-94E8-00AA0059CE02}
const CLSID CLSID_ControlRefreshCallback = {
                                0x5dfe9e81, 0x46e4, 0x11d0, 
                                0x94, 0xe8, 0x0, 0xaa, 0x0, 
                                0x59, 0xce, 0x2
                                };

const static TCHAR *g_pszUpdateInfo = TEXT("UpdateInfo");
const static TCHAR *g_pszNewControlInCache = TEXT("NewControlInCache");

#define CLSID_MAX_LENGTH 50
#define CONTENT_MAX_LENGTH 1024

/******************************************************************************
    Constructor, Destructor and helper methods
******************************************************************************/

CControlRefreshCallback::CControlRefreshCallback()
{
    DllAddRef();
    m_cRef = 1;
    m_clsidCtrl = CLSID_NULL;
    m_wszURL[0] = '\0';
}

CControlRefreshCallback::~CControlRefreshCallback()
{
    Assert(m_cRef == 0);
    DllRelease();
}

// Give this object information such as the clsid and url of the control
// it's dealing with 
STDMETHODIMP CControlRefreshCallback::SetInfo(
                                        REFCLSID rclsidControl,
                                        LPCWSTR lpwszURL)
{
    m_clsidCtrl = rclsidControl;

    // copy wide strings
#ifdef UNICODE
    lstrcpyW(m_wszURL, lpwszURL);   // only works in Win32 mode
                                    // fails on Win95
#else
    INT i = 0;
    for(; lpwszURL[i]; i++)
        m_wszURL[i] = lpwszURL[i];
    m_wszURL[i] = '\0';
#endif

    Assert(lstrlenW(m_wszURL) == lstrlenW(lpwszURL));

    return S_OK;
}

/*
HRESULT CControlRefreshCallback::UpdateControlInCacheFlag(
                                               SCODE scReason) const
{
    // update flag in registry so that IE initiates a new
    // download when the control is visited.

    LONG lResult = ERROR_SUCCESS;
    TCHAR szKey[MAX_PATH];
    LPOLESTR pwcsClsid = NULL;
    BOOL fChanged = (scReason == S_OK);

    lstrcpy(szKey, TEXT("CLSID\\"));

    if (SUCCEEDED(::StringFromCLSID(m_clsidCtrl, &pwcsClsid)))
    {
        HKEY hKey = NULL;
        int nLen = lstrlen(szKey);

        if (WideCharToMultiByte(
                           CP_ACP, 0, pwcsClsid, -1, szKey + nLen, 
                           MAX_PATH - nLen, NULL, NULL) > 0)
        {
            lstrcat(szKey, "\\");
            lstrcat(szKey, g_pszUpdateInfo);
            lResult = RegOpenKeyEx(
                              HKEY_CLASSES_ROOT, szKey, 0, 
                              KEY_ALL_ACCESS, &hKey); 

            if (lResult == ERROR_SUCCESS)
            {
                DWORD dwKeySet = 0;
                DWORD dwSize = sizeof(DWORD);
                lResult = RegQueryValueEx(
                                    hKey, g_pszNewControlInCache, NULL, NULL,
                                    (LPBYTE)&dwKeySet, &dwSize);

                if (lResult != ERROR_SUCCESS || (dwKeySet == 0 && fChanged))
                {
                    dwKeySet = (fChanged ? 1 : 0);
                    lResult = RegSetValueEx(
                                    hKey, g_pszNewControlInCache, 0, 
                                    REG_DWORD, (LPBYTE)&dwKeySet, sizeof(DWORD));
                }
                RegCloseKey(hKey);
            }
        }

        delete pwcsClsid;
    }

    return (lResult == ERROR_SUCCESS ? S_OK : HRESULT_FROM_WIN32(lResult));
}
*/

HRESULT CControlRefreshCallback::DownloadControl() const
{
    HRESULT hr = S_OK;
    CSilentCodeDLSink *pscdls = NULL;
    LPBC pbc = NULL;

    Assert(lstrlenW(m_wszURL) > 0);
    Assert(m_clsidCtrl != CLSID_NULL);

    pscdls = new CSilentCodeDLSink;
    if (pscdls == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = CreateBindCtx(0, &pbc);
    if (SUCCEEDED(hr))
        hr = RegisterBindStatusCallback(pbc, pscdls, NULL, 0);

    if (FAILED(hr))
        goto Exit;

    hr = AsyncGetClassBits(
                       m_clsidCtrl, NULL, NULL, 
                       (DWORD)-1, (DWORD)-1, m_wszURL,
                       pbc, CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER, 
                       NULL, IID_IClassFactory, 0);

    if (hr == MK_S_ASYNCHRONOUS)
        hr = pscdls->WaitTillNotified();

    RevokeBindStatusCallback(pbc, pscdls);

Exit:

    if (pbc)
        pbc->Release();

    if (pscdls)
        pscdls->Release();

    return hr;
}

/******************************************************************************
    IUnknown Methods
******************************************************************************/

STDMETHODIMP CControlRefreshCallback::QueryInterface(
                                                REFIID iid, 
                                                void** ppvObject)
{
    *ppvObject = NULL;

    if (iid == IID_IUnknown)
    {
        *ppvObject = (void*)this;
    }
    else if (iid == IID_IPersistStream)
    {
        *ppvObject = (void*)(IPersistStream*)this;
    }
    else if (iid == IID_IWebCheckAdviseSink)
    {
        *ppvObject = (void*)(IWebCheckAdviseSink*)this;
    }

    if (*ppvObject) 
    {
        ((LPUNKNOWN)*ppvObject)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CControlRefreshCallback::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CControlRefreshCallback::Release()
{
    if (--m_cRef)
        return m_cRef;

    delete this;
    return 0;   
}


/******************************************************************************
    IPersistStream Methods
******************************************************************************/

STDMETHODIMP CControlRefreshCallback::GetClassID(CLSID* pClsssID)
{
    *pClsssID = CLSID_ControlRefreshCallback;
    return S_OK;
}

STDMETHODIMP CControlRefreshCallback::IsDirty(void)
{
    Assert(m_clsidCtrl != CLSID_NULL);
    return (m_clsidCtrl != CLSID_NULL ? S_OK : S_FALSE);
}

STDMETHODIMP CControlRefreshCallback::Load(IStream* pStm)
{
    DWORD dwLen = 0;

    ULONG cb = sizeof(CLSID);
    ULONG cbRead = 0;
    pStm->Read((void*)&m_clsidCtrl, cb, &cbRead);
    Assert(cb == cbRead);
    if (cb != cbRead)
        goto Exit;

    cb = sizeof(DWORD);
    cbRead = 0;
    pStm->Read((void*)&dwLen, cb, &cbRead);
    Assert(cb == cbRead);
    if (cb != cbRead)
        goto Exit;

    cb = dwLen * sizeof(WCHAR);
    cbRead = 0;
    pStm->Read((void*)&m_wszURL, cb, &cbRead);
    Assert(cb == cbRead);

    Assert((DWORD)lstrlenW(m_wszURL) == dwLen - 1);

Exit:

    return (cbRead == cb ? S_OK : E_FAIL);
}

STDMETHODIMP CControlRefreshCallback::Save(IStream* pStm, BOOL fClearDirty)
{
    DWORD dwLen = lstrlenW(m_wszURL) + 1;    // add 1 for NULL char

    ULONG cb = sizeof(CLSID);
    ULONG cbSaved = 0;
    pStm->Write((void*)&m_clsidCtrl, cb, &cbSaved);
    Assert(cb == cbSaved);
    if (cb != cbSaved)
        goto Exit;

    cb = sizeof(DWORD);
    cbSaved = 0;
    pStm->Write((void*)&dwLen, cb, &cbSaved);
    Assert(cb == cbSaved);
    if (cb != cbSaved)
        goto Exit;

    cb = dwLen * sizeof(WCHAR);
    cbSaved = 0;
    pStm->Write((void*)m_wszURL, cb, &cbSaved);
    Assert(cb == cbSaved);

Exit:

    return (cbSaved == cb ? S_OK : E_FAIL);
}

STDMETHODIMP CControlRefreshCallback::GetSizeMax(ULARGE_INTEGER* pcbSize)
{
    pcbSize->QuadPart = sizeof(CLSID) + sizeof(DWORD) + sizeof(m_wszURL);
    return S_OK;
}


/******************************************************************************
    IWebCheckAdviseSink Methods
******************************************************************************/

STDMETHODIMP CControlRefreshCallback::UpdateBegin(
                                              long lCookie, 
                                              SCODE scReason, 
                                              BSTR lpURL)
{
    return S_OK;
}

// scReason -- S_OK means changed, S_FALSE means no changes
STDMETHODIMP CControlRefreshCallback::UpdateEnd(
                                            long lCookie, 
                                            SCODE scReason)
{
    Assert(m_clsidCtrl != CLSID_NULL);
    LONG lResult = ERROR_SUCCESS;

    if (scReason == S_OK)
    {
        DownloadControl();
//        UpdateControlInCacheFlag(scReason);
    }

    return S_OK;
}

STDMETHODIMP CControlRefreshCallback::UpdateProgress(
                                                 long lCookie, 
                                                 long lCurrent, 
                                                 long lMax)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\zones\regzone.cxx ===
//  File:       regzone.cxx
//
//  Contents:   Registry management for a single zone. 
//
//  Classes:    CRegZone
//
//  Functions:
//
//  History: 
//
//----------------------------------------------------------------------------

#include "zonepch.h"

// Max # of chars to the root of the zones tree (SZZONES, SZTEMPLATE,...)

#define MAX_REGZONE_ROOT        100

// Value names in the registry
#define SZZONEINDEX             __TEXT("ZoneIndex")
#define SZTEMPLATEINDEX         __TEXT("TemplateIndex")
#define SZDISPLAYNAME           __TEXT("DisplayName")
#define SZICON                  __TEXT("Icon")
#define SZDESCRIPTION           __TEXT("Description")
#define SZFLAGS                 __TEXT("Flags")

// Registry key names for the template policies


#define SZLOW                   __TEXT("Low")
#define SZMEDLOW                __TEXT("MedLow")
#define SZMEDIUM                __TEXT("Medium")
#define SZHIGH                  __TEXT("High")


CRegZone::CRegZoneCache CRegZone::s_rzcache;
HANDLE CRegZone::CRegZoneCache::s_hMutexCounter;

// Array of Value Names corresponding to zone attributes.
// These values will not be copied when doing a mass copy 
// from a template zone (HIGH, MED, LOW) to a zone. 
static LPCTSTR rgszAttributeNames [ ] = 
{
    __TEXT(""),            // The default value is excluded as well. 
    SZZONEINDEX,
    SZTEMPLATEINDEX,
    SZDISPLAYNAME,
    SZDESCRIPTION,
    SZICON,
    SZFLAGS,
    SZMINLEVEL,
    SZRECLEVEL,
    SZCURRLEVEL,
};

struct templateNameIdxMap
{
    URLTEMPLATE index;
    LPCTSTR    pszName;
};

static templateNameIdxMap 
TemplateNameIdxMap [ ] = 
{    
    { URLTEMPLATE_LOW,          SZLOW },
    { URLTEMPLATE_MEDLOW,       SZMEDLOW},
    { URLTEMPLATE_MEDIUM,       SZMEDIUM},
    { URLTEMPLATE_HIGH,         SZHIGH}
};     
     
 


// CRegZone implementation.

CRegZone::CRegZone()
{
    // defaults
    m_dwZoneId  =  ZONEID_INVALID;
    m_dwZoneFlags = ZAFLAGS_ADD_SITES;  // BUGBUG: what is the right default here. 
    m_lpZoneName = NULL;
    m_lpZonePath = NULL;

    m_bStandard = TRUE;    
    m_bZoneLockOut = FALSE;
    m_bHKLMOnly = TRUE;
}     

CRegZone::~CRegZone()
{
    LocalFree((HLOCAL)m_lpZoneName);    
    LocalFree((HLOCAL)m_lpZonePath);
}

// Sets up the CRegZone object a given string. 
// If the setting is in the Zones key the string passed in is the actual
// zone index. Otherwise it is one of the "High", "Medium", "Low" strings which indicates
// a template policy. 

BOOL CRegZone::Init(LPCWSTR lpwStr, BOOL bUseHKLMOnly, REGZONEUSE regZoneUse, BOOL bCreate /*=TRUE*/)
{
    TransAssert(lpwStr != NULL);
    if (lpwStr == NULL)
    {
        return FALSE;
    }

    m_bHKLMOnly = bUseHKLMOnly;
    m_regZoneUse = regZoneUse;

    TCHAR szTemp[MAX_REGZONE_ROOT + MAX_ZONE_NAME];

    StrCpyW(szTemp, (regZoneUse == REGZONEUSEZONES? SZZONES : SZTEMPLATE));
    StrCatW(szTemp, lpwStr);

    m_lpZonePath = StrDup(szTemp);
    if(!m_lpZonePath)
    {
        return FALSE;
    }
    m_lpZoneName = StrDup(lpwStr);
    if(!m_lpZoneName)
    {
        return FALSE;
    }

    CRegKey regKey(bUseHKLMOnly);

    if (regKey.Open(NULL, m_lpZonePath, KEY_READ) != ERROR_SUCCESS) 
    {
        // BUGBUG:: We have to be able to deal with this. situation and not just bail.
        // Possibilities: Setup defaults here if we can create and write to the key
        return FALSE;
    }


    // Add code here to 
    DWORD dwZoneId = ZONEID_INVALID;

    // Get the Zone Index.
    if ( regZoneUse == REGZONEUSEZONES )
    {
        // The Zone Id for the string is the same as the key name.
        // Just convert the string 
        m_dwZoneId = StrToInt(m_lpZoneName);
    }
    else if (regZoneUse == REGZONEUSETEMPLATE )
    {
        if (regKey.QueryValue(&dwZoneId, SZTEMPLATEINDEX) == ERROR_SUCCESS)
            m_dwZoneId = dwZoneId;
        else
        {
            // Could happen if the registry is messed up. 
            TransAssert(FALSE);
        }
    }
    else 
    {
        TransAssert(FALSE);
    }       

    // Get the zone flags
    if (regKey.QueryValue(&m_dwZoneFlags, SZFLAGS) != ERROR_SUCCESS)
    {
        m_dwZoneFlags = ZAFLAGS_ADD_SITES;      // What is the right value here.
    }            
    else
    {
        // return value from UpdateZoneMapFlags ignored.  
        UpdateZoneMapFlags( );
    }                
    // Check and make sure the zone Id's are within range.             
    // Assert that the zone ID's are in the appropriate user or standard range.
                    
    return TRUE;
}

// This updates the flags in the ZoneMap part of the registry which correspond to the 
// ZAFLAGS_. For convenience the UI will only update the ZAFLAGS.


BOOL CRegZone::UpdateZoneMapFlags( )
{
    // ProxyByPass is current controlled by the ProxyByPass flag, not the zoneAttrib.
    if (m_dwZoneId == URLZONE_INTRANET)
    {
        // If we are updating zonemap flags we have to invalidate any url to zone caches
        CSecurityManager::IncrementGlobalCounter( );
                
        CRegKey regZoneMap;
        if (ERROR_SUCCESS == regZoneMap.Open(NULL, SZZONEMAP, KEY_READ | KEY_WRITE))
        {
            if (m_dwZoneFlags & ZAFLAGS_INCLUDE_PROXY_OVERRIDE)
            {
                // We will succeed even if this fails.
                regZoneMap.SetValue(m_dwZoneId, SZPROXYBYPASS);
            }
            else 
            {
                regZoneMap.DeleteValue(SZPROXYBYPASS);
            }

            if (m_dwZoneFlags & ZAFLAGS_INCLUDE_INTRANET_SITES)
            {
                // We will succeed even if this fails.
                regZoneMap.SetValue(m_dwZoneId, SZINTRANETNAME);
            }
            else 
            {
                regZoneMap.DeleteValue(SZINTRANETNAME);
            }

            DWORD dwUncAsIntranet = (m_dwZoneFlags & ZAFLAGS_UNC_AS_INTRANET) ? 1 : 0 ;
            regZoneMap.SetValue(dwUncAsIntranet, SZUNCASINTRANET);

        }
    }
    return TRUE;
}

// Static functions.

VOID
CRegZone::IncrementGlobalCounter( )
{
    CRegZone::CRegZoneCache::IncrementGlobalCounter( );
}

BOOL CRegZone::IsAttributeName(LPCTSTR psz)
{
    DWORD dwMaxIndex = sizeof(rgszAttributeNames)/sizeof(rgszAttributeNames[0]);

    for ( DWORD dwIndex = 0 ; dwIndex < dwMaxIndex ; dwIndex++ )
    {
#ifndef UNIX
        if (0 == StrCmpW(psz, rgszAttributeNames[dwIndex]))
#else
        if (0 == lstrcmpi(psz, rgszAttributeNames[dwIndex]))
#endif
            return TRUE;
    }

    return FALSE;
}


LPCTSTR CRegZone::GetTemplateNameFromIndex(URLTEMPLATE urlTemplateIndex)
{
    DWORD dwMaxIndex = sizeof(TemplateNameIdxMap) / sizeof(TemplateNameIdxMap[0]);

    for (DWORD dwIndex = 0 ; dwIndex < dwMaxIndex ; dwIndex++ )
    {
        if (TemplateNameIdxMap[dwIndex].index == urlTemplateIndex)
            return TemplateNameIdxMap[dwIndex].pszName;
    }
    
    return NULL;
}
             
// These are static functions to deal with aggregate policies. 

// Because of the discrepancy between the UI and the actions defined,
// there are cases where the security manager munges the policies for certain actions.

inline void CRegZone::KludgeMapAggregatePolicy(DWORD dwAction, LPDWORD pdwPolicy)
{
    TransAssert(pdwPolicy != NULL);

    switch (dwAction)
    {
        case URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY:
        case URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY:
        case URLACTION_SCRIPT_OVERRIDE_SAFETY:
        {
            if (GetUrlPolicyPermissions(*pdwPolicy) == URLPOLICY_QUERY)
                SetUrlPolicyPermissions(*pdwPolicy, URLPOLICY_DISALLOW);
            break;
        }
    }
}
             

// Call this function to determine if an action is aggregated by some
// other action. 
// RETURNS : TRUE if there is an aggregate action corr to dwAction. 
//           also returns the action in pdwAggregate.
//           FALSE: if this action is not aggregated by some other action.
//           pdwAggregate is unchanged in this case.

inline BOOL CRegZone::GetAggregateAction(DWORD dwAction, LPDWORD pdwAggregate)
{
    DWORD dwAggregate = 0;
    BOOL bReturn = FALSE;
       
    TransAssert(dwAction >= URLACTION_MIN);
    
    switch(dwAction)
    {
        case URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY:
        case URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY:
        case URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY:
        case URLACTION_SCRIPT_OVERRIDE_SAFETY:
            bReturn = TRUE;
            dwAggregate = URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY;
            break;
        case URLACTION_HTML_SUBMIT_FORMS_FROM:
        case URLACTION_HTML_SUBMIT_FORMS_TO:
            bReturn = TRUE;
            dwAggregate = URLACTION_HTML_SUBMIT_FORMS;
            break;
    }

    if (bReturn && pdwAggregate)
        *pdwAggregate = dwAggregate;

    return bReturn;
}


// Functions corresponding to IInternetZoneManager functionality. 
STDMETHODIMP CRegZone::GetZoneAttributes(ZONEATTRIBUTES& zoneAttrib)
{
    if (!IsValid())
    {
        return E_FAIL;
    }

    CRegKey regKey(m_bHKLMOnly);

    if (regKey.Open(NULL, m_lpZonePath, KEY_READ) != ERROR_SUCCESS) 
    {
        // BUGBUG:: We have to be able to deal with this. situation and not just bail.
        // Possibilities: Setup defaults here if we can create and write to the key
        return E_FAIL;
    }

    // Since this is the first rev, we should have enough memory 
    // to fill in the ZONEATTRIBUTES structure. If we need to extend
    // the structure this code will have to be modified.
    TransAssert(zoneAttrib.cbSize >= sizeof(ZONEATTRIBUTES));

    // Amount of information we will copy.
    zoneAttrib.cbSize = sizeof(ZONEATTRIBUTES);

    TransAssert(regKey!= NULL);

    DWORD dwCount;
    LONG lRet;

    // BUGBUG deal with values exceeding size limit. 
    // We would have to allocate memory ourself and 
    // truncate the resulting string down.   

    // Read DisplayName.
    dwCount = sizeof(zoneAttrib.szDisplayName);
    lRet = regKey.QueryValue(zoneAttrib.szDisplayName, SZDISPLAYNAME, &dwCount);   
    TransAssert(ERROR_MORE_DATA != lRet);

    if (NO_ERROR != lRet)
        zoneAttrib.szDisplayName[0] = __TEXT('\0');    

    // Read Description
    dwCount = sizeof(zoneAttrib.szDescription);
    regKey.QueryValue(zoneAttrib.szDescription, SZDESCRIPTION, &dwCount);
    TransAssert(ERROR_MORE_DATA != lRet);

    if (NO_ERROR != lRet)
        zoneAttrib.szDescription[0] = __TEXT('\0');
    
    // Read Icon. 
    dwCount = sizeof(zoneAttrib.szIconPath);
    regKey.QueryValue(zoneAttrib.szIconPath, SZICON, &dwCount);
    TransAssert(ERROR_MORE_DATA != lRet);

    if (NO_ERROR != lRet)
        zoneAttrib.szIconPath[0] = __TEXT('\0');

    // Read Current, Recommended and Min Settings. 
    QueryTemplatePolicyIndex(regKey, SZMINLEVEL, &zoneAttrib.dwTemplateMinLevel);
    QueryTemplatePolicyIndex(regKey, SZRECLEVEL, &zoneAttrib.dwTemplateRecommended);
    QueryTemplatePolicyIndex(regKey, SZCURRLEVEL, &zoneAttrib.dwTemplateCurrentLevel);

    // Re-read the flags in case someone else updated it in an independent process. 
    DWORD dwZoneFlags;
    if (regKey.QueryValue(&dwZoneFlags, SZFLAGS) == ERROR_SUCCESS)
    {
        m_dwZoneFlags = dwZoneFlags;
        UpdateZoneMapFlags();
    }

    zoneAttrib.dwFlags = m_dwZoneFlags;

    return S_OK;
}     
      
STDMETHODIMP CRegZone::SetZoneAttributes(const ZONEATTRIBUTES& zoneAttrib)
{
    if (!IsValid())
    {
        return E_FAIL;
    }

    // Check if the attributes we are trying to set are valid.

    if (!IsValidTemplateIndex(zoneAttrib.dwTemplateMinLevel) ||
        !IsValidTemplateIndex(zoneAttrib.dwTemplateCurrentLevel) ||
        !IsValidTemplateIndex(zoneAttrib.dwTemplateRecommended))
    {
        return E_INVALIDARG;
    }

    CRegKey regKey(m_bHKLMOnly);

    if (regKey.Open(NULL, m_lpZonePath, KEY_WRITE | KEY_READ) != ERROR_SUCCESS) 
    {
        // BUGBUG:: We have to be able to deal with this. situation and not just bail.
        // Possibilities: Setup defaults here if we can create and write to the key
        return E_FAIL;
    }

    
    // Write the descriptive strings. 
    // These should almost never be changed by this call.   
    if (zoneAttrib.szDisplayName[0] != TEXT('\0'))
        regKey.SetValue(zoneAttrib.szDisplayName, SZDISPLAYNAME);   

    if (zoneAttrib.szDescription[0] != TEXT('\0'))
        regKey.SetValue(zoneAttrib.szDescription, SZDESCRIPTION);

    if (zoneAttrib.szIconPath[0] != TEXT('\0'))
        regKey.SetValue(zoneAttrib.szIconPath, SZICON);

    // Write the Template Indicies. 
    SetTemplatePolicyIndex(regKey, SZMINLEVEL, zoneAttrib.dwTemplateMinLevel);
    SetTemplatePolicyIndex(regKey, SZRECLEVEL, zoneAttrib.dwTemplateRecommended);

    DWORD dwTemplateCurrentLevel;

    // When the caller is setting the "CurrentLevel" to "Custom" it is assumed
    // that the caller has already changed the underlying policies. 
    if (zoneAttrib.dwTemplateCurrentLevel == URLTEMPLATE_CUSTOM)
    {
        SetTemplatePolicyIndex(regKey, SZCURRLEVEL, zoneAttrib.dwTemplateCurrentLevel);
    }
    else 
    {
        CopyTemplatePolicies(zoneAttrib.dwTemplateCurrentLevel);
    }


    // Finally write the flags value.
    regKey.SetValue(zoneAttrib.dwFlags, SZFLAGS);
    m_dwZoneFlags = zoneAttrib.dwFlags;
    UpdateZoneMapFlags();

    IncrementGlobalCounter();   // increment the count to invalidate the zone policy cache
    
    return S_OK;
}


STDMETHODIMP CRegZone::GetActionPolicy(DWORD dwAction, URLZONEREG urlZoneReg, DWORD& dwPolicy) const 
{
    if (!IsValid())
        return E_FAIL;

    DWORD dwActionUse;

    // If the action is aggregated by some other action, then we should 
    // actually check the policy for the aggregate action. If the function 
    if (!GetAggregateAction(dwAction, &dwActionUse))
        dwActionUse = dwAction;

    // If it is a hard-coded zone get the policy from internal tables.
    // Don't look up the registry for these.
    if (IsHardCodedZone() && GetHardCodedZonePolicy(dwActionUse, dwPolicy))
    {
        // dwPolicy should have the policy now.
    }
    else
    {
        if(!s_rzcache.Lookup(m_dwZoneId, m_lpZonePath, dwActionUse, UseHKLM(urlZoneReg), &dwPolicy))
        {
            return E_FAIL;
        }

        // For some special aggregate policies we have to modify the policy value.
        KludgeMapAggregatePolicy(dwAction, &dwPolicy);
    }

    return S_OK;
}                                     

STDMETHODIMP CRegZone::SetActionPolicy(DWORD dwAction, URLZONEREG urlZoneReg, DWORD dwPolicy)
{
    if (!IsValid())
        return E_FAIL;

    CRegKey regKey(UseHKLM(urlZoneReg));

    if (regKey.Open(NULL, m_lpZonePath, KEY_WRITE) != ERROR_SUCCESS) 
    {
        // BUGBUG:: We have to be able to deal with this. situation and not just bail.
        // Possibilities: Setup defaults here if we can create and write to the key
        return E_FAIL;
    }

    // Policies cannot be set on Actions that are aggregate's.
    // They can be only be set on the aggregator policy.

    if (IsHardCodedZone())
    {
        TransAssert(FALSE);
        return E_FAIL;
    }
            
    DWORD dwActionUse;

    // If the action is aggregated by some other action, then we should 
    // actually use the policy for the aggregate action. 
    if (!GetAggregateAction(dwAction, &dwActionUse))
        dwActionUse = dwAction;

    // Convert the Action to a string. 
#ifndef unix
    TCHAR wsz[9];  // FFFFFFFF\0
#else
    TCHAR wsz[(sizeof(DWORD)+1)*sizeof(WCHAR)];
#endif /* unix */
    if (!DwToWchar(dwActionUse, wsz, 16))
    {
        TransAssert(FALSE);
        return E_UNEXPECTED;
    }

    DWORD dwPolicyOld;
    if(!s_rzcache.Lookup(m_dwZoneId, m_lpZonePath, dwActionUse, UseHKLM(urlZoneReg), &dwPolicyOld) || dwPolicyOld != dwPolicy)
    {
        regKey.SetValue(dwPolicy, wsz);

        s_rzcache.Add(m_dwZoneId, dwActionUse, UseHKLM(urlZoneReg), dwPolicy, URLZONE_FINDCACHEENTRY);
        // We have to reset the "CurrentLevel" to "Custom" because we have changed an underlying policy:
        SetTemplatePolicyIndex(regKey, SZCURRLEVEL, URLTEMPLATE_CUSTOM);
    }


    return S_OK;
}    

STDMETHODIMP  CRegZone::GetCustomPolicy (REFGUID guid, URLZONEREG urlZoneReg, BYTE** ppByte, DWORD *pcb) const 
{
    if (!IsValid())
        return E_FAIL;


    CRegKey regKey(UseHKLM(urlZoneReg));

    if (regKey.Open(NULL, m_lpZonePath, KEY_READ) != ERROR_SUCCESS) 
    {
        // BUGBUG:: We have to be able to deal with this. situation and not just bail.
        // Possibilities: Setup defaults here if we can create and write to the key
        return E_FAIL;
    }

    // Convert the Action to a string. 
    TCHAR sz[40];  // {8CC49940-3146-11CF-97A1-00AA00424A9F}\0

    SHStringFromGUID(guid, sz, sizeof(sz));

    *pcb = 0;
    // First figure out the amount of memory required.
    if (regKey.QueryBinaryValue(NULL, sz, pcb) != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    // Memory will be freed by caller.
    *ppByte = (BYTE *)CoTaskMemAlloc(*pcb);

    if ( *ppByte == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Actually query the registry for the value.
    if (regKey.QueryBinaryValue(*ppByte, sz, pcb) != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    return S_OK;
}

STDMETHODIMP  CRegZone::SetCustomPolicy (REFGUID guid, URLZONEREG urlZoneReg, BYTE* pByte, DWORD cb)
{
    if (!IsValid())
        return E_FAIL;

    CRegKey regKey(UseHKLM(urlZoneReg));

    if (regKey.Open(NULL, m_lpZonePath, KEY_WRITE) != ERROR_SUCCESS) 
    {
        // BUGBUG:: We have to be able to deal with this. situation and not just bail.
        // Possibilities: Setup defaults here if we can create and write to the key
        return E_FAIL;
    }

    // Convert the Action to a string. 
    TCHAR sz[40];  // {8CC49940-3146-11CF-97A1-00AA00424A9F}\0

    SHStringFromGUID(guid, sz, sizeof(sz));

    DWORD dwError = ERROR_SUCCESS;
    if ((dwError = regKey.SetBinaryValue(pByte, sz, cb)) != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(dwError);
    }

    return S_OK;
}


STDMETHODIMP CRegZone::CopyTemplatePolicies(DWORD dwTemplate)
// Copy the policies from a predefined template into the current zone
{
    HRESULT hr = E_FAIL;

    // First check if we can get a name back for the template.
    LPCTSTR szTemplateName = GetTemplateNameFromIndex((URLTEMPLATE)dwTemplate);

    if (NULL == szTemplateName )
        return E_INVALIDARG;

    // Create a CRegZone for the template.
    CRegZone regTemplate;


    if (regTemplate.Init(szTemplateName, TRUE /* templates are stored in HKLM only */, REGZONEUSETEMPLATE))
    {
        CRegKey regZoneKey(m_bHKLMOnly);
        CRegKey regTemplateKey(TRUE);

        if ((NO_ERROR == regTemplateKey.Open(NULL, regTemplate.m_lpZonePath, KEY_READ)) &&
            (NO_ERROR == regZoneKey.Open(NULL, m_lpZonePath, KEY_WRITE)))
        {
            TCHAR szValueName[MAX_VALUE_NAME];
            DWORD dwNameLen = sizeof(szValueName)/sizeof(TCHAR);
            DWORD dwBufLen = 2048;
            DWORD dwActualLen = 2048;
            BYTE * buffer = new BYTE[dwBufLen];
            DWORD dwEnumIndex = 0;
            DWORD dwType;
            LONG lRet;

            while ((lRet = regTemplateKey.EnumValue (dwEnumIndex, szValueName, &dwNameLen, &dwType, buffer, &dwActualLen))
                      != ERROR_NO_MORE_ITEMS)
            {
                // Need more memory, allocate and re-try.
                if (lRet == ERROR_MORE_DATA && dwActualLen > dwBufLen)
                {
                    dwBufLen = dwActualLen;
                    delete [] buffer;
                    buffer = new BYTE[dwBufLen];

                    dwNameLen = sizeof(szValueName)/sizeof(TCHAR);
                                    
                    // Try with the bigger buffer.
                    lRet = regTemplateKey.EnumValue(dwEnumIndex, szValueName, &dwNameLen, &dwType, buffer, &dwActualLen);
                }                                            
                    
                // dwActualLen contains the actual size of the data to be written. 
                if (lRet == NO_ERROR && !IsAttributeName(szValueName))
                {
                    // Copy the value over.
                    regZoneKey.SetValueOfType(buffer, szValueName, dwActualLen, dwType);
                }

                dwEnumIndex++;
                dwActualLen = dwBufLen;
                dwNameLen = sizeof(szValueName)/sizeof(TCHAR);
            }
            
            // Set the "CurrentLevel" value to the Template Index.
            if (regZoneKey.SetValue(dwTemplate, SZCURRLEVEL) == NO_ERROR)
                hr = S_OK;

            delete [] buffer;
        }
    }

    return hr;
}
                    
                         
// CRegZoneContainer methods.


CRegZoneContainer::CRegZoneContainer()
{
    m_ppRegZones = NULL;
    m_cZones = 0;
    m_bHKLMOnly = FALSE;

    m_pZoneEnumList = NULL;
    m_dwNextEnum = 0;
    InitializeCriticalSection(&m_csect);
}

CRegZoneContainer::~CRegZoneContainer()
{
    Detach();
    DeleteCriticalSection(&m_csect);
};

// This functions goes through the registry and creates the CRegZone objects corresponding 
// to the zones currently in the registry.


BOOL CRegZoneContainer::Attach(BOOL bUseHKLM, REGZONEUSE regZoneUse /* = REGZONEUSEZONES */)                                        
{
    // If this assert fires you probably forgot to call Detach.
    TransAssert(m_cZones == 0);
    TransAssert(m_ppRegZones == NULL);
    // recover if we are messed up.
    Detach();

    m_bHKLMOnly = bUseHKLM ;


    TCHAR sz[MAX_REGZONE_ROOT];
    StrCpyW(sz, (regZoneUse == REGZONEUSEZONES ? SZZONES : SZTEMPLATE )); 

    // Make sure we have the minimal set of zones required and we self-heal if there is a problem.
    // even if self-heal fails we ignore the error code and try to initialize the zones anyway.
    if (regZoneUse == REGZONEUSEZONES )
        SelfHeal(bUseHKLM);


    CRegKey regKey(m_bHKLMOnly);
    
    if (regKey.Open(NULL, sz, KEY_READ) != ERROR_SUCCESS)
    {
        // Hosed setup right defaults here. 
        return FALSE;
    }
        

    TransAssert(regKey.m_hKey != NULL);

    // For each entry in the registry
    DWORD dwIndex = 0;
    DWORD dwCount = 0;
    DWORD lRes;
    TCHAR szZoneName[MAX_ZONE_NAME];
    DWORD dwSize = MAX_ZONE_NAME;    

    CRegListElem *pElemStart = NULL;

    for (; (lRes = regKey.EnumKey(dwIndex, szZoneName, &dwSize)) != ERROR_NO_MORE_ITEMS; dwIndex++)
    {
        if (lRes != ERROR_SUCCESS)
        {
            break;
        }
        
        dwSize = MAX_ZONE_NAME;

        CRegZone *pRegZone = new CRegZone();
        
        if (pRegZone == NULL)
        {
            m_cZones = 0;
            // Out of memory -- change all error codes to return HRESULT's
            break;
        }
        
        if (!pRegZone->Init(szZoneName, m_bHKLMOnly))
        {
            continue;   // can't create the zone for some reason.
        }

        m_cZones++;
        
        CRegListElem * pRegListElem = new CRegListElem();
        if ( pRegListElem == NULL)
        {
            m_cZones = 0;
            break;  // Out of memory.
        }

        pRegListElem->pRegZone = pRegZone;
        pRegListElem->dwZoneIndex = pRegZone->GetZoneId();

        // Insert list into sorted position.
        if (pElemStart == NULL)
        {
            pElemStart = pRegListElem;
            pRegListElem->next = NULL;
        }
        else if (pElemStart->dwZoneIndex > pRegListElem->dwZoneIndex)
        {
            // Insert to the head of the list.
            pRegListElem->next = pElemStart;
            pElemStart = pRegListElem;
        }
        else 
        {
            // Insert in the correct position. 
            CRegListElem *pElemCurr = pElemStart;
            
            while (pElemCurr->next != NULL &&
                 pElemCurr->next->dwZoneIndex < pRegListElem->dwZoneIndex )
            {
                pElemCurr = pElemCurr->next;
            }

            TransAssert(pElemCurr != NULL);
            pRegListElem->next = pElemCurr->next;
            pElemCurr->next = pRegListElem;
        }
    }

    // Now that we have all the RegZones collected we will just store them in 
    // sorted order in an array.

    if (m_cZones)
        m_ppRegZones = new LPREGZONE[m_cZones];
    else
        m_ppRegZones = NULL;

    if (m_ppRegZones == NULL)
    {
        // Out of memory
        m_cZones = 0;
        return FALSE;
    }

    for (dwIndex = 0; dwIndex < m_cZones ; dwIndex++)
    {
        TransAssert(pElemStart != NULL);

        m_ppRegZones[dwIndex] = pElemStart->pRegZone;
        CRegListElem * pElemDelete = pElemStart;
        pElemStart = pElemStart->next;
        delete pElemDelete;
    }

    return TRUE;

}

BOOL CRegZoneContainer::Detach()
{
    // First free all the CRegZone entries we are holding on to.
    DWORD dwIndex = 0;

    for (; dwIndex < m_cZones; dwIndex++)
    {
        delete m_ppRegZones[dwIndex];
    }

    delete [] m_ppRegZones;
    m_ppRegZones = NULL;
    m_cZones = 0;
    m_bHKLMOnly = TRUE;

    // Zone enumerator cleanup.
    // This ASSERT will fire if you forget to call DestroyZoneEnumerator before 
    // freeing the object.
    TransAssert(m_pZoneEnumList == NULL);
    CZoneEnumList * pNextEnum = m_pZoneEnumList;
    while (pNextEnum != NULL)
    {
        CZoneEnumList * pEnumListDelete = pNextEnum;
        pNextEnum = pNextEnum->next;
        delete pEnumListDelete;
    }

    return TRUE;
}

// This function makes sure that the minimal set of zones are in the registry If things are missing
// it calls the self-registration entry point and re-creates the zone key.

#define WIN2KSETUP  TEXT("System\\Setup")
#define INPROGRESS  TEXT("SystemSetupInProgress")

BOOL CRegZoneContainer::SelfHeal(BOOL bUseHKLM)
{
 
    HKEY hKeyZones = NULL;

    if (IsInGUIModeSetup())
    {
        // ignore SelfHeal if we're in GUI-mode setup
        return TRUE;
    }

    if (RegOpenKeyEx((bUseHKLM ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER), SZZONES, 0, KEY_READ, &hKeyZones)
            == ERROR_SUCCESS)
    {
                     
        // Strings corresponding to the five pre-defined zones.
        TCHAR * rgszZones[] = { TEXT("0"), TEXT("1"), TEXT("2"), TEXT("3"), TEXT("4") };
        
        int i;
        for (i = 0 ; i < ARRAYSIZE(rgszZones) ; i++ )
        {
            HKEY hKey;

            DWORD dwError = RegOpenKeyEx(hKeyZones, rgszZones[i], 0, KEY_READ, &hKey);
            
            if (dwError != ERROR_SUCCESS)
                break;
            else
                RegCloseKey(hKey);
        }

        RegCloseKey(hKeyZones);    

        // If we succesfully opened all the zones.
        if (i == ARRAYSIZE(rgszZones))
        {
            return TRUE;
        }

    }


    // If we reached here we were not able to open atleast one of the keys.
    // Note that we use L"" because ZonesDllInstall takes a LPCWSTR  
    BOOL bRet;
    HRESULT hr = ZonesDllInstall(TRUE, bUseHKLM ? L"HKLM" : L"HKCU");
    
    if (SUCCEEDED(hr))
    {
        CRegKey regKey(bUseHKLM);

        // Keep track of how many times we self heal for diagnostic purposes..
        DWORD dwSelfHealCount;
        TCHAR *pszSelfHealCount = TEXT("SelfHealCount");

        if (regKey.Open(NULL, SZZONES, KEY_READ | KEY_WRITE) == ERROR_SUCCESS)
        {
            if (regKey.QueryValue(&dwSelfHealCount, pszSelfHealCount) != ERROR_SUCCESS)
                dwSelfHealCount = 0;

            dwSelfHealCount++;
            regKey.SetValue(dwSelfHealCount, pszSelfHealCount);
        }

        bRet = TRUE;
    }
    else
        bRet = FALSE;

    return bRet;
}

CRegZone * CRegZoneContainer::GetRegZoneByName(LPCTSTR lpName) const
{
    DWORD dwIndex = 0;
    CRegZone *pRegZone = NULL;

    for ( ; dwIndex < m_cZones; dwIndex++ )
    {
        pRegZone = m_ppRegZones[dwIndex] ;

        if (pRegZone && StrCmpIW(pRegZone->GetZoneName(), lpName) == 0)
            break;
    }

    return pRegZone;
}

CRegZone * CRegZoneContainer::GetRegZoneById(DWORD dwZoneId) const
{
    DWORD dwIndex = 0;
    CRegZone * pReturnZone = NULL;

    for (; dwIndex < m_cZones ; dwIndex++ )
    {
        CRegZone * pRegZone = m_ppRegZones[dwIndex];

        
        if (pRegZone == NULL)       
        {
            // This shouldn't happen but a safety check doesn't hurt.
            break;
        }
        else if (pRegZone->GetZoneId() == dwZoneId)
        {
            pReturnZone = pRegZone;
            break;      // Got it
        }
        else if (pRegZone->GetZoneId() > dwZoneId)
        {
            break;
        }
    }

    return pReturnZone;
}

// Zone Enumeration functions. 
BOOL CRegZoneContainer::VerifyZoneEnum(DWORD dwEnum ) const
{
    BOOL bFound = FALSE;

    CZoneEnumList *pNext = m_pZoneEnumList;
    while (pNext)
    {
        if (pNext->dwEnum == dwEnum)
        {
            bFound = TRUE;
            break;
        }

        pNext = pNext->next;
    }
    
    return bFound;
}
          


STDMETHODIMP CRegZoneContainer::CreateZoneEnumerator(DWORD* pdwEnum,  DWORD *pdwCount)
{
    if (pdwEnum == NULL || pdwCount == NULL)
        return E_INVALIDARG;

    if (m_cZones == 0)
    {
        return E_FAIL;
    }

    CZoneEnumList *pEnumListElem = new CZoneEnumList;
    if (pEnumListElem == NULL)
        return E_OUTOFMEMORY;

    pEnumListElem->dwEnum = m_dwNextEnum++;

    EnterCriticalSection(&m_csect);

    if (m_pZoneEnumList == NULL)
    {
        pEnumListElem->next = NULL;
        m_pZoneEnumList = pEnumListElem;
    }
    else 
    {
        pEnumListElem->next = m_pZoneEnumList;
        m_pZoneEnumList = pEnumListElem;
    }

    *pdwEnum = m_pZoneEnumList->dwEnum;
    *pdwCount = m_cZones;
        
    TransAssert(VerifyZoneEnum(*pdwEnum));
    
    LeaveCriticalSection(&m_csect);
        
    return S_OK;
}


STDMETHODIMP CRegZoneContainer::GetZoneAt(DWORD dwEnum, DWORD dwIndex, DWORD *pdwZone)
{
    if (!VerifyZoneEnum(dwEnum) || dwIndex >= m_cZones)
    {
        return E_INVALIDARG;
    }

    if (m_ppRegZones && m_ppRegZones[dwIndex])
    {
        *pdwZone = m_ppRegZones[dwIndex]->GetZoneId();
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CRegZoneContainer::DestroyZoneEnumerator(DWORD dwEnum)
{
    HRESULT hr = S_OK;
    CZoneEnumList *pDelete = NULL;

    EnterCriticalSection(&m_csect);
    if (m_pZoneEnumList == NULL)
    {
    }
    else if (m_pZoneEnumList->dwEnum == dwEnum)
    {
        pDelete = m_pZoneEnumList;
        m_pZoneEnumList = pDelete->next;
    }
    else {
        CZoneEnumList *pCurr = m_pZoneEnumList;

        while (pCurr != NULL)
        {
            if (pCurr->next && pCurr->next->dwEnum == dwEnum)
            {
                pDelete = pCurr->next;
                pCurr->next = pDelete->next;
                break;
            }
            pCurr = pCurr->next;
        }
    }

    if (pDelete == NULL)
    {
        // Didn't find the entry must be an invalid Enumerator.
        hr = E_INVALIDARG;
    }
    else 
    {
        delete pDelete;
        hr = S_OK;
    }
    LeaveCriticalSection(&m_csect);
    return hr;
}

//=============================================================================
// CRegZoneCache methods
//=============================================================================
CRegZone::CRegZoneCache::CRegZoneCache(void)
{
    InitializeCriticalSection(&m_csectZoneCache);
    
    // single static object, so this only gets inited once per
    // process.
    s_hMutexCounter = CreateMutexA(NULL, FALSE, "ZonesCacheCounterMutex");
    m_iAdd = 0;
}

CRegZone::CRegZoneCache::~CRegZoneCache(void)
{
    Flush();
    DeleteCriticalSection(&m_csectZoneCache) ; 

    CloseHandle(s_hMutexCounter);
}

BOOL
CRegZone::CRegZoneCache::Lookup(DWORD dwZone, LPTSTR lpZonePath, DWORD dwAction, BOOL fUseHKLM, DWORD *pdwPolicy)
{
    BOOL fFound = FALSE;
    int iEntry = URLZONE_FINDCACHEENTRY;

    TransAssert(iEntry < MAX_REG_ZONE_CACHE);

    EnterCriticalSection(&m_csectZoneCache);

    if ( !IsCounterEqual() )
        Flush();
    
    fFound = FindCacheEntry(dwZone, dwAction, fUseHKLM, iEntry );
    if (fFound)
    {
        if (pdwPolicy)
        {
            *pdwPolicy = m_arzce[iEntry].m_dwPolicy;
        }
    }
    else
    {
        // Convert the Action to a string. 
#ifndef unix
        TCHAR wsz[9];  // FFFFFFFF\0
#else
        TCHAR wsz[(sizeof(DWORD)+1)*sizeof(WCHAR)];
#endif /* unix */

        if (DwToWchar(dwAction, wsz, 16))
        {
            CRegKey regKey(fUseHKLM);

            if (regKey.Open(NULL, lpZonePath, KEY_READ) == ERROR_SUCCESS) 
            {
                if (regKey.QueryValue(pdwPolicy, wsz) == ERROR_SUCCESS)
                {
                    fFound = TRUE;
                    Add(dwZone, dwAction, fUseHKLM, *pdwPolicy, iEntry);
                }
            }
            else
            {
                // BUGBUG:: We have to be able to deal with this situation and not just bail.
                // Possibilities: Setup defaults here if we can create and write to the key
                TransAssert(FALSE);
            }
        }
        else
        {
            TransAssert(FALSE);
        }
    }

    LeaveCriticalSection(&m_csectZoneCache);

    return fFound;
}

void 
CRegZone::CRegZoneCache::Add(DWORD dwZone, DWORD dwAction, BOOL fUseHKLM, DWORD dwPolicy, int iEntry)
{
    BOOL    fFound;

    TransAssert(iEntry < MAX_REG_ZONE_CACHE);
    
    EnterCriticalSection(&m_csectZoneCache);

    if ( !IsCounterEqual() )
        Flush();

    if(iEntry == URLZONE_FINDCACHEENTRY)  // using optional param that indicates the entry we want to add so don't bother doing a find.
        fFound = FindCacheEntry(dwZone, dwAction, fUseHKLM, iEntry ); // found or not, iEntry will be the right place to set it.

    m_arzce[iEntry].Set(dwZone, dwAction, fUseHKLM, dwPolicy);

    SetToCurrentCounter(); // validate this cache.

    LeaveCriticalSection(&m_csectZoneCache);
}

void 
CRegZone::CRegZoneCache::Flush(void)
{
    int i;

    EnterCriticalSection(&m_csectZoneCache);

    for ( i = 0; i < MAX_REG_ZONE_CACHE; i++ )
        m_arzce[i].Flush();

    m_iAdd = 0;
    
    LeaveCriticalSection(&m_csectZoneCache);
}

// Is the counter we saved with the cache entry, equal to the current counter.
BOOL
CRegZone::CRegZoneCache::IsCounterEqual( ) const 
{
    CExclusiveLock lock(s_hMutexCounter);
    LPDWORD lpdwCounter = (LPDWORD)g_SharedMem.GetPtr(SM_REGZONECHANGE_COUNTER);
    // If we couldn't create the shared memory for some reason, we just assume our cache is up to date.
    if (lpdwCounter == NULL)
        return TRUE;

    return (m_dwPrevCounter == *lpdwCounter);
}

VOID
CRegZone::CRegZoneCache::SetToCurrentCounter( ) 
{
    CExclusiveLock lock(s_hMutexCounter);
    LPDWORD lpdwCounter = (LPDWORD)g_SharedMem.GetPtr(SM_REGZONECHANGE_COUNTER);
    if (lpdwCounter == NULL)
        return;

    m_dwPrevCounter = *lpdwCounter;
}

VOID
CRegZone::CRegZoneCache::IncrementGlobalCounter( )
{
    CExclusiveLock lock(s_hMutexCounter);
    LPDWORD lpdwCounter = (LPDWORD)g_SharedMem.GetPtr(SM_REGZONECHANGE_COUNTER);
    if (lpdwCounter == NULL)
        return;

    (*lpdwCounter)++;
}

BOOL
CRegZone::CRegZoneCache::FindCacheEntry(DWORD dwZone, DWORD dwAction, BOOL fUseHKLM, int& riEntry )
{
    BOOL fFound = FALSE;

    for ( riEntry = 0; (m_arzce[riEntry].m_dwZone != ZONEID_INVALID) && (riEntry < MAX_REG_ZONE_CACHE); riEntry++ )
    {
        if ( m_arzce[riEntry].m_dwZone == dwZone &&
             m_arzce[riEntry].m_dwAction == dwAction &&
             m_arzce[riEntry].m_fUseHKLM == fUseHKLM )
        {
            fFound = TRUE;
            break;
        }
    }

    if(!fFound)
    {
        riEntry = m_iAdd;
        m_iAdd = (m_iAdd + 1) % MAX_REG_ZONE_CACHE;    // next index to add an entry that's not found
    }
    
    return fFound;
}
  
void 
CRegZone::CRegZoneCache::CRegZoneCacheEntry::Set(DWORD dwZone, DWORD dwAction, BOOL fUseHKLM, DWORD dwPolicy)
{
    m_dwZone = dwZone;    
    m_dwAction = dwAction;
    m_fUseHKLM = fUseHKLM;
    m_dwPolicy = dwPolicy;
}

void 
CRegZone::CRegZoneCache::CRegZoneCacheEntry::Flush(void)
{
    m_dwZone = ZONEID_INVALID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\zones\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by zones.rc
//
#define IDD_WARN_ALERT                  114
#define IDI_SECURITY1                   116
#define IDI_SECURITY2                   118
#define IDI_SECURITY3                   119
#define IDI_TRUSTALERT                  120
#define IDC_DONT_WANT_WARNING           1001
#define IDC_ZONEALERTTEXT               1032
#define IDC_ADD_TRUSTED_SITES           1033
#define IDC_TRUSTDLGTEXT1               1034
#define IDC_TRUSTDLGTEXT2               1035
#define IDC_ENABLE_TRUSTDLG             1036
#define IDC_TRUSTDLGTEXT3               1037
#define IDC_URL                         1039
#define IDC_ESC_HELP                    1040
#define IDD_WARN_ON_POST                1175
#define IDS_WARN_SHELL_FILE_DL          2012
#define IDS_ACTION_DL_SIGNED_JAVA       2013
#define IDS_ACTION_FORMS_POST           2013
#define IDS_ACTION_DL_JAVA              2014
#define IDS_ACTION_POST_FROM            2014
#define IDS_ACTION_DL_ACTIVE_CODE       2015
#define IDS_ACTION_AX_OVERRIDE_SAFETY   2016
#define IDS_ACTION_AX_CONFIRM_NOSAFETY  2017
#define IDS_ACTION_SCRIPT_RUN           2018
#define IDS_ACTION_SCRIPT_JAVA          2019
#define IDS_ACTION_HTML_FORMS           2022
#define IDS_ACTION_HTML_FONT_DL         2023
#define IDS_ACTION_HTML_JAVA            2024
#define IDS_ACTION_SHELL_DRAG_DTCOMP    2025
#define IDS_ACTION_SHELL_INSTALL_DTITEMS 2025
#define IDS_ACTION_SHELL_DRAG_FILE      2026
#define IDS_ACTION_SHELL_MOVE_OR_COPY   2026
#define IDS_ACTION_SHELL_FILE_DL        2027
#define IDS_ACTION_SHELL_VERB           2028
#define IDS_ACTION_NW_CREDENTIALS       2029
#define IDS_ACTION_NW_AUTH_CLIENT       2030
#define IDS_ACTION_DL_SIGNED_ACTIVEX    2031
#define IDS_ACTION_AX_RUN               2032
#define IDS_ACTION_UNKNOWN              2033
#define IDS_ACTION_AX_OVERRIDE_DATA_SAFETY 2034
#define IDS_ACTION_AX_OVERRIDE_SCRIPT_SAFETY 2035
#define IDS_ACTION_SCRIPT_OVERRIDE_SAFETY 2036
#define IDS_ACTION_DL_ACTIVEX           2037
#define IDS_WARN_SHELL_DRAG_DTCOMP      2038
#define IDS_WARN_SHELL_INSTALL_DTITEMS  2038
#define IDS_ACTION_SHELL_DRAG           2039
#define IDS_WARN_SHELL_DRAG_FILE        2040
#define IDS_WARN_SHELL_MOVE_OR_COPY     2040
#define IDS_WARN_SHELL_VERB             2041
#define IDS_WARN_HTML_FORMS             2042
#define IDS_WARN_UNKNOWN                2043
#define IDS_ACTION_SCRIPT_SAFE_ACTIVEX  2044
#define IDS_ACTION_SHELL_WEBVIEW_VERB   2045
#define IDS_WARN_SHELL_WEBVIEW_VERB     2046
#define IDS_ACTION_CROSS_DOMAIN_DATA    2047
#define IDS_ACTION_NW_COOKIES           2048
#define IDS_ACTION_NW_COOKIES_SESSION   2051
#define IDS_ACTION_HTML_USERDATA        2052
#define IDS_ACTION_SCRIPT_PASTE         2053
#define IDS_ACTION_HTML_SUBFRAME_NAVIGATE 2054
#define IDS_ACTION_NW_CLIENT_CERT_PROMPT 2055
#define IDS_ACTION_NW_COOKIES_THIRD_PARTY 2056
#define IDS_ACTION_NW_COOKIES_SESSION_THIRD_PARTY 2057
#define IDS_ACTION_HTML_META_REFRESH    2058
#define IDS_ACTION_HTML_MIXED_CONTENT   2059
#define IDS_TRUST_DLG_MSG_STRING_IE_1   2060
#define IDS_TRUST_DLG_MSG_STRING_URLMON_IE_1 2060
#define IDS_TRUST_DLG_MSG_STRING_IE_2   2061
#define IDS_TRUST_DLG_MSG_STRING_URLMON_IE_2 2061
#define IDS_TRUST_DLG_MSG_STRING_URLMON_SHDOCVW_IE_NONIE_2 2061
#define IDS_TRUST_DLG_MSG_STRING_NONIE_1 2062
#define IDS_TRUST_DLG_MSG_STRING_URLMON_NONIE_1 2062
#define IDS_TRUST_DLG_MSG_STRING_NONIE_2 2063
#define IDS_TRUST_DLG_MSG_STRING_URLMON_NONIE_2 2063
#define IDS_TRUST_DLG_MSG_STRING_IE_NONIE_3 2064
#define IDS_TRUST_DLG_MSG_STRING_URLMON_SHDOCVW_IE_NONIE_WARNING 2064
#define IDS_TRUST_DLG_MSG_STRING_SHDOCVW_IE_1 2065
#define IDS_TRUST_DLG_MSG_STRING_SHDOCVW_IE_2 2066
#define IDS_TRUST_DLG_MSG_STRING_URLMON_SHDOCVW_IE_NONIE_URL 2067
#define IDD_ZONE_ALERT                  4006
#define IDD_TRUST_ALERT                 4007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        115
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1041
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\zones\urlenum.cxx ===
// Implementation of the CEnumString classs

#include "zonepch.h"


// Constructor - destructor.

CEnumString::CEnumString() : m_ref() 
{
    pFirst = NULL;
    pLast = NULL;
    pCurrent = NULL;
}


CEnumString::~CEnumString( )
{
    // Delete all the strings we created.
    ListStr * pNext = pFirst;
    
    while (pNext != NULL)
    {
        ListStr * pDelete = pNext;
        pNext = pNext->pListNext;

        LocalFree(pDelete->lpsz);
        delete pDelete;
    }
}

HRESULT CEnumString::AddString(LPCWSTR lpsz)
{
    // First create the element.
    ListStr *pListStr = new ListStr;
    if (pListStr == NULL)
        return E_OUTOFMEMORY;

    pListStr->lpsz = StrDup(lpsz);
    if (pListStr->lpsz == NULL)
    {
        delete pListStr;
        return E_OUTOFMEMORY;
    }

    pListStr->pListNext = NULL;

    if (pFirst == NULL)
    {
        TransAssert(pCurrent == NULL);
        TransAssert(pLast == NULL);
        pFirst = pCurrent = pLast = pListStr;
    }
    else 
    {
        TransAssert(pLast != NULL);
        // We don't support adding strings while an enumeration is on.
        TransAssert(pFirst == pCurrent);
        
        pLast->pListNext = pListStr;
        pLast = pListStr;
    }

    return S_OK;
}
                
// IUnknown methods.

STDMETHODIMP_(ULONG) CEnumString::AddRef( )
{
    LONG lRet = ++m_ref;
    
    return lRet;
}

STDMETHODIMP_(ULONG) CEnumString::Release( )
{

    LONG lRet =  --m_ref;
    
    if (m_ref == 0)
    {
        delete this;
    }

    return lRet;
}

STDMETHODIMP  CEnumString::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = NOERROR;   
    
    if ( (riid == IID_IUnknown) || (riid == IID_IEnumString))
    { 
        *ppvObj = this;       
        AddRef();
    }
    else 
    {
        *ppvObj = NULL;
        hr  = E_NOINTERFACE;
    }

    return hr;
}


// IEnumString methods.


STDMETHODIMP
CEnumString::Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = NOERROR;
    ULONG cFound = 0;

    // Check the arguments first.     
    if (celt == 0)
        return S_OK;
             
    if (!rgelt)
        return E_INVALIDARG;

    do 
    {
        if (pCurrent == NULL)
            break;
            
        DWORD cChars = lstrlenW(pCurrent->lpsz) + 1;
        rgelt[cFound] = (LPOLESTR)CoTaskMemAlloc(cChars * sizeof(OLECHAR));

        // If we don't have enough memory don't return anything. 
        if (rgelt[cFound] == NULL)
        {
            hr = E_OUTOFMEMORY;
            for (DWORD dwIndex = 0 ; dwIndex < cFound ; dwIndex++ )
            {
                CoTaskMemFree(rgelt[dwIndex]);
                rgelt[dwIndex] = 0;
            }
        } 
        
        StrCpyW(rgelt[cFound], pCurrent->lpsz);
        
        pCurrent = pCurrent->pListNext;
        
        cFound++;
    } while ( cFound < celt );
    
    if (hr == NOERROR)
    {
        if (pceltFetched)
            *pceltFetched = cFound;
            
        hr = (cFound == celt) ?  NOERROR : S_FALSE;
    }
    
    return hr;
}                                      

                    
    
STDMETHODIMP
CEnumString::Skip(ULONG celt)
{
    return E_NOTIMPL;
}


STDMETHODIMP
CEnumString::Reset( )
{
    pCurrent = pFirst;

    return S_OK;
}

STDMETHODIMP
CEnumString::Clone(IEnumString **ppEnumString)
{
    // This should be easy to implement if we do a deep copy.
    // However we should be able to seperate the list from the 
    // current pointer and do a much more efficient job.
    // Not impl for code complete.

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\zones\secmgr.cxx ===
//  File:       secmgr.cxx
//
//  Contents:   This file implements the base IInternetSecurityManager interface
//
//  Classes:    CSecurityManager
//
//  Functions:
//
//  History: 
//
//----------------------------------------------------------------------------

#include "zonepch.h" // PCH HEADER FILE, DON'T INCLUDE ANYTHING ABOVE 
#include <commctrl.h>
#include "shfusion.h"
#include "advpub.h"

PerfDbgTag(tagCSecurityManager, "Urlmon", "Log Security Mgr", DEB_SESSION)
PerfDbgTag(tagZONEMAP_COMPONENTS, "Urlmon", "Log Security URL parser", DEB_SESSION)

#define PRIVATE static

#define ZERO        TEXT('0')
#define NINE        TEXT('9')
#define DOT         TEXT('.')
#define SLASH       TEXT('/')
#define BACKSLASH   TEXT('\\')
#define COLON       TEXT(':')
#define WILDCARD    TEXT('*')
#define SPACE       TEXT(' ')
#define HYPHEN      TEXT('-')
#define BAR         TEXT('|')
#define AT          TEXT('@')
#define PERCENT     TEXT('%')

extern const LPWSTR RtlpWin32NtRoot         = L"\\\\?";
extern const LPWSTR RtlpWin32NtUncRoot      = L"\\\\?\\UNC";

#define MAX_IPRANGE 32

extern BOOL g_bUseImprovedZoneCheck;
extern IInternetSecurityManager* g_pSecurityManager; 
HRESULT EnsureSecurityManager ();

BOOL  CSecurityManager::s_bIPInit = FALSE;
BYTE * CSecurityManager::s_pRanges = NULL;
DWORD CSecurityManager::s_cNumRanges = 0;
DWORD CSecurityManager::s_cbRangeItem = 0;
DWORD CSecurityManager::s_dwNextRangeIndex = 0;

PRIVATE TCHAR chWildCard = WILDCARD;

CSecurityManager::CSecMgrCache CSecurityManager::s_smcache;

BOOL  CSecurityManager::s_bcsectInit = FALSE;
CRITICAL_SECTION CSecurityManager::s_csectIP; 
HANDLE CSecurityManager::CSecMgrCache::s_hMutexCounter;

CLSID * CSecurityManager::s_clsidAllowedList = NULL;
CRITICAL_SECTION CSecurityManager::s_csectAList;
DWORD CSecurityManager::s_dwNumAllowedControls;


// HACK: See assert below.  We have to parse '*' as a valid scheme for wildcarding purposes.
// The big number is to avoid collisions with the pre-defined URL_SCHEME_* numbers that start 
// at 0 and go up sequentially. 
#define URL_SCHEME_WILDCARD (0x0000FFFF)
#define SAFEREGOPERATION(dw, r) \
    dw = r; \
    if(dw == ERROR_KEY_DELETED) \
    {\
        dw = m_regZoneMap.Open (NULL, SZZONEMAP, KEY_READ); \
        if( dw == ERROR_SUCCESS) \
            dw = r; \
    } 

#ifndef ARRAY_ELEMENTS
#define ARRAY_ELEMENTS(array) \
    (sizeof(array)/sizeof((array)[0]))
#endif

typedef DWORD (APIENTRY *WNETGETCONNECTION) (LPSTR, LPSTR, LPDWORD);


// Simple class to force freeing of memory pointer.
class CFreeStrPtr 
{
public:
    CFreeStrPtr(LPWSTR pwsz) { m_pwsz = pwsz; }
    ~CFreeStrPtr()  { delete [] m_pwsz; }
private:
    LPWSTR m_pwsz;
};

#ifdef UNICODE
#define IsSpace IsCharSpaceW
#else
#define IsSpace isspace
#endif

// Scans a string for number from 0 to 255 inclusive.
PRIVATE BOOL ScanByte (LPCTSTR& psz, BYTE *bOut)
{
    DWORD dw;
    
    // first char
    if (*psz < ZERO || *psz > NINE)
        return FALSE;
    dw = *psz++ - ZERO;

    // second char
    if (*psz < ZERO || *psz > NINE)
        goto done;
    dw = 10 * dw + *psz++ - ZERO;

    // third char
    if (*psz < ZERO || *psz > NINE)
        goto done;
    dw = 10 * dw + *psz++ - ZERO;
    if (dw > 255)
        return FALSE;

done:
    *bOut = (BYTE) dw;
    return TRUE;
}

// Scans a string for a range, wrapping ScanByte
PRIVATE BOOL ScanRange (LPCTSTR& psz, BYTE* pbLow, BYTE* pbHigh)
{
    if (*psz == WILDCARD)
    {
        *pbLow  = 0;
        *pbHigh = 255;
        psz++; // move past *
        return TRUE;
    }

    if (!ScanByte (psz, pbLow))
        return FALSE;

    while (*psz == SPACE)
        psz++; // trim whitespace
    if (*psz != HYPHEN)
    {
        *pbHigh = *pbLow;
        return TRUE;
    }
    else
    {
        psz++; // move past -
        while (*psz == SPACE)
            psz++; // trim whitespace
        return ScanByte (psz, pbHigh);
    }
}


PRIVATE BOOL ReadIPRule (LPCTSTR psz, BYTE *pbLow, BYTE *pbHigh)
{
    // Note: ScanRange first param passed by reference.
    return
       (    ScanRange (psz, pbLow++, pbHigh++)
        &&  *psz++ == DOT
        &&  ScanRange (psz, pbLow++, pbHigh++)
        &&  *psz++ == DOT
        &&  ScanRange (psz, pbLow++, pbHigh++)
        &&  *psz++ == DOT
        &&  ScanRange (psz, pbLow++, pbHigh++)
       );
}


// This function is copied here from the network stack code because we don't want to 
// link urlmon with winsock. Urlmon is pulled in by the shell even in cases where there
// is no network connection.

/*
 * Internet address interpretation routine.
 * All the network library routines call this
 * routine to interpret entries in the data bases
 * which are expected to be an address.
 * The value returned is in network order.
 */
PRIVATE ULONG 
inet_addr(
    IN const TCHAR *cp
    )

/*++

Routine Description:

    This function interprets the character string specified by the cp
    parameter.  This string represents a numeric Internet address
    expressed in the Internet standard ".'' notation.  The value
    returned is a number suitable for use as an Internet address.  All
    Internet addresses are returned in network order (bytes ordered from
    left to right).

    Internet Addresses

    Values specified using the "." notation take one of the following
    forms:

    a.b.c.d   a.b.c     a.b  a

    When four parts are specified, each is interpreted as a byte of data
    and assigned, from left to right, to the four bytes of an Internet
    address.  Note that when an Internet address is viewed as a 32-bit
    integer quantity on the Intel architecture, the bytes referred to
    above appear as "d.c.b.a''.  That is, the bytes on an Intel
    processor are ordered from right to left.

    Note: The following notations are only used by Berkeley, and nowhere
    else on the Internet.  In the interests of compatibility with their
    software, they are supported as specified.

    When a three part address is specified, the last part is interpreted
    as a 16-bit quantity and placed in the right most two bytes of the
    network address.  This makes the three part address format
    convenient for specifying Class B network addresses as
    "128.net.host''.

    When a two part address is specified, the last part is interpreted
    as a 24-bit quantity and placed in the right most three bytes of the
    network address.  This makes the two part address format convenient
    for specifying Class A network addresses as "net.host''.

    When only one part is given, the value is stored directly in the
    network address without any byte rearrangement.

Arguments:

    cp - A character string representing a number expressed in the
        Internet standard "." notation.

Return Value:

    If no error occurs, inet_addr() returns an in_addr structure
    containing a suitable binary representation of the Internet address
    given.  Otherwise, it returns the value INADDR_NONE.

--*/

{
        register unsigned long val, base, n;
        register TCHAR c;
        unsigned long parts[4], *pp = parts;
        const unsigned long INADDR_NONE = -1;


again:
        /*
         * Collect number up to ``.''.
         * Values are specified as for C:
         * 0x=hex, 0=octal, other=decimal.
         */
        val = 0; base = 10;
        if (*cp == '0') {
            base = 8, cp++;
            if (*cp == 'x' || *cp == 'X')
                base = 16, cp++;
        }

        while (c = *cp) {
                // If it is a decimal digit..
                if (c <= NINE && c >= ZERO) {
                        val = (val * base) + (c - '0');
                        cp++;
                        continue;
                }
                // If we are base 16 and it is a hex digit...
                if ( base == 16 && 
                     ( (c >= TEXT('a') && c <= TEXT('f')) ||
                       (c >= TEXT('A') && c <= TEXT('F'))
                     )
                   )
                {
                        val = (val << 4) + (c + 10 - (islower(c) ? TEXT('a') : TEXT('A')));
                        cp++;
                        continue;
                }
                break;
        }
        if (*cp == '.') {
                /*
                 * Internet format:
                 *      a.b.c.d
                 *      a.b.c   (with c treated as 16-bits)
                 *      a.b     (with b treated as 24 bits)
                 */
                /* GSS - next line was corrected on 8/5/89, was 'parts + 4' */
                if (pp >= parts + 3) {
                        return ((unsigned long) -1);
                }
                *pp++ = val, cp++;
                goto again;
        }
        /*
         * Check for trailing characters.
         */
        if (*cp && !IsSpace(*cp)) {
                return (INADDR_NONE);
        }
        *pp++ = val;
        /*
         * Concoct the address according to
         * the number of parts specified.
         */
        n = (unsigned long)(pp-parts);
        switch ((int) n) {

        case 1:                         /* a -- 32 bits */
                val = parts[0];
                break;

        case 2:                         /* a.b -- 8.24 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xffffff)) {
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | (parts[1] & 0xffffff);
                break;

        case 3:                         /* a.b.c -- 8.8.16 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
                    (parts[2] > 0xffff)) {
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                        (parts[2] & 0xffff);
                break;

        case 4:                         /* a.b.c.d -- 8.8.8.8 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
                    (parts[2] > 0xff) || (parts[3] > 0xff)) {
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                      ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
                break;

        default:
                return (INADDR_NONE);
        }

#if defined(UNIX) && defined(BIG_ENDIAN)
//  IEUNIX: Dont swap on BIG_ENDIAN Unix m/c.
        return (val);
#else
        val = (val & 0xff000000) >> 24 |
              (val & 0x00ff0000) >> 8  |
              (val & 0x0000ff00) << 8  |
              (val & 0x000000ff) << 24;
        return (val);
#endif
}


// Checks if site is in form of IP address.
PRIVATE BOOL ReadAddress (LPCTSTR pwszSite, BYTE *pb)
{
    ULONG ipaddr = inet_addr(pwszSite);

    if (ipaddr != -1)
    {
#ifndef UNIX
        *(ULONG*)pb = ipaddr;
#else
        memcpy(pb, &ipaddr, sizeof(ULONG));
#endif /* UNIX */
        return TRUE;
    }
    return FALSE;
}

const TCHAR cszFileProt[] = TEXT("file");

struct ZONEMAP_COMPONENTS
{
    // pointers into buffer passed to Crack
    LPCTSTR  pszProtocol, pszSite, pszDomain; 
    DWORD    cchProtocol, cchSite, cchDomain; 

    DWORD    nScheme;   // One of URL_SCHEME_* 
    BOOL     fAddr:1;    // whether name is in form of IP address
    BOOL     fIPRange:1; // whether name is in form of an IP Range.
    BYTE     bAddr[4];  // if IP address, components of IP address
    RANGE_ITEM rangeItem; // If IP Range, components of IP Range.

    BOOL     fDrive; // URL corresponds to a drive letter that couldn't be mapped to a network share name.
    DWORD    dwDriveType; // if so, drive type

    TCHAR    szProtBuf[INTERNET_MAX_SCHEME_LENGTH];
    TCHAR    szSiteBuf[MAX_PATH]; // used for remote drives
    TCHAR    szIPAddr[16];   // room for 255.255.255.255 + NULL
    
    HRESULT Crack (LPCTSTR pwszUrl, DWORD dwFlags, BOOL bIPRange = FALSE);

    BOOL SetUNC (LPSTR pszUNC);
};


BOOL ZONEMAP_COMPONENTS::SetUNC (LPSTR pszUNC)
{
    PerfDbgLog(tagZONEMAP_COMPONENTS, this, "+ZONEMAP_COMPONENTS::SetUNC");

    // Verify and strip leading backslashes.
    if (pszUNC[0] != '\\' || pszUNC[1] != '\\')
        return FALSE;
    pszUNC += 2;

    // Strip the share name from the host.
    LPSTR pszSlash = StrChrA (pszUNC, '\\');
    if (!pszSlash)
        return FALSE;
    *pszSlash = 0;
    DWORD cchUNC = (DWORD) (pszSlash - pszUNC);

    // Convert back to unicode.
    cchSite = MultiByteToWideChar
        (CP_ACP, 0, pszUNC, cchUNC, szSiteBuf, MAX_PATH);
    szSiteBuf[cchSite] = 0;
    pszSite = szSiteBuf;

    PerfDbgLog(tagZONEMAP_COMPONENTS, this, "-ZONEMAP_COMPONENTS::SetUNC");
    return TRUE;        
}


// Helper functions to help with URL cracking.

inline BOOL IsDosPath(LPCTSTR p)
{
#ifndef unix
    return (*p == BACKSLASH 
                || 
            /* it starts with "x:" where x is from the English alphabet */
                ( (*p) && 
                  ((*p >= TEXT('a') && *p <= TEXT('z')) || (*p >= TEXT('A') && *p <= TEXT('Z'))) && 
                  p[1] == COLON) );
#else
    return (*p == SLASH);
#endif /* unix */
}
    
inline BOOL IsDrive(LPCTSTR p)
{
#ifndef unix
    return (*p && (p[1] == COLON || p[1] == BAR));
#else
    return (*p == SLASH);
#endif /* unix */
}

inline BOOL IsWildcardScheme(LPCTSTR p, BOOL &bImplicit)
{
    BOOL bRet = FALSE;
    if ( p && *p )
    {
        if (*p == WILDCARD && p[1] == COLON)
        {
            bRet = TRUE;
            bImplicit = FALSE;
        }
        else if (StrChr(p, COLON) == NULL) 
        {
            // If there is no Colon in the string the user didn't specify a scheme
            // and we will assume it is a wildcard.
            // i.e *:*.microsoft.com is treated the same as *.microsoft.com

            bRet = TRUE;
            bImplicit = TRUE;
        }
    }
    return bRet;
}

// A scheme is opaque if we cannot interpret the URL after the scheme.
inline BOOL IsOpaqueScheme(DWORD dwScheme)
{
    return (dwScheme != URL_SCHEME_FILE && dwScheme != URL_SCHEME_WILDCARD && !IsHierarchicalScheme(dwScheme));
}


// Global Init functions.

BOOL CSecurityManager::GlobalInit( )
{
    InitializeCriticalSection(&s_csectIP);
    InitializeCriticalSection(&s_csectAList);
     
    CSecurityManager::s_bcsectInit = TRUE;
    return TRUE;
}
        
BOOL CSecurityManager::GlobalCleanup( )
{
    delete [] s_pRanges; 
    s_pRanges = NULL;

    if(s_clsidAllowedList)
    {
        delete [] s_clsidAllowedList;
        s_clsidAllowedList = NULL;
    }
    

    if ( s_bcsectInit )
    {
        DeleteCriticalSection(&s_csectIP) ; 
        DeleteCriticalSection(&s_csectAList);
    }

    return TRUE; 
}

VOID CSecurityManager::IncrementGlobalCounter( )
{
    CSecurityManager::CSecMgrCache::IncrementGlobalCounter( );
}

// Helper functions to deal with caching MapUrlToZone results.
    
HRESULT ZONEMAP_COMPONENTS::Crack (LPCTSTR pszScan, DWORD dwFlags, BOOL bIPRange /* = FALSE*/)
{
    PerfDbgLog(tagZONEMAP_COMPONENTS, this, "+ZONEMAP_COMPONENTS::Crack");
    fDrive = FALSE;
    fAddr = FALSE;
    fIPRange = FALSE;
    LPCTSTR  pszSiteUrl = pszScan;

    nScheme = URL_SCHEME_INVALID;
        
    if (IsDosPath(pszScan))
        dwFlags |= PUAF_ISFILE;
    
    if (dwFlags & PUAF_ISFILE)
    {
        pszProtocol = cszFileProt;
        cchProtocol = CSTRLENW(cszFileProt);
        nScheme = URL_SCHEME_FILE;
    }
    else
    {
        PARSEDURL pu;
        pu.cbSize = sizeof(pu);

        BOOL bImplicit = FALSE;        
        if ( (dwFlags & PUAF_ACCEPT_WILDCARD_SCHEME) && 
             IsWildcardScheme(pszScan, bImplicit)
           )
        {
            nScheme = URL_SCHEME_WILDCARD;
            pszProtocol = &chWildCard;
            cchProtocol = 1;
            // Skip over the *: if the user entered this explicity.
            if (!bImplicit)
                pszScan += 2;
        }
        else
        {
            HRESULT hr = ParseURL(pszScan, &pu);

            if (SUCCEEDED(hr))
            {
                nScheme = pu.nScheme;
                pszProtocol = pu.pszProtocol;

                cchProtocol = pu.cchProtocol;
                pszScan = pu.pszSuffix;
            }
            else
            {
                return hr;
            }

        }

        // Copy protocol to null terminate it.
        if (cchProtocol >= INTERNET_MAX_SCHEME_LENGTH)
            return E_INVALIDARG;
        else
        {
            memcpy (szProtBuf, pszProtocol, sizeof(TCHAR) * cchProtocol);
            szProtBuf[cchProtocol] = 0;
            pszProtocol = szProtBuf;
        }
    }
    

    // Opaque URLs - We cannot interpret anything besides the scheme. 
    // Just Treat the rest of the string as the Site.
    if (IsOpaqueScheme(nScheme))
    {
        pszSite = pszScan;
        cchSite = lstrlen(pszSite);
        pszDomain = NULL;
        cchDomain = 0;
    }
    else 
    {
#ifndef unix
        if(nScheme == URL_SCHEME_FILE)
        {
            const TCHAR UncRoot1[] = TEXT("\\\\?\\");
            const TCHAR UncRoot2[] = TEXT("\\\\.\\");
            const TCHAR szUnc[]    = TEXT("UNC\\");

            if (0 == StrCmpNICW(pszScan, UncRoot1, ARRAYSIZE(UncRoot1)-1) || 
                0 == StrCmpNICW(pszScan, UncRoot2, ARRAYSIZE(UncRoot2)-1))
            {
                // If the url starts with \\?\ or \\.\ .
                pszScan += ARRAYSIZE(UncRoot1) - 1;
                // First check if it is in the form of \\?\c:. If it is, don't move pszScan
                if (pszScan[0] == 0)
                    return E_INVALIDARG;
                else if (pszScan[1] != TEXT(':'))
                {
                    if (0 == StrCmpNICW(pszScan, szUnc, ARRAYSIZE(szUnc) - 1))
                        pszScan += ARRAYSIZE(szUnc) - 1;
                    else
                        return E_INVALIDARG;
                }
            }
            else
            {
                DWORD dwSize = ARRAYSIZE(szSiteBuf);
                HRESULT  hr = PathCreateFromUrl( pszSiteUrl, szSiteBuf, &dwSize, NULL);
                if(SUCCEEDED(hr))
                {
                    pszScan = szSiteBuf;
                }
            }
        }

        // Scan past leading '/' and '\' before site.
        while (*pszScan == SLASH || *pszScan == BACKSLASH)
            pszScan++;
#endif /* unix */ 
        pszSite = pszScan;

        // Is this a drive letter. If so we need to figure out whether it is local or remote.
        if (nScheme == URL_SCHEME_FILE && pszSite[0] != WILDCARD && IsDrive(pszSite))
        {
            fDrive = TRUE;

            char szDriveRoot[4];
            szDriveRoot[0] = (BYTE) pszSite[0];
#ifndef unix
            szDriveRoot[1] = ':';
            szDriveRoot[2] = '\\';
            szDriveRoot[3] = 0;
#else
        szDriveRoot[1] = 0;
#endif /* unix */

            dwDriveType = GetDriveTypeFromCacheA (szDriveRoot);

            if (dwDriveType == DRIVE_REMOTE)
            {
                // Strip the trailing backslash.
                szDriveRoot[2] = 0;
            
                char szUNC[MAX_PATH];
                DWORD cchUNC;
                cchUNC = MAX_PATH;

                if (NO_ERROR == WNetGetConnectionA(szDriveRoot, szUNC, &cchUNC))
                {
                    fDrive = FALSE;
                    SetUNC (szUNC);
                }
            }
        }
        
        // SetUNC might have come back with a new site. 
        
        pszScan = pszSite;

        if (fDrive)
        {
            // Just start using the drive as is. 
            cchSite = lstrlen(pszSite);
            cchDomain = 0;
            pszDomain = NULL;
        }
        else
        {
                    
            // Scan for characters which delimit site.
            while (1)
            {
                switch (*pszScan)
                {
                    case 0:        
                    case SLASH:    
                    case BACKSLASH:
                        break;
                
                    case TEXT('@'):
                        // This happens with custom protocols. Remove assert.
                        // TransAssert(FALSE);
                    default:
                        pszScan++;
                        continue;
                }
                break;        
            }

 
            cchSite = (DWORD) (pszScan - pszSite);

            pszDomain = NULL;
            cchDomain = 0;

            // Check for IP ranges if we are asked to first. 
            if (bIPRange)
            {
                fIPRange = ReadIPRule(pszSite, rangeItem.bLow, rangeItem.bHigh);
                if (fIPRange)
                    return S_OK;
            }

            // Windows Bug# 553626:
            // Note: IP address can be expressed in octal or hex, but we don't support them:
            if(cchSite < ( sizeof(szIPAddr) / sizeof(TCHAR) ))
            {
                StrCpyNW(szIPAddr, pszSite, cchSite + 1);
                // Check for names that are form of an IP address.
                fAddr = ReadAddress (szIPAddr, bAddr);
                if (fAddr)
                {
                    cchSite = wnsprintf(szIPAddr, ARRAYSIZE(szIPAddr), TEXT("%d.%d.%d.%d"), bAddr[0], bAddr[1], bAddr[2], bAddr[3]);
                    pszSite = szIPAddr;
                    return S_OK;
                }
            }

            // Scan backward for second '.' indicating domain,
            // ignoring two-char int'l domains like "co.uk" etc.

            DWORD cDot = 0;
            LPCTSTR pszDot = NULL;

            while (pszScan > pszSite)
            {
                if ( (*pszScan == DOT) && (pszScan < pszSite + cchSite - 2) )
                {
                    ++cDot;
                    if (cDot == 1)
                    {
                        pszDot = pszScan;
                    }
                    else if (   cDot == 2
                             && pszDot    // Non-null only the 1st time
                             && pszDot == pszSite + cchSite - 3   // Only check .?? ending
                             && pszScan + 3 >= pszDot)   // Check distance between the dots
                    {
                        // The distance between the 2 dots is less than 3 chars (.?? or smaller),
                        // so don't count this as a dot and don't check again.
                        --cDot;
                        pszDot = NULL;
                    }
                    else
                    {
                        pszDomain = pszScan + 1;
                        cchDomain = (DWORD) (pszSite + cchSite - pszDomain); 
                        cchSite = (DWORD) (pszScan - pszSite);
                        break;
                    }
                }
                pszScan--;
            }
        }
    }

    PerfDbgLog(tagZONEMAP_COMPONENTS, this, "-ZONEMAP_COMPONENTS::Crack");
    return S_OK;
}
    


// Function to get a new IInternetSecurityManager from outside. We might replace this
// with a standard class factory eventually.

STDAPI 
InternetCreateSecurityManager
(
    IUnknown * pUnkOuter,
    REFIID  riid,
    void **ppvObj,
    DWORD dwReserved
)
{
    PerfDbgLog(tagCSecurityManager, NULL, "+InternetCreateSecurityManager");
   
    HRESULT hr = S_OK;      
    *ppvObj = NULL;

    if ( !IsZonesInitialized() )
        return E_UNEXPECTED;

    if (dwReserved != 0 || !ppvObj || (pUnkOuter && riid != IID_IUnknown))
    {
        // If the object has to be aggregated the caller can only ask
        // for an IUnknown back.
        hr = E_INVALIDARG;
    }
    else 
    {
        CSecurityManager * pSecMgr = new CSecurityManager(pUnkOuter, (IUnknown **)ppvObj);

        if ( pSecMgr )
        {

            if (riid == IID_IUnknown || riid == IID_IInternetSecurityManager)
            {
                // The correct pointer is in ppvObj
                *ppvObj = (IInternetSecurityManager *)pSecMgr;
            }
            else 
            {
                hr = E_NOINTERFACE;
            }
        }
        else 
        {
            hr = E_OUTOFMEMORY;
        }
    }

    PerfDbgLog1(tagCSecurityManager, NULL, "-InternetCreateSecurityManager (hr:%lx)", hr);

    return hr;
}


// Class Initialization-Destruction.


CSecurityManager::CSecurityManager(IUnknown *pUnkOuter, IUnknown** ppUnkInner)
{
    PerfDbgLog(tagCSecurityManager, this, "+CSecurityManager::CSecurityManager");

    DllAddRef();

    m_pSite = NULL;
    m_pDelegateSecMgr = NULL;

    m_pZoneManager = NULL;
    
    if (!pUnkOuter)
    {
        pUnkOuter = &m_Unknown;
    }
    else
    {
        TransAssert(ppUnkInner);
        if (ppUnkInner)
        {
            *ppUnkInner = &m_Unknown;
            m_ref = 0;
        }
    }

    m_pUnkOuter = pUnkOuter;
    m_fHardened = IEHardened();

    if (ERROR_SUCCESS != m_regZoneMap.Open (NULL, SZZONEMAP, KEY_READ))
        goto done;

    EnterCriticalSection(&s_csectIP);
    if (!s_bIPInit)
    {
        ReadAllIPRules();
        s_bIPInit = TRUE;
    }
    LeaveCriticalSection(&s_csectIP);
    
done:
    PerfDbgLog(tagCSecurityManager, this, "-CSecurityManager::CSecurityManager");
    return;
}


CSecurityManager::~CSecurityManager()
{
    // Due to a circular dependency between wininet and urlmon, this function 
    // could get called after the dlls global uninit has happened. PerfDbgLog depends on
    // some global Mutext objects and fails because of this reason.
    // PerfDbgLog(tagCSecurityManager, this, "+~CSecurityManager::CSecurityManager");

    if (m_pZoneManager != NULL)
        m_pZoneManager->Release();

    if (m_pSite != NULL)
        m_pSite->Release();

    if (m_pDelegateSecMgr != NULL)
        m_pDelegateSecMgr->Release();
    
    DllRelease();

    // PerfDbgLog(tagCSecurityManager, this, "-~CSecurityManager::CSecurityManager");
}

BOOL CSecurityManager::EnsureZoneManager()
{
    if (m_pZoneManager == NULL)
    {
        if (SUCCEEDED(InternetCreateZoneManager(NULL, 
                          IID_IInternetZoneManager, (void **)&m_pZoneManager, NULL)))
        {
            TransAssert(m_pZoneManager != NULL);
        }
    }
    
    return (m_pZoneManager != NULL);
}
                                
STDMETHODIMP CSecurityManager::CPrivUnknown::QueryInterface(REFIID riid, void** ppvObj)
{

    HRESULT hr = S_OK;
    
    *ppvObj = NULL;

    CSecurityManager * pSecurityManager = GETPPARENT(this, CSecurityManager, m_Unknown);
        
    if (riid == IID_IUnknown || riid == IID_IInternetSecurityManager)
    {
        *ppvObj = (IInternetSecurityManager *)pSecurityManager;
        pSecurityManager->AddRef();
    }
    else 
    {
        hr = E_NOINTERFACE;
    }

    
    return hr;
}
                
STDMETHODIMP_(ULONG) CSecurityManager::CPrivUnknown::AddRef()
{
    LONG lRet = ++m_ref;

    return lRet;
}

STDMETHODIMP_(ULONG) CSecurityManager::CPrivUnknown::Release()
{

    CSecurityManager *pSecurityManager = GETPPARENT(this, CSecurityManager, m_Unknown);

    LONG lRet = --m_ref;

    if (lRet == 0)
    {
        delete pSecurityManager;
    }

    return lRet;
}

HRESULT ReduceUrl(LPWSTR pwszSecUrl)
{
    HRESULT hr = S_OK;

     // Reduce the URL here.  Need to do this up to two times.
        for (int i = 1; i <= 2; i++)
        {
            if (StrChr(pwszSecUrl, PERCENT))
            {
                DWORD dwSecUrl = lstrlenW(pwszSecUrl) + 1;
                UrlUnescapeW(pwszSecUrl, NULL, 0, URL_UNESCAPE_INPLACE);

                if (g_bUseImprovedZoneCheck
                    && (i == 1)
                    && (!StrCmpNIW(pwszSecUrl, L"http:", 5)
                        || !StrCmpNIW(pwszSecUrl, L"https:", 6)))
                 {
                    //For Windows 546559
                    //Imitate wininet behavior
                    DWORD cchIn = dwSecUrl +2; //two for the "//"
                    LPWSTR pwzTemp = new WCHAR[cchIn];
                    if (!pwzTemp)
                    {
                        hr = E_OUTOFMEMORY;
                        goto quit;
                    }

                    CFreeStrPtr freeStr(pwzTemp);

                    WCHAR ch;
                    int j=0;

                    do
                    {
                        ch = (pwzTemp[j] = pwszSecUrl[j]);
                        ++j;
                    }
                    while (ch != L':');

                    if (StrCmpNIW(pwszSecUrl+j, L"//", 2))
                        StrCpyNW(pwzTemp+j, L"//", cchIn-j);
                    else
                        pwzTemp[j] = L'\0';
                    StrCatBuffW(pwzTemp, pwszSecUrl+j, cchIn);                                
                    HRESULT hrLocal = UrlGetPartW(pwzTemp, pwszSecUrl, &dwSecUrl, URL_PART_HOSTNAME, URL_PARTFLAG_KEEPSCHEME);

                    DEBUG_PRINT(19,
                        INFO,
                        ("called UrlGetPartW %.100wq, %.100wq, hrLocal=0x%x\n",
                        pwzTemp, pwszSecUrl, hrLocal
                        ));

                    if (FAILED(hrLocal))
                    {
                        hr = hrLocal;
                        goto quit;
                    }
                }
            }
            else
                break;
        }

quit:
    return hr;
}

HRESULT CSecurityManager::WrapMapUrlToZone(LPCWSTR pwszSecUrl, ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, DWORD dwFlags,
                                BOOL *pfMarked, LPWSTR *ppszMarkURL)
{
    DEBUG_ENTER((DBG_API,
                Hresult,
                "CSecurityManager::WrapMapUrlToZone",
                "%.100wq, %#x, *pdwZone=%#x, dwFlags=%#x",
                pwszSecUrl, (pdwZone ? *pdwZone: 0), dwFlags
                ));

    HRESULT hr = S_OK;

    TransAssert (hr == S_OK);
    if (g_bUseImprovedZoneCheck
        && StrChr(pwszSecUrl, PERCENT)
        && (!StrCmpNIW(pwszSecUrl, L"http:", 5)
            || !StrCmpNIW(pwszSecUrl, L"https:", 6)))
    {
        //NOTICE: Windows 555438
        //Find the zone of twice unescaped url
        //to prevent zone inconsistencies,
        //between this and MapUrlToZone codepath
        ZONEMAP_COMPONENTS zc2;
        LPWSTR pwszRedSecUrl;
        DWORD dwSecUrl = lstrlenW(pwszSecUrl);
        pwszRedSecUrl = new WCHAR[dwSecUrl+1];
        StrCpyW(pwszRedSecUrl, pwszSecUrl);
        if (!pwszRedSecUrl)
        {
            DEBUG_LEAVE(E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }
        CFreeStrPtr freeStr(pwszRedSecUrl);

        hr = ReduceUrl(pwszRedSecUrl);

        if (FAILED(hr))
        {
            DEBUG_LEAVE(hr);
            return hr;
        }

        hr = zc2.Crack(pwszRedSecUrl, dwFlags);

        if (FAILED(hr))
        {
            //consistent with behavior in GetSecurityId.
            DEBUG_LEAVE(E_INVALIDARG);
            return E_INVALIDARG;
        }

        hr = MapUrlToZone (&zc2, pdwZone, dwFlags, pfMarked, ppszMarkURL);

        TransAssert (hr == S_OK);
    }
    else
    {
        hr = MapUrlToZone (pzc, pdwZone, dwFlags, pfMarked, ppszMarkURL);

        TransAssert (hr == S_OK);
    }

    DEBUG_LEAVE(((hr == S_OK) ? *pdwZone : hr));
    return hr;
}

// IUnknown methods
STDMETHODIMP CSecurityManager::QueryInterface(REFIID riid, void **ppvObj)
{
    PerfDbgLog(tagCSecurityManager, this, "+CSecurityManager::QueryInterface");
    HRESULT hr = E_NOINTERFACE;

    *ppvObj = NULL;

    if (riid == IID_IUnknown || riid == IID_IInternetSecurityManager)
    {
        *ppvObj = (IInternetSecurityManager *)this;
    }

    if (*ppvObj != NULL)
    {
        ((IUnknown *)*ppvObj)->AddRef();
        hr = S_OK;
    }

    PerfDbgLog1(tagCSecurityManager, this, "-CSecurityManager::QueryInterface (hr:%lx)", hr);
    return hr;
}

STDMETHODIMP_(ULONG) CSecurityManager::AddRef()
{
    LONG lRet = m_pUnkOuter->AddRef();

    return lRet;
}

STDMETHODIMP_(ULONG) CSecurityManager::Release()
{                            
    LONG lRet = m_pUnkOuter->Release();

    // Controlling Unknown will delete the object if reqd.
        
    return lRet;
}

// IInternetSecurityManager methods

STDMETHODIMP 
CSecurityManager::MapUrlToZone
(
    LPCWSTR pwszUrl,
    DWORD *pdwZone,
    DWORD dwFlags
)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CSecurityManager::MapUrlToZone",
                "%.100wq, %#x, *pdwZone=%#x, dwFlags=%#x",
                pwszUrl, (pdwZone ? *pdwZone: 0), dwFlags
                ));
                
    PerfDbgLog(tagCSecurityManager, this, "+CSecurityManager::MapUrlToZone");
    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (m_pDelegateSecMgr)
    {
        hr = m_pDelegateSecMgr->MapUrlToZone(pwszUrl, pdwZone, dwFlags);
    }

    // Check the cache to see if we already know the answer.
    /* BUGBUG - why are we stomping the delegate's result if we have a cache value?
    if ((NULL != m_pszPrevUrl) && (0 == StrCmpI(m_pszPrevUrl, pwszUrl)) && IsCounterEqual())
    { 
        hr = S_OK;
        *pdwZone = m_dwPrevZone;
    }
    */
            
    if (hr == INET_E_DEFAULT_ACTION)
    {
        LPWSTR pwszSecUrl = NULL;

        if (pdwZone == NULL || pwszUrl == NULL)
        {
            hr = E_INVALIDARG;
        }

        if (dwFlags & MUTZ_ENFORCERESTRICTED)
        {
            *pdwZone = URLZONE_UNTRUSTED;
            hr = S_OK;
        }
        else if (!s_smcache.Lookup(pwszUrl, pdwZone))
        {
            hr =  CoInternetGetSecurityUrl(pwszUrl, &pwszSecUrl, PSU_DEFAULT, 0);

            if (SUCCEEDED(hr))
            {
                TransAssert(pwszSecUrl);
                CFreeStrPtr freeStr(pwszSecUrl);

                hr = ReduceUrl(pwszSecUrl);

                if (FAILED(hr))
                {
                    goto quit;
                }

                ZONEMAP_COMPONENTS zc;
                if (SUCCEEDED(hr = zc.Crack (pwszSecUrl, dwFlags)))
                {
                    BOOL fMarked;

                    hr = MapUrlToZone (&zc, pdwZone, dwFlags, &fMarked);

                    if (hr == S_OK && !(dwFlags & MUTZ_NOCACHE))
                    {
                        s_smcache.Add(pwszUrl, *pdwZone, fMarked ); 
                    }
                }
            }
        }
        else 
        {
            hr = S_OK;
        }
    }

quit:
    PerfDbgLog1(tagCSecurityManager, this, "-CSecurityManager::MapUrlToZone (hr:%lx)", hr);

    DEBUG_LEAVE( (SUCCEEDED(hr) ? *pdwZone : hr));
    return hr;
}    

VOID 
CSecurityManager::PickZCString(ZONEMAP_COMPONENTS *pzc, LPCWSTR *ppwsz, DWORD *pcch, LPCWSTR pwszDocDomain)
{
    if (pzc->cchDomain)
    {
        TransAssert (!pzc->fDrive);
        // We should use the whole site even if we were able to get the
        // primary domain. i.e. security id for http://www.microsoft.com 
        // should be http:www.microsoft.com and NOT http:microsoft.com
        // We will use the fact that the domain and site are actually
        // pointing into one contiguous string to get back at the 
        // whole string.
        TransAssert((pzc->cchSite + 1) == (DWORD)(pzc->pszDomain - pzc->pszSite));
        TransAssert(pzc->pszSite[pzc->cchSite] == DOT);
        *ppwsz = pzc->pszSite;
        *pcch = pzc->cchSite + pzc->cchDomain + 1;
    }
    else if (pzc->fDrive && pzc->dwDriveType != DRIVE_REMOTE)
    {
        *ppwsz = TEXT("");
        *pcch = 0;
    }
    else if (pzc->nScheme == URL_SCHEME_FILE)
    {
        // For URL's of the nature \\server\sharename we want to include both the server and sharename in 
        // the security ID. This permits me from looking at \\server\private by putting up a page on 
        // \\server\public  At thuis point pzc->pszSite should point to the string "server\private\foo.htm"

        LPCTSTR lpszCurr = pzc->pszSite;
        BOOL bFoundFirstSlash = FALSE;
        
        for (; *lpszCurr != NULL ; lpszCurr++)
        {
            if (*lpszCurr == SLASH || *lpszCurr == BACKSLASH)
            {
                if (bFoundFirstSlash)
                {
                    // This is the second slash we are done.
                    break;
                }
                else
                {
                    bFoundFirstSlash = TRUE;
                }
            }
        }
                                        
        *ppwsz = pzc->pszSite;

        if (lpszCurr != NULL)
        {
            *pcch = (DWORD)(lpszCurr - pzc->pszSite);
        }
        else
        {
            TransAssert(FALSE);
            *pcch = pzc->cchSite;
        }
    }
    else
    {
        TransAssert (!pzc->pszDomain && !pzc->cchDomain);
        *ppwsz = pzc->pszSite;
        *pcch = pzc->cchSite;
    }

    // If the domain string passed is a suffix of the site string we will 
    // use that string instead.
    if (*pcch && pwszDocDomain != 0)
    {
        DWORD cchDocDomain = lstrlenW(pwszDocDomain);

        if (*pcch > cchDocDomain && 
            (0 == StrCmpNICW(pwszDocDomain, &((*ppwsz)[*pcch - cchDocDomain]), cchDocDomain)))
        {
            *ppwsz = pwszDocDomain;
            *pcch = cchDocDomain;
        }
    }   
}

STDMETHODIMP
CSecurityManager::GetSecurityId
(
        /* [in] */ LPCWSTR pwszUrl,
        /* [size_is][out] */ BYTE* pbSecurityId,
        /* [out][in] */ DWORD *pcbSecurityId,
        /* [in] */ DWORD_PTR dwReserved
)
{
    DEBUG_ENTER((DBG_API,
                Hresult,
                "CSecurityManager::GetSecurityId",
                "%.100wq",
                pwszUrl
                ));

    PerfDbgLog(tagCSecurityManager, this, "Called CSecurityManager::GetSecurityId");
    HRESULT hr = INET_E_DEFAULT_ACTION;
    DWORD       dwZone;

    // Check args ...
    if (pwszUrl == NULL || !pwszUrl[0] || !pcbSecurityId )
    {
        DEBUG_LEAVE(E_INVALIDARG);
        return E_INVALIDARG;
    }

    if (m_pDelegateSecMgr)
    {
        hr = m_pDelegateSecMgr->GetSecurityId(pwszUrl, pbSecurityId, pcbSecurityId, dwReserved);
    }

    if (hr == INET_E_DEFAULT_ACTION)
    {
        BOOL fFoundInCache;
        BOOL        fMarked = FALSE;
        DWORD       cbSecurityID = *pcbSecurityId;

        fFoundInCache = s_smcache.Lookup(pwszUrl, &dwZone, &fMarked, pbSecurityId, &cbSecurityID, (LPCWSTR)dwReserved);

        // if it wasn't in the cache, or the url and zone were there, but not the security ID,
        // then we still need to do some work.
        if ( !fFoundInCache || cbSecurityID == 0 )
        {
            LPWSTR pwszSecUrl = NULL;
            DWORD dwFlags = 0;

            hr = CoInternetGetSecurityUrl(pwszUrl, &pwszSecUrl, PSU_DEFAULT, 0);

            if (SUCCEEDED(hr))
            {
                TransAssert(pwszSecUrl != NULL);
                CFreeStrPtr freeStr(pwszSecUrl);

                // Crack the URL.
                ZONEMAP_COMPONENTS zc;
                LPWSTR pwszMarkURL = NULL;
                LPWSTR pwszSecUrl2 = NULL;

                if (S_OK != zc.Crack (pwszSecUrl, dwFlags))
                {
                    DEBUG_LEAVE(E_INVALIDARG);
                    return E_INVALIDARG;
                }
                
                // Select middle portion of Id.
                LPCWSTR psz2;
                DWORD  cch2;

                PickZCString(&zc, &psz2, &cch2, (LPCWSTR)dwReserved);
                // Identify the zone and determine if the ID will bear the 
                // Mark of the Web.
                
                // if the url was found in the cache, the an earlier MapUrlToZone
                // put it there with its zone and Marked flag, 
                if (!fFoundInCache || fMarked)
                {
                    hr = WrapMapUrlToZone (pwszSecUrl, &zc, &dwZone, 0, &fMarked, &pwszMarkURL);

                    if (hr != S_OK)
                    {
                        DEBUG_LEAVE(hr);
                        return hr;
                    }
                    // If the Mark of the Web is present, then take the Mark URL
                    // and substitute it for the original one in the zc, this will
                    // allow us to create a security ID that embodies the original
                    // domain, which in turn allows us to recreate the cross-domain
                    // frame security. The '*' we add to the end will prevent a
                    // potentially compromised page on the user's disk from accessing
                    // frames of the live, original site if the two should wind up
                    // in the same frameset.
                    if (fMarked)
                    {
                        TransAssert(pwszMarkURL != NULL);

                        hr = CoInternetGetSecurityUrl(pwszMarkURL, &pwszSecUrl2, PSU_DEFAULT, 0);

                        if (SUCCEEDED(hr))
                        {
                            TransAssert(pwszSecUrl2 != NULL);

                            if(SUCCEEDED(zc.Crack (pwszSecUrl2, dwFlags)))
                                PickZCString(&zc, &psz2, &cch2, (LPCWSTR)dwReserved);
                            else
                            {
                                if (pwszSecUrl2)  delete [] pwszSecUrl2;
                                if (pwszMarkURL)  LocalFree(pwszMarkURL);

                                DEBUG_LEAVE(E_INVALIDARG);
                                return E_INVALIDARG;
                            }
                        }
                    }
                }

                // Calculate required size of buffer.
                DWORD cbTail = sizeof(DWORD) + ((fMarked)? sizeof(CHAR) : 0);
                DWORD cbSite = 0;

                if (cch2 != 0)
                {
                    cbSite = WideCharToMultiByte(CP_ACP, 0, psz2, cch2,
                            NULL, 0, NULL, NULL);
                    if (cbSite == 0)
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        DEBUG_LEAVE(hr);
                        return hr;
                    }
                }

                DWORD cbRequired = zc.cchProtocol + 1 + cbSite + cbTail;

                if (*pcbSecurityId < cbRequired)
                {
                    *pcbSecurityId = cbRequired;
                    hr = HRESULT_FROM_WIN32 (ERROR_INSUFFICIENT_BUFFER);
                    DEBUG_LEAVE(hr);
                    return hr;
                }

                // Emit the protocol in ANSI.
                DWORD cbOut;
                cbOut = WideCharToMultiByte (CP_ACP, 0, zc.pszProtocol, zc.cchProtocol,
                    (LPSTR) pbSecurityId, *pcbSecurityId, NULL, NULL);
                if (cbOut != zc.cchProtocol)
                {
                    DEBUG_LEAVE(E_INVALIDARG);
                    return E_INVALIDARG; // non-ascii chars illegal in URL scheme
                }
                pbSecurityId[cbOut++] = ':';

                // Emit the site/domain in ANSI.
                if (cch2 != 0)
                {
                    cbSite = WideCharToMultiByte (CP_ACP, 0, psz2, cch2,
                        (LPSTR) pbSecurityId + cbOut, *pcbSecurityId - cbOut, NULL, NULL);
                }


                // HACK: Need to figure out a better way to fix this. 
                // File: url's can come in with slashes and backslashes as seperators.
                // To prevent things from breaking we replace any slashes in the 
                // pbSecurityId with a backslash.
                if (zc.nScheme == URL_SCHEME_FILE && cch2 != 0)
                {
                    LPSTR lpszStart = (LPSTR)pbSecurityId + cbOut;
                    LPSTR lpsz = lpszStart;

                    while (lpsz < lpszStart + cbSite)
                    {
                        if (*lpsz == '/')
                            *lpsz = '\\';

                        lpsz = CharNextA(lpsz);
                    }
                }

                cbOut += cbSite;

                // Downcase the buffer.
                pbSecurityId[cbOut] = 0;
                CharLowerA ((LPSTR) pbSecurityId);

                // Add the zone.
                memcpy(pbSecurityId + cbOut, &dwZone, sizeof(DWORD));

                if (fMarked)
                {
                    CHAR chMark = WILDCARD;
                    memcpy(pbSecurityId + cbOut + sizeof(DWORD), &chMark, sizeof(CHAR));
                }

                // Report the output data size.
                *pcbSecurityId = cbRequired;

                // Now that we have all the pieces, (re)add it to the cache
                s_smcache.Add(pwszUrl, dwZone, fMarked, pbSecurityId, cbRequired, (LPCWSTR)dwReserved);

                if (pwszSecUrl2)
                    delete [] pwszSecUrl2 ;

                if (pwszMarkURL)
                    LocalFree(pwszMarkURL);

            } // got security URL 
            
        } // got security URL
        else
        {
            // Got it from the cache.
            *pcbSecurityId = cbSecurityID;
            hr = S_OK;
        }
    } // delegate missing or wants us to do the work

    DEBUG_LEAVE(((hr == S_OK)? dwZone : hr));
    return hr;
}


// Helper functions to do generic UI from within ProcessUrlAction.

struct ActionStrIDMap 
{
    DWORD dwAction;
    DWORD dwStrID;
};

ActionStrIDMap actionAlertIDMap [ ]  = 
{
    { URLACTION_DOWNLOAD_SIGNED_ACTIVEX,            IDS_ACTION_DL_SIGNED_ACTIVEX        },
    { URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX,          IDS_ACTION_DL_ACTIVEX               },

    { URLACTION_ACTIVEX_RUN,                        IDS_ACTION_AX_RUN                   },
    { URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY,     IDS_ACTION_AX_OVERRIDE_SAFETY       },
    { URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY,       IDS_ACTION_AX_OVERRIDE_DATA_SAFETY  },
    { URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY,     IDS_ACTION_AX_OVERRIDE_SCRIPT_SAFETY},
    { URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY,     IDS_ACTION_AX_CONFIRM_NOSAFETY      },

    { URLACTION_SCRIPT_RUN,                         IDS_ACTION_SCRIPT_RUN               },
    { URLACTION_SCRIPT_OVERRIDE_SAFETY,             IDS_ACTION_SCRIPT_OVERRIDE_SAFETY   },
    { URLACTION_SCRIPT_JAVA_USE,                    IDS_ACTION_SCRIPT_JAVA              },
    { URLACTION_SCRIPT_SAFE_ACTIVEX,                IDS_ACTION_SCRIPT_SAFE_ACTIVEX      },
    { URLACTION_CROSS_DOMAIN_DATA,                  IDS_ACTION_CROSS_DOMAIN_DATA        },
    { URLACTION_SCRIPT_PASTE,                       IDS_ACTION_SCRIPT_PASTE             },

    { URLACTION_HTML_SUBMIT_FORMS,                  IDS_ACTION_HTML_FORMS               },
    { URLACTION_HTML_SUBMIT_FORMS_FROM,             IDS_ACTION_HTML_FORMS               },
    { URLACTION_HTML_SUBMIT_FORMS_TO,               IDS_ACTION_HTML_FORMS               },
    { URLACTION_HTML_FONT_DOWNLOAD,                 IDS_ACTION_HTML_FONT_DL             },
    { URLACTION_HTML_JAVA_RUN,                      IDS_ACTION_HTML_JAVA                },
    { URLACTION_HTML_USERDATA_SAVE,                 IDS_ACTION_HTML_USERDATA            },
    { URLACTION_HTML_SUBFRAME_NAVIGATE,             IDS_ACTION_HTML_SUBFRAME_NAVIGATE   },
    { URLACTION_HTML_META_REFRESH,                  IDS_ACTION_HTML_META_REFRESH        },
    { URLACTION_HTML_MIXED_CONTENT,                 IDS_ACTION_HTML_MIXED_CONTENT            },

    { URLACTION_SHELL_INSTALL_DTITEMS,              IDS_ACTION_SHELL_INSTALL_DTITEMS    }, 
    { URLACTION_SHELL_MOVE_OR_COPY,                 IDS_ACTION_SHELL_MOVE_OR_COPY       },
    { URLACTION_SHELL_FILE_DOWNLOAD,                IDS_ACTION_SHELL_FILE_DL            },
    { URLACTION_SHELL_VERB,                         IDS_ACTION_SHELL_VERB               },
    { URLACTION_SHELL_WEBVIEW_VERB,                 IDS_ACTION_SHELL_WEBVIEW_VERB       },

    { URLACTION_CREDENTIALS_USE,                    IDS_ACTION_NW_CREDENTIALS           },
    { URLACTION_AUTHENTICATE_CLIENT,                IDS_ACTION_NW_AUTH_CLIENT           },
    { URLACTION_COOKIES,                            IDS_ACTION_NW_COOKIES               },
    { URLACTION_COOKIES_SESSION,                    IDS_ACTION_NW_COOKIES_SESSION       },
    { URLACTION_CLIENT_CERT_PROMPT,                 IDS_ACTION_NW_CLIENT_CERT_PROMPT    },
    { URLACTION_COOKIES_THIRD_PARTY,                IDS_ACTION_NW_COOKIES_THIRD_PARTY   },
    { URLACTION_COOKIES_SESSION_THIRD_PARTY,        IDS_ACTION_NW_COOKIES_SESSION_THIRD_PARTY },
};

ActionStrIDMap actionWarnIDMap [ ]  = 
{
    { URLACTION_SHELL_INSTALL_DTITEMS,              IDS_WARN_SHELL_INSTALL_DTITEMS      }, 
    { URLACTION_SHELL_MOVE_OR_COPY,                 IDS_WARN_SHELL_MOVE_OR_COPY         },
    { URLACTION_SHELL_FILE_DOWNLOAD,                IDS_WARN_SHELL_FILE_DL              },
    { URLACTION_SHELL_VERB,                         IDS_WARN_SHELL_VERB                 },
    { URLACTION_SHELL_WEBVIEW_VERB,                 IDS_WARN_SHELL_WEBVIEW_VERB         },

    { URLACTION_HTML_SUBMIT_FORMS,                  IDS_WARN_HTML_FORMS                 },
    { URLACTION_HTML_SUBMIT_FORMS_FROM,             IDS_WARN_HTML_FORMS                 },
    { URLACTION_HTML_SUBMIT_FORMS_TO,               IDS_WARN_HTML_FORMS                 },
};   

STDMETHODIMP_(DWORD)
CSecurityManager::GetAlertIdForAction(DWORD dwAction)
{
    // The action should exist in our map.
    int count = ARRAYSIZE(actionAlertIDMap);

    for ( int i = 0 ; i < count ; i++ )
    {
        if (actionAlertIDMap[i].dwAction == dwAction)
        {
            return actionAlertIDMap[i].dwStrID;
        }
    }

    // If we get here the Action was invalid or we are missing an
    // entry in the map.
    TransAssert(FALSE);

    return IDS_ACTION_UNKNOWN;
}

STDMETHODIMP_(DWORD)
CSecurityManager::GetWarnIdForAction(DWORD dwAction)
{
    // The action should exist in our map.
    int count = ARRAYSIZE(actionWarnIDMap);

    for ( int i = 0 ; i < count ; i++ )
    {
        if (actionWarnIDMap[i].dwAction == dwAction)
        {
            return actionWarnIDMap[i].dwStrID;
        }
    }

    // If we get here the Action was invalid or we are missing an
    // entry in the map.
    TransAssert(FALSE);

    return IDS_WARN_UNKNOWN;
}

// INFRASTRUCTURE FOR REMEMBERING ANSWERS.
 
// Are the answers for this action supposed to persist. i.e. if the user says 'Yes' or 'No' for 
// these actions we will not requery them for the same URL for the duration of the security 
// manager.  

BOOL
CSecurityManager::CPersistAnswers::IsPersistentAnswerAction(DWORD dwAction)
{
    switch (dwAction)
    {
        case URLACTION_ACTIVEX_RUN:
        // This shouldn't happen because it is an aggregator
        case URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY:
        // These should never get called because of KludgeMapAggregatePolicy
        case URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY:
        case URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY:
        case URLACTION_SCRIPT_OVERRIDE_SAFETY:

        case URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY:
        case URLACTION_SCRIPT_RUN:
        case URLACTION_SCRIPT_JAVA_USE:
        case URLACTION_HTML_FONT_DOWNLOAD:
        case URLACTION_SCRIPT_SAFE_ACTIVEX:
        case URLACTION_CROSS_DOMAIN_DATA:
            return TRUE;
        default:
            return FALSE;
    }
}

// CAnswerEntry methods. 

CSecurityManager::CPersistAnswers::CAnswerEntry::CAnswerEntry(LPCWSTR pszUrl, DWORD dwAction, BOOL iAnswer)
{
    m_pNext = NULL;
    m_dwAction = dwAction;
    m_iAnswer = iAnswer;
    m_pszUrl = StrDup(pszUrl);
}

CSecurityManager::CPersistAnswers::CAnswerEntry::~CAnswerEntry( )
{
    if (m_pszUrl)
        LocalFree(m_pszUrl);           
}

BOOL CSecurityManager::CPersistAnswers::CAnswerEntry::MatchEntry(LPCWSTR pszUrl, DWORD dwAction)
{
    return (dwAction == m_dwAction && (0 == StrCmp(pszUrl, m_pszUrl)));
}

// CPersistAnswers methods.
CSecurityManager::CPersistAnswers::~CPersistAnswers( )
{
    // go through the CAnswerEntries and free them up. 
    CAnswerEntry * pEntry = m_pAnswerEntry;

    while ( pEntry )
    {
        CAnswerEntry * pDelete = pEntry;
        pEntry = pEntry->GetNext( );
        delete pDelete;
    }
}                    

// Returns TRUE if the user already answered this questions. FALSE otherwise.
// 
BOOL CSecurityManager::CPersistAnswers::GetPrevAnswer(LPCWSTR pszUrl, DWORD dwAction, INT* piAnswer)
{
    BOOL bReturn = FALSE;
    CAnswerEntry * pAnswerEntry;

    if (!IsPersistentAnswerAction(dwAction))
        return FALSE;
                 
    for (pAnswerEntry = m_pAnswerEntry ; pAnswerEntry != NULL; pAnswerEntry = pAnswerEntry->GetNext())
    {
        if (pAnswerEntry->MatchEntry(pszUrl, dwAction))
        {
            if (piAnswer)
                *piAnswer = pAnswerEntry->GetAnswer( );

            bReturn = TRUE;
            break;
        }
    }

    return bReturn;
}

VOID CSecurityManager::CPersistAnswers::RememberAnswer(LPCWSTR pszUrl, DWORD dwAction, BOOL iAnswer)
{
    // Nothing to do if we are not supposed to be persisted. 
    if (!IsPersistentAnswerAction(dwAction))
        return;

    TransAssert(!GetPrevAnswer(pszUrl, dwAction, NULL));

    CAnswerEntry * pNew = new CAnswerEntry(pszUrl, dwAction, iAnswer);
    // Just don't persist answers if we don't have memory. 
    if (pNew == NULL || pNew->GetUrl() == NULL)
        return;

    pNew->SetNext(m_pAnswerEntry);
    m_pAnswerEntry = pNew;
    return;
}

BOOL
CSecurityManager::IsScriptOrActiveXHardenedInternet(DWORD dwAction, DWORD dwPermissions, DWORD dwZone)
{
    if 
    (
        IEHardened() &&  
        (dwAction == URLACTION_ACTIVEX_RUN || dwAction == URLACTION_SCRIPT_RUN) &&
        dwPermissions == URLPOLICY_DISALLOW && 
        dwZone == URLZONE_INTERNET
    )
    {
        // check if trust dialog enabled:
        DWORD dwValue = TRUE;  // default value of TRUSTDLG is TRUE
        HKEY hKeyIE = 0;

        // For applications, check only machine key:
        if (RegOpenKeyEx(IsBrowserHosted()? HKEY_CURRENT_USER: HKEY_LOCAL_MACHINE, 
            REGSTR_PATH_IE_MAIN, 0, KEY_READ, &hKeyIE) == ERROR_SUCCESS) 
        {
             DWORD dwLen = sizeof(dwValue);
        
             RegQueryValueEx(hKeyIE, REGVAL_TRUSTDLG_ENABLED, NULL,
                 NULL, (LPBYTE)&dwValue, &dwLen);
             RegCloseKey(hKeyIE);
        }

        return dwValue;    
    }

    return FALSE;

}

BOOL 
CSecurityManager::IsSiteInZone(LPCWSTR pszUrl, DWORD dwZone, IInternetSecurityManager *pSecMgr)
{
    BOOL fRet = FALSE;

    DWORD dwMappedZone;
    if (pSecMgr && SUCCEEDED(pSecMgr->MapUrlToZone(pszUrl, &dwMappedZone, 0)))
    {
        fRet = (dwZone == dwMappedZone);
    }

    return fRet;
}

BOOL 
CSecurityManager::ShowAddToSitesList(HWND hwnd, LPCWSTR pszUrl, DWORD dwZone)
{
    BOOL fRet = FALSE;
    HMODULE hmod = LoadLibrary(TEXT("inetcpl.cpl"));

    if(hmod)
    {
        BOOL (*pfnAddSitesDlg)(HWND, DWORD, LPCWSTR) = 
            (BOOL (*)(HWND, DWORD, LPCWSTR))GetProcAddress(hmod, "LaunchAddSitesDialog");
            
        if(pfnAddSitesDlg)
        {
            fRet = pfnAddSitesDlg(hwnd, dwZone, pszUrl);
        }
        FreeLibrary(hmod);
    }

    return fRet;
}

BOOL 
GetAddSitesDisplayUrl(LPCWSTR pszUrl, LPWSTR pszUrlDisplay, DWORD cchUrlDisplay)
{
    BOOL fRet = FALSE;
    HMODULE hmod = LoadLibrary(TEXT("inetcpl.cpl"));

    if(hmod)
    {
        BOOL (*pfnGetAddSitesDisplayUrl)(LPCWSTR, LPWSTR, DWORD) = 
            (BOOL (*)(LPCWSTR, LPWSTR, DWORD))GetProcAddress(hmod, "GetAddSitesDisplayUrl");
            
        if(pfnGetAddSitesDisplayUrl)
        {
            fRet = pfnGetAddSitesDisplayUrl(pszUrl, pszUrlDisplay, cchUrlDisplay);
        }
        FreeLibrary(hmod);
    }

    return fRet;
}

// Encapsulate common functionality:
HWND CSecurityManager::SetControlText(HWND hDlg, UINT ctrlID, DWORD dwStrId, LPCWSTR pszDomain)
{
        WCHAR  rgszAlert[MAX_ALERT_SIZE];

        if (::LoadStringWrapW(g_hInst, dwStrId, rgszAlert, MAX_ALERT_SIZE) == 0)
        {
            TransAssert(FALSE);
            ::LoadStringWrapW(g_hInst, IDS_ACTION_UNKNOWN, rgszAlert, MAX_ALERT_SIZE);
        }

        if(pszDomain != NULL)
        {
            WCHAR  rgszAlert2[MAX_ALERT_SIZE];
            wcsncpy(rgszAlert2, rgszAlert, ARRAYSIZE(rgszAlert2) - 1);
            wnsprintf(rgszAlert, ARRAYSIZE(rgszAlert) - 1, rgszAlert2, pszDomain);
        }

        HWND hwndAlertText = ::GetDlgItem(hDlg, ctrlID);

        TransAssert(hwndAlertText != NULL);
        ::SetWindowTextWrapW(hwndAlertText, rgszAlert);
        return hwndAlertText;
}

BOOL CSecurityManager::IsBrowserHosted()
{
    return (GetModuleHandle(TEXT("iexplore.exe")) != NULL 
            || GetModuleHandle(TEXT("explorer.exe")) != NULL);
}

void 
CSecurityManager::ShowUrlInNewBrowserInstance(LPCWSTR pwszUrl)
{
    SHOWURLINNEWBROWSERINSTANCE          pfSHOWURLINNEWBROWSERINSTANCE = NULL;
    HINSTANCE    hShdocvwLib;

    if ( ( hShdocvwLib = LoadLibrary( L"shdocvw.dll" ) ) != NULL )  
    {
        if ( pfSHOWURLINNEWBROWSERINSTANCE = (SHOWURLINNEWBROWSERINSTANCE)
            GetProcAddress( hShdocvwLib, (LPSTR)SHOWURLINNEWBROWSERINSTANCE_ORDINAL) ) 
        {
            pfSHOWURLINNEWBROWSERINSTANCE(pwszUrl);
        }
        FreeLibrary( hShdocvwLib );
    }
}

INT_PTR
CSecurityManager::TrustAlertDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    LPDLGDATA lpDlgData;
    HKEY hKeyIE = 0;

    switch (iMsg)
    {
        case WM_INITDIALOG:
        {
            lpDlgData = (LPDLGDATA)lParam;
            TransAssert(lpDlgData != NULL);

            // Squirrel away the DlgData for later use as initialization data for the Trusted Sites dialog
            SetWindowLongPtr(
                hDlg,
                DWLP_USER,
                (LONG_PTR)lpDlgData);

            UINT uID;
            BOOL bShowCheckbox;
            if(IsBrowserHosted())
            {
                if(!lpDlgData->bFromShdocvw)
                {
                    uID = IDS_TRUST_DLG_MSG_STRING_URLMON_IE_1;

                    // checkbox always checked:
                    bShowCheckbox = TRUE;
                }
                else
                {
                    // browser hosted shdocvw:
                    uID = IDS_TRUST_DLG_MSG_STRING_SHDOCVW_IE_1;

                    // Hide the checkbox:
                    bShowCheckbox = FALSE;
                }
            }
            else // Non-browser hosted weboc:
            {
                TransAssert(!lpDlgData->bFromShdocvw);
                uID = IDS_TRUST_DLG_MSG_STRING_URLMON_NONIE_1;

                // Hide the checkbox:
                bShowCheckbox = FALSE;
            }

            SetControlText(hDlg, IDC_TRUSTDLGTEXT1, uID);
            if(bShowCheckbox)
            {
                CheckDlgButton(hDlg, IDC_ENABLE_TRUSTDLG, BST_CHECKED);
            }
            else
            {
                ShowWindow(GetDlgItem(hDlg, IDC_ENABLE_TRUSTDLG), SW_HIDE);
            }
            
            SetControlText(hDlg, IDC_TRUSTDLGTEXT2, IDS_TRUST_DLG_MSG_STRING_URLMON_SHDOCVW_IE_NONIE_2);
            SetControlText(hDlg, IDC_TRUSTDLGTEXT3, IDS_TRUST_DLG_MSG_STRING_URLMON_SHDOCVW_IE_NONIE_WARNING);
            SetControlText(hDlg, IDC_URL, IDS_TRUST_DLG_MSG_STRING_URLMON_SHDOCVW_IE_NONIE_URL, lpDlgData->pstr);
            
            if(g_bUseHKLMOnly)
            {
                BOOL fEnable = TRUE;
                HINSTANCE hinstAdvPack = LoadLibraryA("ADVPACK.DLL");
                if (hinstAdvPack)
                {
                    ISNTADMIN pfnIsNTAdmin = (ISNTADMIN)GetProcAddress(hinstAdvPack, achISNTADMIN);

                    if (pfnIsNTAdmin)
                    {
                        fEnable = pfnIsNTAdmin(0, NULL);
                    }

                    FreeLibrary(hinstAdvPack);
                }

                EnableWindow(GetDlgItem(hDlg, IDC_ADD_TRUSTED_SITES), fEnable);
            }            
            
            if (lpDlgData->dwFlags & PUAF_FORCEUI_FOREGROUND)
            {
                SetForegroundWindow(hDlg);
            }

            // ensure that this window is topmost
            SetWindowPos(hDlg, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);

            return TRUE;
        }

        case WM_NOTIFY:
            if (IDC_ESC_HELP == LOWORD(wParam))
            {
                NMHDR *pnmh = (NMHDR*) lParam;
                if ((NM_CLICK == pnmh->code) || (NM_RETURN == pnmh->code))
                {
                    ShowUrlInNewBrowserInstance(L"res://shdoclc.dll/IESechelp.htm");
                }
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                 case IDCANCEL:
                    if( IsWindowVisible(GetDlgItem(hDlg, IDC_ENABLE_TRUSTDLG)) )
                    {
                        // persist value in registry:
                         hKeyIE = 0;
                         if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_IE_MAIN, 0, KEY_SET_VALUE, &hKeyIE) == ERROR_SUCCESS) 
                        {
                             DWORD dwValue = IsDlgButtonChecked(hDlg, IDC_ENABLE_TRUSTDLG) == BST_CHECKED;
                        
                             RegSetValueEx(hKeyIE, REGVAL_TRUSTDLG_ENABLED, NULL,
                                 REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));
                             RegCloseKey(hKeyIE);
                         }
                    }

                    // Check if site added to trusted list, if so return ZALERT_YES, to allow URLAction to succeed:
                    lpDlgData = (LPDLGDATA)GetWindowLongPtr(hDlg, DWLP_USER);
                    TransAssert(NULL != lpDlgData && NULL != lpDlgData->pstr && (lpDlgData->bFromShdocvw || NULL != lpDlgData->pSecurityManager));
                    EndDialog(hDlg, 
                        // check if the site was actually added to the trusted zone:
                        IsSiteInZone(lpDlgData->pstr, URLZONE_TRUSTED, lpDlgData->pSecurityManager)? 
                            ZALERT_YES: ZALERT_NO);
                    return TRUE;
                    
                case IDC_ADD_TRUSTED_SITES:
                    // Show Trusted Sites dialog. 
                    lpDlgData = (LPDLGDATA)GetWindowLongPtr(hDlg, DWLP_USER);
                    TransAssert(NULL != lpDlgData && NULL != lpDlgData->pstr);
                    ShowAddToSitesList(hDlg, lpDlgData->pstr, URLZONE_TRUSTED);

                    // check if the site was actually added to the trusted zone:
                    
                    if (IsSiteInZone(lpDlgData->pstr, URLZONE_TRUSTED, lpDlgData->pSecurityManager))
                    {
                        EndDialog(hDlg, ZALERT_YES);
                    }
                    return TRUE;
            }

            break;
    }  /* end switch */

    return FALSE;
}

STDAPI_(int)
ShowTrustAlertDialog(HWND hwndParent, IInternetSecurityManager *pSecurityManager, LPVOID lpDlgDataIn, LPCWSTR pwszUrl )
{
    LPDLGDATA lpDlgData;
    DlgData dlgData;
    int nRet;
    WCHAR szUrl[MAX_ZONE_PATH];
    
    if(!lpDlgDataIn)
    {
        ZeroMemory(&dlgData, sizeof(dlgData));
        lpDlgData = &dlgData;
    }
    else
    {
        lpDlgData = (LPDLGDATA)lpDlgDataIn;
    }        

    if (!pSecurityManager && SUCCEEDED(EnsureSecurityManager()) )
        pSecurityManager = g_pSecurityManager;
    
    lpDlgData->pSecurityManager = pSecurityManager;
    lpDlgData->bFromShdocvw = !lpDlgDataIn;

    if (GetAddSitesDisplayUrl(pwszUrl, szUrl, ARRAYSIZE(szUrl)))
    {
        lpDlgData->pstr = szUrl;
    }
    else
    {
        // Should never reach here
        TransAssert(FALSE);
        lpDlgData->pstr = L"";
    }

    ULONG_PTR uCookie = 0;
    SHActivateContext(&uCookie);
    nRet = (int) ::DialogBoxParamWrapW (
                    g_hInst,
                    MAKEINTRESOURCEW(IDD_TRUST_ALERT),
                    hwndParent,
                    CSecurityManager::TrustAlertDialogProc,
                    (LPARAM)lpDlgData
                );
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }

    return nRet;
}
    


// This is the dialog proc for the generic Zones Alert dialog. 
// IMPORTANT: This is an ANSI function in an otherwise unicode world.
// BE EXTREMELY CAREFUL WHEN CALLING WINDOWS API FUNCTIONS.

INT_PTR
CSecurityManager::ZonesAlertDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    switch (iMsg)
    {
        case WM_INITDIALOG:
        {
            WCHAR  rgszAlert[MAX_ALERT_SIZE];
            LPDLGDATA lpDlgData = (LPDLGDATA)lParam;
            TransAssert(lpDlgData != NULL);

            SetControlText(hDlg, IDC_ZONEALERTTEXT, GetAlertIdForAction(lpDlgData->dwAction));

            if (lpDlgData->dwFlags & PUAF_FORCEUI_FOREGROUND)
            {
                SetForegroundWindow(hDlg);
            }

            // ensure that this window is topmost
            SetWindowPos(hDlg, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);

            return TRUE;
        }
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    EndDialog(hDlg, ZALERT_YES);
                    return TRUE;
                case IDCANCEL:
                    EndDialog(hDlg, ZALERT_NO);
                    return TRUE;
            }

            break;
    }  /* end switch */

    return FALSE;
}

// This is the dialog proc for the Alert displayed when information is posted over the net.
// This is a special case, since it is the only dialog where we let the user persist their change. 
// DO NOT START ADDING OTHER SPECIAL CASES TO THIS. IF YOU NEED TO, CONSIDER CHANGING THE 
// THE TEMPLATE POLICY FOR THE ZONE TO BE "CUSTOM" BECAUSE THE ZONE WILL START DIVERGING FROM
// THE TEMPLATE IT IS SUPPOSED TO BE BASED ON.

BOOL
CSecurityManager::IsFormsSubmitAction(DWORD dwAction)
{
    return (dwAction == URLACTION_HTML_SUBMIT_FORMS ||
            dwAction == URLACTION_HTML_SUBMIT_FORMS_FROM || 
            dwAction == URLACTION_HTML_SUBMIT_FORMS_TO
           );
}
            
INT_PTR
CSecurityManager::FormsAlertDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    switch (iMsg)
    {
        case WM_INITDIALOG:
        {
            LPDLGDATA lpDlgData = (LPDLGDATA)lParam;
            TransAssert(lpDlgData != NULL);
            LPCWSTR pstr = lpDlgData->pstr;
            
            if (pstr != NULL)
            {
                HWND hwnd = ::GetDlgItem(hDlg, IDC_ZONEALERTTEXT);
                TransAssert(hwnd != NULL);
                ::SetWindowTextWrapW(hwnd, pstr);
            }  
              
            if (lpDlgData->dwFlags & PUAF_FORCEUI_FOREGROUND)
            {
                SetForegroundWindow(hDlg);
            }

            if(!(lpDlgData->dwFlags & PUAF_DONTCHECKBOXINDIALOG))
            {
                CheckDlgButton(hDlg, IDC_DONT_WANT_WARNING, BST_CHECKED);
            }
            return TRUE;
        }
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                case IDYES:
                {
                    DWORD dwRet;
                    if (IsDlgButtonChecked(hDlg, IDC_DONT_WANT_WARNING) == BST_CHECKED)
                        dwRet = ZALERT_YESPERSIST;
                    else 
                        dwRet = ZALERT_YES;

                    EndDialog(hDlg, dwRet);
                    return TRUE;
                }

                case IDCANCEL:
                case IDNO:
                    EndDialog(hDlg, ZALERT_NO);
                    return TRUE;
            }

            break;
    }  /* end switch */

    return FALSE;
}

INT 
CSecurityManager::ShowFormsAlertDialog(HWND hwndParent, LPDLGDATA lpDlgData )
{
    int nRet;
    TransAssert(lpDlgData != NULL);
    TransAssert(IsFormsSubmitAction(lpDlgData->dwAction));

    // Compose the dialog string.
    LPWSTR pstr = NULL;
    WCHAR rgch[MAX_ALERT_SIZE]; 

    ZONEATTRIBUTES zc;
    zc.cbSize = sizeof(zc);
    if (SUCCEEDED(m_pZoneManager->GetZoneAttributes(lpDlgData->dwZone, &zc)))
    {
        WCHAR rgchStr[MAX_ALERT_SIZE];
        UINT uID = (lpDlgData->dwAction == URLACTION_HTML_SUBMIT_FORMS_FROM) ? IDS_ACTION_POST_FROM : IDS_ACTION_FORMS_POST;

        if (::LoadStringWrapW(g_hInst, uID, rgchStr, MAX_ALERT_SIZE) != 0)
        {
            if (wnsprintfW(rgch, MAX_ALERT_SIZE, rgchStr, zc.szDisplayName) != 0)
                pstr = rgch;
        }
    }

    lpDlgData->pstr = pstr;
    ULONG_PTR uCookie = 0;
    SHActivateContext(&uCookie);
    nRet =  (int) ::DialogBoxParamWrapW (
                        g_hInst,
                        MAKEINTRESOURCEW(IDD_WARN_ON_POST),
                        hwndParent,
                        CSecurityManager::FormsAlertDialogProc,
                        (LPARAM)lpDlgData
                    );
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }

    return nRet;
}
    
INT_PTR
CSecurityManager::ZonesWarnDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    switch (iMsg)
    {
        case WM_INITDIALOG:
        {
            WCHAR  rgszWarn[MAX_ALERT_SIZE];
            LPDLGDATA lpDlgData = (LPDLGDATA)lParam;
            TransAssert(lpDlgData != NULL);
            DWORD dwAction = lpDlgData->dwAction;

            SetControlText(hDlg, IDC_ZONEALERTTEXT, GetWarnIdForAction(dwAction));

            if (lpDlgData->dwFlags & PUAF_FORCEUI_FOREGROUND)
            {
                SetForegroundWindow(hDlg);
            }

            return TRUE;
        }
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
                    EndDialog(hDlg, ZALERT_YES);
                    return TRUE;
            }

            break;
    }  /* end switch */

    return FALSE;
}
            
// INETCPL calls this during _GetAddSitesDisplayUrl
// to get the correct file://UNC URL domain
// NOTE: The input URL pszUrl has to be atleast MAX_ZONE_PATH in size
STDAPI GetAddSitesFileUrl(LPWSTR /* [in, out] */ pszUrl)
{
    HRESULT hr = S_FALSE;

    ZONEMAP_COMPONENTS zc;
    
    // Conversion for UNC paths:
    if(SUCCEEDED(zc.Crack (pszUrl, 0 /* dwFlags */)) && zc.nScheme == URL_SCHEME_FILE 
        && !zc.cchDomain && !zc.fDrive && zc.pszSite && zc.cchSite
        )
    {
        // Guard against buffer overflow.
        if (ARRAYSIZE(L"file://") + zc.cchSite >= MAX_ZONE_PATH)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            // ZONEMAP_COMPONENTS components could be pointing directly into pszUrl, 
            // so create a new string to hold the result:
            DWORD nSizeNewFileUrl = ARRAYSIZE(L"file://") + zc.cchSite + 1;
            LPWSTR pwzNewFileUrl = new WCHAR [nSizeNewFileUrl];

            if ( pwzNewFileUrl != NULL )            
            {
                // convert to the form file://UNC
                StrCpyNW(pwzNewFileUrl, L"file://", ARRAYSIZE(L"file://") /* No of chars to copy incl NULL */);
                StrNCatW(pwzNewFileUrl, zc.pszSite, zc.cchSite + 1 /* Incl NULL */);
                StrCpyNW(pszUrl, pwzNewFileUrl, nSizeNewFileUrl /* No of chars to copy incl NULL */);

                delete [] pwzNewFileUrl;
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}


STDMETHODIMP
CSecurityManager::ProcessUrlAction
(
    LPCWSTR pwszUrl,
    DWORD dwAction,
    BYTE * pPolicy,
    DWORD cbPolicy,
    BYTE * pContext,
    DWORD cbContext,
    DWORD dwFlags,
    DWORD dwReserved
)
{
    DEBUG_ENTER((DBG_API,
                Hresult,
                "CSecurityManager::ProcessUrlAction",
                "%.100wq, %#x, dwFlags=%#x, dwReserved=%#x",
                pwszUrl, dwAction, dwFlags, dwReserved
                ));
                    
    PerfDbgLog(tagCSecurityManager, this, "+CSecurityManager::ProcessUrlAction");
    HRESULT hr = INET_E_DEFAULT_ACTION;
    DWORD dwZone = ZONEID_INVALID;


// First check if the delegation interface wants to handle this.
    if (m_pDelegateSecMgr)
    {
        if (pwszUrl && wcsncmp(pwszUrl, L"about:security_", 15) == 0)
        {
            hr = m_pDelegateSecMgr->ProcessUrlAction(L"about:blank", dwAction, pPolicy, cbPolicy, pContext, cbContext, dwFlags, dwReserved);
        }
        else
        {
            hr = m_pDelegateSecMgr->ProcessUrlAction(pwszUrl, dwAction, pPolicy, cbPolicy, pContext, cbContext, dwFlags, dwReserved);
        }
    }

    if (hr != INET_E_DEFAULT_ACTION)
    {
        // Delegation interface processed the request.
        DEBUG_LEAVE(hr);
        return hr;
    }

    if (!EnsureZoneManager())
    {
        DEBUG_LEAVE(E_UNEXPECTED);
        return E_UNEXPECTED;
    }

    // Increment our refcount so we don't get destroyed for the duration of this 
    // function.
    AddRef();

    if (dwFlags & PUAF_ENFORCERESTRICTED)
    {
        dwZone = URLZONE_UNTRUSTED;
        hr = S_OK;
    }        
    else
    {
        hr = MapUrlToZone(pwszUrl, &dwZone, dwFlags);
    }        

     
    if (SUCCEEDED(hr))
    {
        DWORD dwPolicy;

        hr = m_pZoneManager->GetZoneActionPolicy(dwZone, dwAction, (BYTE *)&dwPolicy, sizeof(dwPolicy), URLZONEREG_DEFAULT);        

        if (SUCCEEDED(hr))
        {
            DWORD dwPermissions = GetUrlPolicyPermissions(dwPolicy);
            BOOL    isScriptOrActiveXHardenedInternet = IsScriptOrActiveXHardenedInternet(dwAction, dwPermissions, dwZone);
            if(isScriptOrActiveXHardenedInternet)
            {
                // Make it a query:
                dwPermissions = URLPOLICY_QUERY;
            }

            // Are we supposed to be showing any UI here?
            if ( (( dwPermissions == URLPOLICY_QUERY && ( dwFlags & PUAF_NOUI) == 0 ) || 
                  ( dwPermissions == URLPOLICY_DISALLOW && ( dwFlags & PUAF_WARN_IF_DENIED) != 0))
                 && HIWORD(dwPolicy) == 0)
            {
                HWND hwndParent = NULL;
                // Show UI unless the host indicates otherwise.
                BOOL bShowUI = TRUE;
                if  (m_pSite != NULL)
                {
                    HRESULT hrGetWnd = m_pSite->GetWindow(&hwndParent);

                    // Host doesn't want us to show UI.
                    if (hrGetWnd == S_FALSE && hwndParent == INVALID_HANDLE_VALUE)
                        bShowUI = FALSE;
                    else if (FAILED(hrGetWnd))
                        hwndParent = NULL;

                    // Disable any modeless dialog boxes
                    m_pSite->EnableModeless(FALSE);
                }

                int nRet = -1;
                BOOL fRememberAnswer = FALSE;

                // structure used to pass information to the dialog proc's.
                DlgData dlgData;
                dlgData.dwAction = dwAction;
                dlgData.dwZone = dwZone;
                dlgData.pstr = NULL;
                dlgData.dwFlags = dwFlags | ((dwPolicy & URLPOLICY_DONTCHECKDLGBOX) ? PUAF_DONTCHECKBOXINDIALOG : 0);
                dwPolicy = dwPolicy & ~URLPOLICY_DONTCHECKDLGBOX; 
                if ( dwPermissions == URLPOLICY_QUERY )
                { 
                    // First check to see if the user already answered this question once.                
                    if (!m_persistAnswers.GetPrevAnswer(pwszUrl, dwAction, &nRet))
                    {

                        fRememberAnswer = TRUE;

                        if (!bShowUI)
                        {
                            // If we can't show UI just act as if the user said No.
                            nRet = ZALERT_NO;   
                        }
                        else if (IsFormsSubmitAction(dwAction))
                        {
                            nRet = ShowFormsAlertDialog(hwndParent, &dlgData);
                        }
                        else
                        {

                            if(isScriptOrActiveXHardenedInternet)
                            {
                                nRet = ShowTrustAlertDialog(hwndParent, (IInternetSecurityManager *)this, &dlgData, pwszUrl );
                            }
                            else
                            {
                                ULONG_PTR uCookie = 0;
                                SHActivateContext(&uCookie);
                                nRet = (int) ::DialogBoxParamWrapW (
                                                g_hInst,
                                                MAKEINTRESOURCEW(IDD_ZONE_ALERT),
                                                hwndParent,
                                                CSecurityManager::ZonesAlertDialogProc,
                                                (LPARAM)&dlgData
                                            );
                                if (uCookie)
                                {
                                    SHDeactivateContext(uCookie);
                                }
                            }
                        }
                    }
                }
                else 
                {
                    TransAssert(dwPermissions == URLPOLICY_DISALLOW);
                    if (bShowUI)
                    {
                        ULONG_PTR uCookie = 0;
                        SHActivateContext(&uCookie);

                        nRet = (int) ::DialogBoxParamWrapW (
                                        g_hInst,
                                        MAKEINTRESOURCEW(IDD_WARN_ALERT),
                                        hwndParent,
                                        CSecurityManager::ZonesWarnDialogProc,
                                        (LPARAM)&dlgData
                                    );
                        if (uCookie)
                        {
                            SHDeactivateContext(uCookie);
                        }
                    }
                }



                // If we failed to show the dialog we should just return
                // the policies unmodified.
                if (dwPermissions == URLPOLICY_QUERY && nRet != -1 )
                {
                    // Change the policy to reflect the users choice.
                    DWORD dwYesOnlyPolicy;
                    dwYesOnlyPolicy = dwPolicy | URLPOLICY_DONTCHECKDLGBOX; // copy old policy before it is changed  
                    
                    SetUrlPolicyPermissions(dwPolicy, nRet ? URLPOLICY_ALLOW : URLPOLICY_DISALLOW);
                   

                    if (fRememberAnswer)
                        m_persistAnswers.RememberAnswer(pwszUrl, dwAction, nRet);

                    // The only case where we should change the policy is we have a checkbox on the dialog
                    // we popped up that says "Don't ask me again". Today the only thing that does that is 
                    // the forms submit form. 
                    // TODO: create a more generic category name "CanDlgChangePolicy" or something like that
                    // instead of the specific IsFormsSubmitAction.

                    if (IsFormsSubmitAction(dwAction) && ((nRet == ZALERT_YESPERSIST) || (nRet == ZALERT_YES)))
                    {
                        
                        m_pZoneManager->SetZoneActionPolicy(dwZone, dwAction, 
                                                            (BYTE *)((nRet == ZALERT_YESPERSIST) ?  &dwPolicy : &dwYesOnlyPolicy), 
                                                            sizeof(dwPolicy), URLZONEREG_DEFAULT);                                 
                    }
                }
                                     
                if (m_pSite != NULL)
                {
                    m_pSite->EnableModeless(TRUE);
                }
            }
            
            TransAssert(cbPolicy == 0 || cbPolicy >= sizeof(DWORD));

            if (cbPolicy >= sizeof(DWORD) && pPolicy != NULL)                        
                *(DWORD *)pPolicy = dwPolicy;


            // Code to check for allowed list of directx objects 
            // for URLACTION_ACTIVEX_RUN
            if(dwAction == URLACTION_ACTIVEX_RUN &&
                dwPolicy == URLPOLICY_ACTIVEX_CHECK_LIST)
            {
                DWORD dwValue = 0;
                hr = CSecurityManager::GetActiveXRunPermissions(pContext, dwValue);
                *(DWORD *)pPolicy = dwValue;
            }            
            // normal allowed permissions            
            else if(GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_ALLOW)
            {
                hr = S_OK ;
            }
            else
            {
                hr = S_FALSE;
            }
        
        }
    }

    Release();

    DEBUG_LEAVE( (SUCCEEDED(hr) ? *((DWORD*)pPolicy) : hr) );
    return hr;                 
}

STDMETHODIMP
CSecurityManager::QueryCustomPolicy
(
    LPCWSTR pwszUrl,
    REFGUID guidKey,
    BYTE **ppPolicy,
    DWORD *pcbPolicy,
    BYTE *pContext,
    DWORD cbContext,
    DWORD dwReserved
)
{
    PerfDbgLog(tagCSecurityManager, this, "+CSecurityManager::QueryCustomPolicy");
    HRESULT hr = INET_E_DEFAULT_ACTION;
    DWORD dwZone = ZONEID_INVALID;
   
    if (m_pDelegateSecMgr)
    {
        hr = m_pDelegateSecMgr->QueryCustomPolicy(pwszUrl, guidKey, ppPolicy, pcbPolicy, pContext, cbContext, dwReserved);
    }

    if (hr == INET_E_DEFAULT_ACTION)
    {
        if (!EnsureZoneManager())
        {
            return E_UNEXPECTED;
        }

        if (SUCCEEDED(hr = MapUrlToZone(pwszUrl, &dwZone, NULL)))
        {
            hr = m_pZoneManager->GetZoneCustomPolicy(dwZone, guidKey, ppPolicy, pcbPolicy, URLZONEREG_DEFAULT);        
        }
        else 
        {
            hr = E_UNEXPECTED;
        }
    }

    return hr;                 
}


STDMETHODIMP
CSecurityManager::GetSecuritySite
(
    IInternetSecurityMgrSite **ppSite
)
{
    if (ppSite)
    {
        if (m_pSite)
            m_pSite->AddRef();

        *ppSite = m_pSite;
    }
    return S_OK;
}

STDMETHODIMP
CSecurityManager::SetSecuritySite
(
    IInternetSecurityMgrSite *pSite
)
{
    if (m_pSite)
    {
        m_pSite->Release();
    }

    if (m_pDelegateSecMgr)
    {
        m_pDelegateSecMgr->Release();
        m_pDelegateSecMgr = NULL;
    }

    m_pSite = pSite;

    if (m_pSite)
    {
        m_pSite->AddRef();

        IServiceProvider * pServiceProvider = NULL;

        if (SUCCEEDED(m_pSite->QueryInterface(IID_IServiceProvider, (void **)&pServiceProvider)))
        {
            TransAssert(pServiceProvider != NULL);

            if (SUCCEEDED(pServiceProvider->QueryService(
                                SID_SInternetSecurityManager, 
                                IID_IInternetSecurityManager,
                                (void **)&m_pDelegateSecMgr)))
            {
                TransAssert(m_pDelegateSecMgr != NULL);
            }
            else
            {
                m_pDelegateSecMgr = NULL;
            }
            pServiceProvider->Release();
        }
    }

    return S_OK;
}

    
// Mapping related functions

HRESULT
CSecurityManager::SetZoneMapping
(
    DWORD   dwZone,
    LPCWSTR pszPattern,
    DWORD   dwFlags
)
{
    PerfDbgLog(tagCSecurityManager, this, "+CSecurityManager::SetZoneMapping");
    HRESULT hr = INET_E_DEFAULT_ACTION;

    // Increment the counter so any cached url to zone mappings are invalidated.
    IncrementGlobalCounter( );

    if (m_pDelegateSecMgr)
    {
        hr = m_pDelegateSecMgr->SetZoneMapping(dwZone, pszPattern, dwFlags);
    }

    if (hr == INET_E_DEFAULT_ACTION)
    {
        BOOL bUseHardenedZone;
        
        if(bUseHardenedZone = (URLZONE_ESC_FLAG & dwZone) )
        {
            // Remove the special ESC flag bit to convert it to a regular URLZONE_XXX:
            dwZone &= ~URLZONE_ESC_FLAG;
        }
        
        LPWSTR pwszSecPattern = NULL;
        hr = CoInternetGetSecurityUrl(pszPattern, &pwszSecPattern, PSU_DEFAULT, 0);

        if (SUCCEEDED(hr))
        {
            CFreeStrPtr freeStr(pwszSecPattern);

            ZONEMAP_COMPONENTS zc;
            hr = zc.Crack (pwszSecPattern, PUAF_ACCEPT_WILDCARD_SCHEME, TRUE);
            if (hr != S_OK)
                return hr;

            ZONEATTRIBUTES za;
            za.cbSize = sizeof(za);

            if (!EnsureZoneManager())
                return E_OUTOFMEMORY;

            // IEHardening workaround: The "Flags" for the Trusted zone require "Server Authentication" by default for softened mode. 
            // In other words, only HTTPS sites can be added. But the default is to _not_ require https for hardened mode.
            // Since we don't have 2 sets of flags, and since the zone template is not readily accessible, we assume that 
            // http sites can in fact be added for URLZONE_ESC_FLAG | URLZONE_TRUSTED cases
            // Don't allow adding not https entries if the zone requires server verification.

            if( !(bUseHardenedZone && URLZONE_TRUSTED == dwZone && !IEHardened()) )
            {
                if (!(dwFlags & SZM_DELETE) && SUCCEEDED(m_pZoneManager->GetZoneAttributes(dwZone, &za)))
                {
                    if (za.dwFlags & ZAFLAGS_REQUIRE_VERIFICATION)
                    {
                        if (zc.nScheme != URL_SCHEME_HTTPS)
                        {
                            return E_ACCESSDENIED ;
                        }
                    }
                }                           
            }
                                
            if (zc.fIPRange)
            {
                hr = AddDeleteIPRule(&zc, dwZone, dwFlags);
                return hr;
            }
                                                                                         
            // Zone mappings for drive letters are hardcoded
            if (zc.fDrive)
                return E_INVALIDARG;        

            TCHAR szKeyName[MAX_PATH];
            DWORD cchKeyName = CSTRLENW(SZDOMAINS);

            if(bUseHardenedZone || m_fHardened)
            {
                cchKeyName = CSTRLENW(SZHARDENEDDOMAINS);
                memcpy (szKeyName, SZHARDENEDDOMAINS, sizeof(TCHAR) * cchKeyName);
            }
            else
            {
                cchKeyName = CSTRLENW(SZDOMAINS);
                memcpy (szKeyName, SZDOMAINS, sizeof(TCHAR) * cchKeyName);
            }

            // Guard against buffer overflow.
            if (cchKeyName + zc.cchDomain + 1 + zc.cchSite + 1 >= MAX_PATH)
                return E_INVALIDARG;

            if ((zc.cchDomain == 0 && zc.cchSite == 0) || (zc.cchProtocol == 0))
            {
                return E_INVALIDARG;
            }

            if (zc.pszDomain)
            {
                memcpy (szKeyName + cchKeyName,
                    zc.pszDomain, sizeof(TCHAR) * zc.cchDomain);
                // Null terminate for strchr.
                szKeyName[cchKeyName + zc.cchDomain] = TEXT('\0');
                if (StrChr(szKeyName + cchKeyName, WILDCARD) != NULL)
                    return E_INVALIDARG;

                cchKeyName += zc.cchDomain;
            }
            else
            {
                /*We need to catch the following here:
                 1. *.com
                 2. www.*
                 3. www.*.*
                 4. *.co.uk

                 All these show up if zc.pszDomain is NULL.
                 */

                 if (StrChr(zc.pszSite, WILDCARD) != NULL)
                    return E_INVALIDARG;
            }     
                 

            // Check for the simple wildcard case.
            // patterns such as *.microsoft.com where the only thing
            // after a * is the second-level domain.            
            if (zc.pszSite[0] == WILDCARD && zc.cchSite == 1)
            {
                if (!zc.pszDomain)
                    return E_INVALIDARG;
            }
            else
            {
                // Wildcards are only permitted at the begining of pattern.
                // So patterns such as *.foo.*.microsoft.com are invalid.

                if (zc.pszSite[0] == WILDCARD)
                {
                    // We already know that zc.cchSite is greater than 1
                    // because we would have caught it in the outer 'if' clause 
                    // otherwise.
                    if (zc.pszSite[1] != DOT)
                    {
                        return E_INVALIDARG;
                    }

                    // Skip over the leading *. and make sure there are no 
                    // other *'s in the string. 
                    if (StrRChr(zc.pszSite + 2, zc.pszSite + zc.cchSite, WILDCARD) != NULL)
                    {
                        return E_INVALIDARG;
                    }
                }

                if (zc.pszDomain)  // Add seperator only if we added a domain name.
                { 
                    szKeyName[cchKeyName++] = BACKSLASH;
                }
                else if (!IsOpaqueScheme(zc.nScheme) && 
                          (zc.pszSite[zc.cchSite - 1] == DOT || 
                           zc.pszSite[0] == DOT)
                        )

                {
                    // Catches invalid cases such as http://ohserv. or http://.inetsdk.
                    return E_INVALIDARG;
                }

                memcpy (szKeyName + cchKeyName,
                    zc.pszSite, sizeof(TCHAR) * zc.cchSite);

                if (!IsOpaqueScheme(zc.nScheme))
                { 
                    szKeyName[cchKeyName + zc.cchSite] = TEXT('\0');
                }
                cchKeyName += zc.cchSite;
            }
            szKeyName[cchKeyName] = 0;

            CRegKey regMap;

            DWORD dwErr;
    
            if (dwFlags & SZM_DELETE)
            {
                // Delete mapping if one exists.
                if (ERROR_FILE_NOT_FOUND == regMap.Open (m_regZoneMap, szKeyName, KEY_WRITE))
                    return S_OK; // nothing to delete
                if ((dwErr = regMap.DeleteValue (zc.pszProtocol)) == ERROR_SUCCESS)
                {
                    // Try reclaiming any registry key's which might be empty. 
                    regMap.Close();
                    m_regZoneMap.DeleteEmptyKey(szKeyName); 
                    if (zc.pszDomain)
                    {
                        DWORD cch;
                        if(bUseHardenedZone || m_fHardened)
                        {
                            cch = CSTRLENW(SZHARDENEDDOMAINS) + zc.cchDomain;
                        }
                        else
                        {
                            cch = CSTRLENW(SZDOMAINS) + zc.cchDomain;
                        }
                        szKeyName[cch] = TEXT('\0');
                        m_regZoneMap.DeleteEmptyKey(szKeyName);
                    }                               
                    return S_OK;
                }
                else 
                {
                    hr = HRESULT_FROM_WIN32(dwErr);
                }
            }
            else
            {
                // Creates new mapping.
                if ((dwErr = regMap.Create (m_regZoneMap, szKeyName, KEY_READ | KEY_WRITE)) == ERROR_SUCCESS)
                {
                    regMap.Close();
                    if ((dwErr = regMap.Open(m_regZoneMap, szKeyName, KEY_READ | KEY_WRITE)) != ERROR_SUCCESS)
                    {
                        return HRESULT_FROM_WIN32(GetLastError());
                    }

                    DWORD dwZoneEntry;
                    if (regMap.QueryValue(&dwZoneEntry, zc.pszProtocol) == ERROR_SUCCESS)
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
                    }
                    else if ((dwErr = regMap.SetValue (dwZone, zc.pszProtocol)) == ERROR_SUCCESS)
                    {
                        return S_OK;
                    }
                    else 
                    {
                        hr = HRESULT_FROM_WIN32(dwErr);
                    }
                }
                else 
                {
                    hr = HRESULT_FROM_WIN32(dwErr);
                }
            }
        }
    }

    return hr;
}

// Helper functions for GetZoneMappings

// Given a site name and a domain name composes the string 
// site.domain.com

HRESULT
CSecurityManager::ComposeUrlSansProtocol
(
    LPCTSTR pszDomain,
    int     cchDomain,
    LPCTSTR pszSite,
    int     cchSite,
    LPTSTR  *ppszRet,
    int     *pcchUrlSansProtocol
)
{

    if (ppszRet == NULL)
    {
       return E_INVALIDARG;
    }

    int cchUrlSansProtocol = cchSite + 1 /* . */ + cchDomain ;

    // Create the part of the string without the protocol 
    LPTSTR szUrlSansProtocol = new TCHAR [cchUrlSansProtocol + 1];


    if ( szUrlSansProtocol == NULL )            
    {
        *ppszRet = NULL;

        if (pcchUrlSansProtocol)
            *pcchUrlSansProtocol = 0;

        return E_OUTOFMEMORY;
    }

    LPTSTR szCurrent = szUrlSansProtocol;

    // Copy over the specific parts of the name. 
    if (pszSite != NULL)
    {
        memcpy(szCurrent, pszSite, cchSite * sizeof(TCHAR));
        szCurrent += cchSite;
        memcpy(szCurrent, TEXT("."), 1 * sizeof(TCHAR));
        szCurrent += 1;
    }

    memcpy(szCurrent, pszDomain, cchDomain * sizeof(TCHAR));
    szCurrent += cchDomain;

    // Finally copy over the trailing zero.
    szCurrent[0] = TEXT('\0');

    *ppszRet = szUrlSansProtocol;

    if (pcchUrlSansProtocol)
        *pcchUrlSansProtocol = cchUrlSansProtocol;

    return S_OK;
}
    

HRESULT
CSecurityManager::ComposeUrl
(
    LPCTSTR pszUrlSansProt,
    int cchUrlSansProt,
    LPCTSTR pszProtocol,
    int cchProtocol,
    BOOL bAddWildCard,
    LPTSTR * ppszUrl,
    int *pcchUrl
)
{
    if (ppszUrl == NULL)
    {
        return E_INVALIDARG;
    }

    BOOL bWildCardScheme = FALSE;
    BOOL bOpaqueScheme   = FALSE;

    if (cchProtocol == 1 && pszProtocol[0] == WILDCARD)
    {
        bWildCardScheme = TRUE;
        bOpaqueScheme = FALSE;
    }
    else
    {
        // Figure out if this is an an opaque scheme. 
        LPWSTR pszTemp = (LPWSTR)_alloca((cchProtocol + 2) * sizeof(TCHAR));
        memcpy(pszTemp, pszProtocol, cchProtocol * sizeof(TCHAR));
        pszTemp[cchProtocol] = TEXT(':');
        pszTemp[cchProtocol + 1] = TEXT('\0');

        PARSEDURL pu; 
        pu.cbSize = sizeof(pu);

        HRESULT hr = ParseURL(pszTemp, &pu);

        if (SUCCEEDED(hr))
        {
            bOpaqueScheme = IsOpaqueScheme(pu.nScheme);
        }
        else
        {
            bOpaqueScheme = TRUE;
        }
    }

    // cchUrl will have the eventual length of the string we will send out                    
    int cchUrl = cchUrlSansProt; 
                 
    
    if (bOpaqueScheme)
    {
        cchUrl += cchProtocol + 1;    // we have to add prot: to the URL
    }
    else if (bWildCardScheme)
    {
        // If the scheme is a wildcard we don't add it to the eventual display.
    }
    else
    {
       cchUrl += cchProtocol + 3;  // we have to add prot:// to the url.
    }

    // If we are not an opaque schema, we might need to add a wildcard character as well.
    if (!bOpaqueScheme && bAddWildCard)
    {
        cchUrl += 2; /* for *. */
    }

    LPTSTR szUrl = new TCHAR [cchUrl + 1];
    
    if (szUrl == NULL)
    {
        *ppszUrl = NULL;

        if (pcchUrl)
            *pcchUrl = 0;

        return E_OUTOFMEMORY;
    }

    LPTSTR szCurrent = szUrl;

    // if the scheme is wildcard we don't want to display the scheme at all.
    // i.e we will show *.microsoft.com and *:*.microsoft.com
    if (bWildCardScheme)
    {
        if (bAddWildCard)
        {
            memcpy(szCurrent, TEXT("*."), 2 * sizeof(TCHAR));
            szCurrent += 2;
        }
    }
    else
    {
        memcpy(szCurrent, pszProtocol, cchProtocol * sizeof(TCHAR));
        szCurrent += cchProtocol;

        if (bOpaqueScheme)
        {
            memcpy(szCurrent, TEXT(":"), 1 * sizeof(TCHAR));
            szCurrent += 1;
        }
        else
        {
            memcpy(szCurrent, TEXT("://"), 3 * sizeof(TCHAR));
            szCurrent += 3;
            if (bAddWildCard)
            {
                memcpy(szCurrent, TEXT("*."), 2 * sizeof(TCHAR));
                szCurrent += 2;
            }
        }           
    }

    memcpy(szCurrent, pszUrlSansProt, cchUrlSansProt * sizeof(TCHAR));
    szCurrent += cchUrlSansProt;

    szCurrent[0] = TEXT('\0');

    *ppszUrl = szUrl;
    if (pcchUrl)
        *pcchUrl = cchUrl;

    return S_OK;
}

HRESULT
CSecurityManager::AddIPRulesToEnum
(
    DWORD dwZone,
    CEnumString *pEnumString
)
{
    HRESULT hr = NOERROR;

    if ((HUSKEY)m_regZoneMap == NULL)
        return E_UNEXPECTED;

    CRegKey regRanges;
    DWORD cNumRanges = 0;
    TCHAR szKeyName[MAX_PATH] = SZRANGES;

    if(m_fHardened)
    {
        StrCpy(szKeyName, SZESCRANGES);
    }

    if (   ERROR_SUCCESS != regRanges.Open(m_regZoneMap, szKeyName, KEY_READ)
        || ERROR_SUCCESS != regRanges.QuerySubKeyInfo(&cNumRanges, NULL, NULL)
       )
    {
        return S_OK;  // Nothing to add if we can't open the key.       
    }
    
    if (cNumRanges == 0)
        return S_OK;

    DWORD cchMaxKey = 20;
    TCHAR rgchSansProtocol[MAX_PATH];
    DWORD iItem;

    for (iItem = 0 ; iItem < cNumRanges ; iItem++ )
    {
        DWORD cbName, cbRange;
        CRegKey regItem;
        cbName = cchMaxKey;
        cbRange = sizeof(rgchSansProtocol) - 3 * sizeof(TCHAR); 
                
        if  (  ERROR_SUCCESS == regRanges.EnumKey(iItem, szKeyName, &cbName)
            && ERROR_SUCCESS == regItem.Open(regRanges, szKeyName, KEY_READ)
            && ERROR_SUCCESS == regItem.QueryValue(rgchSansProtocol, SZRANGE, &cbRange) 
            )
        {
            LONG lRetProtocol = NOERROR;
            TCHAR rgchProtocol[MAX_PATH]; 
            DWORD dwZoneRead = ZONEID_INVALID;
            DWORD dwType;
            
            for ( DWORD dwIdxProt = 0 , cchP = ARRAYSIZE(rgchProtocol), dwSizeZoneId = sizeof(dwZoneRead);
                  (((lRetProtocol = regItem.EnumValue(dwIdxProt, rgchProtocol, &cchP, &dwType, &dwZoneRead, &dwSizeZoneId)) != ERROR_NO_MORE_ITEMS)
                   && (hr == NOERROR));
                   dwIdxProt++, cchP = ARRAYSIZE(rgchProtocol), dwSizeZoneId = sizeof(dwZoneRead), dwZoneRead = ZONEID_INVALID
                )
            {
#ifdef unix
                if (lRetProtocol == ERROR_MORE_DATA)
                    continue;
#endif /* unix */

                if (lRetProtocol != NOERROR)
                    break;
                
                if (dwSizeZoneId == 0 || cchP == 0 || rgchProtocol[0] == TEXT('\0')
                    || dwType != REG_DWORD || dwZoneRead == ZONEID_INVALID)
                    continue;
                                                         
                if (dwZone == dwZoneRead)
                {
                    int cchProtocol = lstrlen(rgchProtocol);
                    int cchRange = lstrlen(rgchSansProtocol);                    

                    LPTSTR szUrl = NULL;

                    if ( (SUCCEEDED(ComposeUrl(rgchSansProtocol, cchRange, rgchProtocol, cchProtocol, FALSE, &szUrl, NULL)))
                         && (SUCCEEDED(pEnumString->AddString(szUrl))))
                    {
                        if (szUrl != NULL)
                            delete [] szUrl;
                    }
                    else
                    {
                        if (szUrl != NULL)
                            delete [] szUrl;
                            
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                }
            } /* for each protocol */
        } 
    } /* for each range entry */

    return hr;
}

                                                                     
// Given a Registry key and a part to the URL, this function looks through the 
// 'values' in the registry looking for a zone match. When it finds one it adds the 
// strings to the CEnumString class that is passed in. 

HRESULT
CSecurityManager::AddUrlsToEnum
(
    CRegKey * pRegKey,
    DWORD dwZone, 
    LPCTSTR pszUrlSansProt,
    int cchUrlSansProt,
    BOOL bAddWildCard,
    CEnumString *pEnumString
)
{
    HRESULT hr = NOERROR;
    // Iterate over the values and make up the strings we need.
    LONG lRetProtocol = NOERROR;
    TCHAR rgszProtocol[MAX_PATH];
    DWORD dwZoneRead = ZONEID_INVALID;
    DWORD dwType;
                
    for ( DWORD dwIdxProt = 0 , cchP = sizeof(rgszProtocol)/sizeof(TCHAR), dwSizeZoneId = sizeof(dwZoneRead);
          (((lRetProtocol = pRegKey->EnumValue(dwIdxProt, rgszProtocol, &cchP, &dwType, &dwZoneRead, &dwSizeZoneId)) != ERROR_NO_MORE_ITEMS)
           && (hr == NOERROR));
           dwIdxProt++, cchP = sizeof(rgszProtocol)/sizeof(TCHAR), dwSizeZoneId = sizeof(dwZoneRead), dwZoneRead = ZONEID_INVALID
        )
    {
        if (lRetProtocol != NO_ERROR)
        {
            // Break out of this loop but keep trying other sites.
            break;
        }

        if (  dwSizeZoneId == 0 || cchP == 0 || rgszProtocol[0] == TEXT('\0') 
                || dwType != REG_DWORD || dwZoneRead == ZONEID_INVALID)
            continue;                       

        // Yippeee, finally found a match.
        if (dwZone == dwZoneRead)
        {
            int cchProtocol = lstrlen(rgszProtocol);

            LPTSTR szUrl = NULL;

            // Compose the name of the URL.
            if ( (SUCCEEDED(ComposeUrl(pszUrlSansProt, cchUrlSansProt, rgszProtocol, cchProtocol, bAddWildCard, &szUrl, NULL)))
                 && (SUCCEEDED(pEnumString->AddString(szUrl))))
            {
                // Both succeeded we have added this string to the enumeration. 
                // Just free up the memory and move on.
                if (szUrl != NULL)
                    delete [] szUrl;
            }
            else
            {
                if (szUrl != NULL)
                    delete [] szUrl;
                hr = E_OUTOFMEMORY;
                break;
            }
        }           
    }  /* for each protocol */

    return hr;
}

                       
HRESULT
CSecurityManager::GetZoneMappings
(
    DWORD dwZone,
    IEnumString **ppEnumString,
    DWORD dwFlags
)
{
    PerfDbgLog(tagCSecurityManager, this, "+CSecurityManager::GetZoneMappings");

    HRESULT hr = NOERROR;

    CEnumString *pEnumString = NULL;

    pEnumString = new CEnumString( );
    
    if (pEnumString == NULL)
        return E_OUTOFMEMORY;

    CRegKey regDomainRoot;


    // We setup three loops below.
    // 
    //      for each domain name
    //          for each site
    //              for each protocol. 
    // The one twist is that for each domain we also have to enumerate the sites
    // to deal with wildcards such as http://*.microsoft.com
    // 
    // BUGBUG: MAX_PATH is a safe assumption, but we should change this to get the 
    // memory dynamically.

    TCHAR rgszDomain[MAX_PATH]; 
    TCHAR rgszSite[MAX_PATH];
    TCHAR rgszProtocol[MAX_PATH];
    LONG lRetDomain = NOERROR;
    TCHAR szKeyName[MAX_PATH];

    if(m_fHardened)
    {
        lstrcpy (szKeyName, SZHARDENEDDOMAINS);
    }
    else
    {
        lstrcpy (szKeyName, SZDOMAINS);
    }
        
    if ( ((HUSKEY)m_regZoneMap != NULL) && 
         (regDomainRoot.Open(m_regZoneMap, szKeyName, KEY_READ) == NOERROR)
       )
    {
        // If we couldn't open the root, then no rules exist for any zone.
        // Return an empty enumerator
        for ( DWORD dwIdxDomain = 0, cchD = sizeof(rgszDomain)/sizeof(TCHAR) ;
              (((lRetDomain = regDomainRoot.EnumKey(dwIdxDomain, rgszDomain, &cchD)) != ERROR_NO_MORE_ITEMS)
               && (hr == NOERROR));
              dwIdxDomain++ , cchD = sizeof(rgszDomain)/sizeof(TCHAR)
            )
        {
            if (lRetDomain != NOERROR)
            {
                TransAssert(lRetDomain != ERROR_MORE_DATA);
                break;
            }
        
            TCHAR rgszSite[MAX_PATH];
            LONG lRetSite = NOERROR;
        
            // Open the key to the domain.
            CRegKey regDomain;

            if (regDomain.Open(regDomainRoot, rgszDomain, KEY_READ) != NOERROR )
            {
                // We couldn't open this domain for some reason, but we will
                // keep trying the other domains.  
                continue;
            }

            int cchDomain = lstrlen(rgszDomain);

            TransAssert((HUSKEY)regDomain != NULL);

            for ( DWORD dwIdxSite = 0 , cchS = sizeof(rgszSite)/sizeof(TCHAR) ;
                  (((lRetSite = regDomain.EnumKey(dwIdxSite, rgszSite, &cchS)) != ERROR_NO_MORE_ITEMS)
                    && (hr == NOERROR));
                  dwIdxSite++ , cchS = sizeof(rgszSite)/sizeof(TCHAR)
                )
            {
                if (lRetSite != NOERROR)
                {
                    TransAssert(lRetSite !=  ERROR_MORE_DATA);
                    break;      // We will break out of this loop but keep trying other domains.
                }
            
                CRegKey regSite;

                if (regSite.Open(regDomain, rgszSite, KEY_READ) != NOERROR )
                {
                    // Couldn't open the site but try other sites anyway.
                    continue;
                }

                int cchSite = lstrlen(rgszSite);

                LPTSTR szUrlSansProtocol = NULL;
                int cchUrlSansProtocol = 0;

                // Get everything about the name figured out 
                if ((FAILED(ComposeUrlSansProtocol(rgszDomain, cchDomain, rgszSite, cchSite, &szUrlSansProtocol, &cchUrlSansProtocol)))
                     || szUrlSansProtocol == NULL  )
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            
                TransAssert(cchUrlSansProtocol != 0);

                hr = AddUrlsToEnum(&regSite, dwZone, szUrlSansProtocol, cchUrlSansProtocol, FALSE, pEnumString);

                // Free up the memory we just allocated. 
                delete [] szUrlSansProtocol;

            } /* for each site */ 
                                                                     
            // At the domain level we need to look for any protocol defaults
            // An example string would look like http://*.microsoft.com
            LPTSTR szSiteWildCard = NULL;
            int cchSiteWildCard = 0;

            // If the string doesn't contain any .'s we didn't break it out as a domain/site 
            // in the first place. We shouldn't add a *. wildcard in this case. 
            BOOL bAddWildCard = (StrChr(rgszDomain, DOT) != NULL);

            if ((FAILED(ComposeUrlSansProtocol(rgszDomain, cchDomain, NULL, 0, &szSiteWildCard, &cchSiteWildCard)))
                  || szSiteWildCard == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            TransAssert(cchSiteWildCard != 0);

            hr = AddUrlsToEnum(&regDomain, dwZone, szSiteWildCard, cchSiteWildCard, bAddWildCard, pEnumString);

            delete [] szSiteWildCard;
        }
    }// opened domains root key

    // Finally add all the IP range entries to the structure.
    if (hr == NOERROR)    
    {
        hr = AddIPRulesToEnum(dwZone, pEnumString);
    }

    // Finally call the strings              
    if ( hr == NOERROR )
    {
        // Pass back the Enumeration to the caller. 
        if (ppEnumString)
            *ppEnumString = pEnumString;
    }
    else
    {
        // We need to free the object and return NULL to the caller. 
        if (ppEnumString)
            *ppEnumString = NULL;

        delete pEnumString;
    }
    
    return hr;        
                                                
}                       

//
// MapUrlToZone helper methods return S_OK if match found
//
// RETURN value is ONLY S_OK.
// Be careful about returning anything else since some calling functions assume this is the only return value.

HRESULT
CSecurityManager::MapUrlToZone (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, DWORD dwFlags,
                                BOOL *pfMarked, LPWSTR *ppszMarkURL)
{
    HRESULT hr;
    CRegKey regProtocols;
    BOOL    fMarked = FALSE;

    if (dwFlags & MUTZ_ENFORCERESTRICTED)
    {
        *pdwZone = URLZONE_UNTRUSTED;
        hr = S_OK;
        goto done;
    }

    // Guard against buffer overflow.

    DWORD dwLength = CSTRLENW(SZDOMAINS);
    if(m_fHardened)
    {
        dwLength = CSTRLENW(SZHARDENEDDOMAINS);
    }

    if (dwLength + pzc->cchDomain + 1 + pzc->cchSite + 1 >= MAX_PATH)
        goto default_zone;

    if (pzc->fDrive)
    {
        switch (pzc->dwDriveType)
        {
            case DRIVE_UNKNOWN:
            case DRIVE_NO_ROOT_DIR:
                break;
            case DRIVE_REMOTE:
                TransAssert(FALSE);
                *pdwZone = URLZONE_INTRANET;
                goto done;
            default:
            {
                BOOL bCacheFile = IsFileInCacheDir(pzc->pszSite);

                *pdwZone = bCacheFile ? URLZONE_INTERNET : URLZONE_LOCAL_MACHINE;
                if(bCacheFile)
                    goto done;

                bCacheFile = IsFileInCookieDir(pzc->pszSite);

                *pdwZone = bCacheFile ? URLZONE_UNTRUSTED : URLZONE_LOCAL_MACHINE;
                if(bCacheFile)
                    goto done;

                // do the Mark of the Web stuff, if we have a local non-cache file:
                LPWSTR pwszMarkURL = NULL;
                TCHAR  *pszExt = PathFindExtension(pzc->pszSite);
                LPCTSTR pszPath = pzc->pszSite;

                // Don't look for the mark if flags say not to.
                // We only want to pursue the Mark of the Web for htm(l) files.
                // If Marked, we want to be sure we're not chasing our tail recursively.
                if ( !(dwFlags & MUTZ_NOSAVEDFILECHECK) &&
                     (StrCmpI(pszExt,TEXT(".htm")) == 0 || StrCmpI(pszExt,TEXT(".html")) == 0) &&
                     FileBearsMarkOfTheWeb(pszPath, &pwszMarkURL) &&
                     StrCmp(pszPath, pwszMarkURL) != 0)
                {
                    MapUrlToZone( pwszMarkURL, pdwZone, dwFlags | MUTZ_NOSAVEDFILECHECK | MUTZ_NOCACHE );

                    fMarked = TRUE;
                    if (ppszMarkURL)
                    {
                        *ppszMarkURL = pwszMarkURL;
                        pwszMarkURL = NULL; // give mark string to caller, don't free
                    }
                }

                if (pwszMarkURL)
                    LocalFree(pwszMarkURL);

                goto done;
            }
        }
    }
    else if (IsOpaqueScheme(pzc->nScheme))
    {
        if(m_fHardened)
        {
            if (S_OK == CheckSiteAndDomainMappings (pzc, pdwZone, pzc->pszProtocol, TRUE))
                goto done;
        }
        else
        {
            if (S_OK == CheckSiteAndDomainMappings (pzc, pdwZone, pzc->pszProtocol))
                goto done;
        }

        if (S_OK == CheckMKURL(pzc, pdwZone, pzc->pszProtocol))
            goto done;
    }
    else 
    {
        if (pzc->fAddr)
        {
            // Check name in form of IP address against range rules.
            if (S_OK == CheckAddressAgainstRanges (pzc, pdwZone, pzc->pszProtocol))
                goto done;
        }                

        if ((HUSKEY) m_regZoneMap)
        {
            // Check for a mapping for the site (or domain, if applicable)

            if(m_fHardened)
            {
                if (S_OK == CheckSiteAndDomainMappings (pzc, pdwZone, pzc->pszProtocol, TRUE))
                    goto done;
            }
            else
            {
                if (S_OK == CheckSiteAndDomainMappings (pzc, pdwZone, pzc->pszProtocol))
                    goto done;
            }

            if (S_OK == CheckUNCAsIntranet(pzc, pdwZone, pzc->pszProtocol))
                goto done;

            // Check for Local Intranet name rules.
            if (S_OK == CheckIntranetName (pzc, pdwZone, pzc->pszProtocol))
                goto done;
                          
            // Check for proxy bypass rule.
            if (S_OK == CheckProxyBypassRule (pzc, pdwZone, pzc->pszProtocol))
                goto done;
        }
    }        

    // Check for protocol defaults.
    if (    ERROR_SUCCESS == regProtocols.Open (m_regZoneMap, SZPROTOCOLS, KEY_READ)
        &&  ERROR_SUCCESS == regProtocols.QueryValueOrWild (pdwZone, pzc->pszProtocol)
       )
    {       
        goto done;
    }

default_zone:
        *pdwZone = URLZONE_INTERNET;
done:   
        if (pfMarked)
            *pfMarked = fMarked;

        hr = S_OK; 
        return hr;
}

HRESULT
CSecurityManager::ReadAllIPRules( )
{
    DWORD* pdwIndexes = NULL;

    EnterCriticalSection(&s_csectIP);
    if (s_pRanges != NULL)
    {
        delete [] s_pRanges;
        s_pRanges = NULL;
        s_cNumRanges = 0;
    }

    // We always start with the key "Range1" if nothing is found.
    s_dwNextRangeIndex = 1;  

    CRegKey regRanges, regItem;

    if ((HUSKEY)m_regZoneMap == NULL)
    {
        if (ERROR_SUCCESS != m_regZoneMap.Open (NULL, SZZONEMAP, KEY_READ))
            goto done;
    }

    DWORD cchMaxKey;
    TCHAR szKeyName[MAX_PATH];

    if(m_fHardened)
    {        
        StrCpy (szKeyName, SZESCRANGES);
    }
    else
    {
        StrCpy (szKeyName, SZRANGES);
    }

    // Read in ranges from registry.
    if (   ERROR_SUCCESS != regRanges.Open (m_regZoneMap, szKeyName, KEY_READ)
        || ERROR_SUCCESS != regRanges.QuerySubKeyInfo (&s_cNumRanges, &cchMaxKey, NULL)
        || 0 == s_cNumRanges
       )
    {
        goto done;
    }

    // BUGBUG: TODO: Figure out why QuerySubKeyInfo is returning the wrong information. 
    cchMaxKey = 20; 
    // Calculate size of range item and allocate array (no alignment padding)
    s_cbRangeItem = sizeof(RANGE_ITEM) + sizeof(TCHAR) * (cchMaxKey + 1);
    s_pRanges = new BYTE [s_cbRangeItem * s_cNumRanges];
    pdwIndexes = new DWORD[s_cNumRanges];
        
    if (!s_pRanges || !pdwIndexes)
    {
        s_cNumRanges = 0;
        goto done;
    }

    // Loop through the ranges.
    TCHAR szRange[MAX_IPRANGE]; // 4x "###-###."
    RANGE_ITEM* pItem;
    DWORD iItem, cItem;

    pItem = (RANGE_ITEM *) s_pRanges;
    cItem = s_cNumRanges;
    s_cNumRanges = 0;
    
    for (iItem = 0; iItem < cItem; iItem++)
    {
        // Reset output buffer sizes.
        DWORD cbName, cbRange;
        cbName = cchMaxKey;
        cbRange = sizeof(szRange);
                
        // Get range from next key.
        if (  ERROR_SUCCESS != regRanges.EnumKey (iItem, pItem->szName, &cbName)
           || ERROR_SUCCESS != regItem.Open (regRanges, pItem->szName, KEY_READ)
           || ERROR_SUCCESS != regItem.QueryValue (szRange, SZRANGE, &cbRange)
           )
        {
            break;
        }

        // Figure out the index for the named Range entry. Ignore it is not of the 
        // form Range followed by Number. Range####
        DWORD chRange = lstrlen(SZRANGEPREFIX);

        if (0 == StrCmpNI(pItem->szName, SZRANGEPREFIX, chRange))
        {
            pdwIndexes[iItem] = StrToInt(pItem->szName + chRange);            
        }

        if (!ReadIPRule (szRange, pItem->bLow, pItem->bHigh))
            continue;
        
        // Advance to next range item in array.
        pItem = (RANGE_ITEM*) (((LPBYTE) pItem) + s_cbRangeItem);
        s_cNumRanges++;
    }

    // Find an empty slot or if we don't find one
    for (s_dwNextRangeIndex = 1 ; s_dwNextRangeIndex <= cItem; s_dwNextRangeIndex++)    
    {
        DWORD i;
        // Go through the entries and see if the index exists.
        for (i = 0; i < cItem ; i++ )
        {
            if (pdwIndexes[i] == s_dwNextRangeIndex)
                break;
        }

        if (i == cItem) // This range item is available.
            break;
    }

    TransAssert(s_dwNextRangeIndex >= 1 && s_dwNextRangeIndex <= (cItem + 1));
    delete [] pdwIndexes;
                     
done:
    LeaveCriticalSection(&s_csectIP);
    return S_OK;
}

HRESULT
CSecurityManager::AddDeleteIPRule
    (ZONEMAP_COMPONENTS* pzc, DWORD dwZone, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    DWORD dwError = ERROR_SUCCESS;
    BOOL bFoundItem = FALSE;
    TCHAR szItemName[MAX_PATH];

    TransAssert(s_dwNextRangeIndex != 0);
    TransAssert(pzc->fIPRange);

    if (s_dwNextRangeIndex == 0)
        return E_UNEXPECTED;

    EnterCriticalSection(&s_csectIP);

    RANGE_ITEM *pItem = (RANGE_ITEM *)s_pRanges;

    // First figure out if this item already exists in our list. 
    // This is useful in both the delete and add case.
    for (DWORD iRange = 0; 
               iRange < s_cNumRanges ; 
               iRange++, pItem = (RANGE_ITEM*) (((LPBYTE) pItem) + s_cbRangeItem))
    {
        if  ( ( 0 == memcmp(pItem->bLow, pzc->rangeItem.bLow, sizeof(pItem->bLow)))
              && (0 == memcmp(pItem->bHigh, pzc->rangeItem.bHigh, sizeof(pItem->bHigh)))
            )
        {
            break;
        }
    }

    // If we have a valid "named" entry in the registry.        
    if (iRange < s_cNumRanges && pItem->szName[0] != TEXT('\0'))
    {
        bFoundItem = TRUE;
        if(m_fHardened)
        {
            StrCpy(szItemName, SZESCRANGES);
        }
        else
        {
            StrCpy(szItemName, SZRANGES);
        }

        StrCat(szItemName, pItem->szName);
    }
    else 
    {
        bFoundItem = FALSE;
        pItem = NULL;
    }

    // Are we trying to do an add or a delete.
    if  (dwFlags & SZM_DELETE)
    {
        // If we have a valid "named" entry in the registry delete it now.        
        if (bFoundItem)
        { 
            TransAssert(pItem != NULL);
            
            CRegKey regItem;        
            if ((dwError = regItem.Open(m_regZoneMap, szItemName, KEY_READ | KEY_WRITE)) != ERROR_SUCCESS)
            {
                hr = HRESULT_FROM_WIN32(dwError);
            }
            else 
            {
                // Get the protocol name and delete the protocol related value.
                if ((dwError = regItem.DeleteValue (pzc->pszProtocol)) == ERROR_SUCCESS)
                {
                    DWORD dwNumValues = 0;

                    // Is this the last entry for this range? If so delete the range & nuke the key.
                    if (ERROR_SUCCESS == regItem.QuerySubKeyInfo(NULL, NULL, &dwNumValues) &&
                        dwNumValues == 1 &&
                        ERROR_SUCCESS == regItem.DeleteValue(SZRANGE)
                       )
                    {
                        regItem.Close();
                        m_regZoneMap.DeleteEmptyKey(szItemName);
                    }
                }
                else 
                {
                    hr = HRESULT_FROM_WIN32(dwError);
                }
            }
        }
        else 
        {
            hr =  HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }
    }
    else
    {
        if (bFoundItem)
        {
            TransAssert(pItem != NULL);            
            // See if an entry with the given name already
            CRegKey regItem;                        

            if ((dwError = regItem.Open(m_regZoneMap, szItemName, KEY_READ | KEY_WRITE)) != ERROR_SUCCESS)
            {
                hr = HRESULT_FROM_WIN32(dwError);
            }
            else 
            {
                DWORD dwZoneExists;
                // If we were able to read the value, fail because entry already exists.  
                if (regItem.QueryValue(&dwZoneExists, pzc->pszProtocol) == ERROR_SUCCESS)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
                }
            }
        }
        else 
        {
            // Create the new item name. 
            DWORD dwLen = 0;

            if(m_fHardened)
            {
                StrCpy(szItemName, SZESCRANGES);
                dwLen = lstrlen(SZESCRANGES);
            }
            else
            {
                StrCpy(szItemName, SZRANGES);
                dwLen = lstrlen(SZRANGES);
            }

            StrCat(szItemName, SZRANGEPREFIX);            
            if (!DwToWchar(s_dwNextRangeIndex, szItemName + dwLen + lstrlen(SZRANGEPREFIX), 10))
            {
                TransAssert(FALSE);
                hr = E_UNEXPECTED;
            }
        }
            
        // Okay to go ahead and create the entry.
        if (SUCCEEDED(hr))
        {
            TCHAR szIPRule[MAX_IPRANGE];
            // We shouldn't have any domain part for IP Rules.
            TransAssert(pzc->pszDomain == NULL);
            memcpy(szIPRule, pzc->pszSite, sizeof(TCHAR) * pzc->cchSite);
            szIPRule[pzc->cchSite] = TEXT('\0');

            CRegKey regMap;
                                    
            // Now add the entry to the registry.
            if ( ((dwError = regMap.Create(m_regZoneMap, szItemName, KEY_WRITE)) == ERROR_SUCCESS) &&
                 ((dwError = regMap.SetValue(dwZone, pzc->pszProtocol)) == ERROR_SUCCESS) &&
                 ((dwError = regMap.SetValue(szIPRule, SZRANGE)) == ERROR_SUCCESS)
               ) 
            {
                hr = S_OK;
            }
            else
            { 
                hr = HRESULT_FROM_WIN32(dwError);                                     
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = ReadAllIPRules();
    }

    LeaveCriticalSection(&s_csectIP);

    return hr;
}
            
HRESULT 
CSecurityManager::CheckAddressAgainstRanges
    (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt)
{
    TCHAR szKeyName[MAX_PATH];
    const DWORD cchRanges = m_fHardened? CSTRLENW(SZESCRANGES) : CSTRLENW(SZRANGES);

    if(m_fHardened)
    {
        memcpy (szKeyName, SZESCRANGES, sizeof(TCHAR) * cchRanges);
    }
    else
    {
        memcpy (szKeyName, SZRANGES, sizeof(TCHAR) * cchRanges);
    }

    CRegKey regItem;

    EnterCriticalSection(&s_csectIP);
    RANGE_ITEM* pItem = (RANGE_ITEM *) s_pRanges;

    for (DWORD iRange=0; iRange < s_cNumRanges; iRange++)
    {
        for (DWORD iByte=0; iByte<4; iByte++)
        {
            if (   pzc->bAddr[iByte] < pItem->bLow[iByte]
                || pzc->bAddr[iByte] > pItem->bHigh[iByte]
               )
            {
                goto next_range; // much cleaner than a break and test
            }
        }

        StrCpyW (szKeyName + cchRanges, pItem->szName);
        
        if (    ERROR_SUCCESS == regItem.Open (m_regZoneMap, szKeyName, KEY_READ)
            &&  ERROR_SUCCESS == regItem.QueryValueOrWild (pdwZone, pszProt)
           )
        {
            LeaveCriticalSection(&s_csectIP);
            return S_OK;
        }

next_range:
        pItem = (RANGE_ITEM*) (((LPBYTE) pItem) + s_cbRangeItem);
    }

    LeaveCriticalSection(&s_csectIP);
    return S_FALSE;
}


HRESULT CSecurityManager::CheckSiteAndDomainMappings
    (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt, BOOL fCheckHardenKey)
{
    CRegKey regDomain, regSite;
    DWORD dwRegErr;

    TCHAR szKeyName[MAX_PATH];
    DWORD cchKeyName;
    
    if(fCheckHardenKey)
    {
        cchKeyName = CSTRLENW(SZHARDENEDDOMAINS);
        memcpy (szKeyName, SZHARDENEDDOMAINS, sizeof(TCHAR) * cchKeyName);
    }
    else
    {
        cchKeyName = CSTRLENW(SZDOMAINS);
        memcpy (szKeyName, SZDOMAINS, sizeof(TCHAR) * cchKeyName);
    }


    TransAssert(!pzc->fDrive);

    if (pzc->pszDomain)
    {
        // First, look for domain rule.
        memcpy (szKeyName + cchKeyName, pzc->pszDomain, sizeof(TCHAR) * pzc->cchDomain);
        szKeyName[cchKeyName + pzc->cchDomain] = 0;
        SAFEREGOPERATION(dwRegErr, regDomain.Open (m_regZoneMap, szKeyName, KEY_READ));

        if ((dwRegErr != ERROR_SUCCESS)
            && (szKeyName[cchKeyName + pzc->cchDomain -1] == DOT)//check if this is a terminal-dotted-site
            && ((pzc->nScheme == URL_SCHEME_HTTP)
                || (pzc->nScheme == URL_SCHEME_HTTPS)
                || (pzc->nScheme == URL_SCHEME_FILE)))
        {
                szKeyName[cchKeyName + pzc->cchDomain -1] = 0;
                dwRegErr = regDomain.Open(m_regZoneMap, szKeyName, KEY_READ);
        }

        if(dwRegErr != ERROR_SUCCESS)
            return S_FALSE;
            
        // Now add the site.
        memcpy (szKeyName, pzc->pszSite, sizeof(TCHAR) * pzc->cchSite);
        szKeyName[pzc->cchSite] = 0;
        dwRegErr = regSite.Open (regDomain, szKeyName, KEY_READ);

        // For IE5.0 we support wildcard's beyond the second level domain.
        // For example if you had an intranet address www.internal.mycorp.com
        // you can specify a zone mapping for *.internal.mycorp.com.
        // In IE4 we would have flagged this as an error because we allowed
        // wildcards only at the second level domain.
        //  IE5 since we lifted this restriction, we have to search the sub-keys 
        // and look for strings such as "*.internal" under the mycorp.com key. 
        // If we find one we see if the wildcard pattern matches the site whose
        // zone we are trying to determine.
        
        if (dwRegErr != ERROR_SUCCESS)
        {
            TCHAR rgchSubKeyName[MAX_PATH];
            LONG lRet = NOERROR;
            
            for ( DWORD dwIndex = 0 , cchSubKey = ARRAYSIZE(rgchSubKeyName) ;
                   ((lRet = regDomain.EnumKey(dwIndex, rgchSubKeyName, &cchSubKey)) != ERROR_NO_MORE_ITEMS) ;
                   dwIndex++ , cchSubKey = ARRAYSIZE(rgchSubKeyName)
                )
            {
                if (lRet != NOERROR)                   
                {
                    TransAssert(lRet != ERROR_MORE_DATA);
                    break;
                }

                // For patterns that finish with a *. we will do a suffix 
                // match to see if the wildcard sequence is valid.                
                if (cchSubKey > 2 && rgchSubKeyName[0] == WILDCARD && rgchSubKeyName[1] == DOT)
                {
                    // First condition
                    //    for xyz.foo.microsoft.com to match *.foo.microsoft.com
                    //        www.foo has to be greater than or equal to foo.microsoft.com
                    //        note that we allow just foo.microsoft.com as well.
                    // Second condition
                    //     cchSubkey is the length of *.foo, therefore the last 
                    //     cchSubKey - 2 characters of the two strings should match.
                    if (pzc->cchSite >= (cchSubKey - 2) &&
                        ( StrCmpNI (rgchSubKeyName + 2, /* skip *. */
                                    pzc->pszSite + pzc->cchSite - cchSubKey + 2,
                                    cchSubKey - 2 
                                   )  == 0
                         )
                       )
                    {
                        dwRegErr = regSite.Open(regDomain, rgchSubKeyName, KEY_READ);
                        break;
                    }
                }
            }
        }                                    
    }
    else
    {
        // There was no domain.  Look for a site rule.
        memcpy (szKeyName + cchKeyName, pzc->pszSite, sizeof(TCHAR) * pzc->cchSite);
        szKeyName[cchKeyName + pzc->cchSite] = 0;
        SAFEREGOPERATION(dwRegErr, regSite.Open (m_regZoneMap, szKeyName, KEY_READ));

        if ((dwRegErr != ERROR_SUCCESS)
            && (szKeyName[cchKeyName + pzc->cchSite -1] == DOT) //check if this is a terminal-dotted-site
            && ((pzc->nScheme == URL_SCHEME_HTTP)
                || (pzc->nScheme == URL_SCHEME_HTTPS)
                || (pzc->nScheme == URL_SCHEME_FILE)))
        {
                szKeyName[cchKeyName + pzc->cchSite -1] = 0;
                dwRegErr = regSite.Open(m_regZoneMap, szKeyName, KEY_READ);
        }
    }

    // Look for matching protocols under site key.
    if (    ERROR_SUCCESS == dwRegErr
        &&  ERROR_SUCCESS == regSite.QueryValueOrWild (pdwZone, pszProt)
       )
    {           
        return S_OK;
    }

    // Now fall back to domain if there was one.
    else if (   pzc->pszDomain
            &&  ERROR_SUCCESS == regDomain.QueryValueOrWild (pdwZone, pszProt)
       )
    {            
        return S_OK;
    }

    else return S_FALSE;

}


HRESULT CSecurityManager::CheckUNCAsIntranet
    (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt)
{
    HRESULT hr = S_FALSE;
    DWORD dwUNCAsIntranet;
    DWORD dwRegErr;

    TransAssert(!pzc->fDrive);
    TransAssert(!pzc->fIPRange);

    if (pzc->fAddr || pzc->nScheme != URL_SCHEME_FILE)
        return hr;

    SAFEREGOPERATION(dwRegErr, m_regZoneMap.QueryValue(&dwUNCAsIntranet, SZUNCASINTRANET));
    
    if(ERROR_SUCCESS != dwRegErr)
        return hr;

    if (dwUNCAsIntranet == 0)
    {
        hr = S_OK;
        if (pdwZone)
            *pdwZone = URLZONE_INTERNET;
    }

    return hr;
}

HRESULT CSecurityManager::CheckIntranetName
    (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt)
{
    HRESULT hr = S_FALSE;
    DWORD dwZone = ZONEID_INVALID;
    DWORD dwRegErr;

    TransAssert(!pzc->fDrive);
    TransAssert(!pzc->fIPRange);

    if (pzc->fAddr)
        return hr;

    // Check if there is a local intranet rule.
    SAFEREGOPERATION(dwRegErr, m_regZoneMap.QueryValue(&dwZone, SZINTRANETNAME));
    
    if(ERROR_SUCCESS != dwRegErr)
        return hr;

    if (dwZone != URLZONE_INTRANET)
    {
        TransAssert(FALSE);
        if(pdwZone)
        {
            *pdwZone = URLZONE_INTERNET;
        }
        hr = E_FAIL;
        return hr;
    }

        
    if (pzc->pszSite && !pzc->pszDomain)
    {
        BOOL bFoundDot = FALSE;

        for (DWORD dwIndex = 0 ; dwIndex < pzc->cchSite ; dwIndex++ )
        {
            if (pzc->pszSite[dwIndex] == DOT)
            {
                bFoundDot = TRUE;
                break;
            }
        }

        hr = bFoundDot ? S_FALSE : S_OK;
    }

    if (hr == S_OK && pdwZone)
        *pdwZone = dwZone;

    return hr;
}            


HRESULT CSecurityManager::CheckProxyBypassRule
    (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt)
{    
    TransAssert(!pzc->fDrive);
    DWORD dwRegErr;
    DWORD dwValue = 0;

    // Check if there is a proxy bypass rule.
    SAFEREGOPERATION(dwRegErr, m_regZoneMap.QueryValue(&dwValue, SZPROXYBYPASS));
 
    if(ERROR_SUCCESS != dwRegErr || !dwValue)
        return S_FALSE;

    *pdwZone = URLZONE_INTRANET;
        
    // Calculate length of hostname = site (+ . + domain)
    DWORD cchTotal;
    cchTotal = pzc->cchSite;
    if (pzc->cchDomain)
        cchTotal += 1 + pzc->cchDomain;

    // Convert from unicode to ansi.
    char szHost[MAX_PATH];
    DWORD cbHost;
    cbHost = WideCharToMultiByte
        (CP_ACP, 0, pzc->pszSite, cchTotal, szHost, sizeof(szHost), NULL, NULL);
    if (!cbHost)
        return S_FALSE;
        
    // WideCharToMultiByte won't null terminate szHost,
    // IsHostInProxyBypassList shouldn't need it,
    // but just do it anyway to play it safe.
    szHost[cbHost] = 0;
    INTERNET_SCHEME tScheme;
    BOOL bCheckByPassRules = TRUE;
    switch(pzc->nScheme)
    {
        case URL_SCHEME_HTTP:
            tScheme = INTERNET_SCHEME_HTTP;
            break;
        case URL_SCHEME_HTTPS:
            tScheme = INTERNET_SCHEME_HTTPS;
            break;
        case URL_SCHEME_GOPHER:
            tScheme = INTERNET_SCHEME_GOPHER;
            break;
        case URL_SCHEME_FTP:
            tScheme = INTERNET_SCHEME_FTP;
            break;
        default:
            bCheckByPassRules = FALSE;
            break;
    }

    return bCheckByPassRules && IsHostInProxyBypassList (tScheme, szHost, cbHost) ? S_OK : S_FALSE;
}

HRESULT CSecurityManager::CheckMKURL
    (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt)
{
    HRESULT hr = S_FALSE;
    DWORD dwZone = ZONEID_INVALID;    
    TransAssert(!pzc->fDrive);

    // First check if it looks like a valid mk: string. 
    if (pzc->nScheme == URL_SCHEME_MK && 
        pzc->pszDomain == NULL && 
        pzc->pszSite != NULL && 
        pzc->pszSite[0] == AT)
    {
        // look for a : in the domain string.
        LPTSTR pszColon = StrChr(pzc->pszSite, COLON);
        if ( pszColon != NULL)
        {
            CRegKey regProtocols;
            *pszColon = TEXT('\0'); // Temporarily overwrite the colon.
            if ((ERROR_SUCCESS == regProtocols.Open(m_regZoneMap, SZPROTOCOLS, KEY_READ)) &&
                (ERROR_SUCCESS == regProtocols.QueryValue(&dwZone, pzc->pszSite))
               )
            {
                *pdwZone = dwZone;
                hr = S_OK;
            }
            *pszColon = COLON;     // Set the domain string back to its original state.
        }
    }
    
    return hr;
}          


CSecurityManager::CSecMgrCache::CSecMgrCache(void)
{
    InitializeCriticalSection(&m_csectZoneCache);
    
    // single static object, so this only gets inited once per
    // process.
    s_hMutexCounter = CreateMutexA(NULL, FALSE, "ZonesCounterMutex");

    m_iAdd = 0;
}


CSecurityManager::CSecMgrCache::~CSecMgrCache(void)
{
    Flush();
    DeleteCriticalSection(&m_csectZoneCache) ; 

    CloseHandle(s_hMutexCounter);
}

BOOL
CSecurityManager::CSecMgrCache::Lookup(LPCWSTR pwszURL,
                                       DWORD *pdwZone,
                                       BOOL *pfMarked,
                                       BYTE* pbSecurityID,
                                       DWORD *pcbSecurityID,
                                       LPCWSTR pwszDocDomain)
{
    BOOL fFound = FALSE;

    EnterCriticalSection(&m_csectZoneCache);

    if ( !IsCounterEqual() )
    {
        Flush();
    }
    else
    {
        int i;

        fFound = FindCacheEntry( pwszURL, i );
        if (fFound)
        {
            if ( pbSecurityID )
            {
                TransAssert(pcbSecurityID);
                if ( m_asmce[i].m_pbSecurityID && 
                     (  (m_asmce[i].m_pwszDocDomain == NULL && pwszDocDomain == NULL) || /* both are NULL */
                        (   m_asmce[i].m_pwszDocDomain && pwszDocDomain &&
                            (0 == StrCmpW(m_asmce[i].m_pwszDocDomain, pwszDocDomain))  /* the strings match */
                        )
                     ) &&
                     m_asmce[i].m_cbSecurityID <= *pcbSecurityID)
                {

                    memcpy( pbSecurityID, m_asmce[i].m_pbSecurityID, m_asmce[i].m_cbSecurityID  );
                    *pcbSecurityID = m_asmce[i].m_cbSecurityID;
                }
                else 
                    *pcbSecurityID = 0;
            }

            if (pdwZone)
            {
                *pdwZone = m_asmce[i].m_dwZone;

                if (pfMarked)
                    *pfMarked = m_asmce[i].m_fMarked;
            }
        }
    }

    LeaveCriticalSection(&m_csectZoneCache);

    return fFound;
}

void 
CSecurityManager::CSecMgrCache::Add(LPCWSTR pwszURL,
                                    DWORD dwZone,
                                    BOOL fMarked,
                                    const BYTE *pbSecurityID,
                                    const DWORD cbSecurityID, 
                                    LPCWSTR pwszDocDomain)
{
    int     i;
    BOOL    fFound;

    EnterCriticalSection(&m_csectZoneCache);

    if ( !IsCounterEqual() )
        Flush();

    fFound = FindCacheEntry( pwszURL, i ); // found or not, i will be the right place to set it.
    m_asmce[i].Set(pwszURL, dwZone, fMarked, pbSecurityID, cbSecurityID, pwszDocDomain);
    if (!fFound)
        m_iAdd = (m_iAdd + 1) % MAX_SEC_MGR_CACHE;

    SetToCurrentCounter(); // validate this cache.

    LeaveCriticalSection(&m_csectZoneCache);
}

void 
CSecurityManager::CSecMgrCache::Flush(void)
{
    int i;

    EnterCriticalSection(&m_csectZoneCache);

    for ( i = 0; i < MAX_SEC_MGR_CACHE; i++ )
        m_asmce[i].Flush();

    m_iAdd = 0;

    LeaveCriticalSection(&m_csectZoneCache);
}

// Is the counter we saved with the cache entry, equal to the current counter.
BOOL
CSecurityManager::CSecMgrCache::IsCounterEqual( ) const 
{
    CExclusiveLock lock(s_hMutexCounter);
    LPDWORD lpdwCounter = (LPDWORD) g_SharedMem.GetPtr(SM_SECMGRCHANGE_COUNTER);
    // If we couldn't create the shared memory for some reason, we just assume our cache is up to date.
    if (lpdwCounter == NULL)
        return TRUE;

    return (m_dwPrevCounter == *lpdwCounter);
}

VOID
CSecurityManager::CSecMgrCache::SetToCurrentCounter( ) 
{
    CExclusiveLock lock(s_hMutexCounter);
    LPDWORD lpdwCounter = (LPDWORD) g_SharedMem.GetPtr(SM_SECMGRCHANGE_COUNTER);
    if (lpdwCounter == NULL)
        return;

    m_dwPrevCounter = *lpdwCounter;
}

VOID
CSecurityManager::CSecMgrCache::IncrementGlobalCounter( )
{
    CExclusiveLock lock(s_hMutexCounter);
    LPDWORD lpdwCounter = (LPDWORD) g_SharedMem.GetPtr(SM_SECMGRCHANGE_COUNTER);
    if (lpdwCounter == NULL)
        return;

    (*lpdwCounter)++;
}

BOOL
CSecurityManager::CSecMgrCache::FindCacheEntry( LPCWSTR pwszURL, int& riEntry )
{
    BOOL fFound = FALSE;
    riEntry = m_iAdd - 1 % MAX_SEC_MGR_CACHE;

    // our cache is a circular buffer. We scan it from the last entry
    // we added backwards to the next slot to add to, createing a quasi-
    // MRU.
    if ( riEntry < 0 )
        riEntry = MAX_SEC_MGR_CACHE + riEntry;

    // check below us, starting with the most recent addition, if any.
    for ( ; riEntry >= 0; riEntry-- )
    {
        if ( m_asmce[riEntry].m_pwszURL &&
             StrCmpW( m_asmce[riEntry].m_pwszURL, pwszURL ) == 0 )
        {
            fFound = TRUE;
            break;
        }
    }

    if (!fFound)
    {
        for ( riEntry = MAX_SEC_MGR_CACHE - 1; riEntry >= m_iAdd; riEntry-- )
        {
            if (m_asmce[riEntry].m_pwszURL == NULL)
                break; // hasn't been used yet.
            else if ( m_asmce[riEntry].m_pwszURL &&
                      StrCmpW( m_asmce[riEntry].m_pwszURL, pwszURL ) == 0 )
            {
                fFound = TRUE;
                break;
            }
        }
    }

    if (!fFound)
        riEntry = m_iAdd;

    return fFound;
}
  
void 
CSecurityManager::CSecMgrCache::CSecMgrCacheEntry::Set(LPCWSTR pwszURL,
                                                       DWORD dwZone,
                                                       BOOL fMarked,
                                                       const BYTE *pbSecurityID,
                                                       DWORD cbSecurityID,
                                                       LPCWSTR pwszDocDomain)
{
    if ( pwszURL )
    {
        // Only replace if the string has changed.
        // We may see the same string if the entry is
        // set by MapUrlToZone before GetSecurityID is called.
        if (m_pwszURL && StrCmpW(pwszURL, m_pwszURL))
        {
            delete [] m_pwszURL;
            m_pwszURL = NULL;
        }

        if (!m_pwszURL)
        {
            int cchURL = lstrlenW( pwszURL );

            m_pwszURL = new WCHAR[cchURL+1];
            if ( m_pwszURL )
                StrCpyW( m_pwszURL, pwszURL );
            else
                return;
        }
    }

    // We always set the url zone mark first, then come back later and
    // add the security ID, than means that on any set operation, we're
    // either changing the url or adding the security ID. Either way, if
    // we have a security ID, its invalid now, so flush it.
    if (m_pbSecurityID)
    {
        delete [] m_pbSecurityID;
        m_pbSecurityID = NULL;
        m_cbSecurityID = 0;
    }

    if (m_pwszDocDomain)
    {
        delete [] m_pwszDocDomain;
        m_pwszDocDomain = NULL;
    }

    if ( pbSecurityID )
    {
        m_pbSecurityID = new BYTE[cbSecurityID];
        if ( m_pbSecurityID )
        {
            memcpy( m_pbSecurityID, pbSecurityID, cbSecurityID  );
            if (pwszDocDomain)
            {
                m_pwszDocDomain = new WCHAR[lstrlenW(pwszDocDomain) + 1];
                if (m_pwszDocDomain != NULL)
                {
                    StrCpyW(m_pwszDocDomain, pwszDocDomain);
                }
                else
                {
                    // If we don't have memory for the Document's domain property
                    // we better not remember the security ID either.
                    delete [] m_pbSecurityID;
                    m_pbSecurityID = NULL;
                    cbSecurityID = 0;
                }
            }
        }
        else
        {
            cbSecurityID = 0;
        }

        m_cbSecurityID = cbSecurityID;
    }

    if (dwZone != URLZONE_INVALID)
    {
        m_dwZone = dwZone;
        m_fMarked = fMarked;
    }
}

void 
CSecurityManager::CSecMgrCache::CSecMgrCacheEntry::Flush(void)
{
    if (m_pwszURL)
        delete[] m_pwszURL;
    m_pwszURL = NULL;

    if (m_pbSecurityID)
        delete[] m_pbSecurityID;
    m_pbSecurityID = NULL;
    
    m_cbSecurityID = 0;

    if (m_pwszDocDomain)
    {
        delete [] m_pwszDocDomain;
        m_pwszDocDomain = NULL;
    }

    m_dwZone = URLZONE_INVALID;
    m_fMarked = FALSE;
}
          
BOOL
CSecurityManager::EnsureListReady(BOOL bForce)
// Make sure the list of allowed controls is ready
// Returns whether or not the list had to be made
// bForce is whether to force a reinitialization
{
    if(CSecurityManager::s_clsidAllowedList == NULL || bForce == TRUE)
    {
        CSecurityManager::IntializeAllowedControls();
        return TRUE;
    }
    else
        return FALSE;
}

void 
CSecurityManager::IntializeAllowedControls()
{
    DWORD i = 0;
    DWORD dwNumKeys=0;
    DWORD dwMaxLen=0;
    DWORD dwNumValues=0;
    // this buffer size should be long enough to hold a string-form
    // CLSID, plus the two end braces, plus a null terminator
    TCHAR szValueName[40];
    DWORD dwNameLength = 40;
    DWORD dwType = 0;
    DWORD dwData = 0;
    DWORD dwDataLength = sizeof(DWORD);

    // In case we somehow get multiply initialized
    if(CSecurityManager::s_clsidAllowedList != NULL)
    {
        delete [] CSecurityManager::s_clsidAllowedList;
        CSecurityManager::s_clsidAllowedList = NULL;
    }
    CSecurityManager::s_dwNumAllowedControls = 0;


    //open key
    // look at HKLM only, first
    CRegKey * prkey_AllowedControls;
    CRegKey rkey_AllowedControls(TRUE);
    CRegKey rkey_AllowedControlsCU(FALSE);

    LONG lRes = rkey_AllowedControls.Open(NULL, ALLOWED_CONTROLS_KEY, KEY_READ);
    if(lRes != ERROR_SUCCESS)
    {
        // List not found in HKLM, check HKCU
        
        lRes = rkey_AllowedControlsCU.Open(NULL, ALLOWED_CONTROLS_KEY, KEY_READ);

        if(lRes != ERROR_SUCCESS)
        {
            // AllowedControls Key not able to be opened
            return;
        }
        else
        {
            prkey_AllowedControls = &rkey_AllowedControlsCU;
        }
    }
    else
    {
        prkey_AllowedControls = &rkey_AllowedControls;
    }


    lRes = prkey_AllowedControls->QuerySubKeyInfo(&dwNumKeys, &dwMaxLen, &dwNumValues);
    if(lRes != ERROR_SUCCESS)
        return;

    // prepare space in data structure
    // array will not need to be resized, since the maximum number of allowed
    // CLSIDs is the number of values in the key
    CSecurityManager::s_clsidAllowedList = new CLSID[dwNumValues];
    if(CSecurityManager::s_clsidAllowedList == NULL) // new failed
        return;

        // loop through all values in the key
    for(i = 0; i < dwNumValues; i++)
    {
        // at every loop, these values get changed and must be reset to the 
        // length of the name and data buffers, respectively
        dwNameLength = ARRAYSIZE(szValueName);
        dwDataLength = sizeof(DWORD);

        // Get the (DWORD) value for the current value name     
        LONG lResult = prkey_AllowedControls->EnumValue(i, szValueName, &dwNameLength, 
                                                 &dwType, &dwData, &dwDataLength);

        if(lResult == ERROR_SUCCESS && dwType == REG_DWORD
            && GetUrlPolicyPermissions(dwData) == URLPOLICY_ALLOW)
        {
                // found a value for the CLSID given, and it is set to allow the CLSID
            // add the CLSID to the list
            CLSID * p_id = CSecurityManager::s_clsidAllowedList +   //pointer + 
                           CSecurityManager::s_dwNumAllowedControls;//offset
            HRESULT hr = CLSIDFromString(szValueName, p_id);
            if(hr != NOERROR)
                continue;

            CSecurityManager::s_dwNumAllowedControls++;
        }
    }
}

HRESULT 
CSecurityManager::GetControlPermissions(BYTE * raw_CLSID, DWORD & dwPerm)
{
    CLSID * id = (CLSID *)(raw_CLSID);
    dwPerm = 0;

    // If the list is not initialized (something's wrong) leave function
    if(CSecurityManager::s_clsidAllowedList == NULL)
    {
        return E_UNEXPECTED;
    }


    DWORD index = 0;
    // Search for the given CLSID in the list of allowed Controls
    for(index = 0; index < CSecurityManager::s_dwNumAllowedControls; index++)
    {
        if(*id == (CSecurityManager::s_clsidAllowedList[index]))
        {
            dwPerm = URLPOLICY_ALLOW; // not necesarry, since currently only allowed controls
                                      // are in the list, but this may change later
            return S_OK;
        }
    }
    
    // Not found, return false to indicate not in list
    return S_FALSE;
}

HRESULT
CSecurityManager::GetActiveXRunPermissions(BYTE * raw_CLSID, DWORD & dwPerm)
{
    HRESULT hr = S_FALSE;
    DWORD dwValue;

    EnterCriticalSection(&s_csectAList);
    // Initialize the Allowed Controls list if it is not already
    CSecurityManager::EnsureListReady(FALSE);    
    // get the list permission for pContext, if it is in the list
    HRESULT permHR = CSecurityManager::GetControlPermissions(raw_CLSID,dwValue);
    LeaveCriticalSection(&s_csectAList);

    // interpret results, (zone dependent interpretation not yet implemented)
    if(SUCCEEDED(permHR))
    {
        if(permHR == S_OK) // found in list
        {
            if(dwValue == URLPOLICY_ALLOW)
            {
                hr = S_OK;
                dwPerm = URLPOLICY_ALLOW;
            }
            else
            {
                hr = S_FALSE;
                dwPerm = URLPOLICY_DISALLOW;
            }
        }
        else  // not in list; default is to disallow
        {
            hr = S_FALSE;
            dwPerm = URLPOLICY_DISALLOW;
        }
    }
    else // Unknown error.  Disallow by default
    {
        hr = S_FALSE;
        dwPerm = URLPOLICY_DISALLOW;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\zones\secmgr.h ===
//  File:       secmgr.h
//
//  Contents:   The object that implements the base IInternetSecurityManager interface
//
//  Classes:    CSecurityManager
//
//  Functions:
//
//  History: 
//
//----------------------------------------------------------------------------

#ifndef _SECMGR_H_
#define _SECMGR_H_

#pragma warning(disable:4200)

#define MAX_SEC_MGR_CACHE   4
#define URLZONE_INVALID     URLZONE_USER_MAX+1

#define MUTZ_NOCACHE    0x80000000  // start private flags from high end

#define TSZMICROSOFTPATH                  TEXT("Software\\Microsoft")
#define TSZIEPATH                               TSZMICROSOFTPATH TEXT("\\Internet Explorer")
#define REGSTR_PATH_IE_MAIN                 TSZIEPATH TEXT("\\Main")
#define REGVAL_TRUSTDLG_ENABLED             TEXT("DisplayTrustAlertDlg")

// private function only exported by ordinal:
#define SHOWURLINNEWBROWSERINSTANCE_ORDINAL    230       
typedef HRESULT (STDAPICALLTYPE * SHOWURLINNEWBROWSERINSTANCE)(LPCWSTR);
    
struct ZONEMAP_COMPONENTS;

struct RANGE_ITEM
{
    BYTE  bLow[4];    // high byte values for range
    BYTE  bHigh[4];   // low byte values for range
    TCHAR szName[1];  // actually variable length
};

// This structure is used to exchange data between the security manager 
// and the dialog proc's.
struct DlgData 
{
    DWORD dwAction;
    DWORD dwZone;
    LPCWSTR pstr;
    DWORD dwFlags;

    // TrustAlertDialogProc use:
    IInternetSecurityManager *pSecurityManager;
    BOOL bFromShdocvw;
};

typedef DlgData * LPDLGDATA;

class CSecurityManager : public IInternetSecurityManager
{
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID iid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP MapUrlToZone( 
        /* [in] */ LPCWSTR pwszUrl,
        /* [out] */ DWORD *pdwZone,
        /* [in] */ DWORD dwReserved);

    STDMETHODIMP GetSecurityId( 
        /* [in] */ LPCWSTR pwszUrl,
        /* [size_is][out] */ BYTE* pbSecurityId,
        /* [out][in] */ DWORD *pcbSecurityId,
        /* [in] */ DWORD_PTR dwReserved);
        
    STDMETHODIMP ProcessUrlAction( 
        /* [in] */ LPCWSTR pwszUrl,
        /* [in] */ DWORD dwAction,
        /* [size_is][out] */ BYTE *pPolicy,
        /* [in] */ DWORD cbPolicy,
        /* [in] */ BYTE *pContext,
        /* [in] */ DWORD cbContext,
        /* [in] */ DWORD dwFlags,
        /* [in] */ DWORD dwReserved);
        
    STDMETHODIMP QueryCustomPolicy(
        /* [in] */ LPCWSTR     pwszUrl,
        /* [in] */ REFGUID     guidKey,
        /* [size_is][size_is][out] */ BYTE **ppPolicy,
        /* [out] */ DWORD *pcbPolicy,
        /* [in] */ BYTE *pContext,
        /* [in] */ DWORD cbContext,
        /* [in] */ DWORD dwReserved
    );

    STDMETHODIMP SetSecuritySite(
        /* [in] */  IInternetSecurityMgrSite *pSite
    );

    STDMETHODIMP GetSecuritySite(
        /* [out] */  IInternetSecurityMgrSite **ppSite
    );

    STDMETHODIMP SetZoneMapping( 
        /* [in] */ DWORD dwZone,
        /* [in] */ LPCWSTR lpszPattern,
        /* [in] */ DWORD dwFlags);
    
    STDMETHODIMP GetZoneMappings( 
        /* [in] */ DWORD dwZone,
        /* [out] */ IEnumString **ppEnumString,
        /* [in] */ DWORD dwFlags);

// Constructors/destructors
public:
    CSecurityManager(IUnknown *pUnkOuter, IUnknown **ppUnkInner);
    virtual ~CSecurityManager();

    static BOOL GlobalInit( ) ;
            
    static BOOL GlobalCleanup( );


// Aggregation and RefCount support.
protected:
    CRefCount m_ref;
        
    class CPrivUnknown : public IUnknown
    {
    public:
        STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);

        ~CPrivUnknown() {}
        CPrivUnknown() : m_ref () {}

    private:
        CRefCount   m_ref;          // the total refcount of this object
    };

    friend class CPrivUnknown;
    CPrivUnknown m_Unknown;

    IUnknown*   m_pUnkOuter;

    STDMETHODIMP_(ULONG) PrivAddRef()
    {
        return m_Unknown.AddRef();
    }
    STDMETHODIMP_(ULONG) PrivRelease()
    {
        return m_Unknown.Release();
    }

protected:

    BOOL EnsureZoneManager();
    VOID PickZCString(ZONEMAP_COMPONENTS *pzc, LPCWSTR *ppwsz, DWORD *pcch, LPCWSTR pwszDocDomain);

    // Helper methods to deal with IP Rules
    HRESULT ReadAllIPRules( );
    HRESULT AddDeleteIPRule(ZONEMAP_COMPONENTS *pzc, DWORD dwZone, DWORD dwFlags);

    // helper methods to do GetZoneMappings.
    HRESULT AddUrlsToEnum(CRegKey *pRegKey, DWORD dwZone, LPCTSTR lpsz, int cch, BOOL bAddWildCard, CEnumString *);
    HRESULT AddIPRulesToEnum(DWORD dwZone, CEnumString *);

    static HRESULT ComposeUrlSansProtocol(LPCTSTR pszDomain, int cchDomain, LPCTSTR pszSite, int cchSite,
                                        LPTSTR * ppszRet, int * cchRet);
    static HRESULT ComposeUrl(LPCTSTR pszUrlSansProt, int cchUrlSansProt, LPCTSTR pszProt, int cchProt, BOOL bAddWildCard,
                                LPTSTR * ppszRet, int * cchRet);

protected:  // UI related definitions.

    enum    { MAX_ALERT_SIZE = 256 };
    // Return values from DialogProc's
    enum  {  ZALERT_NO = 0 /* should be 0*/ , ZALERT_YES, ZALERT_YESPERSIST };

    // helper methods to display generic UI.
    static DWORD GetAlertIdForAction(DWORD dwAction);
    static DWORD GetWarnIdForAction(DWORD dwAction);

    // Dialog proc's etc.
    static BOOL    IsScriptOrActiveXHardenedInternet(DWORD dwAction, DWORD dwPermissions, DWORD dwZone);
    static BOOL    IsSiteInZone(LPCWSTR pszUrl, DWORD dwZone, IInternetSecurityManager *pSecMgr);
    static BOOL    ShowAddToSitesList(HWND hwnd, LPCWSTR pszUrl, DWORD dwZone);
    static HWND    SetControlText(HWND hDlg, UINT ctrlID, DWORD dwStrId, LPCWSTR pszDomain = NULL);
    static BOOL    IsHostedInIE(IUnknown* punk);
    static BOOL     IsBrowserHosted();
    static void     ShowUrlInNewBrowserInstance(LPCWSTR pwszUrl);

public:
    static INT_PTR TrustAlertDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);

protected:
    static INT_PTR ZonesAlertDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam); 
    static INT_PTR ZonesWarnDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam); 

    static inline BOOL IsFormsSubmitAction(DWORD dwAction);

    static INT_PTR FormsAlertDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
                
    INT CSecurityManager::ShowFormsAlertDialog(HWND hwndParent, LPDLGDATA lpDlgData);

protected: 
    // Methods to help Map a URL to a zone. 

    HRESULT MapUrlToZone
        (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, DWORD dwFlags, BOOL *pfMarked = NULL, LPWSTR *ppszURLMark = NULL);

    HRESULT WrapMapUrlToZone(LPCWSTR pwszSecUrl, ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, DWORD dwFlags,
                                BOOL *pfMarked, LPWSTR *ppszMarkURL);

    HRESULT CheckAddressAgainstRanges
        (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt);

    HRESULT CheckSiteAndDomainMappings
        (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt, BOOL fCheckHardenKey = FALSE);

    HRESULT CheckUNCAsIntranet
        (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt);

    HRESULT CheckIntranetName
        (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt);

    HRESULT CheckProxyBypassRule
        (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt);

    HRESULT CheckMKURL
        (ZONEMAP_COMPONENTS* pzc, DWORD* pdwZone, LPCTSTR pszProt);

protected:
    // Class to remember persistent actions.
    class CPersistAnswers 
    {
    public:
            CPersistAnswers( ) : m_pAnswerEntry(NULL) { };
            ~CPersistAnswers( );

    public:
       BOOL GetPrevAnswer(LPCWSTR pszUrl, DWORD dwAction, INT* piAnswer);
        VOID RememberAnswer(LPCWSTR pszUrl, DWORD dwAction, INT iAnswer);
        static inline BOOL IsPersistentAnswerAction(DWORD dwAction);

    private:                            
        struct CAnswerEntry 
        {
            // Construction
            CAnswerEntry(LPCWSTR pszUrl, DWORD dwAction, INT iAnswer);
            ~CAnswerEntry( );

            // Methods.
            BOOL MatchEntry (LPCWSTR pszUrl, DWORD dwAction);
            INT GetAnswer( ) const { return m_iAnswer; }
            LPCWSTR GetUrl( ) const { return m_pszUrl; }
            CAnswerEntry * GetNext( ) const { return m_pNext; }
            VOID SetNext(CAnswerEntry * pNext) { m_pNext = pNext; }

            private:
            CAnswerEntry * m_pNext;
            LPWSTR m_pszUrl;
            DWORD  m_dwAction;
            INT    m_iAnswer;
        };

        CAnswerEntry* m_pAnswerEntry;
    };

    CPersistAnswers m_persistAnswers;

// Methods/members to support caching so we optimize MapUrlToZone, etc.
protected:

    class CSecMgrCache {
    public:
        CSecMgrCache(void);
        ~CSecMgrCache(void);

        BOOL Lookup(LPCWSTR pwszURL,
                    DWORD *pdwZone = NULL,
                    BOOL *pfMarked = NULL,
                    BYTE *pbSecurityID = NULL,
                    DWORD *pcbSecurityID = NULL, 
                    LPCWSTR pwszDocDomain = NULL);
        void Add(LPCWSTR pwszURL,
                 DWORD dwZone,
                 BOOL fMarked,
                 const BYTE *pbSecurityID = NULL,
                 DWORD cbSecurityID = NULL,
                 LPCWSTR pwszDocDomain = NULL );
        void Flush(void);

        static VOID IncrementGlobalCounter( );

    protected:

        // Counters to flag cross-process cache invalidation.
        DWORD         m_dwPrevCounter ; // Global counter so we can correctly invalidate the cache if 
                                        // user changes options.
        static HANDLE s_hMutexCounter;  // mutex controlling access to shared memory counter 
 
        BOOL IsCounterEqual() const;
        VOID SetToCurrentCounter();

        // The body of the cache is this array of cache entries.
        // Cross-thread access control for the array is by critical section.

        CRITICAL_SECTION m_csectZoneCache; // assumes only one, static instance of the cache 


        struct CSecMgrCacheEntry {
            CSecMgrCacheEntry(void) :
                m_pwszURL(NULL),
                m_pbSecurityID(NULL),
                m_cbSecurityID(NULL),
                m_dwZone(URLZONE_INVALID),
                m_fMarked(FALSE),
                m_pwszDocDomain(NULL) {};
            ~CSecMgrCacheEntry(void) { Flush(); };

            void Set(LPCWSTR pwszURL, DWORD dwZone, BOOL fMarked, 
                    const BYTE *pbSecurityID, DWORD cbSecurityID, LPCWSTR pwszDocDomain);
            void Flush(void);
            
            LPWSTR  m_pwszURL;
            BYTE*   m_pbSecurityID;
            DWORD   m_cbSecurityID;
            DWORD   m_dwZone;
            BOOL    m_fMarked;
            LPWSTR  m_pwszDocDomain;
        }; // CSecMgrCacheEntry

        CSecMgrCacheEntry   m_asmce[MAX_SEC_MGR_CACHE];
        int                 m_iAdd;         // index in m_asmce to add the next element

        BOOL FindCacheEntry( LPCWSTR pwszURL, int& riEntry ); // must be called under critical section.

    }; // CSecMgrCache

    static CSecMgrCache s_smcache;

protected:
    // Methods to manage List of Allowed ActiveX controls

    static BOOL EnsureListReady(BOOL bForce = FALSE);
    static void IntializeAllowedControls();
    static HRESULT GetControlPermissions(BYTE * raw_CLSID, DWORD & dwPerm);

    // Get the final decision on the whether to run a CLSID (for this zone, etc)
    static HRESULT GetActiveXRunPermissions(BYTE * raw_CLSID, DWORD & dwPerm);

public:
    static VOID IncrementGlobalCounter( );

private:
    IInternetSecurityMgrSite*   m_pSite;
    IInternetZoneManager* m_pZoneManager;
    IInternetSecurityManager* m_pDelegateSecMgr;

    CRegKey m_regZoneMap;
    BOOL    m_fHardened;


    // Static members to do remember the correct IP Ranges.
    static BOOL   s_bIPInit;     // have we read the IP ranges. 
    static BYTE*  s_pRanges;     // array of range items
    static DWORD  s_cNumRanges;  // number of range items
    static DWORD  s_cbRangeItem; // size of each range item
    static DWORD  s_dwNextRangeIndex; // Next index to use to add numbers in the range entry.

    static CRITICAL_SECTION s_csectIP; // crit section to protect it all. 
    static BOOL s_bcsectInit;
    static CLSID * s_clsidAllowedList;
    static CRITICAL_SECTION s_csectAList;
    static DWORD s_dwNumAllowedControls;
};

#pragma warning(default:4200)

#endif // _SECMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\zones\zonepch.h ===
//  File:       zonepch.h
//
//  Contents:   Standard header files included by every file in this directory
//
//  
//  Functions://
//  History: 
//
//----------------------------------------------------------------------------

#ifndef _ZONEPCH_H_
#define _ZONEPCH_H_

// NOTE: This directory only supports Unicode currently

// Include this first since urlmon.hxx redefines malloc, free etc.
#include <malloc.h> // required for alloca prototype. 

#include "urlmon.hxx"
#include "shlwapi.h"
#include "shlwapip.h"
#include "winineti.h"

#include "zoneutil.h"
#include "urlenum.h"
#include "regzone.h"
#include "zonemgr.h"
#include "secmgr.h"

#include "resource.h"
// Unix: may not need to include unaligned.hpp if building with Apogee
//       Need it for Solaris CC compiler
#include <unaligned.hpp>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\zones\zonemgr.h ===
//  File:       zonemgr.h
//
//  Contents:   This file defines the class that implements the base IInternetZoneManager
//
//  Classes:    CUrlZoneManager
//
//  Functions:
//
//  History: 
//
//----------------------------------------------------------------------------

#ifndef _ZONEMGR_H_
#define _ZONEMGR_H_

class CUrlZoneManager : public IInternetZoneManager
{
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID iid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);



    // IInternetZoneManager overrides
       
    STDMETHODIMP GetZoneAttributes( 
        /* [in] */ DWORD dwZone,
        /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes);
    
    STDMETHODIMP SetZoneAttributes( 
        /* [in] */ DWORD dwZone,
        /* [in] */ ZONEATTRIBUTES *pZoneAttributes);
    
    STDMETHODIMP GetZoneCustomPolicy( 
        /* [in] */ DWORD dwZone,
        /* [in] */ REFGUID guidKey,
        /* [size_is][size_is][out] */ BYTE **ppPolicy,
        /* [out] */ DWORD *pcbPolicy,
        /* [in] */ URLZONEREG urlZoneReg);
    
    STDMETHODIMP SetZoneCustomPolicy( 
        /* [in] */ DWORD dwZone,
        /* [in] */ REFGUID guidKey,
        /* [size_is][in] */ BYTE *pPolicy,
        /* [in] */ DWORD cbPolicy,
        /* [in] */ URLZONEREG urlZoneReg);
    
    STDMETHODIMP GetZoneActionPolicy( 
        /* [in] */ DWORD dwZone,
        /* [in] */ DWORD dwAction,
        /* [size_is][out] */ BYTE *pPolicy,
        /* [in] */ DWORD cbPolicy,
        /* [in] */ URLZONEREG urlZoneReg);
    
    STDMETHODIMP SetZoneActionPolicy( 
        /* [in] */ DWORD dwZone,
        /* [in] */ DWORD dwAction,
        /* [size_is][in] */ BYTE *pPolicy,
        /* [in] */ DWORD cbPolicy,
        /* [in] */ URLZONEREG urlZoneReg);
    
    STDMETHODIMP PromptAction( 
        /* [in] */ DWORD dwAction,
        /* [in] */ HWND hwndParent,
        /* [in] */ LPCWSTR pwszUrl,
        /* [in] */ LPCWSTR pwszText,
        /* [in] */ DWORD dwPromptFlags);
    
    STDMETHODIMP LogAction( 
        /* [in] */ DWORD dwAction,
        /* [in] */ LPCWSTR pwszUrl,
        /* [in] */ LPCWSTR pwszText,
        /* [in] */ DWORD dwLogFlags);
    
    STDMETHODIMP CreateZoneEnumerator( 
        /* [out] */ DWORD *pdwEnum,
        /* [out] */ DWORD *pdwCount,
        /* [in] */ DWORD dwFlags);
    
    STDMETHODIMP GetZoneAt( 
        /* [in] */ DWORD dwEnum,
        /* [in] */ DWORD dwIndex,
        /* [out] */ DWORD *pdwZone);
    
    STDMETHODIMP DestroyZoneEnumerator( 
        /* [in] */ DWORD dwEnum);
    
    STDMETHODIMP CopyTemplatePoliciesToZone( 
        /* [in] */ DWORD dwTemplate,
        /* [in] */ DWORD dwZone,
        /* [in] */ DWORD dwReserved);
    

public:
    CUrlZoneManager(IUnknown *pUnkOuter, IUnknown** ppUnkInner );
    virtual ~CUrlZoneManager();
    virtual BOOL Initialize();  

    static inline BOOL Cleanup ( )
    {   delete s_pRegZoneContainer ;  
        if ( s_bcsectInit ) DeleteCriticalSection(&s_csect) ; 
        return TRUE;
    }



    static CRITICAL_SECTION s_csect;
    static BOOL s_bcsectInit;

// Aggregation and RefCount support.
protected:
    CRefCount m_ref;
        
    class CPrivUnknown : public IUnknown
    {
    public:
        STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);

        ~CPrivUnknown() {}
        CPrivUnknown() : m_ref () {}

    private:
        CRefCount   m_ref;          // the total refcount of this object
    };

    friend class CPrivUnknown;
    CPrivUnknown m_Unknown;

    IUnknown*   m_pUnkOuter;

    STDMETHODIMP_(ULONG) PrivAddRef()
    {
        return m_Unknown.AddRef();
    }
    STDMETHODIMP_(ULONG) PrivRelease()
    {
        return m_Unknown.Release();
    }


protected:
    static CRegZoneContainer* s_pRegZoneContainer;
    static inline CRegZone * GetRegZoneById(DWORD dw) 
        { return s_pRegZoneContainer->GetRegZoneById(dw); }

private:
    IServiceProvider *m_pSP;    
};

#endif // _ZONEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\zones\zonemgr.cxx ===
//  File:      zonemgr.cxx
//
//  Contents:  Implementation of the IInternetZoneManager interface for basic (i.e. not
//             pluggable protocols with weird Urls)              
//
//  Classes:    CUrlZoneManager
//
//  Functions:
//
//  History: 
//
//----------------------------------------------------------------------------

#include "zonepch.h"


CRegZoneContainer*  CUrlZoneManager::s_pRegZoneContainer = NULL;
CRITICAL_SECTION    CUrlZoneManager::s_csect;
BOOL                CUrlZoneManager::s_bcsectInit = FALSE;

STDAPI 
InternetCreateZoneManager
(
    IUnknown * pUnkOuter,
    REFIID  riid,
    void **ppvObj,
    DWORD dwReserved
)
{   
    HRESULT hr = S_OK;      
    *ppvObj = NULL;

    if ( !IsZonesInitialized() )
        return E_UNEXPECTED;

    if (dwReserved != 0 || !ppvObj || (pUnkOuter && riid != IID_IUnknown))
    {
        // If the object has to be aggregated the caller can only ask
        // for an IUnknown back.
        hr = E_INVALIDARG;
    }
    else 
    {
        CUrlZoneManager * pZoneMgr = new CUrlZoneManager(pUnkOuter, (IUnknown **)ppvObj);

        if ( pZoneMgr )
        {

            if (!pZoneMgr->Initialize())
            {
                hr = E_UNEXPECTED;
            }
            else 
            {
                if (riid == IID_IUnknown || riid == IID_IInternetZoneManager)
                {
                    // The correct pointer is in ppvObj
                    *ppvObj = (IInternetZoneManager *)pZoneMgr;
                }
                else 
                {
                    hr = E_NOINTERFACE;
                }
            }
        }
        else 
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


CUrlZoneManager::CUrlZoneManager(IUnknown *pUnkOuter, IUnknown **ppUnkInner)
{
    DllAddRef();

    m_pSP = NULL;


    if (!pUnkOuter)
    {
        pUnkOuter = &m_Unknown;
    }
    else
    {
        TransAssert(ppUnkInner);
        if (ppUnkInner)
        {
            *ppUnkInner = &m_Unknown;
            m_ref = 0;
        }
    }

    m_pUnkOuter = pUnkOuter;
}


CUrlZoneManager::~CUrlZoneManager()
{
    DllRelease();
}


BOOL CUrlZoneManager::Initialize()
{
    BOOL bReturn = TRUE;
    
    EnterCriticalSection(&s_csect);

    if (s_pRegZoneContainer == NULL)
    {
        // We want to defer the initialization of the shared memory section.
        // This is a convenient place since it is already guarded by a critical 
        // section and this code has to be run before any caching related operations
        // happen. This should be done before the reg zones themselves are initialized
        // since they can call into the shared memory sections.

        g_SharedMem.Init(SM_SECTION_NAME, SM_SECTION_SIZE);

        // InitializeCriticalSection in the CRegZoneContainer constructor
        // can raise a STATUS_NO_MEMORY exception:
        __try 
        {
            s_pRegZoneContainer = new CRegZoneContainer();
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            s_pRegZoneContainer = NULL; // Just in case
        }

        if (s_pRegZoneContainer == NULL )
        {
            bReturn = FALSE;   // We are hosed.
        }
        else if (!s_pRegZoneContainer->Attach(g_bUseHKLMOnly))
        {
            bReturn = FALSE;
        }

    }

    LeaveCriticalSection(&s_csect);

    return bReturn;        
}

STDMETHODIMP CUrlZoneManager::CPrivUnknown::QueryInterface(REFIID riid, void** ppvObj)
{
    HRESULT hr = S_OK;
    
    *ppvObj = NULL;

    CUrlZoneManager * pUrlZoneManager = GETPPARENT(this, CUrlZoneManager, m_Unknown);
        
    if (riid == IID_IUnknown || riid == IID_IInternetZoneManager)
    {
        *ppvObj = (IInternetZoneManager *)pUrlZoneManager;
        pUrlZoneManager->AddRef();
    }
    else 
    {
        hr = E_NOINTERFACE;
    }
    
    return hr;
}
                
STDMETHODIMP_(ULONG) CUrlZoneManager::CPrivUnknown::AddRef()
{
    LONG lRet = ++m_ref;

    return lRet;
}

STDMETHODIMP_(ULONG) CUrlZoneManager::CPrivUnknown::Release()
{

    CUrlZoneManager *pUrlZoneManager = GETPPARENT(this, CUrlZoneManager, m_Unknown);

    LONG lRet = --m_ref;

    if (lRet == 0)
    {
        delete pUrlZoneManager;
    }

    return lRet;
}

// IUnknown methods.
STDMETHODIMP CUrlZoneManager::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (riid == IID_IUnknown || riid == IID_IInternetZoneManager)
    {
        *ppvObj = (IInternetZoneManager *)this;
    }

    if (*ppvObj != NULL)
    {
        ((IUnknown *)*ppvObj)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CUrlZoneManager::AddRef()
{
    LONG lRet = m_pUnkOuter->AddRef();

    return lRet;
}

STDMETHODIMP_(ULONG) CUrlZoneManager::Release()
{                            
    LONG lRet = m_pUnkOuter->Release();

    // Controlling Unknown will delete the object if reqd.
        
    return lRet;
}


// The IInternetZoneManager methods

HRESULT
CUrlZoneManager::GetZoneAttributes
(
    DWORD dwZone,
    ZONEATTRIBUTES *pZoneAttributes
)
{
    if (pZoneAttributes == NULL /* || !IsZoneValid(dwZone) */)
    {
        return E_INVALIDARG;
    }

    CRegZone *pRegZone = GetRegZoneById(dwZone);
    if (pRegZone != NULL)
    {
        return pRegZone->GetZoneAttributes(*pZoneAttributes);
    }

    return E_FAIL;
}

HRESULT
CUrlZoneManager::SetZoneAttributes
(
    DWORD dwZone,
    ZONEATTRIBUTES *pZoneAttributes
)
{
    if (pZoneAttributes == NULL /* || !IsZoneValid(dwZone) */) 
    {
        return E_INVALIDARG;
    }
    
    CRegZone *pRegZone = GetRegZoneById(dwZone);
    if (pRegZone != NULL)
    {
        return (pRegZone->SetZoneAttributes(*pZoneAttributes));
    }

    return E_FAIL;
}


HRESULT
CUrlZoneManager::GetZoneCustomPolicy
(
    DWORD dwZone,
    REFGUID guidKey,
    BYTE **ppPolicy,
    DWORD *pcbPolicy,
    URLZONEREG urlZoneReg
)
{
    if (ppPolicy == NULL || pcbPolicy == NULL)
    {
        return E_INVALIDARG;
    }

    CRegZone *pRegZone = GetRegZoneById(dwZone);
    if (pRegZone == NULL)
    {
        return E_INVALIDARG; // Could be messed up registry here. 
    }

    return (pRegZone->GetCustomPolicy(guidKey, urlZoneReg, ppPolicy, pcbPolicy));
}

HRESULT
CUrlZoneManager::SetZoneCustomPolicy
(
    DWORD dwZone,
    REFGUID guidKey,
    BYTE *pPolicy,
    DWORD cbPolicy,
    URLZONEREG urlZoneReg
)
{
    if (pPolicy == NULL )
    {
        return E_INVALIDARG;
    }

    CRegZone *pRegZone = GetRegZoneById(dwZone);
    if (pRegZone == NULL)
    {
        return E_INVALIDARG;
    }

    return (pRegZone->SetCustomPolicy(guidKey, urlZoneReg, pPolicy, cbPolicy));
}


HRESULT
CUrlZoneManager::GetZoneActionPolicy
(
    DWORD dwZone,
    DWORD dwAction,
    BYTE* pPolicy,
    DWORD cbPolicy,
    URLZONEREG urlZoneReg
)
{
    if (pPolicy == NULL || cbPolicy < sizeof(DWORD))
    {
        return E_INVALIDARG;
    }

        
    CRegZone *pRegZone = GetRegZoneById(dwZone);
    if (pRegZone == NULL)
    {
        return E_INVALIDARG; // Could be messed up registry here. 
    }

    return (pRegZone->GetActionPolicy(dwAction, urlZoneReg, *((DWORD *)pPolicy)));
}
         

HRESULT 
CUrlZoneManager::SetZoneActionPolicy
(
    DWORD dwZone,
    DWORD dwAction,
    BYTE* pPolicy,
    DWORD cbPolicy,
    URLZONEREG urlZoneReg
)
{
    if (pPolicy == NULL || cbPolicy != sizeof(DWORD))
    {
        return E_INVALIDARG;
    }
        
    CRegZone *pRegZone = GetRegZoneById(dwZone);
    if (pRegZone == NULL)
    {
        return E_INVALIDARG; // Could be messed up registry here. 
    }

    return (pRegZone->SetActionPolicy(dwAction, urlZoneReg, *((DWORD *)pPolicy)));
}



// Actions that are actually carried out by the Zone Manager.


HRESULT
CUrlZoneManager::PromptAction
(
    DWORD dwAction,
    HWND hwndParent,
    LPCWSTR pwszUrl,
    LPCWSTR pwszText,
    DWORD dwPromptFlags
)
{
    return E_NOTIMPL;
}


HRESULT
CUrlZoneManager::LogAction
(
    DWORD dwAction,
    LPCWSTR pwszUrl,
    LPCWSTR pwszText,
    DWORD dwLogFlags
)
{
    return E_NOTIMPL;
}


// Zone enumerations
// This is really convoluted. These functions don't belong to the CUrlZoneManager but 
// really to the collection of zones. To support this we remember the pointer to the container
// that created us and delegate these functions on. 

HRESULT
CUrlZoneManager::CreateZoneEnumerator
(
    DWORD* pdwEnum,
    DWORD* pdwCount,
    DWORD  dwFlags   
)
{
    if (dwFlags != 0)
        return E_INVALIDARG;

    if (s_pRegZoneContainer != NULL)
    {
        return s_pRegZoneContainer->CreateZoneEnumerator(pdwEnum, pdwCount);
    }
    else
    {
        TransAssert(FALSE);
        return E_FAIL;
    }
}

HRESULT
CUrlZoneManager::GetZoneAt
(
    DWORD dwEnum,
    DWORD dwIndex,
    DWORD *pdwZone
)
{
    if (s_pRegZoneContainer != NULL)
    {
        return s_pRegZoneContainer->GetZoneAt(dwEnum, dwIndex, pdwZone);
    }
    else
    {
        TransAssert(FALSE);
        return E_FAIL;
    }
}

HRESULT
CUrlZoneManager::DestroyZoneEnumerator
(
    DWORD dwEnum
)
{
    if (s_pRegZoneContainer != NULL)
    {
        return s_pRegZoneContainer->DestroyZoneEnumerator(dwEnum);
    }
    else
    {
        TransAssert(FALSE);
        return E_FAIL;
    }
}



HRESULT
CUrlZoneManager::CopyTemplatePoliciesToZone
(
    DWORD dwTemplate,
    DWORD dwZone,
    DWORD dwReserved
)
{

    if (URLTEMPLATE_PREDEFINED_MIN > dwTemplate || URLTEMPLATE_PREDEFINED_MAX < dwTemplate)
        return E_INVALIDARG;
        
    CRegZone *pRegZone = GetRegZoneById(dwZone);
    if (pRegZone == NULL)
    {
        return E_INVALIDARG; // Could be messed up registry here. 
    }

    return (pRegZone->CopyTemplatePolicies(dwTemplate));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\zones\urlenum.h ===
#ifndef _URLENUM_H_
#define _URLENUM_H



class CEnumString : public IEnumString
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IEnumString ***
    virtual STDMETHODIMP Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(IEnumString **ppenum);

public:
    // Constructor-destructor, don't create this on the stack. 
    CEnumString();
    ~CEnumString();

    // This is a very simple class where all the strings should be added
    // before any enumeration occurs. 
    HRESULT AddString(LPCWSTR lpsz);

private:
    CRefCount m_ref;

    struct ListStr 
    {
        LPTSTR lpsz;
        ListStr * pListNext;
    };

    ListStr * pFirst;
    ListStr * pLast;
    ListStr * pCurrent;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\zones\zoneutil.h ===
//  File:       util.h
//
//  Contents:   Utility classes.
//
//  Classes:    CRefCount
//
//  Functions://
//  History: 
//
//----------------------------------------------------------------------------

#ifndef _URLZONE_UTIL_H_
#define _URLZONE_UTIL_H_

// Declarations for global variables.
extern BOOL g_bUseHKLMOnly;
extern BOOL g_bInit;

extern BOOL IsZonesInitialized();
extern HINSTANCE g_hInst;

// Cache of drive letter to drive type.
extern DWORD GetDriveTypeFromCacheA(LPCSTR psz);

// Is this file under the Cache directory.
extern BOOL IsFileInCacheDir(LPCWSTR pszFile);

// Is this file under the Cookie directory.
extern BOOL IsFileInCookieDir(LPCWSTR pszFile);

// Is urlmon currently loaded in GUI-mode setup?
extern BOOL IsInGUIModeSetup();

// Replacement for ultoa, works with wide-chars.
extern BOOL DwToWchar (DWORD dw, LPWSTR lpwsz, int radix);

#ifdef unix
#undef offsetof
#endif /* unix */
#define offsetof(s,m) ( (SIZE_T) &( ((s*)NULL)->m) )
#define GETPPARENT(pmemb, struc, membname) ((struc*)(((char*)(pmemb))-offsetof(struc, membname)))

// Does this file bear the Mark of the Web
extern BOOL FileBearsMarkOfTheWeb(LPCTSTR pszFile, LPWSTR *ppszURLMark);

EXTERN_C HRESULT ZonesDllInstall(BOOL bInstall, LPCWSTR pwStr);

/////////////////////////////////////////////////////////////////////////////
// CRegKey

class CRegKey
{
public:
    CRegKey(BOOL bHKLMOnly);
    CRegKey();      
    ~CRegKey();

// Attributes
public:
    operator HUSKEY() const;
    HUSKEY m_hKey;
    BOOL m_bHKLMOnly;

// Operations
public:
    LONG SetValue(DWORD dwValue, LPCTSTR lpszValueName);                // DWORD
    LONG SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);     // STRING
    LONG SetBinaryValue(const BYTE *pb, LPCTSTR lpszValueName, DWORD dwCount);        // BINARY
    LONG SetValueOfType(const BYTE *pb, LPCTSTR lpszValueName, DWORD dwCount, DWORD dwType); // ANY TYPE

    LONG QueryValue(DWORD* pdwValue, LPCTSTR lpszValueName);
    LONG QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount);
    LONG QueryBinaryValue(LPBYTE pb, LPCTSTR lpszValueName, DWORD *pdwCount);
    
    LONG QueryValueOrWild (DWORD* pdwValue, LPCTSTR lpszValueName)
    {
        if (ERROR_SUCCESS == QueryValue (pdwValue, lpszValueName))
            return ERROR_SUCCESS;
        else
            return QueryValue (pdwValue, TEXT("*"));
    }

    LONG SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);
    static LONG WINAPI SetValue(HUSKEY hKeyParent, LPCTSTR lpszKeyName,
        LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL, BOOL bHKLMOnly = FALSE);

    inline LONG QuerySubKeyInfo (DWORD* pdwNumKeys, DWORD* pdwMaxLen, DWORD *pdwNumValues);

    LONG EnumKey(DWORD dwIndex, LPTSTR lpszName, DWORD* pcchName);
    LONG EnumValue(DWORD dwIndex, LPTSTR pszValueName, LPDWORD pcchValueNameLen, 
                    LPDWORD pdwType, LPVOID pvData, LPDWORD pcbData);

    LONG Create(
        HUSKEY hKeyParent, // OPTIONAL
        LPCTSTR lpszKeyName,
        REGSAM samDesired);
        
    LONG Open(
        HUSKEY hKeyParent,  // OPTIONAL
        LPCTSTR lpszKeyName,
        REGSAM samDesired);
        
    LONG Close();
    HUSKEY Detach();
    void Attach(HUSKEY hKey);
    LONG DeleteValue(LPCTSTR lpszValue);
    LONG DeleteEmptyKey(LPCTSTR pszSubKey);

private:
    inline DWORD RegSetFlags() const 
    { return m_bHKLMOnly ? SHREGSET_FORCE_HKLM : SHREGSET_FORCE_HKCU; } 

    inline SHREGDEL_FLAGS RegDelFlags() const
    { return m_bHKLMOnly ? SHREGDEL_HKLM : SHREGDEL_HKCU; } 

    inline SHREGENUM_FLAGS RegEnumFlags() const
    { return m_bHKLMOnly ? SHREGENUM_HKLM : SHREGENUM_DEFAULT; }
};

inline CRegKey::CRegKey(BOOL bHKLMOnly)
{m_hKey = NULL; m_bHKLMOnly = bHKLMOnly;}

inline CRegKey::CRegKey()
{
    TransAssert(g_bInit);
    m_bHKLMOnly = g_bUseHKLMOnly;
    m_hKey = NULL;
}

inline CRegKey::~CRegKey()
{Close();}

inline CRegKey::operator HUSKEY() const
{return m_hKey;}

inline LONG CRegKey::SetValue(DWORD dwValue, LPCTSTR lpszValueName)
{
    TransAssert(m_hKey != NULL);

    return SHRegWriteUSValue(m_hKey, lpszValueName, REG_DWORD,
        (LPVOID)&dwValue, sizeof(DWORD), RegSetFlags());
}

inline LONG CRegKey::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
    TransAssert(lpszValue != NULL);
    TransAssert(m_hKey != NULL);

    return SHRegWriteUSValue(m_hKey, lpszValueName, REG_SZ,
        (LPVOID)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR), RegSetFlags());
}

inline LONG CRegKey::SetBinaryValue(const BYTE *pb, LPCTSTR lpszValueName, DWORD dwCount)
{
    TransAssert(pb != NULL);
    TransAssert(m_hKey != NULL);
    return SHRegWriteUSValue(m_hKey, lpszValueName, REG_BINARY,
        (LPVOID)pb, dwCount, RegSetFlags());
}

inline LONG CRegKey::SetValueOfType(const BYTE *pb, LPCTSTR lpszValueName, DWORD dwCount, DWORD dwType)
{
    TransAssert(pb != NULL);
    TransAssert(m_hKey != NULL);

    return SHRegWriteUSValue(m_hKey, lpszValueName, dwType,
        (LPVOID)pb, dwCount, RegSetFlags());
}

inline LONG CRegKey::EnumKey(DWORD dwIndex, LPTSTR lpszName, LPDWORD pcchName)
{
    TransAssert(pcchName != NULL);

    return SHRegEnumUSKey(m_hKey, dwIndex, lpszName, pcchName, RegEnumFlags());
}

inline LONG CRegKey::EnumValue(DWORD dwIndex, LPTSTR pszValueName, LPDWORD pcchValueNameLen, 
                                  LPDWORD pdwType, LPVOID pvData, LPDWORD pcbData)
{
    // If these counts are all NULL, you will not get anything useful back.
    TransAssert(pcchValueNameLen != NULL || pdwType != NULL || pcbData != NULL);

    return SHRegEnumUSValue(m_hKey, dwIndex, pszValueName, pcchValueNameLen, pdwType,
                                pvData, pcbData, RegEnumFlags());
}

inline LONG CRegKey::QuerySubKeyInfo(DWORD *pdwNumKeys, DWORD *pdwMaxLen, DWORD *pdwNumValues)
{
    return SHRegQueryInfoUSKey (m_hKey, pdwNumKeys, pdwMaxLen,
        pdwNumValues, NULL, RegEnumFlags());
}
       
inline HUSKEY CRegKey::Detach()
{
    HUSKEY hKey = m_hKey;
    m_hKey = NULL;
    return hKey;
}

inline void CRegKey::Attach(HUSKEY hKey)
{
    TransAssert(m_hKey == NULL);
    m_hKey = hKey;
}

inline LONG CRegKey::DeleteValue(LPCTSTR lpszValue)
{
    TransAssert(m_hKey != NULL);
    return SHRegDeleteUSValue(m_hKey, lpszValue, RegDelFlags());
}

inline LONG CRegKey::DeleteEmptyKey(LPCTSTR pszSubKey)
{
    TransAssert(m_hKey != NULL);
    return SHRegDeleteEmptyUSKey(m_hKey, pszSubKey, RegDelFlags());
}

// Simple helper class to get an exclusive lock for the duration of a function. 
// WILL NOT BLOCK IF THE HANDLE PASSED IS NULL OR INVALID.

class CExclusiveLock 
{
public:
    CExclusiveLock(HANDLE hMutex);  // pass in a handle to a mutex.
    ~CExclusiveLock();
private:
    HANDLE m_hMutex;
    BOOL fOk;
};

inline CExclusiveLock::CExclusiveLock( HANDLE hMutex )
{
    fOk = FALSE;
    if ( hMutex )
    {
        m_hMutex = hMutex;
        DWORD dw = WaitForSingleObject(hMutex, INFINITE);
        if ( (dw == WAIT_OBJECT_0) || (dw == WAIT_ABANDONED) )
        {
            // fix IE bug 18152
            fOk = TRUE;
        }
        else
        {
            TransAssert(FALSE); //shouldn't be anything else
        }
    }
}

inline CExclusiveLock::~CExclusiveLock( )
{
    if ( fOk )
    {
        ReleaseMutex(m_hMutex);
    }
}
                

// Helper class to create a shared memory object to share between processes. 

class CSharedMem
{
public:
    CSharedMem() { m_hFileMapping = NULL; m_lpVoidShared = NULL ; m_dwSize = 0; };
    ~CSharedMem( ) { Release( ); }
    BOOL Init(LPCSTR pszNamePrefix, DWORD dwSize);
    VOID Release( );
    // Offset into the shared memory section.
    // Always check return value since this can return NULL.
    LPVOID GetPtr (DWORD dwOffset); 

private:
    HANDLE m_hFileMapping ; 
    LPVOID m_lpVoidShared; 
    DWORD m_dwSize;
};

extern CSharedMem g_SharedMem;

// Shared memory related constants
#define SM_REGZONECHANGE_COUNTER    0   // Dword at offset 0
#define SM_SECMGRCHANGE_COUNTER     4   // Dword at offset 4

#define SM_SECTION_SIZE             8   // Total size of shared memory section.
#define SM_SECTION_NAME             "UrlZonesSM_"

// registry key paths - absolute
#define SZROOT          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\")
#define SZZONES         SZROOT TEXT("Zones\\")
#define SZTEMPLATE      SZROOT TEXT("TemplatePolicies\\")
#define SZZONEMAP       SZROOT TEXT("ZoneMap\\")
#define SZCACHE         SZROOT TEXT("Cache")

#define SZPOLICIES      TEXT("Software\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
#define SZHKLMONLY      TEXT("Security_HKLM_only")

// Entries to figure out if per user cache is allowed.
#define SZLOGON         TEXT("Network\\Logon")
#define SZUSERPROFILES  TEXT("UserProfiles")

// Cache location if per user cache is allowed.
#define SZSHELLFOLDER   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")
#define SZTIFS          TEXT("Cache")

// cache location if global
#define SZCACHECONTENT  SZROOT TEXT("Cache\\Content")
#define SZCACHEPATH     TEXT("CachePath")


// registry key paths - relative to SZZONES
#define SZZONESTANDARD      TEXT("Standard\\")
#define SZZONEUSERDEFINED   TEXT("User-Defined\\")

// registry key paths - relative to SZZONEMAP
#define SZDOMAINS           TEXT("Domains\\")
#define SZHARDENEDDOMAINS   TEXT("EscDomains\\")
#define SZRANGES            TEXT("Ranges\\")
#define SZESCRANGES         TEXT("EscRanges\\")
#define SZPROTOCOLS         TEXT("ProtocolDefaults\\")

// registry value names
#define SZINTRANETNAME      TEXT("IntranetName")
#define SZUNCASINTRANET     TEXT("UNCAsIntranet")
#define SZPROXYBYPASS       TEXT("ProxyBypass")
#define SZRANGE             TEXT(":Range")
#define SZRANGEPREFIX       TEXT("Range")

// Attributes to deal with "High", "Med", "Low" template policies
#define SZMINLEVEL              __TEXT("MinLevel")
#define SZRECLEVEL              __TEXT("RecommendedLevel")
#define SZCURRLEVEL             __TEXT("CurrentLevel")

// registry key path for allowed activex controls list; relative to HKEY_LOCAL_MACHINE _or_ HKEY_CURRENT_USER
#define ALLOWED_CONTROLS_KEY  TEXT("SOFTWARE\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\AllowedControls")


#define CSTRLENW(str)       (sizeof(str)/sizeof(TCHAR) - 1)

#define MARK_PREFIX_SIZE                30
#define MARK_SUFFIX_SIZE                10
#define EXTRA_BUFFER_SIZE               1024
#define UNICODE_HEADER_SIZE             2

#endif // _URLZONE_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\proxycfg\proxymigrate.cxx ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>
#include <wininet.h>
#include <proxreg.h>
#include <proxymsg.h>

void PrintMessage(DWORD dwMsg, ...);

DWORD SetProxySettings(DWORD Flags, char * ProxyServer, char * BypassList);


DWORD MigrateProxySettings (void)
{
    INTERNET_PER_CONN_OPTION_LIST list;
    DWORD dwBufSize = sizeof(list);
    DWORD dwErr = ERROR_SUCCESS;
    
    // fill out list struct
    list.dwSize = sizeof(list);
    list.pszConnection = NULL;      // NULL == LAN, otherwise connectoid name
    list.dwOptionCount = 3;         // get three options
    list.pOptions = new INTERNET_PER_CONN_OPTION[3];
    if(NULL == list.pOptions)
        return ERROR_NOT_ENOUGH_MEMORY;
        
    list.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
    list.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
    list.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;

    // ask wininet
    BOOL fRet = InternetQueryOption (NULL,
        INTERNET_OPTION_PER_CONNECTION_OPTION,
        &list,
        &dwBufSize);

// TODO: what if there is no manual proxy setting?

    if (!fRet)
    {
        dwErr = GetLastError();
        goto cleanup;
    }
    else
    {
        dwErr = SetProxySettings(
                    list.pOptions[0].Value.dwValue,
                    list.pOptions[1].Value.pszValue,
                    list.pOptions[2].Value.pszValue
                    );
    }
    
cleanup:

    GlobalFree (list.pOptions[1].Value.pszValue);
    GlobalFree (list.pOptions[2].Value.pszValue);
    delete [] list.pOptions;

    if (dwErr == ERROR_INTERNET_INVALID_OPTION)
    {
        PrintMessage(MSG_REQUIRES_IE501);
    }
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\zones\zoneutil.cxx ===
//  File:       util.cxx
//
//  Contents:   Utility classes.
//
//  Classes:    CRefCount, CRegKey
//
//  Functions://
//  History: 
//
//----------------------------------------------------------------------------

#include "zonepch.h"
#include "advpub.h"
#ifdef UNIX
#include <platform.h>
#endif /* UNIX */
#include "shfolder.h"



// Misc utility functions and declarations.
#define DRIVE_UNINIT    0xFFFF  // Indicates that we haven't called GetDriveType yet.  
DWORD rgdwDriveTypeCache[26]; // one for each drive letter. 

BOOL g_bInit = FALSE;
BOOL g_bUseHKLMOnly = FALSE;

static LPWSTR s_pwzCacheDir;
static HRESULT GetCacheDirectory( ); 
static LPWSTR s_pwzCookieDir = NULL;

static CHAR *s_szMarkPrefix = "<!-- saved from url=(%04d)";
static CHAR *s_szMarkSuffix = " -->\r\n";

CSharedMem g_SharedMem;

static CRITICAL_SECTION g_csect_GetCacheDir;

BOOL IsZonesInitialized( )
{
    return g_bInit;
}     


BOOL ZonesInit( )
{
    if (!g_bInit)
    {
        DWORD dwType;
        DWORD dwSize = sizeof(DWORD);
        DWORD dwDefault = FALSE ; // If no entry found default is use HKCU.

        g_bInit = TRUE;

        // Call the shlwapi wrapper function that directly reads in a value for us.
        // Note that if the call fails we have the right value in g_bHKLMOnly already.
        SHRegGetUSValue(SZPOLICIES, SZHKLMONLY, &dwType, &g_bUseHKLMOnly,
                &dwSize, TRUE, &dwDefault, sizeof(dwDefault));

        InitializeCriticalSection(&CUrlZoneManager::s_csect);
        CUrlZoneManager::s_bcsectInit = TRUE;

        CSecurityManager::GlobalInit();

        // Initialize the drive type cache.
        for ( int i = 0 ; i < ARRAYSIZE(rgdwDriveTypeCache) ; i++ )
            rgdwDriveTypeCache[i] = DRIVE_UNINIT;

        //initialize critical section for GetCacheDirectory()
        InitializeCriticalSection(&g_csect_GetCacheDir);
    }

    return TRUE;
}                          

VOID ZonesUnInit ( )
{
    CUrlZoneManager::Cleanup( );
    CSecurityManager::GlobalCleanup( );
    g_SharedMem.Release();

    // Free any memory allocated for the cache directory.
    delete [] s_pwzCacheDir;

    if(s_pwzCookieDir)
        delete [] s_pwzCookieDir;

    // Destroy the GetCacheDirectory() critsec.
    DeleteCriticalSection(&g_csect_GetCacheDir);
}

// IEAK calls this function so force us to re-read the global settings for 
// HKLM vs HKCU.
STDAPI ZonesReInit(DWORD /* dwReserved */)
{          
    DWORD dwType;
    DWORD dwDefault = g_bUseHKLMOnly;
    DWORD dwSize = sizeof(DWORD);

    DWORD dwError = SHRegGetUSValue(SZPOLICIES, SZHKLMONLY, &dwType, &g_bUseHKLMOnly,
                        &dwSize, TRUE, &dwDefault, sizeof(dwDefault));

    return HRESULT_FROM_WIN32(dwError);
}

// SHDOCVW calls this during Thicket save to get the comment to flag the
// saved file as 
STDAPI GetMarkOfTheWeb(LPCSTR pszURL, LPCSTR pszFile, DWORD dwFlags, LPSTR *ppszMark)
{
    HRESULT hr = S_OK;
    int  cchURL = lstrlenA(pszURL);

    // Note - the code assumes that lstrlen(IDS_MARK_PREFIX)
    // equals wsprintf(IDS_MARK_PREFIX, lstrlen(url)

    *ppszMark = (LPSTR)LocalAlloc( LMEM_FIXED, (lstrlenA(s_szMarkPrefix) +
                                                cchURL +
                                                lstrlenA(s_szMarkSuffix) +
                                                1) * sizeof(CHAR) );
    if ( *ppszMark )
    {
        wsprintfA( *ppszMark, s_szMarkPrefix, cchURL );
        lstrcatA( *ppszMark, pszURL );
        lstrcatA( *ppszMark, s_szMarkSuffix );
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}


// The security manager calls this to sniff a file: URL for the Mark of the Web
BOOL FileBearsMarkOfTheWeb(LPCTSTR pszFile, LPWSTR *ppszURLMark)
{
    BOOL              fMarked = FALSE;
    HANDLE            hFile;
    CHAR              szMarkPrefix[MARK_PREFIX_SIZE];
    CHAR              szMarkSuffix[MARK_SUFFIX_SIZE];
    WCHAR             wzMarkPrefix[MARK_PREFIX_SIZE];
    WCHAR             wzMarkSuffix[MARK_SUFFIX_SIZE];
    BOOL              fIsInUnicode = FALSE;
    DWORD             cchReadBufLen = 0;
    DWORD             cchURL;
    CHAR             *szMarkHead = NULL;
    WCHAR            *wzMarkHead = NULL;
    CHAR             *szMarkSuf = NULL;
    WCHAR            *wzMarkSuf = NULL;
    CHAR             *pszURLMark = NULL;
    DWORD             cchReadLen = 0;
    char             *pszTmp = NULL;
    char             *szReadBuf = NULL;
    int               iIteration = 1;

    lstrcpyA(szMarkPrefix, s_szMarkPrefix);
    lstrcpyA(szMarkSuffix, s_szMarkSuffix);

    hFile = CreateFile( pszFile, GENERIC_READ, FILE_SHARE_READ ,
                        NULL, OPEN_EXISTING, 
                        FILE_ATTRIBUTE_NORMAL, NULL );

    if ( hFile != INVALID_HANDLE_VALUE )
    {
        DWORD   cchPrefix = lstrlenA(szMarkPrefix);
        DWORD   dwRead;
        CHAR    szHeader[UNICODE_HEADER_SIZE];
        DWORD   cchHeader = UNICODE_HEADER_SIZE;

        if (ReadFile(hFile, szHeader, cchHeader, &dwRead, NULL) &&
                     cchHeader == dwRead)
        {
            if ((BYTE)szHeader[0] == (BYTE)0xFF && (BYTE)szHeader[1] == (BYTE)0xFE)
            {
                fIsInUnicode = TRUE;
            }
            else
            {
                fIsInUnicode = FALSE;
                SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
                TransAssert(GetLastError() == NO_ERROR);
            }
        }
        else
        {
            // Unable to sniff for header
            goto Exit;
        }

        // File pointer is not at "real" beginning of file, regardless of
        // whether we are reading a UNICODE or ANSI file.

        szReadBuf = NULL;
        cchReadBufLen = 0;
        iIteration = 1;

        // Anchor NULL to make szMarkPrefix: <!-- saved from url=
        szMarkPrefix[cchPrefix-6] = '\0';

        if (fIsInUnicode)
        {
            if (!MultiByteToWideChar(CP_ACP, 0, szMarkPrefix, -1,
                                     wzMarkPrefix, MARK_PREFIX_SIZE))
            {
                goto Exit;
            }

            if (!MultiByteToWideChar(CP_ACP, 0, szMarkSuffix, -1,
                                     wzMarkSuffix, MARK_SUFFIX_SIZE))
            {
                goto Exit;
            }
        }

        for (;;)
        {
            cchReadBufLen = INTERNET_MAX_URL_LENGTH +
                            EXTRA_BUFFER_SIZE * iIteration + 1;

            if (fIsInUnicode)
            {
                cchReadBufLen *= 2;
            }
                            
            szReadBuf = new char[cchReadBufLen];

            if (!szReadBuf)
            {
                goto Exit;
            }

            
            cchReadLen = (fIsInUnicode) ? (cchReadBufLen - 2) : (cchReadBufLen - 1);
    
            if (ReadFile(hFile, szReadBuf, cchReadLen, &dwRead, NULL))
            {
                // look for mark of the web
                if (fIsInUnicode)
                {
                    szReadBuf[dwRead] = L'\0';
                    wzMarkHead = StrStrW((WCHAR *)szReadBuf, wzMarkPrefix);

                    if (wzMarkHead)
                    {
                        // Look for mark of the web suffix. If we don't
                        // have it, that means that we didn't have enough
                        // space for the buffer, and we need to try again
                        // with more space.

                        wzMarkSuf = StrStrW(wzMarkHead, wzMarkSuffix);

                        if (wzMarkSuf)
                        {
                            // Found suffix. We're done.
                            break;
                        }
                        else
                        {
                            if (dwRead < cchReadLen)
                            {
                                // We've already read everything, and
                                // we didn't find the suffix!
                                goto Exit;
                            }


                            // Didn't find suffix because buffer was too
                            // small. Try it again

                            delete [] szReadBuf;
                            szReadBuf = NULL;
                            iIteration++;

                            SetFilePointer(hFile, 2, 0, FILE_BEGIN);
                            TransAssert(GetLastError() == NO_ERROR);

                            continue;
                        }
                    }
                    else
                    {
                        // Can't find the mark head! Must find it on
                        // first iteration, or we give up.
                        goto Exit;
                    }
                }
                else
                {
                    // We are dealing with ANSI
                    szReadBuf[dwRead] = '\0';
                    szMarkHead = StrStrA(szReadBuf, szMarkPrefix);

                    if (szMarkHead)
                    {
                        // Look for mark of the web suffix. If we don't
                        // have it, that means that we didn't have enough
                        // space for the buffer, and we need to try again
                        // with more space.

                        szMarkSuf = StrStrA(szMarkHead, szMarkSuffix);

                        if (szMarkSuf)
                        {
                            // Found suffix. We're done.
                            break;
                        }
                        else
                        {
                            if (dwRead < cchReadLen)
                            {
                                // We've already read everything, and
                                // we didn't find the suffix!
                                goto Exit;
                            }

                            // Didn't find suffix because buffer was too
                            // small. Try it again

                            delete [] szReadBuf;
                            szReadBuf = NULL;
                            iIteration++;

                            SetFilePointer(hFile, 0, 0, FILE_BEGIN);
                            TransAssert(GetLastError() == NO_ERROR);

                            continue;
                        }
                    }
                    else
                    {
                        // Can't find the mark head! Must find it on
                        // first iteration, or we give up.
                        goto Exit;
                    }
                }
            }
            else
            {
                // Read failure!
                TransAssert(0);
            }
        }

        // now wzMarkHead or szMarkHead points to beginning of the mark
        // of the web, and wzMarkSuf or szMarkSuf point to the mark suffix

        if (fIsInUnicode)
        {
            DWORD     cchURL = 0;
            LPWSTR    wzPtr = StrStrW(wzMarkHead, L"=(");

            if (!wzPtr) goto Exit;

            wzPtr += 2;       // skip to beginning of length
            
            TransAssert((wzMarkSuf >= wzPtr));           
            wzPtr[4] = L'\0'; // anchor NULL

            cchURL = StrToIntW(wzPtr);
            if (cchURL > INTERNET_MAX_URL_LENGTH)
            {
                cchURL = INTERNET_MAX_URL_LENGTH;
            }

            //the string length of the url should be greater than or equal to cchURL.
            //else abort the allocation.
            if ((wzMarkSuf-(wzPtr+5)) < (INT)cchURL)
                goto Exit;
                
            *ppszURLMark = (WCHAR*)LocalAlloc(LMEM_FIXED, (cchURL+1) * sizeof(WCHAR));

            if (!*ppszURLMark)
            {
                goto Exit;
            }

            // StrCpyN length includes NULL terminator
            StrCpyNW(*ppszURLMark, wzPtr + 5, cchURL + 1);
        }
        else
        {
            DWORD     cchURL = 0;
            LPSTR     szPtr = StrStrA(szMarkHead, "=(");

            if (!szPtr) goto Exit;

            szPtr += 2; // skip to beginning of length
            
            TransAssert((szMarkSuf >= szPtr));
            szPtr[4] = '\0'; // anchor NULL

            cchURL = StrToIntA(szPtr);
            if (cchURL > INTERNET_MAX_URL_LENGTH)
            {
                cchURL = INTERNET_MAX_URL_LENGTH;
            }

            //the string length of the url should be greater than or equal to cchURL.
            //else abort the allocation.
            if ((szMarkSuf-(szPtr+5)) < (INT)cchURL)
                goto Exit;
                
            pszTmp = new char[cchURL + 1];

            if (!pszTmp)
            {
                goto Exit;
            }

            *ppszURLMark = (WCHAR*)LocalAlloc(LMEM_FIXED, (cchURL+1) * sizeof(WCHAR));

            if (!*ppszURLMark)
            {
                goto Exit;
            }

            // StrCpyN length includes NULL terminator
            StrCpyNA(pszTmp, szPtr + 5, cchURL + 1);
            MultiByteToWideChar(CP_ACP, 0, pszTmp, -1, *ppszURLMark, cchURL);
            (*ppszURLMark)[cchURL] = '\0';

        }

        if (szReadBuf)
        {
            delete [] szReadBuf;
            szReadBuf = NULL;
        }
    }
    else
    {
        // CreateFile failure
        goto Exit;
    }

    fMarked = TRUE;

Exit:

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    if (szReadBuf)
    {
        delete [] szReadBuf;
    }

    if (pszURLMark)
    {
        delete [] pszURLMark;
    }

    if (pszTmp) {
        delete [] pszTmp;
    }

    return fMarked;
}

//This function may now be called by one or more threads from IsFileInCacheDir() ( since we've moved invocation out of
//ZonesInit ( to prevent LoadLibrary() being called during DllMain execution ) ).
//Hence, we need a critsec for mutual exclusion..
//This also means that if for some reason, this function fails the first time, it may be called mutliple times by different
//threads, whereas earlier if it failed during ZonesInit(), it was never tried again.
HRESULT GetCacheDirectory( )
{
    HRESULT hr = E_FAIL;
    HMODULE hModShell=NULL;
    HMODULE hModShfolder=NULL;
    PFNSHGETFOLDERPATH pfnGetFolderPath;

	EnterCriticalSection(&g_csect_GetCacheDir);

    // If another thread managed to get this while this thread was waiting, bail out with success.
    // Optionally, if we want this code to execute only once, we can use a static boolean check.
    if (s_pwzCacheDir != NULL && s_pwzCookieDir != NULL)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hModShell = LoadLibrary(TEXT("shell32.dll"));
    if (NULL == hModShell)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());  
        goto Cleanup;
    }

#ifdef UNICODE
    pfnGetFolderPath = (PFNSHGETFOLDERPATHW)GetProcAddress(hModShell, "SHGetFolderPathW");
#else
    pfnGetFolderPath = (PFNSHGETFOLDERPATHA)GetProcAddress(hModShell, "SHGetFolderPathA");
#endif

    if (pfnGetFolderPath == NULL)
    {
        hModShfolder = LoadLibrary(TEXT("shfolder.dll"));
        if (hModShfolder == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Cleanup;
        }
        
#ifdef UNICODE
        pfnGetFolderPath = (PFNSHGETFOLDERPATHW)GetProcAddress(hModShfolder, "SHGetFolderPathW");
#else
        pfnGetFolderPath = (PFNSHGETFOLDERPATHA)GetProcAddress(hModShfolder, "SHGetFolderPathA");
#endif
    }

    if (pfnGetFolderPath == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else 
    {
        TCHAR rgchCachePath[MAX_PATH];

        hr = pfnGetFolderPath(NULL, CSIDL_INTERNET_CACHE, NULL, 0, rgchCachePath);

        if (rgchCachePath[0] == TEXT('\0'))
            hr = E_FAIL;
       
        if (SUCCEEDED(hr))
        {
            if (s_pwzCacheDir != NULL)
            {
                delete [] s_pwzCacheDir;
                s_pwzCacheDir = NULL;
            }
            // Allocate memory for the new location.
            s_pwzCacheDir = new TCHAR[lstrlen(rgchCachePath) + 1];
            if (s_pwzCacheDir != NULL)
            {
                StrCpy(s_pwzCacheDir, rgchCachePath);
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }


        hr = pfnGetFolderPath(NULL, CSIDL_COOKIES, NULL, 0, rgchCachePath);

        if (rgchCachePath[0] == TEXT('\0'))
            hr = E_FAIL;
       
        if (SUCCEEDED(hr))
        {
            if (s_pwzCookieDir != NULL)
            {
                delete [] s_pwzCookieDir;
                s_pwzCookieDir = NULL;
            }
            // Allocate memory for the new location.
            s_pwzCookieDir = new TCHAR[lstrlen(rgchCachePath) + 1];
            if (s_pwzCookieDir != NULL)
            {
                StrCpy(s_pwzCookieDir, rgchCachePath);
                hr = S_OK;
            }
            else
                hr = E_OUTOFMEMORY;
        }

    }

Cleanup:
    if (hModShfolder)
        FreeLibrary(hModShfolder);

    if (hModShell)
        FreeLibrary(hModShell);

    LeaveCriticalSection(&g_csect_GetCacheDir);
   	
    return hr;
}


#if NOTUSED // Keep this code around in the unlikely event that we resurrect the Unix port. 
// This function gets the location of the cache directory.
HRESULT GetCacheDirectory( ) 
{
    DWORD dwType;

    // First figure out if we are using per-user cache or per-machine cache. 
    // This decides which registry key to look at for the cache value.
    BOOL fPerUserCache = TRUE;
#ifndef UNIX
    OSVERSIONINFOA osvi = {0};
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

    GetVersionExA(&osvi);
    if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        fPerUserCache = TRUE;
    }
    else
    { 
       DWORD dwUserProfile = 0;
       DWORD dwSize = sizeof(dwUserProfile);

        // Determine if user profiles are enabled.
        if ((ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, SZLOGON, SZUSERPROFILES, &dwType, &dwUserProfile, &dwSize))
            && (dwUserProfile != 0 ))
        {
            fPerUserCache = TRUE;
            // Look for the exceptional case where User Profiles are enabled but the cache is still
            // global.
            dwSize = sizeof(dwUserProfile);

            if ((ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, SZCACHE, SZUSERPROFILES, &dwType, &dwUserProfile, &dwSize))
                && (dwUserProfile == 0))
            {
                fPerUserCache = FALSE;
            }
        }
        else
        {
            fPerUserCache = FALSE;
        }
    }
#endif /* !UNIX */

    HRESULT hr = S_OK;
#ifdef UNIX
    WCHAR wszIE5Dir[] = L"ie5/"; 
    DWORD cchPath = MAX_PATH + sizeof(wszIE5Dir)/sizeof(WCHAR);
#else
    DWORD cchPath = MAX_PATH;
#endif /* !UNIX */
    s_pwzCacheDir = new WCHAR[cchPath];
    DWORD dwError = NOERROR;

    // First figure out if we are using per-user cache or per-machine cache. 
    // This decides which registry key to look at for the cache value.
    if (s_pwzCacheDir != NULL)
    {
        LPCWSTR pwzKey = fPerUserCache ? SZSHELLFOLDER : SZCACHECONTENT;
        LPCWSTR pwzValue = fPerUserCache ? SZTIFS : SZCACHEPATH ;
        HKEY hKey = fPerUserCache ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;

        dwError = SHGetValueW(hKey, pwzKey, pwzValue, &dwType, s_pwzCacheDir, &cchPath);
    }
    else 
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (dwError != NOERROR)    
    {
        delete [] s_pwzCacheDir;
        s_pwzCacheDir = NULL;
        hr = HRESULT_FROM_WIN32(dwError);
    }
    else 
    {
        TransAssert(s_pwzCacheDir != NULL);
        PathRemoveBackslashW(s_pwzCacheDir);
#ifdef UNIX
        {
           int   ccPath, index;
           int   lenIE5Dir  = lstrlen(wszIE5Dir);

           ccPath = lstrlen(s_pwzCacheDir);
           index  = ccPath - 1;

           while(index >= 0 && s_pwzCacheDir[index] != FILENAME_SEPARATOR_W)
                index--;

           index++;
           memmove(&s_pwzCacheDir[index+lenIE5Dir],&s_pwzCacheDir[index],(ccPath-index+1)*sizeof(TCHAR));
           memcpy(&s_pwzCacheDir[index], wszIE5Dir, lenIE5Dir*sizeof(TCHAR));
        }
#endif /* UNIX */
        hr = S_OK;
    }
    return hr;
}                                                        
#endif // NOTUSED

BOOL IsFileInCacheDir(LPCWSTR pwzFile) 
{
    BOOL bReturn = FALSE;
    TCHAR szLongPath[MAX_PATH];

    if(!GetLongPathNameWrapW(pwzFile, szLongPath, sizeof(szLongPath)/sizeof(TCHAR)))
    {
        goto exit;
    }

    if (s_pwzCacheDir == NULL || s_pwzCookieDir == NULL)
    {
        if (! (SUCCEEDED(GetCacheDirectory())) )
            goto exit;
    }

    if(PathIsPrefixW(s_pwzCacheDir, szLongPath))
    {
        bReturn = TRUE;
    }

exit:
    return bReturn;
}

BOOL IsFileInCookieDir(LPCWSTR pwzFile) 
{
    BOOL bReturn = FALSE;
    TCHAR szLongPath[MAX_PATH];

    if(!GetLongPathNameWrapW(pwzFile, szLongPath, sizeof(szLongPath)/sizeof(TCHAR)))
    {
        goto exit;
    }

    if (s_pwzCacheDir == NULL || s_pwzCookieDir == NULL)
    {
        if (! (SUCCEEDED(GetCacheDirectory())) )
            goto exit;
    }

    if(PathIsPrefixW(s_pwzCookieDir, szLongPath))
    {
        bReturn = TRUE;
    }

exit:
    return bReturn;
}

// This function takes a DWORD and returns a wide char string
// in hex. There is no leading 0x and the leading 0's are stripped off
// This is to avoid pulling in the general wsprintfW into wininet which is 
// pretty big. You have to pass in enough memory to write the resulting string 
// into ( i.e >= 9 chars)

BOOL DwToWchar(DWORD dw, LPWSTR pwz, int radix)
{
    char sz[9];
    LPSTR psz = sz;
    LPSTR pszTemp = (LPSTR)pwz;
    char rgFormatHex[] = "%lX";
    char rgFormatDecimal[] = "%ld";
    char *pszFormat;
        
    if (radix == 16)
        pszFormat = rgFormatHex;
    else if (radix == 10)
        pszFormat = rgFormatDecimal;
    else
    {
        TransAssert(FALSE);
        return FALSE;
    }
                        
    if (wsprintfA(sz, pszFormat, dw) == 0)
    {
        return FALSE;
    }
#ifndef unix
    // Everything in the string sz is ANSI.
    while (*psz != 0) 
    {
        *pszTemp++ = *psz++;
        *pszTemp++ = '\0';
    }

    // Put the trailing NULL to the wide-char string.
    *pszTemp++ = '\0';
    *pszTemp++ = '\0';
#else
    while(*psz != 0)
        *pwz++ = (WCHAR)(DWORD)*psz++;
    *pwz++ = 0;
#endif /* unix */
    return TRUE;
}

// Drive type caching function.
//
DWORD GetDriveTypeFromCacheA(LPCSTR lpsz) 
{
    // NOTE: The retail version doesn't do any paramater validation to determine if this path is 
    // a valid one. So something like CTHISISGARBAGE will return the drive type for C:. 
    // This is just meant to be used inside the security manager so we can bypass these
    // checks. 
        
    TransAssert(lstrlenA(lpsz) >= 3);   // c:\ for example
    TransAssert(lpsz[1] == ':' && lpsz[2] == '\\');
#ifndef unix
    CHAR ch = (CHAR)CharLowerA((LPSTR)lpsz[0]);
#else
    CHAR *pch = CharLowerA((LPSTR)lpsz);
    CHAR ch = *pch;
#endif /* unix */

#ifndef UNIX 
    if (ch >= 'a' && ch <= 'z')
    {
        // First check the cache to see if the entry already exists.
        int index = ch - 'a';
        if (rgdwDriveTypeCache[index] == DRIVE_UNINIT)
        {
            rgdwDriveTypeCache[index] = GetDriveTypeA(lpsz);
        }

        TransAssert(rgdwDriveTypeCache[index] != DRIVE_UNINIT);
        return rgdwDriveTypeCache[index];
    }
#else
    if (ch == '/')
    {
        // IEUNIX - On unix we have only one drive "/" which is of type fixed
        // This was causing a wrong zone to be calculated for unix paths.
        return DRIVE_FIXED;
    }
#endif
    else 
    {
        return DRIVE_UNKNOWN;
    }
}
                        

// Helper to determine if we're currently loaded during GUI mode setup
BOOL IsInGUIModeSetup()
{
    static DWORD s_dwSystemSetupInProgress = 42;

    if (42 == s_dwSystemSetupInProgress)
    {
        // Rule is that this value will exist and be equal to 1 if in GUI mode setup.
        // Default to NO, and only do this for upgrades because this is potentially
        // needed for unattended clean installs.
        s_dwSystemSetupInProgress = 0;

        HKEY hKeySetup = NULL;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                          TEXT("System\\Setup"),
                                          0,
                                          KEY_READ,
                                          &hKeySetup))
        {
            DWORD dwSize = sizeof(s_dwSystemSetupInProgress);

            if (ERROR_SUCCESS != RegQueryValueEx (hKeySetup,
                                                  TEXT("SystemSetupInProgress"),
                                                  NULL,
                                                  NULL,
                                                  (LPBYTE) &s_dwSystemSetupInProgress,
                                                  &dwSize))
            {
                s_dwSystemSetupInProgress = 0;
            }
            else
            {
                dwSize = sizeof(s_dwSystemSetupInProgress);
                if (s_dwSystemSetupInProgress &&
                    ERROR_SUCCESS != RegQueryValueEx (hKeySetup,
                                                      TEXT("UpgradeInProgress"),
                                                      NULL,
                                                      NULL,
                                                      (LPBYTE) &s_dwSystemSetupInProgress,
                                                      &dwSize))
                {
                    s_dwSystemSetupInProgress = 0;
                }
            }

            RegCloseKey(hKeySetup);
        }
    }
    return s_dwSystemSetupInProgress ? TRUE : FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CRegKey

LONG CRegKey::Close()
{
    LONG lRes = ERROR_SUCCESS;
    if (m_hKey != NULL)
    {
        lRes = SHRegCloseUSKey(m_hKey);
        m_hKey = NULL;
    }
    return lRes;
}

LONG CRegKey::Create(HUSKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
    HUSKEY hKey = NULL;
    // BUGBUG : Is this the correct flag to call this function with?
    DWORD dwFlags = m_bHKLMOnly ? SHREGSET_FORCE_HKLM : SHREGSET_FORCE_HKCU;

    LONG lRes = SHRegCreateUSKey(lpszKeyName, samDesired, hKeyParent, &hKey, dwFlags); 

    if (lRes == ERROR_SUCCESS)
    {
        lRes = Close();
        m_hKey = hKey;
    }
    return lRes;
}

LONG CRegKey::Open(HUSKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
    HUSKEY hKey = NULL;

    LONG lRes = SHRegOpenUSKey(lpszKeyName, samDesired, hKeyParent, &hKey, m_bHKLMOnly);

    if (lRes == ERROR_SUCCESS)
    {
        lRes = Close();
        TransAssert(lRes == ERROR_SUCCESS);
        m_hKey = hKey;
    }
    return lRes;
}

LONG CRegKey::QueryValue(DWORD* pdwValue, LPCTSTR lpszValueName)
{
    DWORD dwType = NULL;
    DWORD dwCount = sizeof(DWORD);
    LONG lRes = SHRegQueryUSValue(m_hKey, lpszValueName, &dwType,
        pdwValue, &dwCount, m_bHKLMOnly, NULL, 0);
    TransAssert((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
    TransAssert((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
    return lRes;
}

LONG CRegKey::QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount)
{
    TransAssert(pdwCount != NULL);
    DWORD dwType = 0;
    LONG lRes = SHRegQueryUSValue(m_hKey, lpszValueName, &dwType,
        szValue, pdwCount, m_bHKLMOnly, NULL, 0);
    TransAssert((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
             (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));
    return lRes;
}

LONG CRegKey::QueryBinaryValue(LPBYTE pb, LPCTSTR lpszValueName, DWORD* pdwCount)
{
    TransAssert(pdwCount != NULL);
    DWORD dwType = NULL;
    LONG lRes = SHRegQueryUSValue(m_hKey, lpszValueName, &dwType,
        pb, pdwCount, m_bHKLMOnly, NULL, 0);
    TransAssert((lRes!=ERROR_SUCCESS) || (dwType == REG_BINARY));
    return lRes;
}


LONG WINAPI CRegKey::SetValue(HUSKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName, BOOL bHKLMOnly)
{
    TransAssert(lpszValue != NULL);
    CRegKey key(bHKLMOnly);
    LONG lRes = key.Create(hKeyParent, lpszKeyName, KEY_WRITE);
    if (lRes == ERROR_SUCCESS)
        lRes = key.SetValue(lpszValue, lpszValueName);
    return lRes;
}

LONG CRegKey::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
    TransAssert(lpszValue != NULL);
    CRegKey key(m_bHKLMOnly);
    LONG lRes = key.Create(m_hKey, lpszKeyName, KEY_WRITE);
    if (lRes == ERROR_SUCCESS)
        lRes = key.SetValue(lpszValue, lpszValueName);
    return lRes;
}


//////////////////////////////////////////////////////////////////////////
//
// Autoregistration entry points
//
//////////////////////////////////////////////////////////////////////////

HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibraryA("ADVPACK.DLL");

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);

        if (pfnri)
        {
            hr = pfnri(g_hInst, szSection, NULL);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}

/*
 * We want to show the inetcpl settings as "Custom" in case of an upgrade only.
 *
 * We detect an upgrade using an HKCU key which only urlmon selfreg. code can set
 * Earlier we used the "Zones" key.
 *
 * In Whistler, the problem is some other module ( Office maybe ) registers this key,
 * so that even on a fresh install, we assume it's Custom.
 * Fix is to change the key we check for.
 *
 * On Millenium, there was a problem with double registration - in this case, the fix
 * would be to also put in the version key and check both for existence of a known key
 * and to match version to avoid slamming "Custom" in if there's a version match.
 */
BOOL
ShouldSetCustom()
{

#define SZPATH_ZONES_LOCAL_A  "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones\\0\\"

    BOOL fUpgrade = FALSE;
    HKEY hKeyZones;

    LONG dwResult = RegOpenKeyExA(
        HKEY_CURRENT_USER,
        SZPATH_ZONES_LOCAL_A, 
        0, 
        KEY_READ,
        &hKeyZones);

    if (dwResult == ERROR_SUCCESS)
    {
        //key exists, not an upgrade
        RegCloseKey(hKeyZones);
        fUpgrade = TRUE;
    }
    
    return fUpgrade;
}

STDAPI
ZonesDllInstall
(
    IN BOOL      bInstall,   // Install or Uninstall
    IN LPCWSTR    pwStr
)
{
    TransAssert(pwStr != NULL);

    HRESULT hr = S_OK;
    BOOL bUseHKLM = TRUE;

    if (pwStr && (0 == StrCmpIW(pwStr, L"HKCU")))
    {
        // Don't write to HKCU during GUI mode setup.  Otherwise,
        // the values may get slammed into all profiles during an upgrade.
        if (IsInGUIModeSetup())
            return hr;

        bUseHKLM = FALSE;
    }

    if (bInstall && pwStr)
    {
        if(!StrCmpIW(pwStr, L"HKCUSoft"))
        {
            return CallRegInstall("RegSoften.HKCU");
        }
        else if(!StrCmpIW(pwStr, L"HKCUHard"))
        {
            return CallRegInstall("RegHarden.HKCU");
        }
        else if(!StrCmpIW(pwStr, L"HKLMHard"))
        {
            return CallRegInstall("RegHarden.HKLM");
        }
        else if(!StrCmpIW(pwStr, L"HKLMSoft"))
        {
            return CallRegInstall("RegSoften.HKLM");
        }
    }


    if ( bInstall )
    {
        BOOL fSetHKCUToCustom = FALSE; //Default to no-upgrade to avoid overwriting default zone settings.
        
        if (!bUseHKLM)
        {
            fSetHKCUToCustom = ShouldSetCustom();
        }

        // Backup IE3 user agent string, but don't do ever do these during
        // GUI mode setup
        if (!IsInGUIModeSetup())
        {
            CallRegInstall("BackupUserAgent");
            CallRegInstall("BackupConnectionSettings");
        }
        
        CallRegInstall(bUseHKLM ? "Backup.HKLM" : "Backup.HKCU");
        hr = CallRegInstall(bUseHKLM ? "Reg.HKLM" : "Reg.HKCU");

        if (!bUseHKLM)
        {
// Bug # 19514: To appease the press, we need to change the default for scripting unsafe activex
// controls to "disable" instead of "prompt". But at install time we can't blindly overwrite
// the existing value. We have to check if the users Intranet/Internet zones are at medium
// security from the previous install. To avoid instantiating the zone manager at registration
// time we also hardcode the registry values here.
#define  SZINTRANET  SZZONES TEXT("1")
#define  SZTRUSTED   SZZONES TEXT("2")
#define  SZINTERNET  SZZONES TEXT("3")
#define  SZUNTRUSTED SZZONES TEXT("4")
            TransAssert(URLZONE_INTRANET  == 1);
            TransAssert(URLZONE_TRUSTED   == 2);
            TransAssert(URLZONE_INTERNET  == 3);
            TransAssert(URLZONE_UNTRUSTED == 4);

            DWORD dwCurrentLevel ;

            CRegKey regKeyIntranet(FALSE);
            if ((regKeyIntranet.Open(NULL, SZINTRANET, KEY_READ) == ERROR_SUCCESS) &&
                (regKeyIntranet.QueryValue(&dwCurrentLevel, SZCURRLEVEL) == NOERROR) &&
                (dwCurrentLevel == URLTEMPLATE_MEDIUM)
               )
            {
                CallRegInstall("Intranet.HackActiveX");
            }

            CRegKey regKeyInternet(FALSE);
            if ((regKeyInternet.Open(NULL, SZINTERNET, KEY_READ) == ERROR_SUCCESS) &&
                (regKeyInternet.QueryValue(&dwCurrentLevel, SZCURRLEVEL) == NOERROR) &&
                (dwCurrentLevel == URLTEMPLATE_MEDIUM)
               )
            {
                CallRegInstall("Internet.HackActiveX");
            }

            if (fSetHKCUToCustom)
            {
            //108298/104506  We want to preserve the settings prior to an upgrade, but at
            // the same time, we dont want to show a security level inconsistent with the
            // actual policies ( which is what will happen if templates change or default
            // policy values change.  So set all templates to CUSTOM on install.
                CRegKey regKeyIntranet(FALSE);
                if(regKeyIntranet.Open(NULL, SZINTRANET, KEY_WRITE) == ERROR_SUCCESS)
                    regKeyIntranet.SetValue(URLTEMPLATE_CUSTOM, SZCURRLEVEL);

                CRegKey regKeyTrusted(FALSE);
                if(regKeyTrusted.Open(NULL, SZTRUSTED, KEY_WRITE) == ERROR_SUCCESS)
                    regKeyTrusted.SetValue(URLTEMPLATE_CUSTOM, SZCURRLEVEL);

                CRegKey regKeyInternet(FALSE);
                if(regKeyInternet.Open(NULL, SZINTERNET, KEY_WRITE) == ERROR_SUCCESS)
                    regKeyInternet.SetValue(URLTEMPLATE_CUSTOM, SZCURRLEVEL);

                CRegKey regKeyUntrusted(FALSE);
                if(regKeyUntrusted.Open(NULL, SZUNTRUSTED, KEY_WRITE) == ERROR_SUCCESS)
                    regKeyUntrusted.SetValue(URLTEMPLATE_CUSTOM, SZCURRLEVEL);
            }
        }
                                                  
    }
    else
    {
        // Restore IE3 user agent string.
        CallRegInstall("RestoreUserAgent");
        CallRegInstall("RestoreConnectionSettings");
        hr = CallRegInstall(bUseHKLM ? "Unreg.HKLM" : "UnReg.HKCU");

        if (bUseHKLM)
            hr = CallRegInstall("Restore.HKLM");

    }

    return hr;
}



// CSharedMem member functions.

BOOL CSharedMem::Init(LPCSTR pszNamePrefix, DWORD dwSize)
{
    // Note that this function is in ANSI, because we don't have Unicode wrappers 
    // for the file-mapping functions on Win9x and these need to work on Win9x.

    // Create the name for the file mapping object. 
    // We want this name to be unique per logged in user.
    // We will choose a name of the form ZonesSM_"UserName" for systems prior to NT5
    // BUGBUG: On Terminal server should we use Global\ in the name. If a user is logged on in multiple
    // sessions this seems desirable, but not sure if registry changes get reflected in the other 
    // session anyway.

    DWORD cchPrefix = lstrlenA(pszNamePrefix);
    LPSTR pszHandleName = (LPSTR) _alloca(cchPrefix + MAX_PATH);
    if (pszHandleName == NULL)
        return FALSE;

    memcpy(pszHandleName, pszNamePrefix, cchPrefix);

    // Move pointer to after the fixed part of the string.
    LPSTR psz = pszHandleName + cchPrefix;

    // Technically the max username possible is UNLEN which is less than MAX_PATH.
    // We use MAX_PATH to not pull in another random header into the build.
    DWORD dwMaxNameSize = MAX_PATH;

    if (GetUserNameA(psz, &dwMaxNameSize)) 
    { 
        // If succeeded, rgchHandleName now contains the exact same thing.
    }
    else
    {
        TransAssert(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
        // if it fails, we will assume no logged on user and just use a global shared memory
        // section of the base name
    }

    m_dwSize = dwSize ;

    // First try to see if the shared memory section already exists.
    m_hFileMapping = CreateFileMappingA(INVALID_HANDLE_VALUE,
                                       NULL,
                                       PAGE_READWRITE,
                                       0,
                                       m_dwSize,
                                       pszHandleName) ;
    if (m_hFileMapping != NULL)
    {
        m_lpVoidShared = MapViewOfFile(m_hFileMapping, FILE_MAP_WRITE, 0, 0, 0);
    }

    return (m_hFileMapping != NULL && m_lpVoidShared != NULL);
}

VOID CSharedMem::Release()
{
    if (m_lpVoidShared != NULL)
    {
        UnmapViewOfFile(m_lpVoidShared);
        m_lpVoidShared = NULL;
    }

    if (m_hFileMapping != NULL)
    {
        CloseHandle(m_hFileMapping);
        m_hFileMapping = NULL;
    }

    m_dwSize = 0;

}

// This function will return NULL if either we couldn not initialize the shared memory
// for some reason or the offset specified is not in range. The offset should be specified
// in number of bytes.

LPVOID CSharedMem::GetPtr(DWORD dwOffset)
{
    if (m_lpVoidShared == NULL)
        return NULL;

    if (dwOffset >= m_dwSize)
        return NULL;

    return (BYTE *)m_lpVoidShared + dwOffset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\proxycfg\proxycfg.cxx ===
// ===========================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 2000 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>
#include <winhttp.h>
#include <ntverp.h>
#include <common.ver>
#include "proxymsg.h"

// Global module handles for error message lookup

HMODULE g_hModWinHttp = NULL;

//
// MessageCleanup
// 
// Free DLL loaded for message lookup
//
void
MessageCleanup(void)
{
    if (g_hModWinHttp)
        FreeLibrary(g_hModWinHttp);
}

//
// GetMessage
// 
// Get localized message text from WinHTTP or System.
// Caller responsible for LocalFree'ing the returned string.
//
PWSTR
GetMessage(
    IN  DWORD   dwError
)
{
    PWSTR  pwszMessage = NULL;
    DWORD  dwCount  = 0;

    if (dwError > WINHTTP_ERROR_BASE && dwError <= WINHTTP_ERROR_LAST)
    {
        if (g_hModWinHttp == NULL)
        {
            g_hModWinHttp = LoadLibraryEx(
                                "winhttp.dll",
                                NULL,
                                LOAD_LIBRARY_AS_DATAFILE
                                );
        }

        dwCount = FormatMessageW(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |    // allocate space for message
                    FORMAT_MESSAGE_IGNORE_INSERTS |     // don't expand printf tokens
                    FORMAT_MESSAGE_FROM_HMODULE,        // get message from module
                    g_hModWinHttp, 
                    dwError,
                    0,                                  // default language
                    (PWSTR)&pwszMessage,
                    0,                                  // allocate as much as necessary
                    NULL                                // no args
                    );
    }
    else
    {
        dwCount = FormatMessageW(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |    // allocate space for message
                    FORMAT_MESSAGE_IGNORE_INSERTS |     // don't expand printf tokens
                    FORMAT_MESSAGE_FROM_SYSTEM,         // get system message
                    NULL, 
                    dwError,
                    0,                                  // default language
                    (PWSTR)&pwszMessage,
                    0,                                  // allocate as much as necessary
                    NULL                                // no args
                    );
    }
    
    if (dwCount > 0 && pwszMessage != NULL)
        return pwszMessage;

    return L"\n";             
}

//
//  PrintMessage
//
//  Prints messages using localized strings from the resources 
//  of this application.
//
void
PrintMessage(
    IN  DWORD   dwMsg,
    ...
)
{
    va_list     pArg;
    PWSTR       pwszUnicode = NULL;
    PSTR        pszStr = NULL;
    DWORD       dwLen = 0;
    HANDLE      hOut;
    DWORD       dwBytesWritten;
    DWORD       fdwMode;

    va_start(pArg, dwMsg);

    dwLen = FormatMessageW(
                FORMAT_MESSAGE_ALLOCATE_BUFFER |    // allocate space for message and
                FORMAT_MESSAGE_FROM_HMODULE,        // get message from module and
                NULL,                               // NULL means this application
                dwMsg,
                0,                                  // default language
                (PWSTR)&pwszUnicode,
                0,                                  // allocate as much as necessary
                &pArg                               // args for printf inserts
                );

    va_end(pArg);

    if (dwLen == 0 || pwszUnicode == NULL)
        return;

    hOut = GetStdHandle(STD_OUTPUT_HANDLE);

    if ((GetFileType(hOut) & FILE_TYPE_CHAR) && GetConsoleMode(hOut, &fdwMode))
    {
        // output not redirected - output UNICODE to console directly
        
        WriteConsoleW(hOut, pwszUnicode, wcslen(pwszUnicode), &dwBytesWritten, 0);

    }
    else
    {

        // output redirected - convert to multi-byte and output to file
        
        dwLen = WideCharToMultiByte(
                    GetConsoleOutputCP(),
                    0, 
                    pwszUnicode,
                    -1,
                    NULL,
                    0,
                    NULL,
                    NULL);

        pszStr = new CHAR[dwLen];

        if (pszStr == NULL)
            return;

        dwLen = WideCharToMultiByte(
                    GetConsoleOutputCP(),
                    0,
                    pwszUnicode,
                    -1,
                    pszStr,
                    dwLen,
                    NULL,
                    NULL);

        WriteFile(hOut, pszStr, dwLen-1, &dwBytesWritten, 0);
        
        if (pszStr) delete [] pszStr;
    }

    return;
}


//
//  AnsiToWideChar 
//  
//  Used to convert command line input to UNICODE
//

DWORD
AnsiToWideChar(const char * pszA, LPWSTR * ppszW)
{
    DWORD cchW;

    *ppszW = NULL;

    if (!pszA)
        return ERROR_SUCCESS;

    // Determine how big the widechar string will be
    cchW = MultiByteToWideChar(CP_ACP, 0, pszA, -1, NULL, 0);

    *ppszW = new WCHAR[cchW];

    if (!*ppszW)
        return ERROR_NOT_ENOUGH_MEMORY;

    // now convert it
    cchW = MultiByteToWideChar(CP_ACP, 0, pszA, -1, *ppszW, cchW);

    return ERROR_SUCCESS;
}


typedef struct
{
    DWORD dwAccessType;      // see WINHTTP_ACCESS_* types below
    LPSTR lpszProxy;         // proxy server list
    LPSTR lpszProxyBypass;   // proxy bypass list
}
WINHTTP_PROXY_INFOA;


//  MigrateProxySettings is defined in ProxyMigrate.cxx
DWORD MigrateProxySettings (void);


/*

usage:

    proxycfg -?  : to view help information
    
    proxycfg     : to view current WinHTTP proxy settings
    
    proxycfg [-d] [-p <server-name> [<bypass-list>]]
    
        -d : set direct access       
        -p : set proxy server(s), and optional bypass list
        
    proxycfg -u  :  import proxy settings from current user's 
                    Microsoft Internet Explorer manual settings (in HKCU)

 */


enum ARGTYPE
{
    ARGS_HELP,
    ARGS_SET_PROXY_SETTINGS,
    ARGS_VIEW_PROXY_SETTINGS,
    ARGS_INITIALIZE_PROXY_SETTINGS, // updates from HKCU only if never init
    ARGS_MIGRATE_PROXY_SETTINGS     // forces update from HKCU
};


struct ARGS
{
    ARGTYPE Command;

    DWORD   Flags;
    char *  ProxyServer;
    char *  BypassList;
};

#define INTERNET_SETTINGS_KEY         L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"

static const WCHAR szRegPathConnections[] = INTERNET_SETTINGS_KEY L"\\Connections";


void ParseArguments(int argc, char ** argv, ARGS * Args)
{
    Args->Command = ARGS_VIEW_PROXY_SETTINGS;
    Args->Flags = WINHTTP_ACCESS_TYPE_NO_PROXY;
    Args->ProxyServer = NULL;
    Args->BypassList = NULL;

    if (argc == 0)
        return;

    for (;;)
    {
        if ((argv[0][0] != '-') || (lstrlen(argv[0]) != 2))
        {
            Args->Command = ARGS_HELP;
            goto Exit;
        }

        switch (tolower(argv[0][1]))
        {
        default:
            Args->Command = ARGS_HELP;
            goto Exit;

        case 'd':
            Args->Command = ARGS_SET_PROXY_SETTINGS;
            Args->Flags   = WINHTTP_ACCESS_TYPE_NO_PROXY;

            argc--;
            argv++; 

            if (argc == 0)
                goto Exit;

            continue;

        case 'i':
            Args->Command = ARGS_INITIALIZE_PROXY_SETTINGS;
            goto Exit;
            
        case 'p':
            argc--;
            argv++;

            if (argc == 0)
            {
                // error: no proxy specified
                Args->Command = ARGS_HELP;
            }
            else
            {
                Args->Command = ARGS_SET_PROXY_SETTINGS;
                Args->Flags  |= WINHTTP_ACCESS_TYPE_NAMED_PROXY;

                Args->ProxyServer = argv[0];

                argc--;
                argv++;

                if (argc >= 1)
                {
                    Args->BypassList = argv[0];
                }
            }
            goto Exit;

        case 'u':
            Args->Command = ARGS_MIGRATE_PROXY_SETTINGS;
            goto Exit;
            
        }
       
    }

Exit:
    return;
}


DWORD WriteProxySettings( WINHTTP_PROXY_INFOA * pInfo)
{
    DWORD       error = ERROR_SUCCESS;
    
    WINHTTP_PROXY_INFO proxyInfo;
    memset( &proxyInfo, 0, sizeof( proxyInfo));

    switch( pInfo->dwAccessType)
    {
    case WINHTTP_ACCESS_TYPE_NAMED_PROXY:
    case WINHTTP_ACCESS_TYPE_NO_PROXY:
        proxyInfo.dwAccessType = pInfo->dwAccessType;
        break;
    default:
        //  When migrating, we get some weird flags in dwAccessType.
        //  Be smart about guessing if there is a proxy or not.
        proxyInfo.dwAccessType = pInfo->lpszProxy != NULL
                                 ? WINHTTP_ACCESS_TYPE_NAMED_PROXY
                                 : WINHTTP_ACCESS_TYPE_NO_PROXY;
    }

    // we only support ANSI hostnames so only try to convert from ANSI to UNICODE
    
    if( NULL != pInfo->lpszProxy)
    {
        error = AnsiToWideChar( pInfo->lpszProxy, &proxyInfo.lpszProxy);
        if( error != ERROR_SUCCESS)
            goto quit;
    }

    if( NULL != pInfo->lpszProxyBypass)
    {
        error = AnsiToWideChar( pInfo->lpszProxyBypass, &proxyInfo.lpszProxyBypass);
        if( error != ERROR_SUCCESS)
            goto quit;
    }

    error = ERROR_SUCCESS;
    if( TRUE != WinHttpSetDefaultProxyConfiguration( &proxyInfo))
    {
        error = GetLastError();
    }

quit:
    if( proxyInfo.lpszProxy != NULL)
        delete[] proxyInfo.lpszProxy;

    if( proxyInfo.lpszProxyBypass != NULL)
        delete[] proxyInfo.lpszProxyBypass;
    
    return error;
}


DWORD SetProxySettings(DWORD Flags, char * ProxyServer, char * BypassList)
{
    WINHTTP_PROXY_INFOA     proxyInfo;
    DWORD                   error;
    LPWSTR                  pwszString = NULL;

    // initialize structure
    memset(&proxyInfo, 0, sizeof(proxyInfo));
    proxyInfo.dwAccessType = Flags;
    proxyInfo.lpszProxy = ProxyServer;
    proxyInfo.lpszProxyBypass = BypassList;

    error = WriteProxySettings(&proxyInfo);

    if (error != ERROR_SUCCESS)
    {
        pwszString = GetMessage(error);
        PrintMessage(MSG_ERROR_WRITING_PROXY_SETTINGS, error, 
                pwszString ? pwszString : L"");
        if (pwszString) LocalFree(pwszString);
    }
    else
    {
        PrintMessage(MSG_UPDATE_SUCCESS);
    }
    return error;
}


void ViewProxySettings()
{
    WINHTTP_PROXY_INFO      proxyInfo;
    DWORD                   error;
    PWSTR                   pwszString = NULL;

    if( TRUE != WinHttpGetDefaultProxyConfiguration( &proxyInfo))
    {
        error = GetLastError();
        pwszString = GetMessage(error);
        PrintMessage(MSG_ERROR_READING_PROXY_SETTINGS, error, 
            pwszString ? pwszString : L"");
        if (pwszString ) LocalFree(pwszString );

        return;
    }

    PrintMessage(MSG_CURRENT_SETTINGS_HEADER, szRegPathConnections);

    switch( proxyInfo.dwAccessType)
    {
    case WINHTTP_ACCESS_TYPE_NO_PROXY:      
        PrintMessage(MSG_DIRECT_ACCESS);

        break;
    case WINHTTP_ACCESS_TYPE_NAMED_PROXY:
        if( proxyInfo.lpszProxy != NULL)
            PrintMessage(MSG_PROXY_SERVERS, proxyInfo.lpszProxy);
        else
            PrintMessage(MSG_ERROR_PROXY_SERVER_MISSING);
        
        if( proxyInfo.lpszProxyBypass != NULL)
            PrintMessage(MSG_BYPASS_LIST, proxyInfo.lpszProxyBypass);
        else
            PrintMessage(MSG_BYPASS_LIST_NONE);

        break;
    default: 
        PrintMessage(MSG_UNKNOWN_PROXY_ACCESS_TYPE);
        break;
    }

    if( NULL != proxyInfo.lpszProxy)
        GlobalFree( proxyInfo.lpszProxy);
    if( NULL != proxyInfo.lpszProxyBypass)
        GlobalFree( proxyInfo.lpszProxyBypass);

}


int __cdecl main (int argc, char **argv)
{
    ARGS    Args;
    DWORD   dwErr;
    PWSTR   pwszString = NULL;

    PrintMessage(MSG_STARTUP_BANNER);
    PrintMessage(MSG_COPYRIGHT);
    
    // Discard program arg.
    argv++;
    argc--;

    ParseArguments(argc, argv, &Args);

    switch (Args.Command)
    {
    
    case ARGS_HELP:
    default:
        PrintMessage(MSG_USAGE);
        break;

    case ARGS_SET_PROXY_SETTINGS:

        SetProxySettings(Args.Flags, Args.ProxyServer, Args.BypassList);
        ViewProxySettings();
        break;

    case ARGS_INITIALIZE_PROXY_SETTINGS:
        // intentional fall through
    
    case ARGS_MIGRATE_PROXY_SETTINGS:
    
        dwErr = MigrateProxySettings();
        if (dwErr != ERROR_SUCCESS)
        {
            pwszString = GetMessage(dwErr);
            PrintMessage(MSG_MIGRATION_FAILED_WITH_ERROR, dwErr, 
                pwszString ? pwszString : L"");
            if (pwszString) LocalFree(pwszString);
            exit (dwErr);
        }
        ViewProxySettings();
        break;

    case ARGS_VIEW_PROXY_SETTINGS:
    
        ViewProxySettings();
        break;
    }

    MessageCleanup();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\sdk\tracecfg\tracecfg.cxx ===
// ===========================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 2001 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================

/*
WinHTTP Trace Configuration Tool
*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>
#include <wininet.h>

//
// private macros
//

#define REGOPENKEYEX(a, b, c, d, e) RegOpenKeyEx((a), (b), (c), (d), (e))

#define REGCREATEKEYEX(a, b, c, d, e, f, g, h, i) \
    RegCreateKeyEx((a), (b), (c), (d), (e), (f), (g), (h), (i))

#define REGCLOSEKEY(a)              RegCloseKey(a)

#define CASE_OF(constant)   case constant: return # constant

#define BASE_TRACE_KEY                      HKEY_LOCAL_MACHINE
#define TRACE_ENABLED_VARIABLE_NAME         "Enabled"
#define LOG_FILE_PREFIX_VARIABLE_NAME       "LogFilePrefix"
#define TO_FILE_OR_DEBUGGER_VARIABLE_NAME   "ToFileOrDebugger"
#define SHOWBYTES_VARIABLE_NAME             "ShowBytes"
#define SHOWAPITRACE_VARIABLE_NAME          "ShowApiTrace"
#define MAXFILESIZE_VARIABLE_NAME           "MaxFileSize"
#define MINFILESIZE                         65535

#define INTERNET_SETTINGS_KEY         "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
#define INTERNET_TRACE_SETTINGS_KEY INTERNET_SETTINGS_KEY "\\WinHttp\\Tracing"
#define SZREGVALUE_MAX  255

#if !defined(max)

#define max(a, b)   ((a)<(b)) ? (b) : (a)

#endif

#define OUTPUT_MESSAGE(Member, Value, DefaultValue)    if(Value != INVALID_VALUE) \
        fprintf(stdout, "    " #Member ": %d\n", Value);\
    else \
        fprintf(stdout, "    " #Member " -key not set- (default value: %d)\n", DefaultValue)

#define HANDLE_COMMON_SWITCH(Member, HigherBound)    \
            argc--; \
            argv++; \
                     \
            int Member; \
            /* TODO: atoi() will return zero for garbage too: */ \
            if (argc == 0 || (((Member = atoi(argv[0])), Member < 0) || Member > HigherBound)) \
            { \
                Args->Error = true; \
                goto Exit; \
            } \
            else \
            { \
                Args-> Member = Member; \
             } 


    
#define INVALID_VALUE   0xFFFFFFFF

//
// private prototypes
//

LPSTR InternetMapError(DWORD Error);

//
// private functions based on registry.cxx and notifctn.cxx:
//

DWORD
ReadTraceSettingsDwordKey(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );
DWORD
ReadTraceSettingsStringKey(
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
);

DWORD
WriteTraceSettingsDwordKey(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    );
DWORD WriteTraceSettingsStringKey(
    IN LPCSTR pszKey,
    IN LPSTR pszValue, 
    IN DWORD dwSize);


struct ARGS
{
    bool        Error;
    DWORD   TracingEnabled;
    char *  FileNamePrefix;
    DWORD   ToFileOrDebugger;
    DWORD   ShowBytes;
    DWORD   ShowApiTrace;
    DWORD   MaxFileSize;
    
    ARGS()  :   Error(false), TracingEnabled(INVALID_VALUE), FileNamePrefix(NULL), 
        ToFileOrDebugger(INVALID_VALUE), ShowBytes(INVALID_VALUE), ShowApiTrace(INVALID_VALUE), MaxFileSize(INVALID_VALUE)
    {
    }

    BOOL operator ==( ARGS &Args2)
    {
        if((this->Error == Args2.Error) && (this->TracingEnabled == Args2.TracingEnabled) && (this->FileNamePrefix == Args2.FileNamePrefix) 
            && (this->ToFileOrDebugger == Args2.ToFileOrDebugger) && (this->ShowBytes == Args2.ShowBytes) 
            && (this->ShowApiTrace == Args2.ShowApiTrace) && (this->MaxFileSize == Args2.MaxFileSize))
            return TRUE;
        return FALSE;
    }
};

void ParseArguments(int argc, char ** argv, ARGS * Args)
{
    if (argc == 0)
        return;

    while (argc && argv[0][0] == '-')
    {
        switch (tolower(argv[0][1]))
        {
        default:
            Args->Error = true;
            goto Exit;

        case 'e':
            HANDLE_COMMON_SWITCH(TracingEnabled, 1);
            break;

        case 'd':
            HANDLE_COMMON_SWITCH(ToFileOrDebugger, 2);
            break;

        case 's':
            HANDLE_COMMON_SWITCH(ShowBytes, 2);
            break;

        case 't':
            HANDLE_COMMON_SWITCH(ShowApiTrace, 1);
            break;

        case 'm':
            HANDLE_COMMON_SWITCH(MaxFileSize, INVALID_VALUE);
            Args->MaxFileSize = max(Args->MaxFileSize, MINFILESIZE);
            break;

        case 'l':
            argc--;
            argv++;

            if (argc == 0)
            {
                // error: no filename prefix specified
                Args->Error = true;
                goto Exit;
            }
            else
            {
                Args->FileNamePrefix = argv[0];
                if(!strcmp(argv[0], "*"))
                    // Blank out registry setting 
                    Args->FileNamePrefix = "";
            }
            break;
        }

        argv++;
        argc--;
    }

    if (argc > 0)
    {
        Args->Error = true;
        goto Exit;
    }

Exit:
    return;
}


void SetTraceSettings(ARGS Args)
{
    DWORD error;
    
    if((error = WriteTraceSettingsDwordKey(TRACE_ENABLED_VARIABLE_NAME, Args.TracingEnabled) ) == ERROR_SUCCESS 
        && (error = WriteTraceSettingsStringKey(LOG_FILE_PREFIX_VARIABLE_NAME, Args.FileNamePrefix, Args.FileNamePrefix? strlen(Args.FileNamePrefix) + 1: -1)) == ERROR_SUCCESS
        && (error = WriteTraceSettingsDwordKey(TO_FILE_OR_DEBUGGER_VARIABLE_NAME, Args.ToFileOrDebugger)) == ERROR_SUCCESS
        && (error = WriteTraceSettingsDwordKey(SHOWBYTES_VARIABLE_NAME, Args.ShowBytes)) == ERROR_SUCCESS
        && (error = WriteTraceSettingsDwordKey(SHOWAPITRACE_VARIABLE_NAME, Args.ShowApiTrace) ) == ERROR_SUCCESS
        && (error = WriteTraceSettingsDwordKey(MAXFILESIZE_VARIABLE_NAME, Args.MaxFileSize) ) == ERROR_SUCCESS)
    {
        fprintf(stderr, "Updated trace settings\n");
    }
    else
    {
        fprintf(stderr, "Error (%s) writing trace settings.\n", InternetMapError(error));
    }
}
void ViewTraceSettings()
{
    ARGS    Args;
    ReadTraceSettingsDwordKey(TRACE_ENABLED_VARIABLE_NAME, &(Args.TracingEnabled));
    char lpszFilenamePrefix[MAX_PATH + 1];
    DWORD dwDummy = sizeof(lpszFilenamePrefix) - 1;
    if(ReadTraceSettingsStringKey(LOG_FILE_PREFIX_VARIABLE_NAME, lpszFilenamePrefix, &dwDummy) == ERROR_SUCCESS)
    {
        Args.FileNamePrefix = lpszFilenamePrefix;
    }
    
    ReadTraceSettingsDwordKey(TO_FILE_OR_DEBUGGER_VARIABLE_NAME, &(Args.ToFileOrDebugger));
    ReadTraceSettingsDwordKey(SHOWBYTES_VARIABLE_NAME, &(Args.ShowBytes));
    ReadTraceSettingsDwordKey(SHOWAPITRACE_VARIABLE_NAME, &(Args.ShowApiTrace));
    ReadTraceSettingsDwordKey(MAXFILESIZE_VARIABLE_NAME, &(Args.MaxFileSize));

    ARGS    ArgsUntouched;
    if (Args == ArgsUntouched)
    {
        fprintf(stderr, "\nWinHttp trace configuration not set.\n");
        return;
    }

    fprintf(stdout, "\nCurrent WinHTTP trace settings under\n\n  HKEY_LOCAL_MACHINE\\\n    %s:\n\n", INTERNET_TRACE_SETTINGS_KEY);

    DWORD   TracingEnabled;
    char *  FileNamePrefix;
    DWORD   ToFileOrDebugger;
    DWORD   ShowBytes;
    DWORD   ShowApiTrace;
    DWORD   MaxFileSize;

    OUTPUT_MESSAGE(TracingEnabled, Args.TracingEnabled, 0);
    OUTPUT_MESSAGE(ToFileOrDebugger, Args.ToFileOrDebugger, 0);
    OUTPUT_MESSAGE(ShowBytes, Args.ShowBytes, 1);
    OUTPUT_MESSAGE(ShowApiTrace, Args.ShowApiTrace, 0);
    OUTPUT_MESSAGE(MaxFileSize, Args.MaxFileSize, MINFILESIZE);

    if(Args.FileNamePrefix != NULL)
        fprintf(stdout, "    FileNamePrefix: %s\n", Args.FileNamePrefix);
    else
        fprintf(stdout, "    FileNamePrefix -key not set- (default value: \"\")\n");
}


int __cdecl main (int argc, char **argv)
{
    ARGS    Args;
    DWORD dwErr;
    
    fprintf (stdout,
        "Microsoft (R) WinHTTP Tracing Facility Configuration Tool\n"
        "Copyright (C) Microsoft Corporation 2001.\n\n"
        );

    // Discard program arg.
    argv++;
    argc--;

    ParseArguments(argc, argv, &Args);

    if (Args.Error)
    {

        fprintf (stderr,
            "usage:\n"
            "    WinHttpTraceCfg -?  : to view help information\n"
            "    WinHttpTraceCfg     : to view current winhttp trace settings (in HKLM)\n"
            "    WinHttpTraceCfg    [-e <0|1>] [-l [log-file]] [-d <0|1>] [-s <0|1|2>]\n"
            "                       [-t <0|1>] [-m <MaxFileSize>]\n\n"
            "        -e : 1: enable tracing; 0: disable tracing\n"
            "        -l : [trace-file-prefix], i.e., \"C:\\Temp\\Test3\"; or simply: \"Test3\"\n"
            "        -d : 0: output to file; 1: output to debugger; 2: output to both\n"
            "        -s : 0: show HTTP headers only; 1: ANSI output; 2: Hex output\n"
            "        -t : 1: enable top-level API traces; 0: disable top-level API traces\n"
            "        -m : Maximum size the trace file can grow to\n"
            "");
    }
    else
    {
        if(argc)
            SetTraceSettings(Args);
        ViewTraceSettings();
    }

    return 0;
}        


LPSTR InternetMapError(DWORD Error)

/*++

Routine Description:

    Map error code to string. Try to get all errors that might ever be returned
    by an Internet function

Arguments:

    Error   - code to map

Return Value:

    LPSTR - pointer to symbolic error name

--*/

{
    switch (Error)
    {
    //
    // WINERROR errors
    //

    CASE_OF(ERROR_SUCCESS);
    CASE_OF(ERROR_INVALID_FUNCTION);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    //CASE_OF(WAIT_ABANDONED_0);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);
    //CASE_OF(STILL_ACTIVE);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);


    //
    // WININET errors
    //

    CASE_OF(ERROR_INTERNET_OUT_OF_HANDLES);
    CASE_OF(ERROR_INTERNET_TIMEOUT);
    CASE_OF(ERROR_INTERNET_EXTENDED_ERROR);
    CASE_OF(ERROR_INTERNET_INTERNAL_ERROR);
    CASE_OF(ERROR_INTERNET_INVALID_URL);
    CASE_OF(ERROR_INTERNET_UNRECOGNIZED_SCHEME);
    CASE_OF(ERROR_INTERNET_NAME_NOT_RESOLVED);
    CASE_OF(ERROR_INTERNET_PROTOCOL_NOT_FOUND);
    CASE_OF(ERROR_INTERNET_INVALID_OPTION);
    CASE_OF(ERROR_INTERNET_BAD_OPTION_LENGTH);
    CASE_OF(ERROR_INTERNET_OPTION_NOT_SETTABLE);
    CASE_OF(ERROR_INTERNET_SHUTDOWN);
    CASE_OF(ERROR_INTERNET_INCORRECT_USER_NAME);
    CASE_OF(ERROR_INTERNET_INCORRECT_PASSWORD);
    CASE_OF(ERROR_INTERNET_LOGIN_FAILURE);
    CASE_OF(ERROR_INTERNET_INVALID_OPERATION);
    CASE_OF(ERROR_INTERNET_OPERATION_CANCELLED);
    CASE_OF(ERROR_INTERNET_INCORRECT_HANDLE_TYPE);
    CASE_OF(ERROR_INTERNET_INCORRECT_HANDLE_STATE);
    CASE_OF(ERROR_INTERNET_NOT_PROXY_REQUEST);
    CASE_OF(ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND);
    CASE_OF(ERROR_INTERNET_BAD_REGISTRY_PARAMETER);
    CASE_OF(ERROR_INTERNET_NO_DIRECT_ACCESS);
    CASE_OF(ERROR_INTERNET_NO_CONTEXT);
    CASE_OF(ERROR_INTERNET_NO_CALLBACK);
    CASE_OF(ERROR_INTERNET_REQUEST_PENDING);
    CASE_OF(ERROR_INTERNET_INCORRECT_FORMAT);
    CASE_OF(ERROR_INTERNET_ITEM_NOT_FOUND);
    CASE_OF(ERROR_INTERNET_CANNOT_CONNECT);
    CASE_OF(ERROR_INTERNET_CONNECTION_ABORTED);
    CASE_OF(ERROR_INTERNET_CONNECTION_RESET);
    CASE_OF(ERROR_INTERNET_FORCE_RETRY);
    CASE_OF(ERROR_INTERNET_INVALID_PROXY_REQUEST);
    CASE_OF(ERROR_INTERNET_NEED_UI);
    CASE_OF(ERROR_INTERNET_HANDLE_EXISTS);
    CASE_OF(ERROR_INTERNET_SEC_CERT_DATE_INVALID);
    CASE_OF(ERROR_INTERNET_SEC_CERT_CN_INVALID);
    CASE_OF(ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR);
    CASE_OF(ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR);
    CASE_OF(ERROR_INTERNET_MIXED_SECURITY);
    CASE_OF(ERROR_INTERNET_CHG_POST_IS_NON_SECURE);
    CASE_OF(ERROR_INTERNET_POST_IS_NON_SECURE);
    CASE_OF(ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED);
    CASE_OF(ERROR_INTERNET_INVALID_CA);
    CASE_OF(ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP);
    CASE_OF(ERROR_INTERNET_ASYNC_THREAD_FAILED);
    CASE_OF(ERROR_INTERNET_REDIRECT_SCHEME_CHANGE);
    CASE_OF(ERROR_INTERNET_DIALOG_PENDING);
    CASE_OF(ERROR_INTERNET_RETRY_DIALOG);
    CASE_OF(ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR);
    CASE_OF(ERROR_INTERNET_INSERT_CDROM);
    CASE_OF(ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED);
    CASE_OF(ERROR_INTERNET_SEC_CERT_ERRORS);
    CASE_OF(ERROR_INTERNET_SECURITY_CHANNEL_ERROR);
    CASE_OF(ERROR_INTERNET_UNABLE_TO_CACHE_FILE);
    CASE_OF(ERROR_INTERNET_TCPIP_NOT_INSTALLED);
    CASE_OF(ERROR_INTERNET_SERVER_UNREACHABLE);
    CASE_OF(ERROR_INTERNET_PROXY_SERVER_UNREACHABLE);
    CASE_OF(ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT);
    CASE_OF(ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT);
    CASE_OF(ERROR_INTERNET_SEC_INVALID_CERT);
    CASE_OF(ERROR_INTERNET_SEC_CERT_REVOKED);
    CASE_OF(ERROR_INTERNET_FAILED_DUETOSECURITYCHECK);
    CASE_OF(ERROR_INTERNET_NOT_INITIALIZED);

    CASE_OF(ERROR_HTTP_HEADER_NOT_FOUND);
    CASE_OF(ERROR_HTTP_DOWNLEVEL_SERVER);
    CASE_OF(ERROR_HTTP_INVALID_SERVER_RESPONSE);
    CASE_OF(ERROR_HTTP_INVALID_HEADER);
    CASE_OF(ERROR_HTTP_INVALID_QUERY_REQUEST);
    CASE_OF(ERROR_HTTP_HEADER_ALREADY_EXISTS);
    CASE_OF(ERROR_HTTP_REDIRECT_FAILED);
    CASE_OF(ERROR_HTTP_NOT_REDIRECTED);
    CASE_OF(ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION);
    CASE_OF(ERROR_HTTP_COOKIE_DECLINED);
    CASE_OF(ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION);

    //
    // SSPI errors
    //

    CASE_OF(SEC_E_INSUFFICIENT_MEMORY);
    CASE_OF(SEC_E_INVALID_HANDLE);
    CASE_OF(SEC_E_UNSUPPORTED_FUNCTION);
    CASE_OF(SEC_E_TARGET_UNKNOWN);
    CASE_OF(SEC_E_INTERNAL_ERROR);
    CASE_OF(SEC_E_SECPKG_NOT_FOUND);
    CASE_OF(SEC_E_NOT_OWNER);
    CASE_OF(SEC_E_CANNOT_INSTALL);
    CASE_OF(SEC_E_INVALID_TOKEN);
    CASE_OF(SEC_E_CANNOT_PACK);
    CASE_OF(SEC_E_QOP_NOT_SUPPORTED);
    CASE_OF(SEC_E_NO_IMPERSONATION);
    CASE_OF(SEC_E_LOGON_DENIED);
    CASE_OF(SEC_E_UNKNOWN_CREDENTIALS);
    CASE_OF(SEC_E_NO_CREDENTIALS);
    CASE_OF(SEC_E_MESSAGE_ALTERED);
    CASE_OF(SEC_E_OUT_OF_SEQUENCE);
    CASE_OF(SEC_E_NO_AUTHENTICATING_AUTHORITY);
    CASE_OF(SEC_I_CONTINUE_NEEDED);
    CASE_OF(SEC_I_COMPLETE_NEEDED);
    CASE_OF(SEC_I_COMPLETE_AND_CONTINUE);
    CASE_OF(SEC_I_LOCAL_LOGON);
    CASE_OF(SEC_E_BAD_PKGID);
    CASE_OF(SEC_E_CONTEXT_EXPIRED);
    CASE_OF(SEC_E_INCOMPLETE_MESSAGE);


    //
    // WINSOCK errors
    //

    CASE_OF(WSAEINTR);
    CASE_OF(WSAEBADF);
    CASE_OF(WSAEACCES);
    CASE_OF(WSAEFAULT);
    CASE_OF(WSAEINVAL);
    CASE_OF(WSAEMFILE);
    CASE_OF(WSAEWOULDBLOCK);
    CASE_OF(WSAEINPROGRESS);
    CASE_OF(WSAEALREADY);
    CASE_OF(WSAENOTSOCK);
    CASE_OF(WSAEDESTADDRREQ);
    CASE_OF(WSAEMSGSIZE);
    CASE_OF(WSAEPROTOTYPE);
    CASE_OF(WSAENOPROTOOPT);
    CASE_OF(WSAEPROTONOSUPPORT);
    CASE_OF(WSAESOCKTNOSUPPORT);
    CASE_OF(WSAEOPNOTSUPP);
    CASE_OF(WSAEPFNOSUPPORT);
    CASE_OF(WSAEAFNOSUPPORT);
    CASE_OF(WSAEADDRINUSE);
    CASE_OF(WSAEADDRNOTAVAIL);
    CASE_OF(WSAENETDOWN);
    CASE_OF(WSAENETUNREACH);
    CASE_OF(WSAENETRESET);
    CASE_OF(WSAECONNABORTED);
    CASE_OF(WSAECONNRESET);
    CASE_OF(WSAENOBUFS);
    CASE_OF(WSAEISCONN);
    CASE_OF(WSAENOTCONN);
    CASE_OF(WSAESHUTDOWN);
    CASE_OF(WSAETOOMANYREFS);
    CASE_OF(WSAETIMEDOUT);
    CASE_OF(WSAECONNREFUSED);
    CASE_OF(WSAELOOP);
    CASE_OF(WSAENAMETOOLONG);
    CASE_OF(WSAEHOSTDOWN);
    CASE_OF(WSAEHOSTUNREACH);
    CASE_OF(WSAENOTEMPTY);
    CASE_OF(WSAEPROCLIM);
    CASE_OF(WSAEUSERS);
    CASE_OF(WSAEDQUOT);
    CASE_OF(WSAESTALE);
    CASE_OF(WSAEREMOTE);
    CASE_OF(WSAEDISCON);
    CASE_OF(WSASYSNOTREADY);
    CASE_OF(WSAVERNOTSUPPORTED);
    CASE_OF(WSANOTINITIALISED);
    CASE_OF(WSAHOST_NOT_FOUND);
    CASE_OF(WSATRY_AGAIN);
    CASE_OF(WSANO_RECOVERY);
    CASE_OF(WSANO_DATA);

    default:
        return "?";
    }
}

//
// private functions based on registry.cxx and notifctn.cxx:
//

DWORD
ReadRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

{
    DWORD error;
    DWORD valueLength;
    DWORD valueType;
    DWORD value;

    valueLength = sizeof(*ParameterValue);
    error = (DWORD)RegQueryValueEx(Key,
                                   ParameterName,
                                   NULL, // reserved
                                   &valueType,
                                   (LPBYTE)&value,
                                   &valueLength
                                   );

    //
    // if the size or type aren't correct then return an error, else only if
    // success was returned do we modify *ParameterValue
    //

    if (error == ERROR_SUCCESS) {
        if (((valueType != REG_DWORD)
        && (valueType != REG_BINARY))
        || (valueLength != sizeof(DWORD))) {

            error = ERROR_PATH_NOT_FOUND;
        } else {
            *ParameterValue = value;
        }
    }
    return error;
}

DWORD
ReadTraceSettingsDwordKey(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

{
    HKEY ParameterKey = BASE_TRACE_KEY;
    LPCSTR keyToReadFrom = INTERNET_TRACE_SETTINGS_KEY;
    HKEY clientKey;
    
    DWORD error = ERROR_SUCCESS;
    error = REGOPENKEYEX(ParameterKey,
                         keyToReadFrom,
                         0, // reserved
                         KEY_QUERY_VALUE,
                         &clientKey
                         );
    if (error == ERROR_SUCCESS) {
        error = ReadRegistryDword(clientKey,
                                  ParameterName,
                                  ParameterValue
                                  );
        REGCLOSEKEY(clientKey);
    }

    return error;
}

DWORD
ReadRegistryOemString(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPSTR String,
    IN OUT LPDWORD Length
    )
{
    LONG error;
    DWORD valueType;
    LPSTR str;
    DWORD valueLength;

    //
    // first, get the length of the string
    //

    valueLength = *Length;
    error = RegQueryValueEx(Key,
                            ParameterName,
                            NULL, // reserved
                            &valueType,
                            (LPBYTE)String,
                            &valueLength
                            );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // we only support REG_SZ (single string) values in this function
    //

    if (valueType != REG_SZ) {
        error = ERROR_PATH_NOT_FOUND;
        goto quit;
    }

    //
    // if 1 or 0 chars returned then the string is empty
    //

    if (valueLength <= sizeof(char)) {
        error = ERROR_PATH_NOT_FOUND;
        goto quit;
    }

    //
    // convert the ANSI string to OEM character set in place. According to Win
    // help, this always succeeds
    //

    CharToOem(String, String);

    //
    // return the length as if returned from strlen() (i.e. drop the '\0')
    //

    *Length = valueLength - sizeof(char);

quit:

    return error;
}


DWORD
ReadTraceSettingsStringKey(
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
)
{
    HKEY ParameterKey = BASE_TRACE_KEY;
    LPCSTR keyToReadFrom = INTERNET_TRACE_SETTINGS_KEY;
    HKEY clientKey;
    
    //
    // zero-terminate the string
    //

    if (*ParameterLength > 0) {
        *ParameterValue = '\0';
    }

    DWORD error = ERROR_SUCCESS;
    error = REGOPENKEYEX(ParameterKey,
                         keyToReadFrom,
                         0, // reserved
                         KEY_QUERY_VALUE,
                         &clientKey
                         );
    if (error == ERROR_SUCCESS) {
        error = ReadRegistryOemString(clientKey,
                                      ParameterName,
                                      ParameterValue,
                                      ParameterLength
                                      );
        REGCLOSEKEY(clientKey);
    }

    return error;
}

DWORD
WriteTraceSettingsDwordKey(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )
{
    DWORD error;
    DWORD valueLength;
    DWORD valueType;
    DWORD value;

    if(ParameterValue == INVALID_VALUE)
        return ERROR_SUCCESS;
    
    LPCSTR keyToReadFrom = INTERNET_TRACE_SETTINGS_KEY;
    HKEY hKey = NULL;

    DWORD dwDisposition;
    if ((error = REGCREATEKEYEX(BASE_TRACE_KEY, keyToReadFrom, 0, NULL, 0, KEY_SET_VALUE,NULL, &hKey,&dwDisposition)) == ERROR_SUCCESS)
    {
        valueLength = sizeof(ParameterValue);
        valueType   = REG_DWORD;
        value       = ParameterValue;

        error = (DWORD)RegSetValueEx(hKey,
                                     ParameterName,
                                     NULL, // reserved
                                     valueType,
                                     (LPBYTE)&value,
                                     valueLength
                                     );
        REGCLOSEKEY(hKey);
    }

    return error;
}

DWORD WriteTraceSettingsStringKey(
    IN LPCSTR pszKey,
    IN LPSTR pszValue, 
    IN DWORD dwSize)
{
    LPCSTR keyToReadFrom = INTERNET_TRACE_SETTINGS_KEY;
    DWORD dwError;
    DWORD dwDisposition;

    if(pszValue == NULL)
        return ERROR_SUCCESS;
    
    HKEY hKey = NULL;
    char szValue[SZREGVALUE_MAX];
    DWORD dwValueLen = SZREGVALUE_MAX;

    if ((dwError = RegCreateKeyEx(BASE_TRACE_KEY, keyToReadFrom, 0, NULL, 0, KEY_SET_VALUE,NULL, &hKey,&dwDisposition)) == ERROR_SUCCESS)
    {
        dwError = RegSetValueEx(hKey, pszKey, NULL, REG_SZ,(const BYTE *)pszValue, dwSize);
        REGCLOSEKEY(hKey);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\test\httpauth.cxx ===
// ===========================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1996 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>
#include <winhttp.h>
#define _UNICODE 
#include <tchar.h>

//==============================================================================
BOOL NeedAuth (HINTERNET hRequest, DWORD dwStatus)
{
    // Look for 401 or 407.
    DWORD dwFlags;
    switch (dwStatus)
    {
        case HTTP_STATUS_DENIED:
            dwFlags = WINHTTP_QUERY_WWW_AUTHENTICATE;
            break;
        case HTTP_STATUS_PROXY_AUTH_REQ:
            dwFlags = WINHTTP_QUERY_PROXY_AUTHENTICATE;
            break;            
        default:
            return FALSE;
    }

    // Enumerate the authentication types.
    BOOL fRet;
    char szScheme[64];
    DWORD dwIndex = 0;
    do
    {
        DWORD cbScheme = sizeof(szScheme);
        fRet = WinHttpQueryHeaders
            (hRequest, dwFlags, NULL, szScheme, &cbScheme, &dwIndex);
        if (fRet)
            fprintf (stderr, "Found auth scheme: %s\n", szScheme);
    }
        while (fRet);

    return TRUE;
}

//==============================================================================
BOOL PromptForCreds (HINTERNET hRequest, DWORD dwTarget, LPVOID pAuthParams)
{
    DWORD dwScheme = 0;
    
    char szScheme[16];
    
    fprintf (stderr, "Enter Scheme : ");
    if (!fscanf (stdin, "%s", szScheme))
        return FALSE;
    if (!_stricmp(szScheme, "Basic"))
    {
        dwScheme = WINHTTP_AUTH_SCHEME_BASIC;
    }
    else if (!_stricmp(szScheme, "Digest"))
    {
        dwScheme = WINHTTP_AUTH_SCHEME_DIGEST;
    }
    else if (!_stricmp(szScheme, "NTLM"))
    {
        dwScheme = WINHTTP_AUTH_SCHEME_NTLM;
    }
    else if (!_stricmp(szScheme, "Negotiate"))
    {
        dwScheme = WINHTTP_AUTH_SCHEME_NEGOTIATE;
    }
    else if (!_stricmp(szScheme, "Passport1.4"))
    {
        dwScheme = WINHTTP_AUTH_SCHEME_PASSPORT;
    }
    else
    {
        return FALSE;
    }
    
    // Prompt username and password.
    
	char szUser[64], szPass[64];
	PWCHAR pwszUser = NULL;
    WCHAR wszUser[128];
	PWCHAR pwszPass = NULL;
    WCHAR wszPass[128];
    
	fprintf (stderr, "Enter Username: ");
    if (!fscanf (stdin, "%s", szUser))
        return FALSE;

	if (_stricmp(szUser, "default"))
    {
		::MultiByteToWideChar(CP_ACP, 0, szUser,   -1, &wszUser[0], 128);
		pwszUser = &wszUser[0];
		
		fprintf (stderr, "Enter Password: ");
		if (!fscanf (stdin, "%s", szPass))
			return FALSE;
	
		::MultiByteToWideChar(CP_ACP, 0, szPass,   -1, &wszPass[0], 128);
		pwszPass = &wszPass[0];
	}


    DWORD dw_ret = WinHttpSetCredentials(hRequest, 
                                            dwTarget, dwScheme, 
                                            pwszUser, pwszPass, pAuthParams);

    return dw_ret;
}

//==============================================================================
DWORD DoCustomUI (HINTERNET hRequest, BOOL fProxy)
{
    // Prompt for username and password.
    char  szUser[64], szPass[64];
    fprintf (stderr, "Enter Username: ");
    if (!fscanf (stdin, "%s", szUser))
        return ERROR_WINHTTP_LOGIN_FAILURE;
    
	if (!_stricmp(szUser, "default"))
    {
		return ERROR_WINHTTP_RESEND_REQUEST;
	}
	
	fprintf (stderr, "Enter Password: ");
    if (!fscanf (stdin, "%s", szPass))
        return ERROR_WINHTTP_LOGIN_FAILURE;

    WCHAR  wszUser[128], wszPass[128];
    ::MultiByteToWideChar(CP_ACP, 0, szUser,   -1, &wszUser[0], 128);
    ::MultiByteToWideChar(CP_ACP, 0, szPass,   -1, &wszPass[0], 128);

    // Set the values in the handle.
    if (fProxy)
    {
        WinHttpSetOption
            (hRequest, WINHTTP_OPTION_PROXY_USERNAME, wszUser, sizeof(wszUser));
        WinHttpSetOption
            (hRequest, WINHTTP_OPTION_PROXY_PASSWORD, wszPass, sizeof(wszPass));
    }
    else
    {
        WinHttpSetOption
            (hRequest, WINHTTP_OPTION_USERNAME, wszUser, sizeof(wszUser));
        WinHttpSetOption
            (hRequest, WINHTTP_OPTION_PASSWORD, wszPass, sizeof(wszPass));
    }
    
    return ERROR_WINHTTP_RESEND_REQUEST;
}


//==============================================================================
int RequestLoop (int argc, char **argv)
{
    HINTERNET hInternet = NULL;
    HINTERNET hConnect  = NULL;
    HINTERNET hRequest  = NULL;

    DWORD   dwAccessType   = WINHTTP_ACCESS_TYPE_DEFAULT_PROXY;
    WCHAR   szProxyServer[256];
    WCHAR   szProxyBypass[256];

    DWORD dwConnectFlags = 0;
    BOOL fPreAuth = FALSE;

    PSTR pPostData = NULL;
    DWORD cbPostData = 0;
    
    PSTR pszErr = NULL;
    BOOL fRet;
    DWORD dwErr = ERROR_SUCCESS;

    DWORD dwTarget = WINHTTP_AUTH_TARGET_SERVER;
    LPVOID pAuthParams = NULL;

    
#define CHECK_ERROR(cond, err) if (!(cond)) {pszErr=(err); goto done;}

    // Parse options.
    while (argc && argv[0][0] == '-')
    {
        switch (tolower(argv[0][1]))
        {
            case 'p':
                dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
                dwTarget = WINHTTP_AUTH_TARGET_PROXY;
                ::MultiByteToWideChar(CP_ACP, 0, argv[1],   -1, &szProxyServer[0], 256);
                // pszProxyServer = argv[1];
                ::MultiByteToWideChar(CP_ACP, 0, "<local>", -1, &szProxyBypass[0], 256);
                // pszProxyBypass = "<local>";
                argv++;
                argc--;
                break;

            case 's':
                dwConnectFlags = WINHTTP_FLAG_SECURE;
                break;

            case 'a':
                fPreAuth = TRUE;
                break;

            default:
                fprintf (stderr, "\nUsage: httpauth [-p <proxy>] [-s] <server> [<object> [<user> [<pass> [<POST-file>]]]]");
                fprintf (stderr, "\n  -s: Secure connection (ssl or pct)");
                fprintf (stderr, "\n  -p: specify proxy server. (\"<local>\" assumed for bypass.)");
                exit (1);
        }
        
        argv++;
        argc--;
    }

    // Parse host:port
    PSTR pszHost     = argv[0];
    DWORD dwPort;
    PSTR pszColon = strchr(pszHost, ':');
    if (!pszColon)
        dwPort = INTERNET_DEFAULT_PORT;
    else
    {
        *pszColon++ = 0;
        dwPort = atol (pszColon);
    }

    PSTR pszObject   = argc >= 2 ? argv[1] : "/";
    PSTR pszPostFile = argc >= 3 ? argv[2] : NULL;

    // Read any POST data into a buffer.
    if (pszPostFile)
    {
        HANDLE hf =
            CreateFile
            (
                pszPostFile,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
            );
        if (hf != INVALID_HANDLE_VALUE)
        {
            cbPostData = GetFileSize (hf, NULL);
            pPostData = (PSTR) LocalAlloc (LMEM_FIXED, cbPostData + 1);
            if (pPostData)
                ReadFile (hf, pPostData, cbPostData, &cbPostData, NULL);
            pPostData[cbPostData] = 0;
            CloseHandle (hf);
        }
    }

    // Initialize wininet.
    hInternet = WinHttpOpen
    (
        _T("HttpAuth Sample"),            // user agent
        // "Mozilla/4.0 (compatible; MSIE 4.0b2; Windows 95",
        dwAccessType,                 // access type
        NULL, // szProxyServer,               // proxy server
        NULL, // szProxyBypass,               // proxy bypass
        0                             // flags
    );
    CHECK_ERROR (hInternet, "WinHttpOpen");


    WCHAR szHost[256];
    ::MultiByteToWideChar(CP_ACP, 0, pszHost,   -1, &szHost[0], 256);

    // Connect to host.
    hConnect = WinHttpConnect
    (
        hInternet,                    // session handle,
        szHost,                      // host
        (INTERNET_PORT) dwPort,       // port
        0                // flags
    );
    CHECK_ERROR (hConnect, "WinHttpConnect");

    WCHAR szObject[256];
    ::MultiByteToWideChar(CP_ACP, 0, pszObject,   -1, &szObject[0], 256);

    // Create request.
    hRequest = WinHttpOpenRequest
    (
        hConnect,                     // connect handle
        pszPostFile? _T("POST") : _T("GET"),  // request method
        szObject,                    // object name
        NULL,                         // version
        NULL,                         // referer
        NULL,                         // accept types
        dwConnectFlags                // flags
    );
    CHECK_ERROR (hRequest, "WinHttpOpenRequest");
    
    if (fPreAuth)
    {
        fprintf (stderr, "Pre Authenticating...\n"); 
        fprintf (stderr, "(Scheme = Basic, Digest, NTLM, Negotiate, or Passport1.4)\n"); 
        PromptForCreds(hRequest, dwTarget, pAuthParams);
    }

resend:

    // Send request.
    fRet = WinHttpSendRequest
    (
        hRequest,                     // request handle
        _T(""),                       // header string
        0,                            // header length
        pPostData,                    // post data
        cbPostData,                   // post data length
        cbPostData,                   // total post length
        0                             // context
    );

    if (!fRet)
    {
        dwErr = GetLastError();
        switch (dwErr)
        {
            case ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED:
                break;
                
            default:
                printf ("HttpSendRequest failed err=%d\n", dwErr);
        }
        goto done;
    }
    else
    {
        fRet = WinHttpReceiveResponse(hRequest, NULL);
        if (!fRet)
        {
            dwErr = GetLastError();
            fprintf (stderr, "WinHttpReceiveResponse failed err=%d\n", dwErr);
            // pContext->state = HTTP_SEND_FAIL_SYNC;
        }
        // goto sync;
    }

    // Get status code.
    DWORD dwStatus, cbStatus;
    cbStatus = sizeof(dwStatus);
    WinHttpQueryHeaders
    (
        hRequest,
        WINHTTP_QUERY_FLAG_NUMBER | WINHTTP_QUERY_STATUS_CODE,
        WINHTTP_HEADER_NAME_BY_INDEX,
        &dwStatus,
        &cbStatus,
        NULL
    );
    fprintf (stderr, "Status: %d\n", dwStatus);

    // Check if the status code is 401 or 407
    if (NeedAuth (hRequest, dwStatus))
    {
        char szChoice[16];

        fprintf (stderr, "Set Credentials or Set Options? (C/O): ");
        if (!fscanf (stdin, "%s", szChoice))
            return FALSE;

        if (!_stricmp(szChoice, "C"))
        {
            DWORD AllSchemes;
            DWORD GoodScheme;
            DWORD AuthTarget;
            if (WinHttpQueryAuthSchemes(hRequest, &AllSchemes, &GoodScheme, &AuthTarget) != FALSE)
            {
                fprintf (stderr, "Proposed Schemes -> ");
                if (AllSchemes & WINHTTP_AUTH_SCHEME_BASIC)
                {
                    fprintf (stderr, "Basic ");
                }
                if (AllSchemes & WINHTTP_AUTH_SCHEME_DIGEST)
                {
                    fprintf (stderr, "Digest ");
                }
                if (AllSchemes & WINHTTP_AUTH_SCHEME_NTLM)
                {
                    fprintf (stderr, "NTLM ");
                }
                if (AllSchemes & WINHTTP_AUTH_SCHEME_NEGOTIATE)
                {
                    fprintf (stderr, "Negotiate ");
                }
                if (AllSchemes & WINHTTP_AUTH_SCHEME_PASSPORT)
                {
                    fprintf (stderr, "Passport1.4 ");
                }
            
                fprintf (stderr, "\n");
            
                fprintf (stderr, "Preferred Schemes -> ");
                if (GoodScheme == WINHTTP_AUTH_SCHEME_BASIC)
                {
                    fprintf (stderr, "Basic ");
                }
                else if (GoodScheme == WINHTTP_AUTH_SCHEME_DIGEST)
                {
                    fprintf (stderr, "Digest ");
                }
                else if (GoodScheme == WINHTTP_AUTH_SCHEME_NTLM)
                {
                    fprintf (stderr, "NTLM ");
                }
                else if (GoodScheme == WINHTTP_AUTH_SCHEME_NEGOTIATE)
                {
                    fprintf (stderr, "Negotiate ");
                }
                else if (GoodScheme == WINHTTP_AUTH_SCHEME_PASSPORT)
                {
                    fprintf (stderr, "Passport1.4 ");
                }
                else
                {
                    fprintf (stderr, "*Unknown* ");
                }
            
                fprintf (stderr, "\n");

                fprintf (stderr, "Auth Target -> ");
                if (AuthTarget == WINHTTP_AUTH_TARGET_PROXY)
                {
                    fprintf (stderr, "Proxy ");
                }
                else if (AuthTarget == WINHTTP_AUTH_TARGET_SERVER)
                {
                    fprintf (stderr, "Server ");
                }
                else
                {
                    fprintf (stderr, "*Unknown* ");
                }
            
                fprintf (stderr, "\n");

                // WinHttpQueryAuthParams(hRequest, GoodScheme, &pAuthParams);

                if (PromptForCreds(hRequest, AuthTarget, pAuthParams) != FALSE)
                    goto resend;
            }
        }
        else
        {
            fprintf (stderr, "*You are using legacy WinHttp functionalities!*\n");
            
            // Prompt for username and password.
            if (DoCustomUI (hRequest, dwStatus != HTTP_STATUS_DENIED))
                goto resend;
        }
    }

    // Dump some bytes.
    BYTE bBuf[1024];
    DWORD cbBuf;
    DWORD cbRead;
    _setmode( _fileno( stdout ), _O_BINARY );

// #define QDA
#ifdef QDA
    while (WinHttpQueryDataAvailable (hRequest, &cbRead) && cbRead)
    {
        cbBuf = cbRead > sizeof(bBuf)? sizeof(bBuf) : cbRead;
        WinHttpReadData(hRequest, bBuf, cbRead, &cbRead);
        fwrite (bBuf, 1, cbRead, stdout);
    }
#else
    cbBuf = sizeof(bBuf);
    while (WinHttpReadData (hRequest, bBuf, cbBuf, &cbRead) && cbRead)
        fwrite (bBuf, 1, cbRead, stdout);
#endif

done: // Clean up.

    if (pszErr)
        fprintf (stderr, "Failed on %s, last error %d\n", pszErr, GetLastError());
    if (hRequest)
        WinHttpCloseHandle (hRequest);
    if (hConnect)
        WinHttpCloseHandle (hConnect);
    if (hInternet)
        WinHttpCloseHandle (hInternet);
    if (pPostData)
        LocalFree (pPostData);
    return 0;
}

//==============================================================================
void ParseArguments 
(
    LPSTR  InBuffer,
    LPSTR* CArgv,
    DWORD* CArgc
)
{
    LPSTR CurrentPtr = InBuffer;
    DWORD i = 0;
    DWORD Cnt = 0;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr == ' ' ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        CArgv[i++] = CurrentPtr;

        //
        // go to next space.
        //

        while(  (*CurrentPtr != '\0') &&
                (*CurrentPtr != '\n') ) {
            if( *CurrentPtr == '"' ) {      // Deal with simple quoted args
                if( Cnt == 0 )
                    CArgv[i-1] = ++CurrentPtr;  // Set arg to after quote
                else
                    *CurrentPtr = '\0';     // Remove end quote
                Cnt = !Cnt;
            }
            if( (Cnt == 0) && (*CurrentPtr == ' ') ||   // If we hit a space and no quotes yet we are done with this arg
                (*CurrentPtr == '\0') )
                break;
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        *CurrentPtr++ = '\0';
    }

    *CArgc = i;
    return;
}

//==============================================================================
int __cdecl main (int argc, char **argv)
{
	char * port    ;
	// Discard program arg.
    argv++;
    argc--;

    if (argc)
        RequestLoop (argc, argv);
        
    else // Enter command prompt loop
    {
        fprintf (stderr, "\nUsage: [-p <proxy>] [-s] <host>[:port] [<object> [<POST-file>]]");
        fprintf (stderr, "\n  -s: use secure sockets layer");
        fprintf (stderr, "\n  -p: specify proxy server. (\"<local>\" assumed for bypass.)");
        fprintf (stderr, "\nTo exit input loop, enter no params");

        while (1)
        {
            char szIn[1024];
            DWORD argcIn;
            LPSTR argvIn[10];

            fprintf (stderr, "\nhttpauth> ");
            gets (szIn);
            
            argcIn = 0;
            ParseArguments (szIn, argvIn, &argcIn);
            if (!argcIn)
                break;
            RequestLoop (argcIn, argvIn);
        }                
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\test\httprequest.cxx ===
// ===========================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1996 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>

#include <ocidl.h>
#include <httprequest.h>



typedef HRESULT (__stdcall * PFNINTERNETCREATEHTTPREQUESTCOMPONENT)(REFIID riid, void ** ppvObject);

PFNINTERNETCREATEHTTPREQUESTCOMPONENT g_pfnInternetCreateHttpRequestComponent;


/**
 * Helper to create a char safearray from a string
 */
HRESULT
CreateVector(VARIANT * pVar, const BYTE * pData, LONG cElems)
{
    HRESULT hr;
    BYTE * pB;

    SAFEARRAY * psa = SafeArrayCreateVector(VT_UI1, 0, (unsigned int)cElems);
    if (!psa)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = SafeArrayAccessData(psa, (void **)&pB);
    if (hr)
        goto Error;

    memcpy(pB, pData, cElems);

    SafeArrayUnaccessData(psa);
    V_ARRAY(pVar) = psa;
    pVar->vt = VT_ARRAY | VT_UI1;

Cleanup:
    return hr;

Error:
    if (psa)
        SafeArrayDestroy(psa);
    goto Cleanup;
}

/*
 *  AsciiToBSTR
 *
 *  Purpose:
 *      Convert an ascii string to a BSTR
 *
 */

HRESULT 
AsciiToBSTR(BSTR * pbstr, char * sz, int cch)
{
    int cwch;

    // Determine how big the ascii string will be
    cwch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, sz, cch,
                                NULL, 0);

    *pbstr = SysAllocStringLen(NULL, cwch);

    if (!*pbstr)
        return E_OUTOFMEMORY;

    cch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, sz, cch,
                                *pbstr, cwch);

    return S_OK;
}


//==============================================================================
int RequestLoop (int argc, char **argv)
{
    IWinHttpRequest *  pIWinHttpRequest = NULL;

    BSTR            bstrMethod = NULL;
    BSTR            bstrUrl = NULL;
    BSTR            bstrStatus = NULL;
    BSTR            bstrResponse = NULL;
    VARIANT         varFalse;
    VARIANT         varEmpty;
    VARIANT         varPostData;
    long            lStatus;
    
    HRESULT         hr = NOERROR;
    CLSID           clsid;

    PSTR            pPostData = NULL;
    DWORD           cbPostData = 0;
    
    VariantInit(&varFalse);
    V_VT(&varFalse)   = VT_BOOL;
    V_BOOL(&varFalse) = VARIANT_FALSE;

    VariantInit(&varEmpty);
    V_VT(&varEmpty) = VT_ERROR;

    VariantInit(&varPostData);

    // Get host:port
    PSTR pszHostAndObject = argv[0];
    PSTR pszObject   = argc >= 2 ? argv[1] : "/";
    PSTR pszPostFile = argc >= 3 ? argv[2] : NULL;

    // Read any POST data into a buffer.
    if (pszPostFile)
    {
        HANDLE hf =
            CreateFile
            (
                pszPostFile,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
            );
        if (hf != INVALID_HANDLE_VALUE)
        {
            cbPostData = GetFileSize (hf, NULL);
            pPostData = (PSTR) LocalAlloc (LMEM_FIXED, cbPostData + 1);
            if (pPostData)
                ReadFile (hf, pPostData, cbPostData, &cbPostData, NULL);
            pPostData[cbPostData] = 0;
            CloseHandle (hf);

            hr = CreateVector(&varPostData, (const BYTE *)pPostData, cbPostData);
        }
    }

    bstrMethod = SysAllocString(pszPostFile? L"POST" : L"GET");

    if (!bstrMethod)
        goto Exit;

    hr = AsciiToBSTR(&bstrUrl, pszHostAndObject, strlen(pszHostAndObject));

    if (SUCCEEDED(hr))
    {
        hr = CLSIDFromProgID(L"WinHttp.WinHttpRequest.5", &clsid);
    }

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IWinHttpRequest, (void **)&pIWinHttpRequest);

    }

    if (SUCCEEDED(hr))
    {
        hr = pIWinHttpRequest->SetProxy(HTTPREQUEST_PROXYSETTING_PRECONFIG, varEmpty, varEmpty);
    }

    if (SUCCEEDED(hr))
    {
        hr = pIWinHttpRequest->Open(bstrMethod, bstrUrl);
    }

    if (SUCCEEDED(hr))
    {
        hr = pIWinHttpRequest->Send(varPostData);
    }


    if (SUCCEEDED(hr))
    {
        hr = pIWinHttpRequest->get_Status(&lStatus);
    }

    if (SUCCEEDED(hr))
    {
        hr = pIWinHttpRequest->get_StatusText(&bstrStatus);
    }

    if (SUCCEEDED(hr))
    {
        fwprintf (stderr, L"Status: %d %s\n", lStatus, bstrStatus);

        hr = pIWinHttpRequest->get_ResponseText(&bstrResponse);
    }

    if (SUCCEEDED(hr))
    {
        fputws (bstrResponse, stdout);
    }
    
Exit:
    VariantClear(&varPostData);

    if (pPostData)
        LocalFree (pPostData);

    if (pIWinHttpRequest)
        pIWinHttpRequest->Release();

    if (bstrMethod)
        SysFreeString(bstrMethod);
    if (bstrUrl)
        SysFreeString(bstrUrl);
    if (bstrStatus)
        SysFreeString(bstrStatus);
    if (bstrResponse)
        SysFreeString(bstrResponse);

    return 0;
}

//==============================================================================
void ParseArguments 
(
    LPSTR  InBuffer,
    LPSTR* CArgv,
    DWORD* CArgc
)
{
    LPSTR CurrentPtr = InBuffer;
    DWORD i = 0;
    DWORD Cnt = 0;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr == ' ' ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        CArgv[i++] = CurrentPtr;

        //
        // go to next space.
        //

        while(  (*CurrentPtr != '\0') &&
                (*CurrentPtr != '\n') ) {
            if( *CurrentPtr == '"' ) {      // Deal with simple quoted args
                if( Cnt == 0 )
                    CArgv[i-1] = ++CurrentPtr;  // Set arg to after quote
                else
                    *CurrentPtr = '\0';     // Remove end quote
                Cnt = !Cnt;
            }
            if( (Cnt == 0) && (*CurrentPtr == ' ') ||   // If we hit a space and no quotes yet we are done with this arg
                (*CurrentPtr == '\0') )
                break;
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        *CurrentPtr++ = '\0';
    }

    *CArgc = i;
    return;
}

//==============================================================================
int __cdecl main (int argc, char **argv)
{
    char * port;

    // Discard program arg.
    argv++;
    argc--;

    HRESULT hr = CoInitialize(0);

    if (FAILED(hr))
        return 0;

    if (argc)
        RequestLoop (argc, argv);
        
    else // Enter command prompt loop
    {
        fprintf (stderr, "\nUsage: <host>[:port]/[<object>] [<POST-file>]]");
//        fprintf (stderr, "\n  -s: use secure sockets layer");
//        fprintf (stderr, "\n  -p: specify proxy server. (\"<local>\" assumed for bypass.)");
        fprintf (stderr, "\nTo exit input loop, enter no params");

        while (1)
        {
            char szIn[1024];
            DWORD argcIn;
            LPSTR argvIn[10];

            fprintf (stderr, "\nhttprequest> ");
            gets (szIn);
            
            argcIn = 0;
            ParseArguments (szIn, argvIn, &argcIn);
            if (!argcIn)
                break;
            RequestLoop (argcIn, argvIn);
        }                
    }

    CoUninitialize();

    return 0;
}        



// Need this for IWinHttpRequest guids...

extern "C" {

#include <httprequest_i.c>

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\test\httpasync.cxx ===
// ===========================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1996 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>
#include <winhttp.h>
#define _UNICODE 
#include <tchar.h>

//==============================================================================
//#define GLOBAL_SESSION 1

#ifdef GLOBAL_SESSION
HINTERNET g_hInternet = NULL;
#endif

#ifndef ASSERT
#define ASSERT( exp ) \
    ((!(exp)) ? \
        DebugBreak() : \
        ((void)0))
#endif

typedef enum
{
    HTTP_INIT = 0,
    HTTP_OPEN = 1,
    HTTP_SEND = 2,
    HTTP_QDA  = 3,
    HTTP_READ = 4,
    HTTP_READ_PASS_SYNC  = 5,
    HTTP_READ_PASS_ASYNC = 6,
    HTTP_READ_FAIL_SYNC  = 7,
    HTTP_READ_FAIL_ASYNC = 8,
    HTTP_SEND_FAIL_SYNC  = 9,
    HTTP_SEND_FAIL_ASYNC = 10
} HTTP_STATE;

typedef struct
{
    HTTP_STATE state;
    BOOL bQDA;
    DWORD dwTotal;
    DWORD_PTR dwResult;
    DWORD dwError;
    HANDLE hEvent;
    DWORD dwSignature;
    BOOL bCallbackDelete;
} TestContext;

VOID CALLBACK Callback(IN HINTERNET hInternet, IN DWORD_PTR dwContext,
                           IN DWORD dwStatus, IN LPVOID pvInfo, IN DWORD dwStatusLen)
{
#if 0
    fprintf(stderr, "callback!!!!!! dwStatus %d\n", dwStatus);
#endif

    TestContext* pContext = (TestContext*)dwContext;
    if ((dwStatus == WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE) && pContext)
    {
        ASSERT (pContext->dwSignature == 0);
        if (pContext->bCallbackDelete)
        {
            delete pContext;
            goto end;
        }
        
        DWORD_PTR dwResult = ((LPWINHTTP_ASYNC_RESULT)(pvInfo))->dwResult;
        DWORD dwError = ((LPWINHTTP_ASYNC_RESULT) (pvInfo) )->dwError;

        pContext->dwResult = dwResult;
        pContext->dwError = dwError;
        SetEvent(pContext->hEvent);
#if 0
        OutputDebugString("\n\tWINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE for QDA\n");
		fprintf(stderr, "\n\tWINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE for QDA with %d result and %d error.\n", dwResult, dwBytes);
#endif
    }

end:
    return;
}

#define CHECK_ERROR(cond, err) if (!(cond)) {pszErr=(err); goto done;}

//==============================================================================
int RequestLoop (int argc, char **argv)
{
#ifndef GLOBAL_SESSION
    HINTERNET g_hInternet = NULL;
#endif
    HINTERNET hConnect  = NULL;
    HINTERNET hRequest  = NULL;

    DWORD   dwAccessType   = WINHTTP_ACCESS_TYPE_DEFAULT_PROXY;
    WCHAR   szProxyServer[256];
    WCHAR   szProxyBypass[256];

    DWORD dwConnectFlags = 0;
    BOOL fPreAuth = FALSE;

    PSTR pPostData = NULL;
    DWORD cbPostData = 0;
    
    PSTR pszErr = NULL;
    BOOL fRet;
    DWORD dwErr = ERROR_SUCCESS;

    DWORD dwTarget = WINHTTP_AUTH_TARGET_SERVER;
    LPVOID pAuthParams = NULL;

    DWORD option = WINHTTP_OPTION_RESOLVE_TIMEOUT;
    DWORD dwTimeout = 1000;
    HANDLE hEvent = NULL;

    PSTR pszObject   = NULL;
    PSTR pszPostFile = NULL;
    char pszHost[128];
    PSTR pszColon    = NULL;
    BOOL bDeleteContext = TRUE;

    TestContext* pContext = new TestContext();
    CHECK_ERROR(pContext, "new TestContext");
    
    memset(pContext, 0, sizeof(TestContext));
    
    // Parse options.
    while (argc && argv[0][0] == '-')
    {
        switch (tolower(argv[0][1]))
        {
            case 'p':
                dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
                dwTarget = WINHTTP_AUTH_TARGET_PROXY;
                ::MultiByteToWideChar(CP_ACP, 0, argv[1],   -1, &szProxyServer[0], 256);
                // pszProxyServer = argv[1];
                ::MultiByteToWideChar(CP_ACP, 0, "<local>", -1, &szProxyBypass[0], 256);
                // pszProxyBypass = "<local>";
                argv++;
                argc--;
                break;

            case 's':
                dwConnectFlags = WINHTTP_FLAG_SECURE;
                break;

            case 'a':
                fPreAuth = TRUE;
                break;

            default:
                fprintf (stderr, "\nUsage: httpauth [-p <proxy>] [-s] <server> [<object> [<user> [<pass> [<POST-file>]]]]");
                fprintf (stderr, "\n  -s: Secure connection (ssl or pct)");
                fprintf (stderr, "\n  -p: specify proxy server. (\"<local>\" assumed for bypass.)");
                exit (1);
        }
        
        argv++;
        argc--;
    }

    // Parse host:port
    {
        int nlen = strlen(argv[0]);
        if (nlen > sizeof(pszHost))
            goto done;
        strcpy(pszHost, argv[0]);
    }
    
    DWORD dwPort;
    pszColon = strchr(pszHost, ':');
    if (!pszColon)
        dwPort = INTERNET_DEFAULT_PORT;
    else
    {
        *pszColon++ = 0;
        dwPort = atol (pszColon);
    }

    pszObject   = argc >= 2 ? argv[1] : "/";
    pszPostFile = argc >= 3 ? argv[2] : NULL;

    // Read any POST data into a buffer.
    if (pszPostFile)
    {
        HANDLE hf =
            CreateFile
            (
                pszPostFile,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
            );
        if (hf != INVALID_HANDLE_VALUE)
        {
            cbPostData = GetFileSize (hf, NULL);
            pPostData = (PSTR) LocalAlloc (LMEM_FIXED, cbPostData + 1);
            if (pPostData)
                ReadFile (hf, pPostData, cbPostData, &cbPostData, NULL);
            pPostData[cbPostData] = 0;
            CloseHandle (hf);
        }
    }

    // Initialize wininet.
#ifdef GLOBAL_SESSION
    if (!g_hInternet)
#endif
        g_hInternet = WinHttpOpen
        (
            _T("HttpAuth Sample"),            // user agent
            // "Mozilla/4.0 (compatible; MSIE 4.0b2; Windows 95",
            dwAccessType,                 // access type
            szProxyServer,               // proxy server
            szProxyBypass,               // proxy bypass
            WINHTTP_FLAG_ASYNC          // flags
        );
    CHECK_ERROR (g_hInternet, "WinHttpOpen");


    WCHAR szHost[256];
    ::MultiByteToWideChar(CP_ACP, 0, pszHost,   -1, &szHost[0], 256);

    WinHttpSetStatusCallback(g_hInternet, Callback, WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS, NULL);
    
    dwTimeout = 1000;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_RESOLVE_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );

    dwTimeout = 1000;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_CONNECT_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );
    
    dwTimeout = 100;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_SEND_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );
    
    dwTimeout = 100;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_RECEIVE_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );
    
    hEvent = CreateEvent(NULL, FALSE /*want auto-reset*/, FALSE /*non-signaled init.*/, NULL);

    CHECK_ERROR(hEvent, "CreateEvent");

    pContext->hEvent = hEvent;
  
    // Connect to host.
    hConnect = WinHttpConnect
    (
        g_hInternet,                    // session handle,
        szHost,                      // host
        (INTERNET_PORT) dwPort,       // port
        dwConnectFlags                // flags
    );
    CHECK_ERROR (hConnect, "WinHttpConnect");

    WCHAR szObject[256];
    ::MultiByteToWideChar(CP_ACP, 0, pszObject,   -1, &szObject[0], 256);

    // Create request.
    
    pContext->state = HTTP_OPEN;
    hRequest = WinHttpOpenRequest
    (
        hConnect,                     // connect handle
        pszPostFile? _T("POST") : _T("GET"),  // request method
        szObject,                    // object name
        NULL,                         // version
        NULL,                         // referer
        NULL,                         // accept types
        dwConnectFlags                // flags
    );
    CHECK_ERROR (hRequest, "WinHttpOpenRequest");

    // Send request.
    pContext->state = HTTP_SEND;
    fRet = WinHttpSendRequest
    (
        hRequest,                     // request handle
        _T(""),                       // header string
        0,                            // header length
        pPostData,                    // post data
        cbPostData,                   // post data length
        cbPostData,                   // total post length
        (DWORD_PTR)pContext             // context
    );

    if (!fRet)
    {
        dwErr = GetLastError();
        switch (dwErr)
        {
            case ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED:
                break;

            case ERROR_IO_PENDING:
                fRet = WinHttpReceiveResponse(hRequest, NULL);
                if (!fRet)
                {
                    dwErr = GetLastError();
                    if (dwErr != ERROR_IO_PENDING)
                    {
                        fprintf (stderr, "WinHttpReceiveResponse failed err=%d\n", dwErr);
                        break;
                    }
                }
                goto async;
                
            default:
                fprintf (stderr, "HttpSendRequest failed err=%d\n", dwErr);
        }
        pContext->state = HTTP_SEND_FAIL_SYNC;
        goto done;
    }
    else
    {
        fRet = WinHttpReceiveResponse(hRequest, NULL);
        if (!fRet)
        {
            dwErr = GetLastError();
            fprintf (stderr, "WinHttpReceiveResponse failed err=%d\n", dwErr);
            pContext->state = HTTP_SEND_FAIL_SYNC;
        }
        goto sync;
    }

async:
#if 0
    fprintf(stderr, "\nERROR_IO_PENDING on HSR...\n");
#endif
    WaitForSingleObject(hEvent, INFINITE);

    ASSERT( pContext->state == HTTP_SEND );
    if (! (pContext->dwResult) )
    {
        pContext->state = HTTP_SEND_FAIL_ASYNC;
        SetLastError (pContext->dwError);
        goto done;
    }
sync:
    
    // Get status code.
    DWORD dwStatus, cbStatus;
    cbStatus = sizeof(dwStatus);
    WinHttpQueryHeaders
    (
        hRequest,
        WINHTTP_QUERY_FLAG_NUMBER | WINHTTP_QUERY_STATUS_CODE,
        NULL,
        &dwStatus,
        &cbStatus,
        NULL
    );
    fprintf (stderr, "Status: %d\n", dwStatus);

    // Dump some bytes.
    BYTE bBuf[1024];
    DWORD cbBuf;

#define QDA 1
#ifdef QDA
    while (TRUE)
    {
        BOOL bAsyncRead = FALSE;
        pContext->state = HTTP_QDA;
        fRet = WinHttpQueryDataAvailable (hRequest, &(pContext->dwError));
        
        if (!fRet)
        {
            if (GetLastError() == ERROR_IO_PENDING)
            {
#if 0
                OutputDebugString("\nERROR_IO_PENDING on QDA\n");
                fprintf(stderr, "\nERROR_IO_PENDING on QDA...\n");
#endif
                WaitForSingleObject(hEvent, INFINITE);
                
                ASSERT (pContext->state = HTTP_QDA);
                if (!(pContext->dwResult))
                {
                    // Done
                    pContext->state = HTTP_READ_FAIL_ASYNC;
                    SetLastError(pContext->dwError);
                    goto done;
                }
                else if (!(pContext->dwError))
                {
                    pContext->state = HTTP_READ_PASS_ASYNC;
                    goto done;
                }
                bAsyncRead = TRUE;
            }
            else
            {
                pContext->state = HTTP_READ_FAIL_SYNC;
                goto done;
            }
        }
        else if (!(pContext->dwError))
        {
            //Done sync
            pContext->state = HTTP_READ_PASS_SYNC;
            goto done;
        }
            
        DWORD dwRead = pContext->dwError;
        DWORD dwActuallyRead = 0;
        while (dwRead > 0)
        {
            cbBuf = (dwRead > sizeof(bBuf)) ? sizeof(bBuf) : dwRead;
            pContext->state = HTTP_READ;
            fRet = WinHttpReadData(hRequest, bBuf, cbBuf, &dwActuallyRead);

            if (!fRet)
            {
                ASSERT ( GetLastError() != ERROR_IO_PENDING );
                fprintf(stderr, "\nError in WinHttpReadData = %d\n", GetLastError());
                goto done;
            }
            ASSERT((cbBuf == dwActuallyRead));
#if 0
            ASSERT(fRet);
            fwrite (bBuf, 1, dwActuallyRead, stdout);
#endif
            pContext->dwTotal += dwActuallyRead;
            dwRead -= dwActuallyRead;
        }    
    }
#else
    cbBuf = sizeof(bBuf);
    while (WinHttpReadData (hRequest, bBuf, cbBuf, &(pContext->dwRead)) && pContext->dwRead)
        fwrite (bBuf, 1, pContext->dwRead, stdout);
#endif

done: // Clean up.

    if (pszErr)
        fprintf (stderr, "Failed on %s, last error %d\n", pszErr, GetLastError());
    if (hRequest)
        WinHttpCloseHandle (hRequest);
    if (hConnect)
        WinHttpCloseHandle (hConnect);
        
#ifndef GLOBAL_SESSION
    if (g_hInternet)
        WinHttpCloseHandle (g_hInternet);
#endif

    if (pPostData)
        LocalFree (pPostData);
    if (hEvent)
        CloseHandle(hEvent);
    if (pContext && bDeleteContext)
    {
        pContext->dwSignature = 0x41414141;
        delete pContext;
    }
        
    return 0;
}

//==============================================================================
void ParseArguments 
(
    LPSTR  InBuffer,
    LPSTR* CArgv,
    DWORD* CArgc
)
{
    LPSTR CurrentPtr = InBuffer;
    DWORD i = 0;
    DWORD Cnt = 0;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr == ' ' ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        CArgv[i++] = CurrentPtr;

        //
        // go to next space.
        //

        while(  (*CurrentPtr != '\0') &&
                (*CurrentPtr != '\n') ) {
            if( *CurrentPtr == '"' ) {      // Deal with simple quoted args
                if( Cnt == 0 )
                    CArgv[i-1] = ++CurrentPtr;  // Set arg to after quote
                else
                    *CurrentPtr = '\0';     // Remove end quote
                Cnt = !Cnt;
            }
            if( (Cnt == 0) && (*CurrentPtr == ' ') ||   // If we hit a space and no quotes yet we are done with this arg
                (*CurrentPtr == '\0') )
                break;
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        *CurrentPtr++ = '\0';
    }

    *CArgc = i;
    return;
}


DWORD WINAPI WorkThread1(LPVOID lpParameter)
{
    int nCount = 0;
    char* pargv[] = {"dennisch", "venkatk/large.html", 0};

    while (nCount++ < 500000)
    {
        fprintf (stderr, "\nLARGE Iteration #%d\n", nCount);
        RequestLoop( 2, pargv);
    }

    fprintf (stderr, "\nLARGE DONE!\n");

    return 0;
}
DWORD WINAPI WorkThread2(LPVOID lpParameter)
{
    int nCount = 0;
    char* pargv[] = {"dennisch", "venkatk/small.html", 0};

    while (nCount++ < 3000000)
    {
        fprintf (stderr, "\nSMALL Iteration #%d\n", nCount);
        RequestLoop( 2, pargv);
    }

    fprintf (stderr, "\nSMALL DONE!\n");

    return 0;
}
DWORD WINAPI WorkThread3(LPVOID lpParameter)
{
    int nCount = 0;
    char* pargv[] = {"venkatk:180", 0};

    while (nCount++ < 10000)
    {
        fprintf (stderr, "\n180 Iteration #%d\n", nCount);
        RequestLoop( 1, pargv);
    }

    fprintf (stderr, "\n180 DONE!\n");

    return 0;
}

//==============================================================================
int __cdecl main (int argc, char **argv)
{
	char * port;
	int nCount = 0;
	// Discard program arg.
    argv++;
    argc--;

    
#if 1
    DWORD dwThreadId;    
    HANDLE hThread1 = CreateThread(NULL, 0, &WorkThread1,
    					NULL, 0, &dwThreadId);
    Sleep(1000);
    HANDLE hThread2 = CreateThread(NULL, 0, &WorkThread2,
    					NULL, 0, &dwThreadId);
    HANDLE hThread3 = CreateThread(NULL, 0, &WorkThread3,
    					NULL, 0, &dwThreadId);

    {
        char* pargv[] = {"pmidge", 0};

        while (nCount++ < 2000000)
        {
            fprintf (stderr, "\nPMIDGE Iteration #%d\n", nCount);
            RequestLoop( 1, pargv);
        }

        fprintf (stderr, "\n180 DONE!\n");
    }

    WaitForSingleObject( hThread1, INFINITE );
    WaitForSingleObject( hThread2, INFINITE );
    WaitForSingleObject( hThread3, INFINITE );
#endif

#if 0
    char* argv_large[] = {"dennisch", "venkatk/large.html", 0};
    char* argv_small[] = {"dennisch", "venkatk/small.html", 0};
    char* argv_delay[] = {"venkatk:180", 0};

    while(nCount++ < 30)
    {
        RequestLoop( 1, argv_delay );
    }
    
    while(nCount++ < 100)
    {
#if 0
        fprintf (stderr, "\nIteration #%d\n", nCount);
#endif
        RequestLoop( 2, argv_large);
        RequestLoop( 2, argv_small);
        RequestLoop( 1, argv_delay);
    }
#endif
    fprintf (stderr, "\nIteration #%d\n", nCount);

#if 0
    if (argc)
        RequestLoop (argc, argv);
        
    else // Enter command prompt loop
    {
        fprintf (stderr, "\nUsage: [-p <proxy>] [-s] <host>[:port] [<object> [<POST-file>]]");
        fprintf (stderr, "\n  -s: use secure sockets layer");
        fprintf (stderr, "\n  -p: specify proxy server. (\"<local>\" assumed for bypass.)");
        fprintf (stderr, "\nTo exit input loop, enter no params");

        while (1)
        {
            char szIn[1024];
            DWORD argcIn;
            LPSTR argvIn[10];

            fprintf (stderr, "\nhttpauth> ");
            gets (szIn);
            
            argcIn = 0;
            ParseArguments (szIn, argvIn, &argcIn);
            if (!argcIn)
                break;
            RequestLoop (argcIn, argvIn);
            //g_cbRead=0;
        }                
    }
#endif

#ifdef GLOBAL_SESSION
    if (g_hInternet)
        WinHttpCloseHandle (g_hInternet);
    g_hInternet = NULL;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\sdk\certcfg\certcfg.cxx ===
/*
    usage:

    winhttpcertcfg [-?]  : to view help information

    winhttpcertcfg [-i PFXFile | -g | -r | -l]
                   -c CertLocation\CertStore [-a Account] [-s SubjectStr] [-p PFXPassword]

        -i PFXFile  : Import cert via specified .pfx filename given
                      with the option.  This option also requires
                      -a and -c to indicate destination (doesn't support -a
                      in conjunction with importing just yet).

        -g          : Grant access to private key for already
                      installed cert indicated by subject string.
                      This option also requires -a, -c, and -s.

        -r          : Remove access to private key for specified
                      account name and certificate.  This option
                      also requires -a, -c, -s to specify the
                      account and certificate information.

        -l          : List accounts that have access to the private
                      key of enumerated certs specified via other
                      filter options.  This option also requires
                      -c and -s to specify which certificate should
                      be queried.

        Description of addtional options:
            -c LOCAL_MACHINE|CURRENT_USER\CertStore   (Example:  LOCAL_MACHINE\MY)

            -a Account (Represents user or domain account on the machine.
                        Examples: IWAM_TESTMACHINE, TESTUSER, or TESTDOMAIN\DOMAINUSER)

            -s SubjectStr (Case-insensitive search string for finding the first enumerated
                           certificate with a subject name that contains this substring.)

            -p PFXPassword (Password to use when importing a PFX file.  Only used with -i.)
 */

#include <windows.h>
#include <cryptui.h>
#include <wincrypt.h>
#include <stdio.h>

typedef DWORD (WINAPI* CRYPTUIWIZIMPORT) (DWORD, HWND, LPCWSTR, PCCRYPTUI_WIZ_IMPORT_SRC_INFO, HCERTSTORE);
typedef BOOL (WINAPI* SETSECURITYDESCRIPTORCONTROL) (PSECURITY_DESCRIPTOR,
                                                     SECURITY_DESCRIPTOR_CONTROL,
                                                     SECURITY_DESCRIPTOR_CONTROL);

static const char gc_szLocalMachine[] = "LOCAL_MACHINE";
static const char gc_szCurrentUser[]  = "CURRENT_USER";

enum ARGTYPE
{
    ARGS_HELP,
    ARGS_IMPORT_PFX,
    ARGS_ADD_PRIVATE_KEY_ACCESS,
    ARGS_REMOVE_PRIVATE_KEY_ACCESS,
    ARGS_LIST_PRIVATE_KEY_ACCESS
};


struct ARGS
{
    ARGTYPE Command;

    LPWSTR  pwszPFXFile;
    LPWSTR  pwszCertStore;
    LPWSTR  pwszCertSubject;
    LPWSTR  pwszPFXPassword;
    LPSTR   pszDomain;
    LPSTR   pszAccount;
    BOOL    fUseLocalMachine;
};


void ParseArguments(int argc, char **argv, ARGS *pArgs);
DWORD AsciiToWideChar(const char * pszA, LPWSTR * ppszW);
DWORD ImportPFXFile(ARGS *pArgs);
VOID DumpSid(BYTE *pSid);
VOID DumpCertInfo(PCCERT_CONTEXT pCertContext);
DWORD GetAccountForSid(BYTE *pSid, LPTSTR *ppszDomain, LPTSTR *ppszAccount);
DWORD GetSidForAccount(LPCTSTR pszDomain, LPCTSTR pszAccount, BYTE **ppSid, char **ppszDomain);
DWORD DumpAccessAllowedList(PACL pDacl);
DWORD DoPrivateKeyAccessAction(ARGS *pArgs);
DWORD ProcessCertContext(PCCERT_CONTEXT pCertContext, BYTE *pSid, ARGTYPE eCommand);
BOOL CheckForRootCert(PCCERT_CONTEXT pCertContext);
DWORD AddPrivateKeyAccess(PACL pDacl, BYTE *pSid, PACL *ppNewDacl);
DWORD RemovePrivateKeyAccess(PACL pDacl, BYTE *pSid);
BOOL MySetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSD,
                                    SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
                                    SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet);

void
ParseArguments(int argc, char **argv, ARGS *pArgs)
{
    char *pszBreak;

    ZeroMemory((PVOID) pArgs, sizeof(ARGS));

    pArgs->Command = ARGS_HELP;
    pArgs->fUseLocalMachine = TRUE;

    for (; argc > 0; argc--, argv++)
    {
        if (((argv[0][0] != '-') && (argv[0][0] != '/')) || (lstrlen(argv[0]) != 2))
        {
            goto ErrorExit;
        }

        switch (tolower(argv[0][1]))
        {
        case 'l':
            pArgs->Command = ARGS_LIST_PRIVATE_KEY_ACCESS;
            break;

        case 'g':
            pArgs->Command = ARGS_ADD_PRIVATE_KEY_ACCESS;
            break;
            
        case 'i':
        {
            TCHAR szShortPath[MAX_PATH];
            BOOL fUseConvertedPath = TRUE;

            argc--;
            argv++;

            if (argc == 0)
            {
                // error: no PFX file specified
                goto ErrorExit;
            }

            // PFX Import API doesn't handle long filenames
            if (GetShortPathName(argv[0], szShortPath, MAX_PATH) > MAX_PATH)
            {
                fUseConvertedPath = FALSE;
            }

            if (ERROR_SUCCESS == AsciiToWideChar(fUseConvertedPath ? szShortPath : argv[0],
                                                 &pArgs->pwszPFXFile))
            {
                pArgs->Command = ARGS_IMPORT_PFX;
                break;
            }
            else
            {
                goto ErrorExit;
            }
        }
        case 'r':
            pArgs->Command = ARGS_REMOVE_PRIVATE_KEY_ACCESS;
            break;

        case 'c':
            argc--;
            argv++;

            if (argc > 0 &&
                (pszBreak = strchr(argv[0], '\\')) != NULL)
            {
                if (_strnicmp(argv[0], gc_szLocalMachine, strlen(gc_szLocalMachine)) == 0)
                {
                    pArgs->fUseLocalMachine = TRUE;
                }
                else if (_strnicmp(argv[0], gc_szCurrentUser, strlen(gc_szCurrentUser)) == 0)
                {
                    pArgs->fUseLocalMachine = FALSE;
                }
                else
                {
                    goto ErrorExit;
                }

                // increment to skip the backslash
                pszBreak++;
                if (ERROR_SUCCESS == AsciiToWideChar(pszBreak, &pArgs->pwszCertStore))
                {
                    break;
                }
            }
            goto ErrorExit;

        case 's':
            argc--;
            argv++;

            if (argc <= 0 ||
                ERROR_SUCCESS != AsciiToWideChar(argv[0], &pArgs->pwszCertSubject))
            {
                goto ErrorExit;
            }
            break;

        case 'a':
            argc--;
            argv++;

            if (argc > 0)
            {
                pArgs->pszAccount = strchr(argv[0], '\\');
                if (pArgs->pszAccount)
                {
                    // Break the two apart by removing the slash
                    *(pArgs->pszAccount) = '\0';
                    pArgs->pszAccount++;
                    pArgs->pszDomain = argv[0];
                }
                else
                {
                    pArgs->pszAccount = argv[0];
                }
            }
            else
            {
                goto ErrorExit;
            }
            break;

        case 'p':
            argc--;
            argv++;

            if (argc <= 0 ||
                ERROR_SUCCESS != AsciiToWideChar(argv[0], &pArgs->pwszPFXPassword))
            {
                // error: no password specified
                goto ErrorExit;
            }
            break;

        default:
            goto ErrorExit;

        }
    }

    // Now verify that we've obtained all the needed
    // options based on the desired config operation.
    if (pArgs->Command != ARGS_HELP)
    {
        // All options need -c.
        // All but -i need -s, and all but -i prohibit -p.
        // All but -l need -a.
        // -a not allowed for -l.
        // -s not allowed for -i.
        if (pArgs->pwszCertStore == NULL ||
            (pArgs->Command != ARGS_IMPORT_PFX &&
             (pArgs->pwszCertSubject == NULL || pArgs->pwszPFXPassword)) ||
            (pArgs->Command == ARGS_LIST_PRIVATE_KEY_ACCESS && pArgs->pszAccount) ||
            (pArgs->Command == ARGS_IMPORT_PFX && pArgs->pwszCertSubject))
        {
            // Incorrect set of options were passed, so flip this to
            // displaying the usage.
            goto ErrorExit;
        }
    }

    return;

ErrorExit:
    pArgs->Command = ARGS_HELP;
    return;
}


//
//  AsciiToWideChar was borrowed from WinHttp\v5\common\util.cxx
//

DWORD
AsciiToWideChar(const char * pszA, LPWSTR * ppszW)
{
    DWORD cchA;
    DWORD cchW;

    *ppszW = NULL;

    if (!pszA)
        return ERROR_SUCCESS;

    cchA = lstrlenA(pszA);

    // Determine how big the widechar string will be
    cchW = MultiByteToWideChar(CP_ACP, 0, pszA, cchA, NULL, 0);

    *ppszW = new WCHAR[cchW+1];

    if (!*ppszW)
        return ERROR_NOT_ENOUGH_MEMORY;

    cchW = MultiByteToWideChar(CP_ACP, 0, pszA, cchA, *ppszW, cchW);

    (*ppszW)[cchW] = 0;

    return ERROR_SUCCESS;
}


DWORD
ImportPFXFile(ARGS *pArgs)
{
    CRYPTUI_WIZ_IMPORT_SRC_INFO importSrc;
    HCERTSTORE hDestCertStore = NULL;
    HCERTSTORE hTempCertStore = NULL;
    DWORD dwError = ERROR_SUCCESS;
    HINSTANCE hCryptUILib = NULL;
    CRYPTUIWIZIMPORT pfnCryptUIWizImport;
        
    hCryptUILib = LoadLibrary(TEXT("cryptui.dll"));
    if (hCryptUILib == NULL)
    {
        dwError = GetLastError();
        fprintf(stderr,
                "Error:  Failed to load cryptography component with error code 0x%X\n",
                dwError);
        goto Cleanup;
    }

    pfnCryptUIWizImport = (CRYPTUIWIZIMPORT)GetProcAddress(hCryptUILib, "CryptUIWizImport");
    if (pfnCryptUIWizImport == NULL)
    {
        dwError = GetLastError();
        fprintf(stderr, "Error:  Could not find needed DLL entry point\n");
        goto Cleanup;
    }

    hDestCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                   0,
                                   NULL,
                                   CERT_STORE_OPEN_EXISTING_FLAG |
                                   (pArgs->fUseLocalMachine ? CERT_SYSTEM_STORE_LOCAL_MACHINE :
                                                              CERT_SYSTEM_STORE_CURRENT_USER),
                                   pArgs->pwszCertStore);

    hTempCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY,
                                   0,
                                   NULL,
                                   0,
                                   NULL);

    if (!hDestCertStore || !hTempCertStore)
    {
        dwError = GetLastError();
        fprintf(stderr,
                "Error:  Failed to open certificate store with error code 0x%X\n",
                dwError);
        goto Cleanup;
    }

    // Ensure that it's really a PFX file that can be imported.
    if(CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                       pArgs->pwszPFXFile,
                       CERT_QUERY_CONTENT_FLAG_PFX,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL))
    {

        memset(&importSrc, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
        importSrc.dwSize          = sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
        importSrc.dwSubjectChoice = CRYPTUI_WIZ_IMPORT_SUBJECT_FILE;
        importSrc.pwszFileName    = pArgs->pwszPFXFile;
        importSrc.pwszPassword    = pArgs->pwszPFXPassword;

        if ((*pfnCryptUIWizImport)(CRYPTUI_WIZ_NO_UI |
                                   (pArgs->fUseLocalMachine ? CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE : 
                                                              CRYPTUI_WIZ_IMPORT_TO_CURRENTUSER) |
                                   CRYPTUI_WIZ_IMPORT_ALLOW_CERT,
                                   NULL,
                                   NULL,
                                   &importSrc, 
                                   hTempCertStore))
        {
            DWORD dwImportCount = 0;
            DWORD dwAclCount = 0;
            BYTE *pSid = NULL;
            LPSTR pszDomain = NULL;

            dwError = GetSidForAccount(pArgs->pszDomain,
                                       pArgs->pszAccount,
                                       &pSid,
                                       &pszDomain);
            if (ERROR_SUCCESS != dwError)
            {
                goto Cleanup;
            }

            // Extract cert context(s) from temporary store and copy to
            // destination store.  Need to enumerate and import one
            // at a time, so the private key access can also be modified.
            PCCERT_CONTEXT pCertContext = NULL;
            PCCERT_CONTEXT pDestCertContext = NULL;

            importSrc.dwSubjectChoice = CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT;

            while (ERROR_SUCCESS == dwError &&
                   (pCertContext = CertEnumCertificatesInStore(hTempCertStore, pCertContext)) != NULL)
            {
                // Root cert is last...break and add it to the root store.
                if (CheckForRootCert(pCertContext))
                    break;

                // Overwrite if already installed.
                if (CertAddCertificateContextToStore(hDestCertStore,
                                                     pCertContext,
                                                     CERT_STORE_ADD_REPLACE_EXISTING,
                                                     &pDestCertContext))
                {
                    // Let the user see info regarding the cert imported
                    fprintf(stdout, "Imported certificate:\n");
                    DumpCertInfo(pCertContext);
                    fprintf(stdout, "\n");
                    dwError = ProcessCertContext(pDestCertContext,
                                                 pSid,
                                                 ARGS_ADD_PRIVATE_KEY_ACCESS);

                    if (ERROR_SUCCESS == dwError)
                    {
                        dwAclCount++;
                    }
                    CertFreeCertificateContext(pDestCertContext);

                    dwImportCount++;
                }
                else
                {
                    fprintf(stderr,
                            "Error: Failed to import a certificate, error = 0x%X\n\n",
                            GetLastError());
                }
            }
            if (pCertContext)
            {
                CertCloseStore(hDestCertStore, 0);

                hDestCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                               0,
                                               NULL,
                                               CERT_STORE_OPEN_EXISTING_FLAG |
                                               (pArgs->fUseLocalMachine ? CERT_SYSTEM_STORE_LOCAL_MACHINE :
                                                                          CERT_SYSTEM_STORE_CURRENT_USER),
                                               L"Root");

                if (!hDestCertStore)
                {
                    dwError = GetLastError();
                    fprintf(stderr, "Error: Unable to import root certificate\n\n");
                    goto Cleanup;
                }

                if (!CertAddCertificateContextToStore(hDestCertStore,
                                                     pCertContext,
                                                     CERT_STORE_ADD_REPLACE_EXISTING,
                                                     NULL))
                {
                    fprintf(stderr, "Warning: Failed to import root certificate\n\n");
                }

                CertFreeCertificateContext(pCertContext);
            }

            if (pSid)
                LocalFree(pSid);

            if (pszDomain)
                LocalFree(pszDomain);
        }
        else
        {
            dwError = GetLastError();
            fprintf(stderr,
                    "Error:  Unable to import contents of PFX file.\n"
                    "        Please make sure the filename and path,\n"
                    "        as well as the password, are correct.\n\n",
                    dwError);
        }
    }
    else
    {
        dwError = GetLastError();
        if (dwError == ERROR_FILE_NOT_FOUND)
        {
            fprintf(stderr,"Error:  PFX file was not found\n");
        }
        else
        {
            fprintf(stderr,"Error:  Unable to open PFX file\n");
        }
    }

Cleanup:

    if (hTempCertStore)
        CertCloseStore(hTempCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
    if (hDestCertStore)
        CertCloseStore(hDestCertStore, CERT_CLOSE_STORE_FORCE_FLAG);

    if (hCryptUILib)
    {
        FreeLibrary(hCryptUILib);
    }

    return dwError;
}


VOID
DumpSid(BYTE *pSid)
{
    LPTSTR pszDomain  = NULL;
    LPTSTR pszAccount = NULL;

    if (ERROR_SUCCESS == GetAccountForSid(pSid, &pszDomain, &pszAccount))
    {
        if (pszDomain)
        {
            fprintf(stdout,
                    "    %s\\%s\n",
                    pszDomain,
                    pszAccount);
        }
        else
        {
            fprintf(stdout,
                    "    %s\n",
                    pszDomain,
                    pszAccount);
        }
        if (pszDomain)
            LocalFree(pszDomain);
        if (pszAccount)
            LocalFree(pszAccount);
    }
}


DWORD
GetAccountForSid(BYTE  *pSid,
                 LPTSTR *ppszDomain,
                 LPTSTR *ppszAccount)
{
    DWORD cbAccountLength = 0;
    DWORD cbDomainLength = 0;
    SID_NAME_USE eUse;
    DWORD dwError = ERROR_SUCCESS;

    if (!pSid || !ppszDomain || !ppszAccount || !IsValidSid(pSid))
        return ERROR_INVALID_PARAMETER;

    *ppszDomain = NULL;
    *ppszAccount = NULL;

    if (!LookupAccountSid(NULL,
                          pSid,
                          *ppszAccount,
                          &cbAccountLength,
                          *ppszDomain,
                          &cbDomainLength,
                          &eUse))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            return GetLastError();
        }
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (cbDomainLength)
    {
        *ppszDomain = (LPTSTR) LocalAlloc(LPTR, cbDomainLength * sizeof(TCHAR));    
        if (!*ppszDomain) 
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        };
    }

    *ppszAccount = (LPTSTR) LocalAlloc(LPTR, cbAccountLength * sizeof(TCHAR));
    if (!*ppszAccount)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    if (!LookupAccountSid(NULL,
                          pSid,
                          *ppszAccount,
                          &cbAccountLength,
                          *ppszDomain,
                          &cbDomainLength,
                          &eUse))
    {
        dwError = GetLastError();
        goto ErrorExit;
    }

    // Made it through, should be ERROR_SUCCESS
    return dwError;

ErrorExit:
    if (*ppszDomain)
    {
        LocalFree(*ppszDomain);
        *ppszDomain = NULL;
    }
    if (*ppszAccount)
    {
        LocalFree(*ppszAccount);
        *ppszAccount = NULL;
    }

    fprintf(stderr,"Error:  Unable to determine account name for SID, error = 0x%X\n", dwError);

    return dwError;
}


DWORD
GetSidForAccount(LPCTSTR pszDomain,
                 LPCTSTR pszAccount,
                 BYTE **ppSid,
                 char **ppszDomain)
{
    SID_NAME_USE su;
    DWORD cbSidLength = 0;
    DWORD cbDomainLength = 0;
    DWORD dwError = ERROR_SUCCESS;

    if (!pszAccount || !ppSid || !ppszDomain)
        return ERROR_INVALID_PARAMETER;

    *ppSid = NULL;
    *ppszDomain = NULL;

    // Determine the SID that belongs to the user. Make first call to
    // get the needed buffer sizes.
    if (!(LookupAccountName(pszDomain,
                            pszAccount,
                            *ppSid,
                            &cbSidLength,
                            *ppszDomain,
                            &cbDomainLength,
                            &su)))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            dwError = GetLastError();
            goto ErrorExit;
        }
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    *ppSid = (BYTE *) LocalAlloc(LPTR, cbSidLength);    
    if (!*ppSid) 
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    };
    
    *ppszDomain = (char *) LocalAlloc(LPTR, cbDomainLength); 
    if (!*ppszDomain) 
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    if (!LookupAccountName(pszDomain,
                           pszAccount,
                           *ppSid,
                           &cbSidLength,
                           *ppszDomain,
                           &cbDomainLength,
                           &su))
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    // Double check the returned SID
    if (!IsValidSid(*ppSid)) 
    {
        dwError = GetLastError();
        goto ErrorExit;
    }

    return dwError;

ErrorExit:
    if (*ppSid)
    {
        LocalFree(*ppSid);
        *ppSid = NULL;
    }
    if (*ppszDomain)
    {
        LocalFree(*ppszDomain);
        *ppszDomain = NULL;
    }

    fprintf(stderr, "Error: No account information was found.\n", dwError);

    return dwError;
}


DWORD
DumpAccessAllowedList(PACL pDacl)
{
    WORD wIndex;
    LPVOID pAce = NULL;

    if (pDacl == NULL)
    {
        fprintf(stdout, "The Discretionary Access Control List (DACL) for this object is a NULL DACL.  "
                        "This implies everyone has full access to this object.  This NULL DACL could be"
                        "in place because the system is running on a filesystem which does not support "
                        "protected files (such as the FAT32 filesystem)"
                        "\n");
        goto done;
    }
 
    fprintf(stdout, "Additional accounts and groups with access to the private key include:\n");
    for (wIndex = 0; wIndex < pDacl->AceCount; wIndex++)
    {
        if (GetAce(pDacl, wIndex, &pAce))
        {
            // Should only be an access allowed ace, right?
            if (((ACCESS_ALLOWED_ACE *)pAce)->Header.AceType ==
                ACCESS_ALLOWED_ACE_TYPE)
            {
                DumpSid((BYTE *)&(((ACCESS_ALLOWED_ACE *)pAce)->SidStart));
            }
        }
    }

done:
    return ERROR_SUCCESS;
}


// Wrapper that performs common work around the list, add, and remove actions
// involving a private key for a specified certificate.
DWORD DoPrivateKeyAccessAction(ARGS *pArgs)
{
    HCRYPTPROV hProv = NULL;
    BOOL fFreeProv = FALSE;
    HCERTSTORE hCertStore = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    DWORD dwError = ERROR_SUCCESS;
    PACL pDacl = NULL;
    DWORD cbSD = 0;

    // Assume args have already been verified.
    hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                               0,
                               NULL,
                               CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG |
                               (pArgs->fUseLocalMachine ? CERT_SYSTEM_STORE_LOCAL_MACHINE :
                                                          CERT_SYSTEM_STORE_CURRENT_USER),
                               pArgs->pwszCertStore);

    if (!hCertStore)
    {
        DWORD dwError = GetLastError();
        goto Cleanup;
    }

    pCertContext = CertFindCertificateInStore(hCertStore,
                                              X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                              0,
                                              CERT_FIND_SUBJECT_STR,
                                              (LPVOID) pArgs->pwszCertSubject,
                                              NULL);

    if (pCertContext)
    {
        BYTE *pSid = NULL;
        LPSTR pszDomain = NULL;

        // Let the user have a solid idea of which cert was matched.
        fprintf(stdout, "Matching certificate:\n");
        DumpCertInfo(pCertContext);

        // Bogus command will fall through when processing the cert context.
        if (pArgs->Command != ARGS_LIST_PRIVATE_KEY_ACCESS)
        {
            dwError = GetSidForAccount(pArgs->pszDomain,
                                       pArgs->pszAccount,
                                       &pSid,
                                       &pszDomain);
        }

        if (ERROR_SUCCESS == dwError)
        {
            dwError = ProcessCertContext(pCertContext, pSid, pArgs->Command);

            if (pSid)
                LocalFree(pSid);

            if (pszDomain)
                LocalFree(pszDomain);
        }
    }
    else
    {
        fprintf(stderr, "Error:  Unable to find or obtain a context for requested certificate\n\n");
        dwError = ERROR_NOT_FOUND;
    }

Cleanup:
    if (pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }
    if (hCertStore)
    {
        CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
    }
    return dwError;
}


// For a given cert, obtain the DACL associated with its private
// key and process the appropriate command.
DWORD
ProcessCertContext(PCCERT_CONTEXT pCertContext, BYTE *pSid, ARGTYPE eCommand)
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwKeySpec;
    DWORD cbSD;
    WORD wIndex;
    LPVOID pAce = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    SECURITY_DESCRIPTOR sd;
    HCRYPTPROV hProv = NULL;
    BOOL fFreeProv = FALSE;
    PACL pDacl = NULL;
    PACL pNewDacl = NULL;
    BOOL fPresent = FALSE;
    BOOL fDefault = FALSE;

    if (!pCertContext)
        return ERROR_INVALID_PARAMETER;

    // Get the CSP for the cert context.
    // The client must be the owner to do this.
    if (CryptAcquireCertificatePrivateKey(pCertContext,
                                          CRYPT_ACQUIRE_USE_PROV_INFO_FLAG |
                                          CRYPT_ACQUIRE_SILENT_FLAG,
                                          NULL,
                                          &hProv,
                                          &dwKeySpec,
                                          &fFreeProv))
    {
        // Grab the DACL ACE list
        if (CryptGetProvParam(hProv,
                              PP_KEYSET_SEC_DESCR,
                              NULL,
                              &cbSD,
                              DACL_SECURITY_INFORMATION))
        {
            pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, cbSD);
            if (pSD)
            {
                if (CryptGetProvParam(hProv,
                                      PP_KEYSET_SEC_DESCR,
                                      (BYTE *)pSD,
                                      &cbSD,
                                      DACL_SECURITY_INFORMATION))
                {
                    if (!GetSecurityDescriptorDacl(pSD,
                                                   &fPresent,
                                                   &pDacl,
                                                   &fDefault) && fPresent)
                    {
                        dwError = GetLastError();
                        fprintf(stderr, "Error: Failed to obtain access list private key\n\n");
                        goto Cleanup;
                    }
                }
                else
                {
                    dwError = GetLastError();
                    fprintf(stderr, "Error: Failed to obtain security information for private key\n\n");
                    goto Cleanup;
                }
            }
            else
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
        }
        else
        {
            fprintf(stderr, "Error: Failed to obtain security descriptor for private key\n\n");
            goto Cleanup;
        }
    }
    else
    {
        fprintf(stderr, "Error: Access was not successfully obtained for the private key.\n");
        fprintf(stderr, "       This can only be done by the user who installed the certificate.\n\n");
        goto Cleanup;
    }

    switch (eCommand)
    {
    case ARGS_ADD_PRIVATE_KEY_ACCESS:
    case ARGS_REMOVE_PRIVATE_KEY_ACCESS:

        if (pDacl == NULL)
        {
            fprintf(stdout, "OPERATION FAILED\n"
                            "The Discretionary Access Control List (DACL) for this object is a NULL DACL.  "
                            "This implies everyone has full access to this object.  This NULL DACL could be"
                            "in place because the system is running on a filesystem which does not support "
                            "protected files (such as the FAT32 filesystem)"
                            "\n");
            dwError = ERROR_SUCCESS;
            goto Cleanup;
        }

        if (eCommand == ARGS_ADD_PRIVATE_KEY_ACCESS)
            dwError = AddPrivateKeyAccess(pDacl, pSid, &pNewDacl);
        else
            dwError = RemovePrivateKeyAccess(pDacl, pSid);

        // If successful, update the DACL in the security descriptor
        if (ERROR_SUCCESS == dwError)
        {
            SECURITY_DESCRIPTOR_CONTROL sdControl;
            DWORD dwRevision;

            if (!GetSecurityDescriptorControl(pSD, &sdControl, &dwRevision))
            {
                dwError = GetLastError();
                goto Cleanup;
            }

            // initialize a new security descriptor.  
            if(!InitializeSecurityDescriptor(&sd, dwRevision))
            {  
                dwError = GetLastError();
                goto Cleanup;
            } 
 
            // add the ACL to the security descriptor. 
            if(!SetSecurityDescriptorDacl(&sd, 
                                          TRUE,
                                          pNewDacl ? pNewDacl : pDacl, 
                                          FALSE))
            {  
                dwError = GetLastError();
                goto Cleanup;
            }

            // Set descriptor control.
            // API Helper for this exists only on Win2K and up.
            MySetSecurityDescriptorControl(&sd, SE_DACL_PROTECTED, SE_DACL_PROTECTED);

            if (!IsValidSecurityDescriptor(&sd))
            {
                dwError = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }

            if(!CryptSetProvParam(hProv,
                                  PP_KEYSET_SEC_DESCR,
                                  (BYTE*)&sd,
                                  DACL_SECURITY_INFORMATION))
            {
                dwError = GetLastError();
                goto Cleanup;
            }
        }
        break;

    case ARGS_LIST_PRIVATE_KEY_ACCESS:
        DumpAccessAllowedList(pDacl);

        // Don't care about reporting an error here when dumping the list.
        dwError = ERROR_SUCCESS;
        break;

    default:
        // should never be here...do nothing
        break;
    }

Cleanup:
    if (ERROR_SUCCESS != dwError)
    {
        fprintf(stderr,
                "Error: Unable to update security info for key container, error = 0x%X\n\n",
                dwError);
    }
    if (fFreeProv && hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    if (pSD)
    {
        LocalFree(pSD);
    }
    return dwError;
}


DWORD
AddPrivateKeyAccess(PACL pDacl, BYTE *pSid, PACL *ppNewDacl)
{
    WORD wIndex;
    BOOL fFound = FALSE;
    LPVOID pAce = NULL;

    for (wIndex = 0; wIndex < pDacl->AceCount; wIndex++)
    {
        if (GetAce(pDacl, wIndex, &pAce))
        {
            // Should only be an access allowed ace, right?
            if (((ACCESS_ALLOWED_ACE *)pAce)->Header.AceType ==
                ACCESS_ALLOWED_ACE_TYPE)
            {
                if (EqualSid((BYTE *)&(((ACCESS_ALLOWED_ACE *)pAce)->SidStart), pSid))
                {
                    fprintf(stdout, "Private key access has already been granted for account:\n");
                    DumpSid((BYTE *)&(((ACCESS_ALLOWED_ACE *)pAce)->SidStart));
                    fFound = TRUE;
                }
            }
        }
    }

    DWORD dwError = ERROR_SUCCESS;

    if (!fFound)
    {
        fprintf(stdout, "Granting private key access for account:\n");
		DumpSid(pSid);

        if (!AddAccessAllowedAce(pDacl, ACL_REVISION, KEY_ALL_ACCESS, pSid))
        {
            dwError = GetLastError();
            if (ERROR_ALLOTTED_SPACE_EXCEEDED == dwError)
            {
                // Not enough space, so allocate a new dacl,
                // and copy data from the old acl and append new ace.
                WORD wAclSize = pDacl->AclSize + (WORD)GetLengthSid(pSid) +
                                sizeof(ACCESS_ALLOWED_OBJECT_ACE);
            
                dwError = ERROR_SUCCESS;

                // Allocate dacl + sizeof new sid + sizeof largest ace
                *ppNewDacl = (PACL) LocalAlloc(LPTR, wAclSize);

                if (NULL == *ppNewDacl)
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorExit;
                }

                if (!InitializeAcl (*ppNewDacl, wAclSize, pDacl->AclRevision))
                {
                    dwError = GetLastError();
                    LocalFree(*ppNewDacl);
                    *ppNewDacl = NULL;
                    goto ErrorExit;
                }
            
                // Copy all the original ACEs
                for (wIndex = 0; wIndex < pDacl->AceCount; wIndex++)
                {
                    if (GetAce(pDacl, wIndex, &pAce))
                    {
                        if (((ACCESS_ALLOWED_ACE *)pAce)->Header.AceType ==
                            ACCESS_ALLOWED_ACE_TYPE)
                        {
                            if (!AddAccessAllowedAce(*ppNewDacl,
                                                     ACL_REVISION,
                                                     ((ACCESS_ALLOWED_ACE *)pAce)->Mask,
                                                     (BYTE *)&(((ACCESS_ALLOWED_ACE *)pAce)->SidStart)))
                            {
                                dwError = GetLastError();
                                break;
                            }
                        }
                        else
                        {
                            // Should only contain access allowed ACEs,
                            // but we'll handle anyway.
                            if (!AddAccessDeniedAce(*ppNewDacl,
                                                    ACL_REVISION,
                                                    ((ACCESS_DENIED_ACE *)pAce)->Mask,
                                                    (BYTE *)&(((ACCESS_DENIED_ACE *)pAce)->SidStart)))
                            {
                                dwError = GetLastError();
                                break;
                            }
                        }
                    }
                    else
                    {
                        dwError = GetLastError();
                        break;
                    }
                }

                // Check for any errors
                if (wIndex >= pDacl->AceCount)
                {
                    // Try again
                    if (!AddAccessAllowedAce(*ppNewDacl, ACL_REVISION, KEY_ALL_ACCESS, pSid))
                    {
                        dwError = GetLastError();
                    }
                }
                else
                {
                    LocalFree(*ppNewDacl);
                    *ppNewDacl = NULL;
                }
            }
        }
    }

ErrorExit:
    if (ERROR_SUCCESS != dwError)
    {
        fprintf(stderr, "Error: Failed to grant access with error code 0x%X\n\n", dwError);
    }
    return dwError;
}


DWORD
RemovePrivateKeyAccess(PACL pDacl, BYTE *pSid)
{
    WORD wIndex;
    LPVOID pAce = NULL;
    BOOL fFound = FALSE;

    for (wIndex = 0; wIndex < pDacl->AceCount; wIndex++)
    {
        if (GetAce(pDacl, wIndex, &pAce))
        {
            // Should only be an access allowed ace, right?
            if (((ACCESS_ALLOWED_ACE *)pAce)->Header.AceType ==
                ACCESS_ALLOWED_ACE_TYPE)
            {
                if (EqualSid((BYTE *)&(((ACCESS_ALLOWED_ACE *)pAce)->SidStart), pSid))
                {
                    fprintf(stdout, "Removing private key access for account:\n");
                    DumpSid((BYTE *)&(((ACCESS_ALLOWED_ACE *)pAce)->SidStart));
                    if (!DeleteAce(pDacl, wIndex))
                    {
                        // Break on error
                        DWORD dwError = GetLastError();
                        fprintf(stderr,
                                "Error: Failed to remove access with error code 0x%X\n\n",
                                dwError);
                        return dwError;
                    }
                    fFound = TRUE;  // Keep going?  Can there be dupes?
                }
            }
        }
    }
    if (!fFound)
    {
        fprintf(stderr, "Account already does not have access to private key.\n\n");
    }
    return ERROR_SUCCESS;
}


// Wrapper to only set on Win2K and up because the API
// doesn't exist on NT4
BOOL
MySetSecurityDescriptorControl(
  PSECURITY_DESCRIPTOR pSD,
  SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
  SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
)
{
    SETSECURITYDESCRIPTORCONTROL pfnSetSecurityDescriptorControl = NULL;
    HMODULE hModule = NULL;

    hModule = GetModuleHandle("advapi32.dll");
    if (NULL != hModule)
    {
        pfnSetSecurityDescriptorControl = (SETSECURITYDESCRIPTORCONTROL)
                GetProcAddress(hModule,
                               "SetSecurityDescriptorControl");
        if (NULL != pfnSetSecurityDescriptorControl)
        {
            return (*pfnSetSecurityDescriptorControl)(pSD,
                                                      ControlBitsOfInterest,
                                                      ControlBitsToSet);
        }
    }
    return FALSE;
}


VOID
DumpCertInfo(PCCERT_CONTEXT pCertContext)
{
    LPTSTR pszCertName = NULL;
    DWORD cbCertName = 0;

    if (!pCertContext)
        return;

    cbCertName = CertNameToStr(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                               &pCertContext->pCertInfo->Subject,
                               CERT_X500_NAME_STR | CERT_NAME_STR_CRLF_FLAG,
                               NULL,
                               0);

    pszCertName = (LPTSTR) LocalAlloc(LPTR, cbCertName * sizeof(TCHAR) + 1);
    if (!pszCertName)
        return;

    *pszCertName = TEXT('\0');

    if (CertNameToStr(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                      &pCertContext->pCertInfo->Subject,
                      CERT_X500_NAME_STR | CERT_NAME_STR_CRLF_FLAG | CERT_NAME_STR_REVERSE_FLAG,
                      pszCertName,
                      cbCertName))
    {
        fprintf(stdout, "%s\n\n", pszCertName);
    }
}


// Does quick and dirty check for a root cert by testing
// the issuer and issued to fields.
BOOL
CheckForRootCert(PCCERT_CONTEXT pCertContext)
{
    TCHAR   szIssuer[1024] = TEXT("");
    TCHAR   szIssuedTo[1024] = TEXT("");
    DWORD   cbCertName = 1024;

    if (!pCertContext)
        return FALSE;

    CertGetNameString(pCertContext,
                      CERT_NAME_SIMPLE_DISPLAY_TYPE,
                      CERT_NAME_ISSUER_FLAG,
                      NULL,
                      szIssuer,
                      cbCertName);

    CertGetNameString(pCertContext,
                      CERT_NAME_SIMPLE_DISPLAY_TYPE,
                      0,
                      NULL,
                      szIssuedTo,
                      cbCertName);

	return (lstrcmp(szIssuer, szIssuedTo) == 0) ? TRUE : FALSE;
}


int __cdecl main (int argc, char **argv)
{
    ARGS    Args;
    DWORD   dwErr = ERROR_SUCCESS;

    fprintf (stdout,
        "Microsoft (R) WinHTTP Certificate Configuration Tool\n"
        "Copyright (C) Microsoft Corporation 2001.\n\n"
        );
    
    // Discard program argument
    argv++;
    argc--;

    ParseArguments(argc, argv, &Args);

    switch (Args.Command)
    {
    case ARGS_IMPORT_PFX:

        dwErr = ImportPFXFile(&Args);
        break;

    case ARGS_ADD_PRIVATE_KEY_ACCESS:
    case ARGS_REMOVE_PRIVATE_KEY_ACCESS:
    case ARGS_LIST_PRIVATE_KEY_ACCESS:

        dwErr = DoPrivateKeyAccessAction(&Args);
        break;

    case ARGS_HELP:
    default:
        fprintf(stderr,
                "Usage:\n\n"
                "    winhttpcertcfg [-?]  : To view help information\n\n"
                "    winhttpcertcfg [-i PFXFile | -g | -r | -l]\n"
                "                   [-a Account] [-c CertStore] [-s SubjectStr] [-p PFXPassword]\n\n"
                "Note:\n\n"
                "    The user must have sufficient privileges to use this tool,\n"
                "    which likely requires the user to be an administrator and\n"
                "    the same user who installed the client certificate, if it is\n"
                "    already installed.\n\n"
                "Options:\n\n"
                "    To list accounts which have access to the private key for\n"
                "    specified certificate:\n"
                "        winhttpcertcfg -l -c CertLocation -s SubjectStr\n\n"
                "    To grant access to private key for an account with\n"
                "    specified certificate that is already installed:\n"
                "        winhttpcertcfg -g -c CertLocation -s SubjectStr -a Account\n\n"
                "    To import a certificate plus private key from a PFX file:\n"
                "        winhttpcertcfg -i PFXFile -c CertLocation\n\n"
                "    To remove access to private key for an account with\n"
                "    specified certificate:\n"
                "        winhttpcertcfg -r -c CertLocation -s SubjectStr -a Account\n\n"
                "Description of secondary options:\n\n"
                "    -c LOCAL_MACHINE|CURRENT_USER\\CertStore\n\n"
                "    Use LOCAL_MACHINE or CURRENT_USER to designate which\n"
                "    registry branch to use for the location.  The\n"
                "    certificate store can be any installed on the machine.\n"
                "    Typical examples are MY, Root, and TrustedPeople.\n\n"
                "    -a Account\n\n"
                "    User account on the machine being configured.  This could\n"
                "    be a local machine or domain account, such as:\n"
                "    IWAM_TESTMACHINE, TESTUSER, or TESTDOMAIN\\DOMAINUSER.\n\n"
                "    -s SubjectStr\n\n"
                "    Case-insensitive search string for finding the first\n"
                "    enumerated certificate with a subject name that contains\n"
                "    this substring.\n\n"
                "    -p PFXPassword\n\n"
                "    Password to use for importing the certificate and\n"
                "    private key.  This option can only be used with -i.\n\n");
        break;
    }

    if (Args.pwszPFXFile)
        delete [] Args.pwszPFXFile;
    if (Args.pwszCertStore)
        delete [] Args.pwszCertStore;
    if (Args.pwszCertSubject)
        delete [] Args.pwszCertSubject;
    if (Args.pwszPFXPassword)
        delete [] Args.pwszPFXPassword;

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\test\httpcert.cxx ===
// ===========================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1996 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>
#include <winhttp.h>
#include <wincrypt.h>
#define _UNICODE 
#include <tchar.h>

//==============================================================================
//#define GLOBAL_SESSION 1

#ifdef GLOBAL_SESSION
HINTERNET g_hInternet = NULL;
#endif

BOOL g_fCloseOnSSLFailure = FALSE;

#ifndef ASSERT
#define ASSERT( exp ) \
    ((!(exp)) ? \
        DebugBreak() : \
        ((void)0))
#endif

typedef enum
{
    HTTP_INIT = 0,
    HTTP_OPEN = 1,
    HTTP_SEND = 2,
    HTTP_QDA  = 3,
    HTTP_READ = 4,
    HTTP_READ_PASS_SYNC  = 5,
    HTTP_READ_PASS_ASYNC = 6,
    HTTP_READ_FAIL_SYNC  = 7,
    HTTP_READ_FAIL_ASYNC = 8,
    HTTP_SEND_FAIL_SYNC  = 9,
    HTTP_SEND_FAIL_ASYNC = 10
} HTTP_STATE;

typedef struct
{
    HTTP_STATE state;
    BOOL bQDA;
    DWORD dwTotal;
    DWORD_PTR dwResult;
    DWORD dwError;
    HANDLE hEvent;
    DWORD dwSignature;
    BOOL bCallbackDelete;
    BOOL fCallbackClose;
} TestContext;

VOID CALLBACK Callback(IN HINTERNET hInternet, IN DWORD_PTR dwContext,
                           IN DWORD dwStatus, IN LPVOID pvInfo, IN DWORD dwStatusLen)
{
#if 0
    fprintf(stderr, "callback!!!!!! dwStatus %d\n", dwStatus);
#endif

    TestContext* pContext = (TestContext*)dwContext;
    if ((dwStatus == WINHTTP_CALLBACK_STATUS_SECURE_FAILURE) && pContext)
    {
        fprintf(stderr, "\n\tWINHTTP_CALLBACK_STATUS_SECURE_FAILURE, StatusFlags=%x\n", *((LPDWORD) pvInfo));
        if (g_fCloseOnSSLFailure)
        {
            WinHttpCloseHandle(hInternet);
            pContext->fCallbackClose = TRUE;
        }
    }
    else if ((dwStatus == WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE) && pContext)
    {
        ASSERT (pContext->dwSignature == 0);
        if (pContext->bCallbackDelete)
        {
            delete pContext;
            goto end;
        }
        
        DWORD_PTR dwResult = ((LPWINHTTP_ASYNC_RESULT)(pvInfo))->dwResult;
        DWORD dwError = ((LPWINHTTP_ASYNC_RESULT) (pvInfo) )->dwError;

        pContext->dwResult = dwResult;
        pContext->dwError = dwError;
        SetEvent(pContext->hEvent);
#if 0
        OutputDebugString("\n\tWINHTTP_STATUS_REQUEST_COMPLETE for QDA\n");
		fprintf(stderr, "\n\tWINHTTP_STATUS_REQUEST_COMPLETE for QDA with %d result and %d error.\n", dwResult, dwBytes);
#endif
    }
    else if ((dwStatus == WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING) && pContext)
    {
        // We aborted the connection due to an SSL failure.
        // Time to wake up.
        SetEvent(pContext->hEvent);
    }

end:
    return;
}

#define CHECK_ERROR(cond, err) if (!(cond)) {pszErr=(err); goto done;}

//==============================================================================
int RequestLoop (int argc, char **argv)
{
#ifndef GLOBAL_SESSION
    HINTERNET g_hInternet = NULL;
#endif
    HINTERNET hConnect  = NULL;
    HINTERNET hRequest  = NULL;

    DWORD   dwAccessType   = WINHTTP_ACCESS_TYPE_DEFAULT_PROXY;
    WCHAR   szProxyServer[256];
    WCHAR   szProxyBypass[256];

    DWORD dwConnectFlags = 0;
    BOOL fPreAuth = FALSE;
    BOOL fEnableRevocation = FALSE;
    DWORD dwEnableFlags = WINHTTP_ENABLE_SSL_REVOCATION;

    PSTR pPostData = NULL;
    DWORD cbPostData = 0;
    
    PSTR pszErr = NULL;
    BOOL fRet;
    DWORD dwErr = ERROR_SUCCESS;

    DWORD dwTarget = WINHTTP_AUTH_TARGET_SERVER;
    LPVOID pAuthParams = NULL;

    DWORD option = WINHTTP_OPTION_RESOLVE_TIMEOUT;
    DWORD dwTimeout = 1000;
    HANDLE hEvent = NULL;

    PSTR pszObject   = NULL;
    PSTR pszPostFile = NULL;
    char pszHost[128];
    PSTR pszColon    = NULL;
    BOOL bDeleteContext = TRUE;

    HCERTSTORE hMyStore = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    WCHAR szCertName[256];
    DWORD dwErrorMask;
    
    szCertName[0] = L'\0';

    TestContext* pContext = new TestContext();
    CHECK_ERROR(pContext, "new TestContext");
    
    memset(pContext, 0, sizeof(TestContext));

    g_fCloseOnSSLFailure = FALSE;
    
    // Parse options.
    while (argc && argv[0][0] == '-')
    {
        switch (tolower(argv[0][1]))
        {
            case 'p':
                dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
                dwTarget = WINHTTP_AUTH_TARGET_PROXY;
                ::MultiByteToWideChar(CP_ACP, 0, argv[1],   -1, &szProxyServer[0], 256);
                // pszProxyServer = argv[1];
                ::MultiByteToWideChar(CP_ACP, 0, "<local>", -1, &szProxyBypass[0], 256);
                // pszProxyBypass = "<local>";
                argv++;
                argc--;
                break;

            case 'c':
                ::MultiByteToWideChar(CP_ACP, 0, argv[1],  -1, &szCertName[0], 256);
                argv++;
                argc--;
                break;

            case 's':
                dwConnectFlags = WINHTTP_FLAG_SECURE;
                break;

            case 'r':
                fEnableRevocation = TRUE;
                break;

            case 'd':
                g_fCloseOnSSLFailure = TRUE;
                break;

            case 'a':
                fPreAuth = TRUE;
                break;

            default:
                fprintf (stderr, "\nUsage: [-p <proxy>] [-s] [-c CERT_FIND_SUBJECT_STR] <host>[:port] [<object> [<POST-file>]]");
                fprintf (stderr, "\n   -s: use secure sockets layer");
                fprintf (stderr, "\n   -p: specify proxy server. (\"<local>\" assumed for bypass.)");
                fprintf (stderr, "\n   -c: Use CERT_FIND_SUBJECT_STR to find cert context when client auth needed");
                fprintf (stderr, "\n   -r: Enable certificate revocation checking");
                fprintf (stderr, "\n   -d: CloseHandle on SSL failure");
                exit (1);
        }
        
        argv++;
        argc--;
    }

    // Parse host:port
    {
        int nlen = strlen(argv[0]);
        if (nlen > sizeof(pszHost))
            goto done;
        strcpy(pszHost, argv[0]);
    }
    
    DWORD dwPort;
    pszColon = strchr(pszHost, ':');
    if (!pszColon)
        dwPort = INTERNET_DEFAULT_PORT;
    else
    {
        *pszColon++ = 0;
        dwPort = atol (pszColon);
    }

    pszObject   = argc >= 2 ? argv[1] : "/";
    pszPostFile = argc >= 3 ? argv[2] : NULL;

    // Read any POST data into a buffer.
    if (pszPostFile)
    {
        HANDLE hf =
            CreateFile
            (
                pszPostFile,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
            );
        if (hf != INVALID_HANDLE_VALUE)
        {
            cbPostData = GetFileSize (hf, NULL);
            pPostData = (PSTR) LocalAlloc (LMEM_FIXED, cbPostData + 1);
            if (pPostData)
                ReadFile (hf, pPostData, cbPostData, &cbPostData, NULL);
            pPostData[cbPostData] = 0;
            CloseHandle (hf);
        }
    }

    // Initialize wininet.
#ifdef GLOBAL_SESSION
    if (!g_hInternet)
#endif
        g_hInternet = WinHttpOpen
        (
            _T("HttpAuth Sample"),            // user agent
            // "Mozilla/4.0 (compatible; MSIE 4.0b2; Windows 95",
            dwAccessType,                 // access type
            dwAccessType == WINHTTP_ACCESS_TYPE_NAMED_PROXY ? szProxyServer : NULL, // proxy server
            dwAccessType == WINHTTP_ACCESS_TYPE_NAMED_PROXY ? szProxyBypass : NULL, // proxy bypass
            WINHTTP_FLAG_ASYNC          // flags
        );
    CHECK_ERROR (g_hInternet, "WinHttpOpen");


    WCHAR szHost[256];
    ::MultiByteToWideChar(CP_ACP, 0, pszHost,   -1, &szHost[0], 256);

    WinHttpSetStatusCallback(g_hInternet, Callback, WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS, NULL);

    dwTimeout = 1000;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_RESOLVE_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );

    dwTimeout = 1000;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_CONNECT_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );

    dwTimeout = 100;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_SEND_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );
    
    dwTimeout = 10000;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_RECEIVE_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );

    hEvent = CreateEvent(NULL, FALSE /*want auto-reset*/, FALSE /*non-signaled init.*/, NULL);

    CHECK_ERROR(hEvent, "CreateEvent");

    pContext->hEvent = hEvent;
  
    // Connect to host.
    hConnect = WinHttpConnect
    (
        g_hInternet,                    // session handle,
        szHost,                      // host
        (INTERNET_PORT) dwPort,       // port
        0                // flags
    );
    CHECK_ERROR (hConnect, "WinHttpConnect");

    WCHAR szObject[256];
    ::MultiByteToWideChar(CP_ACP, 0, pszObject,   -1, &szObject[0], 256);

    // Create request.
    
    pContext->state = HTTP_OPEN;
    hRequest = WinHttpOpenRequest
    (
        hConnect,                     // connect handle
        pszPostFile? _T("POST") : _T("GET"),  // request method
        szObject,                    // object name
        NULL,                         // version
        NULL,                         // referer
        NULL,                         // accept types
        dwConnectFlags                // flags
    );
    CHECK_ERROR (hRequest, "WinHttpOpenRequest");

    if (fEnableRevocation)
    {
        WinHttpSetOption(hRequest,
                         WINHTTP_OPTION_ENABLE_FEATURE,
                         (LPVOID)&dwEnableFlags,
                         sizeof(dwEnableFlags));
    }

try_again:
    // Send request.
    pContext->state = HTTP_SEND;
    fRet = WinHttpSendRequest
    (
        hRequest,                     // request handle
        _T(""),                       // header string
        0,                            // header length
        pPostData,                    // post data
        cbPostData,                   // post data length
        cbPostData,                   // total post length
        (DWORD_PTR) pContext          // flags
    );

    if (!fRet)
    {
        dwErr = GetLastError();
        switch (dwErr)
        {
            case ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED:
                break;

            case ERROR_IO_PENDING:
                fRet = WinHttpReceiveResponse(hRequest, NULL);
                if (!fRet)
                {
                    dwErr = GetLastError();
                    if (dwErr != ERROR_IO_PENDING)
                    {
                        fprintf (stderr, "WinHttpReceiveResponse failed err=%d\n", dwErr);
                        break;
                    }
                }
                goto async;
                
            default:
                fprintf (stderr, "HttpSendRequest failed err=%d\n", dwErr);
        }
        pContext->state = HTTP_SEND_FAIL_SYNC;
        goto done;
    }
    else
    {
        fRet = WinHttpReceiveResponse(hRequest, NULL);
        if (!fRet)
        {
            dwErr = GetLastError();
            fprintf (stderr, "WinHttpReceiveResponse failed err=%d\n", dwErr);
            pContext->state = HTTP_SEND_FAIL_SYNC;
        }
        goto sync;
    }

async:
    fRet = WinHttpReceiveResponse(hRequest, NULL);

    if (!fRet)
    {
        DWORD dwErr = GetLastError();

        if (dwErr != ERROR_IO_PENDING)
        {
            fprintf(stderr, "WinHttpReceiveResponse failed err=%d\n", dwErr);
            pContext->state = HTTP_SEND_FAIL_SYNC;
            goto done;
        }
    }

#if 0
    fprintf(stderr, "\nERROR_IO_PENDING on HSR...\n");
#endif
    WaitForSingleObject(hEvent, INFINITE);

    ASSERT( pContext->state == HTTP_SEND );

    if (pContext->dwError == ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED)
    {
        if (szCertName[0])
        {
            hMyStore = CertOpenSystemStore(0, TEXT("MY"));
            if (hMyStore)
            {
                pCertContext = CertFindCertificateInStore(hMyStore,
                                                          X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                          0,
                                                          CERT_FIND_SUBJECT_STR,
                                                          (LPVOID) szCertName,
                                                          NULL);
                if (pCertContext)
                {
                    WinHttpSetOption(hRequest,
                                     WINHTTP_OPTION_CLIENT_CERT_CONTEXT,
                                     (LPVOID) pCertContext,
                                     sizeof(CERT_CONTEXT));
                    CertFreeCertificateContext(pCertContext);
                }
                CertCloseStore(hMyStore, 0);
                goto try_again;
            }
        }
    }

    if (! (pContext->dwResult) )
    {
        pContext->state = HTTP_SEND_FAIL_ASYNC;
        SetLastError (pContext->dwError);
        goto done;
    }

sync:
    
    fRet = WinHttpReceiveResponse(hRequest, NULL);

    if (!fRet)
    {
        DWORD dwErr = GetLastError();

        if (dwErr != ERROR_IO_PENDING)
        {
            fprintf(stderr, "WinHttpReceiveResponse failed err=%d\n", dwErr);
            pContext->state = HTTP_SEND_FAIL_SYNC;
            goto done;
        }
    }
    // Get status code.
    DWORD dwStatus, cbStatus;
    cbStatus = sizeof(dwStatus);
    WinHttpQueryHeaders
    (
        hRequest,
        WINHTTP_QUERY_FLAG_NUMBER | WINHTTP_QUERY_STATUS_CODE,
        NULL,
        &dwStatus,
        &cbStatus,
        NULL
    );
    fprintf (stderr, "Status: %d\n", dwStatus);

    // Dump some bytes.
    BYTE bBuf[1024];
    DWORD cbBuf;

#define QDA 1
#ifdef QDA
    while (TRUE)
    {
        BOOL bAsyncRead = FALSE;
        pContext->state = HTTP_QDA;
        fRet = WinHttpQueryDataAvailable (hRequest, &(pContext->dwError));
        
        if (!fRet)
        {
            if (GetLastError() == ERROR_IO_PENDING)
            {
#if 0
                OutputDebugString("\nERROR_IO_PENDING on QDA\n");
                fprintf(stderr, "\nERROR_IO_PENDING on QDA...\n");
#endif
                WaitForSingleObject(hEvent, INFINITE);
                
                ASSERT (pContext->state = HTTP_QDA);
                if (!(pContext->dwResult))
                {
                    // Done
                    pContext->state = HTTP_READ_FAIL_ASYNC;
                    SetLastError(pContext->dwError);
                    goto done;
                }
                else if (!(pContext->dwError))
                {
                    pContext->state = HTTP_READ_PASS_ASYNC;
                    goto done;
                }
                bAsyncRead = TRUE;
            }
            else
            {
                pContext->state = HTTP_READ_FAIL_SYNC;
                goto done;
            }
        }
        else if (!(pContext->dwError))
        {
            //Done sync
            pContext->state = HTTP_READ_PASS_SYNC;
            goto done;
        }
            
        DWORD dwRead = pContext->dwError;
        DWORD dwActuallyRead = 0;
        while (dwRead > 0)
        {
            cbBuf = (dwRead > sizeof(bBuf)) ? sizeof(bBuf) : dwRead;
            pContext->state = HTTP_READ;
            fRet = WinHttpReadData(hRequest, bBuf, cbBuf, &dwActuallyRead);

            if (!fRet)
            {
                ASSERT ( GetLastError() != ERROR_IO_PENDING );
                fprintf(stderr, "\nError in WinHttpReadData = %d\n", GetLastError());
                goto done;
            }
            ASSERT((cbBuf == dwActuallyRead));
#if 0
            ASSERT(fRet);
            fwrite (bBuf, 1, dwActuallyRead, stdout);
#endif
            pContext->dwTotal += dwActuallyRead;
            dwRead -= dwActuallyRead;
        }    
    }
#else
    cbBuf = sizeof(bBuf);
    while (WinHttpReadData (hRequest, bBuf, cbBuf, &(pContext->dwRead)) && pContext->dwRead)
        fwrite (bBuf, 1, pContext->dwRead, stdout);
#endif

done: // Clean up.

    if (pszErr)
        fprintf (stderr, "Failed on %s, last error %d\n", pszErr, GetLastError());
    if (hRequest)
        WinHttpCloseHandle (hRequest);
    if (hConnect)
        WinHttpCloseHandle (hConnect);
        
#ifndef GLOBAL_SESSION
    if (g_hInternet)
        WinHttpCloseHandle (g_hInternet);
#endif

    if (pPostData)
        LocalFree (pPostData);
    if (hEvent)
        CloseHandle(hEvent);
    if (pContext && bDeleteContext)
    {
        pContext->dwSignature = 0x41414141;
        delete pContext;
    }
        
    return 0;
}

//==============================================================================
void ParseArguments 
(
    LPSTR  InBuffer,
    LPSTR* CArgv,
    DWORD* CArgc
)
{
    LPSTR CurrentPtr = InBuffer;
    DWORD i = 0;
    DWORD Cnt = 0;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr == ' ' ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        CArgv[i++] = CurrentPtr;

        //
        // go to next space.
        //

        while(  (*CurrentPtr != '\0') &&
                (*CurrentPtr != '\n') ) {
            if( *CurrentPtr == '"' ) {      // Deal with simple quoted args
                if( Cnt == 0 )
                    CArgv[i-1] = ++CurrentPtr;  // Set arg to after quote
                else
                    *CurrentPtr = '\0';     // Remove end quote
                Cnt = !Cnt;
            }
            if( (Cnt == 0) && (*CurrentPtr == ' ') ||   // If we hit a space and no quotes yet we are done with this arg
                (*CurrentPtr == '\0') )
                break;
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        *CurrentPtr++ = '\0';
    }

    *CArgc = i;
    return;
}


DWORD WINAPI WorkThread1(LPVOID lpParameter)
{
    int nCount = 0;
    char* pargv[] = {"dennisch", "venkatk/large.html", 0};

    while (nCount++ < 500000)
    {
        fprintf (stderr, "\nLARGE Iteration #%d\n", nCount);
        RequestLoop( 2, pargv);
    }

    fprintf (stderr, "\nLARGE DONE!\n");

    return 0;
}
DWORD WINAPI WorkThread2(LPVOID lpParameter)
{
    int nCount = 0;
    char* pargv[] = {"dennisch", "venkatk/small.html", 0};

    while (nCount++ < 1000000)
    {
        fprintf (stderr, "\nSMALL Iteration #%d\n", nCount);
        RequestLoop( 2, pargv);
    }

    fprintf (stderr, "\nSMALL DONE!\n");

    return 0;
}
DWORD WINAPI WorkThread3(LPVOID lpParameter)
{
    int nCount = 0;
    char* pargv[] = {"venkatk:180", 0};

    while (nCount++ < 1000)
    {
        fprintf (stderr, "\n180 Iteration #%d\n", nCount);
        RequestLoop( 1, pargv);
    }

    fprintf (stderr, "\n180 DONE!\n");

    return 0;
}

//==============================================================================
int __cdecl main (int argc, char **argv)
{
    char * port;
    int nCount = 0;
    // Discard program arg.
    argv++;
    argc--;


/*
#if 1
    DWORD dwThreadId;    
    HANDLE hThread1 = CreateThread(NULL, 0, &WorkThread1,
                                   NULL, 0, &dwThreadId);
    Sleep(1000);
    HANDLE hThread2 = CreateThread(NULL, 0, &WorkThread2,
                                   NULL, 0, &dwThreadId);
    HANDLE hThread3 = CreateThread(NULL, 0, &WorkThread3,
                                   NULL, 0, &dwThreadId);

    {
        char* pargv[] = {"pmidge", 0};

        while (nCount++ < 1000000)
        {
            fprintf (stderr, "\nPMIDGE Iteration #%d\n", nCount);
            RequestLoop( 1, pargv);
        }

        fprintf (stderr, "\n180 DONE!\n");
    }

    WaitForSingleObject( hThread1, INFINITE );
    WaitForSingleObject( hThread2, INFINITE );
    WaitForSingleObject( hThread3, INFINITE );
#endif

#if 0
    char* argv_large[] = {"dennisch", "venkatk/large.html", 0};
    char* argv_small[] = {"dennisch", "venkatk/small.html", 0};
    char* argv_delay[] = {"venkatk:180", 0};

    while(nCount++ < 30)
    {
        RequestLoop( 1, argv_delay );
    }
    
    while(nCount++ < 100)
    {
#if 0
        fprintf (stderr, "\nIteration #%d\n", nCount);
#endif
        RequestLoop( 2, argv_large);
        RequestLoop( 2, argv_small);
        RequestLoop( 1, argv_delay);
    }
#endif
    fprintf (stderr, "\nIteration #%d\n", nCount);

*/
    if (argc)
        RequestLoop (argc, argv);
        
    else // Enter command prompt loop
    {
        fprintf (stderr, "\nUsage: [-p <proxy>] [-s] [-c CERT_FIND_SUBJECT_STR] <host>[:port] [<object> [<POST-file>]]");
        fprintf (stderr, "\n   -s: use secure sockets layer");
        fprintf (stderr, "\n   -p: specify proxy server. (\"<local>\" assumed for bypass.)");
        fprintf (stderr, "\n   -c: Use CERT_FIND_SUBJECT_STR to find cert context when client auth needed");
        fprintf (stderr, "\n   -r: Enable certificate revocation checking");
        fprintf (stderr, "\n   -d: CloseHandle on SSL failure");
        fprintf (stderr, "\nTo exit input loop, enter no params");

        while (1)
        {
            char szIn[1024];
            DWORD argcIn;
            LPSTR argvIn[10];

            fprintf (stderr, "\nhttpauth> ");
            gets (szIn);
            
            argcIn = 0;
            ParseArguments (szIn, argvIn, &argcIn);
            if (!argcIn)
                break;
            RequestLoop (argcIn, argvIn);
            //g_cbRead=0;
        }                
    }

#ifdef GLOBAL_SESSION
    if (g_hInternet)
        WinHttpCloseHandle (g_hInternet);
    g_hInternet = NULL;
#endif

    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\test\httpsimple.cxx ===
// ===========================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1996 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>
#include <winhttp.h>
#define _UNICODE 
#include <tchar.h>

//==============================================================================
#define GLOBAL_SESSION 1

#ifdef GLOBAL_SESSION
HINTERNET g_hInternet = NULL;
#endif

#ifndef ASSERT
#define ASSERT( exp ) \
    ((!(exp)) ? \
        DebugBreak() : \
        ((void)0))
#endif

typedef enum
{
    HTTP_INIT = 0,
    HTTP_OPEN = 1,
    HTTP_SEND = 2,
    HTTP_QDA  = 3,
    HTTP_READ = 4,
    HTTP_READ_PASS_SYNC  = 5,
    HTTP_READ_PASS_ASYNC = 6,
    HTTP_READ_FAIL_SYNC  = 7,
    HTTP_READ_FAIL_ASYNC = 8,
    HTTP_SEND_FAIL_SYNC  = 9,
    HTTP_SEND_FAIL_ASYNC = 10
} HTTP_STATE;

typedef struct
{
    HTTP_STATE state;
    BOOL bQDA;
    DWORD dwTotal;
    DWORD_PTR dwResult;
    DWORD dwError;
    HANDLE hEvent;
    DWORD dwSignature;
    BOOL bCallbackDelete;
    DWORD dwRead; //for non-QDA i.e. plain WinHttpReadData
} TestContext;

VOID CALLBACK Callback(IN HINTERNET hInternet, IN DWORD_PTR dwContext,
                           IN DWORD dwStatus, IN LPVOID pvInfo, IN DWORD dwStatusLen)
{
#if 0
    fprintf(stderr, "callback!!!!!! dwStatus %d\n", dwStatus);
#endif

    TestContext* pContext = (TestContext*)dwContext;
    if ((dwStatus == WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE) && pContext)
    {
        ASSERT (pContext->dwSignature == 0);
        if (pContext->bCallbackDelete)
        {
            delete pContext;
            goto end;
        }
        
        DWORD_PTR dwResult = ((LPWINHTTP_ASYNC_RESULT)(pvInfo))->dwResult;
        DWORD dwError = ((LPWINHTTP_ASYNC_RESULT) (pvInfo) )->dwError;

        pContext->dwResult = dwResult;
        pContext->dwError = dwError;
        SetEvent(pContext->hEvent);
#if 0
        OutputDebugString("\n\tWINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE for QDA\n");
		fprintf(stderr, "\n\tWINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE for QDA with %d result and %d error.\n", dwResult, dwBytes);
#endif
    }

end:
    return;
}

#define CHECK_ERROR(cond, err) if (!(cond)) {pszErr=(err); goto done;}

//==============================================================================
int RequestLoop (int argc, char **argv)
{
#ifndef GLOBAL_SESSION
    HINTERNET g_hInternet = NULL;
#endif
    HINTERNET hConnect  = NULL;
    HINTERNET hRequest  = NULL;

    DWORD   dwAccessType   = WINHTTP_ACCESS_TYPE_DEFAULT_PROXY;
    WCHAR   szProxyServer[256];
    WCHAR   szProxyBypass[256];

    DWORD dwConnectFlags = 0;
    BOOL fPreAuth = FALSE;

    PSTR pPostData = NULL;
    DWORD cbPostData = 0;
    
    PSTR pszErr = NULL;
    BOOL fRet;
    DWORD dwErr = ERROR_SUCCESS;

    DWORD dwTarget = WINHTTP_AUTH_TARGET_SERVER;
    LPVOID pAuthParams = NULL;

    DWORD option = WINHTTP_OPTION_RESOLVE_TIMEOUT;
    DWORD dwTimeout = 10000;
    HANDLE hEvent = NULL;

    PSTR pszObject   = NULL;
    PSTR pszPostFile = NULL;
    char pszHost[128];
    PSTR pszColon    = NULL;
    BOOL bDeleteContext = TRUE;

    TestContext* pContext = new TestContext();
    CHECK_ERROR(pContext, "new TestContext");
    
    memset(pContext, 0, sizeof(TestContext));
    
    // Parse options.
    while (argc && argv[0][0] == '-')
    {
        switch (tolower(argv[0][1]))
        {
            case 'p':
                dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
                dwTarget = WINHTTP_AUTH_TARGET_PROXY;
                ::MultiByteToWideChar(CP_ACP, 0, argv[1],   -1, &szProxyServer[0], 256);
                // pszProxyServer = argv[1];
                ::MultiByteToWideChar(CP_ACP, 0, "<local>", -1, &szProxyBypass[0], 256);
                // pszProxyBypass = "<local>";
                argv++;
                argc--;
                break;

            case 's':
                dwConnectFlags = WINHTTP_FLAG_SECURE;
                break;

            case 'a':
                fPreAuth = TRUE;
                break;

            default:
                fprintf (stderr, "\nUsage: httpauth [-p <proxy>] [-s] <server> [<object> [<user> [<pass> [<POST-file>]]]]");
                fprintf (stderr, "\n  -s: Secure connection (ssl or pct)");
                fprintf (stderr, "\n  -p: specify proxy server. (\"<local>\" assumed for bypass.)");
                exit (1);
        }
        
        argv++;
        argc--;
    }

    // Parse host:port
    {
        int nlen = strlen(argv[0]);
        if (nlen > sizeof(pszHost))
            goto done;
        strcpy(pszHost, argv[0]);
    }
    
    DWORD dwPort;
    pszColon = strchr(pszHost, ':');
    if (!pszColon)
        dwPort = INTERNET_DEFAULT_PORT;
    else
    {
        *pszColon++ = 0;
        dwPort = atol (pszColon);
    }

    pszObject   = argc >= 2 ? argv[1] : "/";
    pszPostFile = argc >= 3 ? argv[2] : NULL;

    // Read any POST data into a buffer.
    if (pszPostFile)
    {
        HANDLE hf =
            CreateFile
            (
                pszPostFile,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
            );
        if (hf != INVALID_HANDLE_VALUE)
        {
            cbPostData = GetFileSize (hf, NULL);
            pPostData = (PSTR) LocalAlloc (LMEM_FIXED, cbPostData + 1);
            if (pPostData)
                ReadFile (hf, pPostData, cbPostData, &cbPostData, NULL);
            pPostData[cbPostData] = 0;
            CloseHandle (hf);
        }
    }

    // Initialize wininet.
#ifdef GLOBAL_SESSION
    if (!g_hInternet)
#endif
        g_hInternet = WinHttpOpen
        (
            _T("HttpAuth Sample"),            // user agent
            // "Mozilla/4.0 (compatible; MSIE 4.0b2; Windows 95",
            dwAccessType,                 // access type
            szProxyServer,               // proxy server
            szProxyBypass,               // proxy bypass
            WINHTTP_FLAG_ASYNC          // flags
        );
    CHECK_ERROR (g_hInternet, "WinHttpOpen");


    WCHAR szHost[256];
    ::MultiByteToWideChar(CP_ACP, 0, pszHost,   -1, &szHost[0], 256);

    WinHttpSetStatusCallback(g_hInternet, Callback, WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS, NULL);
    
    WinHttpSetOption(
        g_hInternet,
        option,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );

    dwTimeout = 10000;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_SEND_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );
    
    dwTimeout = 10000;
    WinHttpSetOption(
        g_hInternet,
        WINHTTP_OPTION_RECEIVE_TIMEOUT,
        (LPVOID)&dwTimeout,
        sizeof(DWORD)
    );
    
    hEvent = CreateEvent(NULL, FALSE /*want auto-reset*/, FALSE /*non-signaled init.*/, NULL);

    CHECK_ERROR(hEvent, "CreateEvent");

    pContext->hEvent = hEvent;
  
    // Connect to host.
    hConnect = WinHttpConnect
    (
        g_hInternet,                    // session handle,
        szHost,                      // host
        (INTERNET_PORT) dwPort,       // port
        dwConnectFlags                // flags
    );
    CHECK_ERROR (hConnect, "WinHttpConnect");

    WCHAR szObject[256];
    ::MultiByteToWideChar(CP_ACP, 0, pszObject,   -1, &szObject[0], 256);

    // Create request.
    
    pContext->state = HTTP_OPEN;
    hRequest = WinHttpOpenRequest
    (
        hConnect,                     // connect handle
        pszPostFile? _T("POST") : _T("GET"),  // request method
        szObject,                    // object name
        NULL,                         // version
        NULL,                         // referer
        NULL,                         // accept types
        dwConnectFlags                // flags
    );
    CHECK_ERROR (hRequest, "WinHttpOpenRequest");

    // Send request.
    pContext->state = HTTP_SEND;
    fRet = WinHttpSendRequest
    (
        hRequest,                     // request handle
        _T(""),                       // header string
        0,                            // header length
        pPostData,                    // post data
        cbPostData,                   // post data length
        cbPostData,                   // total post length
        (DWORD_PTR)pContext             // context
    );

    if (!fRet)
    {
        dwErr = GetLastError();
        switch (dwErr)
        {
            case ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED:
                break;

            case ERROR_IO_PENDING:
                fRet = WinHttpReceiveResponse(hRequest, NULL);
                if (!fRet)
                {
                    dwErr = GetLastError();
                    fprintf (stderr, "WinHttpReceiveResponse failed err=%d\n", dwErr);
                    break;
                }
                goto async;
                
            default:
                fprintf (stderr, "HttpSendRequest failed err=%d\n", dwErr);
        }
        pContext->state = HTTP_SEND_FAIL_SYNC;
        goto done;
    }
    else
    {
        fRet = WinHttpReceiveResponse(hRequest, NULL);
        if (!fRet)
        {
            dwErr = GetLastError();
            fprintf (stderr, "WinHttpReceiveResponse failed err=%d\n", dwErr);
            pContext->state = HTTP_SEND_FAIL_SYNC;
        }
        goto sync;
    }

async:
#if 0
    fprintf(stderr, "\nERROR_IO_PENDING on HSR...\n");
#endif
    WaitForSingleObject(hEvent, INFINITE);

    ASSERT( pContext->state == HTTP_SEND );
    if (! (pContext->dwResult) )
    {
        pContext->state = HTTP_SEND_FAIL_ASYNC;
        SetLastError (pContext->dwError);
        goto done;
    }
sync:
    
    // Get status code.
    DWORD dwStatus, cbStatus;
    cbStatus = sizeof(dwStatus);
    WinHttpQueryHeaders
    (
        hRequest,
        WINHTTP_QUERY_FLAG_NUMBER | WINHTTP_QUERY_STATUS_CODE,
        NULL,
        &dwStatus,
        &cbStatus,
        NULL
    );
    fprintf (stderr, "Status: %d\n", dwStatus);

    // Dump some bytes.
    BYTE bBuf[1024];
    DWORD cbBuf;

//#define QDA 1
#ifdef QDA
    while (TRUE)
    {
        BOOL bAsyncRead = FALSE;
        pContext->state = HTTP_QDA;
        fRet = WinHttpQueryDataAvailable (hRequest, &(pContext->dwError));//(DWORD_PTR)pContext);
        
        if (!fRet)
        {
            if (GetLastError() == ERROR_IO_PENDING)
            {
#if 0
                OutputDebugString("\nERROR_IO_PENDING on QDA\n");
                fprintf(stderr, "\nERROR_IO_PENDING on QDA...\n");
#endif
                WaitForSingleObject(hEvent, INFINITE);
                
                ASSERT (pContext->state = HTTP_QDA);
                if (!(pContext->dwResult))
                {
                    // Done
                    pContext->state = HTTP_READ_FAIL_ASYNC;
                    SetLastError(pContext->dwError);
                    goto done;
                }
                else if (!(pContext->dwError))
                {
                    pContext->state = HTTP_READ_PASS_ASYNC;
                    goto done;
                }
                bAsyncRead = TRUE;
            }
            else
            {
                pContext->state = HTTP_READ_FAIL_SYNC;
                goto done;
            }
        }
        else if (!(pContext->dwError))
        {
            //Done sync
            pContext->state = HTTP_READ_PASS_SYNC;
            goto done;
        }
            
        DWORD dwRead = pContext->dwError;
        DWORD dwActuallyRead = 0;
        while (dwRead > 0)
        {
            cbBuf = (dwRead > sizeof(bBuf)) ? sizeof(bBuf) : dwRead;
            pContext->state = HTTP_READ;
            fRet = WinHttpReadData(hRequest, bBuf, cbBuf, &dwActuallyRead);

            if (!fRet)
            {
                ASSERT ( GetLastError() != ERROR_IO_PENDING );
                fprintf(stderr, "\nError in WinHttpReadData = %d\n", GetLastError());
                goto done;
            }
            ASSERT((cbBuf == dwActuallyRead));
#if 0
            ASSERT(fRet);
            fwrite (bBuf, 1, dwActuallyRead, stdout);
#endif
            pContext->dwTotal += dwActuallyRead;
            dwRead -= dwActuallyRead;
        }    
    }
#else
/*
    cbBuf = sizeof(bBuf);
    while (WinHttpReadData (hRequest, bBuf, cbBuf, &(pContext->dwRead)) && pContext->dwRead)
        fwrite (bBuf, 1, pContext->dwRead, stdout);
 */
    cbBuf = sizeof(bBuf);

    while (TRUE)
    {
        pContext->state = HTTP_READ;
        fRet = WinHttpReadData (hRequest, bBuf, cbBuf, &(pContext->dwRead));
        
        if (!fRet)
        {
            if (GetLastError() == ERROR_IO_PENDING)
            {
#if 0
                OutputDebugString("\nERROR_IO_PENDING on READ\n");
                fprintf(stderr, "\nERROR_IO_PENDING on RD...\n");
#endif
                WaitForSingleObject(hEvent, INFINITE);
                
                ASSERT (pContext->state = HTTP_READ);
                if (!(pContext->dwResult))
                {
                    // Done
                    pContext->state = HTTP_READ_FAIL_ASYNC;
                    SetLastError(pContext->dwError);
                    goto done;
                }
                else if (!(pContext->dwRead))
                {
                    pContext->state = HTTP_READ_PASS_ASYNC;
                    goto done;
                }
                pContext->dwTotal += pContext->dwRead;
                //bAsyncRead = TRUE;
            }
            else
            {
                pContext->state = HTTP_READ_FAIL_SYNC;
                goto done;
            }
        }
        else if (!(pContext->dwError))
        {
            //Done sync
            pContext->dwTotal += pContext->dwRead;
            pContext->state = HTTP_READ_PASS_SYNC;
            goto done;
        }
        else
        {
            //finished this call sync but not done.
            pContext->dwTotal += pContext->dwRead;
        }
    }
#endif

done: // Clean up.
    if (pContext && TRUE)
    {
        fprintf (stderr, "EndOfRequest: pContext=0x%x\n\t:State: %d\n\t:Result: 0x%x\n"
                         "\t:Error: 0x%x [%d]\n\t:Total: 0x%x [%d]\n",
                         pContext,
                         pContext->state,
                         pContext->dwResult,
                         pContext->dwError, pContext->dwError,
                         pContext->dwTotal, pContext->dwTotal
                );
    }
    if (pszErr)
        fprintf (stderr, "Failed on %s, last error %d\n", pszErr, GetLastError());
    if (hRequest)
        WinHttpCloseHandle (hRequest);
    if (hConnect)
        WinHttpCloseHandle (hConnect);
        
#ifndef GLOBAL_SESSION
    if (g_hInternet)
        WinHttpCloseHandle (g_hInternet);
#endif

    if (pPostData)
        LocalFree (pPostData);
    if (hEvent)
        CloseHandle(hEvent);
    if (pContext && bDeleteContext)
    {
        pContext->dwSignature = 0x41414141;
        delete pContext;
    }
        
    return 0;
}

//==============================================================================
void ParseArguments 
(
    LPSTR  InBuffer,
    LPSTR* CArgv,
    DWORD* CArgc
)
{
    LPSTR CurrentPtr = InBuffer;
    DWORD i = 0;
    DWORD Cnt = 0;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr == ' ' ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        CArgv[i++] = CurrentPtr;

        //
        // go to next space.
        //

        while(  (*CurrentPtr != '\0') &&
                (*CurrentPtr != '\n') ) {
            if( *CurrentPtr == '"' ) {      // Deal with simple quoted args
                if( Cnt == 0 )
                    CArgv[i-1] = ++CurrentPtr;  // Set arg to after quote
                else
                    *CurrentPtr = '\0';     // Remove end quote
                Cnt = !Cnt;
            }
            if( (Cnt == 0) && (*CurrentPtr == ' ') ||   // If we hit a space and no quotes yet we are done with this arg
                (*CurrentPtr == '\0') )
                break;
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        *CurrentPtr++ = '\0';
    }

    *CArgc = i;
    return;
}



//==============================================================================
int __cdecl main (int argc, char **argv)
{
	char * port;
	int nCount = 0;
	// Discard program arg.
    argv++;
    argc--;

    char* argv_large[] = {"dennisch", "venkatk/large.html", 0};
    char* argv_small[] = {"dennisch", "venkatk/small.html", 0};
    char* argv_delay[] = {"venkatk:180", 0};

    while(nCount++ < 1)
    {
        RequestLoop( 2, argv_large );
    }
    
    fprintf (stderr, "\nDone\n", nCount);

#if 0
    if (argc)
        RequestLoop (argc, argv);
        
    else // Enter command prompt loop
    {
        fprintf (stderr, "\nUsage: [-p <proxy>] [-s] <host>[:port] [<object> [<POST-file>]]");
        fprintf (stderr, "\n  -s: use secure sockets layer");
        fprintf (stderr, "\n  -p: specify proxy server. (\"<local>\" assumed for bypass.)");
        fprintf (stderr, "\nTo exit input loop, enter no params");

        while (1)
        {
            char szIn[1024];
            DWORD argcIn;
            LPSTR argvIn[10];

            fprintf (stderr, "\nhttpauth> ");
            gets (szIn);
            
            argcIn = 0;
            ParseArguments (szIn, argvIn, &argcIn);
            if (!argcIn)
                break;
            RequestLoop (argcIn, argvIn);
            //g_cbRead=0;
        }                
    }
#endif

#ifdef GLOBAL_SESSION
    if (g_hInternet)
        WinHttpCloseHandle (g_hInternet);
    g_hInternet = NULL;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\inc\dispids.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    dispids.h

Abstract:

    DISPIDs used by the dual-interface components.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __DISPIDS_H__
#define __DISPIDS_H__

#define SCRRUN_DISPID_BASE           100

#define DISPID_SCRRUN_CREATEOBJECT   (SCRRUN_DISPID_BASE + 1)
#define DISPID_SCRRUN_CREATEFORK     (SCRRUN_DISPID_BASE + 2)
#define DISPID_SCRRUN_PUTVALUE       (SCRRUN_DISPID_BASE + 3)
#define DISPID_SCRRUN_GETVALUE       (SCRRUN_DISPID_BASE + 4)
#define DISPID_SCRRUN_VBCREATEOBJECT (SCRRUN_DISPID_BASE + 5)
#define DISPID_SCRRUN_SETUSERID      (SCRRUN_DISPID_BASE + 6)

#endif /* __DISPIDS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\inc\common.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    common.h

Abstract:

    Generates the precompiled header.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#ifndef _COMMON_H_
#define _COMMON_H_


#define _WIN32_WINNT 0x0500
#define _UNICODE
#define UNICODE


//-----------------------------------------------------------------------------
// os includes
//-----------------------------------------------------------------------------
#if defined(__cplusplus)
extern "C" {
#endif

#include <windows.h>
#include <commdlg.h>
#include <advpub.h>
#include <oleauto.h>
#include <objbase.h>
#include <ocidl.h>
#include <olectl.h>
#include <activscp.h>
#include <activdbg.h>
#include <commctrl.h>

#define NO_SHLWAPI_GDI
#define NO_SHLWAPI_STREAM
#define NO_SHLWAPI_REG

#include <shlwapi.h>

#if defined(__cplusplus)
}
#endif


//-----------------------------------------------------------------------------
// project includes
//-----------------------------------------------------------------------------
#include <dispids.h>
#include <scrrun.h>     // generated
#include <resources.h>
#include <hashtable.h>
#include <utils.h>
#include <log.h>
#include <scrobj.h>
#include <spork.h>


//-----------------------------------------------------------------------------
// global functions
//-----------------------------------------------------------------------------
BOOL   GlobalInitialize(PSPORK pSpork, LPSTR szCmdLine);
void   GlobalUninitialize(void);
LPWSTR GlobalGetScriptName(void);
LPWSTR GlobalGetProfileName(void);
BOOL   GlobalIsSilentModeEnabled(void);
BOOL   GlobalIsDebugOutputEnabled(void);


#endif /* _COMMON_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\inc\pch.cxx ===
#include "common.h"

void foobar(void);

void foobar(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\exe\entry.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    entry.cxx

Abstract:

    Application entrypoint for spork.exe.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include "common.h"


int
WINAPI
WinMain(
  HINSTANCE hInstance,
  HINSTANCE hPrevInstance,
  PSTR      szCmdLine,
  int       iCmdShow
  )
{
  HRESULT hr = S_OK;
  PSPORK  ps = NULL;

  if( !IsRunningOnNT() )
  {
    Alert(
      TRUE,
      L"Spork is currently not supported on Win9x.\r\n\r\n" \
      L"If you have an urgent need for Win9x support\r\n" \
      L"please contact pmidge@microsoft.com."
      );

    return 0L;
  }

  hr = LogInitialize();

    if( FAILED(hr) )
      goto quit;

  DEBUG_TRACE((L"*** THIS DEBUG BUILD BROUGHT TO YOU BY THE LETTER \'D\'! ***"));

  hr = SPORK::Create(hInstance, &ps);

    if( FAILED(hr) )
      goto quit;

  if( !GlobalInitialize(ps, szCmdLine) )
  {
    hr = E_FAIL;
    goto quit;
  }

  hr = ps->Run();

quit:

  SAFEDELETE(ps);
  GlobalUninitialize();
  return (DWORD) hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\inc\hashtable.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    hashtable.cxx

Abstract:

    Simple hash table implementation.


Author:

    Paul M Midgen (pmidge) 14-August-2000


Revision History:

    14-August-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include <common.h>

/*++===========================================================================

    An array is separated into N buckets that     +---+
    each contain a pointer to a binary search     | 0 |------> O
    tree. The tree's nodes are indexed by a       +---+       / \
    DWORD identifier to enable speedy traversals. | 1 |      O   O
    The array buckets are indexed by the values   +---+     / \   \
    generated by the hashing function supplied    | 2 |    O   O   O
    by a derived class.                           +---+        
                                                  | N |

    Clients derive a class from the hashtable ADT and specialize it for a 
    given data type. Any data type can be used. The only function the client
    must implement is the GetHashAndBucket function, and their class must
    provide the number of buckets the ADT needs to support. This is usually
    some number that is modulo'd against the generated hashes to yield the
    bucket number.

===========================================================================--*/

#define HT_COMPARE_LARGER  0x00000001
#define HT_COMPARE_SMALLER 0x00000002
#define HT_COMPARE_EQUAL   0x00000003

#define HT_TREE_ROOT       0x00000004
#define HT_TREE_RHSUBTREE  0x00000005
#define HT_TREE_LHSUBTREE  0x00000006

typedef struct _NODE
{
  DWORD  hash;
  DWORD  bucket;
  LPVOID data;
  _NODE* parent;
  _NODE* rh_child;
  _NODE* lh_child;
  BOOL   isLeft;
}
NODE, *PNODE;

typedef VOID (*PFNCLEARFUNC)(LPVOID* ppv);

template <class T> class CHashTable
{
  public:
    CHashTable(DWORD buckets)
    {
      pfnClear  = NULL;
      cBuckets  = buckets;
      arBuckets = new PNODE[buckets];
      InitializeCriticalSection(&csTable);
    }

   ~CHashTable()
    {
      SAFEDELETEBUF(arBuckets);
      DeleteCriticalSection(&csTable);
    }

    virtual void GetHashAndBucket(T id, LPDWORD lpHash, LPDWORD lpBucket) =0;

    DWORD Insert(T id, LPVOID pv);
    DWORD Get(T id, LPVOID* ppv);
    DWORD Delete(T id, LPVOID* ppv);

    void  Clear(void);
    void  SetClearFunction(PFNCLEARFUNC pfn) { pfnClear = pfn; }

  private:
    void  _Get(DWORD hash, PNODE& proot, PNODE& pnode);
    DWORD _Insert(PNODE& proot, PNODE pnew);
    void  _Remove(DWORD hash, PNODE& proot, PNODE& pnode);

    PNODE _NewNode(T id, LPVOID pv);
    DWORD _CompareNodes(DWORD hash_target, DWORD hash_tree);

    BOOL  _HasChildren(PNODE pnode);
    void  _PostTraverseAndDelete(PNODE proot);
    void  _Lock(void)   { EnterCriticalSection(&csTable); }
    void  _Unlock(void) { LeaveCriticalSection(&csTable); }

    PNODE*           arBuckets;
    DWORD            cBuckets;
    CRITICAL_SECTION csTable;
    PFNCLEARFUNC     pfnClear;
};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T> DWORD CHashTable<T>::Insert(T id, LPVOID pv)
{
  DWORD ret = ERROR_SUCCESS;
  PNODE pn  = _NewNode(id, pv);

  _Lock();

    if( pn )
    {
      ret = _Insert(arBuckets[pn->bucket], pn);
    }
    else
    {
      ret = ERROR_OUTOFMEMORY;
    }

  _Unlock();

  return ret;
}

template <class T> DWORD CHashTable<T>::Get(T id, LPVOID* ppv)
{
  DWORD ret    = ERROR_SUCCESS;
  DWORD hash   = 0L;
  DWORD bucket = 0L;
  PNODE pnode  = NULL;

  GetHashAndBucket(id, &hash, &bucket);

  _Lock();

    _Get(hash, arBuckets[bucket], pnode);

    if( pnode )
    {
      *ppv = (void*) pnode->data;
    }
    else
    {
      *ppv = NULL;
      ret  = ERROR_NOT_FOUND;
    }

  _Unlock();

  return ret;
}

template <class T> DWORD CHashTable<T>::Delete(T id, LPVOID* ppv)
{
  DWORD ret   = ERROR_SUCCESS;
  DWORD hash   = 0L;
  DWORD bucket = 0L;
  PNODE pnode = NULL;

  GetHashAndBucket(id, &hash, &bucket);

  _Lock();

    _Remove(hash, arBuckets[bucket], pnode);

    if( pnode )
    {
      if( ppv )
      {
        *ppv = pnode->data;
      }
      else
      {
        if( pfnClear )
        {
          pfnClear(&pnode->data);
        }
      }

      delete pnode;
    }
    else
    {
      ret = ERROR_NOT_FOUND;

      if( ppv )
      {
        *ppv = NULL;
      }
    }

  _Unlock();

  return ret;
}

template <class T> void CHashTable<T>::Clear(void)
{
  _Lock();

    for(DWORD n=0; n < cBuckets; n++)
    {
      if( arBuckets[n] )
      {
        _PostTraverseAndDelete(arBuckets[n]);
        arBuckets[n] = NULL;
      }
    }

  _Unlock();
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T> DWORD CHashTable<T>::_Insert(PNODE& proot, PNODE pnew)
{
  DWORD ret = ERROR_SUCCESS;

  if( pnew )
  {
    if( !proot )
    {
      proot = pnew;
    }
    else
    {
      switch( _CompareNodes(pnew->hash, proot->hash) )
      {
        case HT_COMPARE_SMALLER :
          {
            pnew->isLeft = TRUE;
            pnew->parent = proot;
            ret = _Insert(proot->lh_child, pnew);
          }
          break;

        case HT_COMPARE_LARGER :
          {
            pnew->isLeft = FALSE;
            pnew->parent = proot;
            ret = _Insert(proot->rh_child, pnew);
          }
          break;

        case HT_COMPARE_EQUAL :
          {
            if( pfnClear )
            {
              pfnClear(&proot->data);
            }

            ret         = ERROR_DUP_NAME;
            proot->data = pnew->data;
            delete pnew;
          }
          break;
      }
    }
  }

  return ret;
}

template <class T> void CHashTable<T>::_Get(DWORD hash, PNODE& proot, PNODE& pnode)
{
  if( proot )
  {
    switch( _CompareNodes(hash, proot->hash) )
    {
      case HT_COMPARE_SMALLER :
        {
          _Get(hash, proot->lh_child, pnode);
        }
        break;

      case HT_COMPARE_LARGER :
        {
          _Get(hash, proot->rh_child, pnode);
        }
        break;

      case HT_COMPARE_EQUAL :
        {
          pnode = proot;
        }
        break;
    }
  }
  else
  {
    pnode = NULL;
  }
}

template <class T> void CHashTable<T>::_Remove(DWORD hash, PNODE& proot, PNODE& pnode)
{
  if( proot )
  {
    switch( _CompareNodes(hash, proot->hash) )
    {
      case HT_COMPARE_SMALLER :
        {
          _Remove(hash, proot->lh_child, pnode);
        }
        break;

      case HT_COMPARE_LARGER :
        {
          _Remove(hash, proot->rh_child, pnode);
        }
        break;

      case HT_COMPARE_EQUAL :
        {
          pnode = proot;

          //
          // if proot has no parent it is the tree's root node
          //
          //   - if it has children, promote the left child to root
          //     and insert the right child in the new tree. after
          //     inserting, make sure the new root has no parent.
          //
          //   - if it has no children the tree is empty, set the root
          //     to null
          //

          if( !proot->parent )
          {
            if( _HasChildren(proot) )
            {
              proot = proot->lh_child;
              _Insert(proot, pnode->rh_child);
              proot->parent = NULL;
            }
            else
            {
              proot = NULL;
            }
          }
          else
          {
            if( proot->isLeft )
            {
              proot->parent->lh_child = NULL;
            }
            else
            {
              proot->parent->rh_child = NULL;
            }

            _Insert(pnode->parent, pnode->lh_child);
            _Insert(pnode->parent, pnode->rh_child);
          }
        }
        break;
    }
  }
  else
  {
    pnode = NULL;
  }
}

template <class T> void CHashTable<T>::_PostTraverseAndDelete(PNODE proot)
{
  if( proot )
  {
    _PostTraverseAndDelete(proot->lh_child);
    _PostTraverseAndDelete(proot->rh_child);

    if( pfnClear )
    {
      pfnClear(&proot->data);
    }

    delete proot;
    proot = NULL;
  }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T> DWORD CHashTable<T>::_CompareNodes(DWORD hash_target, DWORD hash_tree)
{
  if( hash_target == hash_tree )
  {
    return HT_COMPARE_EQUAL;
  }
  else if( hash_target < hash_tree )
  {
    return HT_COMPARE_SMALLER;
  }
  else
  {
    return HT_COMPARE_LARGER;
  }
}

template <class T> PNODE CHashTable<T>::_NewNode(T id, LPVOID pv)
{
  PNODE pn = new NODE;

  if( pn )
  {
    GetHashAndBucket(id, &pn->hash, &pn->bucket);
    pn->data = pv;
  }

  return pn;
}

template <class T> BOOL CHashTable<T>::_HasChildren(PNODE pnode)
{
  if( pnode )
  {
    return (pnode->lh_child || pnode->rh_child);
  }
  else
  {
    return FALSE;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\spork.inc ===
!IF 0

Copyright (c) 2001  Microsoft Corporation

!ENDIF

!IFNDEF SDKINC
SDKINC=$(SDK_INC_PATH)
!ENDIF

!IFDEF LIBDIR
!ERROR LIBDIR already defined - choose new name
!ENDIF

ROOT=$(SDXROOT)\inetcore\winhttp\tools\spork
LIBDIR=$(ROOT)\lib\$(_OBJ_DIR)
PROJECTINC=$(ROOT)\inc

#
# if TARGETPATH is not defined (in the paths that build libraries) then this
# is the default target path
#
!IFNDEF TARGETPATH
TARGETPATH=$(LIBDIR)
TARGETTYPE=LIBRARY
!ENDIF

#
# what it is that we're building
#
MAJORCOMP=spork
USE_NOLIBS=1
NO_NTDLL=1
BINPLACE_PLACEFILE=$(ROOT)\binplace.txt

#
# Linker flags
#
WIN32_WINNT_VERSION=0x0500
#WIN32_WIN95_VERSION=0x0400

#
# compiler warning flags
#
MSC_WARNING_LEVEL=/W3 /WX

#
# enable exception handling
#
USE_NATIVE_EH=1

#
# compiler definitions
#
C_DEFINES=$(C_DEFINES) -DWIN32

CLEANINF = cleaninf.exe $(CLEANINF_FLAGS)

#
# Set debugging level
#
!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
C_DEFINES=$(C_DEFINES) -D_DEBUG

!IF "$(_DEBUG_REFCOUNT)" != ""
C_DEFINES=$(C_DEFINES) -D_DEBUG_REFCOUNT
!ENDIF

!ENDIF


!IFNDEF BUILD_PCH
PRECOMPILED_OPTION=/Fp$(ROOT)\inc\$(_OBJ_DIR)\*\common.pch /Yucommon.h
PRECOMPILED_CXX=1
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\inc\log.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    log.h

Abstract:

    Declaration of the session logging routines used by Spork.
    
Author:

    Paul M Midgen (pmidge) 21-February-2001


Revision History:

    21-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


#ifndef __LOG_H__
#define __LOG_H__


//-----------------------------------------------------------------------------
// types internal to the logging routines
//-----------------------------------------------------------------------------
typedef enum _rettype
{
  rt_void,
  rt_bool,
  rt_dword,
  rt_hresult,
  rt_string
}
RETTYPE, *LPRETTYPE;

enum DEPTH
{
  INCREMENT,
  DECREMENT,
  MAINTAIN
};

typedef struct _callinfo
{
  struct _callinfo* next;
  struct _callinfo* last;
  LPCWSTR           fname;
  RETTYPE           rettype;
}
CALLINFO, *LPCALLINFO;

typedef struct _threadinfo
{
  DWORD      threadid;
  DWORD      depth;
  LPCALLINFO stack;
}
THREADINFO, *LPTHREADINFO;


//-----------------------------------------------------------------------------
// public functions
//-----------------------------------------------------------------------------
HRESULT LogInitialize(void);
void    LogTerminate(void);
void    LogEnterFunction(LPCWSTR function, RETTYPE rt, LPCWSTR format, ...);
void    LogLeaveFunction(INT_PTR retval);
void    LogTrace(LPCWSTR format, ...);

void    ToggleDebugOutput(BOOL bEnable);

LPWSTR  MapHResultToString(HRESULT hr);
LPWSTR  MapErrorToString(INT_PTR error);


#ifdef _DEBUG
//-----------------------------------------------------------------------------
// _DEBUG build only logging macros
//-----------------------------------------------------------------------------
#define DEVTRACE(x) OutputDebugString(L##x##L"\r\n");

#define DEBUG_ENTER(parameters) \
              LogEnterFunction parameters

#define DEBUG_LEAVE(retval) \
              LogLeaveFunction(retval)

#define DEBUG_TRACE(parameters) \
              LogTrace parameters

#define DEBUG_FINALRELEASE(objname) \
              LogTrace(L"%s [%#x] final release!", objname, this)

#ifdef _DEBUG_REFCOUNT
#define DEBUG_ADDREF(objname, refcount) \
              LogTrace(L"%s [%#x] addref: %d", objname, this, refcount)

#define DEBUG_RELEASE(objname, refcount) \
              LogTrace(L"%s [%#x] release: %d", objname, this, refcount)
#else
#pragma warning( disable : 4002 )
#pragma warning( disable : 4003 )

#define DEBUG_ADDREF(x)
#define DEBUG_RELEASE(x)
#endif /* _DEBUG_REFCOUNT */

#else

// we will get rebuked for the bogus 
// arglists in the debug macros
#pragma warning( disable : 4002 )
#pragma warning( disable : 4003 )

#define DEBUG_ENTER(x)
#define DEBUG_LEAVE(x)
#define DEBUG_TRACE(x)
#define DEBUG_ADDREF(x)
#define DEBUG_RELEASE(x)
#define DEBUG_FINALRELEASE(x)

#endif /* _DEBUG */

#endif /* __LOG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\exe\globals.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    globals.cxx

Abstract:

    Contains environment config functions for Spork.

    NOTE: I thought long and hard about whether to use globals at all. In
          the end, it's cleaner to parse the command-line and store some
          global config info in one place rather than carry it around by
          passing params hither and yon. The global data is accessed only
          through the functions in this file.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


//-----------------------------------------------------------------------------
// global vars (note, there are NO 'extern' references anywhere in the code)
//-----------------------------------------------------------------------------
LPWSTR g_wszScriptFile = NULL;
LPWSTR g_wszProfile    = NULL;
BOOL   g_bSilentMode   = FALSE;
BOOL   g_bDebugOut     = FALSE;


//-----------------------------------------------------------------------------
// private
//-----------------------------------------------------------------------------
BOOL   ParseCommandLine(PSPORK pSpork, LPSTR szCmdLine);
LPWSTR GetStringToken(LPSTR* ppsz);
BOOL   StoreEnvironmentVariable(PSPORK pSpork, LPWSTR nvpair);
BOOL   nvpairhelper(PSPORK pSpork, LPWSTR name, LPWSTR value);


//-----------------------------------------------------------------------------
// global functions
//-----------------------------------------------------------------------------
BOOL
GlobalInitialize(
  PSPORK pSpork,
  LPSTR  szCmdLine
  )
{
  BOOL     bInit = FALSE;
  LPWSTR   wide  = NULL;
  VARIANT* pvr   = NULL;

  if( ParseCommandLine(pSpork, szCmdLine) )
  {
    ManageRootKey(TRUE);
    ToggleDebugOutput(g_bDebugOut);

    if( wide = __ansitowide(szCmdLine) )
    {
      nvpairhelper(pSpork, L"cmdline", wide);
      SAFEDELETEBUF(wide);
    }

    if( SUCCEEDED(CoInitializeEx(NULL, COINIT_MULTITHREADED)) )
    {
      bInit = TRUE;
    }
  }
  else
  {
    LogTrace(L"invalid commandline argument in \"%S\"", szCmdLine);
  }

  return bInit;
}


void
GlobalUninitialize(void)
{
  LogTerminate();
  ManageRootKey(FALSE);
  CoUninitialize();
  SAFEDELETEBUF(g_wszScriptFile);
}


LPWSTR
GlobalGetScriptName(void)
{
  return g_wszScriptFile ? StrDup(g_wszScriptFile) : NULL;
}


LPWSTR
GlobalGetProfileName(void)
{
  return g_wszProfile ? StrDup(g_wszProfile) : NULL;
}


BOOL
GlobalIsSilentModeEnabled(void)
{
  return g_bSilentMode;
}


BOOL
GlobalIsDebugOutputEnabled(void)
{
  return g_bDebugOut;
}


//-----------------------------------------------------------------------------
// command line parser
//-----------------------------------------------------------------------------
BOOL
ParseCommandLine(
  PSPORK pSpork,
  LPSTR  szCmdLine
  )
{
  BOOL  bRet    = TRUE;
  CHAR  token   = NULL;
  LPSTR cmdline = NULL;
  LPSTR tmp     = NULL;

  if( !szCmdLine )
    goto quit;

  cmdline = StrDupA(szCmdLine);
  tmp     = cmdline;

  while( *tmp )
  {
    switch( *tmp )
    {
      // eat whitespace
      case ' ' :
        {
          ++tmp;
        }
        continue;

      // locate a command token
      case '-' :
      case '/' :
        {
          if( !token )
          {
            ++tmp;
          }
          else
          {
            // we have an unprocessed command token, this is an error.
            bRet = FALSE;
            goto quit;
          }
        }
        continue;

      default :
        {
          // store the command token and if we're not at the end
          // of the command line, continue processing whitespace
          if( !token )
          {
            token = *tmp++;

            while( *tmp == ' ' )
              ++tmp;
          }

          if( token == '?' )
          {
            Alert(
              FALSE,
              L"SPORK.EXE Command Line Syntax\r\n\r\n" \
              L"-f <scriptname>\r\n"   \
              L"-p <profilename>\r\n"  \
              L"-s <silentmode>\r\n"   \
              L"-d <debugmonitor>\r\n" \
              L"-v <name=value>\r\n"
              );

            bRet = FALSE;
            goto quit;
          }              

          // process the command token
          switch( ((char) (token & 0xdf)) )
          {
            case 'F' : // specify a script to run
              {
                g_wszScriptFile = GetStringToken(&tmp);

                if( !g_wszScriptFile )
                {
                  bRet = FALSE;
                  goto quit;
                }
                else
                {
                  LogTrace(L"using script %s", g_wszScriptFile);
                }
              }
              break;

            case 'P' : // specify the profile to use
              {
                g_wszProfile = GetStringToken(&tmp);

                if( !g_wszProfile )
                {
                  bRet = FALSE;
                  goto quit;
                }
                else
                {
                  LogTrace(L"using profile %s", g_wszProfile);
                }
              }
              break;

            case 'S' : // enable silent mode
              {
                g_bSilentMode = TRUE;
                LogTrace(L"silent mode is enabled");
              }
              break;

            case 'D' : // enable output to a debug monitor
              {
                g_bDebugOut = TRUE;
                LogTrace(L"debug logging is enabled");
              }
              break;

            case 'V' : // set an environment variable
              {
                LPWSTR wtmp = GetStringToken(&tmp);

                if( wtmp )
                {
                  bRet = StoreEnvironmentVariable(pSpork, wtmp);
                  SAFEDELETEBUF(wtmp);

                  if( !bRet )
                    goto quit;
                }
              }
              break;

            default : bRet = FALSE; goto quit;
          }

          token = NULL;
        }
    }
  }

quit:

  SAFEDELETEBUF(cmdline);
  return bRet;
}


//-----------------------------------------------------------------------------
// helper functions
//-----------------------------------------------------------------------------
LPWSTR
GetStringToken(
  LPSTR* ppsz
  )
{
  LPSTR  tmp   = NULL;
  LPWSTR token = NULL;

  if( *(tmp = (*ppsz + StrCSpnA(*ppsz, "-/"))) )
  {
    *tmp = '\0';

    StrTrimA(*ppsz, " ");

    token = __ansitowide(*ppsz);
    *ppsz = tmp+1;
  }
  else
  {
    token  = __ansitowide(*ppsz);
    *ppsz += strlen(*ppsz);
  }

  return token;
}


BOOL
StoreEnvironmentVariable(
  PSPORK pSpork,
  LPWSTR nvpair
  )
{
  BOOL   bStored = FALSE;
  LPWSTR token   = NULL;

  if( nvpair )
  {
    token = StrChr(nvpair, L'=');

    if( token )
    {
      *token  = L'\0';
      bStored = nvpairhelper(pSpork, nvpair, token+1);
    }
  }

  return bStored;
}


BOOL
nvpairhelper(
  PSPORK pSpork,
  LPWSTR name,
  LPWSTR value
  )
{
  VARIANT* pvr = NULL;

  if( value )
  {
    pvr = new VARIANT;

    if( pvr )
    {
      V_VT(pvr)   = VT_BSTR;
      V_BSTR(pvr) = __widetobstr(value);

      pSpork->PropertyBag(name, &pvr, STORE);

      VariantClear(pvr);
      SAFEDELETE(pvr);

      LogTrace(L"stored environment var \"%s\" with value \"%s\"", name, value);

      return TRUE;
    }
  }

  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\inc\scrobj.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    scrobj.h

Abstract:

    Declaration of the ScriptObject class. Implementation is
    in ..\src\scrobj.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


#ifndef __SCROBJ_H__
#define __SCROBJ_H__


DWORD WINAPI ScriptThread(LPVOID pv);


class ScriptObject : public IScriptRuntime,
                     public IActiveScriptSite,
                     public IActiveScriptSiteDebug,
                     public IProvideClassInfo
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();

    // IScriptRuntime
    HRESULT __stdcall CreateObject(
                        BSTR     ProgId,
                        VARIANT* Name,
                        VARIANT* Mode,
                        VARIANT* Object
                        );

    HRESULT __stdcall CreateFork(
                        BSTR     ScriptFile,
                        VARIANT  Threads,
                        BSTR     ChildParams,
                        VARIANT* ChildResult
                        );

    HRESULT __stdcall PutValue(
                        BSTR     Name,
                        VARIANT* Value,
                        VARIANT* Status
                        );

    HRESULT __stdcall GetValue(
                        BSTR     Name,
                        VARIANT* Value
                        );

    HRESULT __stdcall SetUserId(
                        VARIANT  Username,
                        VARIANT  Password,
                        VARIANT* Domain,
                        VARIANT* Status
                        );

    DECLAREIACTIVESCRIPTSITE();
    DECLAREIACTIVESCRIPTSITEDEBUG();
    DECLAREIPROVIDECLASSINFO();

  public:
    ScriptObject();
   ~ScriptObject();

    static HRESULT Create(PSCRIPTINFO psi, PSCRIPTOBJ* ppscrobj);

    HRESULT Run(void);
    HRESULT Terminate(void);

  private:
    HRESULT        _Initialize(PSCRIPTINFO psi);
    LPWSTR         _LoadScript(void);
    HRESULT        _LoadScriptDebugger(void);
    BOOL           _PreprocessScript(HANDLE* phScript);
    BOOL           _RunPreprocessor(void);
    BOOL           _IsDotINewer(LPCWSTR wszDotI);
    BOOL           _IsUnicodeScript(LPVOID pBuf, DWORD cBuf);
    SCRIPTTYPE     _GetScriptType(void);
    HRESULT        _CreateObject(LPWSTR wszProgId, IDispatch** ppdisp);

  private:
    LONG               m_cRefs;
    PSCRIPTINFO        m_psi;
    LPCWSTR            m_wszScriptFile;
    IActiveScript*     m_pScriptEngine;
    IDebugApplication* m_pDebugApplication;
    HTREEITEM          m_htThis;
    DBGOPTIONS         m_DebugOptions;
};

#endif /* __SCROBJ_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\sporklets\testlog\testlog.inc ===
!IF 0

Copyright (c) 1994  Microsoft Corporation

!ENDIF

!IFNDEF SDKINC
SDKINC=$(SDK_INC_PATH)
!ENDIF

!IFDEF LIBDIR
!ERROR LIBDIR already defined - choose new name
!ENDIF

ROOT=$(SDXROOT)\inetcore\winhttp\tools\spork\sporklets\testlog
LIBDIR=$(ROOT)\dll\$(_OBJ_DIR)
PROJINC=$(ROOT)\inc

#
# if TARGETPATH is not defined (in the paths that build libraries) then this
# is the default target path
#
!IFNDEF TARGETPATH
TARGETPATH=$(LIBDIR)
TARGETTYPE=LIBRARY
!ENDIF

#
# what it is that we're building
#
MAJORCOMP=testlog

USE_NOLIBS=1
NO_NTDLL=1
BINPLACE_PLACEFILE=..\binplace.txt

#
# Linker flags
#
WIN32_WINNT_VERSION=0x0500
#WIN32_WIN95_VERSION=0x0400

#
# compiler warning flags
#
MSC_WARNING_LEVEL=/W3 /WX

#
# enable exception handling
#
#USE_NATIVE_EH=1

#
# compiler definitions
#
C_DEFINES=$(C_DEFINES) -DWIN32

#
# Set debugging level
#
!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
C_DEFINES=$(C_DEFINES) -D_DEBUG
!ENDIF

!IFNDEF BUILD_PCH
PRECOMPILED_OPTION=/Fp$(ROOT)\inc\$(_OBJ_DIR)\*\common.pch /Yucommon.h
PRECOMPILED_CXX=1
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\inc\spork.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    spork.h

Abstract:

    Declaration of the Spork class. Implementation is in ..\src\spobj.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#ifndef __SPORK_H__
#define __SPORK_H__


typedef class CObjectCache  OBJCACHE;
typedef class CObjectCache* POBJCACHE;
typedef class CPropertyBag  PROPERTYBAG;
typedef class CPropertyBag* PPROPERTYBAG;

class MultiListView;

void ObjectKiller(LPVOID* ppv);
void VariantKiller(LPVOID* ppv);

typedef class CHashTable<LPWSTR> _WSZTABLE;

class CObjectCache : public _WSZTABLE
{
  public:
    CObjectCache() : _WSZTABLE(10) {}
   ~CObjectCache() {}

    void GetHashAndBucket(LPWSTR id, LPDWORD lpHash, LPDWORD lpBucket);
};


class CPropertyBag : public _WSZTABLE
{
  public:
    CPropertyBag() : _WSZTABLE(10) {}
   ~CPropertyBag() {}

    void GetHashAndBucket(LPWSTR id, LPDWORD lpHash, LPDWORD lpBucket);
};


class Spork
{
  public:
    HRESULT CreateScriptThread(
              PSCRIPTINFO pScriptInfo,
              HANDLE*     pThreadHandle
              );

    HRESULT GetScriptEngine(
              SCRIPTTYPE      st,
              IActiveScript** ppias
              );

    HRESULT GetTypeLib(
              ITypeLib** pptl
              );

    HRESULT GetNamedProfileItem(
              LPWSTR  wszItemName,
              LPVOID* ppvItem
              );

    HRESULT GetProfileDebugOptions(
              PDBGOPTIONS pdbo
              );

    HRESULT ObjectCache(
              LPWSTR       wszObjectName,
              PCACHEENTRY* ppCacheEntry,
              ACTION       action
              );

    HRESULT PropertyBag(
              LPWSTR    wszPropertyName,
              VARIANT** ppvarValue,
              ACTION    action
              );

    HRESULT NotifyUI(
              BOOL       bInsert,
              LPCWSTR    wszName,
              PSCRIPTOBJ pScriptObject,
              HTREEITEM  htParent,
              HTREEITEM* phtItem
              );
    
    friend INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK ProfilePropPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK DebugPropPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    Spork();
   ~Spork();

    static HRESULT Create(HINSTANCE hInst, PSPORK* pps);
    HRESULT Run(void);

  private:
    HRESULT    _Initialize(HINSTANCE hInst);
    HRESULT    _InitializeScriptDebugger(DBGOPTIONS dbo);
    BOOL       _InitializeUI(void);
    HRESULT    _LaunchUI(void);

    INT_PTR    _DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL       _BrowseForScriptFile(void);
    INT_PTR    _RunClicked(void);
    INT_PTR    _ConfigClicked(void);

    INT_PTR    _DebugPropPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL       _LoadDebugOptions(void);
    BOOL       _SaveDebugOptions(HWND dialog);

    INT_PTR    _ProfilePropPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR    _InitProfileSupport(HWND hwndDialog, LPWSTR wszProfile);
    BOOL       _InitProfileSelection(void);
    BOOL       _LoadProfiles(void);
    BOOL       _SaveProfiles(void);
    BOOL       _LoadProfileEntries(INT_PTR dwProfileId, LPWSTR wszProfileName);
    LPWSTR     _GetCurrentProfilePath(void);
    BOOL       _NewProfile(HWND hwnd);
    
  private:
    HINSTANCE          m_hInst;
    DLGWINDOWS         m_DlgWindows;
    ITypeLib*          m_pTypeLib;
    IActiveScript*     m_pScriptEngine[2];
    LPWSTR             m_wszScriptFile;
    LPWSTR             m_wszProfile;
    BOOL               m_bProfilesLoaded;
    POBJCACHE          m_pObjectCache;
    PPROPERTYBAG       m_pPropertyBag;
    MultiListView*     m_pMLV;
};


class MultiListView
{
  public:
    MultiListView() {};
   ~MultiListView();

    BOOL InitializeData(
           DWORD cListViews
           );

    BOOL InitializeDisplay(
           HINSTANCE hInstance,
           HWND      hwndParent,
           POINT*    pptOrigin,
           DWORD     dwWidth,
           DWORD     dwHeight
           );

    BOOL TerminateDisplay(void);

    BOOL AddItem(
           INT_PTR    iListView,
           LPWSTR wszName,
           DWORD  dwType,
           LPVOID pvData
           );

    BOOL GetItem(
           INT_PTR     iListView,
           INT_PTR     iItem,
           LPWSTR* ppwszName,
           LPDWORD pdwType,
           LPVOID* ppvData
           );

    BOOL GetItemByName(
           INT_PTR     iListView,
           LPWSTR  wszName,
           LPDWORD pdwType,
           LPVOID* ppvData
           );

    BOOL ModifyItem(
           INT_PTR    iListView,
           INT_PTR    iItem,
           LPWSTR wszName,
           DWORD  dwType,
           LPVOID pvData
           );

    BOOL EnumItems(
           INT_PTR     iListView,
           LPWSTR* ppwszName,
           LPDWORD pdwType,
           LPVOID* ppvData
           );

    BOOL EnumListViewNames(
           LPWSTR* ppwszName
           );

    BOOL RefreshListView(
           INT_PTR iListView
           );

    BOOL GetListViewName(
           INT_PTR     iListView,
           LPWSTR* ppwszName
           );

    BOOL SetListViewName(
           INT_PTR    iListView,
           LPWSTR wszName
           );

    BOOL ActivateListViewByIndex(
           INT_PTR iListView
           );

    BOOL ActivateListViewByName(
           LPWSTR wszName
           );

    INT_PTR GetActiveIndex(void);

    BOOL InPlaceEdit(
           LPNMITEMACTIVATE pnmia
           );

    BOOL ResizeColumns(
           INT_PTR iListView
           );

    BOOL IsModified(
           INT_PTR iListView
           );

    BOOL IsListViewName(
           LPWSTR wszName
           );
    
    BOOL IsDisplayEnabled(void) { return (m_hwndParent ? TRUE : FALSE); }

    BOOL GetDisplayInfo(
           LPLVITEM plvi
           );

    BOOL GetDebugOptions(
           PDBGOPTIONS pdbo
           );

    BOOL SetDebugOptions(
           DBGOPTIONS dbo
           );

    friend LRESULT ListViewSubclassProc(
                     HWND   hwnd,
                     UINT   uMsg,
                     WPARAM wParam,
                     LPARAM lParam
                     );

  private:
    void    _AddItemToListView(
              INT_PTR iListView,
              INT_PTR iItem
              );

    BOOL    _UpdateItem(
              HWND hwndEdit,
              INT_PTR  iItem
              );

    LRESULT _ListViewSubclassProc(
              HWND   hwnd,
              UINT   uMsg,
              WPARAM wParam,
              LPARAM lParam
              );
  
  private:
    HINSTANCE m_hInstance;
    HWND      m_hwndParent;
    DWORD_PTR m_dwActive;
    DWORD_PTR m_cListViews;
    PMLVINFO  m_arListViews;
};


#endif /* __SPORK_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\inc\resources.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    resources.h

Abstract:

    Shared macros, typedefs, etc. used by the project.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __RESOURCES_H__
#define __RESOURCES_H__

#define ERROR_FAILURE        0xFFFFF666

#define IDC_UNUSED            -1

#define IDD_SPORK            100
#define IDD_PROPPAGE_DEBUG   101
#define IDD_PROPPAGE_PROFILE 102
#define IDD_USERINPUT        103

#define IDI_DEFAULT          200
#define IDI_SCRIPT           201
#define IDI_DBGOUT           202
#define IDI_PROFILE          203
#define IDI_DEBUG            204

#define IDB_QUIT             300
#define IDB_RUN              301
#define IDB_BROWSE           302
#define IDB_CONFIG           303
#define IDB_ENABLEDEBUG      304
#define IDB_DBGBREAK         305
#define IDB_ENABLEDBGOUT     306
#define IDB_NEWPROFILE       307
#define IDB_DELPROFILE       308

#define IDT_TITLE            400
#define IDT_SCRIPTPATH       401
#define IDT_DBGTXT           402
#define IDT_DBGOUTTXT        403

#define IDC_SCRIPTTREE       500
#define IDC_PROFILELIST      501
#define IDC_PROFILEITEMS     502
#define IDC_EDIT             503

#define DECLAREIUNKNOWN() \
    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv); \
    ULONG   __stdcall AddRef(void); \
    ULONG   __stdcall Release(void); 

#define DECLAREICLASSFACTORY() \
    HRESULT __stdcall CreateInstance(IUnknown* outer, REFIID riid, void** ppv); \
    HRESULT __stdcall LockServer(BOOL lock);

#define DECLAREIDISPATCH() \
    HRESULT __stdcall GetTypeInfoCount(UINT* pctinfo);  \
    HRESULT __stdcall GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti); \
    HRESULT __stdcall GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId); \
    HRESULT __stdcall Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae);

#define DECLAREIACTIVESCRIPTSITE() \
    HRESULT __stdcall GetLCID(LCID* plcid); \
    HRESULT __stdcall GetItemInfo(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown** ppunk, ITypeInfo** ppti); \
    HRESULT __stdcall GetDocVersionString(BSTR* pbstrVersion); \
    HRESULT __stdcall OnScriptTerminate(const VARIANT* pvarResult, const EXCEPINFO* pei); \
    HRESULT __stdcall OnStateChange(SCRIPTSTATE ss); \
    HRESULT __stdcall OnScriptError(IActiveScriptError* piase); \
    HRESULT __stdcall OnEnterScript(void); \
    HRESULT __stdcall OnLeaveScript(void);

#define DECLAREIACTIVESCRIPTSITEDEBUG() \
    HRESULT __stdcall GetDocumentContextFromPosition(DWORD dwSourceContext, ULONG uCharacterOffset, ULONG uNumChars, IDebugDocumentContext** ppdc); \
    HRESULT __stdcall GetApplication(IDebugApplication** ppda); \
    HRESULT __stdcall GetRootApplicationNode(IDebugApplicationNode** ppdan); \
    HRESULT __stdcall OnScriptErrorDebug(IActiveScriptErrorDebug* pErrorDebug, LPBOOL pfEnterDebugger, LPBOOL pfCallOnScriptErrorWhenContinuing);

#define DECLAREIPROVIDECLASSINFO() \
    HRESULT __stdcall GetClassInfo(ITypeInfo** ppti);

#define DECLAREIOBJECTWITHSITE() \
    HRESULT __stdcall SetSite(IUnknown* pUnkSite); \
    HRESULT __stdcall GetSite(REFIID riid, void** ppvSite);


#define SAFECLOSE(x) if((x!=INVALID_HANDLE_VALUE) && (x!=NULL)) { CloseHandle(x); x=NULL; }
#define SAFEDELETE(x) if(x) { delete x; x=NULL; }
#define SAFEDELETEBUF(x) if(DWORD_PTR(x)) {delete [] x; x=NULL;}
#define SAFERELEASE(x) if(x) { x->Release(); x=NULL; }
#define SAFEDELETEBSTR(x) if(x) { SysFreeString(x); x=NULL; }
#define VALIDDISPID(x) ((x!=DISPID_UNKNOWN) ? TRUE : FALSE)
#define NEWVARIANT(x) VARIANT x; memset(&x, 0, sizeof(VARIANT)); VariantInit(&x);

#ifdef IA64
#define ITOW(val, buf, radix) _i64tow(val, buf, radix);
#else
#define ITOW(val, buf, radix) _itow(val, buf, radix);
#endif

#define THROWMEMALERT(x) LogTrace(L"*** WARNING: failed to allocate \'%s\' near line %d of %S", x, __LINE__, __FILE__)

#define TF(x) (x?L"TRUE":L"FALSE")
#define VTF(x) ((V_BOOL(x) == VARIANT_TRUE)?L"TRUE":L"FALSE")

#define VPF(x) ((V_BOOL(x) == VARIANT_TRUE)?L"PASS":L"FAIL")

#define ENABLED(x)    (x?L"enabled":L"disabled")
#define SUCCESSFUL(x) (SUCCEEDED(x) ? L"successful" : L"unsuccessful")

#define STRING(x)     (x?x:L"null")

#define CASE_OF(constant) case constant: return L#constant
#define CASE_OF_MUTATE(val, name) case val: return L#name
#define CASE_IID(riid, iid) if(IsEqualIID(riid, iid)) return L#iid

typedef BY_HANDLE_FILE_INFORMATION   BHFI;
typedef LPBY_HANDLE_FILE_INFORMATION LPBHFI;
typedef WIN32_FILE_ATTRIBUTE_DATA    W32FAD;
typedef WIN32_FILE_ATTRIBUTE_DATA*   PW32FAD;
typedef CRITICAL_SECTION             CRITSEC;
typedef LPCRITICAL_SECTION           PCRITSEC;

typedef class Spork         SPORK;
typedef class Spork*        PSPORK;
typedef class ScriptObject  SCRIPTOBJ;
typedef class ScriptObject* PSCRIPTOBJ;

typedef struct _dbgoptions
{
  BOOL bEnableDebug;
  BOOL bBreakOnScriptStart;
  BOOL bEnableDebugWindow;
}
DBGOPTIONS, *PDBGOPTIONS;

typedef struct _tagItemInfo
{
  LPWSTR        wszName;
  DWORD         dwType;
  LPWSTR        wszValue;
  DWORD         dwValue;
  _tagItemInfo* pNext;
}
ITEMINFO, *PITEMINFO;

typedef struct _tagListViewInfo
{
  LPWSTR     name;
  HWND       hwnd;
  WNDPROC    wndproc;
  BOOL       modified;
  PITEMINFO  items;
  DBGOPTIONS dbgopts;
  DWORD      currentid;
}
MLVINFO, *PMLVINFO;

#define MLV_RETAIN 0xF00DD00D
#define MLV_STRING REG_SZ
#define MLV_DWORD  REG_DWORD

typedef struct _dispidtableentry
{
  DWORD  hash;
  DISPID dispid;
  LPWSTR name;
}
DISPIDTABLEENTRY, *PDISPIDTABLEENTRY;

typedef struct _scriptinfo
{
  PSPORK    pSpork;
  LPCWSTR   wszScriptFile;
  BOOL      bIsFork;
  BSTR      bstrChildParams;
  HTREEITEM htParent;
}
SCRIPTINFO, *PSCRIPTINFO;

typedef struct _dlgwindows
{
  HWND Dialog;
  HWND ScriptFile;
  HWND TreeView;
}
DLGWINDOWS, *PDLGWINDOWS;

typedef enum SCRIPTTYPE
{
  JSCRIPT = 0,
  VBSCRIPT,
  UNKNOWN
}
SCRIPTTYPE;

typedef struct _cacheentry
{
  IDispatch* pDispObject;
  DWORD      dwObjectFlags;
  BOOL       bStoreOnly;
}
CACHEENTRY, *PCACHEENTRY;

typedef enum ACTION
{
  STORE,
  RETRIEVE,
  REMOVE
}
ACTION;

#endif /* __RESOURCES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\inc\utils.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    Utility functions used by the probject.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef _UTILS_H_
#define _UTILS_H_

void* __cdecl operator new(size_t size);
void  __cdecl operator delete(void* pv);

// general utility
void    Alert(BOOL bFatal, LPCWSTR format, ...);
INT_PTR GetUserInput(HINSTANCE Instance, HWND Parent, LPCWSTR DialogTitle);
BOOL    IsRunningOnNT(void);
HRESULT GetTypeInfoFromName(LPCOLESTR name, ITypeLib* ptl, ITypeInfo** ppti);
DISPID  GetDispidFromName(PDISPIDTABLEENTRY pdt, DWORD cEntries, LPWSTR name);
HRESULT HandleDispatchError(LPWSTR id, EXCEPINFO* pei, HRESULT hr);
void    AddRichErrorInfo(EXCEPINFO* pei, LPWSTR source, LPWSTR description, HRESULT error);
DWORD   GetHash(LPWSTR name);
HRESULT DispGetOptionalParam(DISPPARAMS* pdp, UINT pos, VARTYPE vt, VARIANT* pvr, UINT* pae);
HRESULT ValidateDispatchArgs(REFIID riid, DISPPARAMS* pdp, VARIANT* pvr, UINT* pae);
HRESULT ValidateInvokeFlags(WORD flags, WORD accesstype, BOOL bNotMethod);
HRESULT ValidateArgCount(DISPPARAMS* pdp, DWORD needed, BOOL bHasOptionalArgs, DWORD optional);

// registry
BOOL  ManageRootKey(BOOL fOpen);
DWORD GetNumberOfSubKeysFromKey(LPCWSTR wszKeyName);
BOOL  SetRootRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID pvData, DWORD dwSize);
BOOL  GetRootRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID* ppvData);
BOOL  SetRegValueInKey(LPCWSTR wszKeyName, LPCWSTR wszValueName, DWORD dwType, LPVOID pvData, DWORD dwSize);
BOOL  GetRegValueFromKey(LPCWSTR wszKeyName, LPCWSTR wszValueName, DWORD dwType, LPVOID* ppvData);
BOOL  SetRegKey(LPCWSTR wszPath, LPCWSTR wszKeyName);
BOOL  EnumerateSubKeysFromKey(LPCWSTR wszKeyName, LPWSTR* ppwszSubKeyName);
BOOL  EnumerateRegValuesFromKey(LPCWSTR wszKeyName, LPWSTR* ppwszValueName, LPDWORD pdwType, LPVOID* ppvData);

// user interface
LRESULT ListBox_GetItemCount(HWND hwndLB);
LPWSTR  ListBox_GetItemText(HWND hwndLB, INT_PTR iItem);
void    ListBox_ResetContent(HWND hwndLB);
BOOL    ListBox_InsertString(HWND hwndLB, INT_PTR iItem, LPWSTR wszString);
LRESULT ListBox_GetSelectionIndex(HWND hwndLB);
LPWSTR  ListBox_GetSelectionText(HWND hwndLB);
LPVOID  ListBox_GetItemData(HWND hwndLB, INT_PTR iItem);
BOOL    ListBox_SetItemData(HWND hwndLB, INT_PTR iItem, LPVOID pvData);
BOOL    ListBox_SetCurrentSelection(HWND hwndLB, INT_PTR iItem);

// string handling
CHAR*  __widetoansi(const WCHAR* pwsz);
WCHAR* __ansitowide(const char* psz);
BOOL   __isempty(VARIANT* var);
BOOL   __mangle(LPWSTR src, LPWSTR* ppdest);
LPWSTR __decorate(LPWSTR src, DWORD_PTR decor);
BSTR   __ansitobstr(LPCSTR src);
BSTR   __widetobstr(LPCWSTR wsrc);
char*  __unescape(char* str);

#endif /* _UTILS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\sporklets\testlog\dll\dllentry.cxx ===
#define UNICODE
#define _UNICODE

#include "common.h"

HINSTANCE  g_hGlobalDllInstance = NULL;
LPCSTR     g_szAdvPackDll       = "advpack.dll";
LPCSTR     g_szInstallSection   = "install";
LPCSTR     g_szUninstallSection = "uninstall";

HRESULT    RegisterServer(BOOL fMode);
HRESULT    RegisterTypeLibrary(BOOL fMode);

//-----------------------------------------------------------------------------
// DLL Entry Point
//-----------------------------------------------------------------------------
BOOL
WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
  BOOL bRet = TRUE;

  switch( dwReason )
  {
    case DLL_PROCESS_ATTACH :
      {
        g_hGlobalDllInstance = hInstance;
      }
      break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
    case DLL_THREAD_ATTACH:
      break;
  }
  
  return bRet;
}


//-----------------------------------------------------------------------------
// COM Entry Points
//-----------------------------------------------------------------------------
STDAPI
DllRegisterServer(void)
{
  return RegisterServer(TRUE);
}


STDAPI
DllUnregisterServer(void)
{
  return RegisterServer(FALSE);
}


STDAPI
DllGetClassObject(REFIID clsid, REFIID riid, void** ppv)
{
  return CLSFACTORY::Create(clsid, riid, ppv);
}


//-----------------------------------------------------------------------------
// SelfRegistration helper routines
//-----------------------------------------------------------------------------
HRESULT
RegisterServer(BOOL fMode)
{
  HRESULT    hr      = S_OK;
  HINSTANCE  advpack = NULL;
  REGINSTALL pfnri   = NULL;

  advpack = LoadLibraryA(g_szAdvPackDll);

    if( !advpack )
    {
      hr = E_FAIL;
      goto quit;
    }

  pfnri = (REGINSTALL) GetProcAddress(advpack, achREGINSTALL);

    if( !pfnri )
    {
      hr = E_FAIL;
      goto quit;
    }

  hr = pfnri(
        g_hGlobalDllInstance,
        fMode ? g_szInstallSection : g_szUninstallSection,
        NULL
        );

  FreeLibrary(advpack);

  hr = RegisterTypeLibrary(fMode);

quit:

  return hr;
}


HRESULT
RegisterTypeLibrary(BOOL fMode)
{
  ITypeLib* ptl  = NULL;
  TLIBATTR* pta  = NULL;
  CHAR*     pbuf = NULL;
  WCHAR*    wbuf = NULL;
  HRESULT   hr   = S_OK;

  if( (pbuf = new CHAR[MAX_PATH]) )
  {
    GetModuleFileNameA(g_hGlobalDllInstance, pbuf, MAX_PATH);
  }
  else
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

  if( !(wbuf = __ansitowide(pbuf)) )
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

  hr = LoadTypeLib(wbuf, &ptl);

  if( SUCCEEDED(hr) )
  {
    if( fMode )
    {
      hr = RegisterTypeLib(ptl, wbuf, NULL);
    }
    else
    {
      hr = ptl->GetLibAttr(&pta);

        if( SUCCEEDED(hr) )
        {
          hr = UnRegisterTypeLib(
                pta->guid,
                pta->wMajorVerNum,
                pta->wMinorVerNum,
                pta->lcid,
                pta->syskind
                );

          ptl->ReleaseTLibAttr(pta);
        }
        else
        {
          goto quit;
        }
    }
    
    ptl->Release();
  }

quit:

  SAFEDELETEBUF(pbuf);
  SAFEDELETEBUF(wbuf);

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\sporklets\testlog\inc\dispids.h ===
#ifndef __DISPIDS_H__
#define __DISPIDS_H__

#define TESTLOG_DISPID_BASE            100

#define DISPID_TESTLOG_OPEN            (TESTLOG_DISPID_BASE + 1)
#define DISPID_TESTLOG_CLOSE           (TESTLOG_DISPID_BASE + 2)
#define DISPID_TESTLOG_ENTERFUNCTION   (TESTLOG_DISPID_BASE + 3)
#define DISPID_TESTLOG_LEAVEFUNCTION   (TESTLOG_DISPID_BASE + 4)
#define DISPID_TESTLOG_TRACE           (TESTLOG_DISPID_BASE + 5)
#define DISPID_TESTLOG_BEGINTEST       (TESTLOG_DISPID_BASE + 6)
#define DISPID_TESTLOG_ENDTEST         (TESTLOG_DISPID_BASE + 7)
#define DISPID_TESTLOG_FINALRESULT     (TESTLOG_DISPID_BASE + 8)

#endif /* __DISPIDS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\sporklets\testlog\inc\common.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    common.h

Abstract:

    Generates the precompiled header.
    
Author:

    Paul M Midgen (pmidge) 20-March-2001


Revision History:

    20-March-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#ifndef __COMMON_H__
#define __COMMON_H__

#define _WIN32_WINNT 0x0500
#define _UNICODE
#define UNICODE

#if defined(__cplusplus)
extern "C" {
#endif

#include <windows.h>
#include <advpub.h>
#include <oleauto.h>
#include <objbase.h>
#include <ocidl.h>
#include <olectl.h>

#define NO_SHLWAPI_GDI
#define NO_SHLWAPI_STREAM
#define NO_SHLWAPI_REG

#include <shlwapi.h>

#if defined(__cplusplus)
}
#endif

#include "ifaces.h"
#include "dispids.h"
#include "istatus.h"
#include "utils.h"
#include "testlog.h"

#endif /* __COMMON_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\sporklets\testlog\inc\pch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    pch.cxx

Abstract:

    Need this so the precompiled header will, umm, compile.
    
Author:

    Paul M Midgen (pmidge) 24-July-2000


Revision History:

    24-July-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

void foobar(void);

void foobar(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\sporklets\testlog\src\classfactory.cxx ===
#include "common.h"

//-----------------------------------------------------------------------------
// ClassFactory methods
//-----------------------------------------------------------------------------
ClassFactory::ClassFactory():
  m_cRefs(0),
  m_cLocks(0)
{
}


ClassFactory::~ClassFactory()
{
}


HRESULT
ClassFactory::Create(REFIID clsid, REFIID riid, void** ppv)
{
  HRESULT     hr  = S_OK;
  PCLSFACTORY pcf = NULL;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( !IsEqualIID(clsid, CLSID_TestLog) )
  {
    hr   = CLASS_E_CLASSNOTAVAILABLE;
    *ppv = NULL;
    goto quit;
  }

  if( pcf = new CLSFACTORY )
  {
    hr = pcf->QueryInterface(riid, ppv);

    if( FAILED(hr) )
    {
      delete pcf;
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  return hr;
}


//-----------------------------------------------------------------------------
// IUnknown methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ClassFactory::QueryInterface(REFIID riid, void** ppv)
{
  HRESULT hr = S_OK;

    if( ppv )
    {
      if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory) )
      {
        *ppv = static_cast<IClassFactory*>(this);
      }
      else
      {
        *ppv = NULL;
        hr   = E_NOINTERFACE;
      }
    }
    else
    {
      hr = E_POINTER;
    }

    if( SUCCEEDED(hr) )
    {
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }

  return hr;
}


ULONG
__stdcall
ClassFactory::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
ClassFactory::Release(void)
{
  InterlockedDecrement(&m_cRefs);

  if( (m_cRefs == 0) && (m_cLocks == 0) )
  {
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IClassFactory methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ClassFactory::CreateInstance(IUnknown* outer, REFIID riid, void** ppv)
{
  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( outer )
  {
    hr   = CLASS_E_NOAGGREGATION;
    *ppv = NULL;
    goto quit;
  }

  hr = TESTLOG::Create(riid, ppv);

quit:

  return hr;
}


HRESULT
__stdcall
ClassFactory::LockServer(BOOL lock)
{
  HRESULT hr = S_OK;

  lock ? InterlockedIncrement(&m_cLocks) : InterlockedDecrement(&m_cLocks);

  if( (m_cRefs == 0) && (m_cLocks == 0) )
  {
    delete this;
    return hr;
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\sporklets\testlog\inc\utils.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    Utility functions used by the probject.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __UTILS_H__
#define __UTILS_H__

void* __cdecl operator new(size_t size);
void  __cdecl operator delete(void* pv);

typedef BY_HANDLE_FILE_INFORMATION   BHFI;
typedef LPBY_HANDLE_FILE_INFORMATION LPBHFI;
typedef WIN32_FILE_ATTRIBUTE_DATA    W32FAD;
typedef WIN32_FILE_ATTRIBUTE_DATA*   PW32FAD;
typedef CRITICAL_SECTION             CRITSEC;
typedef LPCRITICAL_SECTION           PCRITSEC;

typedef struct _dispidtableentry
{
  DWORD  hash;
  DISPID dispid;
  LPWSTR name;
}
DISPIDTABLEENTRY, *PDISPIDTABLEENTRY;

// general utility
HRESULT GetTypeInfoFromName(LPCOLESTR name, ITypeLib* ptl, ITypeInfo** ppti);
DISPID  GetDispidFromName(PDISPIDTABLEENTRY pdt, DWORD cEntries, LPWSTR name);
HRESULT HandleDispatchError(LPWSTR id, EXCEPINFO* pei, HRESULT hr);
void    AddRichErrorInfo(EXCEPINFO* pei, LPWSTR source, LPWSTR description, HRESULT error);
DWORD   GetHash(LPWSTR name);
HRESULT DispGetOptionalParam(DISPPARAMS* pdp, UINT pos, VARTYPE vt, VARIANT* pvr, UINT* pae);
HRESULT ValidateDispatchArgs(REFIID riid, DISPPARAMS* pdp, VARIANT* pvr, UINT* pae);
HRESULT ValidateInvokeFlags(WORD flags, WORD accesstype, BOOL bNotMethod);
HRESULT ValidateArgCount(DISPPARAMS* pdp, DWORD needed, BOOL bHasOptionalArgs, DWORD optional);

// string handling
CHAR*  __widetoansi(const WCHAR* pwsz);
WCHAR* __ansitowide(const char* psz);
BOOL   __isempty(VARIANT* var);
BOOL   __mangle(LPWSTR src, LPWSTR* ppdest);
BSTR   __ansitobstr(LPCSTR src);
BSTR   __widetobstr(LPCWSTR wsrc);
char*  __unescape(char* str);

// miscellaneous
#define DECLAREIUNKNOWN() \
    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv); \
    ULONG   __stdcall AddRef(void); \
    ULONG   __stdcall Release(void); 

#define DECLAREICLASSFACTORY() \
    HRESULT __stdcall CreateInstance(IUnknown* outer, REFIID riid, void** ppv); \
    HRESULT __stdcall LockServer(BOOL lock);

#define DECLAREIDISPATCH() \
    HRESULT __stdcall GetTypeInfoCount(UINT* pctinfo);  \
    HRESULT __stdcall GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti); \
    HRESULT __stdcall GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId); \
    HRESULT __stdcall Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae);

#define DECLAREIACTIVESCRIPTSITE() \
    HRESULT __stdcall GetLCID(LCID* plcid); \
    HRESULT __stdcall GetItemInfo(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown** ppunk, ITypeInfo** ppti); \
    HRESULT __stdcall GetDocVersionString(BSTR* pbstrVersion); \
    HRESULT __stdcall OnScriptTerminate(const VARIANT* pvarResult, const EXCEPINFO* pei); \
    HRESULT __stdcall OnStateChange(SCRIPTSTATE ss); \
    HRESULT __stdcall OnScriptError(IActiveScriptError* piase); \
    HRESULT __stdcall OnEnterScript(void); \
    HRESULT __stdcall OnLeaveScript(void);

#define DECLAREIPROVIDECLASSINFO() \
  HRESULT __stdcall GetClassInfo(ITypeInfo** ppti);

#define DECLAREIOBJECTWITHSITE() \
    HRESULT __stdcall SetSite(IUnknown* pUnkSite); \
    HRESULT __stdcall GetSite(REFIID riid, void** ppvSite);

#define SAFECLOSE(x) if((x!=INVALID_HANDLE_VALUE) && (x!=NULL)) { CloseHandle(x); x=NULL; }
#define SAFEDELETE(x) if(x) { delete x; x=NULL; }
#define SAFEDELETEBUF(x) if(DWORD_PTR(x)) {delete [] x; x=NULL;}
#define SAFERELEASE(x) if(x) { x->Release(); x=NULL; }
#define SAFEDELETEBSTR(x) if(x) { SysFreeString(x); x=NULL; }
#define VALIDDISPID(x) ((x!=DISPID_UNKNOWN) ? TRUE : FALSE)
#define NEWVARIANT(x) VARIANT x; memset(&x, 0, sizeof(VARIANT)); VariantInit(&x);

#define TF(x) (x?L"TRUE":L"FALSE")
#define VTF(x) ((V_BOOL(x) == VARIANT_TRUE)?L"TRUE":L"FALSE")

#define VPF(x) ((V_BOOL(x) == VARIANT_TRUE)?L"PASS":L"FAIL")

#define ENABLED(x)    (x?L"enabled":L"disabled")
#define SUCCESSFUL(x) (SUCCEEDED(x) ? L"successful" : L"unsuccessful")

#define STRING(x)     (x?x:L"null")

#define CASE_OF(constant) case constant: return L#constant
#define CASE_OF_MUTATE(val, name) case val: return L#name
#define CASE_IID(riid, iid) if(IsEqualIID(riid, iid)) return L#iid

#endif /* __UTILS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\sporklets\testlog\inc\istatus.h ===
//==============================================================================
// Microsoft Corporation
// Copyright (C) Microsoft Corporation, 1999-2000
//
//
//  File:       IStatus.h
//
//  Synopsis:   Definition of IStatus, IID_IStatus, CLSID_IStatus
//
//  Classes:    IStatus
//
//  History:    benchr      10/19/99    Created
//
//==============================================================================

#ifndef ISTATUS_DEFINED
#define ISTATUS_DEFINED

interface IStatus : IDispatch
{
    STDMETHOD(OutputStatus)(/*[in]*/ BSTR bstrSrc, /*[in]*/ BSTR bstrText, /*[in]*/ long lLevel);
    STDMETHOD(get_Global)(/*[in]*/ BSTR bstrName, /*[out,retval]*/ VARIANT *var);
    STDMETHOD(put_Global)(/*[in]*/ BSTR bstrName, /*[in]*/ VARIANT var);
    STDMETHOD(get_Property)(/*[in]*/ BSTR bstrName, /*[out,retval]*/ VARIANT *var); 
    STDMETHOD(put_Property)(/*[in]*/ BSTR bstrName, /*[in]*/ VARIANT var);
    STDMETHOD(RegisterDialog)(/*[in]*/ BSTR bstrTest, /*[in]*/ BSTR bstrResponse);
    STDMETHOD(MonitorPID)(/*[in]*/ long lPID);
    STDMETHOD(MonitorPIDwithoutTerminate)(/*[in]*/ long lPID);
    STDMETHOD(LogOtherTest)(/*[in]*/ long lID, /*[in]*/ long lResult, /*[in]*/ BSTR bstrComment, /*[in, optional]*/ VARIANT vAssociateBugID);
    STDMETHOD(get_Result)(/*[out,retval]*/ VARIANT *var); 
    STDMETHOD(put_Result)(/*[in]*/ VARIANT var);
};

const IID IID_IStatus = {0xC6396797,0x10B4,0x4078,{0x83,0xDF,0xBB,0x3F,0x4B,0x3A,0x44,0x1D}};
const CLSID CLSID_Status = {0xB91D58D9,0x68EC,0x4015,{0xB6,0x7F,0xF1,0x9D,0x73,0x44,0x83,0xE2}};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\sporklets\testlog\inc\testlog.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    testlog.h

Abstract:

    Declaration of the TestLog class. Implementation is
    in ..\src\testlog.
    
Author:

    Paul M Midgen (pmidge) 21-February-2001


Revision History:

    21-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


#ifndef __TESTLOG_H__
#define __TESTLOG_H__


#define TESTLOG_MODE_FLAG_USEDEFAULTS  0x00000000

#define TESTLOG_MODE_FLAG_NOLOCALFILE  0x00000001
#define TESTLOG_MODE_FLAG_NOPIPERLOG   0x00000002
#define TESTLOG_MODE_FLAG_OUTPUTTODBG  0x00000004
#define TESTLOG_MODE_FLAG_NOAUTOMATION 0x00000008

#define TESTLOG_MODE_FLAG_ALL          ( TESTLOG_MODE_FLAG_NOLOCALFILE  \
                                       | TESTLOG_MODE_FLAG_NOPIPERLOG   \
                                       | TESTLOG_MODE_FLAG_OUTPUTTODBG  \
                                       | TESTLOG_MODE_FLAG_NOAUTOMATION )


// ERRORLEVEL and PASSFAIL from cpiper.h -- see ananthk
enum ERRORLEVEL
{
    LEVEL_FATAL     = 0,  // Critical Failure info: updates Logs(DB), updates display window, updates log file
    LEVEL_FAILURE   = 1,  // Failure info: updates Logs(DB), updates display window, updates log file
    LEVEL_LOGINFO   = 2,  // Any info: updates Logs(DB), updates display window, updates log file
    LEVEL_STATUS    = 3,  // Any info: updates display window, updates Log File
    LEVEL_DEBUGGING = 4   // Any info: updates Log File
};

enum PASSFAIL
{
    FAIL = 0,
    PASS = 1
};


typedef enum _rettype
{
  rt_void,
  rt_bool,
  rt_dword,
  rt_error,
  rt_hresult,
  rt_string
}
RETTYPE, *LPRETTYPE;

enum DEPTH
{
  INCREMENT,
  DECREMENT,
  MAINTAIN
};

typedef struct _callinfo
{
  struct _callinfo* next;
  struct _callinfo* last;
  LPCWSTR           fname;
  RETTYPE           rettype;
}
CALLINFO, *LPCALLINFO;


typedef class ClassFactory  CLSFACTORY;
typedef class ClassFactory* PCLSFACTORY;
typedef class TestLog       TESTLOG;
typedef class TestLog*      PTESTLOG;


class ClassFactory : public IClassFactory
{
  public:
    DECLAREIUNKNOWN();
    DECLAREICLASSFACTORY();

    ClassFactory();
   ~ClassFactory();

    static HRESULT Create(REFIID clsid, REFIID riid, void** ppv);

  private:
    LONG m_cRefs;
    LONG m_cLocks;
};


class TestLog : public ITestLog,
                public IProvideClassInfo
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();

    // ITestLog
    HRESULT __stdcall Open(
                        BSTR     filename,
                        BSTR     title,
                        VARIANT* mode,
                        VARIANT* success
                        );
        
    HRESULT __stdcall Close(void);

    HRESULT __stdcall BeginTest(
                        BSTR    testname,
                        VARIANT testid
                        );

    HRESULT __stdcall EndTest(void);

    HRESULT __stdcall FinalResult(
                        VARIANT status,
                        VARIANT reason
                        );

    HRESULT __stdcall EnterFunction(
                        BSTR    name,
                        VARIANT params,
                        VARIANT returntype
                        );

    HRESULT __stdcall LeaveFunction(
                        VARIANT returnvalue
                        );

    HRESULT __stdcall Trace(
                        BSTR message
                        );

    DECLAREIPROVIDECLASSINFO();

  public:
    TestLog();
   ~TestLog();

    static HRESULT Create(REFIID riid, void** ppv);

  private:
    HRESULT    _Initialize(LPCWSTR wszFilename, LPCWSTR wszTitle, int iMode);
    HRESULT    _InitPiperSupport(void);

    void       _Terminate(void);
    void       _EnterFunction(LPCWSTR function, RETTYPE rt, LPCWSTR format, ...);
    void       _LeaveFunction(VARIANT retval);
    void       _Trace(LPCWSTR format, ...);
    void       _BeginTest(LPCWSTR casename, DWORD caseid);
    void       _EndTest(void);
    void       _SetMode(int iMode, BOOL bReset);


    void       _WriteLog(BOOL fRaw, BOOL fTrace, DEPTH depth, LPCWSTR format, ...);
    void       _DeleteCallInfo(LPCALLINFO pci);
    LPCALLINFO _PushCallInfo(LPCWSTR function, RETTYPE rt);
    LPCALLINFO _PopCallInfo(void);
    LPWSTR     _FormatCallReturnString(LPCALLINFO pci, VARIANT retval);
    LPWSTR     _GetTimeStamp(void);
    LPWSTR     _GetWhiteSpace(int spaces);
    LPWSTR     _MapErrorToString(int error);
    LPWSTR     _MapHResultToString(HRESULT hr);  

  private:
    LONG       m_cRefs;
    LONG       m_cScriptRefs;
    BOOL       m_bOpened;
    BOOL       m_bResult;
    BSTR       m_bstrReason;
    DWORD      m_dwStackDepth;
    ITypeInfo* m_pTypeInfo;
    IStatus*   m_pStatus;
    HANDLE     m_hLogFile;
    LPCALLINFO m_pStack;
    CRITSEC    m_csLogFile;
    int        m_iMode;
};

#endif /* __TESTLOG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\sporklets\testlog\src\itestlog.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    itestlog.cxx

Abstract:

    Implements the ITestLog, IUnknown, IDispatch and IProvideClassInfo
    interfaces for the TestLog object.
    
Author:

    Paul M Midgen (pmidge) 20-March-2001


Revision History:

    20-March-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include "common.h"


//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_TestLogDisptable[] =
{
  0x00008504,   DISPID_TESTLOG_OPEN,          L"open",
  0x00010203,   DISPID_TESTLOG_CLOSE,         L"close",
  0x01086d76,   DISPID_TESTLOG_ENTERFUNCTION, L"enterfunction",
  0x010740c9,   DISPID_TESTLOG_LEAVEFUNCTION, L"leavefunction",
  0x00011446,   DISPID_TESTLOG_TRACE,         L"trace",
  0x000fc278,   DISPID_TESTLOG_BEGINTEST,     L"begintest",
  0x000417bc,   DISPID_TESTLOG_ENDTEST,       L"endtest",
  0x00410312,   DISPID_TESTLOG_FINALRESULT,   L"finalresult"
};

DWORD g_cTestLogDisptable = (sizeof(g_TestLogDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// ITestLog methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
TestLog::Open(
  BSTR     filename,
  BSTR     title,
  VARIANT* mode,
  VARIANT* success
  )
{
  HRESULT hr = S_OK;

  //
  // a script can be opened only once. we track the number of attempts to call
  // open so we know how many consumers are using us.
  //

  ++m_cScriptRefs;
  
  if( !m_bOpened )
  {
    hr = _Initialize(filename, title, V_I4(mode));

    if( SUCCEEDED(hr) )
    {
      m_bOpened = TRUE;
    }
  }

  if( success )
  {
    V_VT(success)   = VT_BOOL;
    V_BOOL(success) = SUCCEEDED(hr) ? VARIANT_TRUE : VARIANT_FALSE;
  }

  return hr;
}


HRESULT
__stdcall
TestLog::Close(void)
{
  if( !m_bOpened )
    return E_UNEXPECTED;

  //
  // the only time we really will close the log and terminate the object
  // is when the script refcount drops to 0.
  //
  if( --m_cScriptRefs == 0)
  {
    _Terminate();
  }

  return S_OK;
}


HRESULT
__stdcall
TestLog::BeginTest(
  BSTR    testname,
  VARIANT testid
  )
{
  if( !m_bOpened )
    return E_UNEXPECTED;

  _BeginTest(
    testname,
    V_I4(&testid)
    );

  return S_OK;
}


HRESULT
__stdcall
TestLog::EndTest(void)
{
  if( !m_bOpened )
    return E_UNEXPECTED;

  _EndTest();
  return S_OK;
}


HRESULT
__stdcall
TestLog::FinalResult(
  VARIANT status,
  VARIANT reason
  )
{
  if( !m_bOpened )
    return E_UNEXPECTED;

  HRESULT    hr       = S_OK;
  BSTR       property = NULL;
  BSTR       _reason  = (__isempty(&reason) ? L"no reason given" : V_BSTR(&reason));
  LPCALLINFO pci      = _PopCallInfo();
  NEWVARIANT(var);

  //
  // we may get several FinalResult()'s over the course of running a linked model.
  // if ever a subcase reports false, the whole test fails. TestLog inits this
  // overall result to TRUE, so we set up the trap below to trigger one time
  // only.
  //
  if( m_bResult && (V_BOOL(&status) == VARIANT_FALSE) )
  {
    m_bResult    = FALSE;
    m_bstrReason = SysAllocString(_reason);
  }

  _Trace(
    L"\"%s\" status is %s [%s]",
    (pci ? pci->fname : L"unknown test"),
    VPF(&status),
    _reason
    );


  // only report final result status if this is the base case
  if( m_cScriptRefs == 1 )
  {
    _Trace(
      L"\"%s\" final result is %s [%s]",
      (pci ? pci->fname : L"unknown test"),
      (m_bResult ? L"PASS" : L"FAIL"),
      (m_bstrReason ? m_bstrReason : _reason)
      );

    if( !(m_iMode & TESTLOG_MODE_FLAG_NOPIPERLOG) )
    {
      // write pass/fail information to piper
      V_VT(&var) = VT_I4;
      V_I4(&var) = m_bResult ? PASS : FAIL;
      property   = __widetobstr(L"RESULT");
      hr         = m_pStatus->put_Property(property, var);

      SAFEDELETEBSTR(property);

      // write the reason for failure
      V_VT(&var)   = VT_BSTR;
      V_BSTR(&var) = SysAllocString((m_bstrReason ? m_bstrReason : _reason));
      property     = __widetobstr(L"RESULT_REASON");
      hr           = m_pStatus->put_Property(property, var);

      VariantClear(&var);
      SAFEDELETEBSTR(property);
    }
  }

  return hr;
}


HRESULT
__stdcall
TestLog::EnterFunction(
  BSTR    name,
  VARIANT params,
  VARIANT returntype
  )
{
  if( !m_bOpened )
    return E_UNEXPECTED;

  _EnterFunction(
    name,
    (RETTYPE) V_I4(&returntype),
    V_BSTR(&params)
    );

  return S_OK;
}


HRESULT
__stdcall
TestLog::LeaveFunction(
  VARIANT returnvalue
  )
{
  if( !m_bOpened )
    return E_UNEXPECTED;

  _LeaveFunction(
    returnvalue
    );

  return S_OK;
}


HRESULT
__stdcall
TestLog::Trace(
  BSTR message
  )
{
  if( !m_bOpened )
    return E_UNEXPECTED;

  _Trace(
    L"%s",
    message
    );

  return S_OK;
}


//-----------------------------------------------------------------------------
// IUnknown methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
TestLog::QueryInterface(
  REFIID riid,
  void** ppv
  )
{
  HRESULT hr = S_OK;

    if( ppv )
    {
      if(
        IsEqualIID(riid, IID_IUnknown)       ||
        IsEqualIID(riid, IID_IDispatch)      ||
        IsEqualIID(riid, IID_ITestLog)
        )
      {
        *ppv = static_cast<ITestLog*>(this);
      }
      else if( IsEqualIID(riid, IID_IProvideClassInfo) )
      {
        *ppv = static_cast<IProvideClassInfo*>(this);
      }
      else
      {
        *ppv = NULL;
        hr   = E_NOINTERFACE;
      }
    }
    else
    {
      hr = E_POINTER;
    }

    if( SUCCEEDED(hr) )
    {
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }

  return hr;
}


ULONG
__stdcall
TestLog::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
TestLog::Release(void)
{
  InterlockedDecrement(&m_cRefs);

  if( m_cRefs == 0 )
  {
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
TestLog::GetClassInfo(
  ITypeInfo** ppti
  )
{
  HRESULT hr = S_OK;

    if( ppti )
    {
      m_pTypeInfo->AddRef();
      *ppti = m_pTypeInfo;
    }
    else
    {
      hr = E_POINTER;
    }

  return hr;
}


//-----------------------------------------------------------------------------
// IDispatch methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
TestLog::GetTypeInfoCount(
  UINT* pctinfo
  )
{
  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  return hr;
}


HRESULT
__stdcall
TestLog::GetTypeInfo(
  UINT        index,
  LCID        lcid,
  ITypeInfo** ppti
  )
{
  HRESULT hr   = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  return hr;
}


HRESULT
__stdcall
TestLog::GetIDsOfNames(
  REFIID    riid,
  LPOLESTR* arNames,
  UINT      cNames,
  LCID      lcid,
  DISPID*   arDispId
  )
{
  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_TestLogDisptable, g_cTestLogDisptable, arNames[n]);
    ++n;
  }

quit:

  return hr;
}


HRESULT
__stdcall
TestLog::Invoke(
  DISPID      dispid,
  REFIID      riid,
  LCID        lcid,
  WORD        flags,
  DISPPARAMS* pdp,
  VARIANT*    pvr, 
  EXCEPINFO*  pei,
  UINT*       pae
  )
{
  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_VALUE :
      {
        V_VT(pvr) = VT_DISPATCH;
        hr        = QueryInterface(IID_IDispatch, (void**) &V_DISPATCH(pvr));
      }
      break;

    case DISPID_TESTLOG_OPEN :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 2, TRUE, 1);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(logname);
            NEWVARIANT(logtitle);
            NEWVARIANT(logmode);

            hr = DispGetParam(pdp, 0, VT_BSTR, &logname,  pae);

            if( SUCCEEDED(hr) )
            {
              hr = DispGetParam(pdp, 1, VT_BSTR, &logtitle, pae);
            }

            if( SUCCEEDED(hr) )
            {
              hr = DispGetOptionalParam(pdp, 2, VT_I4, &logmode, pae);
            }
                        
              hr = Open(
                     V_BSTR(&logname),
                     V_BSTR(&logtitle),
                     &logmode,
                     pvr
                     );

            VariantClear(&logname);
            VariantClear(&logtitle);
            VariantClear(&logmode);
          }
        }
      }
      break;

    case DISPID_TESTLOG_CLOSE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = Close();
          }
        }
      }
      break;

    case DISPID_TESTLOG_BEGINTEST :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 2, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(testname);
            NEWVARIANT(testid);

            hr = DispGetParam(pdp, 0, VT_BSTR, &testname, pae);

            if( SUCCEEDED(hr) )
            {
              hr = DispGetParam(pdp, 1, VT_I4, &testid, pae);
            }

            if( SUCCEEDED(hr) )
            {
              hr = BeginTest(
                     V_BSTR(&testname),
                     testid
                     );
            }

            VariantClear(&testname);
            VariantClear(&testid);
          }
        }
      }
      break;

    case DISPID_TESTLOG_ENDTEST :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = EndTest();
          }
        }
      }
      break;

    case DISPID_TESTLOG_FINALRESULT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, TRUE, 1);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(reason);
            NEWVARIANT(status);

            DispGetParam(pdp, 0, VT_BOOL, &status, pae);
            DispGetParam(pdp, 1, VT_BSTR, &reason, pae);
            
              hr = FinalResult(
                     status,
                     reason
                     );

            VariantClear(&reason);
            VariantClear(&status);
          }
        }
      }
      break;

    case DISPID_TESTLOG_ENTERFUNCTION :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, TRUE, 2);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(name);
            NEWVARIANT(params);
            NEWVARIANT(rettype);

            hr = DispGetParam(pdp, 0, VT_BSTR, &name, pae);

            if( SUCCEEDED(hr) )
            {
              hr = DispGetOptionalParam(pdp, 1, VT_BSTR, &params, pae);
            }

            if( SUCCEEDED(hr) )
            {
              hr = DispGetOptionalParam(pdp, 2, VT_I4, &rettype, pae);
            }

            if( SUCCEEDED(hr) )
            {
              hr = EnterFunction(
                     V_BSTR(&name),
                     params,
                     rettype
                     );
            }

            VariantClear(&name);
            VariantClear(&params);
            VariantClear(&rettype);
          }
        }
      }
      break;

    case DISPID_TESTLOG_LEAVEFUNCTION :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, TRUE, 1);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(retval);

            if( pdp->cArgs )
            {
              VariantCopy(&retval, &pdp->rgvarg[0]);
            }

            hr = LeaveFunction(
                   retval
                   );

            VariantClear(&retval);
          }
        }
      }
      break;

    case DISPID_TESTLOG_TRACE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(message);

            hr = DispGetParam(pdp, 0, VT_BSTR, &message, pae);

            if( SUCCEEDED(hr) )
            {
              hr = Trace(
                     V_BSTR(&pdp->rgvarg[0])
                     );
            }

            VariantClear(&message);
          }
        }
      }
      break;

    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"TestLog", pei, hr);
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\src\common\registry.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    registry.cpp

Abstract:

    Registry functions.
    
Author:

    Paul M Midgen (pmidge) 23-May-2000


Revision History:

    23-May-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include "common.h"


#define MAX_LENGTH (MAX_PATH+1)


LPCWSTR g_wszAppRootKeyName = L"Software\\Spork";
HKEY    g_hkAppRoot         = NULL;


DWORD
GetNumberOfSubKeysFromKey(LPCWSTR wszKeyName)
{
  BOOL   bStatus   = FALSE;
  DWORD  dwRet     = 0L;
  DWORD  dwSubKeys = 0L;
  HKEY   hKey      = NULL;


  dwRet = RegOpenKeyEx(
            g_hkAppRoot,
            wszKeyName, 0,
            KEY_READ,
            &hKey
            );

    if( dwRet )
    {
      SetLastError(dwRet);
      goto quit;
    }

  dwRet = RegQueryInfoKey(
            hKey,
            NULL,
            NULL,
            NULL,
            &dwSubKeys,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL
            );

  RegCloseKey(hKey);

quit:

  return dwSubKeys;
}


/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  GetRegValue()

  WHAT      : Reads the value of a REG_DWORD or REG_SZ registry value. The
              caller must free the value returned through ppvData.

  ARGS      : szValueName - the value to look up
              dwType      - can be REG_SZ or REG_DWORD
              ppvData     - address of a pointer to initialize to the data
                            read from the registry

  RETURNS   : True if the lookup succeeded, false if there was an error. The
              caller can call GetLastError() to determine the type of error.
              Possible values returned by GetLastError() are:

              ERROR_NOT_ENOUGH_MEMORY - failed to allocate storage for the
                                        requested key

              ERROR_INVALID_PARAMETER - unsupported type in dwType

              If registry lookups fail we set last error to the retcode
              from the registry api we called.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
BOOL
GetRootRegValue(
  LPCWSTR wszValueName,
  DWORD   dwType,
  LPVOID* ppvData
  )
{
  BOOL   bStatus = FALSE;
  DWORD  dwRet   = 0L;
  LPBYTE lpData  = NULL;
  DWORD  cbData  = 0L;

  switch( dwType )
  {
    case REG_DWORD :
      {
        cbData = sizeof(DWORD);
        lpData = new BYTE[cbData];

        if( !lpData )
        {
          SetLastError(ERROR_NOT_ENOUGH_MEMORY);
          goto quit;
        }
      }
      break;

    case REG_SZ :
      {
        // get required buffer size
        dwRet = RegQueryValueEx(
                  g_hkAppRoot, wszValueName, 0L,
                  &dwType, lpData, &cbData
                  );

          if( dwRet )
          {
            SetLastError(dwRet);
            goto quit;
          }

        lpData = new BYTE[cbData];

          if( !lpData )
          {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto quit;
          }
      }
      break;

    default :
      {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto quit;
      }
      break;
  }

  //
  // do the lookup
  //
  dwRet = RegQueryValueEx(
            g_hkAppRoot, wszValueName, 0L,
            &dwType, lpData, &cbData
            );
    
    if( dwRet )
    {
      SAFEDELETEBUF(lpData);
      SetLastError(dwRet);
      goto quit;
    }

  bStatus  = TRUE;
  *ppvData = (LPVOID) lpData;

quit:

  return bStatus;
}


BOOL
GetRegValueFromKey(
  LPCWSTR wszKeyName,
  LPCWSTR wszValueName,
  DWORD   dwType,
  LPVOID* ppvData
  )
{
  BOOL   bStatus = FALSE;
  DWORD  dwRet   = 0L;
  HKEY   hkey    = NULL;
  LPBYTE lpData  = NULL;
  DWORD  cbData  = 0L;


  dwRet = RegOpenKeyEx(
            g_hkAppRoot,
            wszKeyName, 0,
            KEY_READ,
            &hkey
            );

  if( dwRet )
  {
    SetLastError(dwRet);
    return bStatus;
  }

  switch( dwType )
  {
    case REG_DWORD :
      {
        cbData = sizeof(DWORD);
        lpData = new BYTE[cbData];

        if( !lpData )
        {
          SetLastError(ERROR_NOT_ENOUGH_MEMORY);
          goto quit;
        }
      }
      break;

    case REG_SZ :
      {
        // get required buffer size
        dwRet = RegQueryValueEx(
                  hkey, wszValueName, 0L,
                  &dwType, lpData, &cbData
                  );

          if( dwRet )
          {
            SetLastError(dwRet);
            goto quit;
          }

        lpData = new BYTE[cbData];

          if( !lpData )
          {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto quit;
          }
      }
      break;

    default :
      {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto quit;
      }
      break;
  }

  //
  // do the lookup
  //
  dwRet = RegQueryValueEx(
            hkey, wszValueName, 0L,
            &dwType, lpData, &cbData
            );
    
    if( dwRet )
    {
      SAFEDELETEBUF(lpData);
      SetLastError(dwRet);
      goto quit;
    }

  bStatus  = TRUE;
  *ppvData = (LPVOID) lpData;

quit:

  RegCloseKey(hkey);
  return bStatus;
}


BOOL
EnumerateSubKeysFromKey(
  LPCWSTR wszKeyName,
  LPWSTR* ppwszSubKeyName
  )
{
  static HKEY  hKey    = NULL;
  static DWORD dwIndex = 0L;

  BOOL   bStatus = FALSE;
  DWORD  dwRet   = 0L;
  LPWSTR lpName  = NULL;
  DWORD  cbName  = 0L;

  if( wszKeyName )
  {
    if( hKey )
    {
      RegCloseKey(hKey);
      hKey    = NULL;
      dwIndex = 0L;
    }

    dwRet = RegOpenKeyEx(
              g_hkAppRoot,
              wszKeyName, 0,
              KEY_READ,
              &hKey
              );

    if( dwRet )
    {
      SetLastError(dwRet);
      goto quit;
    }
  }
  else
  {
    if( !hKey )
      goto quit;
  }

  lpName = new WCHAR[MAX_LENGTH];
  cbName = MAX_LENGTH;

  dwRet = RegEnumKey(
            hKey,
            dwIndex++,
            lpName,
            cbName
            );

  if( dwRet == ERROR_SUCCESS )
  {
    *ppwszSubKeyName = StrDup(lpName);
    bStatus          = TRUE;
  }
  else
  {
    RegCloseKey(hKey);
    hKey    = NULL;
    dwIndex = 0L;
  }

quit:

  SAFEDELETEBUF(lpName);

  return bStatus;
}


BOOL
EnumerateRegValuesFromKey(
  LPCWSTR  wszKeyName,
  LPWSTR*  ppwszValueName,
  LPDWORD  pdwType,
  LPVOID*  ppvData
  )
{
  static HKEY  hKey    = NULL;
  static DWORD dwIndex = 0L;

  BOOL   bStatus = FALSE;
  DWORD  dwRet   = 0L;
  LPWSTR lpName  = NULL;
  DWORD  cbName  = 0L;
  LPBYTE lpData  = NULL;
  DWORD  cbData  = 0L;
  DWORD  dwType  = 0L;

  if( wszKeyName )
  {
    if( hKey )
    {
      RegCloseKey(hKey);
      hKey    = NULL;
      dwIndex = 0L;
    }

    dwRet = RegOpenKeyEx(
              g_hkAppRoot,
              wszKeyName, 0,
              KEY_READ,
              &hKey
              );

    if( dwRet )
    {
      SetLastError(dwRet);
      goto quit;
    }
  }
  else
  {
    if( !hKey )
      goto quit;
  }

  lpName = new WCHAR[MAX_LENGTH];
  cbName = MAX_LENGTH;

  dwRet = RegEnumValue(
            hKey,
            dwIndex++,
            lpName,
            &cbName,
            NULL,
            &dwType,
            NULL,
            &cbData
            );

  if( dwRet == ERROR_SUCCESS )
  {
    lpData = new BYTE[cbData];

    dwRet = RegQueryValueEx(
              hKey,
              lpName,
              0L,
              &dwType,
              lpData,
              &cbData
              );
    
    if( dwRet == ERROR_SUCCESS )
    {
      *ppwszValueName = StrDup(lpName);
      *pdwType        = dwType;
      *ppvData        = lpData;
      bStatus         = TRUE;
    }
    else
    {
      SAFEDELETEBUF(lpData);
      SetLastError(dwRet);
      goto quit;
    }
  }
  else
  {
    RegCloseKey(hKey);
    hKey    = NULL;
    dwIndex = 0L;
  }

quit:

  SAFEDELETEBUF(lpName);

  return bStatus;
}


/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  SetRegValue()

  WHAT      : Writes a value under the application registry key.

  ARGS      : szValueName - the name of the regkey to write to
              dwType      - type of the regkey to write
              pvData      - regkey data
              dwSize      - bytecount of data to write

  RETURNS   : True if the write succeeded, false if otherwise.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
BOOL
SetRootRegValue(
  LPCWSTR wszValueName,
  DWORD   dwType,
  LPVOID  pvData,
  DWORD   dwSize
  )
{
  BOOL  bStatus = FALSE;
  DWORD dwRet   = 0L;

    if( !dwSize && pvData )
      dwSize = strlen((LPSTR)pvData);

    dwRet = RegSetValueEx(
              g_hkAppRoot, wszValueName, 0L,
              dwType, (LPBYTE)pvData, dwSize
              );

    if( dwRet != ERROR_SUCCESS )
      SetLastError(dwRet);
    else
      bStatus = TRUE;      

  return bStatus;
}


BOOL
SetRegKey(
  LPCWSTR wszPath,
  LPCWSTR wszKeyName
  )
{
  HKEY  hKeyPath = NULL;
  HKEY  hKeyNew  = NULL;
  BOOL  bStatus  = FALSE;
  DWORD dwRet    = 0L;

  dwRet = RegCreateKeyEx(
            g_hkAppRoot,
            wszPath, 0,
            NULL, 0,
            KEY_ALL_ACCESS,
            NULL,
            &hKeyPath,
            NULL
            );

  if( dwRet == ERROR_SUCCESS )
  {
    bStatus = TRUE;
  }
  else
  {
    goto quit;
  }

  if( wszKeyName )
  {
    dwRet = RegCreateKeyEx(
              hKeyPath,
              wszKeyName, 0,
              NULL, 0,
              KEY_ALL_ACCESS,
              NULL,
              &hKeyNew,
              NULL
              );

    if( dwRet == ERROR_SUCCESS )
    {
      RegCloseKey(hKeyNew);
      bStatus = TRUE;
    }
    else
    {
      bStatus = FALSE;
    }
  }

  RegCloseKey(hKeyPath);

quit:

  return bStatus;
}


BOOL
SetRegValueInKey(
  LPCWSTR wszKeyName,
  LPCWSTR wszValueName,
  DWORD   dwType,
  LPVOID  pvData,
  DWORD   dwSize
  )
{
  HKEY  hKey    = NULL;
  BOOL  bStatus = FALSE;
  DWORD dwRet   = 0L;

  dwRet = RegOpenKeyEx(
            g_hkAppRoot,
            wszKeyName, 0,
            KEY_WRITE,
            &hKey
            );

  if( dwRet )
  {
    SetLastError(dwRet);
    return bStatus;
  }

  if( !dwSize && pvData )
  {
    if( dwType == REG_SZ )
    {
      dwSize = (wcslen((LPWSTR) pvData) * sizeof(WCHAR));
    }
    else if( dwType == REG_DWORD )
    {
      dwSize = sizeof(DWORD);
    }
    else
    {
      dwRet = ERROR_INVALID_PARAMETER;
      goto quit;
    }
  }

  dwRet = RegSetValueEx(
            hKey, wszValueName,
            0L, dwType,
            (LPBYTE) pvData, dwSize
            );

  if( dwRet )
  {
    SetLastError(dwRet);
    goto quit;
  }

  bStatus = TRUE;

quit:

  RegCloseKey(hKey);
  return bStatus;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  ManageRootKey()

  WHAT      : Opens or closes the application's root regkey.

  ARGS      : fOpen - open or close the key.

  RETURNS   : True on success

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
BOOL
ManageRootKey(
  BOOL fOpen
  )
{
  DWORD disp = 0;
  DWORD ret  = ERROR_SUCCESS;

  if( fOpen )
  {
    if( !g_hkAppRoot )
    {
      ret = RegCreateKeyEx(
              HKEY_CURRENT_USER,
              g_wszAppRootKeyName,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &g_hkAppRoot,
              &disp
              );
    }
  }
  else
  {
    if( g_hkAppRoot )
    {
      RegCloseKey(g_hkAppRoot);
      g_hkAppRoot = NULL;
    }
  }

  return (ret == ERROR_SUCCESS) ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\sporklets\testlog\src\utils.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    utils.cxx

Abstract:

    Utility functions used by the project.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


//-----------------------------------------------------------------------------
// new & delete
//-----------------------------------------------------------------------------
void* __cdecl operator new(size_t size)
{
  return (void*) LocalAlloc(
#ifdef NO_ZEROINIT
    NONZEROLPTR,
#else
    LPTR,
#endif
    size);
}

void __cdecl operator delete(void* pv)
{
  LocalFree(pv);
}

//-----------------------------------------------------------------------------
// general utility functions
//-----------------------------------------------------------------------------
HRESULT
GetTypeInfoFromName(LPCOLESTR name, ITypeLib* ptl, ITypeInfo** ppti)
{
  HRESULT  hr     = S_OK;
  BOOL     bFound = FALSE;
  USHORT   cf     = 1L;
  ULONG    hash   = 0L;
  LONG     id     = 0L;
  LPOLESTR pstr   = NULL;

  if( !name || ! ptl )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppti )
  {
    hr = E_POINTER;
    goto quit;
  }

  *ppti = NULL;
  pstr  = StrDup(name);

    ptl->IsName(pstr, 0L, &bFound);

      if( !bFound )
      {
        hr = TYPE_E_ELEMENTNOTFOUND;
        goto quit;
      }

    hash = LHashValOfNameSys(
             SYS_WIN32,
             MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT),
             pstr
             );

    hr = ptl->FindName(pstr, hash, ppti, &id, &cf);

quit:

  SAFEDELETEBUF(pstr);
  return hr;
}

DISPID
GetDispidFromName(PDISPIDTABLEENTRY pdt, DWORD cEntries, LPWSTR name)
{
  DWORD  n      = 0L;
  DWORD  hash   = GetHash(name);
  DISPID dispid = DISPID_UNKNOWN;

  while( n < cEntries )
  {
    if( pdt[n].hash != hash )
    {
      ++n;
    }
    else
    {
      dispid = pdt[n].dispid;
      break;
    }
  }

  return dispid;
}

void
AddRichErrorInfo(EXCEPINFO* pei, LPWSTR source, LPWSTR description, HRESULT error)
{
  if( pei )
  {
    pei->bstrSource      = __widetobstr((source ? source : L"unknown source"));
    pei->bstrDescription = __widetobstr((description ? description : L"no description"));
    pei->scode           = error;
  }
}

DWORD
GetHash(LPWSTR name)
{
  DWORD hash   = 0L;
  DWORD n      = 0L;
  DWORD len    = 0L;
  LPSTR string = NULL;

  string = __widetoansi(name);

  if( string )
  {
    _strlwr(string);

    for(n=0, len=strlen(string); n<=len; n++)
    {
      hash += __toascii(string[len-n]) * ((10<<n)^n);
    }
  }

  SAFEDELETEBUF(string);
  return hash;
}

HRESULT
DispGetOptionalParam(DISPPARAMS* pdp, UINT pos, VARTYPE vt, VARIANT* pvr, UINT* pae)
{
  HRESULT hr = DispGetParam(pdp, pos, vt, pvr, pae);

  //
  // if DispGetParam failed due to a type mismatch, it was likely deliberate on
  // the part of the dispatch code. i pass in VT_VARIANT when i have no idea
  // what the controller is sending me, all i know is that i need a copy, maybe.
  //
  if( hr == DISP_E_TYPEMISMATCH )
  {
    hr = VariantCopy(pvr, &pdp->rgvarg[((pdp->cArgs-1)-pos)]);
  }

  return (hr == DISP_E_PARAMNOTFOUND) ? S_OK : hr;
}

HRESULT
ValidateDispatchArgs(REFIID riid, DISPPARAMS* pdp, VARIANT* pvr, UINT* pae)
{
  HRESULT hr = S_OK;

    if( !IsEqualIID(riid, IID_NULL) )
    {
      hr = DISP_E_UNKNOWNINTERFACE;
      goto quit;
    }

    if( !pdp )
    {
      hr = E_INVALIDARG;
      goto quit;
    }

    if( pae )
    {
      *pae = 0;
    }

    if( pvr )
    {
      VariantInit(pvr);
    }

quit:

  return hr;
}

HRESULT
ValidateInvokeFlags(WORD flags, WORD accesstype, BOOL bMethod)
{
  HRESULT hr = S_OK;

    if( (flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT)) )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      if( !bMethod )
      {
        if( flags & DISPATCH_METHOD )
        {
          hr = E_NOINTERFACE;
        }
        else
        {
          if( (flags & DISPATCH_PROPERTYPUT) && !(accesstype & DISPATCH_PROPERTYPUT) )
          {
            hr = E_ACCESSDENIED;
          }
          else
          {
            if( !(flags & accesstype) )
            {
              hr = E_FAIL;
            }
          }
        }
      }
      else
      {
        if( flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET) )
        {
          hr = E_NOINTERFACE;
        }
      }
    }

  return hr;
}

HRESULT
ValidateArgCount(DISPPARAMS* pdp, DWORD needed, BOOL bHasOptionalArgs, DWORD optional)
{
  HRESULT hr = S_OK;

    if( bHasOptionalArgs )
    {
      if( (pdp->cArgs > needed+optional) || (pdp->cArgs < needed) )
      {
        hr = DISP_E_BADPARAMCOUNT;
      }
    }
    else
    {
      if( (!needed && pdp->cArgs) || (needed < pdp->cArgs) )
      {
        hr = DISP_E_BADPARAMCOUNT;
      }
      else
      {
        hr = (pdp->cArgs == needed) ? S_OK : DISP_E_PARAMNOTOPTIONAL;
      }
    }

  return hr;
}

HRESULT
HandleDispatchError(LPWSTR id, EXCEPINFO* pei, HRESULT hr)
{
  LPWSTR msg = NULL;

  switch( hr )
  {
    case E_POINTER      : msg = L"a return pointer parameter was missing";                          break;
    case E_ACCESSDENIED : msg = L"an attempt to modify a property failed because it is read-only";  break;
    case E_FAIL         : msg = L"an unhandled error occurred";                                     break;
    case E_INVALIDARG   : msg = L"an argument passed to a property or method was invalid";          break;
    case E_NOINTERFACE  : msg = L"a property or method was accessed incorrectly";                   break;
    case E_UNEXPECTED   : msg = L"a call to open() must precede any attempt to use the log object"; break;
    default             : return hr;
  }

  AddRichErrorInfo(pei, id, msg, hr);

  return DISP_E_EXCEPTION;
}

//-----------------------------------------------------------------------------
// string & type manipulation
//-----------------------------------------------------------------------------
WCHAR*
__ansitowide(const char* psz)
{
  WCHAR* wide = NULL;
  int    len  = 0L;

  if( psz )
  {
    len = strlen(psz);

    if( len )
    {
      wide      = new WCHAR[len+1];
      wide[len] = L'\0';

      MultiByteToWideChar(
        CP_ACP, 0,
        psz,  len,
        wide, len
        );
    }
  }

  return wide;
}

CHAR*
__widetoansi(const WCHAR* pwsz)
{
  CHAR* ansi = NULL;
  int   len  = 0L;
  BOOL  def  = FALSE;

  if( pwsz )
  {
    len = wcslen(pwsz);

    if( len )
    {
      ansi      = new CHAR[len+1];
      ansi[len] = '\0';

      WideCharToMultiByte(
        CP_ACP, 0,
        pwsz, len,
        ansi, len,
        "?", &def
        );
    }
  }

  return ansi;
}

BSTR
__ansitobstr(LPCSTR src)
{
  BSTR   ret = NULL;
  LPWSTR wsz = NULL;

  if( src )
  {
    wsz = __ansitowide(src);
    ret = SysAllocString(wsz);
    SAFEDELETEBUF(wsz);
  }

  return ret;
}

BSTR
__widetobstr(LPCWSTR wsrc)
{
  return (wsrc ? SysAllocString(wsrc) : NULL);
}

BOOL
__isempty(VARIANT* var)
{
  BOOL isempty = FALSE;

  if( var )
  {
    if(
        ((V_VT(var) == VT_EMPTY) || (V_VT(var) == VT_NULL) || (V_VT(var) == VT_ERROR)) ||
        ((V_VT(var) == VT_BSTR) && (SysStringLen(V_BSTR(var)) == 0))
      )
    {
      isempty = TRUE;
    }
  }
  else
  {
    isempty = TRUE;
  }

  return isempty;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\src\scrobj\iactivescriptsitedebug.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    iactivescriptsitedebug.cxx

Abstract:

    Implements the IActiveScriptSiteDebug interface for the ScriptObject class.
    
Author:

    Paul M Midgen (pmidge) 20-April-2001


Revision History:

    20-April-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


//-----------------------------------------------------------------------------
// ScriptObject script debugging methods
//-----------------------------------------------------------------------------
HRESULT
ScriptObject::_LoadScriptDebugger(void)
{
  HRESULT               hr   = S_OK;
  IProcessDebugManager* pdbm = NULL;

  if( !m_pDebugApplication )
  {
    hr = CoCreateInstance(
           CLSID_ProcessDebugManager,
           NULL,
           CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER | CLSCTX_LOCAL_SERVER,
           IID_IProcessDebugManager,
           (void**) &pdbm
           );

    if( SUCCEEDED(hr) )
    {
      hr = pdbm->GetDefaultApplication(&m_pDebugApplication);

      if( SUCCEEDED(hr) )
      {
        hr = m_pDebugApplication->SetName(L"Spork");
      }
    }
  
    SAFERELEASE(pdbm);
  }

  return hr;
}


//-----------------------------------------------------------------------------
// IActiveScriptSiteDebug
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ScriptObject::GetDocumentContextFromPosition(
  DWORD dwSourceContext,
  ULONG uCharacterOffset,
  ULONG uNumChars,
  IDebugDocumentContext** ppdc
  )
{
  return E_NOTIMPL;
}


HRESULT
__stdcall
ScriptObject::GetApplication(
  IDebugApplication** ppda
  )
{
  HRESULT hr = S_OK;

  if( m_DebugOptions.bEnableDebug )
  {
    *ppda = m_pDebugApplication;
    (*ppda)->AddRef();
  }
  else
  {
    *ppda = NULL;
    hr    = E_FAIL;
  }

  return hr;
}


HRESULT
__stdcall
ScriptObject::GetRootApplicationNode(
  IDebugApplicationNode** ppdan
  )
{
  return E_NOTIMPL;
}


HRESULT
__stdcall
ScriptObject::OnScriptErrorDebug(
  IActiveScriptErrorDebug* pErrorDebug,
  LPBOOL pfEnterDebugger,
  LPBOOL pfCallOnScriptErrorWhenContinuing
  )
{
  DEBUG_ENTER((
    L"ScriptObject::OnScriptErrorDebug",
    rt_hresult,
    L"this=%#x; pErrorDebug=%#x; pfEnterDebugger=%#x; pfCallOnScriptErrorWhenContinuing=%#x",
    this,
    pErrorDebug,
    pfEnterDebugger,
    pfCallOnScriptErrorWhenContinuing
    ));

  HRESULT             hr    = S_OK;
  IActiveScriptError* piase = NULL;

  if( m_DebugOptions.bEnableDebug )
  {
    LogTrace(L"launching script debugger");

    *pfEnterDebugger                   = TRUE;
    *pfCallOnScriptErrorWhenContinuing = FALSE;
  }
  else
  {
    hr = pErrorDebug->QueryInterface(IID_IActiveScriptError, (void**) &piase);

    DEBUG_TRACE((L"delegating to OnScriptError"));

    if( SUCCEEDED(hr) )
    {
      *pfEnterDebugger                   = FALSE;
      *pfCallOnScriptErrorWhenContinuing = FALSE;

      hr = OnScriptError(piase);

      SAFERELEASE(piase);
    }
    else
    {
      *pfEnterDebugger                   = FALSE;
      *pfCallOnScriptErrorWhenContinuing = TRUE;
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\src\log\log.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    log.cxx

Abstract:

    Implementation of the session logging routines for Spork.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include "common.h"


//-----------------------------------------------------------------------------
// Logging variables
//-----------------------------------------------------------------------------
HANDLE     g_hLogFile     = INVALID_HANDLE_VALUE;
DWORD      g_dwTlsIndex   = 0L;
BOOL       g_bOutputToDbg = TRUE;
CRITSEC    g_csLogFile;


//-----------------------------------------------------------------------------
// Private
//-----------------------------------------------------------------------------
void         WriteToLog(LPTHREADINFO pti, BOOL fTrace, DEPTH depth, LPCWSTR format, ...);
LPTHREADINFO GetThreadInfo(void);
LPCALLINFO   PushCallInfo(LPTHREADINFO pti, LPCWSTR function, RETTYPE rt);
LPCALLINFO   PopCallInfo(LPTHREADINFO pti);
void         DeleteCallInfo(LPCALLINFO pci);
void         AcquireFileLock(void);
void         ReleaseFileLock(void);
LPWSTR       FormatCallReturnString(LPCALLINFO pci, INT_PTR retval);
LPWSTR       GetWhiteSpace(int spaces);
LPWSTR       GetTimeStamp(void);


//-----------------------------------------------------------------------------
// Logging functions
//-----------------------------------------------------------------------------
void
ToggleDebugOutput(
  BOOL bEnable
  )
{
  if( !bEnable )
  {
    LogTrace(L"debugger output disabled (specify -d to enable)");
  }

  g_bOutputToDbg = bEnable;
}


HRESULT
LogInitialize(void)
{
  HRESULT hr   = S_OK;
  LPWSTR  time = GetTimeStamp();

  if( (g_dwTlsIndex = TlsAlloc()) == 0xFFFFFFFF )
  {
    hr = E_FAIL;
    goto quit;
  }

  __try
  {
    InitializeCriticalSection(&g_csLogFile);
  }
  __except(EXCEPTION_EXECUTE_HANDLER)
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

  g_hLogFile = CreateFile(
                 L"spork.log",
                 GENERIC_WRITE,
                 FILE_SHARE_READ,
                 NULL,
                 CREATE_ALWAYS,
                 FILE_ATTRIBUTE_NORMAL,
                 NULL
                 );
    
      if( !g_hLogFile )
      {
        hr = E_FAIL;
        goto quit;
      }

  WriteToLog(NULL, FALSE, MAINTAIN, L"Spork Session Log\r\n\r\nopened: %s\r\n", time);

quit:

  SAFEDELETEBUF(time);
  return hr;
}


void
LogTerminate(void)
{
  LPWSTR  time   = GetTimeStamp();
  LPDWORD pdepth = (LPDWORD) TlsGetValue(g_dwTlsIndex);

  WriteToLog(NULL, FALSE, MAINTAIN, L"\r\nclosed: %s", time);

  TlsFree(g_dwTlsIndex);
  DeleteCriticalSection(&g_csLogFile);
  SAFECLOSE(g_hLogFile);
  SAFEDELETE(pdepth);
  SAFEDELETEBUF(time);
}


void
LogEnterFunction(
  LPCWSTR function,
  RETTYPE rt,
  LPCWSTR format,
  ...
  )
{
  LPTHREADINFO pti = GetThreadInfo();

  PushCallInfo(pti, function, rt);

  if( format )
  {
    WCHAR   buf[1024];
    va_list arg_list;

    va_start(arg_list, format);

      wvnsprintf(buf, 1024, format, arg_list);
      WriteToLog(pti, FALSE, INCREMENT, L"%s(%s)", function, buf);

    va_end(arg_list);
  }
  else
  {
    WriteToLog(pti, FALSE, INCREMENT, L"%s()", function);
  }
}


void
LogLeaveFunction(
  INT_PTR retval
  )
{
  LPTHREADINFO pti = GetThreadInfo();
  LPCALLINFO   pci = PopCallInfo(pti);
  LPWSTR       buf = FormatCallReturnString(pci, retval);

  WriteToLog(pti, FALSE, DECREMENT, buf);
  DeleteCallInfo(pci);

  SAFEDELETEBUF(buf);
}


void
LogTrace(
  LPCWSTR format,
  ...
  )
{
  WCHAR   buf[1024];
  va_list arg_list;

  va_start(arg_list, format);

    wvnsprintf(buf, 1024, format, arg_list);
    WriteToLog(GetThreadInfo(), TRUE, MAINTAIN, buf);

  va_end(arg_list);
}


void
WriteToLog(
  LPTHREADINFO pti,
  BOOL         fTrace,
  DEPTH        depth,
  LPCWSTR      format,
  ...
  )
{
  LPSTR   ansi       = NULL;
  DWORD   offset     = 0;
  LPWSTR  tmp        = NULL;
  LPWSTR  buffer     = new WCHAR[2048];
  DWORD   call_depth = 0;
  va_list arg_list;

  if( !buffer )
    goto quit;

  //
  // pti will only be null in cases where WriteToLog is called directly. enter/leave/trace make
  // sure a pti has been allocated.
  //
  if( pti )
  {
    if( depth == INCREMENT )
    {
      ++pti->depth;
      call_depth = pti->depth;
    }
    else if( depth == DECREMENT )
    {
      call_depth = pti->depth;
      --pti->depth;
    }
    else
    {
      call_depth = pti->depth;
    }

    tmp     = GetTimeStamp();
    offset  = wnsprintf(buffer, 2048, L"%s ", tmp);
    SAFEDELETEBUF(tmp);

    offset += wnsprintf(buffer+offset, 2048-offset, L"%0.8x:%0.3d ", pti->threadid, call_depth);
    tmp     = GetWhiteSpace((fTrace ? call_depth+1 : call_depth));
    offset += wnsprintf(buffer+offset, 2048-offset, L"%s", tmp);
    SAFEDELETEBUF(tmp);
  }

  if( format )
  {
    va_start(arg_list, format);
    
      offset += wvnsprintf(buffer+offset, 2048-offset, format, arg_list);
      wnsprintf(buffer+offset, 2048-offset, L"\r\n");
    
    va_end(arg_list);
  }

  ansi   = __widetoansi(buffer);
  offset = 0;

  EnterCriticalSection(&g_csLogFile);
  
      WriteFile(
        g_hLogFile,
        ansi,
        strlen(ansi),
        &offset,
        NULL
        );

  LeaveCriticalSection(&g_csLogFile);

  SAFEDELETEBUF(ansi);

  if( g_bOutputToDbg )
  {
    OutputDebugString(buffer);
  }

quit:

  SAFEDELETEBUF(buffer);
}


LPTHREADINFO
GetThreadInfo(void)
{
  LPTHREADINFO pti = (LPTHREADINFO) TlsGetValue(g_dwTlsIndex);

    if( !pti )
    {
      pti = new THREADINFO;

      pti->threadid  = GetCurrentThreadId();
      pti->depth     = 0;
      pti->stack     = NULL;

      TlsSetValue(g_dwTlsIndex, (LPVOID) pti);
    }

  return pti;
}


LPCALLINFO
PushCallInfo(
  LPTHREADINFO pti,
  LPCWSTR      function,
  RETTYPE      rt
  )
{
  LPCALLINFO pci   = NULL;
  LPCALLINFO plast = NULL;

  for( pci = pti->stack; pci; pci = pci->next )
  {
    plast = pci;
  }

  if( !pci )
  {
    pci          = new CALLINFO;
    pci->fname   = StrDup(function);
    pci->rettype = rt;
    pci->last    = plast;
    pci->next    = NULL;

    if( !pti->stack )
    {
      pti->stack = pci;
    }
    else
    {
      plast->next = pci;
    }
  }

  return pci;
}


LPCALLINFO
PopCallInfo(
  LPTHREADINFO pti
  )
{
  LPCALLINFO pci = NULL;

  if( pti->stack )
  {
    for(pci = pti->stack; pci->next; pci = pci->next);
  }

  return pci;
}


void
DeleteCallInfo(
  LPCALLINFO pci
  )
{
  LPTHREADINFO pti = GetThreadInfo();

  if( pci->last )
  {
    pci->last->next = NULL;
  }
  else
  {
    // when the last record is gone, whack the threadinfo
    SAFEDELETE(pti);
    TlsSetValue(g_dwTlsIndex, NULL);
  }

  SAFEDELETEBUF(pci->fname);
  SAFEDELETE(pci);
}


LPWSTR
FormatCallReturnString(
  LPCALLINFO pci,
  INT_PTR    retval
  )
{
  LPWSTR buffer = new WCHAR[256];
  int    offset = 0;

  if( buffer )
  {
    offset = wnsprintf(buffer, 256, L"%s() returned ", pci->fname);

    switch( pci->rettype )
    {
      case rt_void :
        {
          wnsprintf(buffer+offset, 256-offset, L"<void>");
        }
        break;

      case rt_bool :
        {
          wnsprintf(buffer+offset, 256-offset, L"%s", TF(retval));
        }
        break;

      case rt_dword :
        {
          wnsprintf(buffer+offset, 256-offset, L"%d [%s]", retval, MapErrorToString(retval));
        }
        break;

      case rt_hresult :
        {
          wnsprintf(buffer+offset, 256-offset, L"%x [%s]", retval, MapHResultToString((HRESULT) retval));
        }
        break;

      case rt_string :
        {
          wnsprintf(buffer+offset, 256-offset, L"%.16s", (LPWSTR) retval);
        }
        break;

      default:
        {
          wnsprintf(buffer+offset, 256-offset, L"?");
        }
    }
  }

  return buffer;
}


//-----------------------------------------------------------------------------
// Utility functions
//-----------------------------------------------------------------------------
LPWSTR
GetWhiteSpace(
  int spaces
  )
{
  int    n   = 0;
  LPWSTR buf = new WCHAR[(spaces * 2) + 1];

  if( buf )
  {
    while(n<(spaces*2)) buf[n++] = L' ';
    buf[n] = L'\0';
  }

  return buf;
}


LPWSTR
GetTimeStamp(void)
{
  SYSTEMTIME st;
  LPWSTR     buf = new WCHAR[256];
  
  if( buf )
  {
    GetLocalTime(&st);

    wnsprintf(
      buf,
      256,
      L"%0.2d:%0.2d:%0.2d.%0.3d",
      st.wHour,
      st.wMinute,
      st.wSecond,
      st.wMilliseconds
      );
  }

  return buf;
}


//-----------------------------------------------------------------------------
// Mapping functions
//-----------------------------------------------------------------------------
LPWSTR
MapHResultToString(HRESULT hr)
{
  switch(hr)
  {
    CASE_OF(S_OK);
    CASE_OF(E_NOINTERFACE);
    CASE_OF(E_POINTER);
    CASE_OF(E_UNEXPECTED);
    CASE_OF(E_INVALIDARG);
    CASE_OF(E_OUTOFMEMORY);
    CASE_OF(E_FAIL);
    CASE_OF(E_NOTIMPL);
    CASE_OF(E_PENDING);
    CASE_OF(E_ACCESSDENIED);
    CASE_OF(CLASS_E_NOAGGREGATION);
    CASE_OF(TYPE_E_IOERROR);
    CASE_OF(TYPE_E_REGISTRYACCESS);
    CASE_OF(TYPE_E_INVALIDSTATE);
    CASE_OF(TYPE_E_BUFFERTOOSMALL);
    CASE_OF(TYPE_E_FIELDNOTFOUND);
    CASE_OF(TYPE_E_ELEMENTNOTFOUND);
    CASE_OF(TYPE_E_AMBIGUOUSNAME);
    CASE_OF(TYPE_E_UNKNOWNLCID);
    CASE_OF(TYPE_E_BADMODULEKIND);
    CASE_OF(TYPE_E_CANTLOADLIBRARY);
    CASE_OF(TYPE_E_INCONSISTENTPROPFUNCS);
    CASE_OF(CONNECT_E_NOCONNECTION);
    CASE_OF(CONNECT_E_ADVISELIMIT);
    CASE_OF(CO_E_OBJNOTREG);
    CASE_OF(DISP_E_BADPARAMCOUNT);
    CASE_OF(DISP_E_BADVARTYPE);
    CASE_OF(DISP_E_EXCEPTION);
    CASE_OF(DISP_E_MEMBERNOTFOUND);
    CASE_OF(DISP_E_NONAMEDARGS);
    CASE_OF(DISP_E_OVERFLOW);
    CASE_OF(DISP_E_PARAMNOTFOUND);
    CASE_OF(DISP_E_TYPEMISMATCH);
    CASE_OF(DISP_E_UNKNOWNINTERFACE);
    CASE_OF(DISP_E_UNKNOWNLCID);
    CASE_OF(DISP_E_PARAMNOTOPTIONAL);
    CASE_OF(DISP_E_UNKNOWNNAME);

    default : return L"?";
  }
}


LPWSTR
MapErrorToString(INT_PTR error)
{
  switch(error)
  {
    CASE_OF(ERROR_SUCCESS);
    CASE_OF(ERROR_INVALID_FUNCTION);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);

    CASE_OF(EXCEPTION_ACCESS_VIOLATION);
    CASE_OF(EXCEPTION_DATATYPE_MISALIGNMENT);
    CASE_OF(EXCEPTION_BREAKPOINT);
    CASE_OF(EXCEPTION_SINGLE_STEP);
    CASE_OF(EXCEPTION_ARRAY_BOUNDS_EXCEEDED);
    CASE_OF(EXCEPTION_FLT_DENORMAL_OPERAND);
    CASE_OF(EXCEPTION_FLT_DIVIDE_BY_ZERO);
    CASE_OF(EXCEPTION_FLT_INEXACT_RESULT);
    CASE_OF(EXCEPTION_FLT_INVALID_OPERATION);
    CASE_OF(EXCEPTION_FLT_OVERFLOW);
    CASE_OF(EXCEPTION_FLT_STACK_CHECK);
    CASE_OF(EXCEPTION_FLT_UNDERFLOW);
    CASE_OF(EXCEPTION_INT_DIVIDE_BY_ZERO);
    CASE_OF(EXCEPTION_INT_OVERFLOW);
    CASE_OF(EXCEPTION_PRIV_INSTRUCTION);
    CASE_OF(EXCEPTION_IN_PAGE_ERROR);
    CASE_OF(EXCEPTION_ILLEGAL_INSTRUCTION);
    CASE_OF(EXCEPTION_NONCONTINUABLE_EXCEPTION);
    CASE_OF(EXCEPTION_STACK_OVERFLOW);
    CASE_OF(EXCEPTION_INVALID_DISPOSITION);
    CASE_OF(EXCEPTION_GUARD_PAGE);
    CASE_OF(EXCEPTION_INVALID_HANDLE);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);

    CASE_OF(WSAEINTR);
    CASE_OF(WSAEBADF);
    CASE_OF(WSAEACCES);
    CASE_OF(WSAEFAULT);
    CASE_OF(WSAEINVAL);
    CASE_OF(WSAEMFILE);
    CASE_OF(WSAEWOULDBLOCK);
    CASE_OF(WSAEINPROGRESS);
    CASE_OF(WSAEALREADY);
    CASE_OF(WSAENOTSOCK);
    CASE_OF(WSAEDESTADDRREQ);
    CASE_OF(WSAEMSGSIZE);
    CASE_OF(WSAEPROTOTYPE);
    CASE_OF(WSAENOPROTOOPT);
    CASE_OF(WSAEPROTONOSUPPORT);
    CASE_OF(WSAESOCKTNOSUPPORT);
    CASE_OF(WSAEOPNOTSUPP);
    CASE_OF(WSAEPFNOSUPPORT);
    CASE_OF(WSAEAFNOSUPPORT);
    CASE_OF(WSAEADDRINUSE);
    CASE_OF(WSAEADDRNOTAVAIL);
    CASE_OF(WSAENETDOWN);
    CASE_OF(WSAENETUNREACH);
    CASE_OF(WSAENETRESET);
    CASE_OF(WSAECONNABORTED);
    CASE_OF(WSAECONNRESET);
    CASE_OF(WSAENOBUFS);
    CASE_OF(WSAEISCONN);
    CASE_OF(WSAENOTCONN);
    CASE_OF(WSAESHUTDOWN);
    CASE_OF(WSAETOOMANYREFS);
    CASE_OF(WSAETIMEDOUT);
    CASE_OF(WSAECONNREFUSED);
    CASE_OF(WSAELOOP);
    CASE_OF(WSAENAMETOOLONG);
    CASE_OF(WSAEHOSTDOWN);
    CASE_OF(WSAEHOSTUNREACH);
    CASE_OF(WSAENOTEMPTY);
    CASE_OF(WSAEPROCLIM);
    CASE_OF(WSAEUSERS);
    CASE_OF(WSAEDQUOT);
    CASE_OF(WSAESTALE);
    CASE_OF(WSAEREMOTE);
    CASE_OF(WSAEDISCON);
    CASE_OF(WSASYSNOTREADY);
    CASE_OF(WSAVERNOTSUPPORTED);
    CASE_OF(WSANOTINITIALISED);
    CASE_OF(WSAHOST_NOT_FOUND);
    CASE_OF(WSATRY_AGAIN);
    CASE_OF(WSANO_RECOVERY);
    CASE_OF(WSANO_DATA);

    CASE_OF(ERROR_FAILURE);
    CASE_OF(ERROR_INVALID_STATE);

    default : return L"?";
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\src\common\utils.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    utils.cxx

Abstract:

    Utility functions used by the project.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


//-----------------------------------------------------------------------------
// new & delete
//-----------------------------------------------------------------------------
void* __cdecl operator new(size_t size)
{
  return (void*) LocalAlloc(
#ifdef NO_ZEROINIT
    NONZEROLPTR,
#else
    LPTR,
#endif
    size);
}

void __cdecl operator delete(void* pv)
{
  LocalFree(pv);
}


//-----------------------------------------------------------------------------
// platform checking
//-----------------------------------------------------------------------------
BOOL
IsRunningOnNT(void)
{
  OSVERSIONINFO osvi = {0};

  osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

  if( GetVersionEx(&osvi) )
  {
    if( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT )
    {
      return TRUE;
    }
  }
    
  return FALSE;
}


//-----------------------------------------------------------------------------
// user interface
//-----------------------------------------------------------------------------
LRESULT
ListBox_GetItemCount(HWND hwndLB)
{
  return SendMessage(hwndLB, LB_GETCOUNT, (WPARAM) 0L, (LPARAM) 0L);
}

void
ListBox_ResetContent(HWND hwndLB)
{
  SendMessage(hwndLB, LB_RESETCONTENT, (WPARAM) 0L, (LPARAM) 0L);
}

BOOL
ListBox_InsertString(HWND hwndLB, INT_PTR iItem, LPWSTR wszString)
{
  LRESULT retval = SendMessage(hwndLB, LB_INSERTSTRING, (WPARAM) iItem, (LPARAM) wszString);

  return ((retval != LB_ERR) && (retval != LB_ERRSPACE));
}

LRESULT
ListBox_GetSelectionIndex(HWND hwndLB)
{
  return SendMessage(
           hwndLB,
           LB_GETCARETINDEX,
           (WPARAM) 0L,
           (LPARAM) 0L
           );
}

LPWSTR
ListBox_GetSelectionText(HWND hwndLB)
{
  DWORD_PTR  iItem = 0L;
  DWORD_PTR  cb    = 0L;
  LPWSTR     wsz   = NULL;

  iItem = ListBox_GetSelectionIndex(hwndLB);  

  if( LB_ERR != (cb = SendMessage(hwndLB, LB_GETTEXTLEN, iItem, (LPARAM) 0L)) )
  {
    if( (wsz = new WCHAR[cb+1]) )
    {
      if( LB_ERR == SendMessage(hwndLB, LB_GETTEXT, iItem, (LPARAM) wsz) )
      {
        SAFEDELETEBUF(wsz);
      }
    }
  }

  return wsz;
}

LPWSTR
ListBox_GetItemText(HWND hwndLB, INT_PTR iItem)
{
  DWORD_PTR  cb  = 0L;
  LPWSTR     wsz = NULL;

  if( LB_ERR != (cb = SendMessage(hwndLB, LB_GETTEXTLEN, iItem, (LPARAM) 0L)) )
  {
    if( (wsz = new WCHAR[cb+1]) )
    {
      if( LB_ERR == SendMessage(hwndLB, LB_GETTEXT, iItem, (LPARAM) wsz) )
      {
        SAFEDELETEBUF(wsz);
      }
    }
  }

  return wsz;
}

LPVOID
ListBox_GetItemData(HWND hwndLB, INT_PTR iItem)
{
  return (LPVOID) SendMessage(hwndLB, LB_GETITEMDATA, iItem, (LPARAM) 0L);
}

BOOL
ListBox_SetItemData(HWND hwndLB, INT_PTR iItem, LPVOID pvData)
{
  return (SendMessage(hwndLB, LB_SETITEMDATA, iItem, (LPARAM) pvData) != LB_ERR);
}

BOOL
ListBox_SetCurrentSelection(HWND hwndLB, INT_PTR iItem)
{
  return (SendMessage(hwndLB, LB_SETCURSEL, (WPARAM) iItem, (LPARAM) 0L) != LB_ERR);
}

//-----------------------------------------------------------------------------
// general utility functions
//-----------------------------------------------------------------------------
void
Alert(BOOL bFatal, LPCWSTR format, ...)
{
  if( !GlobalIsSilentModeEnabled() )
  {
    DWORD   offset = 0L;
    WCHAR   buffer[2048];
    va_list arg_list;

    va_start(arg_list, format);

      offset = wvnsprintf(buffer, 2048, format, arg_list);

    va_end(arg_list);

    MessageBoxEx(
      NULL,
      buffer,
      L"Spork",
      MB_OK | \
      (bFatal ? MB_ICONSTOP : MB_ICONEXCLAMATION) | \
      MB_TASKMODAL,
      MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)
      );
  }
}

HRESULT
GetTypeInfoFromName(LPCOLESTR name, ITypeLib* ptl, ITypeInfo** ppti)
{
  HRESULT  hr     = S_OK;
  BOOL     bFound = FALSE;
  USHORT   cf     = 1L;
  ULONG    hash   = 0L;
  LONG     id     = 0L;
  LPOLESTR pstr   = NULL;

  if( !name || ! ptl )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppti )
  {
    hr = E_POINTER;
    goto quit;
  }

  *ppti = NULL;
  pstr  = StrDup(name);

    ptl->IsName(pstr, 0L, &bFound);

      if( !bFound )
      {
        hr = TYPE_E_ELEMENTNOTFOUND;
        goto quit;
      }

    hash = LHashValOfNameSys(
             SYS_WIN32,
             MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT),
             pstr
             );

    hr = ptl->FindName(pstr, hash, ppti, &id, &cf);

quit:

  SAFEDELETEBUF(pstr);
  return hr;
}

DISPID
GetDispidFromName(PDISPIDTABLEENTRY pdt, DWORD cEntries, LPWSTR name)
{
  DWORD  n      = 0L;
  DWORD  hash   = GetHash(name);
  DISPID dispid = DISPID_UNKNOWN;

  while( n < cEntries )
  {
    if( pdt[n].hash != hash )
    {
      ++n;
    }
    else
    {
      dispid = pdt[n].dispid;
      break;
    }
  }

  return dispid;
}

void
AddRichErrorInfo(EXCEPINFO* pei, LPWSTR source, LPWSTR description, HRESULT error)
{
  if( pei )
  {
    pei->bstrSource      = __widetobstr((source ? source : L"unknown source"));
    pei->bstrDescription = __widetobstr((description ? description : L"no description"));
    pei->scode           = error;
  }
}

DWORD
GetHash(LPWSTR name)
{
  DWORD hash   = 0L;
  DWORD n      = 0L;
  DWORD len    = 0L;
  LPSTR string = NULL;

  string = __widetoansi(name);

  if( string )
  {
    _strlwr(string);

    for(n=0, len=strlen(string); n<=len; n++)
    {
      hash += __toascii(string[len-n]) * ((10<<n)^n);
    }
  }

  SAFEDELETEBUF(string);
  return hash;
}

HRESULT
DispGetOptionalParam(DISPPARAMS* pdp, UINT pos, VARTYPE vt, VARIANT* pvr, UINT* pae)
{
  HRESULT hr = DispGetParam(pdp, pos, vt, pvr, pae);

  //
  // if DispGetParam failed due to a type mismatch, it was likely deliberate on
  // the part of the dispatch code. i pass in VT_VARIANT when i have no idea
  // what the controller is sending me, all i know is that i need a copy, maybe.
  //
  if( hr == DISP_E_TYPEMISMATCH )
  {
    hr = VariantCopy(pvr, &pdp->rgvarg[((pdp->cArgs-1)-pos)]);
  }

  return (hr == DISP_E_PARAMNOTFOUND) ? S_OK : hr;
}

HRESULT
ValidateDispatchArgs(REFIID riid, DISPPARAMS* pdp, VARIANT* pvr, UINT* pae)
{
  HRESULT hr = S_OK;

    if( !IsEqualIID(riid, IID_NULL) )
    {
      hr = DISP_E_UNKNOWNINTERFACE;
      goto quit;
    }

    if( !pdp )
    {
      hr = E_INVALIDARG;
      goto quit;
    }

    if( pae )
    {
      *pae = 0;
    }

    if( pvr )
    {
      VariantInit(pvr);
    }

quit:

  return hr;
}

HRESULT
ValidateInvokeFlags(WORD flags, WORD accesstype, BOOL bMethod)
{
  HRESULT hr = S_OK;

    if( (flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT)) )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      if( !bMethod )
      {
        if( flags & DISPATCH_METHOD )
        {
          hr = E_NOINTERFACE;
        }
        else
        {
          if( (flags & DISPATCH_PROPERTYPUT) && !(accesstype & DISPATCH_PROPERTYPUT) )
          {
            hr = E_ACCESSDENIED;
          }
          else
          {
            if( !(flags & accesstype) )
            {
              hr = E_FAIL;
            }
          }
        }
      }
      else
      {
        if( flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET) )
        {
          hr = E_NOINTERFACE;
        }
      }
    }

  return hr;
}

HRESULT
ValidateArgCount(DISPPARAMS* pdp, DWORD needed, BOOL bHasOptionalArgs, DWORD optional)
{
  HRESULT hr = S_OK;

    if( bHasOptionalArgs )
    {
      if( (pdp->cArgs > needed+optional) || (pdp->cArgs < needed) )
      {
        hr = DISP_E_BADPARAMCOUNT;
      }
    }
    else
    {
      if( (!needed && pdp->cArgs) || (needed < pdp->cArgs) )
      {
        hr = DISP_E_BADPARAMCOUNT;
      }
      else
      {
        hr = (pdp->cArgs == needed) ? S_OK : DISP_E_PARAMNOTOPTIONAL;
      }
    }

  return hr;
}

HRESULT
HandleDispatchError(LPWSTR id, EXCEPINFO* pei, HRESULT hr)
{
  LPWSTR msg = NULL;

  switch( hr )
  {
    case E_POINTER      : msg = L"a return pointer parameter was missing";                         break;
    case E_ACCESSDENIED : msg = L"an attempt to modify a property failed because it is read-only"; break;
    case E_FAIL         : msg = L"an unhandled error occurred";                                    break;
    case E_INVALIDARG   : msg = L"an argument passed to a property or method was invalid";         break;
    case E_NOINTERFACE  : msg = L"a property or method was accessed incorrectly";                  break;
    default             : return hr;
  }

  AddRichErrorInfo(pei, id, msg, hr);

  return DISP_E_EXCEPTION;
}

//-----------------------------------------------------------------------------
// string & type manipulation
//-----------------------------------------------------------------------------
WCHAR*
__ansitowide(const char* psz)
{
  WCHAR* wide = NULL;
  int    len  = 0L;

  if( psz )
  {
    len = strlen(psz);

    if( len )
    {
      wide      = new WCHAR[len+1];
      wide[len] = L'\0';

      MultiByteToWideChar(
        CP_ACP, 0,
        psz,  len,
        wide, len
        );
    }
  }

  return wide;
}

CHAR*
__widetoansi(const WCHAR* pwsz)
{
  CHAR* ansi = NULL;
  int   len  = 0L;
  BOOL  def  = FALSE;

  if( pwsz )
  {
    len = wcslen(pwsz);

    if( len )
    {
      ansi      = new CHAR[len+1];
      ansi[len] = '\0';

      WideCharToMultiByte(
        CP_ACP, 0,
        pwsz, len,
        ansi, len,
        "?", &def
        );
    }
  }

  return ansi;
}

BSTR
__ansitobstr(LPCSTR src)
{
  BSTR   ret = NULL;
  LPWSTR wsz = NULL;

  if( src )
  {
    wsz = __ansitowide(src);
    ret = SysAllocString(wsz);
    SAFEDELETEBUF(wsz);
  }

  return ret;
}

BSTR
__widetobstr(LPCWSTR wsrc)
{
  return (wsrc ? SysAllocString(wsrc) : NULL);
}

BOOL
__isempty(VARIANT* var)
{
  BOOL isempty = FALSE;

  if( var )
  {
    if(
        ((V_VT(var) == VT_EMPTY) || (V_VT(var) == VT_NULL) || (V_VT(var) == VT_ERROR)) ||
        ((V_VT(var) == VT_BSTR) && (SysStringLen(V_BSTR(var)) == 0))
      )
    {
      isempty = TRUE;
    }
  }
  else
  {
    isempty = TRUE;
  }

  return isempty;
}

BOOL
__mangle(LPWSTR src, LPWSTR* ppdest)
{
  BOOL   bMangled = FALSE;
  LPWSTR wszDot   = NULL;

  if( src && ppdest )
  {
    *ppdest = StrDup(src);

    while( wszDot = StrChr(*ppdest, L'.') )
    {
      *wszDot = L'_';
    }

    bMangled = TRUE;
  }

  return bMangled;
}

LPWSTR
__decorate(LPWSTR src, DWORD_PTR decor)
{
  WCHAR  buf[32];
  LPWSTR decorated = NULL;

  if( src )
  {
    memset(buf, 0, 32);
    ITOW(decor, buf, 16);
    decorated = new WCHAR[wcslen(src)+wcslen(buf)+1];

    if( decorated )
    {
      StrCpy(decorated, src);
      StrCat(decorated, buf);
    }
  }

  return decorated;
}


//-----------------------------------------------------------------------------
// user input dialog
//-----------------------------------------------------------------------------
INT_PTR GetUserInputProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


INT_PTR
GetUserInput(HINSTANCE Instance, HWND Parent, LPCWSTR DialogTitle)
{
  return DialogBoxParam(Instance, MAKEINTRESOURCE(IDD_USERINPUT), Parent, GetUserInputProc, (LPARAM) DialogTitle);
}


INT_PTR
GetUserInputProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
  switch( uMsg )
  {
    case WM_INITDIALOG :
      {
        SetWindowText(hwnd, (LPWSTR) lParam);
        SetFocus(GetDlgItem(hwnd, IDC_EDIT));
      }
      return 0L;

    case WM_COMMAND :
      {
        switch( LOWORD(wParam) )
        {
          case IDOK :
            {
              HWND   edit = GetDlgItem(hwnd, IDC_EDIT);
              WORD   cb   = 0L;
              LPWSTR text = NULL;

              if( SendMessage(edit, EM_GETMODIFY, (WPARAM) 0L, (LPARAM) 0L) )
              {
                cb   = (WORD) SendMessage(edit, EM_GETLIMITTEXT, (WPARAM) 0L, (LPARAM) 0L);
                text = new WCHAR[cb];

                if( text )
                {
                  *text = cb;
                  SendMessage(edit, EM_GETLINE, (WPARAM) 0L, (LPARAM) text);
                }
              }

              EndDialog(hwnd, (INT_PTR) text);
            }
            break;

          case IDCANCEL :
            {
              EndDialog(hwnd, 0);
            }
            break;
        }
      }
      break;

    default : return 0L;
  }

  return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\sporklets\testlog\src\testlog.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    testlog.cxx

Abstract:

    Implements the non-interface class members of the TestLog object.
    
Author:

    Paul M Midgen (pmidge) 30-March-2001


Revision History:

    30-March-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include "common.h"


//-----------------------------------------------------------------------------
// Class members
//-----------------------------------------------------------------------------
TestLog::TestLog():
  m_cRefs(0),
  m_cScriptRefs(0),
  m_bOpened(FALSE),
  m_bResult(TRUE),
  m_bstrReason(NULL),
  m_dwStackDepth(0),
  m_pTypeInfo(NULL),
  m_pStatus(NULL),
  m_hLogFile(INVALID_HANDLE_VALUE),
  m_pStack(NULL),
  m_iMode(0)
{
}


TestLog::~TestLog()
{
}


HRESULT
TestLog::Create(
  REFIID riid,
  void** ppv
  )
{
  HRESULT  hr  = S_OK;
  PTESTLOG ptl = NULL;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( (ptl = new TESTLOG) )
  {
    hr = ptl->QueryInterface(riid, ppv);

    if( FAILED(hr) )
    {
      ptl->_Terminate();
      SAFEDELETE(ptl);
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  return hr;
}


HRESULT
TestLog::_Initialize(
  LPCWSTR wszFilename,
  LPCWSTR wszTitle,
  int     iMode
  )
{
  HRESULT   hr   = S_OK;
  LPWSTR    time = _GetTimeStamp();
  LPWSTR    path = NULL;
  ITypeLib* ptl  = NULL;

  if( !wszFilename || !wszTitle )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  __try
  {
    InitializeCriticalSection(&m_csLogFile);
  }
  __except(EXCEPTION_EXECUTE_HANDLER)
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

  _SetMode(iMode, TRUE);

  //
  // if TESTLOG_MODE_FLAG_NOAUTOMATION is not set, we will load typeinfo
  // for the TestLog component in case script engines or other automation
  // controllers ask for it. failure is considered critical since certain
  // automation controllers may outright fail if typeinfo isn't available.
  //
  if( !(m_iMode & TESTLOG_MODE_FLAG_NOAUTOMATION) )
  {
    if( (path = new WCHAR[MAX_PATH]) )
    {
      GetModuleFileName(GetModuleHandle(L"testlog.dll"), path, MAX_PATH);
      
      hr = LoadTypeLib(path, &ptl);

        if( FAILED(hr) )
          goto quit;

      hr = GetTypeInfoFromName(L"TestLog", ptl, &m_pTypeInfo);

        if( FAILED(hr) )
          goto quit;
    }
    else
    {
      hr = E_OUTOFMEMORY;
      goto quit;
    }
  }

  //
  // if TESTLOG_MODE_FLAG_NOLOCALFILE is not set, we create a local file
  // using the name provided in the wszFilename parameter. failure is
  // not considered fatal. in the failure case we enable logging to a
  // debug console.
  //
  if( !(m_iMode & TESTLOG_MODE_FLAG_NOLOCALFILE) )
  {
    m_hLogFile = CreateFile(
                   wszFilename,
                   GENERIC_WRITE,
                   FILE_SHARE_READ,
                   NULL,
                   CREATE_ALWAYS,
                   FILE_ATTRIBUTE_NORMAL,
                   NULL
                   );
    
      if( !m_hLogFile )
      {
        _SetMode(TESTLOG_MODE_FLAG_NOLOCALFILE | TESTLOG_MODE_FLAG_OUTPUTTODBG, FALSE);
      }
  }

  //
  // if TESTLOG_MODE_FLAG_NOPIPERLOG is not set, we attempt to obtain Piper's
  // IStatus interface. failure is considered critical, since test cases may
  // fail to get logged if the root problem isn't sorted out.
  //
  if( !(m_iMode & TESTLOG_MODE_FLAG_NOPIPERLOG) )
  {
    hr = _InitPiperSupport();

    if( FAILED(hr) )
    {
      _SetMode(TESTLOG_MODE_FLAG_NOPIPERLOG | TESTLOG_MODE_FLAG_OUTPUTTODBG, FALSE);
    }
  }

quit:

  _WriteLog(TRUE, FALSE, MAINTAIN, L"%s\r\n\r\nlog opened: %s\r\n", wszTitle, time);

  SAFEDELETEBUF(path);
  SAFERELEASE(ptl);
  SAFEDELETEBUF(time);

  return hr;
}


void
TestLog::_Terminate(
  void
  )
{
  LPWSTR time = _GetTimeStamp();

  _WriteLog(TRUE, FALSE, MAINTAIN, L"\r\nlog closed: %s", time);

  DeleteCriticalSection(&m_csLogFile);
  SAFERELEASE(m_pStatus);
  SAFECLOSE(m_hLogFile);
  SAFERELEASE(m_pTypeInfo);
  SAFEDELETEBUF(time);

  m_bOpened = FALSE;
  SAFEDELETEBSTR(m_bstrReason);
}


HRESULT
TestLog::_InitPiperSupport(
  void
  )
{
  HRESULT   hr     = S_OK;
  IUnknown* punk   = NULL;
  CLSID     clsid  = {0};
  BSTR      progid = NULL;

  progid = SysAllocString(L"piper.status");
  hr     = CLSIDFromProgID(progid, &clsid);

    if( FAILED(hr) )
      goto quit;

  hr = GetActiveObject(clsid, NULL, &punk);

    if( FAILED(hr) )
      goto quit;

  hr = punk->QueryInterface(IID_IStatus, (void**) &m_pStatus);

quit:

  SAFERELEASE(punk);
  SAFEDELETEBSTR(progid);

  return hr;
}


void
TestLog::_SetMode(int iMode, BOOL bReset)
{
  if( bReset )
  {
    if( iMode & ~TESTLOG_MODE_FLAG_ALL )
    {
      m_iMode = TESTLOG_MODE_FLAG_USEDEFAULTS;
    }
    else
    {
      m_iMode = iMode;
    }
  }
  else
  {
    if( !(iMode & ~TESTLOG_MODE_FLAG_ALL) )
    {
      m_iMode |= iMode;
    }
  }
}


void
TestLog::_EnterFunction(
  LPCWSTR function,
  RETTYPE rt,
  LPCWSTR format,
  ...
  )
{
  _PushCallInfo(function, rt);

  if( format )
  {
    WCHAR   buf[1024];
    va_list arg_list;

    va_start(arg_list, format);

      wvnsprintf(buf, 1024, format, arg_list);
      _WriteLog(FALSE, FALSE, INCREMENT, L"%s(%s)", function, buf);

    va_end(arg_list);
  }
  else
  {
    _WriteLog(FALSE, FALSE, INCREMENT, L"%s()", function);
  }
}


void
TestLog::_LeaveFunction(
  VARIANT retval
  )
{
  LPCALLINFO pci = _PopCallInfo();
  LPWSTR     buf = _FormatCallReturnString(pci, retval);

  _WriteLog(FALSE, FALSE, DECREMENT, buf);
  _DeleteCallInfo(pci);

  SAFEDELETEBUF(buf);
}


void
TestLog::_BeginTest(
  LPCWSTR testname,
  DWORD   testid
  )
{
  WCHAR buf[1024];

  wnsprintf(buf, 1024, L"Test #%d", testid);
  _PushCallInfo(buf, rt_void);

  // suppress output if not the base test
  if( m_cScriptRefs == 1 )
  {
    _WriteLog(FALSE, FALSE, INCREMENT, L"Begin%s [%s]", buf, testname);
  }
}


void
TestLog::_EndTest(void)
{
  LPCALLINFO pci = _PopCallInfo();
  WCHAR      buf[1024];

  // suppress output if not the base test
  if( m_cScriptRefs == 1 )
  {
    wnsprintf(buf, 1024, L"End%s", pci->fname);
    _WriteLog(FALSE, FALSE, DECREMENT, buf);
  }

  _DeleteCallInfo(pci);
}


void
TestLog::_Trace(
  LPCWSTR format,
  ...
  )
{
  WCHAR   buf[1024];
  va_list arg_list;

  va_start(arg_list, format);

    wvnsprintf(buf, 1024, format, arg_list);
    _WriteLog(FALSE, TRUE, MAINTAIN, buf);

  va_end(arg_list);
}


void
TestLog::_WriteLog(
  BOOL    fRaw,
  BOOL    fTrace,
  DEPTH   depth,
  LPCWSTR format,
  ...
  )
{
  LPSTR    ansi   = NULL;
  DWORD    offset = 0L;
  LPWSTR   buffer = new WCHAR[2048];
  LPWSTR   tmp    = NULL;
  DWORD    indent = 0L;
  va_list  arg_list;

  if( buffer )
  {
    if( !fRaw )
    {
      if( depth == INCREMENT )
      {
        ++m_dwStackDepth;
        indent = m_dwStackDepth;
      }
      else if( depth == DECREMENT )
      {
        indent = m_dwStackDepth;
        --m_dwStackDepth;
      }
      else
      {
        indent = m_dwStackDepth;
      }

      tmp     = _GetTimeStamp();
      offset  = wnsprintf(buffer, 2048, L"%s ", tmp);
      SAFEDELETEBUF(tmp);

      offset += wnsprintf(buffer+offset, 2048-offset, L"%0.8x:%0.3d ", GetCurrentThreadId(), indent);
      tmp     = _GetWhiteSpace((fTrace ? indent+1 : indent));
      offset += wnsprintf(buffer+offset, 2048-offset, L"%s", tmp);
      SAFEDELETEBUF(tmp);
    }

    if( format )
    {
      va_start(arg_list, format);
    
        offset += wvnsprintf(buffer+offset, 2048-offset, format, arg_list);
        wnsprintf(buffer+offset, 2048-offset, L"\r\n");
    
      va_end(arg_list);
    }

    if( !(m_iMode & TESTLOG_MODE_FLAG_NOLOCALFILE) )
    {
      ansi   = __widetoansi(buffer);
      offset = 0;

        EnterCriticalSection(&m_csLogFile);

          WriteFile(
            m_hLogFile,
            ansi,
            strlen(ansi),
            &offset,
            NULL
            );

        LeaveCriticalSection(&m_csLogFile);

      SAFEDELETEBUF(ansi);
    }

    if( !(m_iMode & TESTLOG_MODE_FLAG_NOPIPERLOG) )
    {
      HRESULT hr   = S_OK;
      BSTR    text = __widetobstr(buffer);
      BSTR    src  = __widetobstr(L"Spork");

       hr = m_pStatus->OutputStatus(src, text, LEVEL_STATUS);

      SAFEDELETEBSTR(text);
      SAFEDELETEBSTR(src);
    }

    if( m_iMode & TESTLOG_MODE_FLAG_OUTPUTTODBG )
    {
      OutputDebugString(buffer);
    }

    SAFEDELETEBUF(buffer);
  }
}


LPCALLINFO
TestLog::_PushCallInfo(
  LPCWSTR function,
  RETTYPE rt
  )
{
  LPCALLINFO pci   = NULL;
  LPCALLINFO plast = NULL;

  for( pci = m_pStack; pci; pci = pci->next )
  {
    plast = pci;
  }

  if( !pci )
  {
    pci          = new CALLINFO;
    pci->fname   = StrDup(function);
    pci->rettype = rt;
    pci->last    = plast;
    pci->next    = NULL;

    if( !m_pStack )
    {
      m_pStack = pci;
    }
    else
    {
      plast->next = pci;
    }
  }

  return pci;
}


LPCALLINFO
TestLog::_PopCallInfo(
  void
  )
{
  LPCALLINFO pci = NULL;

  if( m_pStack )
  {
    for(pci = m_pStack; pci->next; pci = pci->next);
  }

  return pci;
}


void
TestLog::_DeleteCallInfo(
  LPCALLINFO pci
  )
{
  if( pci->last )
  {
    pci->last->next = NULL;
  }

  if( m_pStack == pci )
  {
    m_pStack = NULL;
  }

  SAFEDELETEBUF(pci->fname);
  SAFEDELETE(pci);
}


LPWSTR
TestLog::_FormatCallReturnString(
  LPCALLINFO pci,
  VARIANT    retval
  )
{
  LPWSTR buffer = new WCHAR[256];
  int    offset = 0;

  if( buffer )
  {
    offset = wnsprintf(buffer, 256, L"%s() returned ", pci->fname);

    switch( pci->rettype )
    {
      case rt_void :
        {
          wnsprintf(buffer+offset, 256-offset, L"<void>");
        }
        break;

      case rt_bool :
        {
          wnsprintf(buffer+offset, 256-offset, L"%s", VTF(&retval));
        }
        break;

      case rt_dword :
        {
          wnsprintf(buffer+offset, 256-offset, L"%d", V_I4(&retval));
        }
        break;

      case rt_error :
        {
          wnsprintf(buffer+offset, 256-offset, L"%d [%s]", V_I4(&retval), _MapErrorToString(V_I4(&retval)));
        }
        break;

      case rt_hresult :
        {
          wnsprintf(buffer+offset, 256-offset, L"%x [%s]", V_I4(&retval), _MapHResultToString(V_I4(&retval)));
        }
        break;

      case rt_string :
        {
          wnsprintf(buffer+offset, 256-offset, L"%.16s", V_BSTR(&retval));
        }
        break;

      default:
        {
          wnsprintf(buffer+offset, 256-offset, L"?");
        }
    }
  }

  return buffer;
}


//-----------------------------------------------------------------------------
// Utility functions
//-----------------------------------------------------------------------------
LPWSTR
TestLog::_GetWhiteSpace(
  int spaces
  )
{
  int    n   = 0;
  LPWSTR buf = new WCHAR[(spaces * 2) + 1];

  if( buf )
  {
    while(n<(spaces*2)) buf[n++] = L' ';
    buf[n] = L'\0';
  }

  return buf;
}


LPWSTR
TestLog::_GetTimeStamp(
  void
  )
{
  SYSTEMTIME st;
  LPWSTR     buf = new WCHAR[256];
  
  if( buf )
  {
    GetLocalTime(&st);

    wnsprintf(
      buf,
      256,
      L"%0.2d:%0.2d:%0.2d.%0.3d",
      st.wHour,
      st.wMinute,
      st.wSecond,
      st.wMilliseconds
      );
  }

  return buf;
}


//-----------------------------------------------------------------------------
// Mapping functions
//-----------------------------------------------------------------------------
LPWSTR
TestLog::_MapHResultToString(
  HRESULT hr
  )
{
  switch(hr)
  {
    CASE_OF(S_OK);
    CASE_OF(E_NOINTERFACE);
    CASE_OF(E_POINTER);
    CASE_OF(E_UNEXPECTED);
    CASE_OF(E_INVALIDARG);
    CASE_OF(E_OUTOFMEMORY);
    CASE_OF(E_FAIL);
    CASE_OF(E_NOTIMPL);
    CASE_OF(E_PENDING);
    CASE_OF(E_ACCESSDENIED);
    CASE_OF(CLASS_E_NOAGGREGATION);
    CASE_OF(TYPE_E_IOERROR);
    CASE_OF(TYPE_E_REGISTRYACCESS);
    CASE_OF(TYPE_E_INVALIDSTATE);
    CASE_OF(TYPE_E_BUFFERTOOSMALL);
    CASE_OF(TYPE_E_FIELDNOTFOUND);
    CASE_OF(TYPE_E_ELEMENTNOTFOUND);
    CASE_OF(TYPE_E_AMBIGUOUSNAME);
    CASE_OF(TYPE_E_UNKNOWNLCID);
    CASE_OF(TYPE_E_BADMODULEKIND);
    CASE_OF(TYPE_E_CANTLOADLIBRARY);
    CASE_OF(TYPE_E_INCONSISTENTPROPFUNCS);
    CASE_OF(CONNECT_E_NOCONNECTION);
    CASE_OF(CONNECT_E_ADVISELIMIT);
    CASE_OF(CO_E_OBJNOTREG);
    CASE_OF(DISP_E_BADPARAMCOUNT);
    CASE_OF(DISP_E_BADVARTYPE);
    CASE_OF(DISP_E_EXCEPTION);
    CASE_OF(DISP_E_MEMBERNOTFOUND);
    CASE_OF(DISP_E_NONAMEDARGS);
    CASE_OF(DISP_E_OVERFLOW);
    CASE_OF(DISP_E_PARAMNOTFOUND);
    CASE_OF(DISP_E_TYPEMISMATCH);
    CASE_OF(DISP_E_UNKNOWNINTERFACE);
    CASE_OF(DISP_E_UNKNOWNLCID);
    CASE_OF(DISP_E_PARAMNOTOPTIONAL);
    CASE_OF(DISP_E_UNKNOWNNAME);

    default : return L"?";
  }
}


LPWSTR
TestLog::_MapErrorToString(
  int error
  )
{
  switch(error)
  {
    CASE_OF(ERROR_SUCCESS);
    CASE_OF(ERROR_INVALID_FUNCTION);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);

    CASE_OF(EXCEPTION_ACCESS_VIOLATION);
    CASE_OF(EXCEPTION_DATATYPE_MISALIGNMENT);
    CASE_OF(EXCEPTION_BREAKPOINT);
    CASE_OF(EXCEPTION_SINGLE_STEP);
    CASE_OF(EXCEPTION_ARRAY_BOUNDS_EXCEEDED);
    CASE_OF(EXCEPTION_FLT_DENORMAL_OPERAND);
    CASE_OF(EXCEPTION_FLT_DIVIDE_BY_ZERO);
    CASE_OF(EXCEPTION_FLT_INEXACT_RESULT);
    CASE_OF(EXCEPTION_FLT_INVALID_OPERATION);
    CASE_OF(EXCEPTION_FLT_OVERFLOW);
    CASE_OF(EXCEPTION_FLT_STACK_CHECK);
    CASE_OF(EXCEPTION_FLT_UNDERFLOW);
    CASE_OF(EXCEPTION_INT_DIVIDE_BY_ZERO);
    CASE_OF(EXCEPTION_INT_OVERFLOW);
    CASE_OF(EXCEPTION_PRIV_INSTRUCTION);
    CASE_OF(EXCEPTION_IN_PAGE_ERROR);
    CASE_OF(EXCEPTION_ILLEGAL_INSTRUCTION);
    CASE_OF(EXCEPTION_NONCONTINUABLE_EXCEPTION);
    CASE_OF(EXCEPTION_STACK_OVERFLOW);
    CASE_OF(EXCEPTION_INVALID_DISPOSITION);
    CASE_OF(EXCEPTION_GUARD_PAGE);
    CASE_OF(EXCEPTION_INVALID_HANDLE);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);

    CASE_OF(WSAEINTR);
    CASE_OF(WSAEBADF);
    CASE_OF(WSAEACCES);
    CASE_OF(WSAEFAULT);
    CASE_OF(WSAEINVAL);
    CASE_OF(WSAEMFILE);
    CASE_OF(WSAEWOULDBLOCK);
    CASE_OF(WSAEINPROGRESS);
    CASE_OF(WSAEALREADY);
    CASE_OF(WSAENOTSOCK);
    CASE_OF(WSAEDESTADDRREQ);
    CASE_OF(WSAEMSGSIZE);
    CASE_OF(WSAEPROTOTYPE);
    CASE_OF(WSAENOPROTOOPT);
    CASE_OF(WSAEPROTONOSUPPORT);
    CASE_OF(WSAESOCKTNOSUPPORT);
    CASE_OF(WSAEOPNOTSUPP);
    CASE_OF(WSAEPFNOSUPPORT);
    CASE_OF(WSAEAFNOSUPPORT);
    CASE_OF(WSAEADDRINUSE);
    CASE_OF(WSAEADDRNOTAVAIL);
    CASE_OF(WSAENETDOWN);
    CASE_OF(WSAENETUNREACH);
    CASE_OF(WSAENETRESET);
    CASE_OF(WSAECONNABORTED);
    CASE_OF(WSAECONNRESET);
    CASE_OF(WSAENOBUFS);
    CASE_OF(WSAEISCONN);
    CASE_OF(WSAENOTCONN);
    CASE_OF(WSAESHUTDOWN);
    CASE_OF(WSAETOOMANYREFS);
    CASE_OF(WSAETIMEDOUT);
    CASE_OF(WSAECONNREFUSED);
    CASE_OF(WSAELOOP);
    CASE_OF(WSAENAMETOOLONG);
    CASE_OF(WSAEHOSTDOWN);
    CASE_OF(WSAEHOSTUNREACH);
    CASE_OF(WSAENOTEMPTY);
    CASE_OF(WSAEPROCLIM);
    CASE_OF(WSAEUSERS);
    CASE_OF(WSAEDQUOT);
    CASE_OF(WSAESTALE);
    CASE_OF(WSAEREMOTE);
    CASE_OF(WSAEDISCON);
    CASE_OF(WSASYSNOTREADY);
    CASE_OF(WSAVERNOTSUPPORTED);
    CASE_OF(WSANOTINITIALISED);
    CASE_OF(WSAHOST_NOT_FOUND);
    CASE_OF(WSATRY_AGAIN);
    CASE_OF(WSANO_RECOVERY);
    CASE_OF(WSANO_DATA);

    default : return L"?";
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\src\scrobj\iscriptruntime.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    iscriptruntime.cxx

Abstract:

    Implements the IScriptRuntime, IUnknown, IDispatch and IProvideClassInfo
    interfaces for the ScriptObject class.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>
#include <lmcons.h>


//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_ScriptObjectDisptable[] =
{
  0x00818735,   DISPID_SCRRUN_CREATEOBJECT,   L"createobject",
  0x022312a3,   DISPID_SCRRUN_VBCREATEOBJECT, L"vbcreateobject",
  0x00206a70,   DISPID_SCRRUN_CREATEFORK,     L"createfork",
  0x0008e6dc,   DISPID_SCRRUN_PUTVALUE,       L"putvalue",
  0x00083c24,   DISPID_SCRRUN_GETVALUE,       L"getvalue",
  0x001174b4,   DISPID_SCRRUN_SETUSERID,      L"setuserid"
};

DWORD g_cScriptObjectDisptable = (sizeof(g_ScriptObjectDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// IScriptRuntime
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ScriptObject::CreateObject(
  BSTR     ProgId,
  VARIANT* Name,
  VARIANT* Mode,
  VARIANT* Object
  )
{
  DEBUG_ENTER((
    L"ScriptObject::CreateObject",
    rt_hresult,
    L"this=%#x; ProgId=%s; Name=%s; Mode=%#x; Object=%#x",
    this,
    ProgId,
    STRING(V_BSTR(Name)),
    V_I4(Mode),
    Object
    ));

  HRESULT     hr     = S_OK;
  LPWSTR      name   = NULL;
  PCACHEENTRY pce    = NULL;
  BOOL        cached = FALSE;

  if( !ProgId )
  {
    hr = E_INVALIDARG;
    goto exit;
  }

  if( !Object )
  {
    hr = DISP_E_PARAMNOTOPTIONAL;
    goto exit;
  }


  //
  // The local variable 'name' is used when adding an object to the cache or to the
  // script namespace. ProgIds can be unsuitable, especially if they contain a dot.
  // If the caller doesn't supply a name, we mangle the ProgId into a suitable form
  // by replacing any existing dots with '_'.
  //
  if( !__isempty(Name) )
  {
    name = StrDup(V_BSTR(Name));
  }
  else
  {
    __mangle(ProgId, &name);
  }


  //
  // when CO_MODE_CREATENEW is specified, we bypass the cache and attempt to 
  // create the object. otherwise we attempt a cache lookup. if the lookup fails
  // or the cache entry is marked 'store only', then we attempt to create a new
  // object.
  //
  if( V_I4(Mode) & CO_MODE_CREATENEW )
  {
    hr = _CreateObject(ProgId, &V_DISPATCH(Object));

      if( FAILED(hr) )
        goto quit;

    LogTrace(L"created new object");
  }
  else
  {
    hr = m_psi->pSpork->ObjectCache(name, &pce, RETRIEVE);

    if( SUCCEEDED(hr) )
    {
      if( pce->bStoreOnly )
      {
        pce->pDispObject->Release();
        pce = NULL;
        hr  = _CreateObject(ProgId, &V_DISPATCH(Object));
        
          if( FAILED(hr) )
            goto quit;

        LogTrace(L"created new object");
      }
      else
      {
        V_DISPATCH(Object) = pce->pDispObject;
        cached             = TRUE;
        
        LogTrace(L"reusing cached object");
      }
    }
    else
    {
      hr = _CreateObject(ProgId, &V_DISPATCH(Object));
      
        if( FAILED(hr) )
          goto quit;
        
      LogTrace(L"created new object");
    }
  }


  LogTrace(L"object name is %s", name);


  //
  // if pce is non-null, we know we have a previously cached instance of the object
  // that can be reused (isn't 'store only').
  //
  // if pce is null we allocate a new cache entry and populate it with the new object.
  // we then default to adding a named object and caching it for reuse. both behaviors
  // can be suppressed.
  //
  if( !pce )
  {
    if( pce = new CACHEENTRY )
    {
      pce->dwObjectFlags = V_I4(Mode);
      pce->pDispObject   = V_DISPATCH(Object);

      if( !(V_I4(Mode) & CO_MODE_DONTCACHE) )
      {
        LogTrace(L"caching new object for reuse");

        pce->bStoreOnly = FALSE;
        cached          = TRUE;
        hr              = m_psi->pSpork->ObjectCache(name, &pce, STORE);
      }

      if( !(V_I4(Mode) & CO_MODE_NONAMEDOBJECT) )
      {
        LogTrace(L"adding new object to script namespace");

        if( !cached )
        {
          //
          // the object is being cached for this script only, for reference.
          // uniquely decorate the name.
          //          

          LPWSTR name_decorated = __decorate(name, (DWORD_PTR) this);

          if( name_decorated )
          {
            LogTrace(L"caching new object using per-script id %s", name_decorated);

            cached          = TRUE;
            pce->bStoreOnly = TRUE;
            hr              = m_psi->pSpork->ObjectCache(name_decorated, &pce, STORE);
            
            SAFEDELETEBUF(name_decorated);
          }
        }

        if( SUCCEEDED(hr) )
        {
          hr = m_pScriptEngine->AddNamedItem(name, SCRIPTITEM_ISPERSISTENT | SCRIPTITEM_ISVISIBLE);
        }
      }
    }
    else
    {
      hr = E_OUTOFMEMORY;
    }
  }
  else
  {
    if( !(pce->dwObjectFlags & CO_MODE_NONAMEDOBJECT) )
    {
      LogTrace(L"adding reused object to script namespace");

      hr = m_pScriptEngine->AddNamedItem(name, SCRIPTITEM_ISPERSISTENT | SCRIPTITEM_ISVISIBLE);
    }
  }

quit:

  if( SUCCEEDED(hr) )
  {
    V_VT(Object) = VT_DISPATCH;
  }
  else
  {
    V_VT(Object) = VT_NULL;
    SAFERELEASE(V_DISPATCH(Object));
  }

  if( !cached )
  {
    SAFEDELETE(pce);
  }

  SAFEDELETE(name);

exit:

  DEBUG_LEAVE(hr);  
  return hr;
}


HRESULT
__stdcall
ScriptObject::CreateFork(
  BSTR     ScriptFile,
  VARIANT  Threads,
  BSTR     ChildParams,
  VARIANT* ChildResult
  )
{
  HRESULT     hr        = S_OK;
  PSCRIPTINFO psi       = NULL;
  DWORD       dwThreads = 0L;
  HANDLE      hThread   = NULL;

  //
  // TODO: unused parameters
  //
  //       we don't do anything with the ChildResult parameter.
  //       we should provide a way for the child to report some kind of
  //       non-test related result information. perhaps thru the runtime.
  //

  psi = new SCRIPTINFO;

    if( !psi )
    {
      hr = E_OUTOFMEMORY;
      goto quit;
    }

  dwThreads            = V_I4(&Threads);
  psi->wszScriptFile   = ScriptFile;
  psi->bIsFork         = TRUE;
  psi->bstrChildParams = ChildParams;
  psi->htParent        = m_htThis;
  psi->pSpork          = m_psi->pSpork;

  // if dwThreads is 0, we execute the new script on the same thread
  if( dwThreads == 0 )
  {
    ScriptThread((LPVOID) psi);
  }
  else
  {
    hr = m_psi->pSpork->CreateScriptThread(psi, &hThread);

      if( FAILED(hr) )
      {
        SAFEDELETE(psi);
        goto quit;
      }

    WaitForSingleObject(hThread, INFINITE);
    SAFECLOSE(hThread);
  }

quit:

  return hr;
}


HRESULT
__stdcall
ScriptObject::PutValue(
  BSTR     Name,
  VARIANT* Value,
  VARIANT* Status
  )
{
  HRESULT hr = S_OK;

  if( !Name )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  hr = m_psi->pSpork->PropertyBag(
                        Name,
                        &Value,
                        (!__isempty(Value) ? STORE : REMOVE)
                        );
quit:

  if( Status )
  {
    V_VT(Status)   = VT_BOOL;
    V_BOOL(Status) = (SUCCEEDED(hr) ? VARIANT_TRUE : VARIANT_FALSE);
  }

  return hr;
}


HRESULT
__stdcall
ScriptObject::GetValue(
  BSTR     Name,
  VARIANT* Value
  )
{
  HRESULT hr = S_OK;

  if( !Name || !Value )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  hr = m_psi->pSpork->PropertyBag(Name, &Value, RETRIEVE);

quit:

  return hr;
}


HRESULT
__stdcall
ScriptObject::SetUserId(
  VARIANT  Username,
  VARIANT  Password,
  VARIANT* Domain,
  VARIANT* Status
  )
{
  HRESULT hr = E_NOTIMPL;

  //
  // TODO: implementation
  //

  return hr;
}


//-----------------------------------------------------------------------------
// IUnknown methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ScriptObject::QueryInterface(
  REFIID riid,
  void** ppv
  )
{
  HRESULT hr = S_OK;

    if( ppv )
    {
      if(
        IsEqualIID(riid, IID_IUnknown)  ||
        IsEqualIID(riid, IID_IDispatch) ||
        IsEqualIID(riid, IID_IScriptRuntime)
        )
      {
        *ppv = static_cast<IScriptRuntime*>(this);
      }
      else if( IsEqualIID(riid, IID_IActiveScriptSite) )
      {
        *ppv = static_cast<IActiveScriptSite*>(this);
      }
      else if( IsEqualIID(riid, IID_IActiveScriptSiteDebug) )
      {
        *ppv = static_cast<IActiveScriptSiteDebug*>(this);
      }
      else if( IsEqualIID(riid, IID_IProvideClassInfo) )
      {
        *ppv = static_cast<IProvideClassInfo*>(this);
      }
      else
      {
        *ppv = NULL;
        hr   = E_NOINTERFACE;
      }
    }
    else
    {
      hr = E_POINTER;
    }

    if( SUCCEEDED(hr) )
    {
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }

  return hr;
}


ULONG
__stdcall
ScriptObject::AddRef(
  void
  )
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF(L"ScriptObject", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
ScriptObject::Release(
  void
  )
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE(L"ScriptObject", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE(L"ScriptObject");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ScriptObject::GetClassInfo(
  ITypeInfo** ppti
  )
{
  HRESULT   hr  = S_OK;
  ITypeLib* ptl = NULL;

    if( ppti )
    {
      if( SUCCEEDED(m_psi->pSpork->GetTypeLib(&ptl)) )
      {
        hr = GetTypeInfoFromName(L"ScriptRuntime", ptl, ppti);
        SAFERELEASE(ptl);
      }
    }
    else
    {
      hr = E_POINTER;
    }

  return hr;
}


//-----------------------------------------------------------------------------
// IDispatch methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ScriptObject::GetTypeInfoCount(
  UINT* pctinfo
  )
{
  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  return hr;
}


HRESULT
__stdcall
ScriptObject::GetTypeInfo(
  UINT        index,
  LCID        lcid,
  ITypeInfo** ppti
  )
{
  HRESULT hr = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  return hr;
}


HRESULT
__stdcall
ScriptObject::GetIDsOfNames(
  REFIID    riid,
  LPOLESTR* arNames,
  UINT      cNames,
  LCID      lcid,
  DISPID*   arDispId
  )
{
  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_ScriptObjectDisptable, g_cScriptObjectDisptable, arNames[n]);
    ++n;
  }

quit:

  return hr;
}


HRESULT
__stdcall
ScriptObject::Invoke(
  DISPID      dispid,
  REFIID      riid,
  LCID        lcid,
  WORD        flags,
  DISPPARAMS* pdp,
  VARIANT*    pvr,
  EXCEPINFO*  pei,
  UINT*       pae
  )
{
  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_SCRRUN_CREATEOBJECT :
    case DISPID_SCRRUN_VBCREATEOBJECT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, TRUE, 2);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(progid);
            NEWVARIANT(name);
            NEWVARIANT(mode);

            hr = DispGetParam(pdp, 0, VT_BSTR, &progid, pae);

            if( SUCCEEDED(hr) )
            {
              hr = DispGetOptionalParam(pdp, 1, VT_BSTR, &name, pae);
            }

            if( SUCCEEDED(hr) )
            {
              hr = DispGetOptionalParam(pdp, 2, VT_I4, &mode, pae);
            }

            if( SUCCEEDED(hr) )
            {
              hr = CreateObject(
                     V_BSTR(&progid),
                     &name,
                     &mode,
                     pvr
                     );
            }

            VariantClear(&progid);
            VariantClear(&name);
            VariantClear(&mode);
          }
        }
      }
      break;

    case DISPID_SCRRUN_CREATEFORK :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 3, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(script);
            NEWVARIANT(threads);
            NEWVARIANT(params);

            hr = DispGetParam(pdp, 0, VT_BSTR, &script,  pae);

            if( SUCCEEDED(hr) )
            {
              hr = DispGetParam(pdp, 1, VT_I4,   &threads, pae);
            }

            if( SUCCEEDED(hr) )
            {
              hr = DispGetParam(pdp, 2, VT_BSTR, &params,  pae);
            }

            if( SUCCEEDED(hr) )
            {
              hr = CreateFork(
                     V_BSTR(&script),
                     threads,
                     V_BSTR(&params),
                     pvr
                     );
            }

            VariantClear(&script);
            VariantClear(&threads);
            VariantClear(&params);
          }
        }
      }
      break;

    case DISPID_SCRRUN_PUTVALUE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, TRUE, 1);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(name);
            NEWVARIANT(value);

            hr = DispGetParam(pdp, 0, VT_BSTR, &name, pae);

            if( SUCCEEDED(hr) )
            {
              hr = DispGetOptionalParam(pdp, 1, VT_VARIANT, &value, pae);
            }

            if( SUCCEEDED(hr) )
            {

              hr = PutValue(
                     V_BSTR(&name),
                     &value,
                     pvr
                     );
            }

            VariantClear(&name);
            VariantClear(&value);
          }
        }
      }
      break;

    case DISPID_SCRRUN_GETVALUE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = GetValue(
                   V_BSTR(&pdp->rgvarg[0]),
                   pvr
                   );
          }
        }
      }
      break;

    case DISPID_SCRRUN_SETUSERID :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 2, TRUE, 1);

          if( SUCCEEDED(hr) )
          {
            NEWVARIANT(user);
            NEWVARIANT(password);
            NEWVARIANT(domain);

            hr = DispGetParam(pdp, 0, VT_BSTR, &user, pae);

            if( SUCCEEDED(hr) )
            {
              hr = DispGetParam(pdp, 1, VT_BSTR, &password, pae);
            }

            if( SUCCEEDED(hr) )
            {
              hr = DispGetOptionalParam(pdp, 2, VT_BSTR, &domain, pae);
            }

            if( SUCCEEDED(hr) )
            {
              if( __isempty(&domain) )
              {
                V_VT(&domain)   = VT_BSTR;
                V_BSTR(&domain) = SysAllocString(L".");
              }

              hr = SetUserId(
                     user,
                     password,
                     &domain,
                     pvr
                     );
            }

            VariantClear(&user);
            VariantClear(&password);
            VariantClear(&domain);
          }
        }
      }
      break;

    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"ScriptObject", pei, hr);
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\src\scrobj\iactivescriptsite.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    iactivescriptsite.cxx

Abstract:

    Implements the IActiveScriptSite interface for the ScriptObject class.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


//-----------------------------------------------------------------------------
// IActiveScriptSite
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ScriptObject::GetLCID(
  LCID* plcid
  )
{
  HRESULT hr = S_OK;

    if( !plcid )
    {
      hr = E_POINTER;
    }
    else
    {
      *plcid = MAKELCID(
                 MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                 SORT_DEFAULT
                 );
    }

  return hr;
}


HRESULT
__stdcall
ScriptObject::GetItemInfo(
  LPCOLESTR   pstrName,
  DWORD       dwReturnMask,
  IUnknown**  ppunk,
  ITypeInfo** ppti
  )
{
  HRESULT     hr  = S_OK;
  ITypeLib*   ptl = NULL;
  PCACHEENTRY pce = NULL;

  if( !pstrName )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( dwReturnMask & SCRIPTINFO_IUNKNOWN )
  {
    if( !_wcsicmp(pstrName, L"ScriptRuntime") )
    {
      hr = QueryInterface(IID_IUnknown, (void**) ppunk);
    }
    else
    {
      //
      // If the object the script engine is attempting to resolve isn't part of the
      // script runtime object, then we try to resolve the name with the object
      // cache.
      //

      //
      // first check for a globally cached instance...
      //
      hr = m_psi->pSpork->ObjectCache(
                            (LPWSTR) pstrName,
                            &pce,
                            RETRIEVE
                            );
      
      if( FAILED(hr) )
      {
        //
        // ...failing that, check for a per-script instance
        //
        LPWSTR name_decorated = __decorate((LPWSTR) pstrName, (DWORD_PTR) this);

        hr = m_psi->pSpork->ObjectCache(
                              name_decorated,
                              &pce,
                              RETRIEVE
                              );

        SAFEDELETEBUF(name_decorated);
      }

      if( pce )
      {
        pce->pDispObject->QueryInterface(IID_IUnknown, (void**) ppunk);
        pce->pDispObject->Release();
      }
      else
      {
        hr     = E_FAIL;
        *ppunk = NULL;
      }
    }
  }
  else if( dwReturnMask & SCRIPTINFO_ITYPEINFO )
  {
    //
    // BUGBUG: This could fail when we're asked to get type information for
    //         an object not exposed by Spork, e.g. named objects added via
    //         the 'createobject' method.
    //
    //         NOTE: The JS and VBS engines were tested and work fine for
    //               objects that don't expose event interfaces. Objects
    //               with events were not tested.
    //

    hr = m_psi->pSpork->GetTypeLib(&ptl);

    if( SUCCEEDED(hr) )
    {
      hr = GetTypeInfoFromName(pstrName, ptl, ppti);
      
      if( FAILED(hr) )
      {
        *ppti = NULL;
      }
    }
  }

quit:

  SAFERELEASE(ptl);
  return hr;
}


HRESULT
__stdcall
ScriptObject::GetDocVersionString(
  BSTR* pbstrVersion
  )
{
  return E_NOTIMPL;
}


HRESULT
__stdcall
ScriptObject::OnScriptTerminate(
  const VARIANT*   pvarResult,
  const EXCEPINFO* pei
  )
{
  return E_NOTIMPL;
}


HRESULT
__stdcall
ScriptObject::OnStateChange(
  SCRIPTSTATE ss
  )
{
  return E_NOTIMPL;
}


HRESULT
__stdcall
ScriptObject::OnScriptError(
  IActiveScriptError* piase
  )
{
  HRESULT   hr     = S_OK;
  DWORD     n      = 0L;
  DWORD     cookie = 0L;
  ULONG     line   = 0L;
  LONG      pos    = 0L;
  EXCEPINFO ex;

  piase->GetExceptionInfo(&ex);
  piase->GetSourcePosition(&cookie, &line, &pos);

  Alert(
    FALSE,
    L"A runtime error in script %s occurred.\r\n" \
    L"Check spork.log for more information.\r\n\r\n" \
    L"source\t: %s\r\n" \
    L"error\t: %s\r\n",
    m_wszScriptFile,
    STRING(ex.bstrSource),
    STRING(ex.bstrDescription)
    );

  LogTrace(L"********* SCRIPT ERROR *********");
  LogTrace(L" script : %s", m_wszScriptFile);
  LogTrace(L" cookie : %x", cookie);
  LogTrace(L" line # : %d", line);
  LogTrace(L" char # : %d", pos);
  LogTrace(L" source : %s", STRING(ex.bstrSource));
  LogTrace(L" error  : %s", STRING(ex.bstrDescription));
  LogTrace(L" hresult: 0x%0.8X", ex.scode);
  LogTrace(L"********************************");

  return hr;
}


HRESULT
__stdcall
ScriptObject::OnEnterScript(
  void
  )
{
  LogEnterFunction(L"SCRIPTCODE", rt_void, NULL);
  return E_NOTIMPL;
}


HRESULT
__stdcall
ScriptObject::OnLeaveScript(
  void
  )
{
  LogLeaveFunction(0);
  return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\src\scrobj\thread.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    thread.cxx

Abstract:

    Thread function that executes a script.
    
Author:

    Paul M Midgen (pmidge) 23-February-2001


Revision History:

    23-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


//-----------------------------------------------------------------------------
// the mighty script thread... all ye unwashed bow down.
//-----------------------------------------------------------------------------
DWORD
WINAPI
ScriptThread(LPVOID pv)
{
  HRESULT     hr  = S_OK;
  PSCRIPTINFO psi = (PSCRIPTINFO) pv;
  PSCRIPTOBJ  pso = NULL;

  LogEnterFunction(
    L"ScriptThread",
    rt_hresult,
    L"parentid=%#x; script=%s; spork=%#x",
    psi->htParent,
    psi->wszScriptFile,
    psi->pSpork
    );

  hr = SCRIPTOBJ::Create(psi, &pso);

  if( SUCCEEDED(hr) )
  {
    pso->Run();
    pso->Terminate();

    RevertToSelf();
  }

  SAFERELEASE(pso);
  SAFEDELETE(psi);

  LogLeaveFunction(hr);
  return (DWORD) hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\src\spobj\debugpage.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    debugpage.cxx

Abstract:

    Implements the debug options property page.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


LPCWSTR g_wszEnableDebug        = L"_EnableDebug";
LPCWSTR g_wszBreakOnScriptStart = L"_BreakOnScriptStart";
LPCWSTR g_wszEnableDebugWindow  = L"_EnableDebugWindow";


//-----------------------------------------------------------------------------
// dialog window procedures
//-----------------------------------------------------------------------------
INT_PTR
Spork::_DebugPropPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  switch( uMsg )
  {
    case WM_INITDIALOG :
      {
        _LoadDebugOptions();
      }
      break;

    case WM_NOTIFY :
      {
        switch( ((NMHDR*) lParam)->code )
        {
          case PSN_SETACTIVE :
            {
              DBGOPTIONS dbo = {0};

              if( m_pMLV )
                m_pMLV->GetDebugOptions(&dbo);

              CheckDlgButton(
                hwnd,
                IDB_ENABLEDEBUG,
                (dbo.bEnableDebug ? BST_CHECKED : BST_UNCHECKED)
                );

              EnableWindow(
                GetDlgItem(hwnd, IDB_DBGBREAK),
                (IsDlgButtonChecked(hwnd, IDB_ENABLEDEBUG) == BST_CHECKED)
                );

              CheckDlgButton(
                hwnd,
                IDB_DBGBREAK,
                (dbo.bBreakOnScriptStart ? BST_CHECKED : BST_UNCHECKED)
                );

              CheckDlgButton(
                hwnd,
                IDB_ENABLEDBGOUT,
                (dbo.bEnableDebugWindow ? BST_CHECKED : BST_UNCHECKED)
                );
            }
            break;

          case PSN_KILLACTIVE :
            {
              SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) FALSE);
            }
            return 1L;

          case PSN_APPLY :
            {
              _SaveDebugOptions(hwnd);
              SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
            }
            return 1L;
        }
      }

    case WM_COMMAND :
      {
        BOOL bPageChanged = FALSE;

        switch( LOWORD(wParam) )
        {
          case IDB_ENABLEDEBUG :
            {
              EnableWindow(
                GetDlgItem(hwnd, IDB_DBGBREAK),
                (IsDlgButtonChecked(hwnd, LOWORD(wParam)) == BST_CHECKED)
                );

              bPageChanged = TRUE;
            }
            break;

          case IDB_DBGBREAK :
          case IDB_ENABLEDBGOUT :
            {
              bPageChanged = TRUE;
            }
            break;
        }

        if( bPageChanged )
        {
          PropSheet_Changed(GetParent(hwnd), hwnd);
        }
      }
      break;

    default : return 0L;
  }

  return 0L;
}


//-----------------------------------------------------------------------------
// handlers for dialog events
//-----------------------------------------------------------------------------
BOOL
Spork::_LoadDebugOptions(void)
{
  LPWSTR     wszProfilePath = _GetCurrentProfilePath();
  LPVOID     pvData         = NULL;
  DBGOPTIONS dbo            = {0}; // defaults to all debugging support off

  if( wszProfilePath )
  {
    if( GetRegValueFromKey(wszProfilePath, g_wszEnableDebug, REG_DWORD, &pvData) )
    {
      dbo.bEnableDebug = (BOOL) *((LPDWORD) pvData);
      SAFEDELETEBUF(pvData);
    }

    if( GetRegValueFromKey(wszProfilePath, g_wszBreakOnScriptStart, REG_DWORD, &pvData) )
    {
      dbo.bBreakOnScriptStart = *((LPDWORD) pvData);
      SAFEDELETEBUF(pvData);
    }

    if( GetRegValueFromKey(wszProfilePath, g_wszEnableDebugWindow, REG_DWORD, &pvData) )
    {
      dbo.bEnableDebugWindow = *((LPDWORD) pvData);
      SAFEDELETEBUF(pvData);
    }

    SAFEDELETEBUF(wszProfilePath);

    m_pMLV->SetDebugOptions(dbo);
  }

  return TRUE;
}


BOOL
Spork::_SaveDebugOptions(HWND dialog)
{
  LPWSTR     wszProfilePath = _GetCurrentProfilePath();
  DBGOPTIONS dbo            = {0};

  dbo.bEnableDebug        = (IsDlgButtonChecked(dialog, IDB_ENABLEDEBUG)  == BST_CHECKED);
  dbo.bBreakOnScriptStart = (IsDlgButtonChecked(dialog, IDB_DBGBREAK)     == BST_CHECKED);
  dbo.bEnableDebugWindow  = (IsDlgButtonChecked(dialog, IDB_ENABLEDBGOUT) == BST_CHECKED);

  if( wszProfilePath )
  {
    SetRegValueInKey(wszProfilePath, g_wszEnableDebug,        REG_DWORD, (LPVOID) &dbo.bEnableDebug,        sizeof(DWORD));
    SetRegValueInKey(wszProfilePath, g_wszBreakOnScriptStart, REG_DWORD, (LPVOID) &dbo.bBreakOnScriptStart, sizeof(DWORD));
    SetRegValueInKey(wszProfilePath, g_wszEnableDebugWindow,  REG_DWORD, (LPVOID) &dbo.bEnableDebugWindow,  sizeof(DWORD));

    m_pMLV->SetDebugOptions(dbo);

    SAFEDELETEBUF(wszProfilePath);
  }

  return TRUE;
}


//-----------------------------------------------------------------------------
// friend window procs, delegate to private class members
//-----------------------------------------------------------------------------
INT_PTR
CALLBACK
DebugPropPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  static PSPORK ps = NULL;

  if( !ps )
  {
    switch( uMsg )
    {
      case WM_INITDIALOG :
        {
          ps = (PSPORK) ((LPPROPSHEETPAGE) lParam)->lParam;
        }
        break;
      
      default : return FALSE;
    }
  }

  return ps->_DebugPropPageProc(hwnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\src\scrobj\scrobj.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

   scrobj.cxx

Abstract:

    Implementation of the ScriptObject class member functions.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


//-----------------------------------------------------------------------------
// Class members
//-----------------------------------------------------------------------------
ScriptObject::ScriptObject():
  m_cRefs(1),
  m_psi(NULL),
  m_wszScriptFile(NULL),
  m_pDebugApplication(NULL),
  m_pScriptEngine(NULL),
  m_htThis(NULL)
{
  DEBUG_TRACE((L"ScriptObject [%#x] created", this));
}


ScriptObject::~ScriptObject()
{
  SAFEDELETEBUF(m_wszScriptFile);
  SAFERELEASE(m_pDebugApplication);
  SAFERELEASE(m_pScriptEngine);

  DEBUG_TRACE((L"ScriptObject [%#x] deleted", this));
}


HRESULT
ScriptObject::Create(
  PSCRIPTINFO psi,
  PSCRIPTOBJ* ppscrobj
  )
{
  HRESULT    hr      = S_OK;
  PSCRIPTOBJ pscrobj = NULL;

  if( !psi )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppscrobj )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( (pscrobj = new SCRIPTOBJ) )
  {
    hr = pscrobj->_Initialize(psi);

    if( SUCCEEDED(hr) )
    {
      *ppscrobj = pscrobj;
    }
    else
    {
      *ppscrobj = NULL;
      pscrobj->Release();

      //SAFEDELETE(pscrobj);
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  return hr;
}


HRESULT
ScriptObject::_Initialize(
  PSCRIPTINFO psi
  )
{
  HRESULT             hr        = S_OK;
  LPWSTR              wszScript = NULL;
  IActiveScriptParse* parse     = NULL;
  EXCEPINFO           excepinfo = {0};

  m_psi           = psi;
  m_wszScriptFile = StrDup(m_psi->wszScriptFile);
  wszScript       = _LoadScript();

    if( wszScript )
    {
      m_psi->pSpork->GetProfileDebugOptions(&m_DebugOptions);

      if( m_DebugOptions.bEnableDebug )
      {
        hr = _LoadScriptDebugger();
        
        if( SUCCEEDED(hr) )
        {
          if( m_DebugOptions.bBreakOnScriptStart )
          {
            m_pDebugApplication->CauseBreak();
          }
        }
      }

      hr = m_psi->pSpork->GetScriptEngine(_GetScriptType(), &m_pScriptEngine);

        if( FAILED(hr) )
          goto quit;

      hr = m_pScriptEngine->QueryInterface(IID_IActiveScriptParse, (void**) &parse);

        if( FAILED(hr) )
          goto quit;

      hr = parse->InitNew();

        if( FAILED(hr) )
          goto quit;

      hr = m_pScriptEngine->SetScriptSite(dynamic_cast<IActiveScriptSite*>(this));

        if( FAILED(hr) )
          goto quit;

      hr = m_pScriptEngine->AddNamedItem(
                              L"ScriptRuntime",
                              SCRIPTITEM_ISPERSISTENT | SCRIPTITEM_ISVISIBLE | SCRIPTITEM_GLOBALMEMBERS
                              );

        if( FAILED(hr) )
          goto quit;

      hr = parse->ParseScriptText(
                    wszScript,
                    NULL,
                    NULL,
                    NULL,
                    (DWORD) ((DWORD_PTR) this), // IA64: this is just a cookie value, we never use the pointer
                    0,
                    SCRIPTTEXT_ISPERSISTENT | SCRIPTTEXT_ISVISIBLE,
                    NULL,
                    &excepinfo
                    );

        if( FAILED(hr) )
        {
          m_pScriptEngine->Close();
          goto quit;
        }

      hr = m_pScriptEngine->SetScriptState(SCRIPTSTATE_STARTED);
    }
    else
    {
      hr = E_FAIL;
    }

quit:

  if( SUCCEEDED(hr) )
  {
    m_psi->pSpork->NotifyUI(
                     TRUE,
                     m_wszScriptFile,
                     this,
                     m_psi->htParent,
                     &m_htThis
                     );
  }

  SAFERELEASE(parse);
  SAFEDELETEBUF(wszScript);

  return hr;
}


HRESULT
ScriptObject::Run(void)
{
  HRESULT    hr         = S_OK;
  IDispatch* psd        = NULL;
  DISPID     testid     = 0L;
  LPWSTR     entrypoint = NULL;
  UINT       argerr     = 0L;
  EXCEPINFO  ei         = {0};
  DISPPARAMS dp         = {0};

  hr = m_pScriptEngine->GetScriptDispatch(NULL, &psd);

  if( SUCCEEDED(hr) )
  {
    entrypoint = (m_psi->bIsFork ? L"SPORK_OnCreateFork" : L"SPORK_Main");

    hr = psd->GetIDsOfNames(
                IID_NULL,
                &entrypoint, 1,
                MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT),
                &testid
                );

    if( SUCCEEDED(hr) )
    {
      if( m_psi->bIsFork )
      {
        dp.cArgs          = 1;
        dp.rgvarg         = new VARIANT;
        V_VT(dp.rgvarg)   = VT_BSTR;
        V_BSTR(dp.rgvarg) = m_psi->bstrChildParams;
      }

        hr = psd->Invoke(
                    testid,
                    IID_NULL,
                    MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT),
                    DISPATCH_METHOD,
                    &dp,
                    NULL,
                    &ei,
                    &argerr
                    );

      if( FAILED(hr) )
      {
        LogTrace(L"error invoking %s: %s", entrypoint, MapHResultToString(hr));
      }

      SAFEDELETE(dp.rgvarg);
    }
    else
    {
      LogTrace(L"%s not present, cannot run script", entrypoint);
    }

    SAFERELEASE(psd);
  }
  
  return hr;
}


HRESULT
ScriptObject::Terminate(void)
{
  HRESULT hr = S_OK;

    hr = m_pScriptEngine->Close();

    m_psi->pSpork->NotifyUI(
                     FALSE, 
                     m_wszScriptFile,
                     this,
                     m_psi->htParent,
                     &m_htThis
                     );

  return hr;
}


LPWSTR
ScriptObject::_LoadScript(void)
{
  HANDLE hFile  = INVALID_HANDLE_VALUE;
  DWORD  dwLen  = 0L;
  DWORD  dwRead = 0L;
  PBYTE  pBuf   = NULL;
  LPWSTR wide   = NULL;

  _PreprocessScript(&hFile);

  if( hFile != INVALID_HANDLE_VALUE )
  {
    dwLen = GetFileSize(hFile, NULL);

    // we don't know yet if the script is unicode, assume we need a 16-bit NULL.
    pBuf = new BYTE[dwLen+2];

    if( pBuf )
    {
      if( ReadFile(hFile, (void*) pBuf, dwLen, &dwRead, NULL) )
      {
        if( _IsUnicodeScript((void*) pBuf, dwRead) )
        {
          *(pBuf+dwLen) = L'\0';

          //
          // the first two bytes of the buffer will be a Unicode byte ordering mark (BOM),
          // which has no meaning whatsoever in a wide string, so we need to remove it or
          // else the script parser will choke.
          //
          wide = StrDup((LPWSTR) (pBuf+2));
        }
        else
        {
          *(pBuf+dwLen) = '\0';
          wide          = __ansitowide((LPSTR) pBuf);
        }
      }
      
      SAFEDELETEBUF(pBuf);
    }

    SAFECLOSE(hFile);
  }

  if( !wide )
  {
    LogTrace(L"failed to load script file");
  }

  return wide;
}


BOOL
ScriptObject::_PreprocessScript(
  HANDLE* phScript
  )
{
  BOOL   bRet    = TRUE;
  LPWSTR wszDotI = StrDup(PathFindFileName(m_wszScriptFile));

  if( wszDotI )
  {
    StrCpyN(StrStr(wszDotI, L"."), L".i\0", 3);

#ifdef CONDITIONAL_PRECOMPILE
    if( !_IsDotINewer(wszDotI) )
    {
#endif

      bRet = _RunPreprocessor();

      if( !bRet )
      {
        Alert(
          FALSE,
          L"An error occurred preprocessing %s, please check spork.log for more information",
          m_wszScriptFile
          );
      }

#ifdef CONDITIONAL_PRECOMPILE
    }
#endif

    if( bRet )
    {
      *phScript = CreateFile(
                    wszDotI,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

      if( *phScript == INVALID_HANDLE_VALUE )
      {
        DEBUG_TRACE((L"failed to open .i file: %s", MapErrorToString(GetLastError())));
        bRet = FALSE;
      }
    }

    SAFEDELETEBUF(wszDotI);
  }
  else
  {
    DEBUG_TRACE((L"StrDup failed to duplicate scriptname"));
    bRet = FALSE;
  }

  return bRet;
}


LPWSTR g_wszPreprocCmdLine = L"cl.exe /Tc %s /EP /P /I. /I%s /nologo";
LPWSTR g_wszPreprocDefault = L"cl.exe /Tc %s /EP /P /I. /Iinclude /nologo";


BOOL
ScriptObject::_RunPreprocessor(void)
{
  BOOL                bRet    = FALSE;
  DWORD               dwRet   = 0L;
  LPWSTR              cmdline = NULL;
  LPWSTR              include = NULL;
  STARTUPINFO         si      = {0};
  PROCESS_INFORMATION pi      = {0};

  si.cb      = sizeof(STARTUPINFO);
  si.dwFlags = STARTF_USESTDHANDLES;

  cmdline = new WCHAR[MAX_PATH];

  if( cmdline )
  {
    // check to see if there's a profile loaded, and if so does it provide
    // an include path we should use
    if( SUCCEEDED(m_psi->pSpork->GetNamedProfileItem(L"include", (LPVOID*) &include)) )
    {
      wnsprintf(cmdline, MAX_PATH, g_wszPreprocCmdLine, m_wszScriptFile, include);
    }
    else
    {
      wnsprintf(cmdline, MAX_PATH, g_wszPreprocDefault, m_wszScriptFile);
    }

    LogTrace(L"preprocessor command-line: \"%s\"", cmdline);

    bRet = CreateProcess(
             NULL,
             cmdline,
             NULL,
             NULL,
             FALSE,
             CREATE_NO_WINDOW | NORMAL_PRIORITY_CLASS,
             NULL,
             NULL,
             &si,
             &pi
             );

    if( bRet )
    {
      WaitForSingleObject(pi.hProcess, INFINITE);
      GetExitCodeProcess(pi.hProcess, &dwRet);

      if( dwRet )
      {
        LogTrace(L"failed to preprocess %s, please run the logged command-line", m_wszScriptFile);
        bRet = FALSE;
      }
    }

    SAFEDELETEBUF(include);
  }

  SAFEDELETEBUF(cmdline);
  SAFECLOSE(pi.hThread);
  SAFECLOSE(pi.hProcess);

  return bRet;
}


SCRIPTTYPE
ScriptObject::_GetScriptType(void)
{
  if( StrStr(m_wszScriptFile, L".js") )
  {
    return JSCRIPT;
  }
  else if( StrStr(m_wszScriptFile, L".vbs") )
  {
    return VBSCRIPT;
  }
  else
  {
    return UNKNOWN;
  }
}


BOOL
ScriptObject::_IsDotINewer(
  LPCWSTR wszDotI
  )
{
  BOOL   bNewer = FALSE;
  W32FAD script = {0};
  W32FAD doti   = {0};

  if( GetFileAttributesEx(wszDotI, GetFileExInfoStandard, (void*) &doti) )
  {
    if( GetFileAttributesEx(m_wszScriptFile, GetFileExInfoStandard, (void*) &script) )
    {
      bNewer = (CompareFileTime(&doti.ftLastWriteTime, &script.ftLastWriteTime) == 1);
    }
  }  

  return bNewer;
}


BOOL
ScriptObject::_IsUnicodeScript(
  LPVOID pBuf,
  DWORD  cBuf
  )
{
  DWORD dwRet  = 0L;
  INT   iFlags = 0L;
  
  iFlags = IS_TEXT_UNICODE_SIGNATURE  | \
           IS_TEXT_UNICODE_ODD_LENGTH | \
           IS_TEXT_UNICODE_NULL_BYTES;

  dwRet  = IsTextUnicode(pBuf, cBuf, &iFlags);

  DEBUG_TRACE(
    (L"script is %s", (dwRet ? L"unicode" : L"ansi"))
    );

  return (BOOL) dwRet;
}


HRESULT
ScriptObject::_CreateObject(LPWSTR wszProgId, IDispatch** ppdisp)
{
  DEBUG_ENTER((
    L"ScriptObject::_CreateObject",
    rt_hresult,
    L"this=%#x; wszProgId=%s; ppdisp=%#x",
    this,
    wszProgId,
    ppdisp
    ));

  HRESULT hr    = S_OK;
  CLSID   clsid = {0};

  hr = CLSIDFromProgID(wszProgId, &clsid);

  if( SUCCEEDED(hr) )
  {
    hr = CoCreateInstance(
           clsid,
           NULL,
           CLSCTX_INPROC_SERVER,
           IID_IDispatch,
           (void**) ppdisp
           );

    if( FAILED(hr) )
    {
      LogTrace(L"failed to create component, error %s", MapHResultToString(hr));
    }
  }
  else
  {
    if( FAILED(hr) )
    {
      LogTrace(L"progid \"%s\" could not be found, error %s", wszProgId, MapHResultToString(hr));
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\src\spobj\profpage.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    profpage.cxx

Abstract:

    Implements the profile options property page.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


HWND g_hwndListBox = NULL;


//-----------------------------------------------------------------------------
// dialog window procedures
//-----------------------------------------------------------------------------
INT_PTR
Spork::_ProfilePropPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
  switch( uMsg )
  {
    case WM_INITDIALOG :
      {
        g_hwndListBox = GetDlgItem(hwnd, IDC_PROFILELIST);

        // disable delete profile button. notimpl.
        EnableWindow(GetDlgItem(hwnd, IDB_DELPROFILE), FALSE);

        _InitProfileSupport(hwnd, NULL);
      }
      return 0L;

    case WM_NOTIFY :
      {
        switch( ((NMHDR*) lParam)->code )
        {
          case PSN_APPLY :
            {
              _SaveProfiles();
              SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) PSNRET_NOERROR);
            }
            return 1L;

          case PSN_KILLACTIVE :
            {
              SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) FALSE);
            }
            return 1L;

          case LVN_GETDISPINFO :
            {
              m_pMLV->GetDisplayInfo(&(((NMLVDISPINFO*) lParam)->item));
            }
            break;

          case NM_DBLCLK :
            {
              if( ((LPNMITEMACTIVATE) lParam)->iItem == 0xFFFFFFFF )
              {
                m_pMLV->InPlaceEdit((LPNMITEMACTIVATE) lParam);
              }
            }
            break;

          case PSN_TRANSLATEACCELERATOR :
            {
              HWND  hwndCtl = NULL;
              LPMSG pm      = (LPMSG) ((LPPSHNOTIFY) lParam)->lParam;
              WCHAR buf[64];

              switch( pm->message )
              {
                case WM_KEYDOWN : 
                  {
                    if( pm->wParam == VK_RETURN )
                    {
                      hwndCtl = WindowFromPoint(pm->pt);

                      if( hwndCtl )
                      {
                        GetClassName(hwndCtl, buf, 64);

                        if( !StrCmpI(buf, L"edit") )
                        {
                          SendMessage(
                            GetParent(hwndCtl),
                            WM_COMMAND,
                            MAKEWPARAM(0, EN_KILLFOCUS),
                            (LPARAM) hwndCtl
                            );

                          SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_MESSAGEHANDLED);
                        }
                        else
                        {
                          SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
                        }
                      }

                      return 1L;
                    }
                  }
                  break;
              }
            }
            break;
        }
      }

    case WM_COMMAND :
      {
        switch( LOWORD(wParam) )
        {
          case IDB_NEWPROFILE :
            {
              _NewProfile(hwnd);
            }
            break;

          case IDB_DELPROFILE :
            {
              // notimpl
            }
            break;

          default :
            {
              switch( HIWORD(wParam) )
              {
                case LBN_DBLCLK :
                  {
                    m_pMLV->ActivateListViewByIndex(
                              ListBox_GetSelectionIndex(g_hwndListBox)
                              );
                  }
                  break;
              }
            }
            break;
        }
      }
      break;

    default : return 0L;
  }

  return 0L;
}


//-----------------------------------------------------------------------------
// handlers for dialog events
//-----------------------------------------------------------------------------
INT_PTR
Spork::_InitProfileSupport(HWND hwndDialog, LPWSTR wszProfile)
{
  BOOL  bSuccess = FALSE;
  POINT pt;
  RECT  rcDlg;
  RECT  rcCtl;

  if( !m_pMLV )
  {
    if( !(m_pMLV = new MultiListView) )
      goto quit;

    if( m_pMLV->InitializeData(GetNumberOfSubKeysFromKey(L"Profiles")) )
    {
      m_bProfilesLoaded = _LoadProfiles();
      bSuccess          = m_bProfilesLoaded;
    }
    else
    {
      SAFEDELETE(m_pMLV);
      goto quit;
    }
  }

  if( wszProfile )
  {
    bSuccess = m_pMLV->ActivateListViewByName(wszProfile);
  }

  if( hwndDialog )
  {
    GetWindowRect(hwndDialog, &rcDlg);
    GetWindowRect(GetDlgItem(hwndDialog, IDC_PROFILEITEMS), &rcCtl);

    pt.x = rcCtl.left - rcDlg.left;
    pt.y = rcCtl.top  - rcDlg.top;

    bSuccess = m_pMLV->InitializeDisplay(
                         m_hInst,
                         hwndDialog,
                         &pt,
                         rcCtl.right  - rcCtl.left,
                         rcCtl.bottom - rcCtl.top
                         );

      if( !bSuccess )
        goto quit;

    bSuccess = m_pMLV->RefreshListView(-1);

      if( !bSuccess )
        goto quit;

    bSuccess = _InitProfileSelection();

      if( !bSuccess )
        goto quit;

    ListBox_SetCurrentSelection(g_hwndListBox, m_pMLV->GetActiveIndex());
    m_pMLV->ActivateListViewByIndex(m_pMLV->GetActiveIndex());
  }

quit:

  return (INT_PTR) bSuccess;
}


BOOL
Spork::_InitProfileSelection(void)
{
  LPWSTR wszName = NULL;
  
  ListBox_ResetContent(g_hwndListBox);

  while( m_pMLV->EnumListViewNames(&wszName) )
  {
    ListBox_InsertString(g_hwndListBox, -1, wszName);
    SAFEDELETEBUF(wszName);
  }

  return TRUE;
}


BOOL
Spork::_LoadProfiles(void)
{
  BOOL   bSuccess    = FALSE;
  BOOL   bEntry      = FALSE;
  LPWSTR wszSubKey   = NULL;
  DWORD  dwProfileId = 0L;

  if( !m_bProfilesLoaded )
  {
    bEntry = EnumerateSubKeysFromKey(L"Profiles", &wszSubKey);

    while( bEntry )
    {
      _LoadProfileEntries(dwProfileId, wszSubKey);

      SAFEDELETEBUF(wszSubKey);
      ++dwProfileId;

      // we loaded at least a single profile, so we're good to go
      bSuccess = TRUE;
      bEntry   = EnumerateSubKeysFromKey(NULL, &wszSubKey);
    }

    _LoadDebugOptions();
  }

  return bSuccess;
}


BOOL
Spork::_SaveProfiles(void)
{
  INT_PTR cProfiles = ListBox_GetItemCount(g_hwndListBox);

  for(INT_PTR n=0; n<cProfiles; n++)
  {
    if( m_pMLV->IsModified(n) )
    {
      BOOL   bEntry         = FALSE;
      LPWSTR wszProfileName = ListBox_GetItemText(g_hwndListBox, n);
      LPWSTR wszProfileKey  = new WCHAR[MAX_PATH+1];
      LPWSTR wszValueName   = NULL;
      LPVOID pvData         = NULL;
      DWORD  dwType         = 0L;

      StrCpyN(
        (StrCpy(wszProfileKey, L"Profiles\\") + wcslen(L"Profiles\\")),
        wszProfileName,
        MAX_PATH+1
        );

      bEntry = m_pMLV->EnumItems(n, &wszValueName, &dwType, &pvData);

      while( bEntry )
      {
        SetRegValueInKey(
          wszProfileKey,
          wszValueName,
          dwType,
          (dwType == REG_DWORD ? &pvData : pvData),
          0L
          );

        bEntry = m_pMLV->EnumItems(-1, &wszValueName, &dwType, &pvData);
      }

      SAFEDELETEBUF(wszProfileName);
      SAFEDELETEBUF(wszProfileKey);
    }
  }

  return TRUE;
}


BOOL
Spork::_LoadProfileEntries(INT_PTR dwProfileId, LPWSTR wszProfileName)
{
  BOOL   bSuccess      = FALSE;
  BOOL   bEntry        = FALSE;
  LPWSTR wszProfileKey = NULL;
  LPWSTR wszValueName  = NULL;
  LPVOID pvValueData   = NULL;
  DWORD  dwType        = 0L;

  m_pMLV->SetListViewName(dwProfileId, wszProfileName);

  wszProfileKey = new WCHAR[MAX_PATH+1];

  StrCpyN(
    (StrCpy(wszProfileKey, L"Profiles\\") + wcslen(L"Profiles\\")),
    wszProfileName,
    MAX_PATH+1
    );

  bEntry = EnumerateRegValuesFromKey(wszProfileKey, &wszValueName, &dwType, &pvValueData);

    while( bEntry )
    {
      // we read at least one profile item, so we can return success
      bSuccess = TRUE;

      // items prefixed with an underscore are used by other property pages
      if( *wszValueName != L'_' )
      {
        m_pMLV->AddItem(dwProfileId, wszValueName, dwType, pvValueData);
      }

      SAFEDELETEBUF(wszValueName);
      SAFEDELETEBUF(pvValueData);

      // get next value
      bEntry = EnumerateRegValuesFromKey(NULL, &wszValueName, &dwType, &pvValueData);
    }

  SAFEDELETEBUF(wszProfileKey);
  return bSuccess;
}


LPWSTR
Spork::_GetCurrentProfilePath(void)
{
  LPWSTR wszProfileKey  = NULL;
  LPWSTR wszProfileName = NULL;

  if( m_pMLV )
  {
    if( m_pMLV->GetListViewName(-1, &wszProfileName) )
    {
      wszProfileKey = new WCHAR[MAX_PATH+1];

      if( wszProfileKey )
      {
        StrCpyN(
          (StrCpy(wszProfileKey, L"Profiles\\") + wcslen(L"Profiles\\")),
          wszProfileName,
          MAX_PATH+1
          );
      }

      SAFEDELETEBUF(wszProfileName);
    }
  }

  return wszProfileKey;
}


BOOL
Spork::_NewProfile(HWND hwnd)
{
  BOOL   bStatus     = FALSE;
  LPWSTR NewProfile  = NULL;
  LPWSTR ProfilePath = NULL;
  LPWSTR DefInclude  = NULL;

  NewProfile = (LPWSTR) GetUserInput(m_hInst, hwnd, L"Create Profile");

  if( NewProfile )
  {
    ProfilePath = new WCHAR[MAX_PATH];

    if( ProfilePath )
    {
      wnsprintf(
        ProfilePath,
        MAX_PATH,
        L"%s\\%s",
        L"Profiles",
        NewProfile
        );

      if( SetRegKey(ProfilePath, NULL) )
      {
        if( GetRootRegValue(L"InstallDir", REG_SZ, (void**) &DefInclude) )
        {
          if( SetRegValueInKey(ProfilePath, L"include", REG_SZ, (void*) DefInclude, 0) )
          {
            if( m_pMLV )
            {
              m_pMLV->TerminateDisplay();
              SAFEDELETE(m_pMLV);
              m_bProfilesLoaded = FALSE;
            }
          
            _InitProfileSupport(hwnd, NewProfile);
            bStatus = TRUE;
          }

          SAFEDELETEBUF(DefInclude);
        }
      }

      SAFEDELETEBUF(ProfilePath);
    }

    SAFEDELETEBUF(NewProfile);
  }

  return bStatus;
}


INT_PTR
CALLBACK
ProfilePropPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  static PSPORK ps = NULL;

  if( !ps )
  {
    switch( uMsg )
    {
      case WM_INITDIALOG :
        {
          ps = (PSPORK) ((LPPROPSHEETPAGE) lParam)->lParam;
        }
        break;
      
      default : return FALSE;
    }
  }

  return ps->_ProfilePropPageProc(hwnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\src\spobj\spork.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    spork.cxx

Abstract:

    Implements the non-interface class members of the Spork object.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


//-----------------------------------------------------------------------------
// Class members
//-----------------------------------------------------------------------------
Spork::Spork():
  m_hInst(NULL),
  m_pTypeLib(NULL),
  m_wszScriptFile(NULL),
  m_wszProfile(NULL),
  m_bProfilesLoaded(FALSE),
  m_pObjectCache(NULL),
  m_pPropertyBag(NULL),
  m_pMLV(NULL)
{
  DEBUG_TRACE((L"Spork [%#x] created", this));
}


Spork::~Spork()
{
  if( m_pObjectCache )
  {
    m_pObjectCache->Clear();
    SAFEDELETE(m_pObjectCache);
  }

  if( m_pPropertyBag )
  {
    m_pPropertyBag->Clear();
    SAFEDELETE(m_pPropertyBag);
  }

  SAFEDELETE(m_pMLV);
  SAFERELEASE(m_pScriptEngine[JSCRIPT]);
  SAFERELEASE(m_pScriptEngine[VBSCRIPT]);
  SAFERELEASE(m_pTypeLib);
  SAFEDELETEBUF(m_wszScriptFile);
  SAFEDELETEBUF(m_wszProfile);

  DEBUG_TRACE((L"Spork [%#x] deleted", this));
}


HRESULT
Spork::Create(
  HINSTANCE hInst,
  PSPORK*   pps
  )
{
  HRESULT hr = S_OK;
  PSPORK  ps = NULL;

  if( !pps )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( ps = new SPORK )
  {
    hr = ps->_Initialize(hInst);

    if( SUCCEEDED(hr) )
    {
      LogTrace(L"spork initialized");
      *pps = ps;
    }
    else
    {
      SAFEDELETE(ps);
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  return hr;
}


HRESULT
Spork::_Initialize(
  HINSTANCE hInst
  )
{
  HRESULT hr   = S_OK;
  LPWSTR  path = NULL;

  m_hInst = hInst;

  m_pObjectCache = new OBJCACHE;

    if( !m_pObjectCache )
    {
      hr = E_OUTOFMEMORY;
      goto quit;
    }

  m_pPropertyBag = new PROPERTYBAG;

    if( !m_pPropertyBag )
    {
      hr = E_OUTOFMEMORY;
      goto quit;
    }

  m_pObjectCache->SetClearFunction(ObjectKiller);
  m_pPropertyBag->SetClearFunction(VariantKiller);

  path = new WCHAR[MAX_PATH];

    if( !path )
    {
      hr = E_OUTOFMEMORY;
      goto quit;
    }

  if( GetModuleFileName(NULL, path, MAX_PATH) )
  {
    hr = LoadTypeLib(path, &m_pTypeLib);
  }
  else
  {
    LogTrace(L"spork failed to load its typeinfo");
    hr = E_FAIL;
  }
  
  SAFEDELETEBUF(path);

quit:

  return hr;
}


HRESULT
Spork::Run(void)
{
  HRESULT     hr      = S_OK;
  HANDLE      hThread = NULL;
  PSCRIPTINFO psi     = NULL;
  DBGOPTIONS  dbo;

  m_wszScriptFile = GlobalGetScriptName();
  m_wszProfile    = GlobalGetProfileName();

  if( !m_wszProfile )
  {
    m_wszProfile = StrDup(L"default");
  }

  if( !_InitProfileSupport(NULL, m_wszProfile) )
  {
    LogTrace(L"failed to init profile support");
  }

  if( GlobalIsSilentModeEnabled() )
  {
    if( !m_wszScriptFile )
    {
      LogTrace(L"no script to run, exiting");
      goto quit;
    }

    psi = new SCRIPTINFO;

      if( !psi )
      {
        hr = E_OUTOFMEMORY;
        goto quit;
      }

    psi->bIsFork         = FALSE;
    psi->bstrChildParams = NULL;
    psi->htParent        = TVI_ROOT;
    psi->pSpork          = this;
    hr                   = CreateScriptThread(psi, &hThread);

      if( FAILED(hr) )
      {
        SAFEDELETE(psi);
        goto quit;
      }

    WaitForSingleObject(hThread, INFINITE);
    SAFECLOSE(hThread);
  }
  else
  {
    hr = _LaunchUI();
  }
  
quit:

  return hr;
}


//-----------------------------------------------------------------------------
// 'Service interface' methods
//-----------------------------------------------------------------------------
HRESULT
Spork::CreateScriptThread(
  PSCRIPTINFO pScriptInfo,
  HANDLE*     pThreadHandle
  )
{
  HRESULT hr         = S_OK;
  DWORD   dwThreadId = 0L;

  if( pScriptInfo )
  {
    //
    // default behavior: if the caller's scriptinfo doesn't name a script,
    // we use the last script selected into the spork object.
    //
    if( !pScriptInfo->wszScriptFile )
    {
      pScriptInfo->wszScriptFile = m_wszScriptFile;
    }

    LogTrace(L"running script %s", pScriptInfo->wszScriptFile);

    *pThreadHandle = CreateThread(
                       NULL,
                       0L,
                       ScriptThread,
                       (LPVOID) pScriptInfo,
                       0L,
                       &dwThreadId
                       );

    if( !(*pThreadHandle) )
    {
      LogTrace(L"failed to create script thread");
      hr = E_FAIL;
    }
  }
  else
  {
    hr = E_INVALIDARG;
  }

  return hr;
}


HRESULT
Spork::GetScriptEngine(
  SCRIPTTYPE      st,
  IActiveScript** ppias
  )
{
  HRESULT        hr     = S_OK;
  IActiveScript* pias   = NULL;
  CLSID          clsid  = {0};
  LPWSTR         progid = NULL;

  if( st == UNKNOWN )
  {
    LogTrace(L"the script type is unknown, aborting");
    hr = E_FAIL;
    goto quit;
  }

  if( m_pScriptEngine[st] )
  {
    pias = m_pScriptEngine[st];
  }
  else
  {
    switch( st )
    {
      case JSCRIPT  : progid = L"JScript";   break;
      case VBSCRIPT : progid = L"VBScript";  break;
      default       : hr     = E_INVALIDARG; goto quit;
    }

    LogTrace(L"loading %s engine", progid);

    hr = CLSIDFromProgID(progid, &clsid);

      if( FAILED(hr) )
        goto quit;

    hr = CoCreateInstance(
           clsid,
           NULL,
           CLSCTX_INPROC_SERVER,
           IID_IActiveScript,
           (void**) &m_pScriptEngine[st]
           );

      if( FAILED(hr) )
      {
        LogTrace(L"load failed: %s", MapHResultToString(hr));
        goto quit;
      }
        
    pias = m_pScriptEngine[st];
  }

  hr = pias->Clone(ppias);

quit:

  return hr;
}


HRESULT
Spork::GetTypeLib(
  ITypeLib** pptl
  )
{
  return m_pTypeLib->QueryInterface(IID_ITypeLib, (void**) pptl);
}


HRESULT
Spork::GetNamedProfileItem(
  LPWSTR  wszItemName,
  LPVOID* ppvItem
  )
{
  HRESULT hr     = E_FAIL;
  BOOL    bRet   = FALSE;
  DWORD   dwType = 0L;
  LPVOID  pvData = NULL;

  if( m_bProfilesLoaded )
  {
    bRet = m_pMLV->GetItemByName(
                     -1,
                     wszItemName,
                     &dwType,
                     &pvData
                     );

    if( bRet )
    {
      if( dwType == MLV_STRING )
      {
        *ppvItem = (LPVOID) StrDup((LPWSTR) pvData);
      }
      else
      {
        *ppvItem              = (LPVOID) new DWORD;
        *((DWORD_PTR*) *ppvItem) = (DWORD_PTR) pvData;
      }

      hr = S_OK;
    }
  }

  return hr;
}


HRESULT
Spork::GetProfileDebugOptions(
  PDBGOPTIONS pdbo
  )
{
  if( m_bProfilesLoaded )
  {
    m_pMLV->GetDebugOptions(pdbo);
  }
  else
  {
    pdbo->bEnableDebug        = FALSE;
    pdbo->bBreakOnScriptStart = FALSE;
    pdbo->bEnableDebugWindow  = FALSE;
  }
  
  return S_OK;
}


HRESULT
Spork::ObjectCache(
  LPWSTR       wszObjectName,
  PCACHEENTRY* ppCacheEntry,
  ACTION       action
  )
{
  HRESULT hr = S_OK;

  switch( action )
  {
    case STORE :
      {
        (*ppCacheEntry)->pDispObject->AddRef();
        m_pObjectCache->Insert(wszObjectName, (void*) *ppCacheEntry);
      }
      break;

    case RETRIEVE :
      {
        if( m_pObjectCache->Get(wszObjectName, (void**) ppCacheEntry) == ERROR_SUCCESS )
        {
          (*ppCacheEntry)->pDispObject->AddRef();
        }
        else
        {
          hr = E_FAIL;
        }
      }
      break;

    case REMOVE :
      {
        m_pObjectCache->Delete(wszObjectName, NULL);
      }
      break;
  }

  return hr;
}


HRESULT
Spork::PropertyBag(
  LPWSTR    wszPropertyName,
  VARIANT** ppvarValue,
  ACTION    action
  )
{
  HRESULT  hr  = S_OK;
  VARIANT* pvr = NULL;

  switch( action )
  {
    case STORE :
      {
        pvr = new VARIANT;
        VariantInit(pvr);

        hr = VariantCopy(pvr, *ppvarValue);

        if( SUCCEEDED(hr) )
        {
          m_pPropertyBag->Insert(wszPropertyName, (void*) pvr);
        }
      }
      break;

    case RETRIEVE :
      {
        if( m_pPropertyBag->Get(wszPropertyName, (void**) &pvr) == ERROR_SUCCESS )
        {
          hr = VariantCopy(*ppvarValue, pvr);
        }
        else
        {
          V_VT(*ppvarValue) = VT_NULL;
        }
      }
      break;

    case REMOVE :
      {
        m_pPropertyBag->Delete(wszPropertyName, NULL);
      }
      break;
  }

  return hr;
}


HRESULT
Spork::NotifyUI(
  BOOL       bInsert,
  LPCWSTR    wszName,
  PSCRIPTOBJ pScriptObject,
  HTREEITEM  htParent,
  HTREEITEM* phtItem
  )
{
  HRESULT        hr = S_OK;
  HTREEITEM      ht = NULL;
  TVINSERTSTRUCT tvins;
  TVITEM         item;

  if( bInsert )
  {
    item.mask       = TVIF_TEXT | TVIF_PARAM;
    item.pszText    = (LPWSTR) wszName;
    item.cchTextMax = wcslen(wszName);
    item.lParam     = (LPARAM) pScriptObject;

    tvins.item      = item;
    tvins.hParent   = htParent;

    *phtItem = (HTREEITEM) TreeView_InsertItem(m_DlgWindows.TreeView, &tvins);
    TreeView_EnsureVisible(m_DlgWindows.TreeView, *phtItem);

    if( htParent == TVI_ROOT )
    {
      EnableWindow(GetDlgItem(m_DlgWindows.Dialog, IDB_RUN), FALSE);
    }
  }
  else
  {
    TreeView_DeleteItem(m_DlgWindows.TreeView, *phtItem);

    if( htParent == TVI_ROOT )
    {
      EnableWindow(GetDlgItem(m_DlgWindows.Dialog, IDB_RUN), TRUE);
    }
    else
    {
      TreeView_EnsureVisible(m_DlgWindows.TreeView, htParent);
    }
  }

  return hr;
}


//-----------------------------------------------------------------------------
// hashtable support functions
//-----------------------------------------------------------------------------
void
CObjectCache::GetHashAndBucket(LPWSTR id, LPDWORD lpHash, LPDWORD lpBucket)
{
  *lpHash   = GetHash(id);
  *lpBucket = (*lpHash) % 10;
}


void
CPropertyBag::GetHashAndBucket(LPWSTR id, LPDWORD lpHash, LPDWORD lpBucket)
{
  *lpHash   = GetHash(id);
  *lpBucket = (*lpHash) % 10;
}


void
ObjectKiller(LPVOID* ppv)
{
  PCACHEENTRY pce = (PCACHEENTRY) *ppv;

  if( pce )
  {
    pce->pDispObject->Release();
    SAFEDELETE(pce);
  }
}


void
VariantKiller(LPVOID* ppv)
{
  VARIANT** ppvr = (VARIANT**) ppv;

  VariantClear(*ppvr);
  SAFEDELETE(*ppvr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\src\spobj\multilistview.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    multilistview.cxx

Abstract:

    Implements the MultiListView control.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

Notes:

    This object implements a pseudo-control based on the Win32 ListView and
    a data store to track the items displayed in the ListView(s). The
    Initialize function has two modes: init display or init data. If it is
    called with a NULL hwndParent, it will only initialize the data store
    portion of the control. It can be called again to initialize UI to display
    the ListViews that show the data.

    Many places in the code are wrapped in if( m_hwndParent ) { ... } constructs,
    please beware if making changes around them, you must make not whether your
    change depends on the UI being available or not.

    In all methods except EnumItems, an iListView value of -1 means "use the
    currently active ListView", the index of which is stored in m_dwActive.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


MultiListView::~MultiListView()
{
  PITEMINFO pCurrent = NULL;
  PITEMINFO pNext    = NULL;

  for(DWORD n=0; n<m_cListViews; n++)
  {
    if( pCurrent = m_arListViews[n].items )
    {
      do
      {
        pNext = pCurrent->pNext;

        SAFEDELETEBUF(pCurrent->wszName);
        SAFEDELETEBUF(pCurrent->wszValue);
        SAFEDELETE(pCurrent);
        pCurrent = pNext;
      }
      while( pNext );
    }
    
    SAFEDELETEBUF(m_arListViews[n].name);
  }

  SAFEDELETEBUF(m_arListViews);
}


BOOL
MultiListView::InitializeData(
  DWORD cListViews
  )
{
  if( !cListViews )
    return FALSE;

  m_dwActive    = 0L;
  m_cListViews  = cListViews;
  m_arListViews = new MLVINFO[m_cListViews];

  if( !m_arListViews )
    return FALSE;

  return TRUE;
}


BOOL
MultiListView::InitializeDisplay(
  HINSTANCE hInstance,
  HWND      hwndParent,
  POINT*    pptOrigin,
  DWORD     dwWidth,
  DWORD     dwHeight
  )
{
  LVCOLUMN lvc;

  m_hInstance  = hInstance;
  m_hwndParent = hwndParent;

  // set column info
  lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM;
  lvc.fmt  = LVCFMT_LEFT;

  for(DWORD n=0; n<m_cListViews; n++)
  {
    // create the listview windows
    m_arListViews[n].hwnd =
      CreateWindowEx(
        WS_EX_CLIENTEDGE,
        WC_LISTVIEW,
        NULL,
        LVS_REPORT | WS_BORDER | WS_CHILD,
        pptOrigin->x,
        pptOrigin->y,
        dwWidth,
        dwHeight,
        m_hwndParent,
        NULL,
        m_hInstance,
        0
        );
    
    // enable gridlines
    ListView_SetExtendedListViewStyle(m_arListViews[n].hwnd, LVS_EX_GRIDLINES);

    // create the listview columns
    lvc.pszText    = L"name";
    lvc.iSubItem   = 0;
    ListView_InsertColumn(m_arListViews[n].hwnd, 0, &lvc);

    lvc.pszText    = L"value";
    lvc.iSubItem   = 1;
    ListView_InsertColumn(m_arListViews[n].hwnd, 1, &lvc);

    // provide a backpointer to this class for the window subclass proc
    SetWindowLongPtr(
      m_arListViews[n].hwnd,
      GWLP_USERDATA,
      (LONG_PTR) this
      );

    // store a pointer to the original listview proc
    m_arListViews[n].wndproc =
      (WNDPROC) SetWindowLongPtr(
                  m_arListViews[n].hwnd,
                  GWLP_WNDPROC,
                  (LONG_PTR) ListViewSubclassProc
                  );
  }

  ShowWindow(
    m_arListViews[m_dwActive].hwnd,
    SW_NORMAL
    );

  return TRUE;
}


BOOL
MultiListView::TerminateDisplay(void)
{
  for(DWORD n=0; n<m_cListViews; n++)
  {
    DestroyWindow(m_arListViews[n].hwnd);
  }

  return TRUE;
}


BOOL
MultiListView::AddItem(
  INT_PTR iListView,
  LPWSTR  wszName,
  DWORD   dwType,
  LPVOID  pvData
  )
{
  PITEMINFO pInsert = NULL;
  PITEMINFO pItem   = NULL;

  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;

  if( !wszName )
    return FALSE;

  if( iListView == -1 )
  {
    iListView = m_dwActive;
  }

  //
  // only insert into a listview if we're displayed; if not, the client
  // will need to call RefreshListView to get the active LV to poll
  // the client for display data (which should be delegated back to us
  // via GetDisplayInfo).
  //
  if( m_hwndParent )
  {
    _AddItemToListView(iListView, m_arListViews[iListView].currentid);
  }

  // advance the current item count
  ++m_arListViews[iListView].currentid;

  if( pItem = new ITEMINFO )
  {
    // find a suitable place to insert the new item
    if( !(pInsert = m_arListViews[iListView].items) )
    {
      m_arListViews[iListView].items = pItem;
    }
    else
    {
      while( pInsert->pNext )
        pInsert = pInsert->pNext;

      pInsert->pNext = pItem;
    }

    pItem->wszName = StrDup(wszName);
    pItem->dwType  = dwType;

    if( dwType == MLV_STRING )
    {
      pItem->wszValue = StrDup((LPWSTR) pvData);
    }
    else
    {
      pItem->dwValue  = *((LPDWORD) pvData);
      pItem->wszValue = new WCHAR[32];
      _itow(pItem->dwValue, pItem->wszValue, 10);
    }
  }

  return TRUE;
}


BOOL
MultiListView::GetItem(
  INT_PTR iListView,
  INT_PTR iItem,
  LPWSTR* ppwszName,
  LPDWORD pdwType,
  LPVOID* ppvData
  )
{
  PITEMINFO pItem = NULL;

  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;

  //
  // BUGBUG: need to validate iItem. can this fn and ModifyItem share code?
  //

  if( iListView == -1 )
  {
    pItem = m_arListViews[m_dwActive].items;
  }
  else
  {
    pItem = m_arListViews[iListView].items;
  }

  for(INT_PTR n=0; n<iItem; n++)
  {
    pItem = pItem->pNext;
  }

  if( ppwszName )
  {
    *ppwszName = pItem->wszName;
  }

  if( pdwType )
  {
    *pdwType = pItem->dwType;
  }

  if( ppvData )
  {
    if( pItem->dwType == MLV_STRING )
    {
      *ppvData = pItem->wszValue;
    }
    else
    {
      *ppvData = (LPVOID) ((DWORD_PTR) pItem->dwValue);
    }
  }

  return TRUE;
}


BOOL
MultiListView::GetItemByName(
  INT_PTR iListView,
  LPWSTR  wszName,
  LPDWORD pdwType,
  LPVOID* ppvData
  )
{
  PITEMINFO pItem = NULL;

  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;

  if( iListView == -1 )
  {
    iListView = m_dwActive;
  }
  
  pItem = m_arListViews[m_dwActive].items;

  while( pItem )
  {
    if( !StrCmpI(wszName, pItem->wszName) )
    {
      if( pdwType )
      {
        *pdwType = pItem->dwType;
      }

      if( ppvData )
      {
        if( pItem->dwType == MLV_STRING )
        {
          *ppvData = pItem->wszValue;
        }
        else
        {
          *ppvData = (LPVOID) ((DWORD_PTR) pItem->dwValue);
        }
      }

      return TRUE;
    }

    pItem = pItem->pNext;
  }

  return FALSE;
}


BOOL
MultiListView::ModifyItem(
  INT_PTR iListView,
  INT_PTR iItem,
  LPWSTR  wszName,
  DWORD   dwType,
  LPVOID  pvData
  )
{
  PITEMINFO pItem = NULL;

  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;

  pItem = m_arListViews[iListView].items;

  //
  // BUGBUG: need to validate iItem before doing anything
  //

  // locate the item we're to modify
  for(INT_PTR n=0; n<iItem; n++)
  {
    pItem = pItem->pNext;
  }

  if( wszName )
  {
    SAFEDELETEBUF(pItem->wszName);
    pItem->wszName = StrDup(wszName);

    if( m_hwndParent )
    {
      ListView_SetItemText(
        m_arListViews[iListView].hwnd,
        iItem, 0,
        pItem->wszName
        );
    }
  }

  if( dwType )
  {
    if( dwType != MLV_RETAIN )
    {
      pItem->dwType = dwType;
    }
  }

  if( pvData )
  {
    SAFEDELETEBUF(pItem->wszValue);

    if( pItem->dwType == MLV_STRING )
    {
      pItem->wszValue = StrDup((LPWSTR) pvData);
    }
    else
    {
      pItem->dwValue  = *((LPDWORD) pvData);
      pItem->wszValue = new WCHAR[32];
      _itow(pItem->dwValue, pItem->wszValue, 10);
    }

    if( m_hwndParent )
    {
      ListView_SetItemText(
        m_arListViews[iListView].hwnd,
        iItem, 1,
        pItem->wszValue
        );
    }
  }

  return TRUE;
}


BOOL
MultiListView::EnumItems(
  INT_PTR iListView,
  LPWSTR* ppwszName,
  LPDWORD pdwType,
  LPVOID* ppvData
  )
{
  static PITEMINFO pItem = NULL;

  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;

  // if the caller specifies the listview to use, get the first item
  // in that listview's list, otherwise continue where we left off.
  if( iListView != -1 )
  {
    pItem = m_arListViews[iListView].items;
  }
  else
  {
    pItem = pItem->pNext;
  }

  // assign references to the data, don't copy it. when there
  // are no more entries, return false.
  if( pItem )
  {
    *ppwszName = pItem->wszName;
    *pdwType   = pItem->dwType;

    if( pItem->dwType == MLV_STRING )
    {
      *ppvData = (LPVOID) pItem->wszValue;
    }
    else
    {
      *ppvData = (LPVOID) ((DWORD_PTR) pItem->dwValue);
    }
  }
  else
  {
    return FALSE;
  }

  return TRUE;
}


BOOL
MultiListView::InPlaceEdit(
  LPNMITEMACTIVATE pnmia
  )
{
  HWND            editctl  = NULL;
  LPLVHITTESTINFO plvhti   = new LVHITTESTINFO;
  RECT            rectItem;
  WCHAR           wsz[256];

  if( !plvhti )
    return FALSE;

  // check to see if the double-click was really on a subitem
  plvhti->pt = pnmia->ptAction;
  ListView_SubItemHitTest(m_arListViews[m_dwActive].hwnd, plvhti);

  if( plvhti->flags & LVHT_ONITEM )
  {
    // get the rectangle containing the selected subitem
    ListView_GetSubItemRect(
      m_arListViews[m_dwActive].hwnd,
      plvhti->iItem, 1,
      LVIR_BOUNDS,
      &rectItem
      );

    // snap a copy of the current text
    ListView_GetItemText(
      m_arListViews[m_dwActive].hwnd,
      plvhti->iItem, 1,
      wsz,
      256
      );

    // create an edit control positioned over the subitem
    // we want to edit
    editctl = CreateWindowEx(
                WS_EX_WINDOWEDGE,
                WC_EDIT,
                wsz,
                ES_AUTOHSCROLL | WS_CHILD,
                rectItem.left+1,
                rectItem.top,
                ListView_GetColumnWidth(m_arListViews[m_dwActive].hwnd, 1),
                rectItem.bottom-rectItem.top-1,
                m_arListViews[m_dwActive].hwnd,
                NULL,
                m_hInstance,
                0
                );

    // store the hittest information in the control's userdata
    // so the listview subclass procedure can apply any changes
    // to the correct listview item
    SetWindowLongPtr(editctl, GWLP_USERDATA, (LONG_PTR) plvhti);

    // set the edit control's font to that of the parent listview
    SendMessage(
      editctl,
      WM_SETFONT,
      (WPARAM) SendMessage(m_arListViews[m_dwActive].hwnd, WM_GETFONT, 0, 0),
      (LPARAM) TRUE
      );

    // set input focus, select all text and show the control
    SetFocus(editctl);
    SendMessage(editctl, EM_SETSEL, 0, -1);
    ShowWindow(editctl, SW_SHOW);

    return TRUE;
  }
  else
  {
    SAFEDELETE(plvhti);
    return FALSE;
  }
}


BOOL
MultiListView::GetDisplayInfo(
  LPLVITEM plvi
  )
{
  DWORD_PTR iListView = plvi->lParam;
  PITEMINFO pItem     = NULL;

  if( plvi->iItem >= (INT_PTR) m_arListViews[iListView].currentid )
    return FALSE;

  pItem = m_arListViews[iListView].items;

  for(INT_PTR n=0; n<plvi->iItem; n++)
  {
    pItem = pItem->pNext;
  }

  plvi->mask    |= LVIF_DI_SETITEM;
  plvi->pszText  = (plvi->iSubItem ? pItem->wszValue : pItem->wszName);

  return TRUE;
}


BOOL
MultiListView::RefreshListView(
  INT_PTR iListView
  )
{
  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;

  DWORD_PTR i = 0;
  INT_PTR   n = 0;

  if( iListView == -1 )
  {
    for(i=0; i<m_cListViews; i++)
    {
      ListView_DeleteAllItems(m_arListViews[i].hwnd);

        for(n=0; n<(INT_PTR) m_arListViews[i].currentid; n++)
        {
          _AddItemToListView(i, n);
        }
      
      ResizeColumns(i);
    }
  }
  else
  {
    ListView_DeleteAllItems(m_arListViews[iListView].hwnd);

      for(n=0; n<(INT_PTR) m_arListViews[iListView].currentid; n++)
      {
        _AddItemToListView(iListView, n);
      }
    
    ResizeColumns(i);
  }

  return TRUE;
}


BOOL
MultiListView::ActivateListViewByIndex(
  INT_PTR iListView
  )
{
  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;

  if( IsDisplayEnabled() )
  {
    ShowWindow(m_arListViews[m_dwActive].hwnd, SW_HIDE);
    ShowWindow(m_arListViews[iListView].hwnd, SW_NORMAL);
  }

  m_dwActive = iListView;

  return TRUE;
}


BOOL
MultiListView::ActivateListViewByName(
  LPWSTR wszName
  )
{
  DWORD dwListView = 0L;

  while( dwListView < m_cListViews )
  {
    if( !StrCmpI(wszName, m_arListViews[dwListView].name) )
    {
      return ActivateListViewByIndex(dwListView);
    }

    ++dwListView;
  }

  return FALSE;
}


INT_PTR
MultiListView::GetActiveIndex(void)
{
  return (INT_PTR) m_dwActive;
}


BOOL
MultiListView::GetListViewName(
  INT_PTR     iListView,
  LPWSTR* ppwszName
  )
{
  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;

  if( iListView == -1 )
  {
    iListView = m_dwActive;
  }

  *ppwszName = StrDup(m_arListViews[iListView].name);

  if( *ppwszName )
    return TRUE;

  return FALSE;
}


BOOL
MultiListView::SetListViewName(
  INT_PTR    iListView,
  LPWSTR wszName
  )
{
  if( (iListView == -1) || (iListView >= (INT_PTR) m_cListViews) )
    return FALSE;

  if( !wszName )
    return FALSE;

  return (m_arListViews[iListView].name = StrDup(wszName)) ? TRUE : FALSE;
}


BOOL
MultiListView::EnumListViewNames(
  LPWSTR* ppwszName
  )
{
  static DWORD dwCurrent = 0L;

  if( dwCurrent < m_cListViews )
  {
    *ppwszName = StrDup(m_arListViews[dwCurrent++].name);
    return TRUE;
  }
  else
  {
    dwCurrent  = 0L;
    *ppwszName = NULL;
    return FALSE;
  }
}


BOOL
MultiListView::ResizeColumns(
  INT_PTR iListView
  )
{
  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;

  if( iListView == -1 )
  {
    iListView = m_dwActive;
  }

  if( m_hwndParent )
  {
    ListView_SetColumnWidth(m_arListViews[iListView].hwnd, 0, LVSCW_AUTOSIZE_USEHEADER);
    ListView_SetColumnWidth(m_arListViews[iListView].hwnd, 1, LVSCW_AUTOSIZE_USEHEADER);
  }

  return TRUE;
}


BOOL
MultiListView::IsListViewName(
  LPWSTR wszName
  )
{
  DWORD dwListView = 0L;

  while( dwListView < m_cListViews )
  {
    if( !StrCmpI(wszName, m_arListViews[dwListView].name) )
    {
      return TRUE;
    }

    ++dwListView;
  }

  return FALSE;
}


BOOL
MultiListView::IsModified(
  INT_PTR iListView
  )
{
  if( iListView >= (INT_PTR) m_cListViews )
    return FALSE;
  
  if( iListView == -1 )
  {
    iListView = m_dwActive;
  }

  return m_arListViews[iListView].modified;
}


BOOL
MultiListView::GetDebugOptions(
  PDBGOPTIONS pdbo
  )
{
  if( !pdbo )
    return FALSE;

  *pdbo = m_arListViews[m_dwActive].dbgopts;

  return TRUE;
}


BOOL
MultiListView::SetDebugOptions(
  DBGOPTIONS dbo
  )
{
  m_arListViews[m_dwActive].dbgopts = dbo;
  return TRUE;
}


void
MultiListView::_AddItemToListView(
  INT_PTR iListView,
  INT_PTR iItem
  )
{
  LVITEM lvitem  = {0};

  lvitem.mask     = LVIF_TEXT | LVIF_PARAM;
  lvitem.lParam   = iListView;
  lvitem.iItem    = (int) iItem;
  lvitem.pszText  = LPSTR_TEXTCALLBACK;

  ListView_InsertItem(m_arListViews[iListView].hwnd, &lvitem);

  lvitem.iSubItem = 1;

  ListView_SetItem(m_arListViews[iListView].hwnd, &lvitem);
}


BOOL
MultiListView::_UpdateItem(
  HWND    hwndEdit,
  INT_PTR iItem
  )
{
  BOOL  bUpdated = FALSE;
  DWORD dwType;
  WCHAR edited[256];

  if( SendMessage(hwndEdit, EM_GETMODIFY, 0, 0) )
  {
    GetWindowText(hwndEdit, edited, 256);

    if( GetItem(m_dwActive, iItem, NULL, &dwType, NULL) )
    {
      ModifyItem(
        m_dwActive,
        iItem,
        NULL,
        MLV_RETAIN,
        ((dwType == MLV_DWORD) ? ((dwType = _wtoi(edited)), (LPVOID) &dwType) : (LPVOID) edited)
        );

      bUpdated = TRUE;
    }
  }

  return bUpdated;
}


//-----------------------------------------------------------------------------
// listview subclass procedure
//-----------------------------------------------------------------------------
LRESULT
MultiListView::_ListViewSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  switch( uMsg )
  {
    case WM_COMMAND :
      {
        switch( HIWORD(wParam) )
        {
          case EN_KILLFOCUS :
            {
              LPLVHITTESTINFO plvhti = (LPLVHITTESTINFO) GetWindowLongPtr((HWND) lParam, GWLP_USERDATA);

              if( plvhti )
              {
                if( _UpdateItem((HWND) lParam, plvhti->iItem) )
                {
                  // notify the propertysheet that something changed
                  PropSheet_Changed(GetParent(m_hwndParent), m_hwndParent);

                  // mark this listview as user-modified
                  m_arListViews[m_dwActive].modified = TRUE;

                  // if this message was posted during VK_RETURN processing in the
                  // propsheetpage proc, we will get a duplicate EN_KILLFOCUS. to
                  // avoid dorking ourselves, clear the window userdata.
                  SetWindowLongPtr((HWND) lParam, GWLP_USERDATA, (LONG) 0L);
                }

                SAFEDELETE(plvhti);
                DestroyWindow((HWND) lParam);
              }
            }
            return 0L;
        }
      }
      break;
  }

  return CallWindowProc(
            m_arListViews[m_dwActive].wndproc,
            hwnd,
            uMsg,
            wParam,
            lParam
            );
}


//-----------------------------------------------------------------------------
// friend window proc
//-----------------------------------------------------------------------------
LRESULT
CALLBACK
ListViewSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  return ((MultiListView*) GetWindowLongPtr(hwnd, GWLP_USERDATA))->_ListViewSubclassProc(hwnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\memstats.h ===
///////////////////////////////////////////////////////////////////////////
// File:  MemStats.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	MemStats.h: Helper functions that get's the system memory info.
//	Borrowed from EricI's memstats app.
//
// History:
//	03/21/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MEMSTATS_H__D91043CB_5CB3_47C9_944F_B9FAA9BD26C4__INCLUDED_)
#define AFX_MEMSTATS_H__D91043CB_5CB3_47C9_944F_B9FAA9BD26C4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

#define UNICODE
#define _UNICODE

//
// WIN32 headers
//
#include <windows.h>
#include <pdh.h>
#include <shlwapi.h>

//
// Project headers
//
#include "WinHttpStressScheduler.h"
#include "ServerCommands.h"


//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////


// struct for process memory stats
#define PROCCOUNTERS    4
struct PROC_CNTRS {
	ULONG lPID;
	ULONG lPrivBytes;
	ULONG lHandles;
	ULONG lThreads;
};

// struct for system wide memory stats
#define MEMCOUNTERS     9
struct MEM_CNTRS {
    ULONG lCommittedBytes;
    ULONG lCommitLimit;
    ULONG lSystemCodeTotalBytes;
    ULONG lSystemDriverTotalBytes;
    ULONG lPoolNonpagedBytes;
    ULONG lPoolPagedBytes;
    ULONG lAvailableBytes;
    ULONG lCacheBytes;
    ULONG lFreeSystemPageTableEntries;
};


BOOL MemStats__SendSystemMemoryLog(LPSTR, DWORD, DWORD);


#endif // !defined(AFX_MEMSTATS_H__D91043CB_5CB3_47C9_944F_B9FAA9BD26C4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\networktools.h ===
///////////////////////////////////////////////////////////////////////////
// File:  NetworkTools.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	NetworkTools.h: Helper functions that send/receive data.
//
// History:
//	02/22/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_NETWORKTOOLS_H__4243AA4D_B243_4A0E_B729_243F260FC4F4__INCLUDED_)
#define AFX_NETWORKTOOLS_H__4243AA4D_B243_4A0E_B729_243F260FC4F4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//
#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <winhttp.h>
#include <shlwapi.h>

//
// Project headers
//


//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////

#define		DEBUGGER_TOOLS_PATH		_T("c:\\debuggers\\")

BOOL	NetworkTools__POSTResponse(LPTSTR, LPSTR, LPTSTR);
BOOL	NetworkTools__SendLog(LPSTR, LPSTR, LPTSTR, DWORD);
BOOL	NetworkTools__URLDownloadToFile(LPCTSTR, LPCTSTR, LPCTSTR);
BOOL	NetworkTools__GetFileNameFromURL(LPTSTR, LPTSTR, DWORD);
BOOL	NetworkTools__CopyFile(LPCTSTR, LPCTSTR);
BOOL	NetworkTools__PageHeap(BOOL, LPCTSTR, LPCTSTR);
BOOL	NetworkTools__UMDH(BOOL, LPCTSTR, LPCTSTR, LPCTSTR, DWORD);
BOOL	NetworkTools__GetDllVersion(LPTSTR, LPSTR, DWORD);

#endif // !defined(AFX_NETWORKTOOLS_H__4243AA4D_B243_4A0E_B729_243F260FC4F4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\spork\src\spobj\ui.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ui.cxx

Abstract:

    Implements the Spork object's UI routines.
    
Author:

    Paul M Midgen (pmidge) 22-February-2001


Revision History:

    22-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/


#include <common.h>


HRESULT
Spork::_LaunchUI(void)
{
  HRESULT hr      = S_OK;
  int     nResult = 1;
  MSG     msg     = {0};

  if( _InitializeUI() )
  {
    LogTrace(L"launching ui");

    while( (nResult != 0) && (nResult != -1) )
    {
      nResult = GetMessage(&msg, NULL, 0,0);

      if( !IsDialogMessage(m_DlgWindows.Dialog, &msg) )
      {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
      }
    }
  }
  else
  {
    LogTrace(L"ui initialization failed");
    hr = E_FAIL;
  }

  return hr;
}


BOOL
Spork::_InitializeUI(void)
{
  BOOL                 bRet = FALSE;
  RECT                 rDialog;
  RECT                 rScreen;
  INITCOMMONCONTROLSEX icex;

  icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
  icex.dwICC  = ICC_TREEVIEW_CLASSES | ICC_LISTVIEW_CLASSES;

  if( InitCommonControlsEx(&icex) )
  {
    m_DlgWindows.Dialog = CreateDialogParam(
                            m_hInst,
                            MAKEINTRESOURCE(IDD_SPORK),
                            0,
                            DlgProc,
                            (LPARAM) this
                            );
    
    if( m_DlgWindows.Dialog )
    {
      GetWindowRect(GetDesktopWindow(), &rScreen);
      GetWindowRect(m_DlgWindows.Dialog, &rDialog);

      MoveWindow(
        m_DlgWindows.Dialog,
        ((rScreen.right / 2) - (rDialog.right / 2)),
        ((rScreen.bottom / 2) - (rDialog.bottom /2)),
        rDialog.right,
        rDialog.bottom,
        FALSE
        );

      ShowWindow(m_DlgWindows.Dialog, SW_SHOWDEFAULT);
      bRet = TRUE;
    }
  }
  
  return bRet;
}


BOOL
Spork::_BrowseForScriptFile(void)
{
  BOOL         bSelected = FALSE;
  OPENFILENAME ofn       = {0};

  // if we're running on win9x, we need to use a top-secret, super-special
  // value for the struct size. *yawn*
  if( IsRunningOnNT() )
  {
    ofn.lStructSize = sizeof(OPENFILENAME);
  }
  else
  {
    ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
  }

  ofn.hwndOwner    = m_DlgWindows.Dialog;
  ofn.lpstrFile    = new WCHAR[MAX_PATH];
  ofn.nMaxFile     = MAX_PATH;
  ofn.lpstrFilter  = L"Script Files (js, vbs)\0*.js;*.vbs\0All Files\0*.*\0\0\0";
  ofn.nFilterIndex = 1;
  ofn.Flags        = OFN_DONTADDTORECENT | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;

  if( ofn.lpstrFile )
  {
    *ofn.lpstrFile = L'\0';

    if( GetOpenFileName(&ofn) )
    {
      SAFEDELETEBUF(m_wszScriptFile);
      m_wszScriptFile = ofn.lpstrFile;
      bSelected = TRUE;
    }
    else
    {
      SAFEDELETEBUF(ofn.lpstrFile);
    }
  }

  return bSelected;
}


//-----------------------------------------------------------------------------
// dialog window procedure
//-----------------------------------------------------------------------------
INT_PTR
Spork::_DlgProc(
  HWND   hwnd,
  UINT   uMsg,
  WPARAM wParam,
  LPARAM lParam
  )
{
  switch( uMsg )
  {
    case WM_INITDIALOG :
      {
        m_DlgWindows.ScriptFile = GetDlgItem(hwnd, IDT_SCRIPTPATH);
        m_DlgWindows.TreeView   = GetDlgItem(hwnd, IDC_SCRIPTTREE);

        if( m_wszScriptFile )
        {
          SetWindowText(
            m_DlgWindows.ScriptFile,
            m_wszScriptFile
            );

          SetFocus(
            GetDlgItem(hwnd, IDB_RUN)
            );
        }
        else
        {
          SetFocus(m_DlgWindows.ScriptFile);
        }
      }
      return 0L;

    case WM_CLOSE :
      {
        wParam = IDB_QUIT;
      }

    case WM_COMMAND :
      {
        switch( LOWORD(wParam) )
        {
          case IDB_BROWSE :
            {
              if( _BrowseForScriptFile() )
              {
                SetWindowText(
                  m_DlgWindows.ScriptFile,
                  m_wszScriptFile
                  );

                SendMessage(
                  m_DlgWindows.ScriptFile,
                  EM_SETMODIFY,
                  (WPARAM) FALSE,
                  (LPARAM) 0
                  );
              }
            }
            break;

          case IDB_RUN :
            {
              _RunClicked();
            }
            break;

          case IDB_CONFIG :
            {
              _ConfigClicked();
            }
            break;

          case IDB_QUIT :
            {
              DestroyWindow(m_DlgWindows.Dialog);
              PostQuitMessage(0);
              m_DlgWindows.Dialog = NULL;
            }
            return 1L;
        }
      }
      return 0L;

    default : return 0L;
  }
}


//-----------------------------------------------------------------------------
// handlers for dialog events
//-----------------------------------------------------------------------------
INT_PTR
Spork::_RunClicked(void)
{
  HRESULT     hr      = S_OK;
  HANDLE      hThread = NULL;
  PSCRIPTINFO psi     = NULL;

  //
  // first check to see if someone updated the script path manually.
  //
  if( SendMessage(m_DlgWindows.ScriptFile, EM_GETMODIFY, (WPARAM) 0, (LPARAM) 0) )
  {
    SAFEDELETEBUF(m_wszScriptFile);

    m_wszScriptFile = new WCHAR[MAX_PATH];

    if( m_wszScriptFile )
    {
      GetWindowText(m_DlgWindows.ScriptFile, m_wszScriptFile, MAX_PATH);

      if( !wcslen(m_wszScriptFile) )
      {
        SAFEDELETEBUF(m_wszScriptFile);
      }
    }
    else
    {
      THROWMEMALERT(L"WCHAR[MAX_PATH]");
    }
  }

  //
  // now run the script, if one has been selected.
  //
  if( m_wszScriptFile )
  {
    psi = new SCRIPTINFO;

    if( psi )
    {
      psi->bIsFork         = FALSE;
      psi->bstrChildParams = NULL;
      psi->htParent        = TVI_ROOT;
      psi->pSpork          = this;
      hr                   = CreateScriptThread(psi, &hThread);

      if( SUCCEEDED(hr) )
      {        
        SAFECLOSE(hThread);
      }
      else
      {
        SAFEDELETE(psi);
      }
    }
    else
    {
      THROWMEMALERT(L"SCRIPTINFO");
    }
  }
  else
  {
    Alert(FALSE, L"Please select a script to run.");
  }

  return 0L;
}


INT_PTR
Spork::_ConfigClicked(void)
{
  DWORD           error = ERROR_SUCCESS;
  PROPSHEETHEADER psh   = {0};
  PROPSHEETPAGE   psp[2];

  memset(&psp, 0, sizeof(PROPSHEETPAGE) * 2);

  // initialize the propertysheet struct
  psh.dwSize     = sizeof(PROPSHEETHEADER);
  psh.dwFlags    = PSH_NOCONTEXTHELP | PSH_PROPSHEETPAGE | PSH_USEICONID;
  psh.hwndParent = m_DlgWindows.Dialog;
  psh.hInstance  = m_hInst;
  psh.pszIcon    = MAKEINTRESOURCE(IDI_PROFILE);
  psh.pszCaption = L"Spork Configuration";
  psh.nPages     = (sizeof(psp) / sizeof(PROPSHEETPAGE));
  psh.nStartPage = 0;
  psh.ppsp       = (LPCPROPSHEETPAGE) &psp;

  // initialize the "profiles" page
  psp[0].dwSize      = sizeof(PROPSHEETPAGE);
  psp[0].pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_PROFILE);
  psp[0].hInstance   = m_hInst;
  psp[0].pfnDlgProc  = ProfilePropPageProc;
  psp[0].lParam      = (LPARAM) this;

  // initialize the "debug" page
  psp[1].dwSize      = sizeof(PROPSHEETPAGE);
  psp[1].pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_DEBUG);
  psp[1].hInstance   = m_hInst;
  psp[1].pfnDlgProc  = DebugPropPageProc;
  psp[1].lParam      = (LPARAM) this;

  if( !PropertySheet(&psh) )
  {
    error = GetLastError();
  }

  return error;
}


//-----------------------------------------------------------------------------
// friend dialog proc, delegates to private class member
//-----------------------------------------------------------------------------
INT_PTR
CALLBACK
DlgProc(
  HWND   hwnd,
  UINT   uMsg,
  WPARAM wParam,
  LPARAM lParam
  )
{
  static PSPORK ps = NULL;

  if( !ps )
  {
    switch( uMsg )
    {
      case WM_INITDIALOG :
        {
          ps = (PSPORK) lParam;
        }
        break;
      
      default : return FALSE;
    }
  }

  return ps->_DlgProc(hwnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\servercommands.cpp ===
///////////////////////////////////////////////////////////////////////////
// File:  WinHttpStressScheduler.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	ServerCommands.cpp: implementation of the ServerCommands class.
//	This class is used to retrieve and act on command from the server.
//
// History:
//	02/08/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//

//
// Project headers
//
#include "ServerCommands.h"
#include "NetworkTools.h"


//////////////////////////////////////////////////////////////////////
// Globals and statics
//////////////////////////////////////////////////////////////////////

HANDLE				g_hQueryServerForCommands;	// Handle for the thread that queries the server for commands
CRITICAL_SECTION	g_csServerCommandsVars;		// For protecting CommandServer private member vars. Used in the QueryServerForCommands_ThreadProc.

extern ServerCommands g_objServerCommands;		// Declared in WinHttpStressScheduler.cpp


////////////////////////////////////////////////////////////
// Function:  QueryServerForCommands_ThreadProc(LPVOID)
//
// Purpose:
//	This method sends a request to the command server for instructions
//	and saves them in the public vars of ServerCommands.
//
////////////////////////////////////////////////////////////
DWORD
WINAPI
QueryServerForCommands_ThreadProc(
	LPVOID lpParam	// [IN] thread proc param
)
{
	BOOL			bResult		= TRUE;
	HINTERNET		hRoot		= NULL;
	HINTERNET		hSession	= NULL;
	HINTERNET		hRequest	= NULL;
	URL_COMPONENTSW	urlComponents;

	// Allocate space for URL components
	ZeroMemory(&urlComponents, sizeof(urlComponents));

	urlComponents.dwSchemeLength	= MAX_PATH;
	urlComponents.lpszScheme		= new TCHAR[MAX_PATH];

	urlComponents.dwHostNameLength  = MAX_PATH;
	urlComponents.lpszHostName		= new TCHAR[MAX_PATH];

	urlComponents.dwUrlPathLength	= MAX_PATH;
	urlComponents.lpszUrlPath		= new TCHAR[MAX_PATH];

	urlComponents.dwExtraInfoLength = MAX_PATH;
	urlComponents.lpszExtraInfo		= new TCHAR[MAX_PATH];
	
	urlComponents.dwUserNameLength	= MAX_PATH;
	urlComponents.lpszUserName		= new TCHAR[MAX_PATH];

	urlComponents.dwPasswordLength	= MAX_PATH;
	urlComponents.lpszPassword		= new TCHAR[MAX_PATH];
	
	urlComponents.nPort				= 0;

	urlComponents.dwStructSize		= sizeof(URL_COMPONENTSW);


	// crack the Command Server URL to be used later
	if (!WinHttpCrackUrl(
			g_objServerCommands.Get_CommandServerURL(),
			_tcslen(g_objServerCommands.Get_CommandServerURL()),
			ICU_ESCAPE,
			&urlComponents)
		)
	{
		bResult = FALSE;
		goto Exit;
	}

	hRoot = WinHttpOpen(
		STRESS_SCHEDULER_USER_AGENT,
		WINHTTP_ACCESS_TYPE_NO_PROXY,
		NULL,
		NULL,
		0);

	if (!hRoot)
	{
		bResult = FALSE;
		goto Exit;
	}

	hSession = WinHttpConnect(
		hRoot,
		urlComponents.lpszHostName,
		// If the URL in urlComponents uses standard HTTP or HTTPS ports then use INTERNET_DEFAULT_PORT. Otherwise use the non-standard port gleaned from the URL.
		((urlComponents.nPort == 80) || (urlComponents.nPort == 443)) ? INTERNET_DEFAULT_PORT : urlComponents.nPort,
		0);
	
	if (!hSession)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Build a full URL with path and querystring
	TCHAR szFullPath[MAX_PATH*2];

	ZeroMemory(szFullPath, sizeof(szFullPath));
	_tcsncpy(szFullPath, urlComponents.lpszUrlPath, urlComponents.dwUrlPathLength);
	//szFullPath[urlComponents.dwUrlPathLength] = _T('\0');
	_tcsncat(szFullPath, urlComponents.lpszExtraInfo, urlComponents.dwExtraInfoLength);

	hRequest = WinHttpOpenRequest(
		hSession,
		_T("POST"),
		szFullPath,
		NULL,
		NULL,
		NULL,
		// if the URL in urlComponents uses HTTPS then pass in WINHTTP_FLAG_SECURE to this param. Otherwise, 0.
		(0 == _tcsnicmp(urlComponents.lpszScheme, _T("https"), 5)) ? WINHTTP_FLAG_SECURE : 0);

	if (!hRequest)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Set reasonable timeouts just in case
	if (!WinHttpSetTimeouts(hRequest, 5000, 5000, 5000, 5000))
	{
		bResult = FALSE;
		goto Exit;
	}

	// Get the computer name and send it in a POST request
	LPSTR	szPost, szMachineName;
	
	szPost			= new CHAR[MAX_PATH];
	szMachineName	= new CHAR[MAX_PATH];


	GetEnvironmentVariableA("COMPUTERNAME", szMachineName, MAX_PATH);
	strcpy(szPost, FIELDNAME__USERINFO_MACHINENAME);
	strcat(szPost, szMachineName);

	bResult = WinHttpSendRequest(
		hRequest,
		_T("Content-Type: application/x-www-form-urlencoded"),
		-1L, 
		szPost,
		strlen(szPost),
		strlen(szPost),
		0);


	delete [] szPost;
	delete [] szMachineName;
	szPost			= NULL;
	szMachineName	= NULL;

	if (!WinHttpReceiveResponse(hRequest, NULL))
	{
		bResult = FALSE;
		goto Exit;
	}



	TCHAR	szBuffer[MAX_URL];
	DWORD	dwBufferSize, dwIndex;


	// get all command headers that we're interested in.
	// make sure there are no pending operations on member vars (pServerCommands->Set_* functions)
	EnterCriticalSection(&g_csServerCommandsVars);


	// *********************************
	// **** COMMANDHEADER__EXIT: Exit if header is present, else continue.
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__EXIT, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_ExitStress(TRUE);
	else
		g_objServerCommands.Set_ExitStress(FALSE);


	// *********************************
	// **** COMMANDHEADER__WINHTTP_DLL_URL: valid values: Valid URL
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__WINHTTP_DLL_URL, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_WinHttpDllURL(szBuffer, dwBufferSize);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__WINHTTP_PDB_URL: valid values: Valid URL
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__WINHTTP_PDB_URL, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_WinHttpPDBURL(szBuffer, dwBufferSize);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__WINHTTP_SYM_URL: valid values: Valid URL
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__WINHTTP_SYM_URL, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_WinHttpSYMURL(szBuffer, dwBufferSize);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__COMMANDSERVER_URL: valid values: Valid URL
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__COMMANDSERVER_URL, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_CommandServerURL(szBuffer, dwBufferSize);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__BEGIN_TIME_HOUR: valid values: Valid string from 0-23
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__BEGIN_TIME_HOUR, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_TimeStressBegins(szBuffer, NULL);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__BEGIN_TIME_MINUTE: valid values: Valid string from 0-59
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__BEGIN_TIME_MINUTE, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_TimeStressBegins(NULL, szBuffer);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__END_TIME_HOUR: valid values: Valid string from 0-23
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__END_TIME_HOUR, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_TimeStressEnds(szBuffer, NULL);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__END_TIME_MINUTE: valid values: Valid string from 0-59
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__END_TIME_MINUTE, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_TimeStressEnds(NULL, szBuffer);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__RUN_FOREVER: valid values: doesn't matter. As long as header is present it gets sent
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__RUN_FOREVER, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_RunForever(TRUE);
	else
		g_objServerCommands.Set_RunForever(FALSE);


	// *********************************
	// **** COMMANDHEADER__UPDATE_INTERVAL: valid values: Valid string in INTERNET_RFC1123 format
	DWORD			dwTimeOut;
	dwTimeOut		= 0;
	dwIndex			= 0;
	dwBufferSize	= sizeof(DWORD);
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM | WINHTTP_QUERY_FLAG_NUMBER, COMMANDHEADER__UPDATE_INTERVAL, &dwTimeOut, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_CommandServerUpdateInterval(dwTimeOut);
	else
		bResult = FALSE;



	// *********************************
	// *********************************
	// **** Query commands for building stress Instance objects
	// ****
	// **** COMMANDHEADER__STRESS_EXE_URL: valid values: Valid URL
	DWORD	dwStressExeID;
	DWORD	dwPageHeapCommandIndex,
			dwUMDHCommandIndex,
			dwStressPDBIndex,
			dwStressSYMIndex,
			dwStressMemDmpPathIndex,
			dwStressExeIDIndex;
	LPTSTR	szPageheapCommand,
			szUMDHCommand,
			szStressPDB_URL,
			szStressSYM_URL,
			szStressMemDmpPath,
			szStressExeID;

	szPageheapCommand	= new TCHAR[MAX_PATH];
	szUMDHCommand		= new TCHAR[MAX_PATH];
	szStressPDB_URL		= new TCHAR[MAX_STRESS_URL];
	szStressSYM_URL		= new TCHAR[MAX_STRESS_URL];
	szStressMemDmpPath	= new TCHAR[MAX_PATH];
	szStressExeID		= new TCHAR[MAX_PATH];

	if (!g_objServerCommands.IsStressRunning())
	{
		// free all old StressExeURLs first - we're replacing it with new URLs anyway
		g_objServerCommands.Clear_StressExeURLs();

		dwIndex					= 0;
		dwStressExeIDIndex		= 0;
		dwPageHeapCommandIndex	= 0;
		dwUMDHCommandIndex		= 0;
		dwStressPDBIndex		= 0;
		dwStressSYMIndex		= 0;
		dwStressMemDmpPathIndex	= 0;
		dwBufferSize			= MAX_URL;
		ZeroMemory(szBuffer, sizeof(szBuffer));

		while (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_EXE_URL, szBuffer, &dwBufferSize, &dwIndex))
		{
			// *************************************
			// *************************************
			// ** COMMANDHEADER__MEMORY_DUMP_PATH: A valid path
			ZeroMemory(szStressMemDmpPath, MAX_PATH);
			dwBufferSize	= MAX_PATH;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__MEMORY_DUMP_PATH, szStressMemDmpPath, &dwBufferSize, &dwStressMemDmpPathIndex);


			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_PDB_URL if there is one
			// **
			ZeroMemory(szStressPDB_URL, MAX_STRESS_URL);
			dwBufferSize	= MAX_STRESS_URL;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_PDB_URL, szStressPDB_URL, &dwBufferSize, &dwStressPDBIndex);


			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_SYM_URL if there is one
			// **
			ZeroMemory(szStressSYM_URL, MAX_STRESS_URL);
			dwBufferSize	= MAX_STRESS_URL;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_SYM_URL, szStressSYM_URL, &dwBufferSize, &dwStressSYMIndex);


			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_EXE_PAGEHEAP if there is one
			// **
			ZeroMemory(szPageheapCommand, MAX_PATH);
			dwBufferSize	= MAX_PATH;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_EXE_PAGEHEAP, szPageheapCommand, &dwBufferSize, &dwPageHeapCommandIndex);

			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_EXE_UMDH if there is one
			// **
			ZeroMemory(szUMDHCommand, MAX_PATH);
			dwBufferSize	= MAX_PATH;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_EXE_UMDH, szUMDHCommand, &dwBufferSize, &dwUMDHCommandIndex);
			

			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_EXE_INSTANCEID
			// For each COMMANDHEADER__STRESS_EXE_URL, there must be an index for the stress instance from the StressADMIN DB table.
			// This identifies the stressinstance run. The test case (stressinstance) WILL NOT be added and run without an ID number.
			ZeroMemory(szStressExeID, MAX_PATH);
			dwBufferSize	= MAX_PATH;

			if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_EXE_INSTANCEID, szStressExeID, &dwBufferSize, &dwStressExeIDIndex))
			{
				// convert header ID string to a DWORD
				dwStressExeID = _ttol(szStressExeID);

				// only add valid stressInstances with valid ID's
				if (0 < dwStressExeID)
				{
					g_objServerCommands.Create_StressInstance(
						dwStressExeID,
						szPageheapCommand,
						szUMDHCommand,
						szStressPDB_URL,
						szStressSYM_URL,
						szStressMemDmpPath,
						szBuffer);

					dwBufferSize = MAX_URL;
					ZeroMemory(szBuffer, MAX_URL);
				}
			}
		}
	}

	delete [] szPageheapCommand;
	delete [] szUMDHCommand;
	delete [] szStressMemDmpPath;
	delete [] szStressPDB_URL;
	delete [] szStressSYM_URL;
	delete [] szStressExeID;


	// *********************************
	// **** COMMANDHEADER__ABORT: Abort the stress instance running specified by this header.
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	while (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__ABORT, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.AbortStressInstance(_ttol(szBuffer));


	LeaveCriticalSection(&g_csServerCommandsVars);


Exit:
	if (hRequest)
		WinHttpCloseHandle(hRequest);

	if (hSession)
		WinHttpCloseHandle(hSession);

	if (hRoot)
		WinHttpCloseHandle(hRoot);

	delete [] urlComponents.lpszScheme;
	delete [] urlComponents.lpszHostName;
	delete [] urlComponents.lpszUrlPath;
	delete [] urlComponents.lpszExtraInfo;
	delete [] urlComponents.lpszPassword;
	delete [] urlComponents.lpszUserName;

	ExitThread(bResult);
}




// *******************************************************************
// *******************************************************************
// ****
// **** ServerCommands class member functions
// ****

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

ServerCommands::ServerCommands()
{
	m_dwCommandServerUpdateInternval	= STRESS_COMMAND_SERVER_UPDATE_INTERVAL;
	m_bExit								= FALSE;
	m_dwStressInstanceIterator			= NULL;
	g_hQueryServerForCommands			= NULL;

	m_szCommandServerURL				= new TCHAR[MAX_STRESS_URL];
	m_szCommandServerResultsURL			= new TCHAR[MAX_STRESS_URL];
	m_szWinHttpDLL_DownloadURL			= new TCHAR[MAX_STRESS_URL];
	m_szWinHttpPDB_DownloadURL			= new TCHAR[MAX_STRESS_URL];
	m_szWinHttpSYM_DownloadURL			= new TCHAR[MAX_STRESS_URL];
	m_szWinHttpDLL_FileName				= new TCHAR[MAX_PATH];
	m_szStressSchedulerCurrentDirectory	= new TCHAR[MAX_PATH];
	m_szClientMachineName				= new CHAR[MAX_PATH];

	ZeroMemory(m_szCommandServerURL,				MAX_STRESS_URL);
	ZeroMemory(m_szCommandServerResultsURL,			MAX_STRESS_URL);
	ZeroMemory(m_szWinHttpDLL_DownloadURL,			MAX_STRESS_URL);
	ZeroMemory(m_szWinHttpPDB_DownloadURL,			MAX_STRESS_URL);
	ZeroMemory(m_szWinHttpSYM_DownloadURL,			MAX_STRESS_URL);
	ZeroMemory(m_szWinHttpDLL_FileName,				MAX_PATH);
	ZeroMemory(m_szStressSchedulerCurrentDirectory, MAX_PATH);
	ZeroMemory(m_szClientMachineName,				MAX_PATH);

	// initilize start/end times to -1 so we know that
	// there are not valid time and we'll skip the Begin/End stress time check
	// until we get real values from the command server
	m_iTimeStressBeginsHour		= -1;
	m_iTimeStressBeginsMinute	= -1;
	m_iTimeStressEndsHour		= -1;
	m_iTimeStressEndsMinute		= -1;
	m_bRunForever				= 0;

	// Set default URLs
	wcsncpy(m_szCommandServerURL, STRESS_COMMAND_SERVER_URL, sizeof(STRESS_COMMAND_SERVER_URL));
	wcsncpy(m_szCommandServerResultsURL, STRESS_COMMAND_SERVER_RESULTS_URL, sizeof(STRESS_COMMAND_SERVER_RESULTS_URL));

	// Get the current working directory
	GetCurrentDirectory(MAX_PATH, m_szStressSchedulerCurrentDirectory);

	// Get the client's machine name
	GetEnvironmentVariableA("COMPUTERNAME", m_szClientMachineName, MAX_PATH);

	InitializeCriticalSection(&g_csServerCommandsVars);

	// Tell the client that we are alive and also send system info
	RegisterClient();

}


ServerCommands::~ServerCommands()
{
	DWORD	dwThreadExitCode	= 0;

	// LOGLOG: stressScheduler has exited
	NetworkTools__SendLog(FIELDNAME__LOGTYPE_EXIT, "WinHttpStressScheduler has exited.", NULL, NULL);

	// Shut down QueryServer thread
	GetExitCodeThread(g_hQueryServerForCommands, &dwThreadExitCode);

	if (STILL_ACTIVE == dwThreadExitCode)
		WaitForSingleObject(g_hQueryServerForCommands, INFINITE);

	// free allocated memory for URLs
	Clear_StressExeURLs();

	// Free our handles
	CloseHandle(g_hQueryServerForCommands);
	DeleteCriticalSection(&g_csServerCommandsVars);

	delete [] m_szCommandServerURL;
	delete [] m_szCommandServerResultsURL;
	delete [] m_szWinHttpDLL_DownloadURL;
	delete [] m_szWinHttpPDB_DownloadURL;
	delete [] m_szWinHttpSYM_DownloadURL;
	delete [] m_szWinHttpDLL_FileName;
	delete [] m_szStressSchedulerCurrentDirectory;
	delete [] m_szClientMachineName;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::GetCurrentWorkingDirectory()
//
// Purpose:
//	Returns string containing the current working directory for
//	this application.
//
////////////////////////////////////////////////////////////
LPTSTR
ServerCommands::Get_CurrentWorkingDirectory()
{
	return m_szStressSchedulerCurrentDirectory;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_ClientMachineName()
//
// Purpose:
//	Returns string containing the machine's NETBIOS name
//
////////////////////////////////////////////////////////////
LPSTR
ServerCommands::Get_ClientMachineName()
{
	return m_szClientMachineName;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::QueryServerForCommands()
//
// Purpose:
//	This method sends a request to the command server for instructions
//	and saves them in our private vars. 
//
////////////////////////////////////////////////////////////
ServerCommands::QueryServerForCommands()
{
	BOOL	bResult				= TRUE;
	DWORD	dwThreadID			= 0;
	DWORD	dwTimeOut			= 0;
	DWORD	dwThreadExitCode	= 0;

	// See if thread is still active before spinning off a new one
	GetExitCodeThread(g_hQueryServerForCommands, &dwThreadExitCode);

	if (STILL_ACTIVE == dwThreadExitCode)
	{
		// wait for existing thread to finish
		dwTimeOut = 0;
		dwTimeOut = WaitForSingleObject(g_hQueryServerForCommands, 500);

		if (WAIT_TIMEOUT == dwTimeOut)
			bResult = FALSE;
	}
	else
	{
		// free handle for previous thread
		CloseHandle(g_hQueryServerForCommands);

		// spin off thread to query server
		g_hQueryServerForCommands = NULL;
		g_hQueryServerForCommands = CreateThread(NULL, 0, QueryServerForCommands_ThreadProc, (LPVOID) this, 0, &dwThreadID);

		if (!g_hQueryServerForCommands)
			bResult = FALSE;
	}

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Download_WinHttpDLL()
//
// Purpose:
//	Downloads the test DLL and symbols.
//
////////////////////////////////////////////////////////////
BOOL ServerCommands::Download_WinHttpDLL()
{
	BOOL	bResult				= TRUE;
	LPTSTR	szSymbolFileName	= new TCHAR[MAX_PATH];
	LPTSTR	szBuffer			= new TCHAR[MAX_PATH];


	// ************************
	// ************************
	// ** download the file to the system32 directory
	// **
	if (!GetSystemDirectory(szBuffer, MAX_PATH))
	{
		bResult = FALSE;
		goto Exit;
	}

	// download DLL if needed
	if (_tcsclen(m_szWinHttpDLL_DownloadURL) > 0)
		bResult = 
			NetworkTools__URLDownloadToFile(
			m_szWinHttpDLL_DownloadURL,
			szBuffer,
			m_szWinHttpDLL_FileName);

	if (bResult)
	{
		// download PDB file if needed
		if (_tcsclen(m_szWinHttpPDB_DownloadURL) > 0)
		{
			NetworkTools__GetFileNameFromURL(m_szWinHttpPDB_DownloadURL, szSymbolFileName, MAX_PATH);

			if (NetworkTools__URLDownloadToFile(m_szWinHttpPDB_DownloadURL, szBuffer, szSymbolFileName))
				NetworkTools__SendLog(FIELDNAME__LOGTYPE_SUCCESS, "PDB symbol file downloaded successfully.", NULL, 0);
			else
				NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "PDB symbol file failed to downloaded.", NULL, 0);
		}


		// download sym file if needed
		if (_tcsclen(m_szWinHttpSYM_DownloadURL) > 0)
		{
			NetworkTools__GetFileNameFromURL(m_szWinHttpSYM_DownloadURL, szSymbolFileName, MAX_PATH);

			if (NetworkTools__URLDownloadToFile(m_szWinHttpSYM_DownloadURL, szBuffer, szSymbolFileName))
				NetworkTools__SendLog(FIELDNAME__LOGTYPE_SUCCESS, "SYM symbol file downloaded successfully.", NULL, 0);
			else
				NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "SYM symbol file failed to downloaded.", NULL, 0);
		}
	}

	// if failed to download DLL, it's probably in use. We'll try to regsvr32 it anyways if it's there.

	// ************************
	// ************************
	// ** regsvr32'ed the dll just downloaded
	// **
	HINSTANCE hLib;
	
	hLib = LoadLibrary(m_szWinHttpDLL_FileName);

	if (hLib < (HINSTANCE)HINSTANCE_ERROR)
	{
		// unable to load the DLL;
		bResult = FALSE;
		goto Exit;
	}

	// **********************
	// **********************
	// ** Register the DLL
	typedef VOID (CALLBACK* LPFNDLLFUNC1)();
	LPFNDLLFUNC1 lpDllEntryPoint;

	// Find the entry point.
	(FARPROC&)lpDllEntryPoint = GetProcAddress(hLib, "DllRegisterServer");

	if (lpDllEntryPoint != NULL)
		(*lpDllEntryPoint)();
	else
	{
		//unable to locate entry point - regsvr failed
		bResult = FALSE;
	}


Exit:
	if (bResult)
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_INFORMATION, "winhttp5.dll downloaded and registered successfully.", NULL, 0);

	delete [] szSymbolFileName;
	delete [] szBuffer;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_RunForever(BOOL)
//
// Purpose:
//	Pass in TRUE to run forever ignoring begin/end time, FALSE not to.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_RunForever(
	BOOL bRunForever	// [IN] TRUE to run forever ignoring begin/end time, FALSE not to.
)
{
	m_bRunForever = bRunForever;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_ExitStress(BOOL)
//
// Purpose:
//	Pass in TRUE to exit stress as soon as possible and FALSE
//	not to.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_ExitStress(
	BOOL bExitStress	// [IN] TRUE to exit stress, FALSE not to.
)
{
	m_bExit = bExitStress;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_WinHttpDllURL(LPTSTR, DWORD)
//
// Purpose:
//	Pass in an URL and its size and to get the WinHttp DLL from.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_WinHttpDllURL(
	LPTSTR szBuffer,	// [IN] string buffer containing URL to the WINHTTP DLL
	DWORD dwBufferSize	// [IN] size of the szBuffer in TCHARs
)
{
	_tcscpy(m_szWinHttpDLL_DownloadURL, szBuffer);

	// Get the full DLL filename from the URL
	NetworkTools__GetFileNameFromURL(m_szWinHttpDLL_DownloadURL, m_szWinHttpDLL_FileName, MAX_PATH);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_WinHttpPDBURL(LPTSTR, DWORD)
//
// Purpose:
//	Pass in an URL and its size and to get the WinHttp PDB file from.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_WinHttpPDBURL(
	LPTSTR szBuffer,	// [IN] string buffer containing URL to the WINHTTP DLL
	DWORD dwBufferSize	// [IN] size of the szBuffer in TCHARs
)
{
	_tcscpy(m_szWinHttpPDB_DownloadURL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_WinHttpSYMURL(LPTSTR, DWORD)
//
// Purpose:
//	Pass in an URL and its size and to get the WinHttp SYM file from.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_WinHttpSYMURL(
	LPTSTR szBuffer,	// [IN] string buffer containing URL to the WINHTTP DLL
	DWORD dwBufferSize	// [IN] size of the szBuffer in TCHARs
)
{
	_tcscpy(m_szWinHttpSYM_DownloadURL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_CommandServerURL(LPTSTR)
//
// Purpose:
//	Pass in a timeout value in milliseconds to query the 
//	Command Server for commands.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_CommandServerURL(
	LPTSTR szBuffer,	// [IN] string buffer containing URL to the WINHTTP DLL
	DWORD dwBufferSize	// [IN] size of the szBuffer in TCHARs
)
{
	_tcscpy(m_szCommandServerURL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_CommandServerUpdateInterval(DWORD)
//
// Purpose:
//	Pass in a timeout value in milliseconds to query the 
//	Command Server for commands.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_CommandServerUpdateInterval(
	DWORD dwUpdateInterval	// [IN] time to wait before pinging the Command Server in milliseconds
)
{
	// server update interval must be at least greater than the minimum timeout
	if (STRESS_COMMAND_SERVER_MINIMUM_UPDATE_INTERVAL < dwUpdateInterval &&
		STRESS_COMMAND_SERVER_MAXIMUM_UPDATE_INTERVAL > dwUpdateInterval)
		m_dwCommandServerUpdateInternval = dwUpdateInterval;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_TimeStressBegins(DWORD, DWORD)
//
// Purpose:
//	Pass in a time string to begin stress in 24 hour time.
//	Takes two parameters to set the hour and minute. A parameter
//	will be ignored if NULL.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_TimeStressBegins(
	LPTSTR szHour,	// [IN] 0-23 parameter ignored if < 0
	LPTSTR szMinute	// [IN] 0-59 parameter ignored if < 0
)
{
	if (szHour)
		m_iTimeStressBeginsHour = _ttoi(szHour);

	if (szMinute)
		m_iTimeStressBeginsMinute = _ttoi(szMinute);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_TimeStressEnds(DWORD, DWORD)
//
// Purpose:
//	Pass in a time string to end stress in 24 hour time.
//	Takes two parameters to set the hour and minute. A parameter
//	will be ignored if NULL.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_TimeStressEnds(
	LPTSTR szHour,	// [IN] 0-23 parameter ignored if < 0
	LPTSTR szMinute	// [IN] 0-59 parameter ignored if < 0
)
{
	if (szHour)
		m_iTimeStressEndsHour = _ttoi(szHour);

	if (szMinute)
		m_iTimeStressEndsMinute = _ttoi(szMinute);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Create_StressInstance(LPTSTR)
//
// Purpose:
//	Pass in an URL and its size and it will be added to the 
//  m_arStressInstanceList list. There is no limit on the number of
//	URLs that can be added.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Create_StressInstance(
	DWORD	dwStressInstanceID,	// [IN] ID from the stressAdmin DB identifying this stressInstance
	LPTSTR	szPageHeapCommand,	// [IN] string buffer containing the pageheap command line
	LPTSTR	szUMDHCommand,		// [IN] string buffer containing the UMDH command line
	LPTSTR	szPDB_URL,			// [IN] string buffer containing URL to the stress EXE's PDB file
	LPTSTR	szSYM_URL,			// [IN] string buffer containing URL to the stress EXE's SYM file
	LPTSTR	szMemDumpPath,		// [IN] string buffer containing path to create memory dump files
	LPTSTR	szEXE_URL			// [IN] string buffer containing URL to the stress EXE
)
{
	PSTRESSINSTANCE pStressInstance = NULL;

	// verify params just in case
	if (!szEXE_URL)
		return;

	// allocate memory for the object and put it in the list
	pStressInstance = new StressInstance;

	pStressInstance->Set_UMDHCommands(szUMDHCommand);
	pStressInstance->Set_PageHeapCommands(szPageHeapCommand);
	pStressInstance->Set_StressExeID(dwStressInstanceID);
	pStressInstance->Set_StressExeURL(szEXE_URL);
	pStressInstance->Set_StressExeMemoryDumpPath(szMemDumpPath);
	pStressInstance->Set_StressExePdbURL(szPDB_URL);
	pStressInstance->Set_StressExeSymURL(szSYM_URL);

	m_arStressInstanceList.push_back(pStressInstance);
	m_dwStressInstanceIterator = m_arStressInstanceList.begin();
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Clear_StressExeURLs()
//
// Purpose:
//	Frees memory from the m_arStressExeList vector.
//
// Called by: QueryServerForCommands_ThreadProc and ~ServerCommands
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Clear_StressExeURLs()
{
	// don't want to delete StressInstances if it's still running
	if (IsStressRunning())
		return;

/*
	// walk the list and delete from the front to back
	while (!m_arStressInstanceList.empty())
		m_arStressInstanceList.erase(m_arStressInstanceList.begin());
*/

	StressInstance *pStressInstance = NULL;

	for (int iIndex=0; iIndex < m_arStressInstanceList.size(); iIndex++)
	{
		pStressInstance = m_arStressInstanceList[iIndex];
		m_arStressInstanceList.erase(&m_arStressInstanceList[iIndex]);
		delete [] pStressInstance;
	}

	m_dwStressInstanceIterator = NULL;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_CommandServerUpdateInterval()
//
// Purpose:
//	Returns the current setting for the Command Server Update
//	interval.
//
////////////////////////////////////////////////////////////
DWORD
ServerCommands::Get_CommandServerUpdateInterval()
{
	if (STRESS_COMMAND_SERVER_MINIMUM_UPDATE_INTERVAL < m_dwCommandServerUpdateInternval &&
		STRESS_COMMAND_SERVER_MAXIMUM_UPDATE_INTERVAL > m_dwCommandServerUpdateInternval)
		return m_dwCommandServerUpdateInternval;
	else
		return STRESS_COMMAND_SERVER_UPDATE_INTERVAL;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::BeginStress()
//
// Purpose:
//	Queries for commands then starts the StressInstance objects.
//
////////////////////////////////////////////////////////////
void
ServerCommands::BeginStress()
{
	EnterCriticalSection(&g_csServerCommandsVars);

	if (!m_arStressInstanceList.empty() && !IsStressRunning())
	{
		// LOGLOG: Stress is beginning
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_BEGIN_STRESS, "Stress is beginning.", NULL, NULL);

		// first download and regsvr32 the winhttp dll and symbols
		Download_WinHttpDLL();

		for(int iIndex = 0; iIndex < m_arStressInstanceList.size(); iIndex++)
			m_arStressInstanceList[iIndex]->Begin();
	}
	else
	{
		// ping Command Server for list of stress EXE URLs.
		QueryServerForCommands();
	}

	LeaveCriticalSection(&g_csServerCommandsVars);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::EndStress()
//
// Purpose:
//	Ends stress and posts the results to the Command Server.
//
////////////////////////////////////////////////////////////
void
ServerCommands::EndStress()
{
	EnterCriticalSection(&g_csServerCommandsVars);

	if (!m_arStressInstanceList.empty())
	{
		if (IsStressRunning())
		{
			// LOGLOG: Stress is ending
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_END_STRESS, "Stress is ending.", NULL, NULL);
		}

		for (int iIndex = 0; iIndex <  m_arStressInstanceList.size(); iIndex++)
			m_arStressInstanceList[iIndex]->End();
	}

	// Remove the stress objects that already finished
	Clear_StressExeURLs();

	LeaveCriticalSection(&g_csServerCommandsVars);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::AbortStressInstance(DWORD)
//
// Purpose:
//	Aborts a all stress instances that recieved a server abort message.
//
// Called in:
//	QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::AbortStressInstance(DWORD dwAbortID)
{
	// EnterCriticalSection(&g_csServerCommandsVars);

	if (!m_arStressInstanceList.empty())
	{
		for (int iIndex = 0; iIndex <  m_arStressInstanceList.size(); iIndex++)
		{
			if (m_arStressInstanceList[iIndex]->Get_ID() == dwAbortID)
				m_arStressInstanceList[iIndex]->End();
		}
	}

	//LeaveCriticalSection(&g_csServerCommandsVars);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::IsStressRunning()
//
// Purpose:
//	Returns TRUE if any of the stressinstances is running. FALSE if not.
//
////////////////////////////////////////////////////////////
BOOL
ServerCommands::IsStressRunning()
{
	BOOL bIsRunning = FALSE;

	EnterCriticalSection(&g_csServerCommandsVars);

	if (!m_arStressInstanceList.empty())
	{
		for (int iIndex = 0; iIndex < m_arStressInstanceList.size(); iIndex++)
		{
			if (m_arStressInstanceList[iIndex]->IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
				bIsRunning = TRUE;
		}
	}

	LeaveCriticalSection(&g_csServerCommandsVars);

	return bIsRunning;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::IsTimeToBeginStress()
//
// Purpose:
//	TRUE if it's time to begin stress based on the time returned
//	from the Command Server. Will return TRUE if m_sysTimeStressBegins
//	is current or in the future. FALSE if not.
//
////////////////////////////////////////////////////////////
BOOL
ServerCommands::IsTimeToBeginStress()
{
	SYSTEMTIME	stCurrent, stBeginStress, stEndStress;
	FILETIME	ftCurrent, ftBeginStress, ftEndStress;
	BOOL		bResult = FALSE;

	EnterCriticalSection(&g_csServerCommandsVars);

	// always run stress now if server tells us to
	if (m_bRunForever)
	{
		bResult = TRUE;
		goto Exit;
	}


	// check to see if valid time values have been received. If not, then we always fail.
	if (
		m_iTimeStressBeginsHour < 0 || m_iTimeStressBeginsMinute < 0 ||
		m_iTimeStressEndsHour < 0 || m_iTimeStressEndsMinute < 0
		)
	{
		bResult = FALSE;
		goto Exit;
	}

	GetLocalTime(&stCurrent);
	GetLocalTime(&stBeginStress);
	GetLocalTime(&stEndStress);

	// use the hour and minute time that we got from the command server
	stBeginStress.wHour		= m_iTimeStressBeginsHour;
	stBeginStress.wMinute	= m_iTimeStressBeginsMinute;

	stEndStress.wHour		= m_iTimeStressEndsHour;
	stEndStress.wMinute		= m_iTimeStressEndsMinute;

	// convert to file time so we can compare
	SystemTimeToFileTime(&stCurrent, &ftCurrent);
	SystemTimeToFileTime(&stBeginStress, &ftBeginStress);
	SystemTimeToFileTime(&stEndStress, &ftEndStress);


	// If EndTime < BeginTime, then it means stress is running for
	// over a day so we have to add 24 hours to the end time.
	ULARGE_INTEGER	ulEndStress;
	ULONGLONG		ullNanoSecondsInAFreakingDay;

	ulEndStress.LowPart		= ftEndStress.dwLowDateTime;
	ulEndStress.HighPart	= ftEndStress.dwHighDateTime;

	// stress runs across two days so we wrap around one day
	ullNanoSecondsInAFreakingDay = 24 * 60;		// minutes in a day
	ullNanoSecondsInAFreakingDay *= 60;			// seconds in a day
	ullNanoSecondsInAFreakingDay *= 1000000000;	// number of nanoseconds in a day. 10^9 NS in a second
	ullNanoSecondsInAFreakingDay /= 100;		// The FILETIME structure is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601. 

	if (m_iTimeStressEndsHour < m_iTimeStressBeginsHour) 
	{
		// ********************
		// ********************
		// ** increase by 24 hours
		// **

		ulEndStress.QuadPart		 += ullNanoSecondsInAFreakingDay;

		// copy back to the original EndStress Date/Time
		ftEndStress.dwHighDateTime	= ulEndStress.HighPart;
		ftEndStress.dwLowDateTime	= ulEndStress.LowPart;

		FileTimeToSystemTime(&ftEndStress, &stEndStress);
	}
	else
	{
		// stress runs in the same day
		if ((m_iTimeStressEndsHour == m_iTimeStressBeginsHour) &&
			(m_iTimeStressEndsMinute <= m_iTimeStressBeginsMinute))
		{
			// if 7:30 to 7:20 - we wrap around one day.
			ulEndStress.QuadPart	+= ullNanoSecondsInAFreakingDay;

			// copy back to the original EndStress Date/Time
			ftEndStress.dwHighDateTime	= ulEndStress.HighPart;
			ftEndStress.dwLowDateTime	= ulEndStress.LowPart;

			FileTimeToSystemTime(&ftEndStress, &stEndStress);
		}
	}


	// Begin stress if:
	// (BeginTime <= CurrentTime <= EndTime)
	if ((0 <= CompareFileTime(&ftCurrent, &ftBeginStress)) && (0 <= CompareFileTime(&ftEndStress, &ftCurrent)))
		bResult = TRUE;
	else
		bResult = FALSE;

Exit:
	LeaveCriticalSection(&g_csServerCommandsVars);

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::IsTimeToExitStress()
//
// Purpose:
//	TRUE if it's time to end stress based on the COMMANDHEADER__EXIT headers
//	from the Command Server exists. FALSE if not.
//
////////////////////////////////////////////////////////////
BOOL
ServerCommands::IsTimeToExitStress()
{
	return m_bExit;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_CommandServerURL()
//
// Purpose:
//	Returns the Command Server URL.
//
////////////////////////////////////////////////////////////
LPTSTR
ServerCommands::Get_CommandServerURL()
{
	return m_szCommandServerURL;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_CommandServerResultsURL()
//
// Purpose:
//	Returns the Command Server Results URL.
//
////////////////////////////////////////////////////////////
LPTSTR
ServerCommands::Get_CommandServerResultsURL()
{
	return m_szCommandServerResultsURL;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_NumberOfStressInstances()
//
// Purpose:
//	Returns the number of stressInstances running or pending.
//
////////////////////////////////////////////////////////////
DWORD
ServerCommands::Get_NumberOfStressInstances()
{
	return m_arStressInstanceList.size();
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_TestDllFileName()
//
// Purpose:
//	Returns the name of the test DLL. ex. "winhttp5.dll"
//
////////////////////////////////////////////////////////////
LPTSTR
ServerCommands::Get_TestDllFileName()
{
	// m_szWinHttpDLL_FileName can be NULL in the case that a test DLL is not downloaded

	if (0 < _tcslen(m_szWinHttpDLL_FileName))
		return m_szWinHttpDLL_FileName;
	else
		return _T("winhttp5.dll");
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::RegisterClient()
//
// Purpose:
//	Sends the command server the system info on this client.
//	This lets the command server know that this client is alive.
//
//	NOTE: This only works in NT because we query
//	environment vars not present in Win9x
//
////////////////////////////////////////////////////////////
BOOL
ServerCommands::RegisterClient()
{
	OSVERSIONINFOA	osInfo;
	BOOL			bResult		= FALSE;
	DWORD			dwPostSize	= 5000;
	DWORD			dwTempSize	= MAX_PATH;
	DWORD			dwSizeSoFar	= 0;	// size of string written to szTemp so far.
	LPSTR			szPost		= new CHAR[dwPostSize];
	LPSTR			szTemp		= new CHAR[dwTempSize];


	ZeroMemory(szTemp, dwTempSize);
	ZeroMemory(szPost, dwPostSize);

	// *********************
	// *********************
	// ** Get windows version info
	osInfo.dwOSVersionInfoSize = sizeof(osInfo);
	if (!GetVersionExA(&osInfo))
		goto Exit;

	dwSizeSoFar += GetEnvironmentVariableA("OS", szTemp, dwTempSize);
	dwSizeSoFar += sizeof(FIELDNAME__OS_PLATFORM);
	strcat(szPost, FIELDNAME__OS_PLATFORM);
	strcat(szPost, szTemp);

	strcat(szPost, "&" FIELDNAME__OS_BUILD);
	strcat(szPost, _itoa(osInfo.dwBuildNumber, szTemp, 10));

	strcat(szPost, "&" FIELDNAME__OS_MAJORVERSION);
	strcat(szPost, _itoa(osInfo.dwMajorVersion, szTemp, 10));

	strcat(szPost, "&" FIELDNAME__OS_MINORVERSION);
	strcat(szPost, _itoa(osInfo.dwMinorVersion, szTemp, 10));

	strcat(szPost, "&" FIELDNAME__OS_EXTRAINFO);
	strcat(szPost, osInfo.szCSDVersion);


	// *********************
	// *********************
	// ** Get processor info
	GetEnvironmentVariableA("PROCESSOR_ARCHITECTURE", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_ARCHITECTURE);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("PROCESSOR_IDENTIFIER", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_ID);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("PROCESSOR_LEVEL", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_LEVEL);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("PROCESSOR_REVISION", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_REVISION);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("NUMBER_OF_PROCESSORS", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_NUMBER_OF);
	strcat(szPost, szTemp);


	// *********************
	// *********************
	// ** Get user info
	GetEnvironmentVariableA("USERNAME", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__USERINFO_USERALIAS);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("USERDOMAIN", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__USERINFO_USERDOMAIN);
	strcat(szPost, szTemp);

	// BUGBUG: someone needs to resolve the user alias to the real full name of the user
	// FIELDNAME__USERINFO_FULLNAME


	// get the client's machine name
	strcat(szPost, "&" FIELDNAME__USERINFO_MACHINENAME);
	strcat(szPost, m_szClientMachineName);


	// Let the Command Server know that this client is alive
	bResult = NetworkTools__POSTResponse(STRESS_COMMAND_SERVER_REGISTERCLIENT_URL, szPost, NULL);

	// LOGLOG: stressScheduler has started
	bResult = NetworkTools__SendLog(FIELDNAME__LOGTYPE_START_UP, "WinHttpStressScheduler has started.", NULL, NULL);

Exit:
	delete [] szPost;
	delete [] szTemp;

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\memstats.cpp ===
///////////////////////////////////////////////////////////////////////////
// File:  MemStats.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	MemStats.cpp: Helper functions that get's the system memory info.
//	Borrowed from EricI's memstats app.
//
// History:
//	03/21/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////


//
// WIN32 headers
//

//
// Project headers
//
#include "MemStats.h"
#include "NetworkTools.h"


//////////////////////////////////////////////////////////////////////
//
// Globals and statics
//
//////////////////////////////////////////////////////////////////////
BOOL (WINAPI *g_lpfnOpenProcessToken)(HANDLE,DWORD,PHANDLE);
BOOL (WINAPI *g_lpfnLookupPrivilegeValueA)(LPCSTR,LPCSTR,PLUID);
BOOL (WINAPI *g_lpfnAdjustTokenPrivileges)(HANDLE,BOOL,PTOKEN_PRIVILEGES,DWORD,PTOKEN_PRIVILEGES,PDWORD);

PDH_STATUS (WINAPI *g_lpfnPdhOpenQuery)(LPCSTR, DWORD_PTR, HQUERY *);
PDH_STATUS (WINAPI *g_lpfnPdhAddCounter)(HQUERY, LPCSTR, DWORD_PTR, HCOUNTER *);
PDH_STATUS (WINAPI *g_lpfnPdhCollectQueryData)(HQUERY);
PDH_STATUS (WINAPI *g_lpfnPdhGetFormattedCounterValue)(HCOUNTER, DWORD, LPDWORD, PPDH_FMT_COUNTERVALUE);
PDH_STATUS (WINAPI *g_lpfnPdhRemoveCounter)(HCOUNTER);
PDH_STATUS (WINAPI *g_lpfnPdhCloseQuery)(HQUERY);



////////////////////////////////////////////////////////////
// Function:  InitPdhLibrary()
//
// Purpose:
//	Loads and returns a pointer to the PDH module.
//
////////////////////////////////////////////////////////////
BOOL
InitPdhLibrary(
	HMODULE	*phPdhLib	// [OUT] Pointer to the PDH.DLL module.
)
{ 
    BOOL    bRet = FALSE;

    *phPdhLib = LoadLibraryA("pdh.dll");

    if(!*phPdhLib)
    {
        goto exit;
    }

	if(!(g_lpfnPdhOpenQuery = (PDH_STATUS (WINAPI *)(LPCSTR, DWORD_PTR, HQUERY *))GetProcAddress(*phPdhLib,"PdhOpenQueryA") ))
	{
		goto exit;
	}
	if(!(g_lpfnPdhAddCounter = (PDH_STATUS (WINAPI *)(HQUERY, LPCSTR, DWORD_PTR, HCOUNTER *))GetProcAddress(*phPdhLib,"PdhAddCounterA") ))
	{
		goto exit;
	}
	if(!(g_lpfnPdhCollectQueryData = (PDH_STATUS (WINAPI *)(HQUERY))GetProcAddress(*phPdhLib,"PdhCollectQueryData") ))
	{
		goto exit;
	}
	if(!(g_lpfnPdhGetFormattedCounterValue = (PDH_STATUS (WINAPI *)(HCOUNTER, DWORD, LPDWORD, PPDH_FMT_COUNTERVALUE))GetProcAddress(*phPdhLib,"PdhGetFormattedCounterValue") ))
	{
		goto exit;
	}
	if(!(g_lpfnPdhRemoveCounter = (PDH_STATUS (WINAPI *)(HCOUNTER))GetProcAddress(*phPdhLib,"PdhRemoveCounter") ))
	{
		goto exit;
	}
	if(!(g_lpfnPdhCloseQuery = (PDH_STATUS (WINAPI *)(HQUERY))GetProcAddress(*phPdhLib,"PdhCloseQuery") ))
	{
		goto exit;
	}
	
    bRet = TRUE;

exit:

    return bRet;
}


////////////////////////////////////////////////////////////
// Function:  GetProcCntrs(PROC_CNTRS, INT, CHAR)
//
// Purpose:
//	Gets and returns the memory info for a given process.
//
////////////////////////////////////////////////////////////
BOOL
GetProcCntrs(
	PROC_CNTRS	*pProcCntrs,	// [OUT]	process memory counters
	INT			nIndex,			// [IN]		The index of the process if there's more than one.
	CHAR		*szProcess		// [IN]		Name of the process. ex "iexplore", "explorer"
)
{
	BOOL						bRet = FALSE;
	INT							n;
	HQUERY						hQuery = 0;
    HCOUNTER					aryHCounter [PROCCOUNTERS] = {0};
	PDH_FMT_COUNTERVALUE		cntVal;
	CHAR						myProcessCntrs[PROCCOUNTERS][1024];
	DWORD						dwPathSize = MAX_PATH;

	sprintf(myProcessCntrs[0],"\\Process(%s#%d)\\ID Process",szProcess,nIndex);
	sprintf(myProcessCntrs[1],"\\Process(%s#%d)\\Private bytes",szProcess,nIndex);
	sprintf(myProcessCntrs[2],"\\Process(%s#%d)\\Handle count",szProcess,nIndex);
	sprintf(myProcessCntrs[3],"\\Process(%s#%d)\\Thread count",szProcess,nIndex);


	if(!(ERROR_SUCCESS == g_lpfnPdhOpenQuery (0, 0, &hQuery)))
	   goto exit;

	for (n = 0; n < PROCCOUNTERS; n++) 
	{ 
		if(!(ERROR_SUCCESS == g_lpfnPdhAddCounter (hQuery,  myProcessCntrs[n], 0, &aryHCounter[n])))
			goto exit;
	}

	if(!(ERROR_SUCCESS == g_lpfnPdhCollectQueryData(hQuery)))
		goto exit;

	for (n=0; n < PROCCOUNTERS; n++) 
	{ 
		if(!(ERROR_SUCCESS == g_lpfnPdhGetFormattedCounterValue (aryHCounter[n],PDH_FMT_LONG,0,&cntVal)))
			goto exit;
        *((ULONG*)pProcCntrs+n) = cntVal.longValue;
	} 

	bRet = TRUE;

exit:
	for(n=0;n<PROCCOUNTERS;n++)
		if(aryHCounter[n])
			g_lpfnPdhRemoveCounter(aryHCounter[n]);

	if(hQuery)
		g_lpfnPdhCloseQuery(hQuery);

	return bRet;
}


////////////////////////////////////////////////////////////
// Function:  GetInfoForPID(PROC_CNTRS, ULONG, CHAR)
//
// Purpose:
//	Gets and returns the memory info for a given process.
//	We do this by going through every process with the same
//	name and comparing the PIDs.
//
////////////////////////////////////////////////////////////
BOOL
GetInfoForPID(
	PROC_CNTRS	*pc,		// [OUT]	Process memory counters for the PID
	ULONG		lPID,		// [IN]		PID for the process to query
	CHAR		*szProcess	// [IN]		Process name of the PID to query. ex. "explore", "iexplore". Don't include the extension
)
{
	BOOL	bRet = TRUE;
	INT		n = 0;
	
	while(bRet)
	{
		bRet = GetProcCntrs(pc,n,szProcess);
		if(lPID == pc->lPID)
			break;

		n++;
	}

	return bRet;
}



////////////////////////////////////////////////////////////
// Function:  GetMemoryCounters(MEM_CNTRS)
//
// Purpose:
//	Gets and returns the memory info for the system.
//
////////////////////////////////////////////////////////////
BOOL
GetMemoryCounters(
	MEM_CNTRS *pMemCounters	// [OUT] Memory counters for the current machine
)
{
	BOOL						bRet                        = FALSE;
	HQUERY						hQuery                      = 0;
    HCOUNTER					aryHCounter[MEMCOUNTERS]    = {0};
	DWORD						dwPathSize                  = MAX_PATH;
	int							n;
	PDH_FMT_COUNTERVALUE		cntVal;
	char						szAryMemoryCntrs[MEMCOUNTERS][1024];

	sprintf(szAryMemoryCntrs[0],"\\Memory\\Committed Bytes");
	sprintf(szAryMemoryCntrs[1],"\\Memory\\Commit Limit");
	sprintf(szAryMemoryCntrs[2],"\\Memory\\System Code Total Bytes");
	sprintf(szAryMemoryCntrs[3],"\\Memory\\System Driver Total Bytes");
	sprintf(szAryMemoryCntrs[4],"\\Memory\\Pool Nonpaged Bytes");
	sprintf(szAryMemoryCntrs[5],"\\Memory\\Pool Paged Bytes");
	sprintf(szAryMemoryCntrs[6],"\\Memory\\Available Bytes");
	sprintf(szAryMemoryCntrs[7],"\\Memory\\Cache Bytes");
	sprintf(szAryMemoryCntrs[8],"\\Memory\\Free System Page Table Entries");


	if(!(ERROR_SUCCESS == g_lpfnPdhOpenQuery (0, 0, &hQuery)))
	   goto exit;

	for (n = 0; n < MEMCOUNTERS; n++) 
	{ 
		if(!(ERROR_SUCCESS == g_lpfnPdhAddCounter (hQuery,  szAryMemoryCntrs[n], 0, &aryHCounter[n])))
        {
			goto exit;
        }
	}

	if(!(ERROR_SUCCESS == g_lpfnPdhCollectQueryData(hQuery)))
		goto exit;

	for (n=0; n < MEMCOUNTERS; n++) 
	{ 
		if(!(ERROR_SUCCESS == g_lpfnPdhGetFormattedCounterValue (aryHCounter[n],PDH_FMT_LONG,0,&cntVal)))
        {
			goto exit;
        }
        *((ULONG*)pMemCounters+n) = cntVal.longValue;
	} 

	bRet = TRUE;

exit:
	for(n=0;n<MEMCOUNTERS;n++)
    {
		if(aryHCounter[n])
        {
			g_lpfnPdhRemoveCounter(aryHCounter[n]);
        }
    }

	if(hQuery)
		g_lpfnPdhCloseQuery(hQuery);

	return bRet;
}


////////////////////////////////////////////////////////////
// Function:  GetAvailableSystemDriveSpace(long)
//
// Purpose:
//	Gets and returns the disk space available on the system drive.
//
////////////////////////////////////////////////////////////
BOOL 
GetAvailableSystemDriveSpace(
	long	*lAvail		// [OUT] Buffer containing the space on the system drive
)
{
    BOOL                bRet    = FALSE;
    char                szSystemPath[MAX_PATH];
    ULARGE_INTEGER      FreeBytesAvailable;         // bytes available to caller
    ULARGE_INTEGER      TotalNumberOfBytes;         // bytes on disk
    ULARGE_INTEGER      TotalNumberOfFreeBytes;     // free bytes on disk
    int                 i;
    DWORD               dwFoo = 0;

    if(!GetSystemDirectoryA(szSystemPath,sizeof(szSystemPath)))
    {
        goto exit;
    }

    //We only want the drive letter
    for(i=0; i<1+lstrlenA(szSystemPath); i++)
    {
        if(szSystemPath[i] == 0)
        {
            goto exit;
        }

        if(szSystemPath[i] == '\\')
        {
            szSystemPath[i+1] = 0;
            break;
        }
    }

    if(GetDiskFreeSpaceExA(szSystemPath,&FreeBytesAvailable,&TotalNumberOfBytes,&TotalNumberOfFreeBytes))
    {
        *lAvail = __int32(TotalNumberOfFreeBytes.QuadPart / 1024 / 1000);
        bRet = TRUE;
    }

exit:
    return bRet;
}


////////////////////////////////////////////////////////////
// Function:  MemStats__SendSystemMemoryLog(LPSTR, DWORD, DWORD)
//
// Purpose:
//	Sends a memory log to the Command Server.
//	Sends the stressInstance ID and client machine name as part of the POST request.
//
////////////////////////////////////////////////////////////
BOOL
MemStats__SendSystemMemoryLog(
	LPSTR szExeName,			// [IN] Name of the process. ex. "explorer", "iexplorer". No extension.
	DWORD dwPID,				// [IN] PID for the above process
	DWORD dwStressInstanceID	// [IN] The stress instanceID
)
{
    BOOL            bRet        = FALSE;
    HMODULE         hPdhLib     = NULL;
    MEM_CNTRS       mc          = {0};
    long			lAvailDriveSpace	= 0;

	DWORD			dwPostDataSize	= MAX_PATH*10;
	DWORD			dwDataFieldSize	= 100;
	LPSTR			szPostData	= new CHAR[dwPostDataSize];
	LPSTR			szDataField	= new CHAR[dwDataFieldSize];
	LPSTR			szFileName	= new CHAR[MAX_PATH];
	PROC_CNTRS		pc;


    if(!InitPdhLibrary(&hPdhLib) || !szExeName)
    {
        goto exit;
    }
	
	// Remove the extension from the filename if there is one
	ZeroMemory(szFileName, MAX_PATH);
	strncpy(szFileName, szExeName, MAX_PATH);
	PathRemoveExtensionA(szFileName);


	ZeroMemory(szPostData,	dwPostDataSize);
	ZeroMemory(szDataField,	dwDataFieldSize);


	// *** !!! need this because NetworkTools__SendLog(...) sends szPost data as fieldname "LogText="
	// so we need an & to delimit memory info fields from "real" log text.
	strcat(szPostData, "&");

	// *************************
	// *************************
	// ** Get process info
	// **
	if (szFileName && GetInfoForPID(&pc, dwPID, szFileName))
	{
		sprintf(szDataField, FIELDNAME__STRESSEXE_HANDLECOUNT,		pc.lHandles);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");

		sprintf(szDataField, FIELDNAME__STRESSEXE_THREADCOUNT,		pc.lThreads);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");

		sprintf(szDataField, FIELDNAME__STRESSEXE_PRIVATEBYTES,		pc.lPrivBytes);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
	}

	// *************************
	// *************************
	// ** Get system memory info
	// **
	if (GetMemoryCounters(&mc))
    {
		sprintf(szDataField, FIELDNAME__MEMORY_COMMITTEDPAGEFILETOTAL,		mc.lCommittedBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");

		sprintf(szDataField, FIELDNAME__MEMORY_AVAILABLEPAGEFILETOTAL,		(mc.lCommitLimit - mc.lCommittedBytes)/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_SYSTEMCODETOTAL,				mc.lSystemCodeTotalBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_SYSTEMDRIVERTOTAL,			mc.lSystemDriverTotalBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_NONPAGEDPOOLTOTAL,			mc.lPoolNonpagedBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_PAGEDPOOLTOTAL,				mc.lPoolPagedBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_PHYSICAL_MEMORY_AVAILABLE,	mc.lAvailableBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_SYSTEMCACHETOTAL,			mc.lCacheBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_FREESYSTEM_PAGETABLE_ENTRIES,mc.lFreeSystemPageTableEntries);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
    }


	// *************************
	// *************************
	// ** Get disk space info
	// **
    if (GetAvailableSystemDriveSpace(&lAvailDriveSpace))
	{
		sprintf(szDataField, FIELDNAME__MEMORY_DISK_SPACE_AVAILABLE, lAvailDriveSpace);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
	}

	NetworkTools__SendLog(FIELDNAME__LOGTYPE_MEMORY_INFORMATION, szPostData, NULL, dwStressInstanceID);

exit:

	// FYI: Recent Whistler main build deadlocks in unload of the PDH library
    if(hPdhLib)
    {
        FreeLibrary(hPdhLib);
    }

	delete [] szPostData;
	delete [] szDataField;
	delete [] szFileName;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressinstance.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  StressInstance.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	StressInstance.cpp: interface for the StressInstance class.
//	This class is used spawn and monitor instances of the stressEXE app
//
// History:
//	02/15/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//
// Includes
//
//////////////////////////////////////////////////////////////////////

//
// Win32 headers
//

//
// Project headers
//
#include "StressInstance.h"
#include "ServerCommands.h"
#include "NetworkTools.h"
#include "MemStats.h"
#include "debugger.h"

//////////////////////////////////////////////////////////////////////
//
// Globals and statics
//
//////////////////////////////////////////////////////////////////////

extern ServerCommands	g_objServerCommands;	// Declared in WinHttpStressScheduler.cpp
extern HWND				g_hWnd;					// Declared in WinHttpStressScheduler.cpp

StressInstance			*g_hThis;				// the current StressInstance object. Used only in (friend) StressExe_TimerProc.
UINT_PTR				g_uiStressExeTimerID;	// ID for the timer that monitors the stressExe when it's spawned

// Forward function definitions

VOID
CALLBACK
StressExe_TimerProc(
	HWND hwnd,         // [IN] handle to window
	UINT uMsg,         // [IN] WM_TIMER message
	UINT_PTR idEvent,  // [IN] timer identifier
	DWORD dwTime       // [IN] current system time
);

DWORD
DebuggerCallbackProc(
	DWORD	dwFlags,
	LPVOID	lpIn,
	LPTSTR	lpszFutureString,
	LPVOID	lpFuturePointer
);


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


StressInstance::StressInstance()
{
	m_szStressExe_URL					= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_PDB_URL				= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_SYM_URL				= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_FilePath				= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_FileName				= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_FilePathAndName		= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_PageHeapCommandLine	= new TCHAR[MAX_PATH];
	m_szStressExe_UMDHCommandLine		= new TCHAR[MAX_PATH];
	m_szStressExe_MemDumpPath			= new TCHAR[MAX_PATH];

	ZeroMemory(m_szStressExe_URL,					MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_PDB_URL,				MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_SYM_URL,				MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_FilePath,				MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_FileName,				MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_FilePathAndName,		MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_PageHeapCommandLine,	MAX_PATH);
	ZeroMemory(m_szStressExe_UMDHCommandLine,		MAX_PATH);
	ZeroMemory(m_szStressExe_MemDumpPath,			MAX_PATH);
	
	ZeroMemory(&m_piStressExeProcess, sizeof(PROCESS_INFORMATION));

	m_hStressExe_ProcessExitEvent	= NULL;
	g_uiStressExeTimerID			= 0;

	m_objDebugger	= NULL;

	g_hThis			= this;
}


StressInstance::~StressInstance()
{
	// End any running tests
	if (IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
		StressInstance::End();

	delete [] m_szStressExe_URL;
	delete [] m_szStressExe_PDB_URL;
	delete [] m_szStressExe_SYM_URL;
	delete [] m_szStressExe_FilePath;
	delete [] m_szStressExe_FileName;
	delete [] m_szStressExe_FilePathAndName;
	delete [] m_szStressExe_PageHeapCommandLine;
	delete [] m_szStressExe_UMDHCommandLine;
	delete [] m_szStressExe_MemDumpPath;
	

	m_szStressExe_URL					= NULL;
	m_szStressExe_PDB_URL				= NULL;
	m_szStressExe_SYM_URL				= NULL;
	m_szStressExe_FilePath				= NULL;
	m_szStressExe_FileName				= NULL;
	m_szStressExe_FilePathAndName		= NULL;
	m_szStressExe_PageHeapCommandLine	= NULL;
	m_szStressExe_UMDHCommandLine		= NULL;
	m_szStressExe_MemDumpPath			= NULL;

	// close stressExe process handles
	if (m_piStressExeProcess.hThread)
		CloseHandle(m_piStressExeProcess.hThread);

	if (m_piStressExeProcess.hProcess)
		CloseHandle(m_piStressExeProcess.hProcess);

	if (m_hStressExe_ProcessExitEvent)
		CloseHandle(m_hStressExe_ProcessExitEvent);

	m_piStressExeProcess.hThread	= NULL;
	m_piStressExeProcess.hProcess	= NULL;
	m_hStressExe_ProcessExitEvent	= NULL;

	// free debugger object
	if (m_objDebugger)
	{
		delete m_objDebugger;
		m_objDebugger = NULL;
	}

	g_hThis = NULL;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Begin()
//
// Purpose:
//	This method begins stress by downloading the stress EXE from
//	m_szStressExe_URL and starts it in CDB.
//
////////////////////////////////////////////////////////////
BOOL
StressInstance::Begin()
{
	BOOL			bResult					= TRUE;
	LPTSTR			szCommandLine			= new TCHAR[MAX_STRESS_URL*4];
	LPTSTR			szFileNameAndPath		= new TCHAR[MAX_STRESS_URL*2];
	DWORD			dwCommandLineSize		= MAX_STRESS_URL*4;
	DWORD			dwFileNameAndPathSize	= MAX_STRESS_URL*2;
	LPSTARTUPINFO	pStartUpInfo			= new STARTUPINFO;


	// don't start if stress is already running or we don't have a FileName or Path.
	if (IsRunning(5000) ||
		0 >= _tcslen(m_szStressExe_FilePath) ||
		0 >= _tcslen(m_szStressExe_FileName))
		goto Exit;


	// ********************************
	// ********************************
	// ** Download the stressExe and symbols.
	// **
	if (!DownloadStressExe())
	{
		bResult = FALSE;
		goto Exit;
	}


	// ********************************
	// ********************************
	// ** Enable pageheap if needed
	// **
	if (0 < _tcsclen(m_szStressExe_PageHeapCommandLine))
	{
		if (!NetworkTools__PageHeap(TRUE, m_szStressExe_FileName, m_szStressExe_PageHeapCommandLine))
		{
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "Pageheap failed when trying to enable.", NULL, Get_ID());
			bResult = FALSE;
			// goto Exit; don't need to exit when pageheap fails
		}
		else
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_SUCCESS, "Pageheap successfully enabled.", NULL, Get_ID());
	}


	// ********************************
	// ********************************
	// ** Create the stressExe process
	// **

	// build Remote/CDB/stressExe path
	ZeroMemory(szCommandLine, dwCommandLineSize);
	_stprintf(szCommandLine, STRESSINSTANCE_DEBUG_COMMANDLINE, m_szStressExe_FilePathAndName);

	// startupInfo
	ZeroMemory(pStartUpInfo, sizeof(STARTUPINFO));
	pStartUpInfo->cb				= sizeof(STARTUPINFO);
	pStartUpInfo->dwFillAttribute	= FOREGROUND_RED| BACKGROUND_RED| BACKGROUND_GREEN| BACKGROUND_BLUE; // red text on white background
	pStartUpInfo->dwFlags			= STARTF_USESHOWWINDOW;
	pStartUpInfo->wShowWindow		= SW_MINIMIZE;


	// Create the stressExe process
	bResult =
	CreateProcess(
		NULL,
		m_szStressExe_FilePathAndName,
		NULL, 
		NULL,
		TRUE,
		CREATE_NEW_CONSOLE | CREATE_SEPARATE_WOW_VDM | NORMAL_PRIORITY_CLASS | CREATE_NEW_PROCESS_GROUP | CREATE_SUSPENDED,
		NULL,
		NULL,
		pStartUpInfo,
		&m_piStressExeProcess);


	if (!bResult)
	{
		// stressExe failed to start 
		goto Exit;
	}


	// ********************************
	// ********************************
	// ** Attach debugger to the process only if there isn't one
	// **

	// remove debugger if there is one
	if (m_objDebugger)
	{
		delete m_objDebugger;
		m_objDebugger = NULL;
	}

	// attach new debugger
	Sleep(2000);
	m_objDebugger = new Debugger(m_piStressExeProcess.dwProcessId, DebuggerCallbackProc);
	m_objDebugger->Go();

	ResumeThread(m_piStressExeProcess.hThread);

	
	// ********************************
	// ********************************
	// ** Initialize dynamically named event objects.
	// ** Set object access to ALL.
	// **

	// Create event object that'll be inherited by the stressExe process.
	// StressScheduler will signal when it's time to close stressExe.
	SECURITY_ATTRIBUTES		securityAttributes;
	PSECURITY_DESCRIPTOR	pSD;

	pSD = new SECURITY_DESCRIPTOR;

	// Set a NULL security descriptor. This gives full access to handles when inherited
	InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
	SetSecurityDescriptorDacl(pSD, TRUE, (PACL) NULL, FALSE);

	securityAttributes.bInheritHandle		= TRUE;
	securityAttributes.lpSecurityDescriptor	= pSD;
	securityAttributes.nLength				= sizeof(securityAttributes);


	// The named event object names have the PID of the process appended to the end of the constants
	// These strings are also created in the stressExe dynamically.
	LPTSTR szExitProcessName;
	LPTSTR szPID;

	szExitProcessName		= new TCHAR[MAX_PATH];
	szPID					= new TCHAR[16];

	// Get the processID string
	_itot(m_piStressExeProcess.dwProcessId, szPID, 10);

	// build ExitProcess event object name
	_tcscpy(szExitProcessName, STRESSINSTANCE_STRESS_EXE_EVENT_EXITPROCESS);
	_tcscat(szExitProcessName, szPID);

	if (m_hStressExe_ProcessExitEvent)
		CloseHandle(m_hStressExe_ProcessExitEvent);

	// this event is sent by us to stressExe when we want it to exit
	// Signaled = tell stressExe to exit; Not-Signaled = stressExe can continue running
	m_hStressExe_ProcessExitEvent = CreateEvent(
		&securityAttributes,
		FALSE,	// manual reset
		FALSE,
		szExitProcessName);


	delete [] szExitProcessName;
	delete [] szPID;
	delete [] pSD;


	// ********************************
	// ********************************
	// ** Begin the stressExe memory monitoring timerproc
	// **
	if (g_uiStressExeTimerID)
	{
		// there shouldn't be a timer already going. If so, nuke it.
		KillTimer(NULL, g_uiStressExeTimerID);
		g_uiStressExeTimerID = 0;
	}

	// create a new timer object
	g_uiStressExeTimerID =
	SetTimer(
		NULL,
		0,
		STRESSINSTANCE_MONITOR_EXE_TIME,
		(TIMERPROC) StressExe_TimerProc);



	// Notify the Command Server that stress has started
	NetworkTools__SendLog(FIELDNAME__LOGTYPE_BEGIN, "This stressInstance has begun.", NULL, Get_ID());

Exit:
	delete [] szCommandLine;
	delete [] szFileNameAndPath;
	delete [] pStartUpInfo;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::End()
//
// Purpose:
//	This method ends stress by sending a message
//
////////////////////////////////////////////////////////////
VOID
StressInstance::End()
{
	// ******************************
	// ******************************
	// ** End the stressExe monitoring timerproc
	if (g_uiStressExeTimerID)
		KillTimer(NULL, g_uiStressExeTimerID);


	// ******************************
	// ******************************
	// ** Tell stressExe to shut down.
	SetEvent(m_hStressExe_ProcessExitEvent);

	// give time for the stressExe to exit
	Sleep(2000);

	// close stressExe process handles
	if (m_piStressExeProcess.hThread)
		CloseHandle(m_piStressExeProcess.hThread);

	if (m_piStressExeProcess.hProcess)
		CloseHandle(m_piStressExeProcess.hProcess);

	if (m_hStressExe_ProcessExitEvent)
		CloseHandle(m_hStressExe_ProcessExitEvent);

	m_piStressExeProcess.hThread	= NULL;
	m_piStressExeProcess.hProcess	= NULL;
	m_hStressExe_ProcessExitEvent	= NULL;


	// stop stressExe if it's still running
	if (IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
	{
		// stressExe failed to signal that it exited.
		// Bad stressExe, terminate the process.
		BOOL temp = TerminateProcess(m_piStressExeProcess.hProcess, 0);
	}


	// ********************************
	// ********************************
	// ** Detach the debugger object
	// **

	// detaching the debugger will (read: should) stop the stressExe
	if (m_objDebugger)
	{
		// ********************************
		// ********************************
		// ** Disable pageheap if needed
		// **
		NetworkTools__PageHeap(FALSE, m_szStressExe_FileName, NULL);

		// let the Command Server know that stressExe has ended
		// we send the message here because ServerCommands.cpp calls this too - even when
		// there isn't a running test case.
		// When the debugger object is valid, then we send the message - because it ensures that Begin() was called.
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_END, "This stressInstance has ended.", NULL, Get_ID());

		delete m_objDebugger;
		m_objDebugger	= NULL;
	}

	ZeroMemory(&m_piStressExeProcess, sizeof(PROCESS_INFORMATION));
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Get_StressExeID()
//
// Purpose:
//	Returns the stress instance's ID receivedfrom the server
//
////////////////////////////////////////////////////////////
DWORD
StressInstance::Get_ID()
{
	return m_dwStressExe_ID;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Get_StressExeMemoryDumpPath()
//
// Purpose:
//	Sets the URL of the memory dump path
//
////////////////////////////////////////////////////////////
LPTSTR
StressInstance::Get_StressExeMemoryDumpPath()
{
	return m_szStressExe_MemDumpPath;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExeMemoryDumpPath()
//
// Purpose:
//	Sets the URL of the memory dump path
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExeMemoryDumpPath(
	LPTSTR szPath
)
{
	_tcsncpy(m_szStressExe_MemDumpPath, szPath, MAX_PATH);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExeURL(LPTSTR)
//
// Purpose:
//	Sets the URL to download the stress EXE for this object.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExeURL(
	LPTSTR szBuffer	// [IN] Buffer containing the URL to download the stressExe app
)
{
	if (!szBuffer || (0 >= _tcslen(szBuffer)))
		return;

	_tcscpy(m_szStressExe_URL, szBuffer);

	// Set the stressExe's filename
	NetworkTools__GetFileNameFromURL(m_szStressExe_URL, m_szStressExe_FileName, MAX_STRESS_URL);

	// Set the stressExe's default path to download to with trailing slash
	GetCurrentDirectory(MAX_STRESS_URL, m_szStressExe_FilePath);
	_tcscat(m_szStressExe_FilePath, _T("\\") STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR _T("\\"));

	// Set the full stressExe path + exe
	_tcscpy(m_szStressExe_FilePathAndName, m_szStressExe_FilePath);
	_tcscat(m_szStressExe_FilePathAndName, m_szStressExe_FileName);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExePdbURL(LPTSTR)
//
// Purpose:
//	Sets the URL to download the stress EXE's PDB file.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExePdbURL(
	LPTSTR szBuffer	// [IN] Buffer containing the URL
)
{
	if (!szBuffer || (0 >= _tcslen(szBuffer)))
		return;

	_tcscpy(m_szStressExe_PDB_URL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExeSymURL(LPTSTR)
//
// Purpose:
//	Sets the URL to download the stress EXE's SYM file.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExeSymURL(
	LPTSTR szBuffer	// [IN] Buffer containing the URL
)
{
	if (!szBuffer || (0 >= _tcslen(szBuffer)))
		return;

	_tcscpy(m_szStressExe_SYM_URL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExeID(DWORD)
//
// Purpose:
//	Sets the URL to download the stress EXE for this object.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExeID(
	DWORD dwID	// [IN] ID from the stressAdmin DB uniquely identifying this stress EXE. 
)
{
	m_dwStressExe_ID = dwID;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_PageHeapCommands(LPCTSTR)
//
// Purpose:
//	Sets the pageheap command line.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_PageHeapCommands(
	LPCTSTR szCommandLine	// [IN] Extra command line params for pageheap.
)
{
	ZeroMemory(m_szStressExe_PageHeapCommandLine, MAX_PATH);
	_tcsncpy(m_szStressExe_PageHeapCommandLine, szCommandLine, MAX_PATH-1);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_UMDHCommands(LPCTSTR)
//
// Purpose:
//	Sets the UMDH command line.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_UMDHCommands(
	LPCTSTR szCommandLine	// [IN] Extra command line params for UMDH.
)
{
	ZeroMemory(m_szStressExe_UMDHCommandLine, MAX_PATH);
	_tcsncpy(m_szStressExe_UMDHCommandLine, szCommandLine, MAX_PATH-1);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::DownloadStressExe()
//
// Purpose:
//	Downloads the stressExe app to the local machine.
//	We create a directory of the stress exe name. For example,
//	"http://hairball/files/stress1.exe" will be put in "stress1\stress1.exe"
//	on the local machine. If the file is already there, it'll try to overwrite it.
//
////////////////////////////////////////////////////////////
BOOL
StressInstance::DownloadStressExe()
{
	BOOL	bResult		= TRUE;
	LPTSTR	szFileName	= new TCHAR[MAX_PATH];

	// Download the stressExe file
	if (NetworkTools__URLDownloadToFile(m_szStressExe_URL, STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR, m_szStressExe_FileName))
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_SUCCESS, "stress EXE file downloaded successfully.", NULL, Get_ID());
	else
	{
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "stress EXE file not downloaded.", NULL, Get_ID());
		bResult = FALSE;
	}

	// Download PDB symbol file if there is one
	if (NetworkTools__GetFileNameFromURL(m_szStressExe_PDB_URL, szFileName, MAX_PATH))
	{
		NetworkTools__URLDownloadToFile(m_szStressExe_PDB_URL, STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR, szFileName);
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_SUCCESS, "stress PDB file downloaded successfully.", NULL, Get_ID());
	}
	else
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "stress PDB file not downloaded.", NULL, Get_ID());

	// Download SYM symbol file if there is one
	if (NetworkTools__GetFileNameFromURL(m_szStressExe_SYM_URL, szFileName, MAX_PATH))
	{
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_SUCCESS, "stress SYM file downloaded successfully.", NULL, Get_ID());
		NetworkTools__URLDownloadToFile(m_szStressExe_SYM_URL, STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR, szFileName);
	}
	else
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "streses SYM file not downloaded.", NULL, Get_ID());

	delete [] szFileName;
	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::IsRunning()
//
// Purpose:
//	Returns TRUE if this stressinstance is running. FALSE if not.
//
////////////////////////////////////////////////////////////
BOOL StressInstance::IsRunning(DWORD dwTimeOut)
{
	BOOL	bResult		= FALSE;
	HANDLE	hStressExe	= NULL;

	hStressExe = OpenProcess(PROCESS_ALL_ACCESS, FALSE, m_piStressExeProcess.dwProcessId);

	if (!hStressExe)
		bResult = FALSE;
	else
	{
		bResult = TRUE;
		CloseHandle(hStressExe);
	}

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  StressExe_TimerProc(HWND, UINT, UINT_PTR, DWORD)
//
// Purpose:
//	When this is called, we will check on the status of the
//	stressExe process send the command server it's memory info
//
////////////////////////////////////////////////////////////
VOID
CALLBACK
StressExe_TimerProc(
	HWND hwnd,         // [IN] handle to window - should be NULL since we didn't specify one
	UINT uMsg,         // [IN] WM_TIMER message
	UINT_PTR idEvent,  // [IN] timer identifier
	DWORD dwTime       // [IN] current system time
)
{
	// build directory to copy dump file
	LPSTR	szExeName = new CHAR[MAX_STRESS_URL];


	if (!g_hThis)
		goto Exit;

	// ***********************************
	// ***********************************
	// ** Check that the stressExe is still running. If it isn't end this instance.
	// **
	if (!g_hThis->IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
	{
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_INFORMATION, "This stress instance has exited prematurely.", NULL, g_hThis->Get_ID());
		g_hThis->End();
		goto Exit;
	}


	ZeroMemory(szExeName, MAX_STRESS_URL); 

	// ******************************
	// ** Remove the file extension of the stressExe name and send the system and process
	// ** memory log to the command server
	WideCharToMultiByte(
		CP_ACP,
		NULL,
		g_hThis->m_szStressExe_FileName,
		-1,
		szExeName,
		MAX_STRESS_URL,
		NULL,
		NULL);

	MemStats__SendSystemMemoryLog(szExeName, g_hThis->m_piStressExeProcess.dwProcessId, g_hThis->Get_ID());

Exit:
	delete [] szExeName;

	return;
}


////////////////////////////////////////////////////////////
// Function:  DebuggerCallbackProc(DWORD, LPVOID, LPTSTR, LPVOID)
//
// Purpose:
//	Creates a memory dump on second change exceptions
//
////////////////////////////////////////////////////////////
DWORD DebuggerCallbackProc(
	DWORD	dwFlags,
	LPVOID	lpIn,
	LPTSTR	lpszFutureString,
	LPVOID	lpFuturePointer
)
{
	//test callback for debugger lib
	DWORD dwContinue = 0;


	// ***********************************
	// ***********************************
	// ** Check that the stressExe is still running.
	// **
	if (!g_hThis || !g_hThis->IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
	{
		dwContinue = DEBUGGER_CONTINUE_STOP_DEBUGGING;
		goto Exit;
	}


	switch (dwFlags)
	{
		case DEBUGGER_FIRST_CHANCE_EXCEPTION:
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_INFORMATION, "FIRST_CHANCE_EXCEPTION detected.", NULL, g_hThis->Get_ID());
			//must use this to pass on first chance exceptions to the system
			dwContinue = DEBUGGER_CONTINUE_UNHANDLED;
			break;

		case DEBUGGER_SECOND_CHANCE_EXCEPTION:
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_INFORMATION, "SECOND_CHANCE_EXCEPTION detected.", NULL, g_hThis->Get_ID());

			// build directory to copy dump file
			LPTSTR szPath;
			LPTSTR szNum;
			LPTSTR szMachineName;
			
			szPath			= new TCHAR[MAX_PATH * 2];
			szNum			= new TCHAR[100];
			szMachineName	= new TCHAR[MAX_PATH];

			// ******************************
			// create the directory STRESSINSTANCE_MEMORY_DUMP_PATH\<MachineName>
			MultiByteToWideChar(
				CP_ACP,
				MB_PRECOMPOSED,
				g_objServerCommands.Get_ClientMachineName(),
				-1,
				szMachineName,
				MAX_PATH);

			// if the server sent a vaild path then use it, else use the default memory dump path
			if (0 < _tcslen(g_hThis->Get_StressExeMemoryDumpPath()))
				_tcscpy(szPath, g_hThis->Get_StressExeMemoryDumpPath());
			else
				_tcscpy(szPath, STRESSINSTANCE_DEFAULT_MEMORY_DUMP_PATH);

			// add the machine name to the end of the directory
			_tcscat(szPath, szMachineName);

			CreateDirectory(szPath, NULL);

			// ******************************
			// create the filename in form "<stressExeFileName>-<stressInstanceID>-<PID>.dmp"
			_tcscat(szPath, _T("\\"));

			_tcscat(szPath, g_hThis->m_szStressExe_FileName);
			_tcscat(szPath, _T("-"));

			_itot(g_hThis->Get_ID(), szNum, 10);
			_tcscat(szPath, szNum);
			_tcscat(szPath, _T("-"));

			_itot(g_hThis->m_piStressExeProcess.dwProcessId, szNum, 10);
			_tcscat(szPath, szNum);
			_tcscat(szPath, _T(".dmp"));

			//this creates a full user dump
			g_hThis->m_objDebugger->CreateMiniDump(szPath, _T("This is a full user dump created by debugger.lib"), DEBUGGER_CREATE_FULL_MINI_DUMP);

			delete [] szPath;
			delete [] szNum;
			delete [] szMachineName;


			// let the Command Server know a dump file was created
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_DUMPFILE_CREATED, "User dump file was created.", NULL, g_hThis->Get_ID());

			// stop the debugger
			dwContinue = DEBUGGER_CONTINUE_STOP_DEBUGGING;
			break;

		case DEBUGGER_EXIT_PROCESS:
			dwContinue = DEBUGGER_CONTINUE_STOP_DEBUGGING;
			break;

		default:
			// let the Command Server know a dump file was created
			break;
	}


Exit:
	return dwContinue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\servercommands.h ===
//////////////////////////////////////////////////////////////////////
// File:  WinHttpStressScheduler.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	ServerCommands.h: interface for the ServerCommands class.
//	This class is used to retrieve and act on command from the server.
//
// History:
//	02/08/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//
#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <shlwapi.h>
#include <windows.h>
#include <tchar.h>
#include <winhttp.h>
#include <vector>

//
// Project headers
//
#include "StressInstance.h"


//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////
#if !defined(AFX_SERVERCOMMANDS_H__6B84102D_2F79_4FE0_A936_ED4F043AC75E__INCLUDED_)
#define AFX_SERVERCOMMANDS_H__6B84102D_2F79_4FE0_A936_ED4F043AC75E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRESS_SCHEDULER_USER_AGENT						_T("WinHttp Stress Scheduler")

//#define STRESS_COMMAND_SERVER_URL						_T("http://hairball/api/Stress/set-response-header.asp?name=WinHttpStress_Quit&value=")
#define STRESS_COMMAND_SERVER_URL						_T("http://hairball/stressAdmin/stressCommand.asp")
#define STRESS_COMMAND_SERVER_RESULTS_URL				_T("http://hairball/api/Stress/set-response-header.asp")

// When we first start up, we report our client stats and post them to this page to let the server know that we're alive
#define STRESS_COMMAND_SERVER_REGISTERCLIENT_URL		_T("http://hairball/stressAdmin/registerClient.asp")
#define STRESS_COMMAND_SERVER_LOGURL					_T("http://hairball/stressAdmin/logStress.asp")

#define STRESS_COMMAND_SERVER_UPDATE_INTERVAL			4000		// 4 second default timeout
#define STRESS_COMMAND_SERVER_MINIMUM_UPDATE_INTERVAL	2000		// 2 second minimum timeout. Don't want to flood the network.
#define STRESS_COMMAND_SERVER_MAXIMUM_UPDATE_INTERVAL	300000		// 5 minute maximum timeout. Don't want to lose you!


#define MAX_URL											MAX_PATH * 2

// Timer related definitions
#define IDT_QUERY_COMMAND_SERVER						1			// timer identifier for pinging the command server


// List of URLs for the stress EXE's that we need to download
using namespace std;

typedef StressInstance			*PSTRESSINSTANCE;
typedef vector<PSTRESSINSTANCE>	PSTRESSINSTANCE_LIST;

// *****************************************************
// *****************************************************
// *** List of headers that the command server can send us.
// *** 
#define COMMANDHEADER__EXIT						_T("WinHttpStress_Exit")					// valid values: None. If the header is present, then assume we want to exit.
#define COMMANDHEADER__WINHTTP_DLL_URL			_T("WinHttpStress_WinHttpDllURL")			// valid values: Valid URL
#define COMMANDHEADER__WINHTTP_PDB_URL			_T("WinHttpStress_WinHttpPDBURL")			// valid values: Valid URL
#define COMMANDHEADER__WINHTTP_SYM_URL			_T("WinHttpStress_WinHttpSYMURL")			// valid values: Valid URL
#define COMMANDHEADER__ABORT					_T("WinHttpStress_Abort")					// valid values: ID of a stressInstance from the DB that needs to be aborted
#define COMMANDHEADER__MEMORY_DUMP_PATH			_T("WinHttpStress_MemoryDumpPath")			// valid values: Valid path
#define COMMANDHEADER__STRESS_EXE_URL			_T("WinHttpStress_StressExeURL")			// valid values: Valid URL
#define COMMANDHEADER__STRESS_PDB_URL			_T("WinHttpStress_StressPDBURL")			// valid values: Valid URL
#define COMMANDHEADER__STRESS_SYM_URL			_T("WinHttpStress_StressSYMURL")			// valid values: Valid URL
#define COMMANDHEADER__STRESS_EXE_INSTANCEID	_T("WinHttpStress_StressExeInstanceID")		// valid values: Valid ID from the stressAdmin DB table identifying the stressInstance. This is how stressScheduler tells stressAdmin the status of each stressInstance.
#define COMMANDHEADER__STRESS_EXE_PAGEHEAP		_T("WinHttpStress_PageHeapCommand")			// valid values: pageheap command line. will not use pageheap if missing
#define COMMANDHEADER__STRESS_EXE_UMDH			_T("WinHttpStress_UMDHCommand")				// valid values: UMDH command line. will not use UMDH if missing
#define COMMANDHEADER__COMMANDSERVER_URL		_T("WinHttpStress_CommandServerURL")		// valid values: Valid URL
#define COMMANDHEADER__BEGIN_TIME_HOUR			_T("WinHttpStress_BeginTimeHour")			// valid values: 0-23
#define COMMANDHEADER__BEGIN_TIME_MINUTE		_T("WinHttpStress_BeginTimeMinute")			// valid values: 0-59
#define COMMANDHEADER__END_TIME_HOUR			_T("WinHttpStress_EndTimeHour")				// valid values: 0-23
#define COMMANDHEADER__END_TIME_MINUTE			_T("WinHttpStress_EndTimeMinute")			// valid values: 0-59
#define COMMANDHEADER__RUN_FOREVER				_T("WinHttpStress_RunForever")				// valid values: 0 or 1
#define COMMANDHEADER__UPDATE_INTERVAL			_T("WinHttpStress_UpdateInterval")			// valid values: Time to wait to ping the command server in milliseconds.

// *****************************************************
// *****************************************************
// *** List of form names and values that we send back to the command server
// *** 

// **********************
// ** Logging POST fields
#define FIELDNAME__LOGTYPE						"LogType="
#define FIELDNAME__LOGTYPE_INFORMATION			FIELDNAME__LOGTYPE "INFORMATION"
#define FIELDNAME__LOGTYPE_START_UP				FIELDNAME__LOGTYPE "STRESSSECHDULER_START_UP"
#define FIELDNAME__LOGTYPE_EXIT					FIELDNAME__LOGTYPE "STRESSSECHDULER_EXIT"
#define FIELDNAME__LOGTYPE_MEMORY_INFORMATION	FIELDNAME__LOGTYPE "MEMORY_INFORMATION"
#define FIELDNAME__LOGTYPE_DUMPFILE_CREATED		FIELDNAME__LOGTYPE "DUMP_FILE_CREATED"
#define FIELDNAME__LOGTYPE_ERROR				FIELDNAME__LOGTYPE "ERROR"
#define FIELDNAME__LOGTYPE_SUCCESS				FIELDNAME__LOGTYPE "SUCCESS"
#define FIELDNAME__LOGTYPE_BEGIN_STRESS			FIELDNAME__LOGTYPE "BEGIN_STRESS"
#define FIELDNAME__LOGTYPE_END_STRESS			FIELDNAME__LOGTYPE "END_STRESS"
#define FIELDNAME__LOGTYPE_BEGIN				FIELDNAME__LOGTYPE "BEGIN_STRESS_INSTANCE"
#define FIELDNAME__LOGTYPE_END					FIELDNAME__LOGTYPE "END_STRESS_INSTANCE"

#define FIELDNAME__LOG_TEXT				"LogText="
#define FIELDNAME__STRESSINSTANCE_ID	"StressInstanceID="


// **********************
// ** System information for registering the client POST fields.

// StressExe process return values
#define FIELDNAME__STRESSEXE_PRIVATEBYTES		"StressExe_PrivateBytes=%d"
#define FIELDNAME__STRESSEXE_HANDLECOUNT		"StressExe_HandleCount=%d"
#define FIELDNAME__STRESSEXE_THREADCOUNT		"StressExe_ThreadCount=%d"

// System Memory Info
#define FIELDNAME__MEMORY_HANDLES						"System_Handles=%d"
#define FIELDNAME__MEMORY_THREADS						"System_Threads=%d"
#define FIELDNAME__MEMORY_VMSIZE						"System_VMSize=%d"
#define FIELDNAME__MEMORY_COMMITTEDPAGEFILETOTAL		"System_CommittedPageFileTotal=%d"
#define FIELDNAME__MEMORY_AVAILABLEPAGEFILETOTAL		"System_AvailablePageFileTotal=%d"
#define FIELDNAME__MEMORY_SYSTEMCODETOTAL				"System_SystemCodeTotal=%d"
#define FIELDNAME__MEMORY_SYSTEMDRIVERTOTAL				"System_SystemDriverTotal=%d"
#define FIELDNAME__MEMORY_NONPAGEDPOOLTOTAL				"System_NonPagedPoolTotal=%d"
#define FIELDNAME__MEMORY_PAGEDPOOLTOTAL				"System_PagedPoolTotal=%d"
#define FIELDNAME__MEMORY_PHYSICAL_MEMORY_AVAILABLE		"System_PhysicalMemoryAvailable=%d"
#define FIELDNAME__MEMORY_SYSTEMCACHETOTAL				"System_SystemCacheTotal=%d"
#define FIELDNAME__MEMORY_FREESYSTEM_PAGETABLE_ENTRIES	"System_FreeSystemPageTableEntries=%d"
#define FIELDNAME__MEMORY_DISK_SPACE_AVAILABLE			"System_DiskSpaceAvailable=%d"

// Processor Info
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_ARCHITECTURE	"StressExeSystemInfo_ProcessorArchitecture="
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_ID				"StressExeSystemInfo_ProcessorID="
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_LEVEL			"StressExeSystemInfo_ProcessorLevel="
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_REVISION		"StressExeSystemInfo_ProcessorRevision="
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_NUMBER_OF		"StressExeSystemInfo_ProcessorNumberOf="

// OS Info
#define FIELDNAME__OS_PLATFORM		"StressExeOSInfo_Platform="
#define FIELDNAME__OS_BUILD			"StressExeOSInfo_Build="
#define FIELDNAME__OS_MAJORVERSION	"StressExeOSInfo_MajorVersion="
#define FIELDNAME__OS_MINORVERSION	"StressExeOSInfo_MinorVersion="
#define FIELDNAME__OS_EXTRAINFO		"StressExeOSInfo_ExtraInfo="

// User Info
#define FIELDNAME__USERINFO_USERALIAS		"StressExeUserInfo_Alias="
#define FIELDNAME__USERINFO_USERDOMAIN		"StressExeUserInfo_Domain="
#define FIELDNAME__USERINFO_FULLNAME		"StressExeUserInfo_FullName="
#define FIELDNAME__USERINFO_MACHINENAME		"StressExeUserInfo_MachineName="

// Test info
#define FIELDNAME__TESTINFO_TEST_DLL_VERSION	"StressExeTestInfo_TestDLLVersion="


class ServerCommands  
{
public:

	// *****************************************************
	// *****************************************************
	// ** Public ServerCommands methods
	// ** 
			ServerCommands();
	virtual	~ServerCommands();

	BOOL	QueryServerForCommands();

	BOOL	IsStressRunning();
	BOOL	IsTimeToBeginStress();
	BOOL	IsTimeToExitStress();

	BOOL	Download_WinHttpDLL();

	VOID	Clear_StressExeURLs();

	LPSTR	Get_ClientMachineName();
	DWORD	Get_CommandServerUpdateInterval();
	LPTSTR	Get_CommandServerResultsURL();
	LPTSTR	Get_CommandServerURL();
	LPTSTR	Get_CurrentWorkingDirectory();
	DWORD	Get_NumberOfStressInstances();
	LPTSTR	Get_TestDllFileName();

	VOID	Create_StressInstance(DWORD, LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR);

	BOOL	RegisterClient();

	VOID	Set_WinHttpDllURL(LPTSTR, DWORD);
	VOID	Set_WinHttpPDBURL(LPTSTR, DWORD);
	VOID	Set_WinHttpSYMURL(LPTSTR, DWORD);
	VOID	Set_CommandServerURL(LPTSTR, DWORD);
	VOID	Set_CommandServerUpdateInterval(DWORD);
	VOID	Set_TimeStressBegins(LPTSTR, LPTSTR);
	VOID	Set_TimeStressEnds(LPTSTR, LPTSTR);
	VOID	Set_RunForever(BOOL);
	VOID	Set_ExitStress(BOOL);

	VOID	BeginStress();
	VOID	EndStress();
	VOID	AbortStressInstance(DWORD);


private:
	// *****************************************************
	// *****************************************************
	// ** These vars contain commands(headers) from the command server
	// **
	LPTSTR		m_szCommandServerURL;					// Command server URL to request commands from
	LPTSTR		m_szCommandServerResultsURL;			// Command server URL where the results will be posted

	DWORD		m_dwCommandServerUpdateInternval;		// Time to wait to ping the server for commands in milliseconds.

	LPTSTR		m_szWinHttpDLL_DownloadURL;				// Where to get the latest WinHttp from
	LPTSTR		m_szWinHttpPDB_DownloadURL;				// Where winhttp's PDB symbol file from
	LPTSTR		m_szWinHttpSYM_DownloadURL;				// Where winhttp's SYM symbol file from
	LPTSTR		m_szWinHttpDLL_FileName;				// Filename of the WinHttp DLL.

	LPSTR		m_szClientMachineName;					// Computer name of the client
	LPTSTR		m_szStressSchedulerCurrentDirectory;	// stressScheduler's current directory.

	INT			m_iTimeStressBeginsHour;				// 0-23
	INT			m_iTimeStressBeginsMinute;				// 0-59
	INT			m_iTimeStressEndsHour;					// 0-23
	INT			m_iTimeStressEndsMinute;				// 0-59

	BOOL		m_bRunForever;							// 1 to run stress until stopped and 0 to rely on begin/end times

	BOOL		m_bExit;								// Quit signal from server to exit the app
	BOOL		m_bStressHasStarted;					// TRUE = started; FALSE = inactive

	PSTRESSINSTANCE_LIST			m_arStressInstanceList;		// List of URLs for the stress EXEs to download
	PSTRESSINSTANCE_LIST::iterator	m_dwStressInstanceIterator;	// Iterator for m_arszStressExeList
};

#endif // !defined(AFX_SERVERCOMMANDS_H__6B84102D_2F79_4FE0_A936_ED4F043AC75E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\networktools.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  NetworkTools.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	NetworkTools.cpp: Helper functions that send/receive data.
//
// History:
//	02/22/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//
// Includes
//
//////////////////////////////////////////////////////////////////////

//
// Project headers
//
#include "NetworkTools.h"
#include "ServerCommands.h"

//
// Win32 headers
//


//////////////////////////////////////////////////////////////////////
//
// Globals and statics
//
//////////////////////////////////////////////////////////////////////
extern ServerCommands	g_objServerCommands;	// Declared in WinHttpStressScheduler.cpp
extern HWND				g_hWnd;					// Declared in WinHttpStressScheduler.cpp


////////////////////////////////////////////////////////////
// Function:  NetworkTools__GetFileNameFromURL(LPTSTR)
//
// Purpose:
//	Returns the filename requested from an URL without a querystring.
//	For example, if szURL="http://dennisch/files/test.exe" we return "test.exe"
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__GetFileNameFromURL(
	LPTSTR	szURL,			// [IN]		Full URL containing the file
	LPTSTR	szBuffer,		// [OUT]	Buffer to store the filename from the URL
	DWORD	dwBufferSize	// [IN]		Size of buffer szFileName
)
{
	TCHAR	*pLastSlash;
	INT		iCharToLookFor;

	if (0 >= _tcslen(szURL))
		return FALSE;

	ZeroMemory(szBuffer, dwBufferSize);

	pLastSlash		= NULL;
	iCharToLookFor	= _T('/');

	// get the last instance of '/'
	pLastSlash = _tcsrchr(szURL, iCharToLookFor);

	// skip the last '/'
	pLastSlash++;

	if (!pLastSlash)
		return FALSE;

	// copy the filename.extension to the buffer
	_tcscpy(szBuffer, pLastSlash);

	return TRUE;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__SendResponse(LPTSTR, LPTSTR, LPTSTR)
//
// Purpose:
//	Sends a message to the Command Server results page 
//	via header/headervalue and/or POST data.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__POSTResponse(
	LPTSTR	szURL,		// [IN] string containing URL to POST to
	LPSTR	szPostData,	// [IN] string containing POST data to send. can be NULL
	LPTSTR	szHeader	// [IN] string containing header(s) to send. can be NULL
)
{
	BOOL			bResult		= TRUE;
	HINTERNET		hRoot		= NULL;
	HINTERNET		hSession	= NULL;
	HINTERNET		hRequest	= NULL;
	URL_COMPONENTSW	urlComponents;


	// Allocate space for URL components
	ZeroMemory(&urlComponents, sizeof(urlComponents));

	urlComponents.dwSchemeLength	= MAX_PATH;
	urlComponents.lpszScheme		= new TCHAR[MAX_PATH];

	urlComponents.dwHostNameLength  = MAX_PATH;
	urlComponents.lpszHostName		= new TCHAR[MAX_PATH];

	urlComponents.dwUrlPathLength	= MAX_PATH;
	urlComponents.lpszUrlPath		= new TCHAR[MAX_PATH];

	urlComponents.dwExtraInfoLength = MAX_PATH;
	urlComponents.lpszExtraInfo		= new TCHAR[MAX_PATH];
	
	urlComponents.dwUserNameLength	= MAX_PATH;
	urlComponents.lpszUserName		= new TCHAR[MAX_PATH];

	urlComponents.dwPasswordLength	= MAX_PATH;
	urlComponents.lpszPassword		= new TCHAR[MAX_PATH];
	
	urlComponents.nPort				= 0;

	urlComponents.dwStructSize		= sizeof(URL_COMPONENTSW);


	// crack the Command Server URL to be used later
	if (!WinHttpCrackUrl(
			szURL,
			_tcslen(szURL),
			ICU_ESCAPE,
			&urlComponents)
		)
	{
		bResult = FALSE;
		goto Exit;
	}

	hRoot = WinHttpOpen(
		STRESS_SCHEDULER_USER_AGENT,
		WINHTTP_ACCESS_TYPE_NO_PROXY,
		NULL,
		NULL,
		0);

	if (!hRoot)
	{
		bResult = FALSE;
		goto Exit;
	}

	hSession = WinHttpConnect(
		hRoot,
		urlComponents.lpszHostName,
		// If the URL in urlComponents uses standard HTTP or HTTPS ports then use INTERNET_DEFAULT_PORT. Otherwise use the non-standard port gleaned from the URL.
		((urlComponents.nPort == 80) || (urlComponents.nPort == 443)) ? INTERNET_DEFAULT_PORT : urlComponents.nPort,
		0);
	
	if (!hSession)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Build a full URL with path and querystring
	TCHAR szFullPath[MAX_PATH*2];

	_tcsncpy(szFullPath, urlComponents.lpszUrlPath, urlComponents.dwUrlPathLength);
	szFullPath[urlComponents.dwUrlPathLength] = _T('\0');
	_tcsncat(szFullPath, urlComponents.lpszExtraInfo, urlComponents.dwExtraInfoLength);

	hRequest = WinHttpOpenRequest(
		hSession,
		_T("POST"),
		szFullPath,
		NULL,
		NULL,
		NULL,
		// if the URL in urlComponents uses HTTPS then pass in WINHTTP_FLAG_SECURE to this param. Otherwise, 0.
		(0 == _tcsnicmp(urlComponents.lpszScheme, _T("https"), 5)) ? WINHTTP_FLAG_SECURE : 0);

	if (!hRequest)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Set reasonable timeouts just in case
	if (!WinHttpSetTimeouts(hRequest, 5000, 5000, 5000, 5000))
	{
		bResult = FALSE;
		goto Exit;
	}

	// Set result header if not NULL
	if (szHeader)
	{
		if (!WinHttpAddRequestHeaders(
				hRequest,
				szHeader,
				_tcsclen(szHeader),
				WINHTTP_ADDREQ_FLAG_ADD))
		{
			bResult = FALSE;
			goto Exit;
		}
	}


	bResult = WinHttpSendRequest(
		hRequest,
		_T("Content-Type: application/x-www-form-urlencoded"),
		-1L, 
		szPostData,
		strlen(szPostData),
		strlen(szPostData),
		0);

	if (!WinHttpReceiveResponse(hRequest, NULL))
	{
		bResult = FALSE;
		goto Exit;
	}


Exit:
	if (hRequest)
		WinHttpCloseHandle(hRequest);

	if (hSession)
		WinHttpCloseHandle(hSession);

	if (hRoot)
		WinHttpCloseHandle(hRoot);

	delete [] urlComponents.lpszScheme;
	delete [] urlComponents.lpszHostName;
	delete [] urlComponents.lpszUrlPath;
	delete [] urlComponents.lpszExtraInfo;
	delete [] urlComponents.lpszPassword;
	delete [] urlComponents.lpszUserName;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__URLDownloadToFile(LPCTSTR, LPCTSTR, LPCTSTR)
//
// Purpose:
//	Downloads a file pointed to by the URL. Returns TRUE if succesfully downloaded.
//  FALSE if not. If the file is in use (ERROR_SHARING_VIOLATION) then we'll
//	return TRUE because the file is already on the system and is valid.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__URLDownloadToFile(
LPCTSTR szURL,			// [IN] Fully qualified URL pointing to the file to download
LPCTSTR szTargetDir,	// [IN] A relative path to the directory to put szTargetFile in. If NULL, then it'll be put in the app's current dir.
LPCTSTR szTargetFile	// [IN] Name of the file to download to. Can be NULL. File will be placed in szTargetDir. If it already exists, then we'll try to overwrite it.
)
{
	HANDLE			hFile		= NULL;
	BOOL			bResult		= TRUE;
	HINTERNET		hRoot		= NULL;
	HINTERNET		hSession	= NULL;
	HINTERNET		hRequest	= NULL;
	URL_COMPONENTSW	urlComponents;


	// Allocate space for URL components
	ZeroMemory(&urlComponents, sizeof(urlComponents));

	urlComponents.dwSchemeLength	= MAX_PATH;
	urlComponents.lpszScheme		= new TCHAR[MAX_PATH];

	urlComponents.dwHostNameLength  = MAX_PATH;
	urlComponents.lpszHostName		= new TCHAR[MAX_PATH];

	urlComponents.dwUrlPathLength	= MAX_PATH;
	urlComponents.lpszUrlPath		= new TCHAR[MAX_PATH];

	urlComponents.dwExtraInfoLength = MAX_PATH;
	urlComponents.lpszExtraInfo		= new TCHAR[MAX_PATH];
	
	urlComponents.dwUserNameLength	= MAX_PATH;
	urlComponents.lpszUserName		= new TCHAR[MAX_PATH];

	urlComponents.dwPasswordLength	= MAX_PATH;
	urlComponents.lpszPassword		= new TCHAR[MAX_PATH];
	
	urlComponents.nPort				= 0;

	urlComponents.dwStructSize		= sizeof(URL_COMPONENTSW);


	// crack the Command Server URL to be used later
	if (!WinHttpCrackUrl(
			szURL,
			_tcslen(szURL),
			ICU_ESCAPE,
			&urlComponents)
		)
	{
		bResult = FALSE;
		goto Exit;
	}

	hRoot = WinHttpOpen(
		STRESS_SCHEDULER_USER_AGENT,
		WINHTTP_ACCESS_TYPE_NO_PROXY,
		NULL,
		NULL,
		0);

	if (!hRoot)
	{
		bResult = FALSE;
		goto Exit;
	}

	hSession = WinHttpConnect(
		hRoot,
		urlComponents.lpszHostName,
		// If the URL in urlComponents uses standard HTTP or HTTPS ports then use INTERNET_DEFAULT_PORT. Otherwise use the non-standard port gleaned from the URL.
		((urlComponents.nPort == 80) || (urlComponents.nPort == 443)) ? INTERNET_DEFAULT_PORT : urlComponents.nPort,
		0);
	
	if (!hSession)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Build a full URL with path and querystring
	TCHAR szFullPath[MAX_PATH*2];

	_tcsncpy(szFullPath, urlComponents.lpszUrlPath, urlComponents.dwUrlPathLength);
	szFullPath[urlComponents.dwUrlPathLength] = _T('\0');
	_tcsncat(szFullPath, urlComponents.lpszExtraInfo, urlComponents.dwExtraInfoLength);

	hRequest = WinHttpOpenRequest(
		hSession,
		_T("GET"),
		szFullPath,
		NULL,
		NULL,
		NULL,
		// if the URL in urlComponents uses HTTPS then pass in WINHTTP_FLAG_SECURE to this param. Otherwise, 0.
		(0 == _tcsnicmp(urlComponents.lpszScheme, _T("https"), 5)) ? WINHTTP_FLAG_SECURE : 0);

	if (!hRequest)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Set reasonable timeouts just in case
	if (!WinHttpSetTimeouts(hRequest, 5000, 5000, 5000, 5000))
	{
		bResult = FALSE;
		goto Exit;
	}


	bResult = WinHttpSendRequest(
		hRequest,
		NULL,
		0, 
		NULL,
		0,
		0,
		0);

	if (!WinHttpReceiveResponse(hRequest, NULL))
	{
		bResult = FALSE;
		goto Exit;
	}


	// **********************************
	// **********************************
	// ** Get the filename and extenstion
	// ** from the URL
	// **
	TCHAR	szFileName[MAX_PATH];		// name of the new file to write to. will be created in szCurrentDir

	ZeroMemory(szFileName, sizeof(szFileName));

	// check to see if the user provided a filename to write to
	if (szTargetFile)
		_tcsncpy(szFileName, szTargetFile, MAX_PATH);
	else
	{
		// user did not specify a filename to write to, so we use the original one from the URL
		if (!NetworkTools__GetFileNameFromURL(urlComponents.lpszUrlPath, szFileName, sizeof(szFileName)))
		{
			bResult = FALSE;
			goto Exit;
		}
	}


	// **********************************
	// **********************************
	// ** Create the directory where the file will reside and set it as the current directory
	// **
	
	// if user specified NULL, then we put the file in the current dir.
	// else we set the current directory as the one specified
	if (szTargetDir)
	{
		// create the dir. don't care if it fails because it already exists...
		CreateDirectory(szTargetDir, NULL);
		SetCurrentDirectory(szTargetDir);
	}


	// create the file to download to.
	hFile = CreateFile(
		// if the user doesn't specify the filename to write to, use the one from the URL
		szFileName,
		GENERIC_WRITE,
		0,
		NULL,
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
		NULL);


	if ((hFile == INVALID_HANDLE_VALUE) || !hFile)
	{
		// We won't return FALSE if the file is in use. This means the file is valid.
		if (ERROR_SHARING_VIOLATION == GetLastError())
		{
			// File is in use that means winhttp is ok. we'll stress the old version
			bResult = TRUE;
			goto Exit;
		}
		else
		{
			bResult = FALSE;
			goto Exit;
		}
	}

	// **********************************
	// **********************************
	// ** Read data from net to file.
	// **
	LPVOID	lpBuffer;
	DWORD	dwBytesToRead, dwBytesRead;

	// read 64K chunks at a time
	lpBuffer		= NULL;
	lpBuffer		= new LPVOID[65536];
	ZeroMemory(lpBuffer, 65536);
	dwBytesToRead	= 65536;
	dwBytesRead		= 65536;

	while (WinHttpReadData(hRequest, lpBuffer, dwBytesToRead, &dwBytesRead) && (0 != dwBytesRead))
	{
		WriteFile(hFile, lpBuffer, dwBytesRead, &dwBytesRead, NULL);

		dwBytesRead = 0;
		ZeroMemory(lpBuffer, sizeof(lpBuffer));
	}

	delete [] lpBuffer;

Exit:
	if (hRequest)
		WinHttpCloseHandle(hRequest);

	if (hSession)
		WinHttpCloseHandle(hSession);

	if (hRoot)
		WinHttpCloseHandle(hRoot);

	if (hFile && (hFile != INVALID_HANDLE_VALUE))
		CloseHandle(hFile);

	// restore the current directory from the one that we created the new file in.
	SetCurrentDirectory(g_objServerCommands.Get_CurrentWorkingDirectory());

	delete [] urlComponents.lpszScheme;
	delete [] urlComponents.lpszHostName;
	delete [] urlComponents.lpszUrlPath;
	delete [] urlComponents.lpszExtraInfo;
	delete [] urlComponents.lpszPassword;
	delete [] urlComponents.lpszUserName;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__CopyFile(LPCTSTR, LPCTSTR)
//
// Purpose:
//	Wrapper for CopyFile. Copies file szSource to szDestination.
//	We'll always overwite the file if it already exists.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__CopyFile(
	LPCTSTR szSource,
	LPCTSTR szDestination
)
{
	BOOL bResult = TRUE;
	
	if (!szSource || !szDestination)
	{
		bResult = FALSE;
		goto Exit;
	}

	bResult = CopyFile(szSource, szDestination, TRUE);

Exit:
	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__PageHeap(BOOL, LPCTSTR)
//
// Purpose:
//	Enables/Disables pageheap.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__PageHeap(
	BOOL	bEnable,		// [IN] Enables/Disables pageheap.
	LPCTSTR	szAppName,		// [IN] The executable to enable or disable.
	LPCTSTR	szCommandLine	// [IN] Command line for pageheap.
)
{
	BOOL		bResult	= TRUE;
	HINSTANCE	hExe	= NULL;
	LPTSTR		szPHCommand = new TCHAR[MAX_PATH];

	if (bEnable)
	{
		hExe = ShellExecute(g_hWnd, _T("open"), _T("pageheap.exe"), szCommandLine, NULL, SW_SHOWMINIMIZED);
	}
	else
	{
		ZeroMemory(szPHCommand, MAX_PATH);
		_tcscpy(szPHCommand, _T("/disable "));
		_tcscat(szPHCommand, szAppName);
		hExe = ShellExecute(g_hWnd, _T("open"), _T("pageheap.exe"), szPHCommand, NULL, SW_SHOWMINIMIZED);
	}

	// Error if HINSTANCE <= 32.
	if (32 >= (INT) hExe)
		bResult = FALSE;

	delete [] szPHCommand;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__UMDH(LPCTSTR, DWORD, LPCTSTR)
//
// Purpose:
//	Enables/Disables UMDH.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__UMDH(
	BOOL	bEnable,		// [IN] Enables/Disables UMDH.
	LPCTSTR	szAppName,		// [IN] The executable to dump.
	LPCTSTR	szCommandLine,	// [IN] Command line for UMDH.
	LPCTSTR szLogFile,		// [IN] Logfile to create
	DWORD	dwPID			// [IN] The PID of the process to dump
)
{
	BOOL		bResult	= TRUE;
	HINSTANCE	hExe	= NULL;
	LPTSTR		szCommand = new TCHAR[MAX_PATH];

	// build command line and run: "GFLAGS -i <stressExe name> +ust"
	ZeroMemory(szCommand, MAX_PATH);
	_tcscpy(szCommand, _T("-i "));
	_tcscat(szCommand, szAppName);
	_tcscat(szCommand, _T(" +ust"));
	hExe = ShellExecute(g_hWnd, _T("open"), DEBUGGER_TOOLS_PATH _T("gflags.exe"), szCommand, NULL, SW_SHOWMINIMIZED);


	// build the UMDH command line
	ZeroMemory(szCommand, MAX_PATH);
	_tcscpy(szCommand, _T("-f:stuff.log"));

	hExe = ShellExecute(g_hWnd, _T("open"), DEBUGGER_TOOLS_PATH _T("umdh.exe"), szCommand, NULL, SW_SHOWMINIMIZED);

	// Error if HINSTANCE <= 32.
	if (32 >= (INT) hExe)
		bResult = FALSE;

	delete [] szCommand;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__SendLog(LPSTR, LPSTR, LPTSTR, DWORD)
//
// Purpose:
//	Sends a log to the Command Server. Takes the log type string and log string.
//	Sends the stressInstance ID and client machine name as part of the POST request.
//	If this is a general message, then the stressInstanceID should be set to zero. Otherwise
//	if and ID is supplied, then stressAdmin will log this to the stressInstanceLog table.
//	You can also add headers too.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__SendLog(
	LPSTR	szLogType,
	LPSTR	szLogText,
	LPTSTR	szExtraHeaders,
	DWORD	dwStressInstanceID
)
{
	BOOL	bResult				= TRUE;
	LPSTR	szPostLogData		= NULL;
	CHAR	szStressInstanceID[10];
	LPSTR	szDllVersion		= new CHAR[MAX_PATH];
	LPSTR	szNumber			= new CHAR[10];
	DWORD	dwPostLogDataSize	= 0;

	if (!szLogType || !szLogText || !g_objServerCommands.Get_ClientMachineName())
	{
		OutputDebugStringA("NetworkTools__SendLog: ERROR: szLogType, szLogText, or g_objServerCommands.Get_ClientMachineName() is NULL.");
		bResult = FALSE;
		goto Exit;
	}

	dwPostLogDataSize	=	sizeof(FIELDNAME__STRESSINSTANCE_ID) + MAX_PATH;
	dwPostLogDataSize	+=	sizeof(FIELDNAME__LOG_TEXT) + strlen(szLogText);
	dwPostLogDataSize	+=	sizeof(FIELDNAME__USERINFO_MACHINENAME) + strlen(g_objServerCommands.Get_ClientMachineName());
	dwPostLogDataSize	+=	strlen(szLogType);
	dwPostLogDataSize	+=	sizeof(FIELDNAME__TESTINFO_TEST_DLL_VERSION) + MAX_PATH;

	szPostLogData		= new CHAR[dwPostLogDataSize];

	ZeroMemory(szPostLogData, dwPostLogDataSize);

	// ***************************
	// ** add the client's machine name
	strcpy(szPostLogData, FIELDNAME__USERINFO_MACHINENAME);
	strcat(szPostLogData, g_objServerCommands.Get_ClientMachineName());


	// ***************************
	// ** add the stressInstance ID if valid
	if (0 < dwStressInstanceID)
	{
		strcat(szPostLogData, "&" FIELDNAME__STRESSINSTANCE_ID);
		strcat(szPostLogData, _itoa(dwStressInstanceID, szStressInstanceID, 10));
	}


	// ***************************
	// ** add the log type data
	strcat(szPostLogData, "&");
	strcat(szPostLogData, szLogType);


	// ***************************
	// ** add the test dll version info
	if (
		g_objServerCommands.Get_TestDllFileName() &&
		NetworkTools__GetDllVersion(g_objServerCommands.Get_TestDllFileName(), szDllVersion, MAX_PATH)
		)
	{
		strcat(szPostLogData, "&" FIELDNAME__TESTINFO_TEST_DLL_VERSION);
		strcat(szPostLogData, szDllVersion);
	}


	// ***************************
	// ** add the log text data
	strcat(szPostLogData, "&" FIELDNAME__LOG_TEXT);
	strcat(szPostLogData, szLogText);


	// ***************************
	// ** Send the data
	bResult = NetworkTools__POSTRespon