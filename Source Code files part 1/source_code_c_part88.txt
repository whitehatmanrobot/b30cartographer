        //

            SingleReadSize = Minimum(Length, 32 * 1024);
            SingleReadSize = Minimum((ULONG)SingleReadSize, CurrentRunByteCount);

            //
            //  Don't read beyond the eof
            //

            if (((ULONG)SingleReadSize + FileTableEntry->Position.LowPart) >
                FileTableEntry->u.FatFileContext.Dirent.FileSize) {

                SingleReadSize = FileTableEntry->u.FatFileContext.Dirent.FileSize -
                                 FileTableEntry->Position.LowPart;

                //
                //  If the readjusted read length is now zero then we're done.
                //

                if (SingleReadSize <= 0) {

                    return ESUCCESS;
                }

                //
                //  By also setting length here we'll make sure that this is our last
                //  read
                //

                Length = SingleReadSize;
            }

            //
            //  Issue the read
            //

            DiskRead( DeviceId, Lbo, SingleReadSize, Buffer, DONT_CACHE_NEW_DATA, FALSE );

            //
            //  Update the remaining length, Current run byte count
            //  and new Lbo offset
            //

            Length -= SingleReadSize;
            CurrentRunByteCount -= SingleReadSize;
            Lbo += SingleReadSize;

            //
            //  Update the current position and the number of bytes transfered
            //

            FileTableEntry->Position.LowPart += SingleReadSize;
            *Transfer += SingleReadSize;

            //
            //  Update buffer to point to the next byte location to fill in
            //

            Buffer = (PCHAR)Buffer + SingleReadSize;
        }
    }

    //
    //  If we get here then remaining sector count is zero so we can
    //  return success to our caller
    //

    return ESUCCESS;
}


ARC_STATUS
FatRename(
    IN ULONG FileId,
    IN CHAR * FIRMWARE_PTR NewFileName
    )

/*++

Routine Description:

    This routine renames an open file.  It does no checking to
    see if the target filename already exists.  It is intended for use
    only when dual-booting DOS on x86 machines, where it is used to
    replace the NT MVDM CONFIG.SYS and AUTOEXEC.BAT with the native DOS
    CONFIG.SYS and AUTOEXEC.BAT files.

Arguments:

    FileId - Supplies the file id of the file to be renamed

    NewFileName - Supplies the new name for the file.

Return Value:

    ARC_STATUS

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PFAT_STRUCTURE_CONTEXT FatStructureContext;
    ULONG DeviceId;
    FAT8DOT3 FatName;
    STRING String;

    //
    //  Initialize our local variables
    //

    RtlInitString( &String, NewFileName );
    FileTableEntry = &BlFileTable[FileId];
    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    DeviceId = FileTableEntry->DeviceId;

    //
    //  Modify a in-memory copy of the dirent with the new name
    //

    FatFirstComponent( &String, (PFAT8DOT3) FatName );

    FatSetDirent( (PFAT8DOT3) FatName,
                  &FileTableEntry->u.FatFileContext.Dirent,
                  FileTableEntry->u.FatFileContext.Dirent.Attributes );

    //
    //  Write the modified dirent to disk
    //

    DiskWrite( DeviceId,
               FileTableEntry->u.FatFileContext.DirentLbo,
               sizeof(DIRENT),
               &FileTableEntry->u.FatFileContext.Dirent );

    //
    //  And return to our caller
    //

    return ESUCCESS;
}


ARC_STATUS
FatSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    This routine seeks to the specified position for the file specified
    by the file id.

Arguments:

    FileId - Supplies the file table index.

    Offset - Supplies the offset in the file to position to.

    SeekMode - Supplies the mode of the seek operation.

Return Value:

    ESUCCESS is returned if the seek operation is successful.  Otherwise,
    EINVAL is returned.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    ULONG NewPosition;

    FatDebugOutput("FatSeek\r\n", 0, 0);

    //
    //  Load our local variables
    //

    FileTableEntry = &BlFileTable[FileId];

    //
    //  Compute the new position
    //

    if (SeekMode == SeekAbsolute) {

        NewPosition = Offset->LowPart;

    } else {

        NewPosition = FileTableEntry->Position.LowPart + Offset->LowPart;
    }

    //
    //  If the new position is greater than the file size then return
    //  an error
    //

    if (NewPosition > FileTableEntry->u.FatFileContext.Dirent.FileSize) {

        return EINVAL;
    }

    //
    //  Otherwise set the new position and return to our caller
    //

    FileTableEntry->Position.LowPart = NewPosition;

    return ESUCCESS;
}


ARC_STATUS
FatSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    )

/*++

Routine Description:

    This routine sets the file attributes of the indicated file

Arguments:

    FileId - Supplies the File Id for the operation

    AttributeFlags - Supplies the value (on or off) for each attribute being modified

    AttributeMask - Supplies a mask of the attributes being altered.  All other
        file attributes are left alone.

Return Value:

    EROFS is always returned
    
--*/

{
    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( AttributeFlags );
    UNREFERENCED_PARAMETER( AttributeMask );

    FatDebugOutput("FatSetFileInformation\r\n", 0, 0);
    
    return EROFS;
 
}


ARC_STATUS
FatWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Transfer
    )

/*++

Routine Description:

    This routine writes data to the specified file.

Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a pointer to the buffer that contains the data
        written.

    Length - Supplies the number of bytes that are to be written.

    Transfer - Supplies a pointer to a variable that receives the number
        of bytes actually transfered.

Return Value:

    ESUCCESS is returned if the write operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PFAT_STRUCTURE_CONTEXT FatStructureContext;
    ULONG DeviceId;
    ULONG OffsetBeyondWrite;

    FatDebugOutput("FatWrite\r\n", 0, 0);

    //
    //  Load our local variables
    //

    FileTableEntry = &BlFileTable[FileId];
    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    DeviceId = FileTableEntry->DeviceId;

    //
    //  Reset the file size to be the maximum of what is it now and the end of
    //  our write.  We will assume that there is always enough allocation to support
    //  the file size, so we only need to increase allocation if we are increasing
    //  the file size.
    //

    OffsetBeyondWrite = FileTableEntry->Position.LowPart + Length;

    if (OffsetBeyondWrite > FileTableEntry->u.FatFileContext.Dirent.FileSize) {

        IncreaseFileAllocation( FileId, OffsetBeyondWrite );

        FileTableEntry->u.FatFileContext.Dirent.FileSize = OffsetBeyondWrite;

        DiskWrite( DeviceId,
                   FileTableEntry->u.FatFileContext.DirentLbo,
                   sizeof(DIRENT),
                   &FileTableEntry->u.FatFileContext.Dirent );
    }

    //
    //  Clear the transfer count
    //

    *Transfer = 0;

    //
    //  Write out runs (i.e., bytes) until the byte count goes to zero
    //

    while (Length > 0) {

        LBO Lbo;

        ULONG CurrentRunByteCount;

        //
        //  Lookup the corresponding Lbo and run length for the current position
        //  (i.e., Vbo).
        //

        VboToLbo( FileId, FileTableEntry->Position.LowPart, &Lbo, &CurrentRunByteCount );

        //
        //  While there are bytes to be written out to the current run
        //  length and we haven't exhausted the request we loop reading
        //  in bytes.  The biggest request we'll handle is only 32KB
        //  contiguous bytes per physical read.  So we might need to loop
        //  through the run.
        //

        while ((Length > 0) && (CurrentRunByteCount > 0)) {

            LONG SingleWriteSize;

            //
            //  Compute the size of the next physical read
            //

            SingleWriteSize = Minimum(Length, 32 * 1024);
            SingleWriteSize = Minimum((ULONG)SingleWriteSize, CurrentRunByteCount);

            //
            //  Issue the Write
            //

            DiskWrite( DeviceId, Lbo, SingleWriteSize, Buffer);

            //
            //  Update the remaining length, Current run byte count
            //  and new Lbo offset
            //

            Length -= SingleWriteSize;
            CurrentRunByteCount -= SingleWriteSize;
            Lbo += SingleWriteSize;

            //
            //  Update the current position and the number of bytes transfered
            //

            FileTableEntry->Position.LowPart += SingleWriteSize;
            *Transfer += SingleWriteSize;

            //
            //  Update buffer to point to the next byte location to fill in
            //

            Buffer = (PCHAR)Buffer + SingleWriteSize;
        }
    }

    //
    //  Check if the fat is dirty and flush it out if it is.
    //

    if (FatStructureContext->CachedFatDirty) {

        FlushFatEntries( FatStructureContext, DeviceId );
    }

    //
    //  If we get here then remaining sector count is zero so we can
    //  return success to our caller
    //

    return ESUCCESS;
}


ARC_STATUS
FatInitialize (
    VOID
    )

/*++

Routine Description:

    This routine initializes the fat boot filesystem.
    Currently this is a no-op.

Arguments:

    None.

Return Value:

    ESUCCESS.

--*/

{
    return ESUCCESS;
}


//
//  Internal support routine
//

ARC_STATUS
FatDiskRead (
    IN ULONG DeviceId,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PVOID Buffer,
    IN BOOLEAN CacheNewData
    )

/*++

Routine Description:

    This routine reads in zero or more bytes from the specified device.

Arguments:

    DeviceId - Supplies the device id to use in the arc calls.

    Lbo - Supplies the LBO to start reading from.

    ByteCount - Supplies the number of bytes to read.

    Buffer - Supplies a pointer to the buffer to read the bytes into.

Return Value:

    ESUCCESS is returned if the read operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    LARGE_INTEGER LargeLbo;
    ARC_STATUS Status;
    ULONG i;

    //
    //  Special case the zero byte read request
    //

    if (ByteCount == 0) {

        return ESUCCESS;
    }

    //
    // Issue the read through the cache.
    //

    LargeLbo.QuadPart = Lbo;
    Status = BlDiskCacheRead(DeviceId, 
                             &LargeLbo, 
                             Buffer, 
                             ByteCount, 
                             &i,
                             CacheNewData);

    if (Status != ESUCCESS) {

        return Status;
    }

    //
    //  Make sure we got back the amount requested
    //

    if (ByteCount != i) {

        return EIO;
    }

    //
    //  Everything is fine so return success to our caller
    //

    return ESUCCESS;
}


//
//  Internal support routine
//

ARC_STATUS
FatDiskWrite (
    IN ULONG DeviceId,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This routine writes in zero or more bytes to the specified device.

Arguments:

    DeviceId - Supplies the device id to use in the arc calls.

    Lbo - Supplies the LBO to start writing from.

    ByteCount - Supplies the number of bytes to write.

    Buffer - Supplies a pointer to the buffer of bytes to write out.

Return Value:

    ESUCCESS is returned if the write operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    LARGE_INTEGER LargeLbo;
    ARC_STATUS Status;
    ULONG i;

    //
    //  Special case the zero byte write request
    //

    if (ByteCount == 0) {

        return ESUCCESS;
    }

    //
    //  Issue the write through the cache.
    //

    LargeLbo.QuadPart = Lbo;

    Status = BlDiskCacheWrite (DeviceId,
                               &LargeLbo,
                               Buffer,
                               ByteCount,
                               &i);

    if (Status != ESUCCESS) {

        return Status;
    }

    //
    //  Make sure we wrote out the amount requested
    //

    if (ByteCount != i) {

        return EIO;
    }

    //
    //  Everything is fine so return success to our caller
    //

    return ESUCCESS;
}


//
//  Internal support routine
//

CLUSTER_TYPE
FatInterpretClusterType (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN FAT_ENTRY Entry
    )

/*++

Routine Description:

    This procedure tells the caller how to interpret a fat table entry.  It will
    indicate if the fat cluster is available, reserved, bad, the last one, or another
    fat index.

Arguments:

    FatStructureContext - Supplies the volume structure for the operation

    DeviceId - Supplies the DeviceId for the volume being used.

    Entry - Supplies the fat entry to examine.

Return Value:

    The type of the input fat entry is returned

--*/

{
    //
    //  Check for 12 or 16 bit fat.
    //

    if (FatIndexBitSize(&FatStructureContext->Bpb) == 12) {

        //
        //  For 12 bit fat check for one of the cluster types, but first
        //  make sure we only looking at 12 bits of the entry
        //

        Entry &= 0x00000fff;

        if       (Entry == 0x000)                      { return FatClusterAvailable; }
        else if ((Entry >= 0xff0) && (Entry <= 0xff6)) { return FatClusterReserved; }
        else if  (Entry == 0xff7)                      { return FatClusterBad; }
        else if ((Entry >= 0xff8) && (Entry <= 0xfff)) { return FatClusterLast; }
        else                                           { return FatClusterNext; }

   } else if (FatIndexBitSize(&FatStructureContext->Bpb) == 32) {

        Entry &= 0x0fffffff;

        if       (Entry == 0x0000)                       { return FatClusterAvailable; }
        else if  (Entry == 0x0ffffff7)                   { return FatClusterBad; }
        else if ((Entry >= 0x0ffffff8))                  { return FatClusterLast; }
        else                                             { return FatClusterNext; }

   } else {

        //
        //  For 16 bit fat check for one of the cluster types, but first
        //  make sure we are only looking at 16 bits of the entry
        //

        Entry &= 0x0000ffff;

        if       (Entry == 0x0000)                       { return FatClusterAvailable; }
        else if ((Entry >= 0xfff0) && (Entry <= 0xfff6)) { return FatClusterReserved; }
        else if  (Entry == 0xfff7)                       { return FatClusterBad; }
        else if ((Entry >= 0xfff8) && (Entry <= 0xffff)) { return FatClusterLast; }
        else                                             { return FatClusterNext; }
    }
}


//
//  Internal support routine
//

ARC_STATUS
FatLookupFatEntry (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN ULONG FatIndex,
    OUT PULONG FatEntry,
    IN BOOLEAN IsDoubleSpace
    )

/*++

Routine Description:

    This routine returns the value stored within the fat table and the specified
    fat index.  It is semantically equivalent to doing

        x = Fat[FatIndex]

Arguments:

    FatStrutureContext - Supplies the volume struture being used

    DeviceId - Supplies the device being used

    FatIndex - Supplies the index being looked up.

    FatEntry - Receives the value stored at the specified fat index

    IsDoubleSpace - Indicates if the search is being done on a double space volume

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    BOOLEAN TwelveBitFat;
    VBO Vbo;

    //****if (IsDoubleSpace) { DbgPrint("FatLookupFatEntry(%0x,%0x,%0x,%0x,%0x)\n",FatStructureContext, DeviceId, FatIndex, FatEntry, IsDoubleSpace); }

    //
    //  Calculate the Vbo of the word in the fat we need and
    //  also figure out if this is a 12 or 16 bit fat
    //

    if (FatIndexBitSize( &FatStructureContext->Bpb ) == 12) {

        TwelveBitFat = TRUE;
        Vbo = (FatIndex * 3) / 2;

    } else if (FatIndexBitSize( &FatStructureContext->Bpb ) == 32) {

        TwelveBitFat = FALSE;
        Vbo = FatIndex * 4;

    } else {

        TwelveBitFat = FALSE;
        Vbo = FatIndex * 2;
    }

    //
    //  Check if the Vbo we need is already in the cached fat
    //

    if ((FatStructureContext->CachedFat == NULL) ||
        (Vbo < FatStructureContext->CachedFatVbo) ||
        ((Vbo+1) > (FatStructureContext->CachedFatVbo + FAT_CACHE_SIZE))) {

        //
        //  Set the aligned cached fat buffer in the structure context
        //

        FatStructureContext->CachedFat = ALIGN_BUFFER( &FatStructureContext->CachedFatBuffer[0] );

        //
        //  As a safety net we'll flush any dirty fats that we might have cached before
        //  we turn the window
        //

        if (!IsDoubleSpace && FatStructureContext->CachedFatDirty) {

            FlushFatEntries( FatStructureContext, DeviceId );
        }

        //
        //  Now set the new cached Vbo to be the Vbo of the cache sized section that
        //  we're trying to map.  Each time we read in the cache we only read in
        //  cache sized and cached aligned pieces of the fat.  So first compute an
        //  aligned cached fat vbo and then do the read.
        //

        FatStructureContext->CachedFatVbo = (Vbo / FAT_CACHE_SIZE) * FAT_CACHE_SIZE;

        DiskRead( DeviceId,
                  FatStructureContext->CachedFatVbo + FatFirstFatAreaLbo(&FatStructureContext->Bpb),
                  FAT_CACHE_SIZE,
                  FatStructureContext->CachedFat,
                  CACHE_NEW_DATA,
                  IsDoubleSpace );
    }

    //
    //  At this point the cached fat contains the vbo we're after so simply
    //  extract the word
    //

    if (IsBpbFat32(&FatStructureContext->Bpb)) {
        CopyUchar4( FatEntry,
                    &FatStructureContext->CachedFat[Vbo - FatStructureContext->CachedFatVbo] );
    } else {
        CopyUchar2( FatEntry,
                    &FatStructureContext->CachedFat[Vbo - FatStructureContext->CachedFatVbo] );
    }

    //
    //  Now if this is a 12 bit fat then check if the index is odd or even
    //  If it is odd then we need to shift it over 4 bits, and in all
    //  cases we need to mask out the high 4 bits.
    //

    if (TwelveBitFat) {

        if ((FatIndex % 2) == 1) { *FatEntry >>= 4; }

        *FatEntry &= 0x0fff;
    }

    return ESUCCESS;
}


//
//  Internal support routine
//

ARC_STATUS
FatSetFatEntry(
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN FAT_ENTRY FatIndex,
    IN FAT_ENTRY FatEntry
    )

/*++

Routine Description:

    This procedure sets the data within the fat table at the specified index to
    to the specified value.  It is semantically equivalent to doing

        Fat[FatIndex] = FatEntry;

Arguments:

    FatStructureContext - Supplies the structure context for the operation

    DeviceId - Supplies the device for the operation

    FatIndex - Supplies the index within the fat table to set

    FatEntry - Supplies the value to store within the fat table

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    BOOLEAN TwelveBitFat;
    VBO Vbo;

    //
    //  Calculate the Vbo of the word in the fat we are modifying and
    //  also figure out if this is a 12 or 16 bit fat
    //

    if (FatIndexBitSize( &FatStructureContext->Bpb ) == 12) {

        TwelveBitFat = TRUE;
        Vbo = (FatIndex * 3) / 2;

    } else if (FatIndexBitSize( &FatStructureContext->Bpb ) == 32) {

        TwelveBitFat = FALSE;
        Vbo = FatIndex * 4;

    } else {

        TwelveBitFat = FALSE;
        Vbo = FatIndex * 2;
    }

    //
    //  Check if the Vbo we need is already in the cached fat
    //

    if ((FatStructureContext->CachedFat == NULL) ||
        (Vbo < FatStructureContext->CachedFatVbo) ||
        ((Vbo+1) > (FatStructureContext->CachedFatVbo + FAT_CACHE_SIZE))) {

        //
        //  Set the aligned cached fat buffer in the structure context
        //

        FatStructureContext->CachedFat = ALIGN_BUFFER( &FatStructureContext->CachedFatBuffer[0] );

        //
        //  As a safety net we'll flush any dirty fats that we might have cached before
        //  we turn the window
        //

        if (FatStructureContext->CachedFatDirty) {

            FlushFatEntries( FatStructureContext, DeviceId );
        }

        //
        //  Now set the new cached Vbo to be the Vbo of the cache sized section that
        //  we're trying to map.  Each time we read in the cache we only read in
        //  cache sized and cached aligned pieces of the fat.  So first compute an
        //  aligned cached fat vbo and then do the read.
        //

        FatStructureContext->CachedFatVbo = (Vbo / FAT_CACHE_SIZE) * FAT_CACHE_SIZE;

        DiskRead( DeviceId,
                  FatStructureContext->CachedFatVbo + FatFirstFatAreaLbo(&FatStructureContext->Bpb),
                  FAT_CACHE_SIZE,
                  FatStructureContext->CachedFat,
                  CACHE_NEW_DATA,
                  FALSE );
    }

    //
    //  At this point the cached fat contains the vbo we're after.  For a 16 bit
    //  fat we simply put in the fat entry.  For the 12 bit fat we first need to extract
    //  the word containing the entry, modify the word, and then put it back.
    //

    if (TwelveBitFat) {

        FAT_ENTRY Temp;

        CopyUchar2( &Temp,
                    &FatStructureContext->CachedFat[Vbo - FatStructureContext->CachedFatVbo] );

        if ((FatIndex % 2) == 0) {

            FatEntry = (FAT_ENTRY)((Temp & 0xf000) | (FatEntry & 0x0fff));

        } else {

            FatEntry = (FAT_ENTRY)((Temp & 0x000f) | ((FatEntry << 4) & 0xfff0));
        }
    }

    if (IsBpbFat32(&FatStructureContext->Bpb)) {
        CopyUchar4( &FatStructureContext->CachedFat[Vbo - FatStructureContext->CachedFatVbo],
                    &FatEntry );

    } else {

        CopyUchar2( &FatStructureContext->CachedFat[Vbo - FatStructureContext->CachedFatVbo],
                    &FatEntry );
    }

    //
    //  Now that we're done we can set the fat dirty
    //

    FatStructureContext->CachedFatDirty = TRUE;

    return ESUCCESS;
}


//
//  Internal support routine
//

ARC_STATUS
FatFlushFatEntries (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId
    )

/*++

Routine Description:

    This routine flushes out any dirty cached fat entries to the volume.

Arguments:

    FatStructureContext - Supplies the structure context for the operation

    DeviceId - Supplies the Device for the operation

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ULONG BytesPerFat;
    ULONG AmountToWrite;
    ULONG i;

    //
    //  Compute the actual number of bytes that we need to write.  We do this
    //  because we don't want to overwrite beyond the fat.
    //

    BytesPerFat = FatBytesPerFat(&FatStructureContext->Bpb);

    if (FatStructureContext->CachedFatVbo + FAT_CACHE_SIZE <= BytesPerFat) {

        AmountToWrite = FAT_CACHE_SIZE;

    } else {

        AmountToWrite = BytesPerFat - FatStructureContext->CachedFatVbo;
    }

    //
    //  For each fat table on the volume we will calculate the lbo for the operation
    //  and then write out the cached fat
    //

    for (i = 0; i < FatStructureContext->Bpb.Fats; i += 1) {

        LBO   Lbo;

        Lbo = FatStructureContext->CachedFatVbo +
              FatFirstFatAreaLbo(&FatStructureContext->Bpb) +
              (i * BytesPerFat);

        DiskWrite( DeviceId,
                   Lbo,
                   AmountToWrite,
                   FatStructureContext->CachedFat );
    }

    //
    //  we are all done so now mark the fat clean
    //

    FatStructureContext->CachedFatDirty = FALSE;

    return ESUCCESS;
}


//
//  Internal support routine
//

LBO
FatIndexToLbo (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN FAT_ENTRY FatIndex
    )

/*++

Routine Description:

    This procedure translates a fat index into its corresponding lbo.

Arguments:

    FatStructureContext - Supplies the volume structure for the operation

    Entry - Supplies the fat entry to examine.

Return Value:

    The LBO for the input fat index is returned

--*/

{
    //
    //  The formula for translating an index into an lbo is to take the index subtract
    //  2 (because index values 0 and 1 are reserved) multiply that by the bytes per
    //  cluster and add the results to the first file area lbo.
    //

    return ((FatIndex-2) * (LBO) FatBytesPerCluster(&FatStructureContext->Bpb))
           + FatFileAreaLbo(&FatStructureContext->Bpb);
}


//
//  Internal support routine
//

ARC_STATUS
FatSearchForDirent (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN FAT_ENTRY DirectoriesStartingIndex,
    IN PFAT8DOT3 FileName,
    OUT PDIRENT Dirent,
    OUT PLBO Lbo,
    IN BOOLEAN IsDoubleSpace
    )

/*++

Routine Description:

    The procedure searches the indicated directory for a dirent that matches
    the input file name.

Arguments:

    FatStructureContext - Supplies the structure context for the operation

    DeviceId - Supplies the Device id for the operation

    DirectoriesStartingIndex - Supplies the fat index of the directory we are
        to search.  A value of zero indicates that we are searching the root directory
        of a non-FAT32 volume.  FAT32 volumes will have a non-zero index.

    FileName - Supplies the file name to look for.  The name must have already been
        biased by the 0xe5 transmogrification

    Dirent - The caller supplies the memory for a dirent and this procedure will
        fill in the dirent if one is located

    Lbo - Receives the Lbo of the dirent if one is located

    IsDoubleSpace - Indicates if the search is being done on a double space volume

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PDIRENT DirentBuffer;
    UCHAR Buffer[ 16 * sizeof(DIRENT) + 256 ];

    ULONG i;
    ULONG j;

    ULONG BytesPerCluster;
    FAT_ENTRY FatEntry;
    CLUSTER_TYPE ClusterType;

    DirentBuffer = (PDIRENT)ALIGN_BUFFER( &Buffer[0] );

    FatDebugOutput83("FatSearchForDirent: %s\r\n", FileName, 0, 0);

    //****if (IsDoubleSpace) { (*FileName)[11] = 0; DbgPrint("FatSearchForDirent(%0x,%0x,%0x,\"%11s\",%0x,%0x,%0x)\n", FatStructureContext, DeviceId, DirectoriesStartingIndex, FileName, Dirent, Lbo, IsDoubleSpace); }

    //
    //  Check if this is the root directory that is being searched
    //

    if (DirectoriesStartingIndex == FAT_CLUSTER_AVAILABLE) {

        VBO Vbo;

        ULONG RootLbo = FatRootDirectoryLbo(&FatStructureContext->Bpb);
        ULONG RootSize = FatRootDirectorySize(&FatStructureContext->Bpb);

        //
        //  For the root directory we'll zoom down the dirents until we find
        //  a match, or run out of dirents or hit the never used dirent.
        //  The outer loop reads in 512 bytes of the directory at a time into
        //  dirent buffer.
        //

        for (Vbo = 0; Vbo < RootSize; Vbo += 16 * sizeof(DIRENT)) {

            *Lbo = Vbo + RootLbo;

            DiskRead( DeviceId, *Lbo, 16 * sizeof(DIRENT), DirentBuffer, CACHE_NEW_DATA, IsDoubleSpace );

            //
            //  The inner loop cycles through the 16 dirents that we've just read in
            //

            for (i = 0; i < 16; i += 1) {

                //
                //  Check if we've found a non label match for file name, and if so
                //  then copy the buffer into the dirent and set the real lbo
                //  of the dirent and return
                //

                if (!FlagOn(DirentBuffer[i].Attributes, FAT_DIRENT_ATTR_VOLUME_ID ) &&
                    AreNamesEqual(&DirentBuffer[i].FileName, FileName)) {

                    for (j = 0; j < sizeof(DIRENT); j += 1) {

                        ((PCHAR)Dirent)[j] = ((PCHAR)DirentBuffer)[(i * sizeof(DIRENT)) + j];
                    }

                    *Lbo = Vbo + RootLbo + (i * sizeof(DIRENT));

                    return ESUCCESS;
                }

                if (DirentBuffer[i].FileName[0] == FAT_DIRENT_NEVER_USED) {

                    return ENOENT;
                }
            }
        }

        return ENOENT;
    }

    //
    //  If we get here we need to search a non-root directory.  The alrogithm
    //  for doing the search is that for each cluster we read in each dirent
    //  until we find a match, or run out of clusters, or hit the never used
    //  dirent.  First set some local variables and then get the cluster type
    //  of the first cluster
    //

    BytesPerCluster = FatBytesPerCluster( &FatStructureContext->Bpb );
    FatEntry = DirectoriesStartingIndex;
    ClusterType = FatInterpretClusterType( FatStructureContext, FatEntry );

    //
    //  Now loop through each cluster, and compute the starting Lbo for each cluster
    //  that we encounter
    //

    while (ClusterType == FatClusterNext) {

        LBO ClusterLbo;
        ULONG Offset;

        ClusterLbo = FatIndexToLbo( FatStructureContext, FatEntry );

        //
        //  Now for each dirent in the cluster compute the lbo, read in the dirent
        //  and check for a match, the outer loop reads in 512 bytes of dirents at
        //  a time.
        //

        for (Offset = 0; Offset < BytesPerCluster; Offset += 16 * sizeof(DIRENT)) {

            *Lbo = Offset + ClusterLbo;

            DiskRead( DeviceId, *Lbo, 16 * sizeof(DIRENT), DirentBuffer, CACHE_NEW_DATA, IsDoubleSpace );

            //
            //  The inner loop cycles through the 16 dirents that we've just read in
            //

            for (i = 0; i < 16; i += 1) {

                //
                //  Check if we've found a for file name, and if so
                //  then copy the buffer into the dirent and set the real lbo
                //  of the dirent and return
                //

                if (!FlagOn(DirentBuffer[i].Attributes, FAT_DIRENT_ATTR_VOLUME_ID ) &&
                    AreNamesEqual(&DirentBuffer[i].FileName, FileName)) {

                    for (j = 0; j < sizeof(DIRENT); j += 1) {

                        ((PCHAR)Dirent)[j] = ((PCHAR)DirentBuffer)[(i * sizeof(DIRENT)) + j];
                    }

                    *Lbo = Offset + ClusterLbo + (i * sizeof(DIRENT));

                    return ESUCCESS;
                }

                if (DirentBuffer[i].FileName[0] == FAT_DIRENT_NEVER_USED) {

                    return ENOENT;
                }
            }
        }

        //
        //  Now that we've exhausted the current cluster we need to read
        //  in the next cluster.  So locate the next fat entry in the chain
        //  and go back to the top of the while loop.
        //

        LookupFatEntry( FatStructureContext, DeviceId, FatEntry, (PULONG) &FatEntry, IsDoubleSpace );

        ClusterType = FatInterpretClusterType(FatStructureContext, FatEntry);
    }

    return ENOENT;
}


//
//  Internal support routine
//

ARC_STATUS
FatCreateDirent (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN FAT_ENTRY DirectoriesStartingIndex,
    IN PDIRENT Dirent,
    OUT PLBO Lbo
    )

/*++

Routine Description:

    This procedure allocates and write out a new dirent for a data file in the
    specified directory.  It assumes that the file name does not already exist.

Arguments:

    FatStructureContext - Supplies the structure context for the operation

    DeviceId - Supplies the device id for the operation

    DirectoriesStartingIndex - Supplies the fat index of the directory we are
        to use.  A value of zero indicates that we are using the root directory

    Dirent - Supplies a copy of the dirent to put out on the disk

    Lbo - Recieves the Lbo of where the dirent is placed

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    DIRENT TemporaryDirent;

    ULONG BytesPerCluster;
    FAT_ENTRY FatEntry;
    FAT_ENTRY PreviousEntry;

    //
    //  Check if this is the root directory that is being used
    //

    if (DirectoriesStartingIndex == FAT_CLUSTER_AVAILABLE) {

        VBO Vbo;

        ULONG RootLbo = FatRootDirectoryLbo(&FatStructureContext->Bpb);
        ULONG RootSize = FatRootDirectorySize(&FatStructureContext->Bpb);

        //
        //  For the root directory we'll zoom down the dirents until we find
        //  a the never used (or deleted) dirent, if we never find one then the
        //  directory is full.
        //

        for (Vbo = 0; Vbo < RootSize; Vbo += sizeof(DIRENT)) {

            *Lbo = Vbo + RootLbo;

            DiskRead( DeviceId, *Lbo, sizeof(DIRENT), &TemporaryDirent, CACHE_NEW_DATA, FALSE );

            if ((TemporaryDirent.FileName[0] == FAT_DIRENT_DELETED) ||
                (TemporaryDirent.FileName[0] == FAT_DIRENT_NEVER_USED)) {

                //
                //  This dirent is free so write out the dirent, and we're done.
                //

                DiskWrite( DeviceId, *Lbo, sizeof(DIRENT), Dirent );

                return ESUCCESS;
            }
        }

        return ENOSPC;
    }

    //
    //  If we get here we need to use a non-root directory.  The alrogithm
    //  for doing the work is that for each cluster we read in each dirent
    //  until we hit a never used dirent or run out of clusters.  First set
    //  some local variables and then get the cluster type of the first
    //  cluster
    //

    BytesPerCluster = FatBytesPerCluster( &FatStructureContext->Bpb );
    FatEntry = DirectoriesStartingIndex;

    //
    //  Now loop through each cluster, and compute the starting Lbo for each cluster
    //  that we encounter
    //

    while (TRUE) {

        LBO ClusterLbo;
        ULONG Offset;

        ClusterLbo = FatIndexToLbo( FatStructureContext, FatEntry );

        //
        //  Now for each dirent in the cluster compute the lbo, read in the dirent
        //  and check if it is available.
        //

        for (Offset = 0; Offset < BytesPerCluster; Offset += sizeof(DIRENT)) {

            *Lbo = Offset + ClusterLbo;

            DiskRead( DeviceId, *Lbo, sizeof(DIRENT), &TemporaryDirent, CACHE_NEW_DATA, FALSE );

            if ((TemporaryDirent.FileName[0] == FAT_DIRENT_DELETED) ||
                (TemporaryDirent.FileName[0] == FAT_DIRENT_NEVER_USED)) {

                //
                //  This dirent is free so write out the dirent, and we're done.
                //

                DiskWrite( DeviceId, *Lbo, sizeof(DIRENT), Dirent );

                return ESUCCESS;
            }
        }

        //
        //  Now that we've exhausted the current cluster we need to read
        //  in the next cluster.  So locate the next fat entry in the chain.
        //  Set previous entry to be the saved entry just in case we run off
        //  the chain and need to allocate another cluster.
        //

        PreviousEntry = FatEntry;

        LookupFatEntry( FatStructureContext, DeviceId, FatEntry, (PULONG) &FatEntry, FALSE );

        //
        //  If there isn't another cluster in the chain then we need to allocate a
        //  new cluster, and set previous entry to point to it.
        //

        if (FatInterpretClusterType(FatStructureContext, FatEntry) != FatClusterNext) {

            AllocateClusters( FatStructureContext, DeviceId, 1, PreviousEntry, (PULONG) &FatEntry );

            SetFatEntry( FatStructureContext, DeviceId, PreviousEntry, FatEntry );
        }
    }

    return ENOSPC;
}


//
//  Internal support routine
//

VOID
FatSetDirent (
    IN PFAT8DOT3 FileName,
    IN OUT PDIRENT Dirent,
    IN UCHAR Attributes
    )

/*++

Routine Description:

    This routine sets up the dirent

Arguments:

    FileName - Supplies the name to store in the dirent

    Dirent - Receives the current date and time

    Attributes - Supplies the attributes to initialize the dirent with

Return Value:

    None.

--*/

{
    PTIME_FIELDS Time;
    ULONG i;

    for (i = 0; i < sizeof(FAT8DOT3); i+= 1) {

        Dirent->FileName[i] = (*FileName)[i];
    }

    Dirent->Attributes = (UCHAR)(Attributes | FAT_DIRENT_ATTR_ARCHIVE);

    Time = ArcGetTime();

    Dirent->LastWriteTime.Time.DoubleSeconds = (USHORT)(Time->Second/2);
    Dirent->LastWriteTime.Time.Minute = Time->Minute;
    Dirent->LastWriteTime.Time.Hour = Time->Hour;

    Dirent->LastWriteTime.Date.Day = Time->Day;
    Dirent->LastWriteTime.Date.Month = Time->Month;
    Dirent->LastWriteTime.Date.Year = (USHORT)(Time->Year - 1980);

    return;
}


//
//  Internal support routine
//

ARC_STATUS
FatLoadMcb (
    IN ULONG FileId,
    IN VBO StartingVbo,
    IN BOOLEAN IsDoubleSpace
    )
/*++

Routine Description:

    This routine loads into the cached mcb table the the retrival information for
    the starting vbo.

Arguments:

    FileId - Supplies the FileId for the operation

    StartingVbo - Supplies the starting vbo to use when loading the mcb

    IsDoubleSpace - Indicates if the operation is being done on a double space volume

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PFAT_STRUCTURE_CONTEXT FatStructureContext;
    PFAT_MCB Mcb;
    ULONG DeviceId;
    ULONG BytesPerCluster;

    FAT_ENTRY FatEntry;
    CLUSTER_TYPE ClusterType;
    VBO Vbo;

    //****if (IsDoubleSpace) { DbgPrint("FatLoadMcb(%0x,%0x,%0x)\n", FileId, StartingVbo, IsDoubleSpace); }

    //
    //  Preload some of the local variables
    //

    FileTableEntry = &BlFileTable[FileId];
    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    Mcb = &FatStructureContext->Mcb;
    DeviceId = FileTableEntry->DeviceId;
    BytesPerCluster = FatBytesPerCluster(&FatStructureContext->Bpb);

    if (IsDoubleSpace) { DeviceId = FileId; }

    //
    //  Set the file id in the structure context, and also set the mcb to be initially
    //  empty
    //

    FatStructureContext->FileId = FileId;
    Mcb->InUse = 0;
    Mcb->Vbo[0] = 0;

    if (!IsBpbFat32(&FatStructureContext->Bpb)) {

        //
        //  Check if this is the root directory.  If it is then we build the single
        //  run mcb entry for the root directory.
        //

        if (FileTableEntry->u.FatFileContext.DirentLbo == 0) {

            Mcb->InUse = 1;
            Mcb->Lbo[0] = FatRootDirectoryLbo(&FatStructureContext->Bpb);
            Mcb->Vbo[1] = FatRootDirectorySize(&FatStructureContext->Bpb);

            return ESUCCESS;
        }

        //
        //  For all other files/directories we need to do some work. First get the fat
        //  entry and cluster type of the fat entry stored in the dirent
        //

        FatEntry = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile;

    } else {

        //
        //  Check if this is the root directory.  If it is then we use
        //  the BPB values to start the run.
        //

        if (FileTableEntry->u.FatFileContext.DirentLbo == 0) {

            FatEntry = FatStructureContext->Bpb.RootDirFirstCluster;

        } else {

            //
            //  For all other files/directories we use the dirent values
            //

            if (IsBpbFat32(&FatStructureContext->Bpb)) {

                FatEntry = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile |
                    (FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFileHi << 16);
            } else {

                FatEntry = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile;
            }
        }

    }

    ClusterType = FatInterpretClusterType(FatStructureContext, FatEntry);

    //
    //  Scan through the fat until we reach the vbo we're after and then build the
    //  mcb for the file
    //

    for (Vbo = BytesPerCluster; Vbo < StartingVbo; Vbo += BytesPerCluster) {

        //
        //  Check if the file does not have any allocation beyond this point in which
        //  case the mcb we return is empty
        //

        if (ClusterType != FatClusterNext) {

            return ESUCCESS;
        }

        LookupFatEntry( FatStructureContext, DeviceId, FatEntry, (PULONG) &FatEntry, IsDoubleSpace );

        ClusterType = FatInterpretClusterType(FatStructureContext, FatEntry);
    }

    //
    //  We need to check again if the file does not have any allocation beyond this
    //  point in which case the mcb we return is empty
    //

    if (ClusterType != FatClusterNext) {

        return ESUCCESS;
    }

    //
    //  At this point FatEntry denotes another cluster, and it happens to be the
    //  cluster we want to start loading into the mcb.  So set up the first run in
    //  the mcb to be this cluster, with a size of a single cluster.
    //

    Mcb->InUse = 1;
    Mcb->Vbo[0] = Vbo - BytesPerCluster;
    Mcb->Lbo[0] = FatIndexToLbo( FatStructureContext, FatEntry );
    Mcb->Vbo[1] = Vbo;

    //
    //  Now we'll scan through the fat chain until we either exhaust the fat chain
    //  or we fill up the mcb
    //

    while (TRUE) {

        LBO Lbo;

        //
        //  Get the next fat entry and interpret its cluster type
        //

        LookupFatEntry( FatStructureContext, DeviceId, FatEntry, (PULONG) &FatEntry, IsDoubleSpace );

        ClusterType = FatInterpretClusterType(FatStructureContext, FatEntry);

        if (ClusterType != FatClusterNext) {

            return ESUCCESS;
        }

        //
        //  Now calculate the lbo for this cluster and determine if it
        //  is a continuation of the previous run or a start of a new run
        //

        Lbo = FatIndexToLbo(FatStructureContext, FatEntry);

        //
        //  It is a continuation if the lbo of the last run plus the current
        //  size of the run is equal to the lbo for the next cluster.  If it
        //  is a contination then we only need to add a cluster amount to the
        //  last vbo to increase the run size.  If it is a new run then
        //  we need to check if the run will fit, and if so then add in the
        //  new run.
        //

        if ((Mcb->Lbo[Mcb->InUse-1] + (Mcb->Vbo[Mcb->InUse] - Mcb->Vbo[Mcb->InUse-1])) == Lbo) {

            Mcb->Vbo[Mcb->InUse] += BytesPerCluster;

        } else {

            if ((Mcb->InUse + 1) >= FAT_MAXIMUM_MCB) {

                return ESUCCESS;
            }

            Mcb->InUse += 1;
            Mcb->Lbo[Mcb->InUse-1] = Lbo;
            Mcb->Vbo[Mcb->InUse] = Mcb->Vbo[Mcb->InUse-1] + BytesPerCluster;
        }
    }

    return ESUCCESS;
}


//
//  Internal support routine
//

ARC_STATUS
FatVboToLbo (
    IN ULONG FileId,
    IN VBO Vbo,
    OUT PLBO Lbo,
    OUT PULONG ByteCount,
    IN BOOLEAN IsDoubleSpace
    )

/*++

Routine Description:

    This routine computes the run denoted by the input vbo to into its
    corresponding lbo and also returns the number of bytes remaining in
    the run.

Arguments:

    Vbo - Supplies the Vbo to match

    Lbo - Recieves the corresponding Lbo

    ByteCount - Receives the number of bytes remaining in the run

    IsDoubleSpace - Indicates if the operation is being done on a double space volume

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PFAT_STRUCTURE_CONTEXT FatStructureContext;
    PFAT_MCB Mcb;
    ULONG i;

    //****if (IsDoubleSpace) { DbgPrint("FatVboToLbo(%0x,%0x,%0x,%0x,%0x)\n", FileId, Vbo, Lbo, ByteCount, IsDoubleSpace); }

    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)BlFileTable[FileId].StructureContext;
    Mcb = &FatStructureContext->Mcb;

    //
    //  Check if the mcb is for the correct file id and has the range we're asking for.
    //  If it doesn't then call load mcb to load in the right range.
    //

    if ((FileId != FatStructureContext->FileId) ||
        (Vbo < Mcb->Vbo[0]) || (Vbo >= Mcb->Vbo[Mcb->InUse])) {

        LoadMcb(FileId, Vbo, IsDoubleSpace);
    }

    //
    //  Now search for the slot where the Vbo fits in the mcb.  Note that
    //  we could also do a binary search here but because the run count
    //  is probably small the extra overhead of a binary search doesn't
    //  buy us anything
    //

    for (i = 0; i < Mcb->InUse; i += 1) {

        //
        //  We found our slot if the vbo we're after is less then the
        //  next mcb's vbo
        //

        if (Vbo < Mcb->Vbo[i+1]) {

            //
            //  Compute the corresponding lbo which is the stored lbo plus
            //  the difference between the stored vbo and the vbo we're
            //  looking up.  Also compute the byte count which is the
            //  difference between the current vbo we're looking up and
            //  the vbo for the next run.
            //

            *Lbo = Mcb->Lbo[i] + (Vbo - Mcb->Vbo[i]);

            *ByteCount = Mcb->Vbo[i+1] - Vbo;

            //
            //  and return success to our caller
            //

            return ESUCCESS;
        }
    }

    //
    //  If we really reach here we have an error, most likely because the file is
    //  not large enough for the requested Vbo.
    //

    return EINVAL;
}


//
//  Internal support routine
//

ARC_STATUS
FatIncreaseFileAllocation (
    IN ULONG FileId,
    IN ULONG ByteSize
    )

/*++

Routine Description:

    This procedure increases the file allocation to be at minimum the indicated
    size.

Arguments:

    FileId - Supplies the file id being processed

    ByteSize - Supplies the minimum byte size for file allocation

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PFAT_STRUCTURE_CONTEXT FatStructureContext;
    ULONG DeviceId;
    ULONG BytesPerCluster;

    ULONG NumberOfClustersNeeded;
    FAT_ENTRY FatEntry;
    CLUSTER_TYPE ClusterType;
    FAT_ENTRY PreviousEntry;
    ULONG i;

    //
    //  Preload some of the local variables
    //

    FileTableEntry = &BlFileTable[FileId];
    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    DeviceId = FileTableEntry->DeviceId;
    BytesPerCluster = FatBytesPerCluster(&FatStructureContext->Bpb);

    //
    //  Check if this is the root directory.  If it is then check if the allocation
    //  increase is already accommodated in the volume
    //

    if (FileTableEntry->u.FatFileContext.DirentLbo == 0) {

        if (FatRootDirectorySize(&FatStructureContext->Bpb) >= ByteSize) {

            return ESUCCESS;

        } else {

            return ENOSPC;
        }
    }

    //
    //  Compute the actual number of clusters needed to satisfy the request
    //  Also get the first fat entry and its cluster type from the dirent.
    //

    NumberOfClustersNeeded = (ByteSize + BytesPerCluster - 1) / BytesPerCluster;

    if (IsBpbFat32(&FatStructureContext->Bpb)) {

        FatEntry = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile |
            (FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFileHi << 16);

    } else {

        FatEntry = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile;
    }

    ClusterType = FatInterpretClusterType(FatStructureContext, FatEntry);

    //
    //  Previous Entry is as a hint to allocate new space and to show us where
    //  the end of the current fat chain is located
    //

    PreviousEntry = 2;

    //
    //  We loop for the number of clusters we need trying to go down the fat chain.
    //  When we exit i is either number of clusters in the file (if less then
    //  the number of clusters we need) or it is set equal to the number of clusters
    //  we need
    //

    for (i = 0; i < NumberOfClustersNeeded; i += 1) {

        if (ClusterType != FatClusterNext) { break; }

        PreviousEntry = FatEntry;

        LookupFatEntry( FatStructureContext, DeviceId, PreviousEntry, (PULONG) &FatEntry, FALSE );

        ClusterType = FatInterpretClusterType(FatStructureContext, FatEntry);
    }

    if (i >= NumberOfClustersNeeded) {

        return ESUCCESS;
    }

    //
    //  At this point previous entry points to the last entry and i contains the
    //  number of clusters in the file.  We now need to build up the allocation
    //

    AllocateClusters( FatStructureContext,
                      DeviceId,
                      NumberOfClustersNeeded - i,
                      PreviousEntry,
                      (PULONG) &FatEntry );

    //
    //  We have our additional allocation, so now figure out if we need to chain off of
    //  the dirent or it we already have a few clusters in the chain and we
    //  need to munge the fat.
    //

    if (FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile == FAT_CLUSTER_AVAILABLE) {

        FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile = (USHORT)FatEntry;
        FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFileHi =
            (USHORT)(FatEntry >> 16);

        DiskWrite( DeviceId,
                   FileTableEntry->u.FatFileContext.DirentLbo,
                   sizeof(DIRENT),
                   &FileTableEntry->u.FatFileContext.Dirent );

    } else {

        SetFatEntry( FatStructureContext, DeviceId, PreviousEntry, FatEntry );
    }

    return ESUCCESS;
}


//
//  Internal support routine
//

ARC_STATUS
FatTruncateFileAllocation (
    IN ULONG FileId,
    IN ULONG ByteSize
    )

/*++

Routine Description:

    This procedure decreases the file allocation to be at maximum the indicated
    size.

Arguments:

    FileId - Supplies the file id being processed

    ByteSize - Supplies the maximum byte size for file allocation

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PFAT_STRUCTURE_CONTEXT FatStructureContext;
    ULONG DeviceId;
    ULONG BytesPerCluster;

    ULONG NumberOfClustersNeeded;
    FAT_ENTRY FatEntry;
    CLUSTER_TYPE ClusterType;
    FAT_ENTRY CurrentIndex;
    ULONG i;

    //
    //  Preload some of the local variables
    //

    FileTableEntry = &BlFileTable[FileId];
    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    DeviceId = FileTableEntry->DeviceId;
    BytesPerCluster = FatBytesPerCluster(&FatStructureContext->Bpb);

    //
    //  Check if this is the root directory.  If it is then noop this request
    //

    if (FileTableEntry->u.FatFileContext.DirentLbo == 0) {

        return ESUCCESS;
    }

    //
    //  Compute the actual number of clusters needed to satisfy the request
    //  Also get the first fat entry and its cluster type from the dirent
    //

    NumberOfClustersNeeded = (ByteSize + BytesPerCluster - 1) / BytesPerCluster;

    if (IsBpbFat32(&FatStructureContext->Bpb)) {

        FatEntry = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile |
            (FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFileHi << 16);

    } else {

        FatEntry = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile;
    }

    ClusterType = FatInterpretClusterType(FatStructureContext, FatEntry);

    //
    //  The current index variable is used to indicate where we extracted the current
    //  fat entry value from.  It has a value of 0 we got the fat entry from the
    //  dirent.
    //

    CurrentIndex = FAT_CLUSTER_AVAILABLE;

    //
    //  Now loop through the fat chain for the number of clusters needed.
    //  If we run out of the chain before we run out of clusters needed then the
    //  current allocation is already smaller than necessary.
    //

    for (i = 0; i < NumberOfClustersNeeded; i += 1) {

        //
        //  If we run out of the chain before we run out of clusters needed then the
        //  current allocation is already smaller than necessary.
        //

        if (ClusterType != FatClusterNext) { return ESUCCESS; }

        //
        //  Update the current index, and read in a new fat entry and interpret its
        //  type
        //

        CurrentIndex = FatEntry;

        LookupFatEntry( FatStructureContext, DeviceId, CurrentIndex, (PULONG) &FatEntry, FALSE );

        ClusterType = FatInterpretClusterType(FatStructureContext, FatEntry);
    }

    //
    //  If we get here then we've found that the current allocation is equal to or
    //  larger than what we want.  It is equal if the current cluster type does not
    //  point to another cluster.  The first thing we have to do is terminate the
    //  fat chain correctly.  If the current index is zero then we zero out the
    //  dirent, otherwise we need to set the value to be last cluster.
    //

    if (CurrentIndex == FAT_CLUSTER_AVAILABLE) {

        FatEntry = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile;

        if (IsBpbFat32(&FatStructureContext->Bpb)) {

            FatEntry |= FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFileHi << 16;
        }

        if (FatEntry != FAT_CLUSTER_AVAILABLE) {

            //
            //  By setting the dirent we set in a new date.
            //

            FatSetDirent( &FileTableEntry->u.FatFileContext.Dirent.FileName,
                          &FileTableEntry->u.FatFileContext.Dirent,
                          0 );

            FatEntry = FAT_CLUSTER_AVAILABLE;

            FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile = (USHORT)FatEntry;

            if (IsBpbFat32(&FatStructureContext->Bpb)) {

                FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFileHi =
                    (USHORT)(FatEntry >> 16);
            }

            FileTableEntry->u.FatFileContext.Dirent.FileSize = 0;

            DiskWrite( DeviceId,
                       FileTableEntry->u.FatFileContext.DirentLbo,
                       sizeof(DIRENT),
                       &FileTableEntry->u.FatFileContext.Dirent );
        }

    } else {

        if (ClusterType != FatClusterLast) {

            SetFatEntry( FatStructureContext, DeviceId, CurrentIndex, FAT_CLUSTER_LAST );
        }
    }

    //
    //  Now while there are clusters left to deallocate then we need to go down the
    //  chain freeing up the clusters
    //

    while (ClusterType == FatClusterNext) {

        //
        //  Read in the value at the next fat entry and interpret its cluster type
        //

        CurrentIndex = FatEntry;

        LookupFatEntry( FatStructureContext, DeviceId, CurrentIndex, (PULONG) &FatEntry, FALSE );

        ClusterType = FatInterpretClusterType(FatStructureContext, FatEntry);

        //
        //  Now deallocate the cluster at the current index
        //

        SetFatEntry( FatStructureContext, DeviceId, CurrentIndex, FAT_CLUSTER_AVAILABLE );
    }

    return ESUCCESS;
}


//
//  Internal support routine
//

ARC_STATUS
FatAllocateClusters (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN ULONG ClusterCount,
    IN ULONG Hint,
    OUT PULONG AllocatedEntry
    )

/*++

Routine Description:

    This procedure allocates a new cluster, set its entry to be the last one,
    and zeros out the cluster.

Arguments:

    FatStructureContext - Supplies the structure context for the operation

    DeviceId - Supplies the device id for the operation

    ClusterCount - Supplies the number of clusters we need to allocate

    Hint - Supplies a hint to start from when looking for a free cluster

    AllocatedEntry - Receives the first fat index for the new allocated cluster chain

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ULONG TotalClustersInVolume;
    ULONG BytesPerCluster;
    UCHAR BlankBuffer[512];

    FAT_ENTRY PreviousEntry;
    ULONG CurrentClusterCount;
    ULONG j;
    LBO ClusterLbo;
    ULONG i;

    //
    //  Load some local variables
    //

    TotalClustersInVolume = FatNumberOfClusters(&FatStructureContext->Bpb);
    BytesPerCluster = FatBytesPerCluster(&FatStructureContext->Bpb);
    RtlZeroMemory((PVOID)&BlankBuffer[0], 512);

    PreviousEntry = 0;
    CurrentClusterCount = 0;

    //
    //  For each cluster on the disk we'll do the following loop
    //

    for (j = 0; j < TotalClustersInVolume; j += 1) {

        FAT_ENTRY EntryToExamine;
        FAT_ENTRY FatEntry;

        //
        //  Check if the current allocation is enough.
        //

        if (CurrentClusterCount >= ClusterCount) {

            return ESUCCESS;
        }

        //
        //  Compute an entry to examine based on the loop iteration and our hint
        //

        EntryToExamine = (FAT_ENTRY)(((j + Hint - 2) % TotalClustersInVolume) + 2);

        //
        //  Read in the prospective fat entry and check if it is available.  If it
        //  is not available then continue looping.
        //

        LookupFatEntry( FatStructureContext, DeviceId, EntryToExamine, (PULONG) &FatEntry, FALSE );

        if (FatInterpretClusterType(FatStructureContext, FatEntry) != FatClusterAvailable) {

            continue;
        }

        //
        //  We have a free cluster, so put it at the end of the chain.
        //

        if (PreviousEntry == 0) {

            *AllocatedEntry = EntryToExamine;

        } else {

            SetFatEntry( FatStructureContext, DeviceId, PreviousEntry, EntryToExamine );
        }

        SetFatEntry( FatStructureContext, DeviceId, EntryToExamine, FAT_CLUSTER_LAST );

        //
        //  Now we need to go through and zero out the data in the cluster that we've
        //  just allocated.  Because all clusters must be a multiple of dirents we'll
        //  do it a dirent at a time.
        //

        ClusterLbo = FatIndexToLbo( FatStructureContext, EntryToExamine );

        for (i = 0; i < BytesPerCluster; i += 512) {

            DiskWrite( DeviceId, ClusterLbo + i, 512, BlankBuffer );
        }

        //
        //  Before we go back to the top of the loop we need to update the
        //  previous entry so that it points to the end of the current chain and
        //  also i because we've just added another cluster.
        //

        PreviousEntry = EntryToExamine;
        CurrentClusterCount += 1;
    }

    return ENOSPC;
}


//
//  Internal support routine
//

VOID
FatFirstComponent (
    IN OUT PSTRING String,
    OUT PFAT8DOT3 FirstComponent
    )

/*++

Routine Description:

    Convert a string into fat 8.3 format and advance the input string
    descriptor to point to the next file name component.

Arguments:

    InputString - Supplies a pointer to the input string descriptor.

    Output8dot3 - Supplies a pointer to the converted string.

Return Value:

    None.

--*/

{
    ULONG Extension;
    ULONG Index;

    //
    //  Fill the output name with blanks.
    //

    for (Index = 0; Index < 11; Index += 1) { (*FirstComponent)[Index] = ' '; }

    //
    //  Copy the first part of the file name up to eight characters and
    //  skip to the end of the name or the input string as appropriate.
    //

    for (Index = 0; Index < String->Length; Index += 1) {

        if ((String->Buffer[Index] == '\\') || (String->Buffer[Index] == '.')) {

            break;
        }

        if (Index < 8) {

            (*FirstComponent)[Index] = (CHAR)ToUpper(String->Buffer[Index]);
        }
    }

    //
    //  Check if the end of the string was reached, an extension was specified,
    //  or a subdirectory was specified..
    //

    if (Index < String->Length) {

        if (String->Buffer[Index] == '.') {

            //
            //  Skip over the extension separator and add the extension to
            //  the file name.
            //

            Index += 1;
            Extension = 8;

            while (Index < String->Length) {

                if (String->Buffer[Index] == '\\') {

                    break;
                }

                if (Extension < 11) {

                    (*FirstComponent)[Extension] = (CHAR)ToUpper(String->Buffer[Index]);
                    Extension += 1;
                }

                Index += 1;
            }
        }
    }

    //
    //  Now we'll bias the first component by the 0xe5 factor so that all our tests
    //  to names on the disk will be ready for a straight 11 byte comparison
    //

    if ((*FirstComponent)[0] == 0xe5) {

        (*FirstComponent)[0] = FAT_DIRENT_REALLY_0E5;
    }

    //
    //  Update string descriptor.
    //

    String->Buffer += Index;
    String->Length = String->Length - (USHORT)Index;

    return;
}


//
//  Internal support routine
//

VOID
FatDirToArcDir (
    IN PDIRENT FatDirent,
    OUT PDIRECTORY_ENTRY ArcDirent
    )

/*++

Routine Description:

    This routine converts a FAT directory entry into an ARC
    directory entry.

Arguments:

    FatDirent - supplies a pointer to a FAT directory entry.

    ArcDirent - supplies a pointer to an ARC directory entry.

Return Value:

    None.

--*/

{
    ULONG i, e;

    //
    //  clear info area
    //

    RtlZeroMemory( ArcDirent, sizeof(DIRECTORY_ENTRY) );

    //
    //  check the directory flag
    //

    if (FlagOn( FatDirent->Attributes, FAT_DIRENT_ATTR_DIRECTORY )) {

        SetFlag( ArcDirent->FileAttribute, ArcDirectoryFile );
    }

    //
    //  check the read-only flag
    //

    if (FlagOn( FatDirent->Attributes, FAT_DIRENT_ATTR_READ_ONLY )) {

        SetFlag( ArcDirent->FileAttribute, ArcReadOnlyFile );
    }

    //
    //  clear name string
    //

    RtlZeroMemory( ArcDirent->FileName, 32 );

    //
    //  copy first portion of file name
    //

    for (i = 0;  (i < 8) && (FatDirent->FileName[i] != ' ');  i += 1) {

        ArcDirent->FileName[i] = FatDirent->FileName[i];
    }

    //
    //  check for an extension
    //

    if ( FatDirent->FileName[8] != ' ' ) {

        //
        //  store the dot char
        //

        ArcDirent->FileName[i++] = '.';

        //
        //  add the extension
        //

        for (e = 8;  (e < 11) && (FatDirent->FileName[e] != ' ');  e += 1) {

            ArcDirent->FileName[i++] = FatDirent->FileName[e];
        }
    }

    //
    //  set file name length before returning
    //

    ArcDirent->FileNameLength = i;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\netboot2.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    net.c

Abstract:

    This module implements the net boot file system used by the operating
    system loader.

    It only contains those functions which are firmware/BIOS dependent.

Author:

    Chuck Lenzmeier (chuckl) 09-Jan-1997

Revision History:

--*/

#include "bootlib.h"
#include "stdio.h"

#ifdef UINT16
#undef UINT16
#endif

#ifdef INT16
#undef INT16
#endif

#include <dhcp.h>
#include <netfs.h>
#include <pxe_cmn.h>

#include <pxe_api.h>

#include <udp_api.h>
#include <tftp_api.h>
#include "bootx86.h"

#ifndef BOOL
typedef int BOOL;
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef TRUE
#define TRUE  1
#endif

#ifndef BYTE
typedef unsigned char BYTE;
#endif

#ifndef LPBYTE
typedef BYTE *LPBYTE;
#endif

#define MAX_PATH          260


//
// Define global data.
//

CHAR NetBootPath[129];

ULONG NetLocalIpAddress;
ULONG NetLocalSubnetMask;
ULONG NetServerIpAddress;
ULONG NetGatewayIpAddress;
UCHAR NetLocalHardwareAddress[16];

UCHAR NetBootIniContents[1020 + 1]; // 4 * 255 = 1020 + 1
UCHAR NetBootIniPath[256 + 1];

USHORT NetMaxTranUnit = 0; // MTU
USHORT NetHwAddrLen = 0; // actual length of hardware address
USHORT NetHwType = 0; // Type of protocol at the hardware level from rfc1010

UCHAR MyGuid[16];
ULONG MyGuidLength = sizeof(MyGuid);
BOOLEAN MyGuidValid = FALSE;


ARC_STATUS
FindDhcpOption(
    IN BOOTPLAYER * Packet,
    IN UCHAR Option,
    IN ULONG MaximumLength,
    OUT PUCHAR OptionData,
    OUT PULONG Length OPTIONAL,
    IN ULONG Instance OPTIONAL
    )
/*++

Routine Description:

    Searches a dhcp packet for a given option.

Arguments:

    Packet - pointer to the dhcp packet.  Caller is responsible for assuring
    that the packet is a valid dhcp packet.
    Option - the dhcp option we're searching for.
    MaximumLength - size in bytes of OptionData buffer.
    OptionData - buffer to receive the option.
    Length - if specified, receives the actual length of option copied.
    Instance - specifies which instance of the option you are searching for. 
    If not specified (zero), then we just grab the first instance of the tag.

Return Value:

    None.

--*/
{
    PUCHAR curOption;
    ULONG copyLength;
    ULONG i = 0;

    if (MaximumLength == 0) {
        return EINVAL;
    }

    RtlZeroMemory(OptionData, MaximumLength);

    //
    // Parse the DHCP options looking for a specific one.
    //

    curOption = &Packet->vendor.d[4];   // skip the magic cookie
    while ((curOption - (PUCHAR)Packet) < sizeof(BOOTPLAYER) &&
           *curOption != 0xff) {

        if (*curOption == DHCP_PAD) {
            //
            // just walk past any pad options
            // these will not have any length
            //
            curOption++;
        }
        else {        
            if (*curOption == Option) {

                //
                // Found it, copy and leave.
                //

                if ( i == Instance ) {

                    if (sizeof(BOOTPLAYER) <= curOption + 2 - (PUCHAR)Packet ||
                        sizeof(BOOTPLAYER) <= curOption + 2 + curOption[1] - (PUCHAR)Packet ) {
                        // 
                        // invalid option.  it walked past the end of the packet
                        //
                        break;
                    }

                    if (curOption[1] > MaximumLength) {
                        copyLength = MaximumLength;
                    } else {
                        copyLength = curOption[1];
                    }

                    RtlCopyMemory(OptionData,
                                  curOption+2,
                                  copyLength);

                    if (ARGUMENT_PRESENT(Length)) {
                        *Length = copyLength;
                    }

                    return ESUCCESS;
                }

                i++;
            }
            
            curOption = curOption + 2 + curOption[1];

        }
    }

    return EINVAL;

}


ARC_STATUS
GetParametersFromRom (
    VOID
    )
{
    SHORT status;
    t_PXENV_GET_BINL_INFO gbi;
    t_PXENV_UNDI_GET_INFORMATION info;
    BOOTPLAYER packet;
    ULONG temp;
    ULONG i;
    PCHAR p;

    NetLocalIpAddress = 0;
    NetGatewayIpAddress = 0;
    NetServerIpAddress = 0;
    NetLocalSubnetMask = 0;
    *NetBootPath = 0;

    RtlZeroMemory( NetBootIniContents, sizeof(NetBootIniContents) ) ;
    RtlZeroMemory( NetBootIniPath, sizeof(NetBootIniPath) ) ;

    //
    // Get client IP address, server IP address, default gateway IP address,
    // and subnet mask from the DHCP ACK packet.
    //
    
    RtlZeroMemory( &packet, sizeof(packet) ) ;
    gbi.packet_type = PXENV_PACKET_TYPE_DHCP_ACK;
    gbi.buffer_size = sizeof(packet);
    gbi.buffer_offset = (USHORT)((ULONG_PTR)&packet & 0x0f);
    gbi.buffer_segment = (USHORT)(((ULONG_PTR)&packet >> 4) & 0xffff);

    status = NETPC_ROM_SERVICES( PXENV_GET_BINL_INFO, &gbi );
    if ( status != PXENV_EXIT_SUCCESS ) {
        DPRINT( ERROR, ("PXENV_GET_BINL_INFO(1) failed with %x\n", status) );
    } else {
        NetLocalIpAddress = *(ULONG *)packet.yip;
        NetServerIpAddress = *(ULONG *)packet.sip;
        if (FindDhcpOption(&packet, DHCP_ROUTER, sizeof(temp), (PUCHAR)&temp, NULL, 0) == ESUCCESS) {
            NetGatewayIpAddress = temp;
        } else {
            NetGatewayIpAddress = *(ULONG *)packet.gip;
        }
        memcpy(NetLocalHardwareAddress, packet.caddr, 16);
        if (FindDhcpOption(&packet, DHCP_SUBNET, sizeof(temp), (PUCHAR)&temp, NULL, 0) == ESUCCESS) {
            NetLocalSubnetMask = temp;
        }
    }

    //
    // Values for client IP address, server IP address, default gateway IP address,
    // and subnet mask that are present in the BINL REPLY packet override those
    // in the DHCP ACK packet.
    //

    RtlZeroMemory( &packet, sizeof(packet) ) ;
    gbi.packet_type = PXENV_PACKET_TYPE_BINL_REPLY;
    gbi.buffer_size = sizeof(packet);
    gbi.buffer_offset = (USHORT)((ULONG_PTR)&packet & 0x0f);
    gbi.buffer_segment = (USHORT)(((ULONG_PTR)&packet >> 4) & 0xffff);

    status = NETPC_ROM_SERVICES( PXENV_GET_BINL_INFO, &gbi );
    if ( status != PXENV_EXIT_SUCCESS ) {
        DPRINT( ERROR, ("PXENV_GET_BINL_INFO(2) failed with %x\n", status) );
        return ENODEV;
    }

    if ( *(ULONG *)packet.yip != 0 ) {
        NetLocalIpAddress = *(ULONG *)packet.yip;
    }
    if ( *(ULONG *)packet.sip != 0 ) {
        NetServerIpAddress = *(ULONG *)packet.sip;
    }

    if (FindDhcpOption(&packet, DHCP_ROUTER, sizeof(temp), (PUCHAR)&temp, NULL, 0) == ESUCCESS) {
        NetGatewayIpAddress = temp;
    } else if ( *(ULONG *)packet.gip != 0 ) {
        NetGatewayIpAddress = *(ULONG *)packet.gip;
    }
    if (FindDhcpOption(&packet, DHCP_SUBNET, sizeof(temp), (PUCHAR)&temp, NULL, 0) == ESUCCESS) {
        NetLocalSubnetMask = temp;
    }

    DPRINT( ERROR, ("Client: %x, Subnet mask: %x; Server: %x; Gateway: %x\n",
            NetLocalIpAddress, NetLocalSubnetMask, NetServerIpAddress, NetGatewayIpAddress) );

    //
    // Find the path of the boot filename (the part before the actual name).
    //
    //
    // do the strncpy first.  that way we know the string is null 
    // terminated, and we are then allowed to use standard str 
    // routines (like the strrchr below)
    //
    strncpy( NetBootPath, (PCHAR)packet.bootfile, sizeof(NetBootPath) );
    NetBootPath[sizeof(NetBootPath)-1] = '\0';
    
    p = strrchr(NetBootPath,'\\');
    if (p) {
        p += 1; // advance it past the '\'
        *p = '\0'; // terminate the path
    } else {
        NetBootPath[0] = '\0';
    }
    
    //
    // The BINL server could optionally specify two private DHCP option tags
    // that are used for processing boot.ini.
    //
    // DHCP_LOADER_BOOT_INI would contain the entire contents of boot.ini
    // and is limited to 1024 bytes. Note that each DHCP option tags is 
    // to 255 bytes. Boot.ini contents can be broken into multiple instances
    // of the same tag. We support up to 4 instances = 1020 bytes.
    //
    for (i = 0; i < 4; i++) {

        if (FindDhcpOption( &packet, 
                            DHCP_LOADER_BOOT_INI, 
                            255, 
                            &NetBootIniContents[i * 255], 
                            NULL,
                            i) != ESUCCESS ) {
            break;
        }                        
    }
    
    //
    // DHCP_LOADER_BOOT_INI_PATH contains a path to a boot.ini file and is 
    // ignored if DHCP_LOADER_BOOT_INI has been specified.
    //
    FindDhcpOption(&packet, DHCP_LOADER_BOOT_INI_PATH, sizeof(NetBootIniPath), NetBootIniPath, NULL, 0);

    //
    // Get UNDI information
    //

    RtlZeroMemory(&info, sizeof(info));
    status = NETPC_ROM_SERVICES( PXENV_UNDI_GET_INFORMATION, &info );
    if ((status != PXENV_EXIT_SUCCESS) || (info.Status != PXENV_EXIT_SUCCESS)) {
        DPRINT( ERROR, ("PXENV_UNDI_GET_INFORMATION failed with %x, status = %x\n", status, info.Status) );
        return ENODEV;
    }

    NetMaxTranUnit = info.MaxTranUnit;
    NetHwAddrLen = info.HwAddrLen;
    NetHwType = info.HwType;
    memcpy( NetLocalHardwareAddress, info.PermNodeAddress, ADDR_LEN );

    return ESUCCESS;
}


ARC_STATUS
GetGuid(
    OUT PUCHAR *Guid,
    OUT PULONG GuidLength
    )

/*++

Routine Description:

    This routine returns the Guid of this machine.

Arguments:

    Guid - Place to store pointer to the guid.

    GuidLength - Place to store the length in bytes of the guid.

Return Value:

    ARC code indicating outcome.

--*/

{
    t_PXENV_GET_BINL_INFO gbi;
    BOOTPLAYER packet;
    SHORT romStatus;
    ARC_STATUS Status;
    UCHAR TmpBuffer[sizeof(MyGuid) + 1];

    if (!MyGuidValid) {
        RtlZeroMemory( &packet, sizeof(packet) ) ;
        gbi.packet_type = PXENV_PACKET_TYPE_BINL_REPLY;
        gbi.buffer_size = sizeof(packet);
        gbi.buffer_offset = (USHORT)((ULONG_PTR)&packet & 0x0f);
        gbi.buffer_segment = (USHORT)(((ULONG_PTR)&packet >> 4) & 0xffff);

        romStatus = NETPC_ROM_SERVICES( PXENV_GET_BINL_INFO, &gbi );
        if ( romStatus == PXENV_EXIT_SUCCESS ) {
            Status = FindDhcpOption(&packet,
                                    DHCP_CLIENT_GUID,
                                    sizeof(TmpBuffer),
                                    TmpBuffer,
                                    &MyGuidLength,
                                    0);
            if (Status == ESUCCESS) {

                if (MyGuidLength > sizeof(MyGuid)) {
                    //
                    // use the end of the GUID if it's too large.
                    //
                    memcpy(MyGuid, TmpBuffer + (MyGuidLength - sizeof(MyGuid)), sizeof(MyGuid));
                    MyGuidLength = sizeof(MyGuid);
                } else {
                    memcpy(MyGuid, TmpBuffer, MyGuidLength);
                }

                *Guid = MyGuid;
                *GuidLength = MyGuidLength;
                MyGuidValid = TRUE;
                return ESUCCESS;
            }
        }

        //
        // Use the NIC hardware address as a GUID
        //
        memset(MyGuid, 0x0, sizeof(MyGuid));
        memcpy(MyGuid + sizeof(MyGuid) - sizeof(NetLocalHardwareAddress),
               NetLocalHardwareAddress,
               sizeof(NetLocalHardwareAddress)
              );
        MyGuidLength = sizeof(MyGuid);
        MyGuidValid = TRUE;
    }

    *Guid = MyGuid;
    *GuidLength = MyGuidLength;

    return ESUCCESS;
}


ULONG
CalculateChecksum(
    IN PLONG Block,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine calculates a simple two's-complement checksum of a block of
    memory. If the returned value is stored in the block (in a word that was
    zero during the calculation), then new checksum of the block will be zero.

Arguments:

    Block - Address of a block of data. Must be 4-byte aligned.

    Length - Length of the block. Must be a multiple of 4.

Return Value:

    ULONG - Two's complement additive checksum of the input block.

--*/

{
    LONG checksum = 0;

    ASSERT( ((ULONG_PTR)Block & 3) == 0 );
    ASSERT( (Length & 3) == 0 );

    for ( ; Length != 0; Length -= 4 ) {
        checksum += *Block;
        Block++;
    }

    return -checksum;
}


NTSTATUS
NetSoftReboot(
    IN PUCHAR NextBootFile,
    IN ULONGLONG Param,
    IN PUCHAR RebootFile OPTIONAL,
    IN PUCHAR SifFile OPTIONAL,
    IN PUCHAR User OPTIONAL,
    IN PUCHAR Domain OPTIONAL,
    IN PUCHAR Password OPTIONAL,
    IN PUCHAR AdministratorPassword OPTIONAL
    )

/*++

Routine Description:

    This routine does a soft reboot by inserting a fake BINL packet into the ROM and
    then inserting the filename of the start of a TFTP command.

Arguments:

    NextBootFile - Fully qualified path name of the file to download.

    Param - Reboot parameter to set.

    RebootFile - String identifying the file to reboot to when after the current reboot is done.

    SifFile - Optional SIF file to pass to the next loader.

    User/Domain/Password/AdministratorPassword - Optional credentials to pass to the next loader.

Return Value:

    Should not return if successful.

--*/

{

    SHORT romStatus;
    NTSTATUS status = STATUS_SUCCESS;
    union {
        t_PXENV_UDP_CLOSE UdpClose;
        t_PXENV_TFTP_READ_FILE TftpReadFile;
    } command;
    t_PXENV_GET_BINL_INFO gbi;
    BOOTPLAYER * packet;
    PTFTP_RESTART_BLOCK restartBlock;
    PTFTP_RESTART_BLOCK_V1 restartBlockV1;

    DPRINT( TRACE, ("NetSoftReboot ( )\n") );

    ASSERT(NextBootFile != NULL);

    //
    // Store the reboot parameters in memory.
    //
    restartBlock = (PTFTP_RESTART_BLOCK)(0x7C00 + 0x8000 - sizeof(TFTP_RESTART_BLOCK));
    RtlZeroMemory(restartBlock, sizeof(TFTP_RESTART_BLOCK));
    
    BlSetHeadlessRestartBlock(restartBlock);

    if (AdministratorPassword) {
        RtlMoveMemory(restartBlock->AdministratorPassword,AdministratorPassword, OSC_ADMIN_PASSWORD_LEN);        
    }

    restartBlockV1 = (PTFTP_RESTART_BLOCK_V1)(0x7C00 + 0x8000 - sizeof(TFTP_RESTART_BLOCK_V1));

    restartBlockV1->RebootParameter = Param;

    if (RebootFile != NULL) {
        strncpy(restartBlockV1->RebootFile, (PCHAR)RebootFile, sizeof(restartBlockV1->RebootFile));
        restartBlockV1->RebootFile[sizeof(restartBlockV1->RebootFile) - 1] = '\0';
    }

    if (SifFile != NULL) {
        strncpy(restartBlockV1->SifFile, (PCHAR)SifFile, sizeof(restartBlockV1->SifFile));
        restartBlockV1->SifFile[sizeof(restartBlockV1->SifFile) - 1] = '\0';
    }

    if (User != NULL) {
        strncpy(restartBlockV1->User, (PCHAR)User, sizeof(restartBlockV1->User));
        restartBlockV1->User[sizeof(restartBlockV1->User) - 1] = '\0';
    }
    if (Domain != NULL) {
        strncpy(restartBlockV1->Domain, (PCHAR)Domain, sizeof(restartBlockV1->Domain));
        restartBlockV1->Domain[sizeof(restartBlockV1->Domain) - 1] = '\0';
    }
    if (Password != NULL) {
        strncpy(restartBlockV1->Password, (PCHAR)Password, sizeof(restartBlockV1->Password));
        restartBlockV1->Password[sizeof(restartBlockV1->Password) - 1] = '\0';
    }

    //
    // Set the tag in the restart block and calculate and store the checksum.
    //
    restartBlockV1->Tag = 'rtsR';
    restartBlockV1->Checksum = CalculateChecksum((PLONG)(0x7C00 + 0x8000 - 128), 128);

    //
    // For all versions of RIS after NT5.0 we have a new datastructure which is
    // more adaptable for the future.  For this section we have a different checksum,
    // do that now.
    //
    restartBlock->TftpRestartBlockVersion = TFTP_RESTART_BLOCK_VERSION;
    restartBlock->NewCheckSumLength = FIELD_OFFSET(TFTP_RESTART_BLOCK, RestartBlockV1);
    restartBlock->NewCheckSum = CalculateChecksum((PLONG)restartBlock,
                                                  restartBlock->NewCheckSumLength);

    //
    // Modify the BINL reply that the ROM has stored so that
    // the file name looks like the one we are rebooting to
    // (this is so we can retrieve the path correctly after
    // reboot, so we know where to look for bootloader).
    //

    gbi.packet_type = PXENV_PACKET_TYPE_BINL_REPLY;
    gbi.buffer_size = 0;
    gbi.buffer_offset = 0;
    gbi.buffer_segment = 0;

    romStatus = NETPC_ROM_SERVICES( PXENV_GET_BINL_INFO, &gbi );
    if ( romStatus != PXENV_EXIT_SUCCESS ) {
        DPRINT( ERROR, ("PXENV_GET_BINL_INFO(1) failed with %x\n", romStatus) );
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Now convert the segment/offset to a pointer and modify the
    // filename.
    //

    packet = (BOOTPLAYER *)UIntToPtr( ((gbi.buffer_segment << 4) + gbi.buffer_offset) );

    RtlZeroMemory(packet->bootfile, sizeof(packet->bootfile));
    strncpy((PCHAR)packet->bootfile, (PCHAR)NextBootFile, sizeof(packet->bootfile));
    packet->bootfile[sizeof(packet->bootfile)-1] = '\0';


    //
    // First tell the ROM to shut down its UDP layer.
    //

    RtlZeroMemory( &command, sizeof(command) );

    command.UdpClose.Status = 0;
    status = NETPC_ROM_SERVICES( PXENV_UDP_CLOSE, &command );
    if ( status != 0 ) {
        DPRINT( ERROR, ("NetSoftReboot: error %d from UDP_CLOSE\n", status) );
    }

    //
    // Now tell the ROM to reboot and do a TFTP read of the specified
    // file from the specifed server.
    //

    RtlZeroMemory( &command, sizeof(command) );

    command.TftpReadFile.BufferOffset = 0x7c00;  // standard boot image location
    // 32K (max size allowed) less area for passing parameters
    command.TftpReadFile.BufferSize = 0x8000 - sizeof(TFTP_RESTART_BLOCK);

    *(ULONG *)command.TftpReadFile.ServerIPAddress = NetServerIpAddress;

    //
    // Determine whether we need to send via the gateway.
    //

    if ( (NetServerIpAddress & NetLocalSubnetMask) == (NetLocalIpAddress & NetLocalSubnetMask) ) {
        *(UINT32 *)command.TftpReadFile.GatewayIPAddress = 0;
    } else {
        *(UINT32 *)command.TftpReadFile.GatewayIPAddress = NetGatewayIpAddress;
    }

    strcpy((PCHAR)command.TftpReadFile.FileName, (PCHAR)NextBootFile);

    //
    // This should not return if it succeeds!
    //

    romStatus = NETPC_ROM_SERVICES( PXENV_RESTART_TFTP, &command );

    if ( (romStatus != 0) || (command.TftpReadFile.Status != 0) ) {

        DPRINT( ERROR, ("NetSoftReboot: Could not reboot to <%s>, %d/%d\n",
                NextBootFile, romStatus, command.TftpReadFile.Status) );
        status = STATUS_UNSUCCESSFUL;

    }

    return status;

}

VOID
NetGetRebootParameters(
    OUT PULONGLONG Param OPTIONAL,
    OUT PUCHAR RebootFile OPTIONAL,
    OUT PUCHAR SifFile OPTIONAL,
    OUT PUCHAR User OPTIONAL,
    OUT PUCHAR Domain OPTIONAL,
    OUT PUCHAR Password OPTIONAL,
    OUT PUCHAR AdministratorPassword OPTIONAL,
    BOOLEAN ClearRestartBlock
    )

/*++

Routine Description:

    This routine reads the reboot parameters from the TFTP_RESTART_BLOCK
    that ends at physical address 0x7c00 + 0x8000
    and returns them. (then clearing the address)

    0x7c00 is the base address for startrom.com
    0x8000 is the largest startrom.com allowed.
    then we reserve some space at the end for parameters.

Arguments:

    Param - Space for returning the value.

    RebootFile - Optional space for storing the file to reboot to when done here. (size >= char[128])

    SifFile - Optional space for storing a SIF file passed from whoever
        initiated the soft reboot.

    User/Domain/Password/AdministratorPassword - Optional space to store credentials passed across
        the soft reboot.

    ClearRestartBlock - If set to TRUE, it wipes out the memory here - should be done exactly once, at the
        last call to this function.

Return Value:

    None.

--*/

{
    PTFTP_RESTART_BLOCK restartBlock;
    PTFTP_RESTART_BLOCK_V1 restartBlockV1;
    TFTP_RESTART_BLOCK nullRestartBlock;
    BOOLEAN restartBlockValid;

    restartBlock = (PTFTP_RESTART_BLOCK)(0x7C00 + 0x8000 - sizeof(TFTP_RESTART_BLOCK));
    restartBlockV1 = (PTFTP_RESTART_BLOCK_V1)(0x7C00 + 0x8000 - sizeof(TFTP_RESTART_BLOCK_V1));

    //
    // See if the block is valid. If it's not, we create a temporary empty
    // one so the copy logic below doesn't have to keep checking.
    //

    if ((restartBlockV1->Tag == 'rtsR') &&
        (CalculateChecksum((PLONG)(0x7C00 + 0x8000 - 128), 128) == 0)) {
        restartBlockValid = TRUE;
    } else {
        restartBlockValid = FALSE;
        RtlZeroMemory( &nullRestartBlock, sizeof(TFTP_RESTART_BLOCK) );
        restartBlock = &nullRestartBlock;
    }


    //
    // Copy out the parameters that were in the original TFTP_RESTART_BLOCK structure.
    // These shipped in Win2K.
    //
    // Unfortunetly we do not know the size of the parameters passed to us.
    // Assume they are no smaller than the fields in the restart block
    //
    if (Param != NULL) {
        *Param = restartBlockV1->RebootParameter;
    }

    if (RebootFile != NULL) {
        memcpy(RebootFile, restartBlockV1->RebootFile, sizeof(restartBlockV1->RebootFile));
    }

    if (SifFile != NULL) {
        memcpy(SifFile, restartBlockV1->SifFile, sizeof(restartBlockV1->SifFile));
    }

    if (User != NULL) {
        strncpy((PCHAR)User, restartBlockV1->User, sizeof(restartBlockV1->User));
        User[sizeof(restartBlockV1->User)-1] = '\0';
    }
    if (Domain != NULL) {
        strncpy((PCHAR)Domain, restartBlockV1->Domain, sizeof(restartBlockV1->Domain));
        Domain[sizeof(restartBlockV1->Domain)-1] = '\0';
    }
    if (Password != NULL) {
        strncpy((PCHAR)Password, restartBlockV1->Password, sizeof(restartBlockV1->Password));
        Password[sizeof(restartBlockV1->Password)-1] = '\0';
    }

    //
    // Now do a new check for all versions past Win2K
    //
    if (restartBlockValid) {

        ULONG RestartBlockChecksumPointer = 0;

        //
        // Figure out how much of the restart block needs to be checksumed.
        //
        RestartBlockChecksumPointer = (ULONG)restartBlockV1;
        RestartBlockChecksumPointer -= (restartBlock->NewCheckSumLength);
        RestartBlockChecksumPointer -= (sizeof(restartBlock->NewCheckSumLength));

        if ((restartBlock->NewCheckSumLength == 0) ||
            (CalculateChecksum((PLONG)(RestartBlockChecksumPointer), restartBlock->NewCheckSumLength) != 0)) {

            //
            // A pre-Win2K OsChooser has given us this block.  Clear out all fields
            // that are post-Win2K and continue.
            //
            RtlZeroMemory(restartBlock, FIELD_OFFSET(TFTP_RESTART_BLOCK, RestartBlockV1));

        }

    }

    //
    // Now extract the parameters from the block.
    //
    if (restartBlock->TftpRestartBlockVersion == TFTP_RESTART_BLOCK_VERSION) {
        BlGetHeadlessRestartBlock(restartBlock, restartBlockValid);

        if (AdministratorPassword) {
            RtlMoveMemory(AdministratorPassword,restartBlock->AdministratorPassword, OSC_ADMIN_PASSWORD_LEN);
        }
    }    

    if (restartBlockValid && ClearRestartBlock) {
        RtlZeroMemory(restartBlock, sizeof(TFTP_RESTART_BLOCK));
    }

    return;
}


ARC_STATUS
NetFillNetworkLoaderBlock (
    PNETWORK_LOADER_BLOCK NetworkLoaderBlock
    )
{
    SHORT status;
    t_PXENV_GET_BINL_INFO gbi;
    BOOTPLAYER packet;


    //
    // Get client IP address, server IP address, default gateway IP address,
    // and subnet mask from the DHCP ACK packet.
    //
    
    gbi.packet_type = PXENV_PACKET_TYPE_DHCP_ACK;
    gbi.buffer_size = sizeof(packet);
    gbi.buffer_offset = (USHORT)((ULONG_PTR)&packet & 0x0f);
    gbi.buffer_segment = (USHORT)(((ULONG_PTR)&packet >> 4) & 0xffff);

    status = NETPC_ROM_SERVICES( PXENV_GET_BINL_INFO, &gbi );
    if ( status != PXENV_EXIT_SUCCESS ) {
        DbgPrint("PXENV_GET_BINL_INFO(DHCPACK) failed with %x\n", status);
        return ENODEV;
    }

    NetworkLoaderBlock->DHCPServerACK = BlAllocateHeap(gbi.buffer_size);
    if (NetworkLoaderBlock->DHCPServerACK == NULL) {
        return ENOMEM;
    }

    memcpy( NetworkLoaderBlock->DHCPServerACK, &packet, gbi.buffer_size );
    NetworkLoaderBlock->DHCPServerACKLength = gbi.buffer_size;

    gbi.packet_type = PXENV_PACKET_TYPE_BINL_REPLY;
    gbi.buffer_size = sizeof(packet);
    gbi.buffer_offset = (USHORT)((ULONG_PTR)&packet & 0x0f);
    gbi.buffer_segment = (USHORT)(((ULONG_PTR)&packet >> 4) & 0xffff);

    status = NETPC_ROM_SERVICES( PXENV_GET_BINL_INFO, &gbi );
    if ( status != PXENV_EXIT_SUCCESS ) {
        DbgPrint("PXENV_GET_BINL_INFO(BINLREPLY) failed with %x\n", status);
    } else {

        NetworkLoaderBlock->BootServerReplyPacket = BlAllocateHeap(gbi.buffer_size);
        if (NetworkLoaderBlock->BootServerReplyPacket == NULL) {
            return ENOMEM;
        }

        memcpy( NetworkLoaderBlock->BootServerReplyPacket, &packet, gbi.buffer_size );
        NetworkLoaderBlock->BootServerReplyPacketLength = gbi.buffer_size;
    }

    return ESUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\ntfsboot.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsBoot.c

Abstract:

    This module implements the Ntfs boot file system used by the operating system
    loader.

Author:

    Gary Kimura     [GaryKi]    10-April-1992

Revision History:

--*/

//
//  Stuff to get around the fact that we include both Fat, Hpfs, and Ntfs include
//  environments
//

#define _FAT_
#define _HPFS_
#define _CVF_

#define VBO ULONG
#define LBO ULONG
#define BIOS_PARAMETER_BLOCK ULONG
#define CVF_LAYOUT ULONG
#define CVF_HEADER ULONG
#define COMPONENT_LOCATION ULONG
#define PCVF_FAT_EXTENSIONS PCHAR

typedef struct DIRENT {
    char      Garbage[32];
} DIRENT;                                       //  sizeof = 32


#include "bootlib.h"
#include "stdio.h"
#include "blcache.h"

#include "bootstatus.h"

BOOTFS_INFO NtfsBootFsInfo={L"ntfs"};

#undef VBO
#undef LBO
#undef BIOS_PARAMETER_BLOCK
#undef DIRENT

#include "ntfs.h"

int Line = 0;

VOID NtfsPrint( IN PCHAR FormatString, ... )
{   va_list arglist; CHAR text[78+1]; ULONG Count,Length;

    va_start(arglist,FormatString);
    Length = _vsnprintf(text,sizeof(text),FormatString,arglist);
    text[78] = 0;
    ArcWrite(ARC_CONSOLE_OUTPUT,text,Length,&Count);
    va_end(arglist);
}

VOID NtfsGetChar(VOID) { UCHAR c; ULONG count; ArcRead(ARC_CONSOLE_INPUT,&c,1,&count); }

#define ReadConsole(c) {                                             \
    UCHAR Key=0; ULONG Count;                                        \
    while (Key != c) {                                               \
        if (ArcGetReadStatus(BlConsoleInDeviceId) == ESUCCESS) {     \
            ArcRead(BlConsoleInDeviceId, &Key, sizeof(Key), &Count); \
        }                                                            \
    }                                                                \
}

#define Pause   ReadConsole( ' ' )

#if FALSE
#define PausedPrint(x) {                                            \
    NtfsPrint x;                                                    \
    Line++;                                                         \
    if (Line >= 20) {                                               \
        NtfsPrint( ">" );                                           \
        Pause;                                                      \
        Line = 0;                                                   \
    }                                                               \
}
#else
#define PausedPrint(x)
#endif

#define ToUpper(C) ((((C) >= 'a') && ((C) <= 'z')) ? (C) - 'a' + 'A' : (C))

#define DereferenceFileRecord(idx) {                                \
    NtfsFileRecordBufferPinned[idx] -= 1;                           \
    if (NtfsFileRecordBufferPinned[idx] & 0xFF00) {                 \
        PausedPrint(( "NtfsFileRecordBufferPinned[%x]=%x\r\n",      \
                      idx, NtfsFileRecordBufferPinned[idx]));       \
    }                                                               \
}


//
//  Low level disk read routines
//

//
//  VOID
//  ReadDisk (
//      IN ULONG DeviceId,
//      IN LONGLONG Lbo,
//      IN ULONG ByteCount,
//      IN OUT PVOID Buffer,
//      IN BOOLEAN CacheNewData
//      );
//

ARC_STATUS
NtfsReadDisk (
    IN ULONG DeviceId,
    IN LONGLONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer,
    IN BOOLEAN CacheNewData
    );

#define ReadDisk(A,B,C,D,E) { ARC_STATUS _s;                     \
    if ((_s = NtfsReadDisk(A,B,C,D,E)) != ESUCCESS) {return _s;} \
}

//
//  Low level disk write routines
//
//
//  VOID
//  WriteDisk (
//      IN ULONG DeviceId,
//      IN LONGLONG Lbo,
//      IN ULONG ByteCount,
//      IN OUT PVOID Buffer
//      );
//

ARC_STATUS
NtfsWriteDisk (
    IN ULONG DeviceId,
    IN LONGLONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer
    );

#define WriteDisk(A,B,C,D) { ARC_STATUS _s;                     \
    if ((_s = NtfsWriteDisk(A,B,C,D)) != ESUCCESS) {return _s;} \
}

//
//  Attribute lookup and read routines
//
//
//  VOID
//  LookupAttribute (
//      IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
//      IN LONGLONG FileRecord,
//      IN ATTRIBUTE_TYPE_CODE TypeCode,
//      OUT PBOOLEAN FoundAttribute,
//      OUT PNTFS_ATTRIBUTE_CONTEXT AttributeContext
//      );
//
//  VOID
//  ReadAttribute (
//      IN PNTFS_STRUCTURE_CONTEXT StructureContext,
//      IN PNTFS_ATTRIBUTE_CONTEXT AttributeContext,
//      IN VBO Vbo,
//      IN ULONG Length,
//      IN PVOID Buffer
//      );
//
//  VOID
//  ReadAndDecodeFileRecord (
//      IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
//      IN LONGLONG FileRecord,
//      OUT PULONG Index
//      );
//
//  VOID
//  DecodeUsa (
//      IN PVOID UsaBuffer,
//      IN ULONG Length
//      );
//

ARC_STATUS
NtfsLookupAttribute(
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN LONGLONG FileRecord,
    IN ATTRIBUTE_TYPE_CODE TypeCode,
    OUT PBOOLEAN FoundAttribute,
    OUT PNTFS_ATTRIBUTE_CONTEXT AttributeContext
    );

ARC_STATUS
NtfsReadResidentAttribute (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    IN ULONG Length,
    IN PVOID Buffer
    );

ARC_STATUS
NtfsReadNonresidentAttribute (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    IN ULONG Length,
    IN PVOID Buffer
    );

ARC_STATUS
NtfsWriteNonresidentAttribute (
    IN PNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    IN ULONG Length,
    IN PVOID Buffer
    );

ARC_STATUS
NtfsReadAndDecodeFileRecord (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN LONGLONG FileRecord,
    OUT PULONG Index
    );

ARC_STATUS
NtfsDecodeUsa (
    IN PVOID UsaBuffer,
    IN ULONG Length
    );

#define LookupAttribute(A,B,C,D,E) { ARC_STATUS _s;                     \
    if ((_s = NtfsLookupAttribute(A,B,C,D,E)) != ESUCCESS) {return _s;} \
}

#define ReadAttribute(A,B,C,D,E) { ARC_STATUS _s;                                    \
    if ((B)->IsAttributeResident) {                                                  \
        if ((_s = NtfsReadResidentAttribute(A,B,C,D,E)) != ESUCCESS) {return _s;}    \
    } else {                                                                         \
        if ((_s = NtfsReadNonresidentAttribute(A,B,C,D,E)) != ESUCCESS) {return _s;} \
    }                                                                                \
}

#define ReadAndDecodeFileRecord(A,B,C) { ARC_STATUS _s;                       \
    if ((_s = NtfsReadAndDecodeFileRecord(A,B,C)) != ESUCCESS) { return _s; } \
}

#define DecodeUsa(A,B) { ARC_STATUS _s;                     \
    if ((_s = NtfsDecodeUsa(A,B)) != ESUCCESS) {return _s;} \
}


//
//  Directory and index lookup routines
//
//
//  VOID
//  SearchForFileName (
//      IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
//      IN CSTRING FileName,
//      IN OUT PLONGLONG FileRecord,
//      OUT PBOOLEAN FoundFileName,
//      OUT PBOOLEAN IsDirectory
//      );
//
//  VOID
//  IsRecordAllocated (
//      IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
//      IN PCNTFS_ATTRIBUTE_CONTEXT AllocationBitmap,
//      IN ULONG BitOffset,
//      OUT PBOOLEAN IsAllocated
//      );
//

ARC_STATUS
NtfsSearchForFileName (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN CSTRING FileName,
    IN OUT PLONGLONG FileRecord,
    OUT PBOOLEAN FoundFileName,
    OUT PBOOLEAN IsDirectory
    );

ARC_STATUS
NtfsIsRecordAllocated (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AllocationBitmap,
    IN ULONG BitOffset,
    OUT PBOOLEAN IsAllocated
    );

ARC_STATUS
NtfsLinearDirectoryScan(
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN CSTRING FileName,
    IN OUT PLONGLONG FileRecord,
    OUT PBOOLEAN Found,
    OUT PBOOLEAN IsDirectory
    );

ARC_STATUS
NtfsInexactSortedDirectoryScan(
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN CSTRING FileName,
    IN OUT PLONGLONG FileRecord,
    OUT PBOOLEAN Found,
    OUT PBOOLEAN IsDirectory
    );

#define SearchForFileName(A,B,C,D,E)                            \
{                                                               \
    ARC_STATUS _s;                                              \
    if ((_s = NtfsSearchForFileName(A,B,C,D,E)) != ESUCCESS) {  \
        return _s;                                              \
    }                                                           \
}

#define IsRecordAllocated(A,B,C,D)                              \
{                                                               \
    ARC_STATUS _s;                                              \
    if ((_s = NtfsIsRecordAllocated(A,B,C,D)) != ESUCCESS) {    \
        return _s;                                              \
    }                                                           \
}

#define LinearDirectoryScan(A,B,C,D,E)                          \
{                                                               \
    ARC_STATUS _s;                                              \
    if ((_s = NtfsLinearDirectoryScan(A,B,C,D,E)) != ESUCCESS) {\
        return _s;                                              \
    }                                                           \
}

#define InexactSortedDirectoryScan(A,B,C,D,E)                   \
{                                                               \
    ARC_STATUS _s;                                              \
    if ((_s = NtfsInexactSortedDirectoryScan(A,B,C,D,E)) != ESUCCESS) {\
        return _s;                                              \
    }                                                           \
}





//
//  Mcb support routines
//
//
//  VOID
//  LoadMcb (
//      IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
//      IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
//      IN VBO Vbo,
//      IN PNTFS_MCB Mcb
//      );
//
//  VOID
//  VboToLbo (
//      IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
//      IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
//      IN VBO Vbo,
//      OUT PLBO Lbo,
//      OUT PULONG ByteCount
//      );
//
//  VOID
//  DecodeRetrievalInformation (
//      IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
//      IN PNTFS_MCB Mcb,
//      IN VCN Vcn,
//      IN PATTRIBUTE_RECORD_HEADER AttributeHeader
//      );
//

ARC_STATUS
NtfsLoadMcb (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    IN PNTFS_MCB Mcb
    );

ARC_STATUS
NtfsVboToLbo (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    OUT PLBO Lbo,
    OUT PULONG ByteCount
    );

ARC_STATUS
NtfsDecodeRetrievalInformation (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PNTFS_MCB Mcb,
    IN VCN Vcn,
    IN PATTRIBUTE_RECORD_HEADER AttributeHeader
    );

#define LoadMcb(A,B,C,D) { ARC_STATUS _s;                     \
    if ((_s = NtfsLoadMcb(A,B,C,D)) != ESUCCESS) {return _s;} \
}

#define VboToLbo(A,B,C,D,E) { ARC_STATUS _s;                     \
    if ((_s = NtfsVboToLbo(A,B,C,D,E)) != ESUCCESS) {return _s;} \
}

#define DecodeRetrievalInformation(A,B,C,D) { ARC_STATUS _s;                     \
    if ((_s = NtfsDecodeRetrievalInformation(A,B,C,D)) != ESUCCESS) {return _s;} \
}


//
//  Miscellaneous routines
//


VOID
NtfsFirstComponent (
    IN OUT PCSTRING String,
    OUT PCSTRING FirstComponent
    );

int
NtfsCompareName (
    IN CSTRING AnsiString,
    IN UNICODE_STRING UnicodeString
    );

VOID
NtfsInvalidateCacheEntries(
    IN ULONG DeviceId
    );
//
//  VOID
//  FileReferenceToLargeInteger (
//      IN PFILE_REFERENCE FileReference,
//      OUT PLONGLONG LargeInteger
//      );
//
//  VOID
//  InitializeAttributeContext (
//      IN PNTFS_STRUCTURE_CONTEXT StructureContext,
//      IN PVOID FileRecordBuffer,
//      IN PVOID AttributeHeader,
//      IN LONGLONG FileRecord,
//      OUT PNTFS_ATTRIBUTE_CONTEXT AttributeContext
//      );
//

#define FileReferenceToLargeInteger(FR,LI) {     \
    *(LI) = *(PLONGLONG)&(FR);              \
    ((PFILE_REFERENCE)(LI))->SequenceNumber = 0; \
}

//
//**** note that the code to get the compression engine will need to change
//**** once the NTFS format changes
//

#define InitializeAttributeContext(SC,FRB,AH,FR,AC) {                               \
    (AC)->TypeCode = (AH)->TypeCode;                                                \
    (AC)->FileRecord = (FR);                                                        \
    (AC)->FileRecordOffset = (USHORT)PtrOffset((FRB),(AH));                         \
    if (((AC)->IsAttributeResident = ((AH)->FormCode == RESIDENT_FORM)) != 0) {     \
        (AC)->DataSize = /*xxFromUlong*/((AH)->Form.Resident.ValueLength);          \
    } else {                                                                        \
        (AC)->DataSize = (AH)->Form.Nonresident.FileSize;                           \
    }                                                                               \
    (AC)->CompressionFormat = COMPRESSION_FORMAT_NONE;                              \
    if ((AH)->Flags & ATTRIBUTE_FLAG_COMPRESSION_MASK) {                            \
        ULONG _i;                                                                   \
        (AC)->CompressionFormat = COMPRESSION_FORMAT_LZNT1;                         \
        (AC)->CompressionUnit = (SC)->BytesPerCluster;                              \
        for (_i = 0; _i < (AH)->Form.Nonresident.CompressionUnit; _i += 1) {        \
            (AC)->CompressionUnit *= 2;                                             \
        }                                                                           \
    }                                                                               \
}

#define FlagOn(Flags,SingleFlag) ((BOOLEAN)(((Flags) & (SingleFlag)) != 0))
#define SetFlag(Flags,SingleFlag) { (Flags) |= (SingleFlag); }
#define ClearFlag(Flags,SingleFlag) { (Flags) &= ~(SingleFlag); }

#define Add2Ptr(POINTER,INCREMENT) ((PVOID)((PUCHAR)(POINTER) + (INCREMENT)))
#define PtrOffset(BASE,OFFSET) ((ULONG)((ULONG_PTR)(OFFSET) - (ULONG_PTR)(BASE)))

#define Minimum(X,Y) ((X) < (Y) ? (X) : (Y))

#define IsCharZero(C)    (((C) & 0x000000ff) == 0x00000000)
#define IsCharLtrZero(C) (((C) & 0x00000080) == 0x00000080)

//
//  The following types and macros are used to help unpack the packed and misaligned
//   fields found in the Bios parameter block
//

typedef union _UCHAR1 { UCHAR  Uchar[1]; UCHAR  ForceAlignment; } UCHAR1, *PUCHAR1;
typedef union _UCHAR2 { UCHAR  Uchar[2]; USHORT ForceAlignment; } UCHAR2, *PUCHAR2;
typedef union _UCHAR4 { UCHAR  Uchar[4]; ULONG  ForceAlignment; } UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }


//
//  Define global data.
//

ULONG LastMcb = 0;
BOOLEAN FirstTime = TRUE;

//
//  File entry table - This is a structure that provides entry to the NTFS
//      file system procedures. It is exported when a NTFS file structure
//      is recognized.
//

BL_DEVICE_ENTRY_TABLE NtfsDeviceEntryTable;

//
//  These are the static buffers that we use when read file records and index
//  allocation buffers.  To save ourselves some extra reads we will identify the
//  current file record by its Vbo within the mft.
//

#define BUFFER_COUNT (64)

USHORT NtfsFileRecordBufferPinned[BUFFER_COUNT];
VBO NtfsFileRecordBufferVbo[BUFFER_COUNT];
PFILE_RECORD_SEGMENT_HEADER NtfsFileRecordBuffer[BUFFER_COUNT];

PINDEX_ALLOCATION_BUFFER NtfsIndexAllocationBuffer;

//
//  The following field are used to identify and store the cached
//  compressed buffer and its uncompressed equivalent.  The first
//  two fields identifies the attribute stream, and the third field
//  identifies the Vbo within the attribute stream that we have
//  cached.  The compressed and uncompressed buffer contains
//  the data.
//

LONGLONG NtfsCompressedFileRecord;
USHORT        NtfsCompressedOffset;
ULONG         NtfsCompressedVbo;

PUCHAR NtfsCompressedBuffer;
PUCHAR NtfsUncompressedBuffer;

UCHAR NtfsBuffer0[MAXIMUM_FILE_RECORD_SIZE+256];
UCHAR NtfsBuffer1[MAXIMUM_FILE_RECORD_SIZE+256];
UCHAR NtfsBuffer2[MAXIMUM_INDEX_ALLOCATION_SIZE+256];
UCHAR NtfsBuffer3[MAXIMUM_COMPRESSION_UNIT_SIZE+256];
UCHAR NtfsBuffer4[MAXIMUM_COMPRESSION_UNIT_SIZE+256];

//
//  The following is a simple prefix cache to speed up directory traversal
//

typedef struct {

    //
    //  DeviceId used to for I/O.  Serves as unique volume identifier
    //

    ULONG DeviceId;

    //
    //  Parent file record of entry
    //

    LONGLONG ParentFileRecord;

    //
    //  Name length and text of entry.  This is already uppercased!
    //

    ULONG NameLength;
    UCHAR RelativeName[32];

    //
    //  File record of name relative to parent
    //

    LONGLONG ChildFileRecord;
} NTFS_CACHE_ENTRY;

#define MAX_CACHE_ENTRIES   8
NTFS_CACHE_ENTRY NtfsLinkCache[MAX_CACHE_ENTRIES];
ULONG NtfsLinkCacheCount = 0;


PBL_DEVICE_ENTRY_TABLE
IsNtfsFileStructure (
    IN ULONG DeviceId,
    IN PVOID OpaqueStructureContext
    )

/*++

Routine Description:

    This routine determines if the partition on the specified channel contains an
    Ntfs file system volume.

Arguments:

    DeviceId - Supplies the file table index for the device on which read operations
        are to be performed.

    StructureContext - Supplies a pointer to a Ntfs file structure context.

Return Value:

    A pointer to the Ntfs entry table is returned if the partition is recognized as
    containing a Ntfs volume. Otherwise, NULL is returned.

--*/

{
    PNTFS_STRUCTURE_CONTEXT StructureContext = (PNTFS_STRUCTURE_CONTEXT)OpaqueStructureContext;

    PPACKED_BOOT_SECTOR BootSector;
    BIOS_PARAMETER_BLOCK Bpb;

    ULONG ClusterSize;
    ULONG FileRecordSize;

    PATTRIBUTE_RECORD_HEADER AttributeHeader;

    ULONG i;

    //
    //  Clear the file system context block for the specified channel and initialize
    //  the global buffer pointers that we use for buffering I/O
    //

    RtlZeroMemory(StructureContext, sizeof(NTFS_STRUCTURE_CONTEXT));

    //
    //  Zero out the pinned buffer array because we start with nothing pinned
    //  Also negate the vbo array to not let us get spooked with stale data
    //

    RtlZeroMemory( NtfsFileRecordBufferPinned, sizeof(NtfsFileRecordBufferPinned));
    for (i = 0; i < BUFFER_COUNT; i += 1) { NtfsFileRecordBufferVbo[i] = -1; }

    NtfsCompressedFileRecord = 0;
    NtfsCompressedOffset     = 0;
    NtfsCompressedVbo        = 0;

    //
    //  Set up a local pointer that we will use to read in the boot sector and check
    //  for an Ntfs partition.  We will temporarily use the global file record buffer
    //

    BootSector = (PPACKED_BOOT_SECTOR)NtfsFileRecordBuffer[0];

    //
    //  Now read in the boot sector and return null if we can't do the read
    //

    if (NtfsReadDisk(DeviceId, 0, sizeof(PACKED_BOOT_SECTOR), BootSector, CACHE_NEW_DATA) != ESUCCESS) {

        return NULL;
    }

    //
    //  Unpack the Bios parameter block
    //

    NtfsUnpackBios( &Bpb, &BootSector->PackedBpb );

    //
    //  Check if it is NTFS, by first checking the signature, then must be zero
    //  fields, then the media type, and then sanity check the non zero fields.
    //

    if (RtlCompareMemory( &BootSector->Oem[0], "NTFS    ", 8) != 8) {

        return NULL;
    }

    if ((Bpb.ReservedSectors != 0) ||
        (Bpb.Fats            != 0) ||
        (Bpb.RootEntries     != 0) ||
        (Bpb.Sectors         != 0) ||
        (Bpb.SectorsPerFat   != 0) ||
        (Bpb.LargeSectors    != 0)) {

        return NULL;
    }

    if ((Bpb.Media != 0xf0) &&
        (Bpb.Media != 0xf8) &&
        (Bpb.Media != 0xf9) &&
        (Bpb.Media != 0xfc) &&
        (Bpb.Media != 0xfd) &&
        (Bpb.Media != 0xfe) &&
        (Bpb.Media != 0xff)) {

        return NULL;
    }

    if ((Bpb.BytesPerSector !=  128) &&
        (Bpb.BytesPerSector !=  256) &&
        (Bpb.BytesPerSector !=  512) &&
        (Bpb.BytesPerSector != 1024) &&
        (Bpb.BytesPerSector != 2048)) {

        return NULL;
    }

    if ((Bpb.SectorsPerCluster !=  1) &&
        (Bpb.SectorsPerCluster !=  2) &&
        (Bpb.SectorsPerCluster !=  4) &&
        (Bpb.SectorsPerCluster !=  8) &&
        (Bpb.SectorsPerCluster != 16) &&
        (Bpb.SectorsPerCluster != 32) &&
        (Bpb.SectorsPerCluster != 64) &&
        (Bpb.SectorsPerCluster != 128)) {

        return NULL;
    }

    if ((BootSector->NumberSectors == 0) ||
        (BootSector->MftStartLcn == 0) ||
        (BootSector->Mft2StartLcn == 0) ||
        (BootSector->ClustersPerFileRecordSegment == 0) ||
        (BootSector->DefaultClustersPerIndexAllocationBuffer == 0)) {

        return NULL;
    }

    if ((BootSector->ClustersPerFileRecordSegment < 0) &&
        ((BootSector->ClustersPerFileRecordSegment > -9) ||
         (BootSector->ClustersPerFileRecordSegment < -31))) {

        return NULL;
    }

    //
    //  So far the boot sector has checked out to be an NTFS partition so now compute
    //  some of the volume constants.
    //

    StructureContext->DeviceId           = DeviceId;

    StructureContext->BytesPerCluster    =
    ClusterSize                          = Bpb.SectorsPerCluster * Bpb.BytesPerSector;

    //
    //  If the number of clusters per file record is less than zero then the file record
    //  size computed by using the negative of this number as a shift value.
    //

    if (BootSector->ClustersPerFileRecordSegment > 0) {

        StructureContext->BytesPerFileRecord =
        FileRecordSize                       = BootSector->ClustersPerFileRecordSegment * ClusterSize;

    } else {

        StructureContext->BytesPerFileRecord =
        FileRecordSize                       = 1 << (-1 * BootSector->ClustersPerFileRecordSegment);
    }

    //
    //  Read in the base file record for the mft
    //

    if (NtfsReadDisk( DeviceId,
                      /*xxXMul*/(BootSector->MftStartLcn * ClusterSize),
                      FileRecordSize,
                      NtfsFileRecordBuffer[0],
                      CACHE_NEW_DATA) != ESUCCESS) {

        return NULL;
    }

    //
    //  Decode Usa for the file record
    //

    if (NtfsDecodeUsa(NtfsFileRecordBuffer[0], FileRecordSize) != ESUCCESS) {

        return NULL;
    }

    //
    //  Make sure the file record is in use
    //

    if (!FlagOn(NtfsFileRecordBuffer[0]->Flags, FILE_RECORD_SEGMENT_IN_USE)) {

        return NULL;
    }

    //
    //  Search for the unnamed $data attribute header, if we reach $end then it is
    //  an error
    //

    for (AttributeHeader = NtfsFirstAttribute( NtfsFileRecordBuffer[0] );
         (AttributeHeader->TypeCode != $DATA) || (AttributeHeader->NameLength != 0);
         AttributeHeader = NtfsGetNextRecord( AttributeHeader )) {

        if (AttributeHeader->TypeCode == $END) {

            return NULL;
        }
    }

    //
    //  Make sure the $data attribute for the mft is non resident
    //

    if (AttributeHeader->FormCode != NONRESIDENT_FORM) {

        return NULL;
    }

    //
    //  Now set the mft structure context up for later use
    //

    InitializeAttributeContext( StructureContext,
                                NtfsFileRecordBuffer[0],
                                AttributeHeader,
                                0,
                                &StructureContext->MftAttributeContext );

    //
    //  Now decipher the part of the Mcb that is stored in the file record
    //

    if (NtfsDecodeRetrievalInformation( StructureContext,
                                        &StructureContext->MftBaseMcb,
                                        0,
                                        AttributeHeader ) != ESUCCESS) {

        return NULL;
    }

    //
    //  We have finished initializing the structure context so now Initialize the
    //  file entry table and return the address of the table.
    //

    NtfsDeviceEntryTable.Open               = NtfsOpen;
    NtfsDeviceEntryTable.Close              = NtfsClose;
    NtfsDeviceEntryTable.Read               = NtfsRead;
    NtfsDeviceEntryTable.Seek               = NtfsSeek;
    NtfsDeviceEntryTable.Write              = NtfsWrite;
    NtfsDeviceEntryTable.GetFileInformation = NtfsGetFileInformation;
    NtfsDeviceEntryTable.SetFileInformation = NtfsSetFileInformation;
    NtfsDeviceEntryTable.BootFsInfo = &NtfsBootFsInfo;

    return &NtfsDeviceEntryTable;
}


ARC_STATUS
NtfsClose (
    IN ULONG FileId
    )

/*++

Routine Description:

    This routine closes the file specified by the file id.

Arguments:

    FileId - Supplies the file table index.

Return Value:

    ESUCCESS if returned as the function value.

--*/

{
    //
    //  Indicate that the file isn't open any longer
    //
    BlFileTable[FileId].Flags.Open = 0;

    //
    //  And return to our caller
    //

    return ESUCCESS;
}


ARC_STATUS
NtfsGetFileInformation (
    IN ULONG FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
    )

/*++

Routine Description:

    This procedure returns to the user a buffer filled with file information

Arguments:

    FileId - Supplies the File id for the operation

    Buffer - Supplies the buffer to receive the file information.  Note that
        it must be large enough to hold the full file name

Return Value:

    ESUCCESS is returned if the open operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PNTFS_STRUCTURE_CONTEXT StructureContext;
    PNTFS_FILE_CONTEXT FileContext;

    NTFS_ATTRIBUTE_CONTEXT AttributeContext;
    BOOLEAN Found;

    STANDARD_INFORMATION StandardInformation;

    ULONG i;

    //
    //  Setup some local references
    //

    FileTableEntry   = &BlFileTable[FileId];
    StructureContext = (PNTFS_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    FileContext      = &FileTableEntry->u.NtfsFileContext;

    //
    //  Zero out the output buffer and fill in its non-zero values
    //

    RtlZeroMemory(Buffer, sizeof(FILE_INFORMATION));

    Buffer->EndingAddress.QuadPart   = FileContext->DataSize;
    Buffer->CurrentPosition = FileTableEntry->Position;

    //
    //  Locate and read in the standard information for the file.  This will get us
    //  the attributes for the file.
    //

    LookupAttribute( StructureContext,
                     FileContext->FileRecord,
                     $STANDARD_INFORMATION,
                     &Found,
                     &AttributeContext );

    if (!Found) { return EBADF; }

    ReadAttribute( StructureContext,
                   &AttributeContext,
                   0,
                   sizeof(STANDARD_INFORMATION),
                   &StandardInformation );

    //
    //  Now check for set bits in the standard information structure and set the
    //  appropriate bits in the output buffer
    //

    if (FlagOn(StandardInformation.FileAttributes, FAT_DIRENT_ATTR_READ_ONLY))   {

        SetFlag(Buffer->Attributes, ArcReadOnlyFile);
    }

    if (FlagOn(StandardInformation.FileAttributes, FAT_DIRENT_ATTR_HIDDEN))      {

        SetFlag(Buffer->Attributes, ArcHiddenFile);
    }

    if (FlagOn(StandardInformation.FileAttributes, FAT_DIRENT_ATTR_SYSTEM))      {

        SetFlag(Buffer->Attributes, ArcSystemFile);
    }

    if (FlagOn(StandardInformation.FileAttributes, FAT_DIRENT_ATTR_ARCHIVE))     {

        SetFlag(Buffer->Attributes, ArcArchiveFile);
    }

    if (FlagOn(StandardInformation.FileAttributes, DUP_FILE_NAME_INDEX_PRESENT)) {

        SetFlag(Buffer->Attributes, ArcDirectoryFile);
    }

    //
    //  Get the file name from the file table entry
    //

    Buffer->FileNameLength = FileTableEntry->FileNameLength;

    for (i = 0; i < FileTableEntry->FileNameLength; i += 1) {

        Buffer->FileName[i] = FileTableEntry->FileName[i];
    }

    //
    //  And return to our caller
    //

    return ESUCCESS;
}


ARC_STATUS
NtfsOpen (
    IN CHAR * FIRMWARE_PTR RWFileName,
    IN OPEN_MODE OpenMode,
    IN ULONG * FIRMWARE_PTR FileId
    )

/*++

Routine Description:

    This routine searches the root directory for a file matching FileName.
    If a match is found the dirent for the file is saved and the file is
    opened.

Arguments:

    FileName - Supplies a pointer to a zero terminated file name.

    OpenMode - Supplies the mode of the open.

    FileId - Supplies a pointer to a variable that specifies the file
        table entry that is to be filled in if the open is successful.

Return Value:

    ESUCCESS is returned if the open operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    const CHAR * FIRMWARE_PTR FileName = (const CHAR * FIRMWARE_PTR)RWFileName;
    PBL_FILE_TABLE FileTableEntry;
    PNTFS_STRUCTURE_CONTEXT StructureContext;
    PNTFS_FILE_CONTEXT FileContext;

    CSTRING PathName;
    CSTRING Name;

    LONGLONG FileRecord;
    BOOLEAN IsDirectory;
    BOOLEAN Found;

    PausedPrint(( "NtfsOpen(\"%s\")\r\n", FileName ));

    //
    //  Load our local variables
    //

    FileTableEntry = &BlFileTable[*FileId];
    StructureContext = (PNTFS_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    FileContext = &FileTableEntry->u.NtfsFileContext;

    //
    //  Zero out the file context and position information in the file table entry
    //

    FileTableEntry->Position.QuadPart = 0;

    RtlZeroMemory(FileContext, sizeof(NTFS_FILE_CONTEXT));

    //
    //  Construct a file name descriptor from the input file name
    //

    RtlInitString( (PSTRING)&PathName, FileName );

    //
    //  Open the root directory as our starting point,  The root directory file
    //  reference number is 5.
    //

    FileRecord = 5;
    IsDirectory = TRUE;

    //
    //  While the path name has some characters left in it and current attribute
    //  context is a directory we will continue our search
    //

    while ((PathName.Length > 0) && IsDirectory) {

        //
        //  Extract the first component and search the directory for a match, but
        //  first copy the first part to the file name buffer in the file table entry
        //

        if (PathName.Buffer[0] == '\\') {

            PathName.Buffer +=1;
            PathName.Length -=1;
        }

        for (FileTableEntry->FileNameLength = 0;
             (((USHORT)FileTableEntry->FileNameLength < PathName.Length) &&
              (PathName.Buffer[FileTableEntry->FileNameLength] != '\\'));
             FileTableEntry->FileNameLength += 1) {

            FileTableEntry->FileName[FileTableEntry->FileNameLength] =
                                      PathName.Buffer[FileTableEntry->FileNameLength];
        }

        NtfsFirstComponent( &PathName, &Name );

        //
        //  Search for the name in the current directory
        //

        SearchForFileName( StructureContext,
                           Name,
                           &FileRecord,
                           &Found,
                           &IsDirectory );

        //
        //  If we didn't find it then we should get out right now
        //

        if (!Found) { return ENOENT; }
    }

    //
    //  At this point we have exhausted our pathname or we did not get a directory
    //  Check if we didn't get a directory and we still have a name to crack
    //

    if (PathName.Length > 0) {

        return ENOTDIR;
    }

    //
    //  Now FileRecord is the one we wanted to open.  Check the various open modes
    //  against what we have located
    //

    if (IsDirectory) {

        switch (OpenMode) {

        case ArcOpenDirectory:

            //
            //  To open the directory we will lookup the index root as our file
            //  context and then increment the appropriate counters.
            //

            LookupAttribute( StructureContext,
                             FileRecord,
                             $INDEX_ROOT,
                             &Found,
                             FileContext );

            if (!Found) { return EBADF; }

            FileTableEntry->Flags.Open = 1;
            FileTableEntry->Flags.Read = 1;

            return ESUCCESS;

        case ArcCreateDirectory:

            return EROFS;

        default:

            return EISDIR;
        }

    }

    switch (OpenMode) {

    case ArcOpenReadWrite:
        //
        // The only file allowed to be opened with write access is the hiberfil
        //
        if (!strstr(FileName, "\\hiberfil.sys") && 
            !strstr(FileName, BSD_FILE_NAME)) {
            return EROFS;
        }

        //
        //  To open the file we will lookup the $data as our file context and then
        //  increment the appropriate counters.
        //

        LookupAttribute( StructureContext,
                         FileRecord,
                         $DATA,
                         &Found,
                         FileContext );

        if (!Found) { return EBADF; }

        FileTableEntry->Flags.Open = 1;
        FileTableEntry->Flags.Read = 1;
        FileTableEntry->Flags.Write = 1;
        return ESUCCESS;

    case ArcOpenReadOnly:

        //
        //  To open the file we will lookup the $data as our file context and then
        //  increment the appropriate counters.
        //

        LookupAttribute( StructureContext,
                         FileRecord,
                         $DATA,
                         &Found,
                         FileContext );

        if (!Found) { return EBADF; }

        FileTableEntry->Flags.Open = 1;
        FileTableEntry->Flags.Read = 1;

        return ESUCCESS;

    case ArcOpenDirectory:

        return ENOTDIR;

    default:

        return EROFS;
    }
}


ARC_STATUS
NtfsRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Transfer
    )

/*++

Routine Description:

    This routine reads data from the specified file.

Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a pointer to the buffer that receives the data
        read.

    Length - Supplies the number of bytes that are to be read.

    Transfer - Supplies a pointer to a variable that receives the number
        of bytes actually transfered.

Return Value:

    ESUCCESS is returned if the read operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PNTFS_STRUCTURE_CONTEXT StructureContext;
    PNTFS_FILE_CONTEXT FileContext;

    LONGLONG AmountLeft;

    //
    //  Setup some local references
    //

    FileTableEntry = &BlFileTable[FileId];
    StructureContext = (PNTFS_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    FileContext = &FileTableEntry->u.NtfsFileContext;

    //
    //  Compute the amount left in the file and then from that we compute the amount
    //  for the transfer
    //

    AmountLeft = /*xxSub*/( FileContext->DataSize - FileTableEntry->Position.QuadPart);

    if (/*xxLeq*/(/*xxFromUlong*/(Length) <= AmountLeft)) {

        *Transfer = Length;

    } else {

        *Transfer = ((ULONG)AmountLeft);
    }

    //
    //  Now issue the read attribute
    //

    ReadAttribute( StructureContext,
                   FileContext,
                   FileTableEntry->Position.QuadPart,
                   *Transfer,
                   Buffer );

    //
    //  Update the current position, and return to our caller
    //

    FileTableEntry->Position.QuadPart = /*xxAdd*/(FileTableEntry->Position.QuadPart + /*xxFromUlong*/(*Transfer));

    return ESUCCESS;
}


ARC_STATUS
NtfsSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    This routine seeks to the specified position for the file specified
    by the file id.

Arguments:

    FileId - Supplies the file table index.

    Offset - Supplies the offset in the file to position to.

    SeekMode - Supplies the mode of the seek operation.

Return Value:

    ESUCCESS if returned as the function value.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    LONGLONG NewPosition;

    //
    //  Load our local variables
    //

    FileTableEntry = &BlFileTable[FileId];

    //
    //  Compute the new position
    //

    if (SeekMode == SeekAbsolute) {

        NewPosition = Offset->QuadPart;

    } else {

        NewPosition = /*xxAdd*/(FileTableEntry->Position.QuadPart + Offset->QuadPart);
    }

    //
    //  If the new position is greater than the file size then return an error
    //

    if (/*xxGtr*/(NewPosition > FileTableEntry->u.NtfsFileContext.DataSize)) {

        return EINVAL;
    }

    //
    //  Otherwise set the new position and return to our caller
    //

    FileTableEntry->Position.QuadPart = NewPosition;

    return ESUCCESS;
}


ARC_STATUS
NtfsSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    )

/*++

Routine Description:

    This routine sets the file attributes of the indicated file

Arguments:

    FileId - Supplies the File Id for the operation

    AttributeFlags - Supplies the value (on or off) for each attribute being modified

    AttributeMask - Supplies a mask of the attributes being altered.  All other
        file attributes are left alone.

Return Value:

    ESUCCESS is returned if the read operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( AttributeFlags );
    UNREFERENCED_PARAMETER( AttributeMask );

    return EROFS;
}


ARC_STATUS
NtfsWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Transfer
    )

/*++

Routine Description:

    This routine writes data to the specified file.

Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a pointer to the buffer that contains the data
        written.

    Length - Supplies the number of bytes that are to be written.

    Transfer - Supplies a pointer to a variable that receives the number
        of bytes actually transfered.

Return Value:

    ESUCCESS is returned if the write operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PNTFS_STRUCTURE_CONTEXT StructureContext;
    PNTFS_FILE_CONTEXT FileContext;
    LONGLONG AmountLeft;
    ULONG Status;

    //
    //  Setup some local references
    //

    FileTableEntry = &BlFileTable[FileId];
    StructureContext = (PNTFS_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    FileContext = &FileTableEntry->u.NtfsFileContext;

    //
    //  Compute the amount left in the file and then from that we compute the amount
    //  for the transfer
    //

    AmountLeft = /*xxSub*/( FileContext->DataSize - FileTableEntry->Position.QuadPart);

    if (Length <= AmountLeft) {

        *Transfer = Length;

    } else {

        *Transfer = ((ULONG)AmountLeft);
    }

    //
    //  Now issue the write attribute
    //

    if (FileContext->IsAttributeResident) {
        return EROFS;
    }

    Status = NtfsWriteNonresidentAttribute(
                StructureContext,
                FileContext,
                FileTableEntry->Position.QuadPart,
                *Transfer,
                Buffer
                );

    if (Status != ESUCCESS) {
        return Status;
    }

    //
    //  Update the current position, and return to our caller
    //

    FileTableEntry->Position.QuadPart += *Transfer;
    return ESUCCESS;
}


ARC_STATUS
NtfsInitialize (
    VOID
    )

/*++

Routine Description:

    This routine initializes the ntfs boot filesystem.
    Currently this is a no-op.

Arguments:

    None.

Return Value:

    ESUCCESS.

--*/

{
    //
    //  The first time we will zero out the file record buffer and allocate
    //  a few buffers for read in data.
    //
    ARC_STATUS Status = ESUCCESS;
    ULONG Index = 0;
    
    RtlZeroMemory(NtfsLinkCache, sizeof(NtfsLinkCache));

    for (Index=0; Index < MAX_CACHE_ENTRIES; Index++) {
        NtfsLinkCache[Index].DeviceId = UNINITIALIZED_DEVICE_ID;
    }
    
    RtlZeroMemory( NtfsFileRecordBuffer, sizeof(NtfsFileRecordBuffer));

    NtfsFileRecordBuffer[0]   = ALIGN_BUFFER(NtfsBuffer0);
    NtfsFileRecordBuffer[1]   = ALIGN_BUFFER(NtfsBuffer1);
    NtfsIndexAllocationBuffer = ALIGN_BUFFER(NtfsBuffer2);
    NtfsCompressedBuffer      = ALIGN_BUFFER(NtfsBuffer3);
    NtfsUncompressedBuffer    = ALIGN_BUFFER(NtfsBuffer4);

#ifdef CACHE_DEVINFO

    Status = ArcRegisterForDeviceClose(NtfsInvalidateCacheEntries);

#endif // for CACHE_DEV_INFO

    return Status;    
}


//
//  Local support routine
//

ARC_STATUS
NtfsReadDisk (
    IN ULONG DeviceId,
    IN LONGLONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer,
    IN BOOLEAN CacheNewData
    )

/*++

Routine Description:

    This routine reads in zero or more bytes from the specified device.

Arguments:

    DeviceId - Supplies the device id to use in the arc calls.

    Lbo - Supplies the LBO to start reading from.

    ByteCount - Supplies the number of bytes to read.

    Buffer - Supplies a pointer to the buffer to read the bytes into.

    CacheNewData - Whether to cache new data read from the disk.

Return Value:

    ESUCCESS is returned if the read operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ARC_STATUS Status;
    ULONG i;

    //
    //  Special case the zero byte read request
    //

    if (ByteCount == 0) {

        return ESUCCESS;
    }

    //
    //  Issue the read through the cache.
    //

    Status = BlDiskCacheRead(DeviceId, 
                             (PLARGE_INTEGER)&Lbo, 
                             Buffer, 
                             ByteCount, 
                             &i,
                             CacheNewData); 

    if (Status != ESUCCESS) {

        return Status;
    }

    //
    //  Make sure we got back the amount requested
    //

    if (ByteCount != i) {

        return EIO;
    }

    //
    //  Everything is fine so return success to our caller
    //

    return ESUCCESS;
}


//
//  Local support routine
//

ARC_STATUS
NtfsWriteDisk (
    IN ULONG DeviceId,
    IN LONGLONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer
    )

/*++

Routine Description:

    This routine Writes in zero or more bytes from the specified device.

Arguments:

    DeviceId - Supplies the device id to use in the arc calls.

    Lbo - Supplies the LBO to start Writeing from.

    ByteCount - Supplies the number of bytes to Write.

    Buffer - Supplies a pointer to the buffer to Write the bytes into.

Return Value:

    ESUCCESS is returned if the Write operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ARC_STATUS Status;
    ULONG i;

    //
    //  Special case the zero byte Write request
    //

    if (ByteCount == 0) {

        return ESUCCESS;
    }


    //
    //  Issue the write through the cache.
    //

    Status = BlDiskCacheWrite (DeviceId,
                               (PLARGE_INTEGER) &Lbo,
                               Buffer,
                               ByteCount,
                               &i);

    if (Status != ESUCCESS) {
        
        return Status;
    }

    //
    //  Make sure we got back the amount requested
    //

    if (ByteCount != i) {

        return EIO;
    }

    //
    //  Everything is fine so return success to our caller
    //

    return ESUCCESS;
}


//
//  Local support routine
//

ARC_STATUS
NtfsLookupAttribute (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN LONGLONG FileRecord,
    IN ATTRIBUTE_TYPE_CODE TypeCode,
    OUT PBOOLEAN FoundAttribute,
    OUT PNTFS_ATTRIBUTE_CONTEXT AttributeContext
    )

/*++

Routine Description:

    This routine search the input file record for the indicated
    attribute record.  It will search through multiple related
    file records to find the attribute.  If the type code is for $data
    then the attribute we look for must be unnamed otherwise we will
    ignore the names of the attributes and return the first attriubute
    of the indicated type.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    FileRecord - Supplies the file record to start searching from.  This need
        not be the base file record.

    TypeCode - Supplies the attribute type that we are looking for

    FoundAttribute - Receives an indicating if the attribute was located

    AttributeContext - Receives the attribute context for the found attribute

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PATTRIBUTE_RECORD_HEADER AttributeHeader;

    NTFS_ATTRIBUTE_CONTEXT AttributeContext1;
    PNTFS_ATTRIBUTE_CONTEXT AttributeList;

    LONGLONG li;
    ATTRIBUTE_LIST_ENTRY AttributeListEntry;

    ULONG BufferIndex;

    //
    //  Unless other noted we will assume we haven't found the attribute
    //

    *FoundAttribute = FALSE;

    //
    //  Read in the file record and if necessary move ourselves up to the base file
    //  record
    //

    ReadAndDecodeFileRecord( StructureContext,
                             FileRecord,
                             &BufferIndex );

    if (/*!xxEqlZero*/(*((PLONGLONG)&(NtfsFileRecordBuffer[BufferIndex]->BaseFileRecordSegment)) != 0)) {

        //
        //  This isn't the base file record so now extract the base file record
        //  number and read it in
        //

        FileReferenceToLargeInteger( NtfsFileRecordBuffer[BufferIndex]->BaseFileRecordSegment,
                                     &FileRecord );

        DereferenceFileRecord( BufferIndex );

        ReadAndDecodeFileRecord( StructureContext,
                                 FileRecord,
                                 &BufferIndex );
    }

    //
    //  Now we have read in the base file record so search for the target attribute
    //  type code and also remember if we find the attribute list attribute
    //

    AttributeList = NULL;

    for (AttributeHeader = NtfsFirstAttribute( NtfsFileRecordBuffer[BufferIndex] );
         AttributeHeader->TypeCode != $END;
         AttributeHeader = NtfsGetNextRecord( AttributeHeader )) {

        //
        //  We have located the attribute in question if the type code match and if
        //  it is either not the data attribute or if it is the data attribute then
        //  it is also unnamed
        //

        if ((AttributeHeader->TypeCode == TypeCode)

                    &&

            ((TypeCode != $DATA) ||
             ((TypeCode == $DATA) && (AttributeHeader->NameLength == 0)))

                    &&

            ((AttributeHeader->FormCode != NONRESIDENT_FORM) ||
             (AttributeHeader->Form.Nonresident.LowestVcn == 0))) {

            //
            //  Indicate that we have found the attribute and setup the output
            //  attribute context and then return to our caller
            //

            *FoundAttribute = TRUE;

            InitializeAttributeContext( StructureContext,
                                        NtfsFileRecordBuffer[BufferIndex],
                                        AttributeHeader,
                                        FileRecord,
                                        AttributeContext );

            DereferenceFileRecord( BufferIndex );

            return ESUCCESS;
        }

        //
        //  Check if this is the attribute list attribute and if so then setup a
        //  local attribute context to use just in case we don't find the attribute
        //  we're after in the base file record
        //

        if (AttributeHeader->TypeCode == $ATTRIBUTE_LIST) {

            InitializeAttributeContext( StructureContext,
                                        NtfsFileRecordBuffer[BufferIndex],
                                        AttributeHeader,
                                        FileRecord,
                                        AttributeList = &AttributeContext1 );
        }
    }

    //
    //  If we reach this point then the attribute has not been found in the base file
    //  record so check if we have located an attribute list.  If not then the search
    //  has not been successful
    //

    if (AttributeList == NULL) {

        DereferenceFileRecord( BufferIndex );

        return ESUCCESS;
    }

    //
    //  Now that we've located the attribute list we need to continue our search.  So
    //  what this outer loop does is search down the attribute list looking for a
    //  match.
    //

    for (li = 0;
         /*xxLtr*/(li < AttributeList->DataSize);
         li = /*xxAdd*/(li + /*xxFromUlong*/(AttributeListEntry.RecordLength))) {

        //
        //  Read in the attribute list entry.  We don't need to read in the name,
        //  just the first part of the list entry.
        //

        ReadAttribute( StructureContext,
                       AttributeList,
                       li,
                       sizeof(ATTRIBUTE_LIST_ENTRY),
                       &AttributeListEntry );

        //
        //  Now check if the attribute matches, and it is the first of multiple
        //  segments, and either it is not $data or if it is $data then it is unnamed
        //

        if ((AttributeListEntry.AttributeTypeCode == TypeCode)

                    &&

            /*xxEqlZero*/(AttributeListEntry.LowestVcn == 0)

                    &&

            ((TypeCode != $DATA) ||
             ((TypeCode == $DATA) && (AttributeListEntry.AttributeNameLength == 0)))) {

            //
            //  We found a match so now compute the file record containing the
            //  attribute we're after and read in the file record
            //

            FileReferenceToLargeInteger( AttributeListEntry.SegmentReference,
                                         &FileRecord );

            DereferenceFileRecord( BufferIndex );

            ReadAndDecodeFileRecord( StructureContext,
                                     FileRecord,
                                     &BufferIndex );

            //
            //  Now search down the file record for our matching attribute, and it
            //  better be there otherwise the attribute list is wrong.
            //

            for (AttributeHeader = NtfsFirstAttribute( NtfsFileRecordBuffer[BufferIndex] );
                 AttributeHeader->TypeCode != $END;
                 AttributeHeader = NtfsGetNextRecord( AttributeHeader )) {

                //
                //  We have located the attribute in question if the type code match
                //  and if it is either not the data attribute or if it is the data
                //  attribute then it is also unnamed
                //

                if ((AttributeHeader->TypeCode == TypeCode)

                            &&

                    ((TypeCode != $DATA) ||
                     ((TypeCode == $DATA) && (AttributeHeader->NameLength == 0)))) {

                    //
                    //  Indicate that we have found the attribute and setup the
                    //  output attribute context and return to our caller
                    //

                    *FoundAttribute = TRUE;

                    InitializeAttributeContext( StructureContext,
                                                NtfsFileRecordBuffer[BufferIndex],
                                                AttributeHeader,
                                                FileRecord,
                                                AttributeContext );

                    DereferenceFileRecord( BufferIndex );

                    return ESUCCESS;
                }
            }

            DereferenceFileRecord( BufferIndex );

            return EBADF;
        }
    }

    //
    //  If we reach this point we've exhausted the attribute list without finding the
    //  attribute
    //

    DereferenceFileRecord( BufferIndex );

    return ESUCCESS;
}


//
//  Local support routine
//

ARC_STATUS
NtfsReadResidentAttribute (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    IN ULONG Length,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This routine reads in the value of a resident attribute.  The attribute
    must be resident.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    AttributeContext - Supplies the attribute being read.

    Vbo - Supplies the offset within the value to return

    Length - Supplies the number of bytes to return

    Buffer - Supplies a pointer to the output buffer for storing the data

Return Value:

    ESUCCESS is returned if the read operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PATTRIBUTE_RECORD_HEADER AttributeHeader;

    ULONG BufferIndex;

    //
    //  Read in the file record containing the resident attribute
    //

    ReadAndDecodeFileRecord( StructureContext,
                             AttributeContext->FileRecord,
                             &BufferIndex );

    //
    //  Get a pointer to the attribute header
    //

    AttributeHeader = Add2Ptr( NtfsFileRecordBuffer[BufferIndex],
                               AttributeContext->FileRecordOffset );

    //
    //  Copy the amount of data the user asked for starting with the proper offset
    //

    RtlMoveMemory( Buffer,
                   Add2Ptr(NtfsGetValue(AttributeHeader), ((ULONG)Vbo)),
                   Length );

    //
    //  And return to our caller
    //

    DereferenceFileRecord( BufferIndex );

    return ESUCCESS;
}


//
//  Local support routine
//

ARC_STATUS
NtfsReadNonresidentAttribute (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    IN ULONG Length,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This routine reads in the value of a Nonresident attribute.  The attribute
    must be Nonresident.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    AttributeContext - Supplies the attribute being read.

    Vbo - Supplies the offset within the value to return

    Length - Supplies the number of bytes to return

    Buffer - Supplies a pointer to the output buffer for storing the data

Return Value:

    ESUCCESS is returned if the read operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    BOOLEAN bCacheNewData;

    //
    //  We want to cache new data read from the disk to satisfy this
    //  request only if we are reading the MFT, or $INDEX_ROOT,
    //  $BITMAP or $INDEX_ALLOCATION attributes for directory look
    //  up. $INDEX_ROOT is supposed to be resident in the file record
    //  but we want cache a read we make for it otherwise.
    //
    
    if ((AttributeContext == &StructureContext->MftAttributeContext) ||
        (AttributeContext->TypeCode == $INDEX_ROOT) ||
        (AttributeContext->TypeCode == $INDEX_ALLOCATION) ||
        (AttributeContext->TypeCode == $BITMAP)) {

        bCacheNewData = CACHE_NEW_DATA;

    } else {

        bCacheNewData = DONT_CACHE_NEW_DATA;

    }
    

    //
    //  Check if we are reading a compressed attribute
    //

    if (AttributeContext->CompressionFormat != 0) {

        //
        //  While there is still some more to copy into the
        //  caller's buffer, we will load the cached compressed buffers
        //  and then copy out the data
        //

        while (Length > 0) {

            ULONG ByteCount;

            //
            //  Load up the cached compressed buffers with the
            //  the proper data.  First check if the buffer is
            //  already (i.e., the file record and offset match and
            //  the vbo we're after is within the buffers range)
            //

            if (/*xxNeq*/(NtfsCompressedFileRecord != AttributeContext->FileRecord) ||
                (NtfsCompressedOffset != AttributeContext->FileRecordOffset)  ||
                (((ULONG)Vbo) < NtfsCompressedVbo)                             ||
                (((ULONG)Vbo) >= (NtfsCompressedVbo + AttributeContext->CompressionUnit))) {

                ULONG i;
                LBO Lbo;

                //
                //  Load up the cached identification information
                //

                NtfsCompressedFileRecord = AttributeContext->FileRecord;
                NtfsCompressedOffset = AttributeContext->FileRecordOffset;

                NtfsCompressedVbo = ((ULONG)Vbo) & ~(AttributeContext->CompressionUnit - 1);

                //
                //  Now load up the compressed buffer with data.  We keep on
                //  loading until we're done loading or the Lbo we get back is
                //  zero.
                //

                for (i = 0; i < AttributeContext->CompressionUnit; i += ByteCount) {

                    VboToLbo( StructureContext,
                              AttributeContext,
                              /*xxFromUlong*/(NtfsCompressedVbo + i),
                              &Lbo,
                              &ByteCount );

                    if (/*xxEqlZero*/(Lbo == 0)) { break; }

                    //
                    //  Trim the byte count down to a compression unit and we'll catch the
                    //  excess the next time through the loop
                    //

                    if ((i + ByteCount) > AttributeContext->CompressionUnit) {

                        ByteCount = AttributeContext->CompressionUnit - i;
                    }

                    ReadDisk( StructureContext->DeviceId, Lbo, ByteCount, &NtfsCompressedBuffer[i], bCacheNewData );
                }

                //
                //  If the index for the preceding loop is zero then we know
                //  that there isn't any data on disk for the compression unit
                //  and in-fact the compression unit is all zeros
                //

                if (i == 0) {

                    RtlZeroMemory( NtfsUncompressedBuffer, AttributeContext->CompressionUnit );

                //
                //  Otherwise the unit we just read in cannot be compressed
                //  because it completely fills up the compression unit
                //

                } else if (i >= AttributeContext->CompressionUnit) {

                    RtlMoveMemory( NtfsUncompressedBuffer,
                                   NtfsCompressedBuffer,
                                   AttributeContext->CompressionUnit );

                //
                //  If the index for the preceding loop is less then the
                //  compression unit size then we know that the data we
                //  read in is less than the compression unit and we hit
                //  a zero lbo.  So the unit must be compressed.
                //

                } else {

                    NTSTATUS Status;

                    Status = RtlDecompressBuffer( AttributeContext->CompressionFormat,
                                                  NtfsUncompressedBuffer,
                                                  AttributeContext->CompressionUnit,
                                                  NtfsCompressedBuffer,
                                                  i,
                                                  &ByteCount );

                    if (!NT_SUCCESS(Status)) {

                        return EINVAL;
                    }

                    //
                    //  Check if the decompressed buffer doesn't fill up the
                    //  compression unit and if so then zero out the remainder
                    //  of the uncompressed buffer
                    //

                    if (ByteCount < AttributeContext->CompressionUnit) {

                        RtlZeroMemory( &NtfsUncompressedBuffer[ByteCount],
                                       AttributeContext->CompressionUnit - ByteCount );
                    }
                }
            }

            //
            //  Now copy off the data from the compressed buffer to the
            //  user buffer and continue the loop until the length is zero.
            //  The amount of data we need to copy is the smaller of the
            //  length the user wants back or the number of bytes left in
            //  the uncompressed buffer from the requested vbo to the end
            //  of the buffer.
            //

            ByteCount = Minimum( Length,
                                 NtfsCompressedVbo + AttributeContext->CompressionUnit - ((ULONG)Vbo) );

            RtlMoveMemory( Buffer,
                           &NtfsUncompressedBuffer[ ((ULONG)Vbo) - NtfsCompressedVbo ],
                           ByteCount );

            //
            //  Update the length to be what the user now needs read in,
            //  also update the Vbo and Buffer to be the next locations
            //  to be read in.
            //

            Length -= ByteCount;
            Vbo = /*xxAdd*/( Vbo + /*xxFromUlong*/(ByteCount));
            Buffer = (PCHAR)Buffer + ByteCount;
        }

        return ESUCCESS;
    }

    //
    //  Read in runs of data until the byte count goes to zero
    //

    while (Length > 0) {

        LBO Lbo;
        ULONG CurrentRunByteCount;

        //
        //  Lookup the corresponding Lbo and run length for the current position
        //  (i.e., vbo)
        //

        VboToLbo( StructureContext,
                  AttributeContext,
                  Vbo,
                  &Lbo,
                  &CurrentRunByteCount );

        //
        //  While there are bytes to be read in from the current run length and we
        //  haven't exhausted the request we loop reading in bytes.  The biggest
        //  request we'll handle is only 32KB contiguous bytes per physical read.
        //  So we might need to loop through the run
        //

        while ((Length > 0) && (CurrentRunByteCount > 0)) {

            LONG SingleReadSize;

            //
            //  Compute the size of the next physical read
            //

            SingleReadSize = Minimum(Length, 32*1024);
            SingleReadSize = Minimum((ULONG)SingleReadSize, CurrentRunByteCount);

            //
            //  Don't read beyond the data size
            //

            if (/*xxGtr*/(/*xxAdd*/(Vbo + /*xxFromUlong*/(SingleReadSize)) > AttributeContext->DataSize )) {

                SingleReadSize = ((ULONG)(/*xxSub*/(AttributeContext->DataSize - Vbo)));

                //
                //  If the readjusted read length is now zero then we're done
                //

                if (SingleReadSize <= 0) {

                    return ESUCCESS;
                }

                //
                //  By also setting length we'll make sure that this is our last read
                //

                Length = SingleReadSize;
            }

            //
            //  Issue the read
            //

            ReadDisk( StructureContext->DeviceId, Lbo, SingleReadSize, Buffer, bCacheNewData );

            //
            //  Update the remaining length, current run byte count, and new lbo
            //  offset
            //

            Length -= SingleReadSize;
            CurrentRunByteCount -= SingleReadSize;
            Lbo = /*xxAdd*/(Lbo + /*xxFromUlong*/(SingleReadSize));
            Vbo = /*xxAdd*/(Vbo + /*xxFromUlong*/(SingleReadSize));

            //
            //  Update the buffer to point to the next byte location to fill in
            //

            Buffer = (PCHAR)Buffer + SingleReadSize;
        }
    }

    //
    //  If we get here then the remaining byte count is zero so we can return success
    //  to our caller
    //

    return ESUCCESS;
}


//
//  Local support routine
//

ARC_STATUS
NtfsWriteNonresidentAttribute (
    IN PNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    IN ULONG Length,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This routine write in the value of a Nonresident attribute.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    AttributeContext - Supplies the attribute being written

    Vbo - Supplies the offset within the value to return

    Length - Supplies the number of bytes to return

    Buffer - Supplies a pointer to the output buffer for storing the data

Return Value:

    ESUCCESS is returned if the write operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    //
    //  Check if we are writing a compressed attribute
    //

    if (AttributeContext->CompressionFormat != 0) {

        return EROFS;

    }

    //
    //  Write in runs of data until the byte count goes to zero
    //

    while (Length > 0) {

        LBO Lbo;
        ULONG CurrentRunByteCount;

        //
        //  Lookup the corresponding Lbo and run length for the current position
        //  (i.e., vbo)
        //

        VboToLbo( StructureContext,
                  AttributeContext,
                  Vbo,
                  &Lbo,
                  &CurrentRunByteCount );

        //
        //  While there are bytes to be written in from the current run length and we
        //  haven't exhausted the request we loop writing in bytes.  The biggest
        //  request we'll handle is only 32KB contiguous bytes per physical write.
        //  So we might need to loop through the run
        //

        while ((Length > 0) && (CurrentRunByteCount > 0)) {

            LONG SingleWriteSize;

            //
            //  Compute the size of the next physical written
            //

            SingleWriteSize = Minimum(Length, 32*1024);
            SingleWriteSize = Minimum((ULONG)SingleWriteSize, CurrentRunByteCount);

            //
            //  Don't write beyond the data size
            //

            if (/*xxGtr*/(/*xxAdd*/(Vbo + /*xxFromUlong*/(SingleWriteSize)) > AttributeContext->DataSize )) {

                SingleWriteSize = ((ULONG)(/*xxSub*/(AttributeContext->DataSize - Vbo)));

                //
                //  If the adjusted write length is now zero then we're done
                //

                if (SingleWriteSize <= 0) {

                    return ESUCCESS;
                }

                //
                //  By also setting length we'll make sure that this is our last write
                //

                Length = SingleWriteSize;
            }

            //
            //  Issue the write
            //

            WriteDisk( StructureContext->DeviceId, Lbo, SingleWriteSize, Buffer );

            //
            //  Update the remaining length, current run byte count, and new lbo
            //  offset
            //

            Length -= SingleWriteSize;
            CurrentRunByteCount -= SingleWriteSize;
            Lbo = /*xxAdd*/(Lbo + /*xxFromUlong*/(SingleWriteSize));
            Vbo = /*xxAdd*/(Vbo + /*xxFromUlong*/(SingleWriteSize));

            //
            //  Update the buffer to point to the next byte location to fill in
            //

            Buffer = (PCHAR)Buffer + SingleWriteSize;
        }
    }

    //
    //  If we get here then the remaining byte count is zero so we can return success
    //  to our caller
    //

    return ESUCCESS;
}



//
//  Local support routine
//


ARC_STATUS
NtfsReadAndDecodeFileRecord (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN LONGLONG FileRecord,
    OUT PULONG Index
    )

/*++

Routine Description:

    This routine reads in the specified file record into the indicated
    ntfs file record buffer index provided that the buffer is not pinned.
    It will also look at the current buffers and see if any will already
    satisfy the request or assign an unused buffer if necessary and
    fix Index to point to the right buffer

Arguments:

    StructureContext - Supplies the volume structure for this operation

    FileRecord - Supplies the file record number being read

    Index - Receives the index of where we put the buffer.  After this
        call the buffer is pinned and will need to be unpinned if it is
        to be reused.

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ARC_STATUS Status;

    //
    //  For each buffer that is not null check if we have a hit on the
    //  file record and if so then increment the pin count and return
    //  that index
    //

    for (*Index = 0; (*Index < BUFFER_COUNT) && (NtfsFileRecordBuffer[*Index] != NULL); *Index += 1) {

        if (NtfsFileRecordBufferVbo[*Index] == FileRecord) {

            NtfsFileRecordBufferPinned[*Index] += 1;
            return ESUCCESS;
        }
    }

    //
    //  Check for the first unpinned buffer and make sure we haven't exhausted the
    //  array
    //

    for (*Index = 0; (*Index < BUFFER_COUNT) && (NtfsFileRecordBufferPinned[*Index] != 0); *Index += 1) {

        NOTHING;
    }

    if (*Index == BUFFER_COUNT) { return E2BIG; }

    //
    //  We have an unpinned buffer that we want to use, check if we need to
    //  allocate a buffer to actually hold the data
    //

    PausedPrint(( "Reusing index %x for %I64x\r\n", *Index, FileRecord ));

    if (NtfsFileRecordBuffer[*Index] == NULL) {

        NtfsFileRecordBuffer[*Index] = BlAllocateHeapAligned(MAXIMUM_FILE_RECORD_SIZE);
    }

    //
    //  Pin the buffer and then read in the data
    //

    NtfsFileRecordBufferPinned[*Index] += 1;

    if ((Status = NtfsReadNonresidentAttribute( StructureContext,
                                                &StructureContext->MftAttributeContext,
                                                FileRecord * StructureContext->BytesPerFileRecord,
                                                StructureContext->BytesPerFileRecord,
                                                NtfsFileRecordBuffer[*Index] )) != ESUCCESS) {

        return Status;
    }

    //
    //  Decode the usa
    //

    if ((Status = NtfsDecodeUsa( NtfsFileRecordBuffer[*Index],
                                 StructureContext->BytesPerFileRecord )) != ESUCCESS) {

        return Status;
    }

    //
    //  And set the file record so that we know where it came from
    //

    NtfsFileRecordBufferVbo[*Index] = FileRecord;

    return ESUCCESS;
}


//
//  Local support routine
//

ARC_STATUS
NtfsDecodeUsa (
    IN PVOID UsaBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine takes as input file record or index buffer and applies the
    usa transformation to get it back into a state that we can use it.

Arguments:

    UsaBuffer - Supplies the buffer used in this operation

    Length - Supplies the length of the buffer in bytes

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PMULTI_SECTOR_HEADER MultiSectorHeader;

    PUSHORT UsaOffset;
    ULONG UsaSize;

    ULONG i;
    PUSHORT ProtectedUshort;

    UNREFERENCED_PARAMETER( Length );

    //
    //  Setup our local variables
    //

    MultiSectorHeader = (PMULTI_SECTOR_HEADER)UsaBuffer;

    UsaOffset = Add2Ptr(UsaBuffer, MultiSectorHeader->UpdateSequenceArrayOffset);
    UsaSize = MultiSectorHeader->UpdateSequenceArraySize;

    //
    //  For every entry in the usa we need to compute the address of the protected
    //  ushort and then check that the protected ushort is equal to the current
    //  sequence number (i.e., the number at UsaOffset[0]) and then replace the
    //  protected ushort number with the saved ushort in the usa.
    //

    for (i = 1; i < UsaSize; i += 1) {

        ProtectedUshort = Add2Ptr( UsaBuffer,
                                   (SEQUENCE_NUMBER_STRIDE * i) - sizeof(USHORT));

        if (*ProtectedUshort != UsaOffset[0]) {

//            NtfsPrint( "USA Failure\r\n" );

            return EBADF;
        }

        *ProtectedUshort = UsaOffset[i];
    }

    //
    //  And return to our caller
    //

    return ESUCCESS;
}


//
//  Local support routine
//

BOOLEAN
NtfsIsNameCached (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN CSTRING FileName,
    IN OUT PLONGLONG FileRecord,
    OUT PBOOLEAN Found,
    OUT PBOOLEAN IsDirectory
    )

/*++

Routine Description:

    This routine consults the cache for the given link.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    FileName - name of entry to look up

    FileRecord - IN file record of parent directory, OUT file record of child

    Found - whether we found this in the cache or not

Return Value:

    TRUE if the name was found in the cache.

--*/

{
    ULONG i, j;

    *Found = FALSE;

#ifdef CACHE_DEVINFO    

//    NtfsPrint( "Cache probe on %04x %I64x '%.*s'\r\n",
//               StructureContext->DeviceId,
//               *FileRecord,
//               FileName.Length,
//               FileName.Buffer );

    for (i = 0; i < MAX_CACHE_ENTRIES; i++) {
//        NtfsPrint( "Cache comparing to %04x %I64x '%.*s'\r\n",
//                   NtfsLinkCache[i].DeviceId,
//                   NtfsLinkCache[i].ParentFileRecord,
//                   NtfsLinkCache[i].NameLength,
//                   NtfsLinkCache[i].RelativeName );

        if (NtfsLinkCache[i].DeviceId == StructureContext->DeviceId &&
            NtfsLinkCache[i].ParentFileRecord == *FileRecord &&
            NtfsLinkCache[i].NameLength == FileName.Length) {

//            NtfsPrint( "Comparing names\r\n" );

            for (j = 0; j < FileName.Length; j++ ) {
                if (NtfsLinkCache[i].RelativeName[j] != ToUpper( (USHORT) FileName.Buffer[j] )) {
                    break;
                }
            }

            if (j == FileName.Length) {

                //
                //  Match
                //

//                NtfsPrint( "Cache hit\r\n" );

                *Found = TRUE;
                *FileRecord = NtfsLinkCache[i].ChildFileRecord;
                *IsDirectory = TRUE;

                break;
            }
        }
    }

#endif  // CACHE_DEVINFO    

    return *Found;
}



//
//  Local support routine
//

#ifdef CACHE_DEVINFO

VOID
NtfsInvalidateCacheEntries(
    IN ULONG DeviceId
    )
{
    ULONG i, Count = 0;


#if 0
    BlPrint("NtfsInvalidateCacheEntries() called for %d(%d)\r\n", 
            DeviceId,
            NtfsLinkCacheCount);
            
    while (!BlGetKey());    
#endif    
        
    for (i = 0; i < MAX_CACHE_ENTRIES; i++) {
        if (NtfsLinkCache[i].DeviceId == DeviceId) {
            NtfsLinkCache[i].DeviceId = UNINITIALIZED_DEVICE_ID;
            Count++;
        }
    }

    if (NtfsLinkCacheCount >= Count) {
        NtfsLinkCacheCount -= Count;
    } else {
        NtfsLinkCacheCount = 0;
    }        


#if 0
    BlPrint("NtfsInvalidateCacheEntries() called for %d(%d)\r\n", 
            DeviceId,
            NtfsLinkCacheCount);
            
    while (!BlGetKey());            
#endif    
}

#endif // CACHE_DEV_INFO

VOID
NtfsAddNameToCache (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN CSTRING FileName,
    IN LONGLONG ParentFileRecord,
    IN LONGLONG FileRecord
    )

/*++

Routine Description:

    This routine adds a name and link to the name cache

Arguments:

    StructureContext - Supplies the volume structure for this operation

    FileName - Supplies the file name being cached (in ansi).

    ParentFileRecord - the file record of the parent

    FileRecord - file record associated with the name


Return Value:

    None.

--*/

{
#ifdef CACHE_DEVINFO

    if (NtfsLinkCacheCount < MAX_CACHE_ENTRIES) {
        ULONG i;
        ULONG Index;

        for (Index = 0; Index < MAX_CACHE_ENTRIES; Index++) {
            if (NtfsLinkCache[Index].DeviceId == UNINITIALIZED_DEVICE_ID) {
                break;
            }                
        }

        if (Index < MAX_CACHE_ENTRIES) {
            NtfsLinkCache[Index].DeviceId = StructureContext->DeviceId;
            NtfsLinkCache[Index].ParentFileRecord = ParentFileRecord;
            NtfsLinkCache[Index].NameLength = FileName.Length;
            
            for (i = 0; i < FileName.Length; i++) {
                NtfsLinkCache[Index].RelativeName[i] = ToUpper( FileName.Buffer[i] );
            }

            NtfsLinkCache[Index].ChildFileRecord = FileRecord;
            NtfsLinkCacheCount++;

            PausedPrint( ("Caching %04x %I64x %.*s %I64X\r\n",
                          StructureContext->DeviceId,
                          ParentFileRecord,
                          FileName.Length,
                          FileName.Buffer,
                          FileRecord ));
        }                                                
    } else {
//        NtfsPrint( "Cache is full at %I64x %.*s %I64X\r\n",
//                   ParentFileRecord,
//                   FileName.Length,
//                   FileName.Buffer,
//                   FileRecord );
//        Pause;

    }
    
#endif    
}


//
//  Local support routine
//

ARC_STATUS
NtfsSearchForFileName (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN CSTRING FileName,
    IN OUT PLONGLONG FileRecord,
    OUT PBOOLEAN Found,
    OUT PBOOLEAN IsDirectory
    )

/*++

Routine Description:

    This routine searches a given index root and allocation for the specified
    file name.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    FileName - Supplies the file name being searched for (in ansi).

    FileRecord - Receives the file record for the entry if one was located.

    Found - Receives a value to indicate if we found the specified
        file name in the directory

    IsDirectory - Receives a value to indicate if the found index is itself
        a directory

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    LONGLONG ParentFileRecord;

    //
    //  Test to see if the file name is cached
    //

    if (NtfsIsNameCached( StructureContext, FileName, FileRecord, Found, IsDirectory )) {
        return ESUCCESS;
    }

    ParentFileRecord = *FileRecord;

    InexactSortedDirectoryScan( StructureContext, FileName, FileRecord, Found, IsDirectory );

    if (!*Found) {
        LinearDirectoryScan( StructureContext, FileName, FileRecord, Found, IsDirectory );
    }

    //
    //  If we have a directory entry, then add it to the cache
    //

    if (*Found && *IsDirectory) {
        NtfsAddNameToCache( StructureContext, FileName, ParentFileRecord, *FileRecord );
    }

    return ESUCCESS;
}


//
//  Local support routine
//

ARC_STATUS
NtfsInexactSortedDirectoryScan (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN CSTRING FileName,
    IN OUT PLONGLONG FileRecord,
    OUT PBOOLEAN Found,
    OUT PBOOLEAN IsDirectory
    )

/*++

Routine Description:

    This routine searches a given index root and allocation for the specified
    file name by performing simple uppercasing and using that to wander through
    the directory tree.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    FileName - Supplies the file name being searched for (in ansi).

    FileRecord - Receives the file record for the entry if one was located.

    Found - Receives a value to indicate if we found the specified
        file name in the directory

    IsDirectory - Receives a value to indicate if the found index is itself
        a directory

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PATTRIBUTE_RECORD_HEADER IndexAttributeHeader;
    PINDEX_ROOT IndexRootValue;
    PINDEX_HEADER IndexHeader;

    NTFS_ATTRIBUTE_CONTEXT AttributeContext1;
    NTFS_ATTRIBUTE_CONTEXT AttributeContext2;
    NTFS_ATTRIBUTE_CONTEXT AttributeContext3;

    PNTFS_ATTRIBUTE_CONTEXT IndexRoot;
    PNTFS_ATTRIBUTE_CONTEXT IndexAllocation;
    PNTFS_ATTRIBUTE_CONTEXT AllocationBitmap;

    ULONG NextIndexBuffer;
    ULONG BytesPerIndexBuffer;

    ULONG BufferIndex;

    //
    //  The current file record must be a directory so now lookup the index root,
    //  allocation and bitmap for the directory and then we can do our search.
    //

//    NtfsPrint( "InexactSortedDirectoryScan %04x %I64x for '%.*s'\r\n",
//               StructureContext->DeviceId,
//               *FileRecord, FileName.Length, FileName.Buffer );
//    Pause;

    IndexRoot = &AttributeContext1;

    LookupAttribute( StructureContext,
                     *FileRecord,
                     $INDEX_ROOT,
                     Found,
                     IndexRoot);

    if (!*Found) { return EBADF; }

    IndexAllocation = &AttributeContext2;

    LookupAttribute( StructureContext,
                     *FileRecord,
                     $INDEX_ALLOCATION,
                     Found,
                     IndexAllocation);

    if (!*Found) { IndexAllocation = NULL; }

    AllocationBitmap = &AttributeContext3;

    LookupAttribute( StructureContext,
                     *FileRecord,
                     $BITMAP,
                     Found,
                     AllocationBitmap);

    if (!*Found) { AllocationBitmap = NULL; }

    //
    //  unless otherwise set we will assume that our search has failed
    //

    *Found = FALSE;

    //
    //  First read in and search the index root for the file name.  We know the index
    //  root is resident so we'll save some buffering and just read in file record
    //  with the index root directly
    //

    ReadAndDecodeFileRecord( StructureContext,
                             IndexRoot->FileRecord,
                             &BufferIndex );

    IndexAttributeHeader = Add2Ptr( NtfsFileRecordBuffer[BufferIndex],
                                    IndexRoot->FileRecordOffset );

    IndexRootValue = NtfsGetValue( IndexAttributeHeader );

    IndexHeader = &IndexRootValue->IndexHeader;

    //
    //  We also setup ourselves so that if the current index does not contain a match
    //  we will read in the next index and continue our search
    //

    BytesPerIndexBuffer = IndexRootValue->BytesPerIndexBuffer;

    //
    //  Now we'll just continue looping intil we either find a match or exhaust all
    //  of the index buffer
    //

    NextIndexBuffer = UNINITIALIZED_DEVICE_ID;
    while (TRUE) {

        PINDEX_ENTRY IndexEntry;
        VBO Vbo;

//        NtfsPrint( "Searching IndexBuffer %x\r\n", NextIndexBuffer );

        //
        //  Search the current index buffer (from index header looking for a match
        //

        for (IndexEntry = Add2Ptr(IndexHeader, IndexHeader->FirstIndexEntry);
             !FlagOn(IndexEntry->Flags, INDEX_ENTRY_END);
             IndexEntry = Add2Ptr(IndexEntry, IndexEntry->Length)) {

            PFILE_NAME FileNameEntry;
            UNICODE_STRING UnicodeFileName;
            int Result;

            //
            //  Get the FileName for this index entry
            //

            FileNameEntry = Add2Ptr(IndexEntry, sizeof(INDEX_ENTRY));

            UnicodeFileName.Length = FileNameEntry->FileNameLength * 2;
            UnicodeFileName.Buffer = &FileNameEntry->FileName[0];

            //
            //  Check if this the name we're after if it is then say we found it and
            //  setup the output variables
            //

            Result = NtfsCompareName( FileName, UnicodeFileName );
            if (Result == 0) {

                FileReferenceToLargeInteger( IndexEntry->FileReference,
                                             FileRecord );

                *Found = TRUE;
                *IsDirectory = FlagOn( FileNameEntry->Info.FileAttributes,
                                       DUP_FILE_NAME_INDEX_PRESENT);

//                NtfsPrint( "Found Entry %I64x\r\n", *FileRecord );

                DereferenceFileRecord( BufferIndex );

                return ESUCCESS;
            } else if (Result < 0) {
//                NtfsPrint( "Found > entry '%.*ws'\r\n", UnicodeFileName.Length, UnicodeFileName.Buffer );
                break;
            }
        }

        //
        //  At this point, we've either hit the end of the index or we have
        //  found the first entry larger than the name we're looking for.  In either case
        //  we may have a downpointer to examine.  If not, then there is no entry here.
        //

        //
        //  If no down pointer then release the file record buffer and quit
        //

        if (!FlagOn( IndexEntry->Flags, INDEX_ENTRY_NODE )) {
            DereferenceFileRecord( BufferIndex );

//            NtfsPrint( "No down pointer\r\n" );

            return ESUCCESS;
        }

        //
        //  At this point we've searched one index header and need to read in another
        //  one to check.  But first make sure there are additional index buffers
        //

        if (!ARGUMENT_PRESENT(IndexAllocation) ||
            !ARGUMENT_PRESENT(AllocationBitmap)) {

//            NtfsPrint( "No index allocation\r\n" );

            DereferenceFileRecord( BufferIndex );

            return ESUCCESS;
        }

        NextIndexBuffer = (ULONG)NtfsIndexEntryBlock( IndexEntry ) ;
        Vbo = NextIndexBuffer * StructureContext->BytesPerCluster;

        //
        //  Make sure the buffer offset is within the stream
        //

        if (Vbo >= IndexAllocation->DataSize) {

//            NtfsPrint( "Beyond end of stream %I64x %x\r\n", IndexAllocation->DataSize, NextIndexBuffer );

            DereferenceFileRecord( BufferIndex );

            return ESUCCESS;

        }

        //
        //  At this point we've computed the next index allocation buffer to read in
        //  so read it in, decode it, and go back to the top of our loop
        //

        ReadAttribute( StructureContext,
                       IndexAllocation,
                       Vbo,
                       BytesPerIndexBuffer,
                       NtfsIndexAllocationBuffer );

        DecodeUsa( NtfsIndexAllocationBuffer, BytesPerIndexBuffer );

        IndexHeader = &NtfsIndexAllocationBuffer->IndexHeader;
    }
}


//
//  Local support routine
//

ARC_STATUS
NtfsLinearDirectoryScan (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN CSTRING FileName,
    IN OUT PLONGLONG FileRecord,
    OUT PBOOLEAN Found,
    OUT PBOOLEAN IsDirectory
    )

/*++

Routine Description:

    This routine searches a given index root and allocation for the specified
    file name by looking linearly through every entry.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    FileName - Supplies the file name being searched for (in ansi).

    FileRecord - Receives the file record for the entry if one was located.

    Found - Receives a value to indicate if we found the specified
        file name in the directory

    IsDirectory - Receives a value to indicate if the found index is itself
        a directory

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PATTRIBUTE_RECORD_HEADER IndexAttributeHeader;
    PINDEX_ROOT IndexRootValue;
    PINDEX_HEADER IndexHeader;

    NTFS_ATTRIBUTE_CONTEXT AttributeContext1;
    NTFS_ATTRIBUTE_CONTEXT AttributeContext2;
    NTFS_ATTRIBUTE_CONTEXT AttributeContext3;

    PNTFS_ATTRIBUTE_CONTEXT IndexRoot;
    PNTFS_ATTRIBUTE_CONTEXT IndexAllocation;
    PNTFS_ATTRIBUTE_CONTEXT AllocationBitmap;

    ULONG NextIndexBuffer;
    ULONG BytesPerIndexBuffer;

    ULONG BufferIndex;

    //
    //  The current file record must be a directory so now lookup the index root,
    //  allocation and bitmap for the directory and then we can do our search.
    //

//    NtfsPrint( "LinearSearching %04x %I64x for %.*s\r\n",
//               StructureContext->DeviceId,
//               *FileRecord, FileName.Length, FileName.Buffer );
//    Pause;

    IndexRoot = &AttributeContext1;

    LookupAttribute( StructureContext,
                     *FileRecord,
                     $INDEX_ROOT,
                     Found,
                     IndexRoot);

    if (!*Found) { return EBADF; }

    IndexAllocation = &AttributeContext2;

    LookupAttribute( StructureContext,
                     *FileRecord,
                     $INDEX_ALLOCATION,
                     Found,
                     IndexAllocation);

    if (!*Found) { IndexAllocation = NULL; }

    AllocationBitmap = &AttributeContext3;

    LookupAttribute( StructureContext,
                     *FileRecord,
                     $BITMAP,
                     Found,
                     AllocationBitmap);

    if (!*Found) { AllocationBitmap = NULL; }

    //
    //  unless otherwise set we will assume that our search has failed
    //

    *Found = FALSE;

    //
    //  First read in and search the index root for the file name.  We know the index
    //  root is resident so we'll save some buffering and just read in file record
    //  with the index root directly
    //

    ReadAndDecodeFileRecord( StructureContext,
                             IndexRoot->FileRecord,
                             &BufferIndex );

    IndexAttributeHeader = Add2Ptr( NtfsFileRecordBuffer[BufferIndex],
                                    IndexRoot->FileRecordOffset );

    IndexRootValue = NtfsGetValue( IndexAttributeHeader );

    IndexHeader = &IndexRootValue->IndexHeader;

    //
    //  We also setup ourselves so that if the current index does not contain a match
    //  we will read in the next index and continue our search
    //

    NextIndexBuffer = 0;

    BytesPerIndexBuffer = IndexRootValue->BytesPerIndexBuffer;

    //
    //  Now we'll just continue looping intil we either find a match or exhaust all
    //  of the index buffer
    //

    while (TRUE) {

        PINDEX_ENTRY IndexEntry;
        BOOLEAN IsAllocated;
        VBO Vbo = 0;

        //
        //  Search the current index buffer (from index header looking for a match
        //

        for (IndexEntry = Add2Ptr(IndexHeader, IndexHeader->FirstIndexEntry);
             !FlagOn(IndexEntry->Flags, INDEX_ENTRY_END);
             IndexEntry = Add2Ptr(IndexEntry, IndexEntry->Length)) {

            PFILE_NAME FileNameEntry;
            UNICODE_STRING UnicodeFileName;

            //
            //  Get the FileName for this index entry
            //

            FileNameEntry = Add2Ptr(IndexEntry, sizeof(INDEX_ENTRY));

            UnicodeFileName.Length = FileNameEntry->FileNameLength * 2;
            UnicodeFileName.Buffer = &FileNameEntry->FileName[0];

            //
            //  Check if this the name we're after if it is then say we found it and
            //  setup the output variables
            //

            if (NtfsCompareName( FileName, UnicodeFileName ) == 0) {

                FileReferenceToLargeInteger( IndexEntry->FileReference,
                                             FileRecord );

                *Found = TRUE;
                *IsDirectory = FlagOn( FileNameEntry->Info.FileAttributes,
                                       DUP_FILE_NAME_INDEX_PRESENT);

                DereferenceFileRecord( BufferIndex );

                return ESUCCESS;
            }
        }

        //
        //  At this point we've searched one index header and need to read in another
        //  one to check.  But first make sure there are additional index buffers
        //

        if (!ARGUMENT_PRESENT(IndexAllocation) ||
            !ARGUMENT_PRESENT(AllocationBitmap)) {

            DereferenceFileRecord( BufferIndex );

            return ESUCCESS;
        }

        //
        //  Now the following loop reads in the valid index buffer.  The variable
        //  next index buffer denotes the buffer we want to read in.  The idea is to
        //  first check that the buffer is part of the index allocation otherwise
        //  we've exhausted the list without finding a match.  Once we know the
        //  allocation exists then we check if the record is really allocated if it
        //  is not allocated we try the next buffer and so on.
        //

        IsAllocated = FALSE;

        while (!IsAllocated) {

            //
            //  Compute the starting vbo of the next index buffer and check if it is
            //  still within the data size.
            //

            Vbo = (BytesPerIndexBuffer * NextIndexBuffer);

            if (Vbo >= IndexAllocation->DataSize) {

                DereferenceFileRecord( BufferIndex );

                return ESUCCESS;

            }

            //
            //  Now check if the index buffer is in use
            //

            IsRecordAllocated( StructureContext,
                               AllocationBitmap,
                               NextIndexBuffer,
                               &IsAllocated );

            NextIndexBuffer += 1;
        }

        //
        //  At this point we've computed the next index allocation buffer to read in
        //  so read it in, decode it, and go back to the top of our loop
        //

        ReadAttribute( StructureContext,
                       IndexAllocation,
                       Vbo,
                       BytesPerIndexBuffer,
                       NtfsIndexAllocationBuffer );

        DecodeUsa( NtfsIndexAllocationBuffer, BytesPerIndexBuffer );

        IndexHeader = &NtfsIndexAllocationBuffer->IndexHeader;
    }
}


//
//  Local support routine
//

ARC_STATUS
NtfsIsRecordAllocated (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AllocationBitmap,
    IN ULONG BitOffset,
    OUT PBOOLEAN IsAllocated
    )

/*++

Routine Description:

    This routine indicates to the caller if the specified index allocation record
    is in use (i.e., its bit is 1).

Arguments:

    StructureContext - Supplies the volume structure for this operation

    AllocationBitmap - Supplies the attribute context for the index allocation bitmap

    BitOffset - Supplies the offset (zero based) being checked

    IsAllocated - Recieves an value indicating if the record is allocated or not

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ULONG ByteIndex;
    ULONG BitIndex;
    UCHAR LocalByte;

    //
    //  This routine is rather dumb in that it only reads in the byte that contains
    //  the bit we're interested in and doesn't keep any state information between
    //  calls.  We first break down the bit offset into the byte and bit within
    //  the byte that we need to check
    //

    ByteIndex = BitOffset / 8;
    BitIndex = BitOffset % 8;

    //
    //  Read in a single byte containing the bit we need to check
    //

    ReadAttribute( StructureContext,
                   AllocationBitmap,
                   /*xxFromUlong*/(ByteIndex),
                   1,
                   &LocalByte );

    //
    //  Shift over the local byte so that the bit we want is in the low order bit and
    //  then mask it out to see if the bit is set
    //

    if (FlagOn(LocalByte >> BitIndex, 0x01)) {

        *IsAllocated = TRUE;

    } else {

        *IsAllocated = FALSE;
    }

    //
    //  And return to our caller
    //

    return ESUCCESS;
}


//
//  Local support routine
//

ARC_STATUS
NtfsLoadMcb (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    IN PNTFS_MCB Mcb
    )

/*++

Routine Description:

    This routine loads into one of the cached mcbs the retrival information for the
    starting vbo.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    AttributeContext - Supplies the Nonresident attribute being queried

    Vbo - Supplies the starting Vbo to use when loading the mcb

    Mcb - Supplies the mcb that we should be loading

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PATTRIBUTE_RECORD_HEADER AttributeHeader;

    ULONG BytesPerCluster;

    VBO LowestVbo;
    VBO HighestVbo;

    LONGLONG FileRecord;

    NTFS_ATTRIBUTE_CONTEXT AttributeContext1;
    PNTFS_ATTRIBUTE_CONTEXT AttributeList;

    LONGLONG li;
    LONGLONG Previousli;
    ATTRIBUTE_LIST_ENTRY AttributeListEntry;

    ATTRIBUTE_TYPE_CODE TypeCode;

    ULONG BufferIndex;
    ULONG SavedBufferIndex;

    //
    //  Load our local variables
    //

    BytesPerCluster = StructureContext->BytesPerCluster;

    //
    //  Setup a pointer to the cached mcb, indicate the attribute context that is will
    //  now own the cached mcb, and zero out the mcb
    //

    Mcb->InUse = 0;

    //
    //  Read in the file record that contains the non-resident attribute and get a
    //  pointer to the attribute header
    //

    ReadAndDecodeFileRecord( StructureContext,
                             AttributeContext->FileRecord,
                             &BufferIndex );

    AttributeHeader = Add2Ptr( NtfsFileRecordBuffer[BufferIndex],
                               AttributeContext->FileRecordOffset );

    //
    //  Compute the lowest and highest vbo that is described by this attribute header
    //

    LowestVbo  = AttributeHeader->Form.Nonresident.LowestVcn * BytesPerCluster;

    HighestVbo = ((AttributeHeader->Form.Nonresident.HighestVcn + 1) * BytesPerCluster) - 1;

    //
    //  Now check if the vbo we are after is within the range of this attribute header
    //  and if so then decode the retrieval information and return to our caller
    //

    if ((LowestVbo <= Vbo) && (Vbo <= HighestVbo)) {

        DecodeRetrievalInformation( StructureContext, Mcb, Vbo, AttributeHeader );

        DereferenceFileRecord( BufferIndex );

        return ESUCCESS;
    }

    //
    //  At this point the attribute header does not contain the range we need so read
    //  in the base file record and we'll search the attribute list for a attribute
    //  header that we need.  We need to make sure that we don't already have the base FRS.
    //  If we do, then we just continue using it.
    //

    if (/*!xxEqlZero*/(*((PLONGLONG)&(NtfsFileRecordBuffer[BufferIndex]->BaseFileRecordSegment)) != 0)) {

        FileReferenceToLargeInteger( NtfsFileRecordBuffer[BufferIndex]->BaseFileRecordSegment,
                                     &FileRecord );

        DereferenceFileRecord( BufferIndex );

        ReadAndDecodeFileRecord( StructureContext,
                                 FileRecord,
                                 &BufferIndex );

    } else {

        FileRecord = NtfsFileRecordBufferVbo[BufferIndex];
    }

    //
    //  Now we have read in the base file record so search for the attribute list
    //  attribute
    //

    AttributeList = NULL;

    for (AttributeHeader = NtfsFirstAttribute( NtfsFileRecordBuffer[BufferIndex] );
         AttributeHeader->TypeCode != $END;
         AttributeHeader = NtfsGetNextRecord( AttributeHeader )) {

        //
        //  Check if this is the attribute list attribute and if so then setup a local
        //  attribute context
        //

        if (AttributeHeader->TypeCode == $ATTRIBUTE_LIST) {

            InitializeAttributeContext( StructureContext,
                                        NtfsFileRecordBuffer[BufferIndex],
                                        AttributeHeader,
                                        FileRecord,
                                        AttributeList = &AttributeContext1 );
        }
    }

    //
    //  We have better located an attribute list otherwise we're in trouble
    //

    if (AttributeList == NULL) {

        DereferenceFileRecord( BufferIndex );

        return EINVAL;
    }

    //
    //  Setup a local for the type code
    //

    TypeCode = AttributeContext->TypeCode;

    //
    //  Now that we've located the attribute list we need to continue our search.  So
    //  what this outer loop does is search down the attribute list looking for a
    //  match.
    //

    NtfsFileRecordBufferPinned[SavedBufferIndex = BufferIndex] += 1;

    for (Previousli = li = 0;
         /*xxLtr*/(li < AttributeList->DataSize);
         li = /*xxAdd*/(li + /*xxFromUlong*/(AttributeListEntry.RecordLength))) {

        //
        //  Read in the attribute list entry.  We don't need to read in the name,
        //  just the first part of the list entry.
        //

        ReadAttribute( StructureContext,
                       AttributeList,
                       li,
                       sizeof(ATTRIBUTE_LIST_ENTRY),
                       &AttributeListEntry );

        //
        //  Now check if the attribute matches, and either it is not $data or if it
        //  is $data then it is unnamed
        //

        if ((AttributeListEntry.AttributeTypeCode == TypeCode)

                    &&

            ((TypeCode != $DATA) ||
             ((TypeCode == $DATA) && (AttributeListEntry.AttributeNameLength == 0)))) {

            //
            //  If the lowest vcn is is greater than the vbo we've after then
            //  we are done and can use previous li otherwise set previous li accordingly.

            if (Vbo < AttributeListEntry.LowestVcn * BytesPerCluster) {

                break;
            }

            Previousli = li;
        }
    }

    //
    //  Now we should have found the offset for the attribute list entry
    //  so read it in and verify that it is correct
    //

    ReadAttribute( StructureContext,
                   AttributeList,
                   Previousli,
                   sizeof(ATTRIBUTE_LIST_ENTRY),
                   &AttributeListEntry );

    if ((AttributeListEntry.AttributeTypeCode == TypeCode)

                &&

        ((TypeCode != $DATA) ||
         ((TypeCode == $DATA) && (AttributeListEntry.AttributeNameLength == 0)))) {

        //
        //  We found a match so now compute the file record containing this
        //  attribute and read in the file record
        //

        FileReferenceToLargeInteger( AttributeListEntry.SegmentReference, &FileRecord );

        DereferenceFileRecord( BufferIndex );

        ReadAndDecodeFileRecord( StructureContext,
                                 FileRecord,
                                 &BufferIndex );

        //
        //  Now search down the file record for our matching attribute, and it
        //  better be there otherwise the attribute list is wrong.
        //

        for (AttributeHeader = NtfsFirstAttribute( NtfsFileRecordBuffer[BufferIndex] );
             AttributeHeader->TypeCode != $END;
             AttributeHeader = NtfsGetNextRecord( AttributeHeader )) {

            //
            //  As a quick check make sure that this attribute is non resident
            //

            if (AttributeHeader->FormCode == NONRESIDENT_FORM) {

                //
                //  Compute the range of this attribute header
                //

                LowestVbo  = AttributeHeader->Form.Nonresident.LowestVcn * BytesPerCluster;

                HighestVbo = ((AttributeHeader->Form.Nonresident.HighestVcn + 1) * BytesPerCluster) - 1;

                //
                //  We have located the attribute in question if the type code
                //  match, it is within the proper range, and if it is either not
                //  the data attribute or if it is the data attribute then it is
                //  also unnamed
                //

                if ((AttributeHeader->TypeCode == TypeCode)

                            &&

                    (LowestVbo <= Vbo) && (Vbo <= HighestVbo)

                            &&

                    ((TypeCode != $DATA) ||
                     ((TypeCode == $DATA) && (AttributeHeader->NameLength == 0)))) {

                    //
                    //  We've located the attribute so now it is time to decode
                    //  the retrieval information and return to our caller
                    //

                    DecodeRetrievalInformation( StructureContext,
                                                Mcb,
                                                Vbo,
                                                AttributeHeader );

                    DereferenceFileRecord( BufferIndex );
                    DereferenceFileRecord( SavedBufferIndex );

                    return ESUCCESS;
                }
            }
        }
    }


    DereferenceFileRecord( BufferIndex );
    DereferenceFileRecord( SavedBufferIndex );

    return EINVAL;
}


//
//  Local support routine
//


ARC_STATUS
NtfsVboToLbo (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PCNTFS_ATTRIBUTE_CONTEXT AttributeContext,
    IN VBO Vbo,
    OUT PLBO Lbo,
    OUT PULONG ByteCount
    )

/*++

Routine Description:

    This routine computes the run denoted by the input vbo to into its
    corresponding lbo and also returns the number of bytes remaining in
    the run.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    AttributeContext - Supplies the Nonresident attribute being queried

    Vbo - Supplies the Vbo to match

    Lbo - Recieves the corresponding Lbo

    ByteCount - Receives the number of bytes remaining in the run

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PNTFS_MCB Mcb;
    ULONG i;

    //
    //  Check if we are doing the mft or some other attribute
    //

    Mcb = NULL;

    if (AttributeContext == &StructureContext->MftAttributeContext) {

        //
        //  For the mft we start with the base mcb but if the vbo is not in the mcb
        //  then we immediately switch over to the cached mcb
        //

        Mcb = (PNTFS_MCB)&StructureContext->MftBaseMcb;

        if (/*xxLtr*/(Vbo < Mcb->Vbo[0]) || /*xxGeq*/(Vbo >= Mcb->Vbo[Mcb->InUse])) {

            Mcb = NULL;
        }
    }

    //
    //  If the Mcb is still null then we are to use the cached mcb, first find
    //  if one of the cached ones contains the range we're after
    //

    if (Mcb == NULL) {

        for (i = 0; i < 16; i += 1) {

            //
            //  check if we have a hit, on the same attribute and range
            //

            Mcb = (PNTFS_MCB)&StructureContext->CachedMcb[i];

            if ((/*xxEql*/(AttributeContext->FileRecord == StructureContext->CachedMcbFileRecord[i]) &&
                (AttributeContext->FileRecordOffset == StructureContext->CachedMcbFileRecordOffset[i]) &&
                /*xxLeq*/(Mcb->Vbo[0] <= Vbo) && /*xxLtr*/(Vbo < Mcb->Vbo[Mcb->InUse]))) {

                break;
            }

            Mcb = NULL;
        }

        //
        //  If we didn't get a hit then we need to load a new mcb we'll
        //  alternate through our two cached mcbs
        //

        if (Mcb == NULL) {


            Mcb = (PNTFS_MCB)&StructureContext->CachedMcb[LastMcb % 16];
            ((PNTFS_STRUCTURE_CONTEXT)StructureContext)->CachedMcbFileRecord[LastMcb % 16]
                = AttributeContext->FileRecord;
            ((PNTFS_STRUCTURE_CONTEXT)StructureContext)->CachedMcbFileRecordOffset[LastMcb % 16]
                = AttributeContext->FileRecordOffset;

            LastMcb += 1;

            LoadMcb( StructureContext, AttributeContext, Vbo, Mcb );
        }
    }

    //
    //  At this point the mcb contains the vbo asked for.  So now search for the vbo.
    //  Note that we could also do binary search here but because the run count is
    //  probably small the extra overhead of a binary search doesn't buy us anything
    //

    for (i = 0; i < Mcb->InUse; i += 1) {


        //
        //  We found our slot if the vbo we're after is less than the next mcb's vbo
        //

        if (/*xxLtr*/(Vbo < Mcb->Vbo[i+1])) {

            //
            //  Compute the corresponding lbo which is the stored lbo plus the
            //  difference between the stored vbo and the vbo we're looking up.
            //  Also compute the byte count which is the difference between the
            //  current vbo we're looking up and the vbo for the next run
            //

            if (/*xxNeqZero*/(Mcb->Lbo[i] != 0)) {

                *Lbo = /*xxAdd*/(Mcb->Lbo[i] + /*xxSub*/(Vbo - Mcb->Vbo[i]));

            } else {

                *Lbo = 0;
            }

            *ByteCount = ((ULONG)/*xxSub*/(Mcb->Vbo[i+1] - Vbo));

            //
            //  And return to our caller
            //

            return ESUCCESS;
        }
    }

    //
    //  If we really reach here we have an error.  Most likely the file is not large
    //  enough for the requested vbo
    //

    return EINVAL;
}


//
//  Local support routine
//

ARC_STATUS
NtfsDecodeRetrievalInformation (
    IN PCNTFS_STRUCTURE_CONTEXT StructureContext,
    IN PNTFS_MCB Mcb,
    IN VBO Vbo,
    IN PATTRIBUTE_RECORD_HEADER AttributeHeader
    )

/*++

Routine Description:

    This routine does the decode of the retrival information stored in a Nonresident
    attribute header into the specified output mcb starting with the specified
    Lbo.

Arguments:

    StructureContext - Supplies the volume structure for this operation

    Mcb - Supplies the Mcb used in this operation

    Vbo - Supplies the starting vbo that must be stored in the mcb

    AttributeHeader - Supplies the non resident attribute header that
        we are to use in this operation

Return Value:

    ESUCCESS is returned if the operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ULONG BytesPerCluster;

    VBO NextVbo;
    LBO CurrentLbo;
    VBO CurrentVbo;

    LONGLONG Change;
    PCHAR ch;
    ULONG VboBytes;
    ULONG LboBytes;

    //
    //  Initialize our locals
    //

    BytesPerCluster = StructureContext->BytesPerCluster;

    //
    //  Setup the next vbo and current lbo and ch for the following loop that decodes
    //  the retrieval information
    //

    NextVbo = /*xxXMul*/(AttributeHeader->Form.Nonresident.LowestVcn * BytesPerCluster);

    CurrentLbo = 0;

    ch = Add2Ptr( AttributeHeader,
                  AttributeHeader->Form.Nonresident.MappingPairsOffset );

    Mcb->InUse = 0;

    //
    //  Loop to process mapping pairs
    //

    while (!IsCharZero(*ch)) {

        //
        //  Set current Vbo from initial value or last pass through loop
        //

        CurrentVbo = NextVbo;

        //
        //  Extract the counts from the two nibbles of this byte
        //

        VboBytes = *ch & 0x0f;
        LboBytes = *ch++ >> 4;

        //
        //  Extract the Vbo change and update next vbo
        //

        Change = 0;

        if (IsCharLtrZero(*(ch + VboBytes - 1))) {

            return EINVAL;
        }

        RtlMoveMemory( &Change, ch, VboBytes );

        ch += VboBytes;

        NextVbo = /*xxAdd*/(NextVbo + /*xXMul*/(Change * BytesPerCluster));

        //
        //  If we have reached the maximum for this mcb then it is time
        //  to return and not decipher any more retrieval information
        //

        if (Mcb->InUse >= MAXIMUM_NUMBER_OF_MCB_ENTRIES - 1) {

            break;
        }

        //
        //  Now check if there is an lbo change.  If there isn't
        //  then we only need to update the vbo, because this
        //  is sparse/compressed file.
        //

        if (LboBytes != 0) {

            //
            //  Extract the Lbo change and update current lbo
            //

            Change = 0;

            if (IsCharLtrZero(*(ch + LboBytes - 1))) {

                Change = /*xxSub*/( Change - 1 );
            }

            RtlMoveMemory( &Change, ch, LboBytes );

            ch += LboBytes;

            CurrentLbo = /*xxAdd*/( CurrentLbo + /*xxXMul*/(Change * BytesPerCluster));
        }

        //
        //  Now check if the Next Vbo is greater than the Vbo we after
        //

        if (/*xxGeq*/(NextVbo >= Vbo)) {

            //
            //  Load this entry into the mcb and advance our in use counter
            //

            Mcb->Vbo[Mcb->InUse]     = CurrentVbo;
            Mcb->Lbo[Mcb->InUse]     = (LboBytes != 0 ? CurrentLbo : 0);
            Mcb->Vbo[Mcb->InUse + 1] = NextVbo;

            Mcb->InUse += 1;
        }
    }

    return ESUCCESS;
}


//
//  Local support routine
//

VOID
NtfsFirstComponent (
    IN OUT PCSTRING String,
    OUT PCSTRING FirstComponent
    )

/*++

Routine Description:

    This routine takes an input path name and separates it into its first
    file name component and the remaining part.

Arguments:

    String - Supplies the original string being dissected (in ansi).  On return
        this string will now point to the remaining part.

    FirstComponent - Recieves the string representing the first file name in
        the input string.

Return Value:

    None.

--*/

{
    ULONG Index;

    //
    //  Copy over the string variable into the first component variable
    //

    *FirstComponent = *String;

    //
    //  Now if the first character in the name is a backslash then
    //  simply skip over the backslash.
    //

    if (FirstComponent->Buffer[0] == '\\') {

        FirstComponent->Buffer += 1;
        FirstComponent->Length -= 1;
    }

    //
    //  Now search the name for a backslash
    //

    for (Index = 0; Index < FirstComponent->Length; Index += 1) {

        if (FirstComponent->Buffer[Index] == '\\') {

            break;
        }
    }

    //
    //  At this point Index denotes a backslash or is equal to the length of the
    //  string.  So update string to be the remaining part.  Decrement the length of
    //  the first component by the approprate amount
    //

    String->Buffer = &FirstComponent->Buffer[Index];
    String->Length = (SHORT)(FirstComponent->Length - Index);

    FirstComponent->Length = (SHORT)Index;

    //
    //  And return to our caller.
    //

    return;
}


//
//  Local support routine
//

int
NtfsCompareName (
    IN CSTRING AnsiString,
    IN UNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine compares two names (one ansi and one unicode) for equality.

Arguments:

    AnsiString - Supplies the ansi string to compare

    UnicodeString - Supplies the unicode string to compare

Return Value:

    < 0 if AnsiString is approximately < than UnicodeString
    = 0 if AnsiString is approximately == UnicodeString
    > 0 otherwise

--*/

{
    ULONG i;
    ULONG Length;

    //
    //  Determine length for compare
    //

    if (AnsiString.Length * sizeof( WCHAR ) < UnicodeString.Length) {
        Length = AnsiString.Length;
    } else {
        Length = UnicodeString.Length / sizeof( WCHAR );
    }

    i = 0;
    while (i < Length) {

        //
        //  If the current char is a mismatch, return the difference
        //

        if (ToUpper( (USHORT)AnsiString.Buffer[i] ) != ToUpper( UnicodeString.Buffer[i] )) {
            return ToUpper( (USHORT)AnsiString.Buffer[i] ) - ToUpper( UnicodeString.Buffer[i] );
        }

        i++;
    }

    //
    //  We've compared equal up to the length of the shortest string.  Return
    //  based on length comparison now.
    //

    return AnsiString.Length - UnicodeString.Length / sizeof( WCHAR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\nlsboot.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    nlsboot.c

Abstract:

    This module contains NLS routines for use by the OS Loader.  Before
    the NLS tables are loaded, they convert between ANSI and Unicode by
    zero-extending.

Author:

    John Vert (jvert) 11-Nov-1992

Revision History:

    John Vert (jvert) 11-Nov-1992
        created - mostly copied from old RTL routines

--*/
#include "bldr.h"

//
// Hack-o-rama string routines to use before tables are loaded
//

#define upcase(C) (WCHAR )(((C) >= 'a' && (C) <= 'z' ? (C) - ('a' - 'A') : (C)))


NTSTATUS
RtlAnsiStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCANSI_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

{
    ULONG UnicodeLength;
    ULONG Index;

    UnicodeLength = (SourceString->Length << 1) + sizeof(UNICODE_NULL);

    if ( UnicodeLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(UnicodeLength - sizeof(UNICODE_NULL));
    if ( AllocateDestinationString ) {
        return STATUS_NO_MEMORY;
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    Index = 0;
    while(Index < SourceString->Length ) {
        DestinationString->Buffer[Index] = (WCHAR)SourceString->Buffer[Index];
        Index++;
        }
    DestinationString->Buffer[Index] = UNICODE_NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
RtlUnicodeStringToAnsiString(
    OUT PANSI_STRING DestinationString,
    IN  PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

{
    ULONG AnsiLength;
    ULONG Index;

    AnsiLength = SourceString->Length + 1;

    if ( AnsiLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = SourceString->Length >> 1;
    if ( AllocateDestinationString ) {
        return STATUS_NO_MEMORY;
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    Index = 0;
    while(Index < SourceString->Length ) {
        DestinationString->Buffer[Index] = (CHAR)SourceString->Buffer[Index];
        Index++;
        }
    DestinationString->Buffer[Index] = '\0';

    return STATUS_SUCCESS;
}


LONG
RtlCompareUnicodeString(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlCompareUnicodeString function compares two counted strings.  The
    return value indicates if the strings are equal or String1 is less than
    String2 or String1 is greater than String2.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Signed value that gives the results of the comparison:

        Zero - String1 equals String2

        < Zero - String1 less than String2

        > Zero - String1 greater than String2


--*/

{

    UNALIGNED WCHAR *s1, *s2;
    USHORT n1, n2;
    WCHAR c1, c2;
    LONG cDiff;

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n1 = (USHORT )(String1->Length / sizeof(WCHAR));
    n2 = (USHORT )(String2->Length / sizeof(WCHAR));
    while (n1 && n2) {
        c1 = *s1++;
        c2 = *s2++;

        if (CaseInSensitive) {
            //
            // Note that this needs to reference the translation table !
            //
            c1 = upcase(c1);
            c2 = upcase(c2);
        }

        if ((cDiff = ((LONG)c1 - (LONG)c2)) != 0) {
            return( cDiff );
            }

        n1--;
        n2--;
        }

    return( n1 - n2 );
}

BOOLEAN
RtlEqualUnicodeString(
    IN const UNICODE_STRING *String1,
    IN const UNICODE_STRING *String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlEqualUnicodeString function compares two counted unicode strings for
    equality.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{
    UNALIGNED WCHAR *s1, *s2;
    USHORT n1, n2;
    WCHAR c1, c2;

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n1 = (USHORT )(String1->Length / sizeof(WCHAR));
    n2 = (USHORT )(String2->Length / sizeof(WCHAR));

    if ( n1 != n2 ) {
        return FALSE;
        }

    if (CaseInSensitive) {

        while ( n1 ) {

            if ( *s1++ != *s2++ ) {
                c1 = upcase(*(s1-1));
                c2 = upcase(*(s2-1));
                if (c1 != c2) {
                    return( FALSE );
                    }
                }
            n1--;
            }
        }
    else {

        while ( n1 ) {

            if (*s1++ != *s2++) {
                return( FALSE );
                }

            n1--;
            }
        }

    return TRUE;
}


VOID
RtlInitString(
    OUT PSTRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    DestinationString->Length = 0;
    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        while (*SourceString++) {
            DestinationString->Length++;
            }

        DestinationString->MaximumLength = (SHORT)(DestinationString->Length+1);
        }
    else {
        DestinationString->MaximumLength = 0;
        }
}


VOID
RtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    USHORT Length = 0;
    DestinationString->Length = 0;
    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        while (*SourceString++) {
            Length += sizeof(*SourceString);
            }

        DestinationString->Length = Length;

        DestinationString->MaximumLength = Length+(USHORT)sizeof(UNICODE_NULL);
        }
    else {
        DestinationString->MaximumLength = 0;
        }
}


VOID
RtlInitAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PCSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitAnsiString function initializes an NT counted
    ANSI string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated ANSI string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    USHORT Length = 0;
    DestinationString->Length = 0;
    DestinationString->Buffer = (PSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        while (*SourceString++) {
            Length += sizeof(*SourceString);
            }

        DestinationString->Length = Length;

        DestinationString->MaximumLength = Length+1;
        }
    else {
        DestinationString->MaximumLength = 0;
        }
}



NTSTATUS
RtlAppendUnicodeStringToString (
    IN OUT PUNICODE_STRING Destination,
    IN PCUNICODE_STRING Source
    )

/*++

Routine Description:

    This routine will concatinate two PSTRINGs together.  It will copy
    bytes from the source up to the MaximumLength of the destination.

Arguments:

    IN PSTRING Destination, - Supplies the destination string
    IN PSTRING Source - Supplies the source for the string copy

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    USHORT n = Source->Length;
    UNALIGNED WCHAR *dst;

    if (n) {
        if ((n + Destination->Length) > Destination->MaximumLength) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        dst = &Destination->Buffer[ (Destination->Length / sizeof( WCHAR )) ];
        RtlMoveMemory( dst, Source->Buffer, n );

        Destination->Length = Destination->Length + n;

        if (Destination->Length < Destination->MaximumLength) {
            dst[ n / sizeof( WCHAR ) ] = UNICODE_NULL;
            }
        }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlAppendUnicodeToString (
    IN PUNICODE_STRING Destination,
    IN PCWSTR Source OPTIONAL
    )

/*++

Routine Description:

    This routine appends the supplied UNICODE string to an existing
    PUNICODE_STRING.

    It will copy bytes from the Source PSZ to the destination PSTRING up to
    the destinations PUNICODE_STRING->MaximumLength field.

Arguments:

    IN PUNICODE_STRING Destination, - Supplies a pointer to the destination
                            string
    IN PWSTR Source - Supplies the string to append to the destination

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    USHORT n;
    UNALIGNED WCHAR *dst;

    if (ARGUMENT_PRESENT( Source )) {
        UNICODE_STRING UniSource;

        RtlInitUnicodeString(&UniSource, Source);

        n = UniSource.Length;

        if ((n + Destination->Length) > Destination->MaximumLength) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        dst = &Destination->Buffer[ (Destination->Length / sizeof( WCHAR )) ];
        RtlMoveMemory( dst, Source, n );

        Destination->Length = Destination->Length + n;

        if (Destination->Length < Destination->MaximumLength) {
            dst[ n / sizeof( WCHAR ) ] = UNICODE_NULL;
            }
        }

    return( STATUS_SUCCESS );
}

WCHAR
RtlUpcaseUnicodeChar(
    IN WCHAR SourceCharacter
    )

/*++

Routine Description:

    This function translates the specified unicode character to its
    equivalent upcased unicode chararacter.  The purpose for this routine
    is to allow for character by character upcase translation.  The
    translation is done with respect to the current system locale
    information.


Arguments:

    SourceCharacter - Supplies the unicode character to be upcased.

Return Value:

    Returns the upcased unicode equivalent of the specified input character.

--*/

{

    return (upcase(SourceCharacter));
}

WCHAR
RtlAnsiCharToUnicodeChar(
    IN OUT PUCHAR *SourceCharacter
    )

/*++

Routine Description:

    This function translates the specified ansi character to unicode and
    returns the unicode value.  The purpose for this routine is to allow
    for character by character ansi to unicode translation.  The
    translation is done with respect to the current system locale
    information.


Arguments:

    SourceCharacter - Supplies a pointer to an ansi character pointer.
        Through two levels of indirection, this supplies an ansi
        character that is to be translated to unicode.  After
        translation, the ansi character pointer is modified to point to
        the next character to be converted.  This is done to allow for
        dbcs ansi characters.

Return Value:

    Returns the unicode equivalent of the specified ansi character.

--*/

{
    WCHAR UnicodeCharacter;


    UnicodeCharacter = (WCHAR)**SourceCharacter;
    (*SourceCharacter)++;
    return(UnicodeCharacter);
}

NTSTATUS
RtlUpcaseUnicodeToMultiByteN(
    OUT PCH MultiByteString,
    IN ULONG MaxBytesInMultiByteString,
    OUT PULONG BytesInMultiByteString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions upper cases the specified unicode source string and
    converts it into an ansi string. The translation is done with respect
    to the ANSI Code Page (ACP) loaded at boot time.

Arguments:

    MultiByteString - Returns an ansi string that is equivalent to the
        upper case of the unicode source string.  If the translation can
        not be done, an error is returned.

    MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
        written to MultiByteString.  If this causes MultiByteString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInMultiByteString - Returns the number of bytes in the returned
        ansi string pointed to by MultiByteString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to ansi.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

--*/

{
    ULONG LoopCount;
    ULONG CharsInUnicodeString;
    ULONG i;

    //
    // Convert Unicode byte count to character count. Byte count of
    // multibyte string is equivalent to character count.
    //
    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
                 CharsInUnicodeString : MaxBytesInMultiByteString;

    if (ARGUMENT_PRESENT(BytesInMultiByteString))
        *BytesInMultiByteString = LoopCount;


    for (i=0;i<LoopCount;i++) {

        MultiByteString[i] = (UCHAR)RtlUpcaseUnicodeChar((UCHAR)(UnicodeString[i]));
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RtlMultiByteToUnicodeN(
    OUT PWCH UnicodeString,
    IN ULONG MaxBytesInUnicodeString,
    OUT PULONG BytesInUnicodeString OPTIONAL,
    IN PCSTR MultiByteString,
    IN ULONG BytesInMultiByteString)

/*++

Routine Description:

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    ANSI Code Page (ACP) installed at boot time.  Single byte characters
    in the range 0x00 - 0x7f are simply zero extended as a performance
    enhancement.  In some far eastern code pages 0x5c is defined as the
    Yen sign.  For system translation we always want to consider 0x5c
    to be the backslash character.  We get this for free by zero extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    UnicodeString - Returns a unicode string that is equivalent to
        the ansi source string.

    MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
        written to UnicodeString.  If this causes UnicodeString to be a
        truncated equivalent of MultiByteString, no error condition results.

    BytesInUnicodeString - Returns the number of bytes in the returned
        unicode string pointed to by UnicodeString.

    MultiByteString - Supplies the ansi source string that is to be
        converted to unicode.

    BytesInMultiByteString - The number of bytes in the string pointed to
        by MultiByteString.

Return Value:

    SUCCESS - The conversion was successful.


--*/

{
    ULONG LoopCount;
    ULONG MaxCharsInUnicodeString;
    ULONG i;

    MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);

    LoopCount = (MaxCharsInUnicodeString < BytesInMultiByteString) ?
                 MaxCharsInUnicodeString : BytesInMultiByteString;

    if (ARGUMENT_PRESENT(BytesInUnicodeString))
        *BytesInUnicodeString = LoopCount * sizeof(WCHAR);

    for (i=0;i<LoopCount;i++) {
        UnicodeString[i] = (WCHAR)((UCHAR)(MultiByteString[i]));
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
RtlUnicodeToMultiByteN(
    OUT PCH MultiByteString,
    IN ULONG MaxBytesInMultiByteString,
    OUT PULONG BytesInMultiByteString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    ansi string. The translation is done with respect to the
    ANSI Code Page (ACP) loaded at boot time.

Arguments:

    MultiByteString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.

    MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
        written to MultiByteString.  If this causes MultiByteString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInMultiByteString - Returns the number of bytes in the returned
        ansi string pointed to by MultiByteString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to ansi.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

--*/

{
    ULONG LoopCount;
    ULONG CharsInUnicodeString;
    ULONG i;

    //
    // Convert Unicode byte count to character count. Byte count of
    // multibyte string is equivalent to character count.
    //
    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
                 CharsInUnicodeString : MaxBytesInMultiByteString;

    if (ARGUMENT_PRESENT(BytesInMultiByteString))
        *BytesInMultiByteString = LoopCount;


    for (i=0;i<LoopCount;i++) {
        MultiByteString[i] = (CHAR)(UnicodeString[i]);
    }

    return STATUS_SUCCESS;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\peldrt.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    peldrt.c

Abstract:

    This module implements the code to load a PE format image into memory
    and relocate it if necessary.

Author:

    David N. Cutler (davec) 10-May-1991

Environment:

    Kernel mode only.

Revision History:

    Forrest Foltz (forrestf) 10-Jun-2000

        Broke out x86 32/64 code into this module

--*/
#if defined(_IA64_)
#include "bootia64.h"
#else
#include "bootx86.h"
#endif

extern BOOLEAN BlBootingFromNet;

#if defined(_X86AMD64_)
#define ChkSum(a,b,c) 0
#endif


ARC_STATUS
BlLoadImageEx(
    IN ULONG DeviceId,
    IN TYPE_OF_MEMORY MemoryType,
    IN PCHAR LoadFile,
    IN USHORT ImageType,
    IN OPTIONAL ULONG PreferredAlignment,
    IN OPTIONAL ULONG PreferredBasePage,
    OUT PVOID *ImageBase
    )

/*++

Routine Description:

    This routine attempts to load the specified file from the specified
    device.

Arguments:

    DeviceId - Supplies the file table index of the device to load the
        specified image file from.

    MemoryType - Supplies the type of memory to to be assigned to the
        allocated memory descriptor.

    BootFile - Supplies a pointer to string descriptor for the name of
        the file to load.

    ImageType - Supplies the type of image that is expected.

    PreferredAlignment - If present, supplies the preferred image alignment.

    PreferredBasePage - If present, supplies the preferred base page which will
        override the image base address

    ImageBase - Supplies a pointer to a variable that receives the
        address of the image base.

Return Value:

    ESUCCESS is returned if the specified image file is loaded
    successfully. Otherwise, an unsuccessful status is returned
    that describes the reason for failure.

--*/

{

    ULONG ActualBase;
    ULONG BasePage;
    ULONG Count;
    ULONG FileId;
    ULONG_PTR NewImageBase;
    ULONG Index;
    UCHAR LocalBuffer[(SECTOR_SIZE * 2) + 256];
    PUCHAR LocalPointer;
    ULONG NumberOfSections;
    ULONG PageCount;
    USHORT MachineType;
    ARC_STATUS Status;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_SECTION_HEADER SectionHeader;
    LARGE_INTEGER SeekPosition;
    ULONG RelocSize = 0;
    FILE_INFORMATION FileInfo;
    PUSHORT AdjustSum;
    USHORT PartialSum;
    ULONG CheckSum;
    ULONG VirtualSize;
    ULONG SizeOfRawData;
    BOOLEAN bCloseFile = FALSE;
    BOOLEAN bFreeCache = FALSE;
    IMAGE_PREFETCH_CACHE ImgCache = {0};
    LONGLONG AdditionalImageBias = 0;
#if defined(IMAGE_DEFINITIONS) && IMAGE_DEFINITIONS == 64
    ULONG LoaderBaseAddress;

    UNREFERENCED_PARAMETER( PreferredBasePage );
#endif 

    if (PreferredAlignment == 0) {
        PreferredAlignment = 1;
    }
    //
    // Align the buffer on a Dcache fill boundary.
    //

    LocalPointer = ALIGN_BUFFER(LocalBuffer);

    //
    // Attempt to open the image file.
    //

    Status = BlOpen(DeviceId, LoadFile, ArcOpenReadOnly, &FileId);
    if (Status != ESUCCESS) {
        goto cleanup;
    }
    bCloseFile = TRUE;

    //
    // Try to prefetch the whole file into a prefetch buffer. The file
    // must have been opened read-only and must not be modified until
    // the cache is freed by the BlImageFreeCache call. The file position
    // of FileId is reset to the beginning of the file.
    //

    if ((BlBootingFromNet) || (BlImageInitCache(&ImgCache, FileId) != ESUCCESS) ) {
        //
        // Make sure file position is at the beginning of the file.
        // BlImageInitCache leaves file position undefined under failure.
        //

        SeekPosition.QuadPart = 0;
        Status = BlSeek(FileId, &SeekPosition, SeekAbsolute);
        if (Status != ESUCCESS) {
            goto cleanup;
        }
    } else {
        //
        // We got a cache. Make a note to free it.
        //

        bFreeCache = TRUE;
    }

    //
    // Read the first two sectors of the image header from the file.
    //

    Status = BlImageRead(&ImgCache, FileId, LocalPointer, SECTOR_SIZE * 2, &Count);
    if (Status != ESUCCESS) {
        goto cleanup;
    }

    //
    // If the image file is not the specified type, is not executable, or is
    // not a NT image, then return bad image type status.
    //

    NtHeaders = IMAGE_NT_HEADER(LocalPointer);
    if (NtHeaders == NULL) {
        Status = EBADF;
        goto cleanup;
    }

    MachineType = NtHeaders->FileHeader.Machine;
    if ((MachineType != ImageType) ||
        ((NtHeaders->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0)) {
        Status = EBADF;
        goto cleanup;
    }

    //
    // Compute the starting page and the number of pages that are consumed
    // by the entire image, and then allocate a memory descriptor for the
    // allocated region.
    //

    NumberOfSections = NtHeaders->FileHeader.NumberOfSections;
    SectionHeader = IMAGE_FIRST_SECTION( NtHeaders );

#if !defined(IMAGE_DEFINITIONS) || IMAGE_DEFINITIONS == 32

    //
    // If a preferred alignment was specified or the image is not located in KSEG0,
    // then don't bother trying to put it at its specified image base.
    //
    if (PreferredBasePage != 0) {
        BasePage = PreferredBasePage;
    } else if ((PreferredAlignment != 1) ||
               ((NtHeaders->OptionalHeader.ImageBase & KSEG0_BASE) == 0)) {
        BasePage = 0;
    } else {
        BasePage = (ULONG)((NtHeaders->OptionalHeader.ImageBase & 0x1fffffff) >> PAGE_SHIFT);
    }

    AdditionalImageBias = 0;

#elif IMAGE_DEFINITIONS == 64

    LoaderBaseAddress =
        (ULONG)(NtHeaders->OptionalHeader.ImageBase & 0x7fffffff);

    BasePage = LoaderBaseAddress >> PAGE_SHIFT;
    AdditionalImageBias = (ULONGLONG)KSEG0_BASE_AMD64 - (ULONG)KSEG0_BASE_X86;

#endif

    if (strcmp((PCHAR)&SectionHeader[NumberOfSections - 1].Name, ".debug") == 0) {
        NumberOfSections -= 1;
        PageCount = (NtHeaders->OptionalHeader.SizeOfImage -
            SectionHeader[NumberOfSections].SizeOfRawData + PAGE_SIZE - 1) >> PAGE_SHIFT;

    } else {
        PageCount =
         (NtHeaders->OptionalHeader.SizeOfImage + PAGE_SIZE - 1) >> PAGE_SHIFT;
    }

    //
    // If we fail to allocate memory descriptor here, we will try again
    // below after freeing the cache if we have one.
    //

    Status = BlAllocateAlignedDescriptor(MemoryType,
                                         BasePage,
                                         PageCount,
                                         PreferredAlignment,
                                         &ActualBase);


    if (Status != ESUCCESS) {

        //
        // Free the memory we have allocated for caching the image and
        // try again.
        //

        if (bFreeCache) {
            BlImageFreeCache(&ImgCache, FileId);
            bFreeCache = FALSE;

            Status = BlAllocateDescriptor(MemoryType,
                                          BasePage,
                                          PageCount,
                                          &ActualBase);
        }


        if( Status != ESUCCESS ) {
            //
            // We're about to fail.  Better just try to fiddle with
            // the BlUsableBase and Limit variables and see if we
            // can load the image.
            //
            ULONG oldBase;
            ULONG oldLimit;
            
            oldBase = BlUsableBase;
            oldLimit = BlUsableLimit;
            BlUsableBase = BL_DRIVER_RANGE_LOW;
            BlUsableLimit = BL_DRIVER_RANGE_HIGH;


            Status = BlAllocateDescriptor(MemoryType,
                                          BasePage,
                                          PageCount,
                                          &ActualBase);


            BlUsableBase = oldBase;
            BlUsableLimit = oldLimit;

        }

        //
        // Check to see if we were able to allocate memory after freeing
        // cache if we had one.
        //

        if (Status != ESUCCESS) {
            Status = ENOMEM;
            goto cleanup;
        }
    }

    //
    // Compute the address of the file header.
    //

    NewImageBase = KSEG0_BASE | (ActualBase << PAGE_SHIFT);

    //
    // If we're loading the kernel or hal, the PTEs for these
    // may need to be patched up.  Do that here.
    //
    if (MemoryType == LoaderSystemCode ||
        MemoryType == LoaderHalCode) {
       Status = BlpFixOSMapping( ActualBase, PageCount );
       if (Status != ESUCCESS) {
           Status = ENOMEM;
           goto cleanup;
       }
    }

    //
    // Read the entire image header from the file.
    //

    SeekPosition.QuadPart = 0;
    Status = BlImageSeek(&ImgCache, FileId, &SeekPosition, SeekAbsolute);
    if (Status != ESUCCESS) {
        goto cleanup;
    }

    Status = BlImageRead(&ImgCache,
                         FileId,
                         (PVOID)NewImageBase,
                         NtHeaders->OptionalHeader.SizeOfHeaders,
                         &Count);

    if (Status != ESUCCESS) {
        goto cleanup;
    }

    NtHeaders = IMAGE_NT_HEADER((PVOID)NewImageBase);

    if (NtHeaders == NULL) {
        Status = EBADF;
        goto cleanup;
    }

    //
    // Compute the address of the section headers, set the image base address.
    //

    SectionHeader = IMAGE_FIRST_SECTION(NtHeaders);

    //
    // Compute the check sum on the image.
    //

    PartialSum = ChkSum(0,
                        (PVOID)NewImageBase,
                        NtHeaders->OptionalHeader.SizeOfHeaders / sizeof(USHORT));

    //
    // Scan through the sections and either read them into memory or clear
    // the memory as appropriate.
    //

    for (Index = 0; Index < NumberOfSections; Index += 1) {
        VirtualSize = SectionHeader->Misc.VirtualSize;
        SizeOfRawData = SectionHeader->SizeOfRawData;
        VirtualSize = (VirtualSize + 1) & ~1;
        SizeOfRawData = (SizeOfRawData + 1) & ~1;
        if (VirtualSize == 0) {
            VirtualSize = SizeOfRawData;
        }

        //
        // Compute the size of the raw data.
        //
        // N.B. The size ofthe raw data can be non-zero even when the pointer
        //      to the raw data is zero. The size of the raw data can also be
        //      larger than the virtual size.
        //

        if (SectionHeader->PointerToRawData == 0) {
            SizeOfRawData = 0;

        } else if (SizeOfRawData > VirtualSize) {
            SizeOfRawData = VirtualSize;
        }

        //
        // If the size of the raw data is not zero, then load the raw data
        // into memory.
        //

        if (SizeOfRawData != 0) {
            SeekPosition.LowPart = SectionHeader->PointerToRawData;
            Status = BlImageSeek(&ImgCache,
                                 FileId,
                                 &SeekPosition,
                                 SeekAbsolute);

            if (Status != ESUCCESS) {
                break;
            }

            Status = BlImageRead(&ImgCache,
                                 FileId,
                                 (PVOID)(SectionHeader->VirtualAddress + NewImageBase),
                                 SizeOfRawData,
                                 &Count);

            if (Status != ESUCCESS) {
                break;
            }

            //
            // Remember how far we have read.
            //

            RelocSize = SectionHeader->PointerToRawData + SizeOfRawData;

            //
            // Compute the check sum on the section.
            //

            PartialSum = ChkSum(PartialSum,
                                (PVOID)(SectionHeader->VirtualAddress + NewImageBase),
                                SizeOfRawData / sizeof(USHORT));
        }

        //
        // If the size of the raw data is less than the virtual size, then zero
        // the remaining memory.
        //

        if (SizeOfRawData < VirtualSize) {
            RtlZeroMemory((PVOID)(KSEG0_BASE | SectionHeader->VirtualAddress + NewImageBase + SizeOfRawData),
                          VirtualSize - SizeOfRawData);

        }

        SectionHeader += 1;
    }

    //
    // Only do the check sum if the image loaded properly and is stripped.
    //

    if ((Status == ESUCCESS) &&
        (NtHeaders->FileHeader.Characteristics & IMAGE_FILE_DEBUG_STRIPPED)) {

        //
        // Get the length of the file for check sum validation.
        //

        Status = BlGetFileInformation(FileId, &FileInfo);
        if (Status != ESUCCESS) {

            //
            // Set the length to current end of file.
            //

            Count = RelocSize;
            FileInfo.EndingAddress.LowPart = RelocSize;

        } else {
            Count = FileInfo.EndingAddress.LowPart;
        }

        Count -= RelocSize;
        while (Count != 0) {
            ULONG Length;

            //
            // Read in the rest of the image and check sum it.
            //

            Length = Count < SECTOR_SIZE * 2 ? Count : SECTOR_SIZE * 2;
            if (BlImageRead(&ImgCache, FileId, LocalBuffer, Length, &Length) != ESUCCESS) {
                break;
            }

            if (Length == 0) {
                break;

            }

            PartialSum = ChkSum(PartialSum, (PUSHORT) LocalBuffer, Length / 2);
            Count -= Length;
        }


        AdjustSum = (PUSHORT)(&NtHeaders->OptionalHeader.CheckSum);
        PartialSum -= (PartialSum < AdjustSum[0]);
        PartialSum = PartialSum - AdjustSum[0];
        PartialSum -= (PartialSum < AdjustSum[1]);
        PartialSum = PartialSum - AdjustSum[1];
        CheckSum = (ULONG)PartialSum + FileInfo.EndingAddress.LowPart;

#if !defined(_X86AMD64_)
        if (CheckSum != NtHeaders->OptionalHeader.CheckSum) {
            Status = EBADF;
        }
#endif
    }

    //
    // If the specified image was successfully loaded, then perform image
    // relocation if necessary.
    //

    if (Status == ESUCCESS) {

        //
        // If a virtual bias is specified, then attempt to relocate the
        // image to its biased address. If the image cannot be relocated,
        // then turn off the virtual bias, and attempt to relocate the
        // image again as its allocated base. Otherwise, just attempt to
        // relocate the image to its allocated base.
        //
        // N.B. The loaded image is double mapped at the biased address.
        //
        // N.B. It is assumed that the only possibly nonrelocatable image
        //      is the kernel image which is the first image that is loaded.
        //      Therefore, if a biased address is specified and the kernel
        //      cannot be relocated, then the biased loading of the kernel
        //      image is turned off.
        //

        if (BlVirtualBias != 0) {
            Status = LdrRelocateImage((PVOID)(NewImageBase + BlVirtualBias),
                                      "OS Loader",
                                      ESUCCESS,
                                      0xffff0000 + EBADF,
                                      EBADF);

            if (Status == (0xffff0000 + EBADF)) {
               BlVirtualBias = 0;
               if (NewImageBase != NtHeaders->OptionalHeader.ImageBase) {
                   Status = (ARC_STATUS)LdrRelocateImage((PVOID)NewImageBase,
                                                         "OS Loader",
                                                         ESUCCESS,
                                                         EBADF,
                                                         EBADF);
               } else {
                  Status = ESUCCESS;
               }

            }

        } else {
            if (NewImageBase != NtHeaders->OptionalHeader.ImageBase) {
                Status = LdrRelocateImageWithBias((PVOID)NewImageBase,
                                                  AdditionalImageBias,
                                                  "OS Loader",
                                                  ESUCCESS,
                                                  EBADF,
                                                  EBADF);
            }
        }

        *ImageBase = (PVOID)(NewImageBase + BlVirtualBias);

        if(BdDebuggerEnabled) {
            DbgPrint("BD: %s base address %p\n", LoadFile, *ImageBase);
#if !defined(_X86AMD64_)
            {
                STRING string;

                RtlInitString(&string, LoadFile);
                DbgLoadImageSymbols(&string, *ImageBase, (ULONG_PTR)-1);
            }
#endif
        }
    }

#if 0

    //
    // Mark the pages from the relocation information to the end of the
    // image as MemoryFree and adjust the size of the image so table
    // based structured exception handling will work properly.
    //
    // Relocation sections are no longer deleted here because memory
    // management will be relocating them again in Phase 0.
    //

    RelocDirectory = (PIMAGE_BASE_RELOCATION)
        RtlImageDirectoryEntryToData((PVOID)NewImageBase,
                                     TRUE,
                                     IMAGE_DIRECTORY_ENTRY_BASERELOC,
                                     &RelocSize );

    if (RelocDirectory != NULL) {
        RelocPage = (ULONG)(((ULONG_PTR)RelocDirectory + PAGE_SIZE - 1) >> PAGE_SHIFT);
        RelocPage &= ~(KSEG0_BASE >> PAGE_SHIFT);
        MemoryDescriptor = BlFindMemoryDescriptor(RelocPage);
        if ((MemoryDescriptor != NULL) && (RelocPage < (ActualBase + PageCount))) {
            RelocPageCount = MemoryDescriptor->PageCount +
                             MemoryDescriptor->BasePage  -
                             RelocPage;

            NtHeaders->OptionalHeader.SizeOfImage =
                                        (RelocPage - ActualBase) << PAGE_SHIFT;

            BlGenerateDescriptor(MemoryDescriptor,
                                 MemoryFree,
                                 RelocPage,
                                 RelocPageCount );
        }
    }

#endif

#if defined(_GAMBIT_)
    {
        SSC_IMAGE_INFO ImageInfo;

        ImageInfo.LoadBase = *ImageBase;
        ImageInfo.ImageSize = NtHeaders->OptionalHeader.SizeOfImage;
        ImageInfo.ImageType = NtHeaders->FileHeader.Machine;
        ImageInfo.ProcessID.QuadPart = 0;
        ImageInfo.LoadCount = 1;

        if (memcmp(LoadFile, "\\ntdetect.exe", 13) != 0) {
            SscLoadImage64( LoadFile,
                            &ImageInfo );
        }
    }
#endif // _GAMBIT_

cleanup:

    if (bFreeCache) {
        BlImageFreeCache(&ImgCache, FileId);
    }

    if (bCloseFile) {
        BlClose(FileId);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\ramdisk.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ramdisk.c

Abstract:

    Provides the ARC emulation routines for I/O to a RAM disk device.

Author:

    Chuck Lenzmeier (chuckl) 29-Apr-2001

Revision History:

    Bassam Tabbara (bassamt) 06-Aug-2001 Added Ramdisk Building Support

--*/


#include "bootlib.h"
#include "arccodes.h"
#include "stdlib.h"
#include "string.h"
#if defined(_X86_)
#include "bootx86.h"
#endif
#if defined(_IA64_)
#include "bootia64.h"
#endif
#include "ramdisk.h"
#include "netfs.h"
#include "bmbuild.h"
#include "ntexapi.h"
#include "haldtect.h"
#include "pci.h"
#include "pbios.h"
#include "bldr.h"

#include <sdistructs.h>

//
// Debug helpers
//
#define ERR     0
#define INFO    1
#define VERBOSE 2
#define PAINFUL 3

#define DBGPRINT(lvl, _fmt_) if (RamdiskDebug && lvl <= RamdiskDebugLevel) DbgPrint _fmt_
#define DBGLVL(x) (RamdiskDebug && RamdiskDebugLevel == x)

BOOLEAN RamdiskDebug = TRUE;
BOOLEAN RamdiskDebugLevel = INFO;
BOOLEAN RamdiskBreak = FALSE;

//
// Macros
//
#define BL_INVALID_FILE_ID (ULONG)-1

#define TEST_BIT(value, b) (((value) & (b)) == (b))

#define ROUND2(_val, _round)    (((_val) + ((_round) - 1)) & ~((_round) - 1))

//
// PCI Device struct as persisted in registry by ntdetect.com
//

#include <pshpack1.h>
typedef struct _PCIDEVICE {
    USHORT BusDevFunc;
    PCI_COMMON_CONFIG Config;
} PCIDEVICE, *PPCIDEVICE;
#include <poppack.h>

//
// Externs
//

extern PVOID InfFile;
extern BOOLEAN GraphicsMode;
extern BOOLEAN BlShowProgressBar;
extern BOOLEAN BlOutputDots;
extern BOOLEAN DisplayLogoOnBoot;

//
// Global Ramdisk options. 
// NOTE: All Ip addresses and ports are in network byte order.
//

BOOLEAN RamdiskBuild = FALSE;

//
// Used if downloading a ramdisk directly. RamdiskBuild = FALSE
//

PCHAR  RamdiskPath = NULL;
ULONG  RamdiskTFTPAddr = 0;             // network byte order
ULONG  RamdiskMTFTPAddr = 0;            // network byte order
USHORT RamdiskMTFTPCPort = 0;           // network byte order
USHORT RamdiskMTFTPSPort = 0;           // network byte order
USHORT RamdiskMTFTPTimeout = 5;
USHORT RamdiskMTFTPDelay = 5;
LONGLONG RamdiskMTFTPFileSize = 0;
LONGLONG RamdiskMTFTPChunkSize = 0;


//
// Used if Building a ramdisk. RamdiskBuild = TRUE
//
#define RAMDISK_MAX_SERVERS     10
#define RAMDISK_MAX_TIMEOUT     60
#define RAMDISK_UI_WAIT         3

GUID   RamdiskGuid = {0,0,0,0};
ULONG  RamdiskDiscovery = 0xFFFFFFFF; 
ULONG  RamdiskMCastAddr = 0;        // network byte order
ULONG  RamdiskServerCount = 0;
ULONG  RamdiskServers[RAMDISK_MAX_SERVERS];         // network byte order
USHORT RamdiskBuildPort = BMBUILD_SERVER_PORT_DEFAULT;
USHORT RamdiskTimeout = 4;
USHORT RamdiskRetry = 5;

//
// Globals
//

BOOLEAN RamdiskActive = FALSE;
ULONG RamdiskBasePage = 0;
LONGLONG RamdiskFileSize = 0;
ULONG RamdiskFileSizeInPages = 0;
ULONG RamdiskImageOffset = 0;
LONGLONG RamdiskImageLength = 0;
ULONG_PTR SdiAddress = 0;

ULONG RamdiskMaxPacketSize = 0;
ULONG RamdiskXID = 0;


BL_DEVICE_ENTRY_TABLE RamdiskEntryTable =
    {
        (PARC_CLOSE_ROUTINE)RamdiskClose,
        (PARC_MOUNT_ROUTINE)RamdiskMount,
        (PARC_OPEN_ROUTINE)RamdiskOpen,
        (PARC_READ_ROUTINE)RamdiskRead,
        (PARC_READ_STATUS_ROUTINE)RamdiskReadStatus,
        (PARC_SEEK_ROUTINE)RamdiskSeek,
        (PARC_WRITE_ROUTINE)RamdiskWrite,
        (PARC_GET_FILE_INFO_ROUTINE)RamdiskGetFileInfo,
        (PARC_SET_FILE_INFO_ROUTINE)RamdiskSetFileInfo,
        (PRENAME_ROUTINE)RamdiskRename,
        (PARC_GET_DIRECTORY_ENTRY_ROUTINE)RamdiskGetDirectoryEntry,
        (PBOOTFS_INFO)NULL
    };

//
// forward decls
//

PVOID
MapRamdisk (
    IN LONGLONG Offset,
    OUT PLONGLONG AvailableLength
    );

ARC_STATUS 
RamdiskParseOptions (
    IN PCHAR LoadOptions
    );

ARC_STATUS
RamdiskInitializeFromPath(
    );

ARC_STATUS
RamdiskBuildAndInitialize(
    );

VOID
RamdiskFatalError(
    IN ULONG Message1,
    IN ULONG Message2
    );



ARC_STATUS
RamdiskInitialize(
    IN PCHAR LoadOptions,
    IN BOOLEAN SdiBoot
    )
/*++

Routine Description:

    This function will initiate the boot from a RAMDISK. Depending
    on the options passed in the the boot will either happen from 
    a static RAMDISK (using the /RDPATH option) or from a dynamic
    RAMDISK (using the /RDBUILD option).

Arguments:

    LoadOptions - boot.ini parameters

    SdiBoot - indicates whether this is an SDI boot. If it is, LoadOptions
        is ignored. The global variable SdiAddress gives the pointer to
        the SDI image.

Return Value:

    none

--*/
{
    ARC_STATUS status;
    BOOLEAN OldOutputDots = FALSE;
    BOOLEAN OldShowProgressBar = FALSE;
    ULONG oldBase;
    ULONG oldLimit;

    //
    // Debug Break on entry
    //
    if (RamdiskBreak) {
        DbgBreakPoint();
    }

    //
    // If the ramdisk has already been initialized, just return. We know the
    // ramdisk has been initialized if SdiBoot is FALSE (implying that this is
    // NOT the call from BlStartup(), but the call from BlOsLoader()) and
    // RamdiskBasePage is not NULL (implying that we were previously called
    // from BlStartup() to initialize the SDI boot.
    //

    if ( !SdiBoot && (RamdiskBasePage != 0) ) {

        //
        // Now that ntdetect has been run, we can free up the pages that
        // we allocated earlier (see below).
        //

        BlFreeDescriptor( 0x10 );

        return ESUCCESS;
    }

    //
    // If this is an SDI boot, then we must have a pointer to the SDI image.
    //

    if ( SdiBoot && (SdiAddress == 0) ) {

        RamdiskFatalError( RAMDISK_GENERAL_FAILURE, 
                           RAMDISK_INVALID_OPTIONS );
        return EINVAL;
    }

    //
    // If this is not an SDI boot, parse all ramdisk options (if any).
    //

    if ( !SdiBoot ) {
        status = RamdiskParseOptions ( LoadOptions );
        if (status != ESUCCESS) {
            RamdiskFatalError( RAMDISK_GENERAL_FAILURE, 
                               RAMDISK_INVALID_OPTIONS );
            return status;                           
        }
    }

#if defined(_IA64_)
    // Ramdisk boot path not supported on IA64 as of yet
    if ( RamdiskBuild ) {
        return ESUCCESS;
    }
#endif

    //
    // Show the progress bar in text mode
    //
    if ( RamdiskBuild || RamdiskPath ) {

        // If booting from a ramdisk, graphics mode is off permanently
        DisplayLogoOnBoot = FALSE;
        GraphicsMode = FALSE;

        OldShowProgressBar = BlShowProgressBar;
        BlShowProgressBar = TRUE;

        OldOutputDots = BlOutputDots;
        BlOutputDots = TRUE;
    }

#if defined(i386)

    if ( RamdiskBuild ) {

        //
        // We will need to build the ramdisk first
        //

        ASSERT( RamdiskPath == NULL );

        status = RamdiskBuildAndInitialize();
        if (status != ESUCCESS) {
            RamdiskFatalError( RAMDISK_GENERAL_FAILURE, 
                               RAMDISK_BUILD_FAILURE );
            return status;
        }
    }

#endif

    if ( RamdiskPath ) {

        //
        // Initialize the Ramdisk from the RamdiskPath
        //

        status = RamdiskInitializeFromPath();
        if (status != ESUCCESS) {
            RamdiskFatalError( RAMDISK_GENERAL_FAILURE, 
                               RAMDISK_BOOT_FAILURE );
            return status;
        }

    } else if ( SdiBoot ) {

        //
        // This is an SDI boot. Find the ramdisk image within the SDI image
        // and allocate the pages in which the ramdisk image resides.
        //

        ULONG basePage;
        ULONG pageCount;
        PSDI_HEADER sdiHeader;
        ULONG i;
        ULONG_PTR ramdiskAddress;

        //
        // Temporarily allocate the pages that will be occupied by ntdetect
        // while it runs. BlDetectHardware() just assumes that these pages
        // are free for loading ntdetect. But we're going to allocate and map
        // the ramdisk image, which will result in the allocation of many
        // page table pages, some of which might end up in the place where
        // ntdetect will be loaded. So we allocate the ntdetect range here,
        // then free it later (see above).
        //

        basePage = 0x10;
        pageCount = 0x10;

        status = BlAllocateAlignedDescriptor(
                    LoaderFirmwareTemporary,
                    basePage,
                    pageCount,
                    0,
                    &basePage
                    );

        //
        // Allocate the page that contains the SDI header. This will cause
        // it to be mapped, which will allow us to read the header to find
        // the ramdisk image.
        //

        oldBase = BlUsableBase;
        oldLimit = BlUsableLimit;
        BlUsableBase = BL_XIPROM_RANGE_LOW;
        BlUsableLimit = BL_XIPROM_RANGE_HIGH;
    
        basePage = (ULONG)(SdiAddress >> PAGE_SHIFT);
        pageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES( SdiAddress, sizeof(SDI_HEADER) );

        status = BlAllocateAlignedDescriptor(
                    LoaderFirmwareTemporary,
                    basePage,
                    pageCount,
                    0,
                    &basePage
                    );

        BlUsableBase = oldBase;
        BlUsableLimit = oldLimit;

        //
        // Find the ramdisk image by looking through the TOC in the SDI header.
        //

        sdiHeader = (PSDI_HEADER)SdiAddress;

        for ( i = 0; i < SDI_TOCMAXENTRIES; i++ ) {
            if ( sdiHeader->ToC[i].dwType == SDI_BLOBTYPE_PART ) {
                break;
            }
        }

        if ( i >= SDI_TOCMAXENTRIES ) {
            RamdiskFatalError( RAMDISK_GENERAL_FAILURE, 
                               RAMDISK_BOOT_FAILURE );
            return ENOENT;
        }

        //
        // Calculate the starting address and page of the ramdisk image, the
        // length of the ramdisk image, and the offset within the starting page
        // to the image. The offset should be 0, because everything in the SDI
        // image should be page-aligned.
        //

        ramdiskAddress = (ULONG_PTR)(SdiAddress + sdiHeader->ToC[i].llOffset.QuadPart);
        RamdiskBasePage = (ULONG)(ramdiskAddress >> PAGE_SHIFT);

        RamdiskImageOffset = (ULONG)(ramdiskAddress - ((ULONG_PTR)RamdiskBasePage << PAGE_SHIFT));
        RamdiskImageLength = sdiHeader->ToC[i].llSize.QuadPart;

        RamdiskFileSizeInPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                                    ramdiskAddress,
                                    RamdiskImageLength
                                    );
        RamdiskFileSize = (LONGLONG)RamdiskFileSizeInPages << PAGE_SHIFT;

        //
        // Release the page(s) occupied by the SDI header.
        //

        BlFreeDescriptor( basePage );

        //
        // Tell the memory allocator about the pages occupied by the ramdisk
        // by allocating those pages.
        //

        oldBase = BlUsableBase;
        oldLimit = BlUsableLimit;
        BlUsableBase = BL_XIPROM_RANGE_LOW;
        BlUsableLimit = BL_XIPROM_RANGE_HIGH;
    
        basePage = RamdiskBasePage;
        pageCount = RamdiskFileSizeInPages;

        status = BlAllocateAlignedDescriptor(
                    LoaderXIPRom,
                    basePage,
                    pageCount,
                    0,
                    &basePage
                    );
    
        BlUsableBase = oldBase;
        BlUsableLimit = oldLimit;

        ASSERT( status == ESUCCESS );
        ASSERT( basePage == RamdiskBasePage );

        DBGPRINT(VERBOSE, ("Ramdisk is active\n") );
        RamdiskActive = TRUE;
    }

    //
    // Restore old progress bar settings
    //
    if ( RamdiskBuild || RamdiskPath ) {
        BlShowProgressBar = OldShowProgressBar;
        BlOutputDots = OldOutputDots;
        BlClearScreen();
    }

    return ESUCCESS;
}

ARC_STATUS
RamdiskReadImage(
    PCHAR RamdiskPath
    )
/*++

Routine Description:

    This function will load a ramdisk image from the network
    or another ARC boot device.

Arguments:

    RamdiskPath - name of the file to load

Return Value:

    status    

--*/
{
    ARC_STATUS status;
    ULONG RamdiskDeviceId;
    ULONG RamdiskFileId = BL_INVALID_FILE_ID;
    PCHAR p;
    FILE_INFORMATION fileInformation;
    LARGE_INTEGER offset;
    LONGLONG remainingLength;
    ULONG oldBase;
    ULONG oldLimit;
    BOOLEAN retry = TRUE;
    ULONG lastProgressPercent = 0; 
    BOOLEAN ForceDisplayFirstTime = TRUE; // force display initially
    ULONG currentProgressPercent;
    PUCHAR ip;
    PTCHAR FormatString = NULL;
    TCHAR Buffer[256];
    
    //
    // Show text progress bar
    //
    BlOutputStartupMsg(RAMDISK_DOWNLOAD);
    BlUpdateProgressBar(0);

    DBGPRINT(VERBOSE, ("RamdiskReadImage(%s)\n", RamdiskPath));

    //
    // Open the device that the RAM disk image is on.
    //

    p = strchr(RamdiskPath, '\\');
    if (p == NULL) {
        DBGPRINT(ERR, ("no \\ found in path\n"));
        return EINVAL;
    }

    *p = 0;

try_again:

    status = ArcOpen(RamdiskPath, ArcOpenReadWrite, &RamdiskDeviceId);
    if (status != ESUCCESS) {
        DBGPRINT(ERR, ("ArcOpen(%s) failed: %d\n", RamdiskPath, status));
        if ( retry ) {
            retry = FALSE;
            _strlwr(RamdiskPath);
            goto try_again;
        }
        *p = '\\';
        return status;
    }

    *p++ = '\\';

    //
    // If the RAM disk image is on the network, use TftpGetPut to read it.
    // Otherwise, use normal I/O.
    //

    oldBase = BlUsableBase;
    oldLimit = BlUsableLimit;
    BlUsableBase = BL_XIPROM_RANGE_LOW;
    BlUsableLimit = BL_XIPROM_RANGE_HIGH;

#ifdef EFI // multicast ramdisk download only supported on non-EFI machines for now

    if ( RamdiskDeviceId == NET_DEVICE_ID && RamdiskMTFTPAddr != 0 )
    {
        ArcClose( RamdiskDeviceId );
        return EBADF;
    }

#endif

    if ( RamdiskDeviceId == NET_DEVICE_ID && RamdiskMTFTPAddr == 0) {

        //
        // Network device using UNICAST download. We will use the TFTP
        // client implementation in TFTPLIB for the download.
        //
        TFTP_REQUEST request;
        NTSTATUS ntStatus;

        request.RemoteFileName = (PUCHAR)p;
        request.ServerIpAddress = RamdiskTFTPAddr;
        request.MemoryAddress = NULL;
        request.MaximumLength = 0;
        request.BytesTransferred = 0xbadf00d;
        request.Operation = TFTP_RRQ;
        request.MemoryType = LoaderXIPRom;
#if defined(REMOTE_BOOT_SECURITY)
        request.SecurityHandle = TftpSecurityHandle;
#endif // defined(REMOTE_BOOT_SECURITY)
        request.ShowProgress = TRUE;
        
        //
        // Print progress message
        //
        ip = (PUCHAR) &RamdiskTFTPAddr;
        FormatString = BlFindMessage( RAMDISK_DOWNLOAD_NETWORK );
        if ( FormatString != NULL ) {
            _stprintf(Buffer, FormatString, ip[0], ip[1], ip[2], ip[3] );
            BlOutputTrailerMsgStr( Buffer );
        }

        //
        // Download the image using TFTP
        //
        DBGPRINT(VERBOSE, ("calling TftpGetPut(%s,0x%x)\n", p, NetServerIpAddress));
        ntStatus = TftpGetPut( &request );
        DBGPRINT(VERBOSE, ("status from TftpGetPut 0x%x\n", ntStatus));

        BlUsableBase = oldBase;
        BlUsableLimit = oldLimit;

        if ( !NT_SUCCESS(ntStatus) ) {

            if ( request.MemoryAddress != NULL ) {
                BlFreeDescriptor( (ULONG)((ULONG_PTR)request.MemoryAddress & ~KSEG0_BASE) >> PAGE_SHIFT);
            }

            ArcClose( RamdiskDeviceId );

            if ( ntStatus == STATUS_INSUFFICIENT_RESOURCES ) {
                return ENOMEM;
            }
            return EROFS;
        }

        RamdiskBasePage = (ULONG)((ULONG_PTR)request.MemoryAddress & ~KSEG0_BASE) >> PAGE_SHIFT;

        RamdiskFileSize = request.MaximumLength;
        RamdiskFileSizeInPages = (ULONG) BYTES_TO_PAGES(RamdiskFileSize);
        if ( (RamdiskImageLength == 0) ||
             (RamdiskImageLength > (RamdiskFileSize - RamdiskImageOffset)) ) {
            RamdiskImageLength = RamdiskFileSize - RamdiskImageOffset;
        }

#ifndef EFI // multicast ramdisk download only supported on non-EFI machines for now

    } else if ( RamdiskDeviceId == NET_DEVICE_ID && RamdiskMTFTPAddr != 0) {

        LONGLONG FileOffset = 0;
        LONGLONG VirtualAddressOfOffset;
        ULONG DownloadSize;
        USHORT ClientPort;
        USHORT ServerPort;
        ULONG iSession = 0;
        
        //
        // Network device and using multicast download. For multicast
        // downloads we will use the MTFTP implementation in the ROM.
        // A single MTFTP transfer is limited to 16-bit block counts.
        // This translates to ~32MB for 512 block sizes and ~90MB for
        // 1468 block sizes. In order to support larger files, we will 
        // use multiple MTFTP sessions to bring the file down in chunks.
        // The MTFTP server will need to understand the chunking semantics. 
        //

        //
        // Print progress message
        //
        ip = (PUCHAR) &RamdiskMTFTPAddr;
        FormatString = BlFindMessage( RAMDISK_DOWNLOAD_NETWORK_MCAST );
        if ( FormatString != NULL ) {
            _stprintf(Buffer, FormatString, ip[0], ip[1], ip[2], ip[3], SWAP_WORD( RamdiskMTFTPSPort ) );
            BlOutputTrailerMsgStr( Buffer );
        }

        //
        // Allocate the memory for the entire RAMDisk
        //
        RamdiskFileSize = RamdiskMTFTPFileSize;
        RamdiskFileSizeInPages = (ULONG)BYTES_TO_PAGES(RamdiskFileSize);
        if ( (RamdiskImageLength == 0) ||
             (RamdiskImageLength > (RamdiskFileSize - RamdiskImageOffset)) ) {
            RamdiskImageLength = RamdiskFileSize - RamdiskImageOffset;
        }

        DBGPRINT(INFO, ("Downloading Ramdisk using MTFTP. File Size=0x%I64x Chunk Size=0x%I64x\n", RamdiskFileSize, RamdiskMTFTPChunkSize ));

        status = BlAllocateAlignedDescriptor(
                    LoaderXIPRom,
                    0,
                    RamdiskFileSizeInPages,
                    0,
                    &RamdiskBasePage
                    );

        BlUsableBase = oldBase;
        BlUsableLimit = oldLimit;

        if (status != ESUCCESS) {
            DBGPRINT(ERR, ("BlAllocateAlignedDescriptor(%d pages) failed: %d\n", RamdiskFileSizeInPages, status));
            ArcClose( RamdiskDeviceId );
            return status;
        }
    
        DBGPRINT(VERBOSE, ("Allocated %d pages at page %x for RAM disk\n", RamdiskFileSizeInPages, RamdiskBasePage ));

        //
        // Download the ramdisk file using MTFTP
        //

        if ( RamdiskMTFTPChunkSize == 0 ) {
            RamdiskMTFTPChunkSize = RamdiskMTFTPFileSize;
        }

        // starting client and server port (in Intel byte order to 
        // allow increment operators to work )
        ClientPort = SWAP_WORD( RamdiskMTFTPCPort );
        ServerPort = SWAP_WORD( RamdiskMTFTPSPort );

        while ( FileOffset < RamdiskFileSize ) {

            //
            // Call the ROM implementation to download a single chunk
            //
            VirtualAddressOfOffset = ((LONGLONG)KSEG0_BASE | (RamdiskBasePage << PAGE_SHIFT)) + FileOffset;

            ip = (PUCHAR)&RamdiskMTFTPAddr;
            DBGPRINT(INFO, ("MTFTP Session %d: %s from %u.%u.%u.%u sport=%d cport=%d offset=0x%I64x\n", 
                            iSession, p, 
                            ip[0], ip[1], ip[2], ip[3], ClientPort, ServerPort,
                            VirtualAddressOfOffset ));

            //
            // the high 32 bits are going to be lost when calling RomMtftpReadFile.
            // find out now, if this is happening
            //
            ASSERT( (VirtualAddressOfOffset >> 32) == 0 );
            status = RomMtftpReadFile ( (PUCHAR)p,
                                        (PVOID)(ULONG)VirtualAddressOfOffset,
                                        (ULONG)RamdiskMTFTPChunkSize,
                                        RamdiskTFTPAddr,
                                        RamdiskMTFTPAddr,
                                        SWAP_WORD( ClientPort ),
                                        SWAP_WORD( ServerPort ),
                                        RamdiskMTFTPTimeout,
                                        RamdiskMTFTPDelay,
                                        &DownloadSize );
            if ( status != ESUCCESS ) {
                DBGPRINT(ERR, ("RomMtftpReadFile failed %d\n", status ));
                BlFreeDescriptor( RamdiskBasePage );
                ArcClose( RamdiskDeviceId );
                return status;
            }

#if 1 || INTEL_MTFTP_SERVER_TEST
            p[strlen(p) - 1]++;
            RamdiskMTFTPAddr += 0x01000000;
#else
            ClientPort++;            
            ServerPort++;            
#endif
            FileOffset += DownloadSize;
            iSession++;

            // update progress bar
            currentProgressPercent = (ULONG)(((LONGLONG)FileOffset * 100) / RamdiskFileSize);
            if ( ForceDisplayFirstTime || (currentProgressPercent != lastProgressPercent) ) {
                BlUpdateProgressBar( currentProgressPercent );
                ForceDisplayFirstTime = FALSE;
            }
            lastProgressPercent = currentProgressPercent;

        }

        DBGPRINT(INFO, ("MTFTP Download complete. 0x%I64x bytes transferred using %d sessions\n", RamdiskFileSize, iSession));

#endif

    } else {
    
        //
        // Open the RAM disk image.
        //
    
        status = BlOpen( RamdiskDeviceId, p, ArcOpenReadOnly, &RamdiskFileId );
        if (status != ESUCCESS) {
            DBGPRINT(ERR, ("BlOpen(%s) failed: %d\n", p, status));
            ArcClose( RamdiskDeviceId );
            return status;
        }
    
        //
        // Get the size of the RAM disk image.
        //
    
        status = BlGetFileInformation( RamdiskFileId, &fileInformation );
        if (status != ESUCCESS) {
            DBGPRINT(ERR, ("BlGetFileInformation(%s) failed: %d\n", p, status));
            BlClose( RamdiskFileId );
            ArcClose( RamdiskDeviceId );
            return status;
        }
    
        RamdiskFileSize = fileInformation.EndingAddress.QuadPart;
        RamdiskFileSizeInPages = (ULONG) BYTES_TO_PAGES(RamdiskFileSize);
        if ( (RamdiskImageLength == 0) ||
             (RamdiskImageLength > (RamdiskFileSize - RamdiskImageOffset)) ) {
            RamdiskImageLength = RamdiskFileSize - RamdiskImageOffset;
        }
    
        //
        // Allocate pages to hold the RAM disk image.
        //
    
        status = BlAllocateAlignedDescriptor(
                    LoaderXIPRom,
                    0,
                    RamdiskFileSizeInPages,
                    0,
                    &RamdiskBasePage
                    );

        BlUsableBase = oldBase;
        BlUsableLimit = oldLimit;

        if (status != ESUCCESS) {
            DBGPRINT(ERR, ("BlAllocateAlignedDescriptor(%d pages) failed: %d\n", RamdiskFileSizeInPages, status));
            BlClose( RamdiskFileId );
            ArcClose( RamdiskDeviceId );
            return status;
        }
    
        DBGPRINT(VERBOSE, ("Allocated %d pages at page %x for RAM disk\n", RamdiskFileSizeInPages, RamdiskBasePage ));
    
        //
        // Read the RAM disk image into memory.
        //

#define MAX_DISK_READ (1024 * 1024)

        offset.QuadPart = 0;
        remainingLength = RamdiskFileSize;

        while ( offset.QuadPart < RamdiskFileSize ) {
    
            LONGLONG availableLength;
            ULONG readLength;
            PVOID va;
            ULONG count;
    
            va = MapRamdisk( offset.QuadPart, &availableLength );
    
            if ( remainingLength > availableLength ) {
                readLength = (ULONG)availableLength;
            } else {
                readLength = (ULONG)remainingLength;
            }
            if ( readLength > MAX_DISK_READ ) {
                readLength = MAX_DISK_READ;
            }
    
            status = BlSeek( RamdiskFileId, &offset, SeekAbsolute );
            if ( status != ESUCCESS ) {
                DBGPRINT(ERR, ("Unable to seek RAM disk image: %d\n", status));
                BlClose( RamdiskFileId );
                ArcClose( RamdiskDeviceId );
                return status;
            }
    
            status = BlRead( RamdiskFileId, va, readLength, &count );
            if ( (status != ESUCCESS) || (count != readLength) ) {
                DBGPRINT(ERR, ( "Unable to read RAM disk image: status %d count %x (wanted %x)\n", status, count, readLength) );
                BlClose( RamdiskFileId );
                ArcClose( RamdiskDeviceId );
                return status;
            }

            offset.QuadPart += readLength;
            remainingLength -= readLength;

            // update progress bar
            currentProgressPercent = (ULONG)(((LONGLONG)offset.QuadPart * 100) / RamdiskFileSize);
            if ( ForceDisplayFirstTime || (currentProgressPercent != lastProgressPercent) ) {
                BlUpdateProgressBar( currentProgressPercent );
                ForceDisplayFirstTime = FALSE;
            }
            lastProgressPercent = currentProgressPercent;
        }
        DBGPRINT(VERBOSE, ( "Done reading ramdisk\n" ) );
    
        BlClose( RamdiskFileId );
        RamdiskFileId = BL_INVALID_FILE_ID;
    }

    ArcClose( RamdiskDeviceId );

    return status;

} // RamdiskReadImage

ARC_STATUS
RamdiskInitializeFromPath(
    )
/*++

Routine Description:

    This function will load a ramdisk image from the network
    or another ARC boot device.

Arguments:

    none

Return Value:

    status    

--*/
{
    ARC_STATUS status;

    ASSERT( RamdiskPath );

    DBGPRINT(VERBOSE, ("RamdiskInitializeFromPath(%s)\n", RamdiskPath));

    status = RamdiskReadImage( RamdiskPath );

    if ( status == ESUCCESS ) {
    
        DBGPRINT(VERBOSE, ("Ramdisk is active\n") );
        RamdiskActive = TRUE;
    }

    return status;

} // RamdiskInitializeFromPath


ARC_STATUS
RamdiskClose(
    IN ULONG FileId
    )

/*++

Routine Description:

    Closes the specified device

Arguments:

    FileId - Supplies file id of the device to be closed

Return Value:

    ESUCCESS - Device closed successfully

    !ESUCCESS - Device was not closed.

--*/

{
    if (BlFileTable[FileId].Flags.Open == 0) {
#if DBG
        BlPrint(TEXT("ERROR - Unopened fileid %lx closed\r\n"),FileId);
#endif
    }
    BlFileTable[FileId].Flags.Open = 0;

    return(ESUCCESS);
}


ARC_STATUS
RamdiskOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Opens a RAM disk for raw sector access.

Arguments:

    OpenPath - Supplies a pointer to the name of the RAM disk.

    OpenMode - Supplies the mode of the open

    FileId - Supplies a pointer to a variable that specifies the file
             table entry that is filled in if the open is successful.

Return Value:

    ESUCCESS is returned if the open operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ULONG Key;
    PDRIVE_CONTEXT Context;

    UNREFERENCED_PARAMETER( OpenMode );

    //BlPrint(TEXT("RamdiskOpen entered\r\n"));

    if ( !RamdiskActive ) {
        //BlPrint(TEXT("RamdiskOpen: not active\r\n"));
        return EBADF;
    }

    if(FwGetPathMnemonicKey(OpenPath,"ramdisk",&Key)) {
        DBGPRINT(VERBOSE, ("RamdiskOpen: not a ramdisk path\n"));
        return EBADF;
    }

    if ( Key != 0 ) {
        DBGPRINT(ERR, ("RamdiskOpen: not ramdisk 0\n"));
        return EBADF;
    }

    //
    // Find an available FileId descriptor to open the device with
    //
    *FileId=2;

    while (BlFileTable[*FileId].Flags.Open != 0) {
        *FileId += 1;
        if(*FileId == BL_FILE_TABLE_SIZE) {
            DBGPRINT(ERR, ("RamdiskOpen: no file table entry available\n"));
            return(ENOENT);
        }
    }

    //
    // We found an entry we can use, so mark it as open.
    //
    BlFileTable[*FileId].Flags.Open = 1;
    BlFileTable[*FileId].DeviceEntryTable = &RamdiskEntryTable;


    Context = &(BlFileTable[*FileId].u.DriveContext);
    Context->Drive = (UCHAR)Key;
    Context->xInt13 = TRUE;

    DBGPRINT(VERBOSE, ("RamdiskOpen: exit success\n"));

    return(ESUCCESS);
}


ARC_STATUS
RamdiskSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    Changes the current offset of the file specified by FileId

Arguments:

    FileId - specifies the file on which the current offset is to
             be changed.

    Offset - New offset into file.

    SeekMode - Either SeekAbsolute or SeekRelative
               SeekEndRelative is not supported

Return Value:

    ESUCCESS - Operation completed succesfully

    EBADF - Operation did not complete successfully.

--*/

{
    switch (SeekMode) {
        case SeekAbsolute:
            BlFileTable[FileId].Position = *Offset;
            break;
        case SeekRelative:
            BlFileTable[FileId].Position.QuadPart += Offset->QuadPart;
            break;
        default:
#if DBG
            BlPrint(TEXT("SeekMode %lx not supported\r\n"),SeekMode);
#endif
            return(EACCES);

    }
    return(ESUCCESS);

}

ARC_STATUS
RamdiskWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Writes sectors directly to an open RAM disk.

Arguments:

    FileId - Supplies the file to write to

    Buffer - Supplies buffer with data to write

    Length - Supplies number of bytes to write

    Count - Returns actual bytes written

Return Value:

    ESUCCESS - write completed successfully

    !ESUCCESS - write failed

--*/

{
    PUCHAR buffer;
    LONGLONG offset;
    ULONG remainingLength;
    LONGLONG availableLength;
    ULONG bytesWritten;
    ULONG bytesThisPage;
    PVOID va;

    DBGPRINT(ERR, ("RamdiskWrite entered\n"));
    //DbgBreakPoint();

    buffer = Buffer;
    offset = BlFileTable[FileId].Position.QuadPart;

    remainingLength = Length;
    if ( offset >= RamdiskImageLength ) {
        return EINVAL;
    }
    if ( remainingLength > (RamdiskImageLength - offset) ) {
        remainingLength = (ULONG)(RamdiskImageLength - offset);
    }

    bytesWritten = 0;

    while ( remainingLength != 0 ) {

        va = MapRamdisk( RamdiskImageOffset + offset, &availableLength );

        bytesThisPage = remainingLength;
        if ( remainingLength > availableLength ) {
            bytesThisPage = (ULONG)availableLength;
        }

        memcpy( va, buffer, bytesThisPage );

        offset += bytesThisPage;
        buffer += bytesThisPage;
        remainingLength -= bytesThisPage;
        bytesWritten += bytesThisPage;
    }

    BlFileTable[FileId].Position.QuadPart += bytesWritten;
    *Count = bytesWritten;

    return ESUCCESS;
}


ARC_STATUS
RamdiskRead(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Reads sectors directly from an open RAM disk.

Arguments:

    FileId - Supplies the file to read from

    Buffer - Supplies buffer to read into

    Length - Supplies number of bytes to read

    Count - Returns actual bytes read

Return Value:

    ESUCCESS - read completed successfully

    !ESUCCESS - read failed

--*/

{
    PUCHAR buffer;
    LONGLONG offset;
    ULONG remainingLength;
    LONGLONG availableLength;
    ULONG bytesRead;
    ULONG bytesThisPage;
    PVOID va;

    buffer = Buffer;
    offset = BlFileTable[FileId].Position.QuadPart;
    DBGPRINT(VERBOSE, ( "RamdiskRead: offset %x, length %x, buffer %p\n", (ULONG)offset, Length, buffer ));

    remainingLength = Length;
    if ( offset >= RamdiskImageLength ) {
        DBGPRINT(ERR, ( "RamdiskRead: read beyond EOF\n" ) );
        return EINVAL;
    }
    if ( remainingLength > (RamdiskImageLength - offset) ) {
        remainingLength = (ULONG)(RamdiskImageLength - offset);
    }

    bytesRead = 0;

    while ( remainingLength != 0 ) {

        va = MapRamdisk( RamdiskImageOffset + offset, &availableLength );
        DBGPRINT(VERBOSE, ( "Mapped offset %x, va %p, availableLength %x\n", (ULONG)offset, va, availableLength ) );

        bytesThisPage = remainingLength;
        if ( remainingLength > availableLength ) {
            bytesThisPage = (ULONG)availableLength;
        }

        memcpy( buffer, va, bytesThisPage );

        offset += bytesThisPage;
        buffer += bytesThisPage;
        remainingLength -= bytesThisPage;
        bytesRead += bytesThisPage;
    }

    BlFileTable[FileId].Position.QuadPart += bytesRead;
    *Count = bytesRead;

    return ESUCCESS;
}


ARC_STATUS
RamdiskGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION Finfo
    )
/*++

Routine Description:

    Returns file information about a RAMDISK file.

Arguments:

    FileId - id of the file

    Finfo - file information structure to be filled in

Return Value:

    ESUCCESS - write completed successfully

    !ESUCCESS - write failed

--*/
{
    RtlZeroMemory(Finfo, sizeof(FILE_INFORMATION));

    Finfo->EndingAddress.QuadPart = RamdiskImageLength;
    Finfo->CurrentPosition.QuadPart = BlFileTable[FileId].Position.QuadPart;
    Finfo->Type = DiskPeripheral;

    return ESUCCESS;
}

ARC_STATUS
RamdiskMount(
    IN CHAR * FIRMWARE_PTR MountPath,
    IN MOUNT_OPERATION Operation
    )
{
    UNREFERENCED_PARAMETER( MountPath );
    UNREFERENCED_PARAMETER( Operation );

    DBGPRINT(VERBOSE, ( "RamdiskMount called\n" ));
    return EINVAL;
}

ARC_STATUS
RamdiskReadStatus(
    IN ULONG FileId
    )
{
    UNREFERENCED_PARAMETER( FileId );

    DBGPRINT(VERBOSE, (  "RamdiskReadStatus called\n" ) );
    return EINVAL;
}

ARC_STATUS
RamdiskSetFileInfo (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    )
{
    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( AttributeFlags );
    UNREFERENCED_PARAMETER( AttributeMask );

    DBGPRINT(VERBOSE, (  "RamdiskSetFileInfo called\n" ));
    return EINVAL;
}

ARC_STATUS
RamdiskRename (
    IN ULONG FileId,
    IN CHAR * FIRMWARE_PTR NewName
    )
{
    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( NewName );

    DBGPRINT(VERBOSE, (  "RamdiskRename called\n" ));
    return EINVAL;
}

ARC_STATUS
RamdiskGetDirectoryEntry (
    IN ULONG FileId,
    OUT PDIRECTORY_ENTRY Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    )
{
    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( Count );

    DBGPRINT(VERBOSE, (  "RamdiskGetDirectoryEntry called\n" ));
    return EINVAL;
}

PVOID
MapRamdisk (
    LONGLONG Offset,
    PLONGLONG AvailableLength
    )
{
    LONGLONG VirtualAddressOfOffset;

    VirtualAddressOfOffset = ((LONGLONG)(KSEG0_BASE | (RamdiskBasePage << PAGE_SHIFT))) + Offset;
    *AvailableLength = RamdiskFileSize - Offset;

#if defined(_X86_)
    //
    // the high 32 bits of physicalAddressOfOffset are 
    // going to be lost when returning the address as a pvoid.
    // find out if this is happening now.
    //
    ASSERT( (VirtualAddressOfOffset >> 32) == 0 );
    return (PVOID)(ULONG)VirtualAddressOfOffset;
#else
    return (PVOID)VirtualAddressOfOffset;
#endif
}


PCHAR
RamdiskGetOptionValue(
    IN PCHAR LoadOptions,
    IN PCHAR OptionName
)
/*++

Routine Description:

    Parse the load options string returning a value of one of the
    options.

    Format supported: /OPTIONNAME=VALUE

    Note there is no space before or after the '='.
    Value is terminated with a '\r','\n',' ','/', or '\t'

Arguments:

    LoadOptions - Loader options from boot.ini. Must be all caps.

    OptionName - Name of the option to find.

Return Value:

    Pointer to a value string that has been allocated with
    BlAllocateHeap or NULL if the option has not found.

--*/
{
    PCHAR retValue = NULL;
    PCHAR value;
    PCHAR p;
    ULONG n;

    ASSERT( LoadOptions );
    ASSERT( OptionName );

    if ( (p = strstr( LoadOptions, OptionName )) != 0 ) {

        value = strchr( p , '=' );
        if (value) {

            value++;

            for (p = value;  *p;  p++) {
                if (*p == ' ') break;
                if (*p == '/') break;
                if (*p == '\n') break;
                if (*p == '\r') break;
                if (*p == '\t') break;
            }

            n = (ULONG)(p - value);
            retValue = (PCHAR)BlAllocateHeap( n+1 );
            if ( retValue ) {
                strncpy( retValue, value, n );
            }
        }
    }

    return retValue;
}


ULONG
RamdiskParseIPAddr(
    IN PCHAR psz
)
/*++

Routine Description:

    parses an ip address from a string
    
    Arguments:  [psz]     - Ip address string

    Returns:    ipaddress (in network byte order) or 0.

--*/
{
    ULONG nAddr = 0;
    ULONG nDigit = 0;
    ULONG cDigits = 0;


    for (; (psz!= NULL && *psz != 0); psz++) {
        if (*psz >= '0' && *psz <= '9') {
            nDigit = nDigit * 10 + *psz - '0';
            if ( nDigit > 255 ) {
                return 0;
            }
        }
        else if (*psz == '.') {
            nAddr = (nAddr << 8) | nDigit;
            nDigit = 0;
            cDigits++;
        } else {
            break;
        }
    }

    if (cDigits != 3) { 
        return 0;
    }

    nAddr = (nAddr << 8) | nDigit;
    return SWAP_DWORD( nAddr );
}


BOOLEAN
RamdiskHexStringToDword(
    IN PCHAR psz, 
    OUT PULONG RetValue,
    IN USHORT cDigits, 
    IN CHAR chDelim
)
/*++

Routine Description:

    scan psz for a number of hex digits (at most 8); update psz
    return value in Value; check for chDelim;

    Arguments:  [psz]    - the hex string to convert
                [Value]   - the returned value
                [cDigits] - count of digits

    Returns:    TRUE for success

--*/
{
    USHORT Count;
    ULONG Value;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, psz++)
    {
        if (*psz >= '0' && *psz <= '9') {
            Value = (Value << 4) + *psz - '0';
        } else if (*psz >= 'A' && *psz <= 'F') {
            Value = (Value << 4) + *psz - 'A' + 10;
        } else if (*psz >= 'a' && *psz <= 'f') {
            Value = (Value << 4) + *psz - 'a' + 10;
        } else {
            return(FALSE);
        }
    }

    *RetValue = Value;

    if (chDelim != 0) {
        return *psz++ == chDelim;
    } else {
        return TRUE;
    }
}


BOOLEAN
RamdiskUUIDFromString(
    IN PCHAR psz, 
    OUT LPGUID pguid
)
/**

Routine Description:

    Parse UUID such as 00000000-0000-0000-0000-000000000000

Arguments:  
    [psz]  - Supplies the UUID string to convert
    [pguid] - Returns the GUID.

Returns:    TRUE if successful

**/
{
    ULONG dw;

    if (!RamdiskHexStringToDword(psz, &pguid->Data1, sizeof(ULONG)*2, '-')) {
        return FALSE;
    }            
    psz += sizeof(ULONG)*2 + 1;

    if (!RamdiskHexStringToDword(psz, &dw, sizeof(USHORT)*2, '-')) {
        return FALSE;
    }            
    psz += sizeof(USHORT)*2 + 1;

    pguid->Data2 = (USHORT)dw;

    if (!RamdiskHexStringToDword(psz, &dw, sizeof(USHORT)*2, '-')) {
        return FALSE;
    }            
    psz += sizeof(USHORT)*2 + 1;

    pguid->Data3 = (USHORT)dw;

    if (!RamdiskHexStringToDword(psz, &dw, sizeof(UCHAR)*2, 0)) {
        return FALSE;
    }            
    psz += sizeof(UCHAR)*2;

    pguid->Data4[0] = (UCHAR)dw;
    if (!RamdiskHexStringToDword(psz, &dw, sizeof(UCHAR)*2, '-')) {
        return FALSE;
    }            
    psz += sizeof(UCHAR)*2+1;

    pguid->Data4[1] = (UCHAR)dw;

    if (!RamdiskHexStringToDword(psz, &dw, sizeof(UCHAR)*2, 0)) {
        return FALSE;
    }            
    psz += sizeof(UCHAR)*2;

    pguid->Data4[2] = (UCHAR)dw;

    if (!RamdiskHexStringToDword(psz, &dw, sizeof(UCHAR)*2, 0)) {
        return FALSE;
    }            
    psz += sizeof(UCHAR)*2;

    pguid->Data4[3] = (UCHAR)dw;

    if (!RamdiskHexStringToDword(psz, &dw, sizeof(UCHAR)*2, 0)) {
        return FALSE;
    }            
    psz += sizeof(UCHAR)*2;

    pguid->Data4[4] = (UCHAR)dw;

    if (!RamdiskHexStringToDword(psz, &dw, sizeof(UCHAR)*2, 0)) {
        return FALSE;
    }            
    psz += sizeof(UCHAR)*2;

    pguid->Data4[5] = (UCHAR)dw;

    if (!RamdiskHexStringToDword(psz, &dw, sizeof(UCHAR)*2, 0)) {
        return FALSE;
    }            
    psz += sizeof(UCHAR)*2;

    pguid->Data4[6] = (UCHAR)dw;
    if (!RamdiskHexStringToDword(psz, &dw, sizeof(UCHAR)*2, 0)) {
        return FALSE;
    }            
    psz += sizeof(UCHAR)*2;

    pguid->Data4[7] = (UCHAR)dw;

    return TRUE;
}


BOOLEAN
RamdiskGUIDFromString(
    IN PCHAR psz, 
    OUT LPGUID pguid
)
/**

Routine Description:

    Parse GUID such as {00000000-0000-0000-0000-000000000000}

Arguments:  
    [psz]   - Supplies the UUID string to convert
    [pguid] - Returns the GUID.

Returns:    TRUE if successful

**/
{

    if (*psz == '{' ) {
        psz++;
    }
    
    if (RamdiskUUIDFromString(psz, pguid) != TRUE) {
        return FALSE;
    }
    
    psz += 36;

    if (*psz == '}' ) {
        psz++;
    }
    
    if (*psz != '\0') {
       return FALSE;
    }

    return TRUE;
}


ARC_STATUS 
RamdiskParseOptions (
    IN PCHAR LoadOptions
)
/*++

Routine Description:

    Parses all the Ramdisk params from the boot.ini option string.

Arguments:

    LoadOptions - Loader options from boot.ini. Must be all caps.

    /RDPATH     - Indicates that the boot ramdisk should be downloaded
                  from the specified path. This option takes
                  precedence over RDBUILD.

                  Example: /RDPATH=net(0)\boot\ramdisk.dat

    /RDMTFTPADDR  - Specifies the Multicast Address where the ramdisk
                    image should be downloaded from. If not specified
                    a unicast download from the PXE boot server will
                    be performed.

    /RDMTFTPCPORT - Specifies the Multicast Client port to use.

    /RDMTFTPSPORT - Specifies the Multicast Server port to use.

    /RDMTFTPDELAY - Specifies the delay before starting a new MTFTP session.

    /RDMTFTPTIMEOUT - Specifies the timeout before restarting a MTFTP session.

    /RDIMAGEOFFSET - Specifies the offset into the downloaded file at which the
                     actual disk image begins. If not specified, 0 is used.

    /RDIMAGELENGTH - Specifies the length of the actual disk image. If not
                     specified, the size of the downloaded file minus the offset
                     to the image (RDIMAGEOFFSET) is used.

    /RDFILESIZE   - Specifies the size of the file to be downloaded.

    /RDCHUNKSIZE  - Specifies the size of each file chunck when more than
                    one MTFTP session is required to download a large file. If the
                    file is to be downloaded with one chunk this option is omitted
                    or is set to zero.

                    This is used to workaround a size limitation in the MTFTP 
                    protcol. MTFTP currently has 16-bit block counts, therefore 
                    when using 512 byte blocks we are limited to ~32MB files.

                    Example 1: assume we want to download a 85MB file 
                    using 512 byte TFTP block sizes.

                    /RDMTFTPADDR=224.1.1.1 /RDMTFTPCPORT=100 /RDMTFTPSPORT=200 
                    /RDCHUNKSIZE=31457280 /RDFILESIZE=89128960

                    1st MTFTP session on CPort=100, SPort=200 Size=31457280 (30MB)
                    2nd MTFTP session on CPort=101, SPort=201 Size=31457280 (30MB)
                    3rd MTFTP session on CPort=102, SPort=202 Size=26214400 (25MB)

                    Example 2: assume we want to download a 300MB file 
                    using 1468 byte TFTP block sizes.

                    /RDMTFTPADDR=224.1.1.2 /RDMTFTPCPORT=100 /RDMTFTPSPORT=200 
                    /RDCHUNKSIZE=94371840 /RDFILESIZE=314572800

                    1st MTFTP session on CPort=100, SPort=200 Size=94371840 (90MB)
                    2nd MTFTP session on CPort=101, SPort=201 Size=94371840 (90MB)
                    3rd MTFTP session on CPort=102, SPort=202 Size=94371840 (90MB)
                    4th MTFTP session on CPort=103, SPort=203 Size=31457280 (30MB)
                  

    /RDBUILD    - Indicates that the boot ramdisk should be built
                  from the build server. This is ignored if the RDPATH
                  option is set.

                  Example: /RDBUILD

    /RDGUID     - Specifies the GUID of the configuration to be built
                  by the build server.

                  Example: /RDGUID={54C7D140-09EF-11D1-B25A-F5FE627ED95E}

    /RDDISCOVERY - Indicates what address discovery packets should be sent to.
                   If this option doesn't exist, then we will not do discovery
                   and default to using the list of servers in RDSERVERS.  If 
                   Examples:

                       /RDDISCOVERY=255.255.255.255   
                            This will send a broadcast packet to the local 
                            network that the machine is connected to.

                       /RDDISCOVERY=224.100.100.100
                            This will send a multicast packet to the 
                            address specified.

    /RDSERVERS      Specifies a list of Build Servers to send build
                    requests to.  This will override any setting that
                    RDDISCOVERY has set.  A maximum of 10 servers are supported.

                    Example: /RDSERVERS={10.0.0.3, 10.0.0.4}

    /RDSERVERPORT   Specifies the default port to send build packets to.
                    If this is not set, it defaults to 4012.

                    Example: /RDSERVERPORT=5623                    
                    
    /RDTIMEOUT      Specifies the timeout period to wait for a response in 
                    seconds. Default is 4 secs.

                    Example: /RDTIMEOUT=10                    

    /RDRETRY        Specifies the number of times to retry finding a build
                    server. Default is 5 times.

                    Example: /RDRETRY=5


Return Value:

    ESUCCESS - read completed successfully

    !ESUCCESS - read failed

--*/
{
    PCHAR value;
    PUCHAR p;
    USHORT i;


    if ( LoadOptions == NULL ) {
        return ESUCCESS;
    }

    //
    // Get RDPATH and its associated options
    //
    RamdiskPath = RamdiskGetOptionValue( LoadOptions, "RDPATH" );
    if (RamdiskPath) {

        value = RamdiskGetOptionValue( LoadOptions, "RDIMAGEOFFSET" );
        if (value) RamdiskImageOffset = atoi( value );
        value = RamdiskGetOptionValue( LoadOptions, "RDIMAGELENGTH" );
        if (value) RamdiskImageLength = _atoi64( value );

        //
        // By Default the PXE Boot Server is the TFTP address
        //
        RamdiskTFTPAddr = NetServerIpAddress;

        //
        // Get the MTFTP Address used to download the image.
        // if not specified, the image will be downloaded
        // from the same place as ntldr (i.e. the PXE
        // boot server).
        //
        value = RamdiskGetOptionValue( LoadOptions, "RDMTFTPADDR" );
        if ( value ) {
            RamdiskMTFTPAddr = RamdiskParseIPAddr( value );
 
            value = RamdiskGetOptionValue( LoadOptions, "RDMTFTPCPORT" );
            if ( value ) RamdiskMTFTPCPort = SWAP_WORD( (USHORT)atoi( value ) );
            value = RamdiskGetOptionValue( LoadOptions, "RDMTFTPSPORT" );
            if (value) RamdiskMTFTPSPort = SWAP_WORD( (USHORT)atoi( value ) );
            value = RamdiskGetOptionValue( LoadOptions, "RDMTFTPDELAY" );
            if (value) RamdiskMTFTPDelay = (USHORT)atoi( value );
            value = RamdiskGetOptionValue( LoadOptions, "RDMTFTPTIMEOUT" );
            if (value) RamdiskMTFTPTimeout = (USHORT)atoi( value );
            value = RamdiskGetOptionValue( LoadOptions, "RDFILESIZE" );
            if (value) RamdiskMTFTPFileSize = _atoi64( value );
            value = RamdiskGetOptionValue( LoadOptions, "RDCHUNKSIZE" );
            if (value) RamdiskMTFTPChunkSize = _atoi64( value );

            
            // Validate options
            if ( RamdiskMTFTPAddr == 0 ||
                 RamdiskMTFTPCPort == 0 ||
                 RamdiskMTFTPSPort == 0 || 
                 RamdiskMTFTPDelay == 0 || 
                 RamdiskMTFTPTimeout == 0 ||
                 RamdiskMTFTPFileSize == 0 ||
                 RamdiskMTFTPChunkSize > RamdiskMTFTPFileSize ) {
                return EINVAL;
            }
            
        }

        if (DBGLVL(INFO)) {
            DbgPrint( "RAMDISK options:\n");
            DbgPrint( "RDPATH = %s\n", RamdiskPath);
            p = (PUCHAR) &RamdiskMTFTPAddr;
            DbgPrint( "RDMTFTPADDR = %u.%u.%u.%u\n", p[0], p[1], p[2], p[3]);
            DbgPrint( "RDMTFTPCPORT = %d\n", SWAP_WORD( RamdiskMTFTPCPort ));
            DbgPrint( "RDMTFTPSPORT = %d\n", SWAP_WORD( RamdiskMTFTPSPort ));
            DbgPrint( "RDMTFTPDELAY = %d\n", RamdiskMTFTPDelay);
            DbgPrint( "RDMTFTPTIMEOUT = %d\n", RamdiskMTFTPTimeout);
            DbgPrint( "RDFILESIZE = 0x%0I64x bytes\n", RamdiskMTFTPFileSize );
            DbgPrint( "RDCHUNKSIZE = 0x%0I64x bytes\n", RamdiskMTFTPChunkSize );
            DbgPrint( "RDIMAGEOFFSET = 0x%x bytes\n", RamdiskImageOffset );
            DbgPrint( "RDIMAGELENGTH = 0x%0I64x bytes\n", RamdiskImageLength );
        }
        
        // we are done if RDPATH was specified.
        return ESUCCESS;
    }

    //
    // Check if RDBUILD exists
    //
    if ( strstr( LoadOptions, "RDBUILD" ) ) {

        RamdiskBuild = TRUE;

        value = RamdiskGetOptionValue( LoadOptions, "RDGUID" );
        if ( value == NULL ||
             RamdiskGUIDFromString( value, &RamdiskGuid ) == FALSE ) {
             return EINVAL;
        }

        value = RamdiskGetOptionValue( LoadOptions, "RDDISCOVERY" );
        if ( value ) RamdiskDiscovery = RamdiskParseIPAddr( value );

        value = RamdiskGetOptionValue(LoadOptions, "RDSERVERPORT");
        if (value) RamdiskBuildPort = SWAP_WORD((USHORT)atoi(value));
        
        value = RamdiskGetOptionValue( LoadOptions, "RDSERVERS" );
        if ( value && *value == '{' ) {
            PCHAR e = strchr( value, '}' );

            if ( e && (ULONG)(e - value) > 7 ) { // at least seven characters for X.X.X.X
            
                while ( value && value < e && RamdiskServerCount < RAMDISK_MAX_SERVERS) {
                    value++;
                    RamdiskServers[RamdiskServerCount] = RamdiskParseIPAddr( value );
                    RamdiskServerCount++;
                    value = strchr(value, ',' );
                }
            }
        }

        value = RamdiskGetOptionValue( LoadOptions, "RDTIMEOUT" );
        if (value) RamdiskTimeout = (USHORT)atoi( value );
        value = RamdiskGetOptionValue( LoadOptions, "RDRETRY" );
        if (value) RamdiskRetry = (USHORT)atoi( value );

        // Validate options
        if (((RamdiskDiscovery == 0) && (RamdiskServerCount == 0)) ||
            (RamdiskBuildPort == 0) ||
            (RamdiskTimeout == 0) ||
            (RamdiskRetry == 0)) {
            return EINVAL;
        }

        //
        // Print out debug information
        //
        if (DBGLVL(INFO)) {
            DbgPrint("RDBUILD options:\n");
            DbgPrint("RDGUID = {%x-%x-%x-%x%x%x%x%x%x%x%x}\n",
                   RamdiskGuid.Data1, RamdiskGuid.Data2,
                   RamdiskGuid.Data3,
                   RamdiskGuid.Data4[0], RamdiskGuid.Data4[1],
                   RamdiskGuid.Data4[2], RamdiskGuid.Data4[3],
                   RamdiskGuid.Data4[4], RamdiskGuid.Data4[5],
                   RamdiskGuid.Data4[6], RamdiskGuid.Data4[7]);
            p = (PUCHAR) &RamdiskDiscovery;
            DbgPrint("RDDISCOVERY = %u.%u.%u.%u\n", p[0], p[1], p[2], p[3]);
            DbgPrint("RDBUILDPORT = %d\n", RamdiskBuildPort);
            DbgPrint("RDSERVERS = %d\n", RamdiskServerCount);
            for (i = 0; i < RamdiskServerCount; i++) {
                p = (PUCHAR) &RamdiskServers[i];
                DbgPrint("RDSERVER[%d] = %u.%u.%u.%u\n", i, p[0], p[1], p[2], p[3]);
            }
            DbgPrint("RDTIMEOUT = %d\n", RamdiskTimeout);
            DbgPrint("RDRETRY = %d\n", RamdiskRetry);
        }
    }

    return ESUCCESS;
}


#if defined(i386) // RDBUILD is only supported on x86 machines for now

VOID
RamdiskDeviceInfoToString(
    DEVICE_INFO * Device,
    PCHAR DeviceString
    )
/*++

Routine Description:

    This routine generates a string representation of the Device info for 
    debugging purposes.

Arguments:

    Device - Pointer to the device info structure

    DeviceString - a pointer to a buffer that will hold the final string. The buffer
                   must be at least 128 * sizeof(CHAR) bytes.

Return Value:

    NONE.

--*/
{
    const CHAR HexToCharTable[17] = "0123456789ABCDEF";

    if (Device->DeviceType == BMBUILD_DEVICE_TYPE_PCI) {
        sprintf (   DeviceString, 
                    "%d.%d.%d PCI\\VEN_%04X&DEV_%04X&SUBSYS_%04X%04X&REV_%02X&CC_%02X%02X%02X", 
                    BUSDEVFUNC_TO_BUS( Device->info.pci.BusDevFunc ),
                    BUSDEVFUNC_TO_DEVICE( Device->info.pci.BusDevFunc ),
                    BUSDEVFUNC_TO_FUNCTION( Device->info.pci.BusDevFunc ),
                    Device->info.pci.VendorID,
                    Device->info.pci.DeviceID,
                    Device->info.pci.SubVendorID,
                    Device->info.pci.SubDeviceID,
                    Device->info.pci.RevisionID,
                    Device->info.pci.BaseClass,
                    Device->info.pci.SubClass,
                    Device->info.pci.ProgIntf );
    } else if (Device->DeviceType == BMBUILD_DEVICE_TYPE_PCI_BRIDGE ) {
        sprintf (   DeviceString, 
                    "%d.%d.%d PCI\\VEN_%04X&DEV_%04X&REV_%02X&CC_%02X%02X%02X Bridge %d->%d Sub = %d", 
                    BUSDEVFUNC_TO_BUS( Device->info.pci_bridge.BusDevFunc ),
                    BUSDEVFUNC_TO_DEVICE( Device->info.pci_bridge.BusDevFunc ),
                    BUSDEVFUNC_TO_FUNCTION( Device->info.pci_bridge.BusDevFunc ),
                    Device->info.pci_bridge.VendorID,
                    Device->info.pci_bridge.DeviceID,
                    Device->info.pci_bridge.RevisionID,
                    Device->info.pci_bridge.BaseClass,
                    Device->info.pci_bridge.SubClass,
                    Device->info.pci_bridge.ProgIntf,
                    Device->info.pci_bridge.PrimaryBus,
                    Device->info.pci_bridge.SecondaryBus,
                    Device->info.pci_bridge.SubordinateBus );
    
    } else if (Device->DeviceType == BMBUILD_DEVICE_TYPE_PNP) {
        CHAR ProductIDStr[8];
        PUCHAR id = (PUCHAR)&Device->info.pnp.EISADevID;

        ProductIDStr[0] = (id[0] >> 2) + 0x40;
        ProductIDStr[1] = (((id[0] & 0x03) << 3) | (id[1] >> 5)) + 0x40;
        ProductIDStr[2] = (id[1] & 0x1f) + 0x40;
        ProductIDStr[3] = HexToCharTable[id[2] >> 4];
        ProductIDStr[4] = HexToCharTable[id[2] & 0x0F];
        ProductIDStr[5] = HexToCharTable[id[3] >> 4];
        ProductIDStr[6] = HexToCharTable[id[3] & 0x0F];
        ProductIDStr[7] = 0x00;

        sprintf(    DeviceString,
                    "%d %s CC_%02X%02X%02X",
                    Device->info.pnp.CardSelNum,
                    ProductIDStr,
                    Device->info.pnp.BaseClass,
                    Device->info.pnp.SubClass,
                    Device->info.pnp.ProgIntf );
    }
}

VOID
RamdiskWait(
    ULONG WaitTime
    )
/*++

Routine Description:

    This routine will spin a loop so you can wait for the specified time.

Arguments:

    WaitTime - The time to wait in seconds

Return Value:

    NONE.

--*/
{
    ULONG startTime = SysGetRelativeTime();
    while ((SysGetRelativeTime() - startTime) < WaitTime) {
    }
}

VOID
RamdiskPrintBuildProgress(
    ULONG MsgId,
    ULONG BuildServerIpAddress
    )
/*++

Routine Description:

    This routine will look up the passed in message id and display it on the screen
    using the address as arguments.

Arguments:

    MsgId - The Id of the message to display

    BuildServerIpAddress - The ip address to use as agruments to the message

Return Value:

    NONE.

--*/
{    
    PUCHAR address;
    PTCHAR formatString = NULL;
    TCHAR buffer[256];

    //
    // look up format message
    //
    formatString = BlFindMessage(MsgId);

    if (formatString != NULL) {
        
        //
        // print progress message
        //
        address = (PUCHAR) &BuildServerIpAddress;
        _stprintf(buffer, formatString, address[0], address[1], address[2], address[3]);
        BlOutputTrailerMsgStr(buffer);
    }
}

ARC_STATUS
RamdiskBuildDiscover(
    IN BMBUILD_DISCOVER_PACKET * Discover,
    IN ULONG DiscoverLengthMax,
    OUT ULONG * DiscoverLength
    )
/*++

Routine Description:

    This routine will build a discover packet based on the Ramdisk parameters in the
    boot.ini.

Arguments:

    Discover - The buffer to fill in with data

    DiscoverLengthMax - The maximum size the discovery packet could be

    DiscoverLength - The final size of the discovery packet

Return Value:

    ESUCCESS - If the packet was filled in correctly.

    EINVAL - If the packet couldn't be filled in correctly

--*/
{
    ULONG GuidLength;
    PUCHAR Guid;

    ASSERT(Discover);
    ASSERT(DiscoverLength);

    if (DiscoverLengthMax < sizeof(BMBUILD_DISCOVER_PACKET)) {
        return EINVAL;
    }
    
    RtlZeroMemory(Discover, DiscoverLengthMax);
    
    //
    // Set the protocol defaults
    //
    Discover->Version = BMBUILD_PACKET_VERSION;
    Discover->OpCode = BMBUILD_OPCODE_DISCOVER;
    
    //
    // Get the SMBIOS UUID (or PXE MAC address)
    //
    GetGuid(&Guid, &GuidLength);
    ASSERT(GuidLength == sizeof(Discover->MachineGuid));
    if (GuidLength == sizeof(Discover->MachineGuid)) {        
        memcpy(&Discover->MachineGuid, Guid, GuidLength);
    }

    //
    // Set the product guid from boot.ini
    //
    memcpy(&Discover->ProductGuid, &RamdiskGuid, sizeof(GUID));

    //
    // Debug prints
    //
    if (DBGLVL(INFO)) {
        DbgPrint("RAMDISK Build Discover\n");
        DbgPrint("MachineGuid = {%x-%x-%x-%x%x%x%x%x%x%x%x}\n",
               Discover->MachineGuid.Data1, Discover->MachineGuid.Data2,
               Discover->MachineGuid.Data3,
               Discover->MachineGuid.Data4[0], Discover->MachineGuid.Data4[1],
               Discover->MachineGuid.Data4[2], Discover->MachineGuid.Data4[3],
               Discover->MachineGuid.Data4[4], Discover->MachineGuid.Data4[5],
               Discover->MachineGuid.Data4[6], Discover->MachineGuid.Data4[7]);
        DbgPrint("ProductGuid = {%x-%x-%x-%x%x%x%x%x%x%x%x}\n",
               Discover->ProductGuid.Data1, Discover->ProductGuid.Data2,
               Discover->ProductGuid.Data3,
               Discover->ProductGuid.Data4[0], Discover->ProductGuid.Data4[1],
               Discover->ProductGuid.Data4[2], Discover->ProductGuid.Data4[3],
               Discover->ProductGuid.Data4[4], Discover->ProductGuid.Data4[5],
               Discover->ProductGuid.Data4[6], Discover->ProductGuid.Data4[7]);
    }

    *DiscoverLength = sizeof(BMBUILD_DISCOVER_PACKET);
    
    return ESUCCESS;
}

ARC_STATUS
RamdiskBuildRequest(
    IN PBMBUILD_REQUEST_PACKET pRequest,
    IN ULONG RequestLengthMax,
    OUT ULONG * pLength    
    )
/*++

Routine Description:

    This routine will build a request packet based on the Ramdisk parameters in the
    boot.ini and the machine configuration.

Arguments:

    pRequest - a pointer to a buffer that will hold the request

    RequestLengthMax - the maximum size that the request packet can be

    pLength - the final size of the request packet

Return Value:

    ESUCCESS - If the packet was filled in correctly.

    !ESUCCESS - If the packet couldn't be filled in correctly

--*/
{
    ARC_STATUS status;
    PDEVICE_INFO pDevice;
    t_PXENV_UNDI_GET_NIC_TYPE PxeNicType;
    PCONFIGURATION_COMPONENT_DATA Node = NULL;
    PCONFIGURATION_COMPONENT_DATA CurrentNode = NULL;
    PCONFIGURATION_COMPONENT_DATA ResumeNode = NULL;
    PPCIDEVICE pPCIDevice;
    PPNP_BIOS_INSTALLATION_CHECK pPNPBios;
    PPNP_BIOS_DEVICE_NODE pDevNode;
    PCM_PARTIAL_RESOURCE_LIST pPartialList;
    PUCHAR pCurr;
    USHORT cDevices;
    USHORT i;    
    ULONG lengthRemaining;
    ULONG GuidLength;
    PUCHAR Guid;
    PCHAR HalName;
    ULONG HalNameSize;
    BOOLEAN fNICFound = FALSE;

    ASSERT(pRequest);
    ASSERT(RequestLengthMax);
    ASSERT(pLength);

    RtlZeroMemory(pRequest, RequestLengthMax);
    
    //
    // Set the protocol defaults
    //
    pRequest->Version = BMBUILD_PACKET_VERSION;
    pRequest->OpCode = BMBUILD_OPCODE_REQUEST;
    
    //
    // Get the SMBIOS UUID (or PXE MAC address)
    //
    GetGuid(&Guid, &GuidLength);
    ASSERT(GuidLength == sizeof(pRequest->MachineGuid));
    if (GuidLength == sizeof(pRequest->MachineGuid)) {        
        memcpy(&pRequest->MachineGuid, Guid, GuidLength);
    }

    //
    // Set the product guid from boot.ini
    //
    memcpy(&pRequest->ProductGuid, &RamdiskGuid, sizeof(GUID));
    
    pRequest->Flags = 0;

#ifdef _IA64_
    pRequest->Architecture = PROCESSOR_ARCHITECTURE_IA64;
#else
    pRequest->Architecture = PROCESSOR_ARCHITECTURE_INTEL;
#endif

    //
    // Detect the appropriate HAL using TextMode Setup methods.
    //

#ifdef DOWNLOAD_TXTSETUP_SIF
    status = SlInitIniFile(  "net(0)",
                             0,
                             "boot\\txtsetup.sif",
                             &InfFile,
                             NULL,
                             NULL,
                             &x);
#endif

    //
    //  The device list start right after the fixed portion of the packet
    pRequest->DeviceCount = 0;

    //
    //  Make sure that the device array starts on a valid boundary
    //
    ASSERT(ROUND2(BMBUILD_FIELD_OFFSET(BMBUILD_REQUEST_PACKET, Data), 4) < 0xFFFF);
    pRequest->DeviceOffset = ROUND2(BMBUILD_FIELD_OFFSET(BMBUILD_REQUEST_PACKET, Data), 4);
    pDevice = (PDEVICE_INFO)((PUCHAR)pRequest + pRequest->DeviceOffset);

    //
    // Get the PXE NIC information
    //
    RtlZeroMemory(&PxeNicType, sizeof(PxeNicType));
    status = RomGetNicType(&PxeNicType);
    if ((status != PXENV_EXIT_SUCCESS) || (PxeNicType.Status != PXENV_EXIT_SUCCESS)) {
        DBGPRINT(ERR, ("RAMDISK ERROR: Couldn't get the NIC type from PXE. Failed with %x, status = %x\n", status, PxeNicType.Status));
        return ENODEV;
    }

    //
    // Fill in PCI Device information
    //

    Node = KeFindConfigurationEntry(FwConfigurationTree,
                                    PeripheralClass,
                                    RealModePCIEnumeration,
                                    NULL);
    ASSERT(Node != NULL);

    if (Node == NULL) {
        return ENODEV;
    }

    ASSERT(Node->ComponentEntry.ConfigurationDataLength > 0);
    ASSERT(Node->ConfigurationData != NULL);

    pPCIDevice = (PPCIDEVICE)((PUCHAR)Node->ConfigurationData + sizeof(CM_PARTIAL_RESOURCE_LIST));
    cDevices = (USHORT)(Node->ComponentEntry.ConfigurationDataLength - sizeof (CM_PARTIAL_RESOURCE_LIST)) / sizeof (PCIDEVICE);

    if (cDevices > BMBUILD_MAX_DEVICES(RequestLengthMax)) {
        DBGPRINT(ERR, ("RAMDISK ERROR: Too many PCI devices to fit in a request\n"));
        return EINVAL;
    }

    for (i = 0; i < cDevices; i++ ) {

        //
        // check if this is a bridge or a normal device
        //
        if ((pPCIDevice->Config.HeaderType & (~PCI_MULTIFUNCTION) ) == PCI_BRIDGE_TYPE) {
            //
            // Bridge.
            //
            pDevice[i].DeviceType = BMBUILD_DEVICE_TYPE_PCI_BRIDGE;

            pDevice[i].info.pci_bridge.BusDevFunc = pPCIDevice->BusDevFunc;
            pDevice[i].info.pci_bridge.VendorID = pPCIDevice->Config.VendorID;
            pDevice[i].info.pci_bridge.DeviceID = pPCIDevice->Config.DeviceID;
            pDevice[i].info.pci_bridge.BaseClass = pPCIDevice->Config.BaseClass;
            pDevice[i].info.pci_bridge.SubClass = pPCIDevice->Config.SubClass;
            pDevice[i].info.pci_bridge.ProgIntf = pPCIDevice->Config.ProgIf;
            pDevice[i].info.pci_bridge.RevisionID = pPCIDevice->Config.RevisionID;
            pDevice[i].info.pci_bridge.PrimaryBus = pPCIDevice->Config.u.type1.PrimaryBus;
            pDevice[i].info.pci_bridge.SecondaryBus = pPCIDevice->Config.u.type1.SecondaryBus;
            pDevice[i].info.pci_bridge.SubordinateBus = pPCIDevice->Config.u.type1.SubordinateBus;

        } else {
            //
            // Non-bridge PCI device
            //
            pDevice[i].DeviceType = BMBUILD_DEVICE_TYPE_PCI;

            pDevice[i].info.pci.BusDevFunc = pPCIDevice->BusDevFunc;
            pDevice[i].info.pci.VendorID = pPCIDevice->Config.VendorID;
            pDevice[i].info.pci.DeviceID = pPCIDevice->Config.DeviceID;
            pDevice[i].info.pci.BaseClass = pPCIDevice->Config.BaseClass;
            pDevice[i].info.pci.SubClass = pPCIDevice->Config.SubClass;
            pDevice[i].info.pci.ProgIntf = pPCIDevice->Config.ProgIf;
            pDevice[i].info.pci.RevisionID = pPCIDevice->Config.RevisionID;
            pDevice[i].info.pci.SubVendorID = pPCIDevice->Config.u.type0.SubVendorID;
            pDevice[i].info.pci.SubDeviceID = pPCIDevice->Config.u.type0.SubSystemID;

            //
            // Check if this device is the PXE boot device
            //
            if ((PxeNicType.NicType == 2) &&
                 (PxeNicType.pci_pnp_info.pci.BusDevFunc == pPCIDevice->BusDevFunc)) {

                 pRequest->PrimaryNicIndex = i;
                 fNICFound = TRUE;
            }
        }
                
        pPCIDevice++;
    }

    pRequest->DeviceCount = pRequest->DeviceCount + cDevices;
    pDevice += cDevices;

    //
    // Fill in PNP Device information (if there)
    //

    Node = NULL;
    
    while ((CurrentNode = KeFindConfigurationNextEntry(
                            FwConfigurationTree, 
                            AdapterClass, 
                            MultiFunctionAdapter,
                            NULL, 
                            &ResumeNode)) != 0) {
        if (!(strcmp(CurrentNode->ComponentEntry.Identifier,"PNP BIOS"))) {
            Node = CurrentNode;
            break;
        }
        ResumeNode = CurrentNode;
    }

    if (Node != NULL) {
        //
        // Set the PnP BIOS devices if found
        //
        ASSERT(Node->ComponentEntry.ConfigurationDataLength > 0);
        ASSERT(Node->ConfigurationData != NULL);

        pPartialList = (PCM_PARTIAL_RESOURCE_LIST)Node->ConfigurationData;
        pPNPBios = (PPNP_BIOS_INSTALLATION_CHECK)((PUCHAR)Node->ConfigurationData + sizeof(CM_PARTIAL_RESOURCE_LIST));

        pCurr = (PUCHAR)pPNPBios + pPNPBios->Length;
        lengthRemaining = pPartialList->PartialDescriptors[0].u.DeviceSpecificData.DataSize - pPNPBios->Length;

        for (cDevices = 0; lengthRemaining > sizeof(PNP_BIOS_DEVICE_NODE); cDevices++) {

            if ((pRequest->DeviceCount + cDevices + 1) > BMBUILD_MAX_DEVICES(RamdiskMaxPacketSize)) {
                DBGPRINT(ERR, ("RAMDISK ERROR: Too many PNP devices to fit in a request\n"));
                return EINVAL;
            }

            pDevNode = (PPNP_BIOS_DEVICE_NODE)pCurr;

            if (pDevNode->Size > lengthRemaining) {

                DBGPRINT(ERR, ("PNP Node # %d, invalid size (%d), length remaining (%d)\n",
                              pDevNode->Node, pDevNode->Size, lengthRemaining));
                ASSERT(FALSE);
                // REVIEW: [bassamt] Should I fail here?
                break;
            }

            pDevice->DeviceType = BMBUILD_DEVICE_TYPE_PNP;
            pDevice->info.pnp.EISADevID = pDevNode->ProductId;
            pDevice->info.pnp.BaseClass = pDevNode->DeviceType[0];
            pDevice->info.pnp.SubClass = pDevNode->DeviceType[1];
            pDevice->info.pnp.ProgIntf = pDevNode->DeviceType[2];
            pDevice->info.pnp.CardSelNum = pDevNode->Node;

            if ((PxeNicType.NicType == 3) &&
                 (PxeNicType.pci_pnp_info.pnp.EISA_Dev_ID == pDevNode->ProductId) &&
                 (PxeNicType.pci_pnp_info.pnp.CardSelNum == pDevNode->Node)) {

                 pRequest->PrimaryNicIndex = pRequest->DeviceCount + cDevices;
                 fNICFound = TRUE;
            }

            pCurr += pDevNode->Size;
            lengthRemaining -= pDevNode->Size;
            pDevice++;
        }

        pRequest->DeviceCount = pRequest->DeviceCount + cDevices;
    }

    //
    // We better have found the primary NIC or the packet is invalid
    //
    if (!fNICFound) {
        DBGPRINT(ERR, ("RAMDISK ERROR: Could not find the primary NIC\n"));
        return ENODEV;
    }
        
    //
    // The hal starts right after the array of device infos
    //
    pRequest->HalDataOffset = pRequest->DeviceOffset + (pRequest->DeviceCount * sizeof(DEVICE_INFO));
    
    //
    // Figure out which hal to use
    //
    HalName = SlDetectHal();
    if (HalName == NULL) {
        DBGPRINT(ERR, ("RAMDISK ERROR: Couldn't get the HAL name.\n"));
        return ENODEV;
    }

    HalNameSize = strlen(HalName);
    if (HalNameSize > (RequestLengthMax - pRequest->HalDataOffset)) {
        DBGPRINT(ERR, ("RAMDISK ERROR: HAL name, %s, is too big for request, size = %d.\n", 
                    HalName, RequestLengthMax - pRequest->HalDataOffset));
        return ENOMEM;
    }

    //
    // Copy over the hal
    //
    memcpy((PUCHAR)pRequest + pRequest->HalDataOffset, HalName, HalNameSize);
    pRequest->HalDataLength = RESET_SIZE_AT_USHORT_MAX(HalNameSize);

    //
    // Return the length
    //
    *pLength = pRequest->HalDataOffset + pRequest->HalDataLength;
    
    //
    // Debug prints
    //
    if (DBGLVL(INFO)) {
        DbgPrint("RAMDISK Build Request\n");
        DbgPrint("Architecture = %d\n", pRequest->Architecture);
        DbgPrint("MachineGuid = {%x-%x-%x-%x%x%x%x%x%x%x%x}\n",
               pRequest->MachineGuid.Data1, pRequest->MachineGuid.Data2,
               pRequest->MachineGuid.Data3,
               pRequest->MachineGuid.Data4[0], pRequest->MachineGuid.Data4[1],
               pRequest->MachineGuid.Data4[2], pRequest->MachineGuid.Data4[3],
               pRequest->MachineGuid.Data4[4], pRequest->MachineGuid.Data4[5],
               pRequest->MachineGuid.Data4[6], pRequest->MachineGuid.Data4[7]);
        DbgPrint("ProductGuid = {%x-%x-%x-%x%x%x%x%x%x%x%x}\n",
               pRequest->ProductGuid.Data1, pRequest->ProductGuid.Data2,
               pRequest->ProductGuid.Data3,
               pRequest->ProductGuid.Data4[0], pRequest->ProductGuid.Data4[1],
               pRequest->ProductGuid.Data4[2], pRequest->ProductGuid.Data4[3],
               pRequest->ProductGuid.Data4[4], pRequest->ProductGuid.Data4[5],
               pRequest->ProductGuid.Data4[6], pRequest->ProductGuid.Data4[7]);
        DbgPrint("HALName = %s\n", HalName);
        DbgPrint("Flags = 0x%x\n", pRequest->Flags);
        DbgPrint("DeviceCount = %d\n", pRequest->DeviceCount);
        pDevice = (PDEVICE_INFO)( (PUCHAR)pRequest + pRequest->DeviceOffset );

        for (i = 0; i < pRequest->DeviceCount; i++ ) {
            CHAR DeviceString[128];
            RamdiskDeviceInfoToString( pDevice, DeviceString );
            DbgPrint("[%d] %s %s\n", i, DeviceString, (i == pRequest->PrimaryNicIndex? "PRIMARY NIC" : ""));
            pDevice++;
        }
    }
    
    return ESUCCESS;
}

ARC_STATUS
RamdiskSendDiscoverAndWait(
    IN PBMBUILD_DISCOVER_PACKET Discover,
    IN ULONG DiscoverSize,
    IN ULONG Timeout
    )
/*++

Routine Description:

    This routine will send a discovery packet on the network in 
    accordance with the RamdiskDiscovery parameters. It will then
    wait for the specified timeout period and collect the responses
    from the build servers.  It will add each of these servers to the
    RamdiskServers list.  If we don't get any responses in the timeout
    period, we will return EIO.

Arguments:

    Discover - Discover packet to send out

    DiscoverSize - the size of the discover packet

    Timeout - timeout interval

Return Value:

    ESUCCESS - received at least one response from a build server

    EIO - if we timed out waiting for a response from a build server

    EINVAL - couldn't send the discover packet

--*/
{
    ULONG waitStartTime;
    BMBUILD_ACCEPT_PACKET accept;
    PUCHAR address = (PUCHAR) &RamdiskDiscovery;
    BOOLEAN receivedAccept;
    ULONG length;
    ULONG remoteHost;
    USHORT remotePort;

    ASSERT(RamdiskServerCount < RAMDISK_MAX_SERVERS);
    ASSERT(RamdiskDiscovery != 0);
    ASSERT(RamdiskBuildPort != 0);

    //
    // Send the discovery packet to the destination address
    //
    length = RomSendUdpPacket(Discover, DiscoverSize, RamdiskDiscovery, RamdiskBuildPort);
    if (length != DiscoverSize) {

        DBGPRINT(ERR, ("FAILED to send discovery packet to %u.%u.%u.%u:%u\n", 
                    address[0], address[1], address[2], address[3], 
                    SWAP_WORD(RamdiskBuildPort)));

        return EINVAL;
    }

    DBGPRINT(INFO, ("Waiting for response (Timeout = %d secs).\n", Timeout));

    //
    // Wait for the responses. We will wait for the timeout period and
    // collect the ACCEPT packets we get within this timeout. 
    //

    waitStartTime = SysGetRelativeTime();
    receivedAccept = FALSE;
    while ((SysGetRelativeTime() - waitStartTime) < Timeout) {

        length = RomReceiveUdpPacket(&accept, sizeof(accept), 0, &remoteHost, &remotePort);
        if (length != 0) {

            //
            // Make sure the packet is one of the ones we expect.
            //
            if ((remoteHost == 0) || (remoteHost == 0xFFFFFFFF) || (RamdiskBuildPort != remotePort)) {
                    
                PUCHAR bad = (PUCHAR) &remoteHost;
                //
                // Recieved a packet from the wrong server/port
                //
                DBGPRINT(ERR, ("RamdiskSendDiscoverPacketAndWait: received an unexpected packet, "
                        "expected %u, received %u.%u.%u.%u:%u\n",
                        SWAP_WORD(RamdiskBuildPort),
                        bad[0], bad[1], bad[2], bad[3], SWAP_WORD(remotePort)));
                
            } else if (length < sizeof(BMBUILD_ACCEPT_PACKET)) {
                
                //
                // Recieved a packet that's too small
                //
                DBGPRINT(ERR, ("RamdiskSendDiscoverPacketAndWait: packet size too small, %d\n", length));
                        
            } else if ((accept.Version != BMBUILD_PACKET_VERSION) ||
                    (accept.OpCode != BMBUILD_OPCODE_ACCEPT) ||
                    (accept.XID != Discover->XID)) {
                    
                //
                // The packet is corrupt
                //
                address = (PUCHAR) &remoteHost;
                DBGPRINT(ERR, ("RamdiskSendDiscoverPacketAndWait: expected ACCEPT with XID %d, "
                            "received Version %d, OpCode %d, XID %d from %u.%u.%u.%u:%u\n", 
                            Discover->XID, accept.Version, accept.OpCode, accept.XID,
                            address[0], address[1], address[2], address[3], SWAP_WORD(remotePort)));
            } else {

                address = (PUCHAR) &remoteHost;
                DBGPRINT(INFO, ("Received ACCEPT packet XID = %d from %u.%u.%u.%u:%u\n", 
                            accept.XID, address[0], address[1], address[2], address[3], 
                            SWAP_WORD(remotePort)));

                //
                // We have a valid packet from a build server. Add it to
                // the list.
                //
                receivedAccept = TRUE;
                ASSERT(RamdiskServerCount < RAMDISK_MAX_SERVERS);
                RamdiskServers[RamdiskServerCount] = remoteHost;
                RamdiskServerCount++;

                //
                // If we filled up the maximum number of servers
                // then we are done
                //
                if (RamdiskServerCount == RAMDISK_MAX_SERVERS) {
                    break;
                }
            }
        }
    }

    //
    // Did we get anything
    //
    if (receivedAccept) {
        return ESUCCESS;        
    } else {
        address = (PUCHAR) &RamdiskDiscovery;
        DBGPRINT(ERR, ("Timed out waiting for accepts using %u.%u.%u.%u:%u "
                    "(Timeout = %d secs).\n", address[0], address[1], address[2],
                    address[3], SWAP_WORD(RamdiskBuildPort), Timeout));

        return EIO;
    }
}

ARC_STATUS
RamdiskDiscoverBuildServer(
    )
/*++

Routine Description:

    This routine will discover a list of build server based on the
    ramdisk build parameters listed in boot.ini.  If we already have
    a list of build server listed in boot.ini, we will use that list
    as the possible build servers.  If we get a response from any 
    build server, we will stop the discover stage and use the list 
    of servers we have heard back from as the list of possible build
    servers to use.  We will retry a number of times to get responses.
    If we get no response after retrying, we will fail.
   
Arguments:

    None

Return Value:

    ESUCCESS - We have a list of build servers

    EIO - We timed out waiting for responses from the build servers

    otherwise, something else failed

--*/
{
    ARC_STATUS status;
    USHORT localPort;
    BMBUILD_DISCOVER_PACKET discover;
    ULONG discoverLength;
    ULONG iRetry;
    ULONG timeout;
    ULONG lastProgressPercent = 0;
    BOOLEAN forceDisplayFirstTime = TRUE;
    ULONG currentProgressPercent;
    PUCHAR address = (PUCHAR) &RamdiskDiscovery;

    
    //
    // Short-circuit discovery if we already have a list of servers
    //
    if (RamdiskServerCount > 0) {
        ASSERT(RamdiskServers[0] != 0);
        ASSERT(RamdiskServers[0] != 0xFFFFFFFF);
        return ESUCCESS;
    }

    ASSERT(RamdiskDiscovery != 0);
    
    //
    // Grab an unused port 
    //
    localPort = UdpAssignUnicastPort();
    DBGPRINT(INFO, ("Sending builder discovers using port %d.\n", SWAP_WORD(localPort)));
    
    //
    // Create discover packet
    //
    status = RamdiskBuildDiscover(&discover, sizeof(discover), &discoverLength);
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Start the discovery. Note that this will be repeated a number
    // of times to account for network congestion and load on the servers.
    //
    BlOutputStartupMsg(RAMDISK_BUILD_DISCOVER);
    BlUpdateProgressBar(0);
    timeout = RamdiskTimeout;
    for (iRetry = 0; iRetry < RamdiskRetry; iRetry++) {

        //
        // Each Discover gets its own transaction ID.
        //
        discover.XID = ++RamdiskXID;

        //
        // update progress bar. this happens here since a timed out packet
        // might take some time.
        //
        currentProgressPercent = (iRetry * 100) / RamdiskRetry;
        if (forceDisplayFirstTime || (currentProgressPercent != lastProgressPercent)) {
            BlUpdateProgressBar(currentProgressPercent);
            forceDisplayFirstTime = FALSE;
        }
        lastProgressPercent = currentProgressPercent;

        DBGPRINT(INFO, ("Sending discovery packet XID = %d to %u.%u.%u.%u:%u. "
                    "Retry %d out of %d. Timeout = %d\n", discover.XID, 
                    address[0], address[1], address[2], address[3], 
                    SWAP_WORD(RamdiskBuildPort), iRetry, RamdiskRetry, timeout));
    
        status = RamdiskSendDiscoverAndWait(&discover, discoverLength, timeout);
        if (status == ESUCCESS) {
            
            //
            // we found at least one server. we are done.
            //
            BlUpdateProgressBar(100);
            return ESUCCESS;
        }

        //
        // double the timeout, but max out at RAMDISK_MAX_TIMEOUT seconds
        //
        if ((timeout * 2) < RAMDISK_MAX_TIMEOUT) {
            timeout = timeout * 2;
        } else {
            timeout = RAMDISK_MAX_TIMEOUT;
        }
    }

    BlUpdateProgressBar(100);
    
    return EIO;
}

ARC_STATUS
RamdiskVerifyResponse(
    BMBUILD_RESPONSE_PACKET * Response,
    ULONG ResponseSize,
    ULONG XID
    )
/*++

Routine Description:

    This routine will verify that the response packet is valid.
   
Arguments:

    Response - the response to validate

    ResponseSize - the size of the response packet

    XID - the XID this packet is supposed to contain

Return Value:

    ESUCCESS - This packet is valid

    EINVAL - The packet is invalid/misformatted

--*/
{

    if (ResponseSize < BMBUILD_RESPONSE_FIXED_PACKET_LENGTH) {
        
        //
        // Recieved a packet that's too small
        //
        DBGPRINT(ERR, ("RamdiskVerifyResponse: packet size too small, %d\n", ResponseSize));
        return EINVAL;
                
    } else if ((Response->Version != BMBUILD_PACKET_VERSION) ||
            (Response->OpCode != BMBUILD_OPCODE_RESPONSE) ||
            (Response->XID != XID)) {
            
        //
        // The packet is corrupt
        //
        DBGPRINT(ERR, ("RamdiskVerifyResponse: expected RESPONSE with XID %d, "
                    "received Version %d, OpCode %d, XID %d\n", 
                    XID, Response->Version, Response->OpCode, Response->XID));
        return EINVAL;
    } else {

        switch (Response->Status) {

        case BMBUILD_S_REQUEST_COMPLETE:
            if ((Response->ImagePathOffset < BMBUILD_RESPONSE_FIXED_PACKET_LENGTH) ||   
                    (Response->ImagePathLength == 0) ||
                    ((ULONG)(Response->ImagePathOffset + Response->ImagePathLength) > ResponseSize)) {

                //
                // The packet is corrupt
                //
                DBGPRINT(ERR, ("RamdiskVerifyResponse: the image path isn't correctly "
                        "formatted. ImageOffset = %d, Imagelength = %d, PacketLength = %d.\n", 
                        Response->ImagePathOffset, Response->ImagePathLength, ResponseSize));
                return EINVAL;
            }
            break;

        case BMBUILD_S_REQUEST_PENDING:  
        case BMBUILD_E_WRONGVERSION:     
        case BMBUILD_E_BUSY:             
        case BMBUILD_E_ACCESSDENIED: 
        case BMBUILD_E_ILLEGAL_OPCODE:
        case BMBUILD_E_PRODUCT_NOT_FOUND:
        case BMBUILD_E_BUILD_FAILED:
        case BMBUILD_E_INVALID_PACKET:
            //
            // No specific checks for these status codes 
            //
            break;

        default:
            //
            // The packet is corrupt
            //
            DBGPRINT(ERR, ("RamdiskVerifyResponse: unexpected RESPONSE status %d.\n", Response->Status));
            return EINVAL;
            break;
        }
    }

    return ESUCCESS;
}

ARC_STATUS
RamdiskSendRequestAndWait(
    IN BMBUILD_REQUEST_PACKET * Request,
    IN ULONG RequestSize,
    IN ULONG BuilderAddress,
    IN ULONG Timeout,
    IN BMBUILD_RESPONSE_PACKET * Response,
    IN ULONG ResponseSizeMax
    )
/*++

Routine Description:

    This routine will send a request packet to the specified server. 
    It will wait for the specified timeout period for a reply from
    the server.  On successful return, the response parameter will
    contain a valid response.

Arguments:

    Request - the request packet to send out

    RequestSize - the size of the request packet

    BuilderAddress - the builder server to send the request to

    Timeout - the amount of time to wait for a response, in seconds

    Response - the response packet that should be filled in

    ResponseSizeMax - the maximum size of the response packet
    
Return Value:

    ESUCCESS - the response packet was received from the server and is valid

    EIO - we timed out waiting for a response from the server

    EINVAL - we couldn't send the packet to the server

--*/
{
    ULONG waitStartTime;
    PUCHAR address = (PUCHAR) &BuilderAddress;
    ULONG length;
    ULONG remoteHost;
    USHORT remotePort;

    ASSERT(Request != NULL);
    ASSERT(RequestSize != 0);
    ASSERT(BuilderAddress != 0);
    ASSERT(BuilderAddress != 0xFFFFFFFF);
    ASSERT(Timeout != 0);
    ASSERT(Response != NULL);
    ASSERT(ResponseSizeMax != 0);
    ASSERT(RamdiskBuildPort != 0);


    //
    // Send the discovery packet to the destination address
    //
    length = RomSendUdpPacket(Request, RequestSize, BuilderAddress, RamdiskBuildPort);
    if (length != RequestSize) {

        DBGPRINT(ERR, ("FAILED to send request packet to %u.%u.%u.%u:%u\n", 
                    address[0], address[1], address[2], address[3], 
                    SWAP_WORD(RamdiskBuildPort)));

        return EINVAL;
    }

    DBGPRINT(INFO, ("Waiting for response (Timeout = %d secs).\n", Timeout));
    
    //
    // Wait for the responses. We will wait for the timeout period and
    // select the best ACCEPT we get within this timeout. The best accept
    // is the one with the lowest build time.
    //

    waitStartTime = SysGetRelativeTime();
    while ((SysGetRelativeTime() - waitStartTime) < Timeout) {

        length = RomReceiveUdpPacket(Response, ResponseSizeMax, 0, &remoteHost, &remotePort);
        if (length != 0) {
        
            //
            // Make sure the packet is one of the ones we expect.
            //
            if ((BuilderAddress != remoteHost) || (RamdiskBuildPort != remotePort)) {
                    
                PUCHAR bad = (PUCHAR) &remoteHost;
                PUCHAR good = (PUCHAR) &BuilderAddress;
                //
                // Recieved a packet from the wrong server/port
                //
                DBGPRINT(ERR, ("RamdiskSendRequest: received an unexpected packet, "
                        "expected %u.%u.%u.%u:%u, received %u.%u.%u.%u:%u\n",
                        good[0], good[1], good[2], good[3], SWAP_WORD(RamdiskBuildPort),
                        bad[0], bad[1], bad[2], bad[3], SWAP_WORD(remotePort)));
                
            } else if (RamdiskVerifyResponse(Response, length, Request->XID) == ESUCCESS) {
                
                PUCHAR good = (PUCHAR) &remoteHost;
                DBGPRINT(INFO, ("Received RESPONSE packet (%d bytes) XID = %d status "
                            "= %d from %u.%u.%u.%u:%u.\n", length, Response->XID, 
                            Response->Status, good[0], good[1], good[2], 
                            good[3], SWAP_WORD(remotePort)));
                return ESUCCESS;
            }
        }
    }

    address = (PUCHAR) &BuilderAddress;
    DBGPRINT(ERR, ("Timed out waiting for a response from %u.%u.%u.%u:%u "
                    "(Timeout = %d secs).\n", address[0], address[1], address[2],
                    address[3], SWAP_WORD(RamdiskBuildPort), Timeout));
    
    //
    // We timed out
    //
    return EIO;
}

ARC_STATUS
RamdiskGetResponse(
    BMBUILD_RESPONSE_PACKET * Response,
    ULONG ResponseSizeMax)
/*++

Routine Description:

    This routine will get a response that contains a valid image path and download
    parameter from a server.  This routine will use the RamdiskServers list to send
    requests to until it receives a valid response indicating that the image has 
    been built.  It will use the networking parameters specified in boot.ini.

Arguments:

    Response - the response packet that should be contain the image path and
                downloading parameters

    ResponseSizeMax - the maximum size of the response packet
    
Return Value:

    ESUCCESS - the response packet contains the image path and downloading parameters

    EIO - we timed out waiting for a response from the server

    EINVAL - we couldn't send the packet to the server

    otherwise - something else stopped us from receiving a valid response 


--*/
{
    ARC_STATUS status;
    BMBUILD_REQUEST_PACKET * request;
    ULONG requestSize;
    USHORT localPort;
    ULONG timeout;
    ULONG iRetry;
    ULONG iServers;
    PUCHAR address;
    ULONG progressMax;
    ULONG lastProgressPercent = 0;
    BOOLEAN forceDisplayFirstTime = TRUE;
    ULONG currentProgressPercent;

    request = BlAllocateHeap(RamdiskMaxPacketSize);
    if (request == NULL) {
        DBGPRINT(ERR, ("Failed to allocate request packet of size %d.\n", RamdiskMaxPacketSize));
        return ENOMEM;
    }

    //
    // Grab an unused port 
    //
    localPort = UdpAssignUnicastPort();
    DBGPRINT(INFO, ("Sending builder requests using port %d.\n", SWAP_WORD(localPort)));

    //
    // Build request packet
    //
    status = RamdiskBuildRequest(request, RamdiskMaxPacketSize, &requestSize);
    if (status != ESUCCESS) {
        return status;
    }

    //
    // We will be sending a maximum of RamdiskRetry request packets
    // to RamdiskServerCount servers
    //
    progressMax = RamdiskServerCount * RamdiskRetry;
    
    //
    // Reset the progress information
    //
    BlOutputStartupMsg(RAMDISK_BUILD_REQUEST);
    BlUpdateProgressBar(0);
   
    DBGPRINT(INFO, ("Requesting appropriate image for this computer...\n"));

    for (iServers = 0; iServers < RamdiskServerCount; iServers++) {

        //
        // Set our initial time out
        //
        timeout  = RamdiskTimeout;

        RamdiskPrintBuildProgress(RAMDISK_BUILD_PROGRESS, RamdiskServers[iServers]);

        for (iRetry = 0; iRetry < RamdiskRetry; iRetry++) {

            //
            // allocate a new transaction ID for this session
            //
            request->XID = ++RamdiskXID;

            //
            // update progress bar. this happens here since a timed out packet
            // might take some time.
            //
            currentProgressPercent = ((iServers * RamdiskRetry + iRetry) * 100) / progressMax;
            if (forceDisplayFirstTime || (currentProgressPercent != lastProgressPercent)) {
                BlUpdateProgressBar(currentProgressPercent);
                forceDisplayFirstTime = FALSE;
            }
            lastProgressPercent = currentProgressPercent;
        
            address = (PUCHAR) &(RamdiskServers[iServers]);
            DBGPRINT(INFO, ("Sending request packet XID = %d to %u.%u.%u.%u:%u. "
                        "Retry %d out of %d. Timeout = %d\n", request->XID, 
                        address[0], address[1], address[2], address[3], 
                        SWAP_WORD(RamdiskBuildPort), iRetry, RamdiskRetry, timeout));
            
            status = RamdiskSendRequestAndWait(request, requestSize, RamdiskServers[iServers],
                        timeout, Response, ResponseSizeMax);
            if (status == ESUCCESS) {  

                //
                // Now that we have a valid response, check to see what we are
                // supposed to do with it.  We assume that any validation was
                // already done in RamdiskSendRequestAndWait
                //
                address = (PUCHAR) &(RamdiskServers[iServers]);
                if (Response->Status == BMBUILD_S_REQUEST_COMPLETE) {
                    
                    DBGPRINT(INFO, ("Request is complete from server %u.%u.%u.%u:%u.\n", 
                                address[0], address[1], address[2], address[3], 
                                SWAP_WORD(RamdiskBuildPort)));

                    BlUpdateProgressBar(100);
                    return ESUCCESS;

                } else if (Response->Status == BMBUILD_S_REQUEST_PENDING) {
                    
                    DBGPRINT(INFO, ("Request is pending. Instructed to wait for %d secs "
                                "by server %u.%u.%u.%u:%u.\n", Response->WaitTime,
                                address[0], address[1], address[2], address[3], 
                                SWAP_WORD(RamdiskBuildPort)));
                    
                    RamdiskPrintBuildProgress(RAMDISK_BUILD_PROGRESS_PENDING, RamdiskServers[iServers]);
                    RamdiskWait(Response->WaitTime);

                } else if (Response->Status == BMBUILD_E_BUSY) {

                    DBGPRINT(INFO, ("Server %u.%u.%u.%u:%u is busy. Waiting for %d secs.\n",
                                address[0], address[1], address[2], address[3], 
                                SWAP_WORD(RamdiskBuildPort), RamdiskTimeout));
                    
                    RamdiskPrintBuildProgress(RAMDISK_BUILD_PROGRESS_ERROR, RamdiskServers[iServers]);
                    RamdiskWait(RAMDISK_UI_WAIT);

                } else {
                    RamdiskPrintBuildProgress(RAMDISK_BUILD_PROGRESS_ERROR, RamdiskServers[iServers]);
                    RamdiskWait(RAMDISK_UI_WAIT);                

                    //
                    //  Try a different server
                    //
                    break;
                }
                
            } else if (status == EIO) {
                RamdiskPrintBuildProgress(RAMDISK_BUILD_PROGRESS_TIMEOUT, RamdiskServers[iServers]);
                RamdiskWait(RAMDISK_UI_WAIT);   
                
                //
                // double the timeout, but max out at RAMDISK_MAX_TIMEOUT seconds
                //
                if ((timeout * 2) < RAMDISK_MAX_TIMEOUT) {
                    timeout = timeout * 2;
                } else {
                    timeout = RAMDISK_MAX_TIMEOUT;
                }
            } else {
                RamdiskPrintBuildProgress(RAMDISK_BUILD_PROGRESS_ERROR, RamdiskServers[iServers]);
                RamdiskWait(RAMDISK_UI_WAIT);                

                //
                //  Try a different server
                //
                break;
            }
        }
    }

    //
    // We completely timed out
    //    
    BlUpdateProgressBar(100);
    return EIO;
}

ARC_STATUS
RamdiskBuildAndInitialize(
    )
/*++

Routine Description:

    This routine will communicate with a build server to build 
    a ramdisk and obtain a RDPATH.

Arguments:


Return Value:

    ESUCCESS - image was successfully built and we have a valid RDPATH

    !ESUCCESS - we failed to build the image

--*/
{
    ARC_STATUS status;
    PBMBUILD_RESPONSE_PACKET response = NULL;
    PUCHAR imagePath;
    PUCHAR address;
    

    //
    // Set the max packet size. This is calculated from the 
    // MTU size of the network (1500 for Ethernet) minus
    // the IP and UDP headers ( which account to 28 bytes ).
    //
    RamdiskMaxPacketSize = NetMaxTranUnit - 28;

    ASSERT(RamdiskMaxPacketSize > 0);

    response = BlAllocateHeap(RamdiskMaxPacketSize);
    if (response == NULL) {
        DBGPRINT(ERR, ("Failed to allocate response packet of size %d.\n", RamdiskMaxPacketSize));
        return ENOMEM;
    }

    RtlZeroMemory(response, RamdiskMaxPacketSize);

    //
    // Discover build server
    //
    status = RamdiskDiscoverBuildServer();
    if (status != ESUCCESS) {
        goto Error;
    }

    //
    //  Get the response from the build server
    //
    status = RamdiskGetResponse(response, RamdiskMaxPacketSize);
    if (status != ESUCCESS) {
        goto Error;
    }
    
    ASSERT (RamdiskPath == NULL);

    //
    // Set the MTFTP options
    //
    RamdiskTFTPAddr = response->TFTPAddr.Address;
    RamdiskMTFTPAddr = response->MTFTPAddr.Address;
    RamdiskMTFTPCPort = response->MTFTPCPort;
    RamdiskMTFTPSPort = response->MTFTPSPort;
    RamdiskMTFTPTimeout = response->MTFTPTimeout;
    RamdiskMTFTPDelay = response->MTFTPDelay;
    RamdiskMTFTPFileSize = response->MTFTPFileSize;
    RamdiskMTFTPChunkSize = response->MTFTPChunkSize;

    //
    // Set the image offset and length
    //
    RamdiskImageOffset = response->ImageFileOffset;
    RamdiskImageLength = response->ImageFileSize;

    imagePath = (PUCHAR)((ULONG_PTR)response + response->ImagePathOffset);

    RamdiskPath = BlAllocateHeap(response->ImagePathLength + sizeof("net(0)\\"));
    if (RamdiskPath == NULL) {
        DBGPRINT(ERR, ("Failed to allocate memory for RamdiskPath size %d.\n", 
                response->ImagePathLength + sizeof("net(0)\\")));
        return ENOMEM;
    }

    strcpy(RamdiskPath, "net(0)\\");
    memcpy(RamdiskPath + sizeof("net(0)\\") - 1, imagePath, response->ImagePathLength);
    RamdiskPath[sizeof("net(0)\\") + response->ImagePathLength - 1] = '\0';

    if (DBGLVL(INFO)) {
        DbgPrint("RDPATH = %s\n", RamdiskPath);
        address = (PUCHAR) &RamdiskTFTPAddr;
        DbgPrint("RDTFTPADDR = %u.%u.%u.%u\n", address[0], address[1], address[2], address[3]);
        address = (PUCHAR) &RamdiskMTFTPAddr;
        DbgPrint("RDMTFTPADDR = %u.%u.%u.%u\n", address[0], address[1], address[2], address[3]);
        DbgPrint("RDMTFTPCPORT = %d\n", SWAP_WORD( RamdiskMTFTPCPort));
        DbgPrint("RDMTFTPSPORT = %d\n", SWAP_WORD( RamdiskMTFTPSPort));
        DbgPrint("RDMTFTPDELAY = %d\n", RamdiskMTFTPDelay);
        DbgPrint("RDMTFTPTIMEOUT = %d\n", RamdiskMTFTPTimeout);
        DbgPrint("RDFILESIZE = 0x%0I64x bytes\n", RamdiskMTFTPFileSize);
        DbgPrint("RDCHUNKSIZE = 0x%0I64x bytes\n", RamdiskMTFTPChunkSize);
        DbgPrint("RDIMAGEOFFSET = 0x%x bytes\n", RamdiskImageOffset);
        DbgPrint("RDIMAGELENGTH = 0x%0I64x bytes\n", RamdiskImageLength);
    }
    
    return ESUCCESS;

Error:
    DBGPRINT(ERR, ("RamdiskBuildAndInitialize: Failed, %d.\n", status));

    //
    //  We should be rebooting the machine here
    //
    return status;
}

#endif

VOID
RamdiskFatalError(
    IN ULONG Message1,
    IN ULONG Message2
    )
/*++

Routine Description:

    This function looks up a message to display at a error condition.

Arguments:

    Message - message that describes the class of problem.

Return Value:

    none

--*/
{

    PTCHAR Text;
    TCHAR Buffer[40];
    ULONG Count;


    BlClearScreen();

    Text = BlFindMessage(Message1);
    if (Text == NULL) {
        _stprintf(Buffer,TEXT("%08lx\r\n"),Message1);
        Text = Buffer;
    }

    ArcWrite(BlConsoleOutDeviceId,
             Text,
             (ULONG)_tcslen(Text)*sizeof(TCHAR),
             &Count);

    Text = BlFindMessage(Message2);
    if (Text == NULL) {
        _stprintf(Buffer,TEXT("%08lx\r\n"),Message2);
        Text = Buffer;
    }

    ArcWrite(BlConsoleOutDeviceId,
             Text,
             (ULONG)_tcslen(Text)*sizeof(TCHAR),
             &Count);

#if defined(ENABLE_LOADER_DEBUG) || DBG
#if (defined(_X86_) || defined(_ALPHA_) || defined(_IA64_)) && !defined(ARCI386) // everything but ARCI386
    if(BdDebuggerEnabled) {
        DbgBreakPoint();
    }
#endif
#endif

    return;
}

#if defined(_X86_)

VOID
RamdiskSdiBoot(
    IN PCHAR SdiFile
    )
{
    ARC_STATUS status;
    PSDI_HEADER sdiHeader;
    PUCHAR startromAddress;
    ULONG startromLength;
    BOOLEAN OldShowProgressBar;
    LONGLONG availableLength;

    //
    // Read the SDI image into memory.
    //

    RamdiskTFTPAddr = NetServerIpAddress;
    RamdiskImageOffset = 0;
    RamdiskImageLength = 0;

    OldShowProgressBar = BlShowProgressBar;
    BlShowProgressBar = TRUE;

    status = RamdiskReadImage( SdiFile );
    if ( status != ESUCCESS ) {
        RamdiskFatalError( RAMDISK_GENERAL_FAILURE, 
                           RAMDISK_BOOT_FAILURE );
        return;
    }

    BlShowProgressBar = OldShowProgressBar;

    //
    // Copy startrom.com from the SDI image to 0x7c00.
    //

    sdiHeader = MapRamdisk( 0, &availableLength );

    ASSERT( availableLength >= sizeof(SDI_HEADER) );
    ASSERT( availableLength >=
            (sdiHeader->liBootCodeOffset.QuadPart + sdiHeader->liBootCodeSize.QuadPart) );

    ASSERT( sdiHeader->liBootCodeOffset.HighPart == 0 );
    ASSERT( sdiHeader->liBootCodeSize.HighPart == 0 );

    startromAddress = (PUCHAR)sdiHeader + sdiHeader->liBootCodeOffset.LowPart;
    startromLength = sdiHeader->liBootCodeSize.LowPart;

    RtlMoveMemory( (PVOID)0x7c00, startromAddress, startromLength );

    //
    // Shut down PXE.
    //

    if ( BlBootingFromNet ) {
        NetTerminate();
    }

    //
    // Inform boot debugger that the boot phase is complete.
    //

#if defined(ENABLE_LOADER_DEBUG) || DBG
#if (defined(_X86_) || defined(_ALPHA_)) && !defined(ARCI386)

    {
        if (BdDebuggerEnabled == TRUE) {
            DbgUnLoadImageSymbols(NULL, (PVOID)-1, 0);
        }
    }

#endif
#endif

    REBOOT( (ULONG)sdiHeader | 3 );

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\scsiboot.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    scsiboot.c

Abstract:

    This is the NT SCSI port driver.

Author:

    Mike Glass
    Jeff Havens

Environment:

    kernel mode only

Notes:

    This module is linked into the kernel.

Revision History:

--*/

#if !defined(DECSTATION)

#include "stdarg.h"
#include "stdio.h"
#if defined(_MIPS_)
#include "..\fw\mips\fwp.h"
#elif defined(_ALPHA_)
#include "bldr.h"
#elif defined(_PPC_)
#include "..\fw\ppc\fwp.h"
#elif defined(_IA64_)
#include "bootia64.h"
#else
#include "bootx86.h"
#endif
#include "scsi.h"
#include "scsiboot.h"
#include "pci.h"

#if DBG
ULONG ScsiDebug = 0;
#endif

ULONG ScsiPortCount;
PDEVICE_OBJECT ScsiPortDeviceObject[MAXIMUM_NUMBER_OF_SCSIPORT_OBJECTS];
PINQUIRYDATA InquiryDataBuffer;
FULL_SCSI_REQUEST_BLOCK PrimarySrb;
FULL_SCSI_REQUEST_BLOCK RequestSenseSrb;
FULL_SCSI_REQUEST_BLOCK AbortSrb;


extern PDRIVER_UNLOAD AEDriverUnloadRoutine;

//
// Function declarations
//

ARC_STATUS
ScsiPortDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ScsiPortExecute(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ScsiPortStartIo (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
ScsiPortInterrupt(
    IN PKINTERRUPT InterruptObject,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
ScsiPortCompletionDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
ScsiPortTickHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

IO_ALLOCATION_ACTION
ScsiPortAllocationRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

ARC_STATUS
IssueInquiry(
    IN PDEVICE_EXTENSION deviceExtension,
    IN PLUNINFO LunInfo
    );

VOID
IssueRequestSense(
    IN PDEVICE_EXTENSION deviceExtension,
    IN PSCSI_REQUEST_BLOCK FailingSrb
    );

VOID
ScsiPortInternalCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

PSCSI_BUS_SCAN_DATA
ScsiBusScan(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN UCHAR ScsiBus,
    IN UCHAR InitiatorBusId
    );

PLOGICAL_UNIT_EXTENSION
CreateLogicalUnitExtension(
    IN PDEVICE_EXTENSION DeviceExtension
    );

BOOLEAN
SpStartIoSynchronized (
    PVOID ServiceContext
    );

VOID
IssueAbortRequest(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP FailingIrp
    );

VOID
SpCheckResetDelay(
    IN PDEVICE_EXTENSION deviceExtension
    );

IO_ALLOCATION_ACTION
SpBuildScatterGather(
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

BOOLEAN
SpGetInterruptState(
    IN PVOID ServiceContext
    );

VOID
SpTimerDpc(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

PLOGICAL_UNIT_EXTENSION
GetLogicalUnitExtension(
    PDEVICE_EXTENSION DeviceExtension,
    UCHAR TargetId
    );

NTSTATUS
SpInitializeConfiguration(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PHW_INITIALIZATION_DATA HwInitData,
    OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN BOOLEAN InitialCall
    );

NTSTATUS
SpGetCommonBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    ULONG NonCachedExtensionSize
    );

BOOLEAN
GetPciConfiguration(
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT DeviceObject,
    PPORT_CONFIGURATION_INFORMATION ConfigInformation,
    ULONG NumberOfAccessRanges,
    PVOID RegistryPath,
    BOOLEAN IsMultiFunction,
    PULONG BusNumber,
    PULONG SlotNumber,
    PULONG FunctionNumber
    );

BOOLEAN
FindPciDevice(
    PHW_INITIALIZATION_DATA HwInitializationData,
    PULONG BusNumber,
    PULONG SlotNumber,
    PULONG FunctionNumber,
    PBOOLEAN IsMultiFunction
    );

#ifdef i386
ULONG
HalpGetCmosData(
    IN ULONG    SourceLocation,
    IN ULONG    SourceAddress,
    IN PVOID    ReturnBuffer,
    IN ULONG    ByteCount
    );
#endif

VOID
ScsiPortInitializeMdlPages (
    IN OUT PMDL Mdl
    );

SCSI_ADAPTER_CONTROL_STATUS
SpCallAdapterControl(
    IN PDEVICE_EXTENSION Adapter,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    );

VOID
SpGetSupportedAdapterControlFunctions(
    PDEVICE_EXTENSION Adapter
    );

VOID
SpUnload(
    IN PDRIVER_OBJECT DriverObject
    );

//
// Routines start
//

BOOLEAN
GetNextPciBus(
    PULONG BusNumber
    )

/*++

Routine Description:

    Advance ConfigInformation to the next PCI bus if one exists in the
    system.  Advances the bus number and calls HalGetBusDataByOffset to
    see if the bus number is valid.

    Note: *BusNumber has already been scanned in its entirety, we
    simply advance to the start of the next bus.   No need to keep
    track of where we might be on this  bus.

Arguments:

    BusNumber   Pointer to a ULONG containing the last BusNumber tested.
                Will be updated to the next bus number if another PCI
                bus exists.

Return Value:

    TRUE    If ConfigInformation has been advanced,
    FALSE   If there are not more PCI busses in the system.

--*/

{
    ULONG  pciBus;
    USHORT pciData;
    ULONG  length = 0;

    pciBus = *BusNumber;

    DebugPrint((3,"GetNextPciBus: try to advance from bus %d\n", pciBus));

    if (++pciBus < 256) {
        length = HalGetBusDataByOffset(
                     PCIConfiguration,
                     pciBus,
                     0,                 // slot number
                     &pciData,
                     0,
                     sizeof(pciData));

        if (length == sizeof(pciData)) {

            //
            // HalGetBusDataByOffset returns zero when out of
            // busses.   If not out of busses it should always
            // succeed a length = 2 read at offset 0 even if
            // just to return PCI_INVALID_VENDORID.
            //

            *BusNumber = pciBus;
            return TRUE;
        }
    }
    DebugPrint((3,"GetNextPciBus: test bus %d returned %d\n", pciBus, length));
    return FALSE;
}

ULONG
ScsiPortInitialize(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN struct _HW_INITIALIZATION_DATA *HwInitializationData,
    IN PVOID HwContext
    )

/*++

Routine Description:

    This routine initializes the port driver.

Arguments:

    Argument1 - Pointer to driver object created by system
    HwInitializationData - Miniport initialization structure
    HwContext - Value passed to miniport driver's config routine

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    PDRIVER_OBJECT driverObject = Argument1;
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT deviceObject;
    BOOLEAN checkAdapterControl = FALSE;
    PORT_CONFIGURATION_INFORMATION configInfo;
    KEVENT allocateAdapterEvent;
    ULONG ExtensionAllocationSize;
    ULONG j;
    UCHAR scsiBus;
    PULONG scsiPortNumber;
    ULONG numberOfPageBreaks;
    PIO_SCSI_CAPABILITIES capabilities;
    BOOLEAN callAgain;
    UCHAR ldrString[] = {'n', 't', 'l', 'd','r','=', '1', ';', 0 };
    DEVICE_DESCRIPTION deviceDescription;
    ARC_CODES status;
    BOOLEAN isPci = FALSE;
    BOOLEAN isMultiFunction = FALSE;
    ULONG busNumber = 0;
    ULONG slotNumber = 0;
    ULONG functionNumber = 0;
    BOOLEAN foundOne = FALSE;

    UNREFERENCED_PARAMETER(Argument2);

    AEDriverUnloadRoutine = SpUnload;

    if (HwInitializationData->HwInitializationDataSize > sizeof(HW_INITIALIZATION_DATA)) {

        DebugPrint((0,"ScsiPortInitialize: Miniport driver wrong version\n"));
        return EBADF;
    }

    if (HwInitializationData->HwInitializationDataSize >= 
        (FIELD_OFFSET(HW_INITIALIZATION_DATA, HwAdapterControl) + 
         sizeof(PVOID))) {

        DebugPrint((2, "ScsiPortInitialize: Miniport may have adapter "
                       "control routine\n"));
        checkAdapterControl = TRUE;
    }

    //
    // Check that each required entry is not NULL.
    //

    if ((!HwInitializationData->HwInitialize) ||
        (!HwInitializationData->HwFindAdapter) ||
        (!HwInitializationData->HwResetBus)) {

        DebugPrint((0,
            "ScsiPortInitialize: Miniport driver missing required entry\n"));

        return EBADF;
    }

CallAgain:

    //
    // Get the configuration information
    //

    scsiPortNumber = &ScsiPortCount;

    //
    // Determine if there is room for the next port device object.
    //

    if (*scsiPortNumber >= MAXIMUM_NUMBER_OF_SCSIPORT_OBJECTS) {
        return foundOne ? ESUCCESS : EIO;
    }

    //
    // If this is a PCI card then do a quick scan to see if we can find 
    // the device.
    //

    if (HwInitializationData->AdapterInterfaceType == PCIBus &&
        HwInitializationData->VendorIdLength > 0 &&
        HwInitializationData->DeviceIdLength > 0 &&
        HwInitializationData->DeviceId &&
        HwInitializationData->VendorId) {

        if (!FindPciDevice(HwInitializationData,
                           &busNumber,
                           &slotNumber,
                           &functionNumber,
                           &isMultiFunction)) {

            DebugPrint((1,
                       "ScsiPortInitialize: FindPciDevice failed\n"));
            return foundOne ? ESUCCESS : EIO;
        }

        isPci = TRUE;
    }

    //
    // Determine size of extensions.
    //

    ExtensionAllocationSize = DEVICE_EXTENSION_SIZE +
        HwInitializationData->DeviceExtensionSize + sizeof(DEVICE_OBJECT);

    deviceObject = ExAllocatePool(NonPagedPool, ExtensionAllocationSize);

    if (deviceObject == NULL) {
        return ENOMEM;
    }

    RtlZeroMemory(deviceObject, ExtensionAllocationSize);

    //
    // Set up device extension pointers
    //

    deviceExtension = deviceObject->DeviceExtension = (PVOID) (deviceObject + 1);
    deviceExtension->DeviceObject = deviceObject;

    //
    // Save the dependent driver routines in the device extension.
    //

    deviceExtension->HwInitialize = HwInitializationData->HwInitialize;
    deviceExtension->HwStartIo = HwInitializationData->HwStartIo;
    deviceExtension->HwInterrupt = HwInitializationData->HwInterrupt;
    deviceExtension->HwReset = HwInitializationData->HwResetBus;
    deviceExtension->HwDmaStarted = HwInitializationData->HwDmaStarted;
    deviceExtension->HwLogicalUnitExtensionSize =
        HwInitializationData->SpecificLuExtensionSize;

    if(checkAdapterControl) {
        deviceExtension->HwAdapterControl = HwInitializationData->HwAdapterControl;
    }

    deviceExtension->HwDeviceExtension =
        (PVOID)(deviceExtension + 1);

    //
    // Set indicater as to whether adapter needs kernel mapped buffers.
    //

    deviceExtension->MapBuffers = HwInitializationData->MapBuffers;

    //
    // Mark this object as supporting direct I/O so that I/O system
    // will supply mdls in irps.
    //

    deviceObject->Flags |= DO_DIRECT_IO;

    //
    // Check if miniport driver requires any noncached memory.
    // SRB extensions will come from zoned memory. A page is
    // allocated as it is the smallest unit of noncached memory
    // allocation.
    //

    deviceExtension->SrbExtensionSize = HwInitializationData->SrbExtensionSize;

    //
    // Get the miniport configuration information.
    //

    capabilities = &deviceExtension->Capabilities;

    capabilities->Length = sizeof(IO_SCSI_CAPABILITIES);

    callAgain = FALSE;

    //
    // This call can't really fail - if it does something is seriously wrong and
    // should fail on the first try.
    //

    if (!NT_SUCCESS(SpInitializeConfiguration(
                        deviceExtension,
                        HwInitializationData,
                        &configInfo,
                        TRUE
                        ))) {

        DebugPrint((2, "ScsiPortInitialize: No config info found\n"));
        return(ENODEV);
    }

    configInfo.NumberOfAccessRanges = HwInitializationData->NumberOfAccessRanges;

    configInfo.AccessRanges = ExAllocatePool(NonPagedPool,
                                             sizeof(ACCESS_RANGE) *
                                             HwInitializationData->NumberOfAccessRanges);

    if (configInfo.AccessRanges == NULL) {

        //
        // We're out of memory - it's probably not worth continuing on to 
        // try and find more adapters.
        //

        return (foundOne ? ESUCCESS : EIO);
    }

    RtlZeroMemory(configInfo.AccessRanges,
        HwInitializationData->NumberOfAccessRanges * sizeof(ACCESS_RANGE));

    //
    // Initialize configuration information with slot information if PCI bus.
    //

    if (isPci) {

        if (!GetPciConfiguration(driverObject,
                                 deviceObject,
                                 &configInfo,
                                 HwInitializationData->NumberOfAccessRanges,
                                 Argument2,
                                 isMultiFunction,
                                 &busNumber,
                                 &slotNumber,
                                 &functionNumber)) {

            DebugPrint((1,
                       "ScsiPortInitialize: GetPciConfiguration failed\n"));
            return foundOne ? ESUCCESS : EIO;
        }

        //
        // Call miniport driver's find adapter routine to search for adapters.
        //

        if (HwInitializationData->HwFindAdapter(
                 deviceExtension->HwDeviceExtension,    // DeviceExtension
                 HwContext,                             // HwContext
                 NULL,                                  // BusInformation
                 (PCHAR)ldrString,                     // ArgumentString
                 &configInfo,                           // ConfigurationInformation
                 &callAgain                             // Again
                 ) != SP_RETURN_FOUND) {

            return foundOne ? ESUCCESS : EIO;
        }
    } else {

        //
        // Not PCI, or PCI but the miniport is fundamentally broken
        // and wants to do its own search.
        //

        //
        // Starting at the current config, examine each bus
        // until we run out of busses.
        //

        configInfo.SystemIoBusNumber = busNumber;

        if (HwInitializationData->HwFindAdapter(
                 deviceExtension->HwDeviceExtension,    // DeviceExtension
                 HwContext,                             // HwContext
                 NULL,                                  // BusInformation
                 (PCHAR)ldrString,                     // ArgumentString
                 &configInfo,                           // ConfigurationInformation
                 &callAgain                             // Again
                 ) != SP_RETURN_FOUND) {

            //
            // No device found on this bus, try next bus.
            //

            if ((HwInitializationData->AdapterInterfaceType != PCIBus) ||
                !GetNextPciBus(&busNumber)) {

                return foundOne ? ESUCCESS : EIO;
            }

            goto CallAgain;
        }
    }

    DebugPrint((1,"ScsiPortInitialize: SCSI adapter IRQ is %d\n",
        configInfo.BusInterruptLevel));

    DebugPrint((1,"ScsiPortInitialize: SCSI adapter ID is %d\n",
        configInfo.InitiatorBusId[0]));

    deviceExtension->NumberOfBuses = configInfo.NumberOfBuses;

    //
    // Free the pointer to the bus data at map register base.  This was
    // allocated by ScsiPortGetBusData.
    //

    if (deviceExtension->MapRegisterBase != NULL) {
        ExFreePool(deviceExtension->MapRegisterBase);
    }

    //
    // Get the adapter object for this card.
    //

    if ( deviceExtension->DmaAdapterObject == NULL &&
        (configInfo.Master || configInfo.DmaChannel != 0xFFFFFFFF) ) {

        deviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
        deviceDescription.DmaChannel = configInfo.DmaChannel;
        deviceDescription.InterfaceType = configInfo.AdapterInterfaceType;
        deviceDescription.BusNumber = configInfo.SystemIoBusNumber;
        deviceDescription.DmaWidth = configInfo.DmaWidth;
        deviceDescription.DmaSpeed = configInfo.DmaSpeed;
        deviceDescription.DmaPort = configInfo.DmaPort;
        deviceDescription.MaximumLength = configInfo.MaximumTransferLength;
        deviceDescription.ScatterGather = configInfo.ScatterGather;
        deviceDescription.Master = configInfo.Master;
        deviceDescription.AutoInitialize = FALSE;
        deviceDescription.DemandMode = FALSE;

        if (configInfo.MaximumTransferLength > 0x11000) {

            deviceDescription.MaximumLength = 0x11000;

        } else {

            deviceDescription.MaximumLength = configInfo.MaximumTransferLength;

        }

        deviceExtension->DmaAdapterObject = HalGetAdapter(
            &deviceDescription,
            &numberOfPageBreaks
            );

        //
        // Set maximum number of page breaks.
        //

        if (numberOfPageBreaks > configInfo.NumberOfPhysicalBreaks) {
            capabilities->MaximumPhysicalPages = configInfo.NumberOfPhysicalBreaks;
        } else {
            capabilities->MaximumPhysicalPages = numberOfPageBreaks;
        }

    }

    //
    // Allocate memory for the non cached extension if it has not already been
    // allocated.  If we can't get any abort the search for adapters but 
    // succeed if we've managed to initialize at least one.
    //

    if (deviceExtension->SrbExtensionSize != 0 &&
        deviceExtension->SrbExtensionZonePool == NULL) {

        status = SpGetCommonBuffer(deviceExtension, 0);

        if (status != ESUCCESS) {

            return (foundOne ? ESUCCESS : status);
        }
    }

    capabilities->Length = sizeof(IO_SCSI_CAPABILITIES);
    capabilities->MaximumTransferLength = configInfo.MaximumTransferLength;
    DebugPrint((1,
               "Maximum physical page breaks = %d. Maximum transfer length = %x\n",
               capabilities->MaximumPhysicalPages,
               capabilities->MaximumTransferLength));

    if (HwInitializationData->ReceiveEvent) {
        capabilities->SupportedAsynchronousEvents |=
            SRBEV_SCSI_ASYNC_NOTIFICATION;
    }

    capabilities->TaggedQueuing = HwInitializationData->TaggedQueuing;
    capabilities->AdapterScansDown = configInfo.AdapterScansDown;
    capabilities->AlignmentMask = configInfo.AlignmentMask;

    //
    // Make sure maximum nuber of pages is set to a reasonable value.
    // This occurs for mini-ports with no Dma adapter.
    //

    if (capabilities->MaximumPhysicalPages == 0) {

        capabilities->MaximumPhysicalPages =
                (ULONG)ROUND_TO_PAGES(capabilities->MaximumTransferLength) + 1;

        //
        // Honor any limit requested by the mini-port.
        //

        if (configInfo.NumberOfPhysicalBreaks < capabilities->MaximumPhysicalPages) {

            capabilities->MaximumPhysicalPages =
                configInfo.NumberOfPhysicalBreaks;
        }
    }

    //
    // Get maximum target IDs.
    //

    if (configInfo.MaximumNumberOfTargets > SCSI_MAXIMUM_TARGETS_PER_BUS) {
        deviceExtension->MaximumTargetIds = SCSI_MAXIMUM_TARGETS_PER_BUS;
    } else {
        deviceExtension->MaximumTargetIds =
            configInfo.MaximumNumberOfTargets;
    }

    if (deviceExtension->DmaAdapterObject != NULL &&
        !HwInitializationData->NeedPhysicalAddresses) {

        //
        // Allocate the adapter object.  For the port driver the adapter object
        // and map registers are permentently allocated and used  shared between
        // all logical units.  The adapter is allocated by initializing an event,
        // calling IoAllocateAdapterChannel and waiting on the event.  When the
        // adapter and map registers are available, ScsiPortAllocationRoutine is
        // called which set the event.  In reality, all this takes zero time since
        // the stuff is available immediately.
        //
        // Allocate the AdapterObject.  The number of registers is equal to the
        // maximum transfer length supported by the adapter + 1.  This insures
        // that there will always be a sufficient number of registers.
        //
        /* TODO: Fix this for the case when there is no maximum transfer length. */

        IoAllocateAdapterChannel(
            deviceExtension->DmaAdapterObject,
            deviceObject,
            capabilities->MaximumPhysicalPages,
            ScsiPortAllocationRoutine,
            &allocateAdapterEvent
            );

        //
        // Wait for adapter object.
        //

        ASSERT(deviceExtension->MapRegisterBase);

        deviceExtension->MasterWithAdapter = FALSE;

    } else if (deviceExtension->DmaAdapterObject != NULL) {

        //
        // This SCSI adapter is a master with an adapter so a scatter/gather
        // list needs to be allocated for each transfer.
        //

        deviceExtension->MasterWithAdapter = TRUE;

    } else {

        deviceExtension->MasterWithAdapter = FALSE;

    } // end if (deviceExtension->DmaAdapterObject != NULL)

    //
    // Call the hardware dependent driver to do its initialization.  If it fails
    // then continue the search for adapters.
    //

    if (!KeSynchronizeExecution(
            deviceExtension->InterruptObject,
            deviceExtension->HwInitialize,
            deviceExtension->HwDeviceExtension
            )) {

        DebugPrint((1,"ScsiPortInitialize: initialization failed\n"));

        if(callAgain) {
            goto CallAgain;
        } else {
            return foundOne ? ESUCCESS : ENODEV;
        }
    }

    //
    // Find out if the miniport supports AdapterControl routines to shutdown.
    //

    SpGetSupportedAdapterControlFunctions(deviceExtension);

    //
    // Allocate properly aligned INQUIRY buffer.  If we can't get one we're 
    // out of memory so searching for more adapters is pointless.
    //

    InquiryDataBuffer = ExAllocatePool(NonPagedPool, INQUIRYDATABUFFERSIZE);

    if (InquiryDataBuffer == NULL) {
        return foundOne ? ESUCCESS : ENOMEM;
    }

    //
    // Reset the scsi bus.
    //

    if (!deviceExtension->HwReset(
        deviceExtension->HwDeviceExtension,
        0)){

        DebugPrint((1,"Reset SCSI bus failed\n"));
    }

    //
    // Call the interupt handler for a few microseconds to clear any reset
    // interrupts.
    //

    for (j = 0; j < 1000 * 100; j++) {

        FwStallExecution(10);
        if (deviceExtension->HwInterrupt != NULL) {
            deviceExtension->HwInterrupt(deviceExtension->HwDeviceExtension);
        }
    }

    deviceExtension->PortTimeoutCounter = PD_TIMER_RESET_HOLD_TIME;
    SpCheckResetDelay( deviceExtension );

    //
    // Find devices on each SCSI bus.
    //

    //
    // Allocate buffer for SCSI bus scan information.
    //

    deviceExtension->ScsiInfo = ExAllocatePool(NonPagedPool,
                   deviceExtension->NumberOfBuses * sizeof(PSCSI_BUS_SCAN_DATA) +
                    4);

    if (deviceExtension->ScsiInfo) {

        deviceExtension->ScsiInfo->NumberOfBuses = deviceExtension->NumberOfBuses;

        //
        // Find devices on each SCSI bus.
        //

        for (scsiBus = 0; scsiBus < deviceExtension->NumberOfBuses; scsiBus++) {
            deviceExtension->ScsiInfo->BusScanData[scsiBus] =
                ScsiBusScan(deviceExtension,
                            scsiBus,
                            configInfo.InitiatorBusId[scsiBus]);
        }
    }

    //
    // Save the device object for use by the driver.
    //

    ScsiPortDeviceObject[*scsiPortNumber] = deviceObject;

    //
    // Bump SCSI host bus adapters count.
    //

    (*scsiPortNumber)++;

    foundOne = TRUE;

    //
    // If the adapter wants to be called again with the same configuration data
    // then start over from the beginning again.
    //

    if (callAgain) {
        goto CallAgain;
    }

    return ESUCCESS;

} // end ScsiPortInitialize()

IO_ALLOCATION_ACTION
ScsiPortAllocationRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )

/*++

Routine Description:

    This function is called by IoAllocateAdapterChannel when sufficent resources
    are available to the driver.  This routine saves the MapRegisterBase in the
    device object and set the event pointed to by the context parameter.

Arguments:

    DeviceObject - Pointer to the device object to which the adapter is being
        allocated.

    Irp - Unused.

    MapRegisterBase - Supplied by the Io subsystem for use in IoMapTransfer.

    Context - Supplies a pointer to an event which is set to indicate the
        AdapterObject has been allocated.

Return Value:

    KeepObject - Indicates the adapter and mapregisters should remain allocated
        after return.

--*/

{
    ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->MapRegisterBase =
        MapRegisterBase;

    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(Context);

    return(KeepObject);
}

IO_ALLOCATION_ACTION
SpBuildScatterGather(
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )

/*++

Routine Description:

    This function is called by the I/O system when an adapter object and map
    registers have been allocated.  This routine then builds a scatter/gather
    list for use by the mini-port driver.  Next it sets the timeout and
    the current Irp for the logical unit.  Finally it calls the mini-port
    StartIo routine.  Once that routines complete, this routine will return
    requesting that the adapter be freed and but the registers remain allocated.
    The registers will be freed the request completes.

Arguments:

    DeviceObject - Supplies a pointer to the port driver device object.

    Irp - Supplies a pointer to the current Irp.

    MapRegisterBase - Supplies a context pointer to be used with calls the
        adapter object routines.

    Context - Supplies a pointer to the logical unit structure.

Return Value:

    Returns DeallocateObjectKeepRegisters so that the adapter object can be
        used by other logical units.

--*/

{
    BOOLEAN writeToDevice;
    PIO_STACK_LOCATION irpstack = IoGetCurrentIrpStackLocation(Irp);
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSCSI_REQUEST_BLOCK srb;
    PSRB_SCATTER_GATHER scatterList;
    ULONG totalLength;

    logicalUnit = Context;
    srb = (PSCSI_REQUEST_BLOCK)irpstack->Parameters.Others.Argument1;
    scatterList = logicalUnit->ScatterGather;
    totalLength = 0;

    //
    // Save the MapRegisterBase for later use to deallocate the map registers.
    //

    logicalUnit->MapRegisterBase = MapRegisterBase;

    //
    // Build the scatter/gather list by looping throught the transfer calling
    // I/O map transfer.
    //

    writeToDevice = srb->SrbFlags & SRB_FLAGS_DATA_OUT ? TRUE : FALSE;

    while (totalLength < srb->DataTransferLength) {

        //
        // Request that the rest of the transfer be mapped.
        //

        scatterList->Length = srb->DataTransferLength - totalLength;

        //
        // Since we are a master call I/O map transfer with a NULL adapter.
        //

        scatterList->PhysicalAddress = IoMapTransfer(
            NULL,
            Irp->MdlAddress,
            MapRegisterBase,
            (PCCHAR) srb->DataBuffer + totalLength,
            &scatterList->Length,
            writeToDevice
            ).LowPart;

        totalLength += scatterList->Length;
        scatterList++;
    }

    //
    // Set request timeout value from Srb SCSI extension in Irp.
    //

    logicalUnit->RequestTimeoutCounter = srb->TimeOutValue;

    //
    // Set current request for this logical unit.
    //

    logicalUnit->CurrentRequest = Irp;

    /* TODO: Check the return value. */
    KeSynchronizeExecution(
        ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->InterruptObject,
        SpStartIoSynchronized,
        DeviceObject
        );

    return(DeallocateObjectKeepRegisters);

}

VOID
ScsiPortExecute(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine calls the start I/O routine an waits for the request to
    complete.  During the wait for complete the interrupt routine is called,
    also the timer routines are called at the appropriate times.  After the
    request completes a check is made to determine if an request sense needs
    to be issued.

Arguments:

    DeviceObject - Supplies pointer to Adapter device object.

    Irp - Supplies a pointer to an IRP.

Return Value:

    Nothing.

--*/

{
    ULONG milliSecondTime;
    ULONG secondTime;
    ULONG completionDelay;
    PDEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpstack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = (PSCSI_REQUEST_BLOCK)irpstack->Parameters.Others.Argument1;
    PVOID logicalUnit;

    deviceExtension = DeviceObject->DeviceExtension;
    logicalUnit = GetLogicalUnitExtension(deviceExtension, srb->TargetId);

    if (logicalUnit == NULL) {
       Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
       srb->SrbStatus = SRB_STATUS_NO_DEVICE;
       return;
    }

    //
    // Make sure the adapter is ready to accept requests.
    //

    SpCheckResetDelay( deviceExtension );

    //
    // Mark IRP as pending.
    //

    Irp->PendingReturned = TRUE;

    //
    // Start the request.
    //

    ScsiPortStartIo( DeviceObject, Irp);

    //
    // The completion delay controls how long interrupts are serviced after
    // a request has been completed.  This allows interrupts which occur after
    // a completion to be serviced.
    //

    completionDelay = COMPLETION_DELAY;

    //
    // Wait for the IRP to complete.
    //

    while (Irp->PendingReturned && completionDelay) {

        //
        // Wait 1 second then call the scsi port timer routine.
        //

        for (secondTime = 0; secondTime < 1000/ 250; secondTime++) {

            for (milliSecondTime = 0; milliSecondTime < (250 * 1000 / PD_INTERLOOP_STALL); milliSecondTime++) {

                ScsiPortInterrupt(NULL, DeviceObject);

                if (!Irp->PendingReturned) {
                    if (completionDelay-- == 0) {
                        goto done;
                    }
                }

                if (deviceExtension->Flags & PD_ENABLE_CALL_REQUEST) {

                    //
                    // Call the mini-port requested routine.
                    //

                    deviceExtension->Flags &= ~PD_ENABLE_CALL_REQUEST;
                    deviceExtension->HwRequestInterrupt(deviceExtension->HwDeviceExtension);

                    if (deviceExtension->Flags & PD_DISABLE_CALL_REQUEST) {

                        deviceExtension->Flags &= ~(PD_DISABLE_INTERRUPTS | PD_DISABLE_CALL_REQUEST);
                        deviceExtension->HwRequestInterrupt(deviceExtension->HwDeviceExtension);

                    }
                }


                if (deviceExtension->Flags & PD_CALL_DMA_STARTED) {

                    deviceExtension->Flags &= ~PD_CALL_DMA_STARTED;

                    //
                    // Notify the mini-port driver that the DMA has been
                    // started.
                    //

                    if (deviceExtension->HwDmaStarted) {
                        KeSynchronizeExecution(
                            &deviceExtension->InterruptObject,
                            (PKSYNCHRONIZE_ROUTINE) deviceExtension->HwDmaStarted,
                            deviceExtension->HwDeviceExtension
                            );
                    }

                }

                FwStallExecution(PD_INTERLOOP_STALL);

                //
                // Check the miniport timer.
                //

                if (deviceExtension->TimerValue != 0) {

                    deviceExtension->TimerValue--;

                    if (deviceExtension->TimerValue == 0) {

                        //
                        // The timer timed out so called requested timer routine.
                        //

                        deviceExtension->HwTimerRequest(deviceExtension->HwDeviceExtension);
                    }
                }
            }
        }

        ScsiPortTickHandler(DeviceObject, NULL);
    }

done:

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        PSCSI_REQUEST_BLOCK Srb;

        irpstack = IoGetCurrentIrpStackLocation(Irp);
        Srb = (PSCSI_REQUEST_BLOCK)irpstack->Parameters.Others.Argument1;

        //
        // Determine if a REQUEST SENSE command needs to be done.
        // Check that a CHECK_CONDITION was received, an autosense has not
        // been done already, and that autosense has been requested.
        //

        if (srb->ScsiStatus == SCSISTAT_CHECK_CONDITION &&
            !(srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID)  &&
            srb->SenseInfoBuffer) {

            //
            // Call IssueRequestSense and it will complete the request after
            // the REQUEST SENSE completes.
            //

            IssueRequestSense(deviceExtension, Srb);
        }
    }
}

VOID
ScsiPortStartIo (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

    DeviceObject - Supplies pointer to Adapter device object.
    Irp - Supplies a pointer to an IRP.

Return Value:

    Nothing.

--*/

{
    PIO_STACK_LOCATION irpstack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK Srb = (PSCSI_REQUEST_BLOCK)irpstack->Parameters.Others.Argument1;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PFULL_SCSI_REQUEST_BLOCK FullSrb;
    NTSTATUS status;

    DebugPrint((3,"ScsiPortStartIo: Enter routine\n"));

    FullSrb = CONTAINING_RECORD(Srb, FULL_SCSI_REQUEST_BLOCK, Srb);

    if (deviceExtension->SrbExtensionZonePool && 
        (Srb->SrbExtension == NULL || 
         (deviceExtension->SrbExtensionSize > FullSrb->SrbExtensionSize))) {

        //
        // Allocate SRB extension from zone.
        //

        Srb->SrbExtension = deviceExtension->SrbExtensionPointer;

        (PCCHAR) deviceExtension->SrbExtensionPointer +=
            deviceExtension->SrbExtensionSize;

        FullSrb->SrbExtensionSize = deviceExtension->SrbExtensionSize;

        if ((ULONG_PTR) deviceExtension->SrbExtensionPointer >
            (ULONG_PTR) deviceExtension->NonCachedExtension) {
            DebugPrint((0, "NtLdr: ScsiPortStartIo: Srb extension overflow.  Too many srb extension allocated.\n"));
            DbgBreakPoint();
        }

        DebugPrint((3,"ExInterlockedAllocateFromZone: %lx\n",
            Srb->SrbExtension));

        DebugPrint((3,"Srb %lx\n",Srb));
    }

    //
    // Get logical unit extension.
    //

    logicalUnit = GetLogicalUnitExtension(deviceExtension, Srb->TargetId);

    //
    // Flush the data buffer if necessary.
    //

    if (Srb->SrbFlags & (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)) {

        if (Srb->DataTransferLength > deviceExtension->Capabilities.MaximumTransferLength) {

            DebugPrint((1, "Scsiboot: ScsiPortStartIo Length Exceeds limit %x, %x\n",
                Srb->DataTransferLength,
                deviceExtension->Capabilities.MaximumTransferLength));
        }

        KeFlushIoBuffers(
            Irp->MdlAddress,
            (BOOLEAN) (Srb->SrbFlags & SRB_FLAGS_DATA_IN ? TRUE : FALSE),
            TRUE
            );

        //
        // Determine if this adapter needs map registers
        //

        if (deviceExtension->MasterWithAdapter) {

            //
            // Calculate the number of map registers needed for this transfer.
            //

            logicalUnit->NumberOfMapRegisters = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                    Srb->DataBuffer,
                    Srb->DataTransferLength
                    );

            //
            // Allocate the adapter channel with sufficient map registers
            // for the transfer.
            //

            status = IoAllocateAdapterChannel(
                deviceExtension->DmaAdapterObject,  // AdapterObject
                DeviceObject,                       // DeviceObject.
                logicalUnit->NumberOfMapRegisters,  // NumberOfMapRegisters
                SpBuildScatterGather,               // ExecutionRoutine
                logicalUnit                         // Context
                );

            if (!NT_SUCCESS(status)) {

                ;
            }

            //
            // The execution routine called by IoAllocateChannel will do the
            // rest of the work so just return.
            //

            return;
        }
    }

    //
    // Set request timeout value from Srb SCSI extension in Irp.
    //

    logicalUnit->RequestTimeoutCounter = Srb->TimeOutValue;

    //
    // Set current request for this logical unit.
    //

    logicalUnit->CurrentRequest = Irp;

    /* TODO: Check the return value. */
    KeSynchronizeExecution(
        deviceExtension->InterruptObject,
        SpStartIoSynchronized,
        DeviceObject
        );

    return;

} // end ScsiPortStartIO()


BOOLEAN
SpStartIoSynchronized (
    PVOID ServiceContext
    )

/*++

Routine Description:

    This routine calls the dependent driver start io routine.

Arguments:

    ServiceContext - Supplies the pointer to the device object.

Return Value:

    Returns the value returned by the dependent start I/O routine.


--*/

{
    PDEVICE_OBJECT DeviceObject = ServiceContext;
    PDEVICE_EXTENSION deviceExtension =  DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpstack;
    PSCSI_REQUEST_BLOCK Srb;

    DebugPrint((3, "ScsiPortStartIoSynchronized: Enter routine\n"));

    irpstack = IoGetCurrentIrpStackLocation(DeviceObject->CurrentIrp);
    Srb = (PSCSI_REQUEST_BLOCK)irpstack->Parameters.Others.Argument1;

    DebugPrint((3, "SpPortStartIoSynchronized: SRB %lx\n",
        Srb));

    DebugPrint((3, "SpPortStartIoSynchronized: IRP %lx\n",
        DeviceObject->CurrentIrp));

    //
    // Disable all synchronous transfers.
    //

    Srb->SrbFlags |=
        (SRB_FLAGS_DISABLE_SYNCH_TRANSFER | SRB_FLAGS_DISABLE_DISCONNECT | SRB_FLAGS_DISABLE_AUTOSENSE);

    return deviceExtension->HwStartIo(
        deviceExtension->HwDeviceExtension,
        Srb
        );

} // end SpStartIoSynchronized()


BOOLEAN
ScsiPortInterrupt(
    IN PKINTERRUPT Interrupt,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:


Arguments:

    Interrupt

    Device Object

Return Value:

    Returns TRUE if interrupt expected.

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER(Interrupt);

    if (deviceExtension->Flags & PD_DISABLE_INTERRUPTS) {
        return FALSE;
    }

    if (deviceExtension->HwInterrupt != NULL) {

        if (deviceExtension->HwInterrupt(deviceExtension->HwDeviceExtension)) {

            return TRUE;

        } else {

            return FALSE;
        }
    }

    return(FALSE);

} // end ScsiPortInterrupt()


VOID
ScsiPortCompletionDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

    Dpc
    DeviceObject
    Irp - not used
    Context - not used

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpstack;
    PSCSI_REQUEST_BLOCK Srb;
    PLOGICAL_UNIT_EXTENSION luExtension;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(Context);

    DebugPrint((3, "ScsiPortCompletionDpc Entered\n"));

    //
    // Acquire the spinlock to protect the flags structure and the saved
    // interrupt context.
    //

    KeAcquireSpinLock(&deviceExtension->SpinLock, &currentIrql);

    //
    // Check for a flush DMA adapter object request.
    //

    if (deviceExtension->InterruptFlags & PD_FLUSH_ADAPTER_BUFFERS) {

        //
        // Call IoFlushAdapterBuffers using the parameters saved from the last
        // IoMapTransfer call.
        //

        IoFlushAdapterBuffers(
            deviceExtension->DmaAdapterObject,
            ((PIRP)deviceExtension->FlushAdapterParameters.Srb->OriginalRequest)
                ->MdlAddress,
            deviceExtension->MapRegisterBase,
            deviceExtension->FlushAdapterParameters.LogicalAddress,
            deviceExtension->FlushAdapterParameters.Length,
            (BOOLEAN)(deviceExtension->FlushAdapterParameters.Srb->SrbFlags
                & SRB_FLAGS_DATA_OUT ? TRUE : FALSE)
            );

        deviceExtension->InterruptFlags &= ~PD_FLUSH_ADAPTER_BUFFERS;
    }

    //
    // Check for an IoMapTransfer DMA request.
    //

    if (deviceExtension->InterruptFlags & PD_MAP_TRANSFER) {

        //
        // Call IoMapTransfer using the parameters saved from the
        // interrupt level.
        //

        IoMapTransfer(
            deviceExtension->DmaAdapterObject,
            ((PIRP)deviceExtension->MapTransferParameters.Srb->OriginalRequest)
                ->MdlAddress,
            deviceExtension->MapRegisterBase,
            deviceExtension->MapTransferParameters.LogicalAddress,
            &deviceExtension->MapTransferParameters.Length,
            (BOOLEAN)(deviceExtension->MapTransferParameters.Srb->SrbFlags
                & SRB_FLAGS_DATA_OUT ? TRUE : FALSE)
            );

        //
        // Save the paramters for IoFlushAdapterBuffers.
        //

        deviceExtension->FlushAdapterParameters =
            deviceExtension->MapTransferParameters;

        deviceExtension->InterruptFlags &= ~PD_MAP_TRANSFER;
        deviceExtension->Flags |= PD_CALL_DMA_STARTED;

    }

    //
    // Process any completed requests.
    //

    while (deviceExtension->CompletedRequests != NULL) {

        Irp = deviceExtension->CompletedRequests;
        irpstack = IoGetCurrentIrpStackLocation(Irp);
        Srb = (PSCSI_REQUEST_BLOCK)irpstack->Parameters.Others.Argument1;
        luExtension =
                GetLogicalUnitExtension(deviceExtension, Srb->TargetId);

        DebugPrint((3, "ScsiPortCompletionDpc: SRB %lx\n", Srb));
        DebugPrint((3, "ScsiPortCompletionDpc: IRP %lx\n", Irp));

        //
        // Remove the request from the linked-list.
        //

        deviceExtension->CompletedRequests =
            irpstack->Parameters.Others.Argument3;

        //
        // Check for very unlikely return of NULL.
        //
        if (luExtension == NULL) {

            ASSERT(luExtension != NULL); // Debug why this happened.  It should not.

            //
            // But in retail, if some reason it did, complete the IRP and continue.
            //
            Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            Irp->IoStatus.Information = Srb->DataTransferLength;

            //
            // Free SrbExtension if allocated.
            //
            if (Srb->SrbExtension == (deviceExtension->SrbExtensionPointer -
                                      deviceExtension->SrbExtensionSize) ) {

                Srb->SrbExtension = NULL;

                (PCCHAR) deviceExtension->SrbExtensionPointer -=
                                        deviceExtension->SrbExtensionSize;
            }

            IoCompleteRequest(Irp, 2);
            continue;
        }

        //
        // Reset request timeout counter.
        //

        luExtension->RequestTimeoutCounter = -1;

        //
        // Flush the adapter buffers if necessary.
        //

        if (luExtension->MapRegisterBase) {

            //
            // Since we are a master call I/O flush adapter buffers with a NULL
            // adapter.
            //

            IoFlushAdapterBuffers(
                NULL,
                Irp->MdlAddress,
                luExtension->MapRegisterBase,
                Srb->DataBuffer,
                Srb->DataTransferLength,
                (BOOLEAN) (Srb->SrbFlags & SRB_FLAGS_DATA_OUT ? TRUE : FALSE)
                );

            //
            // Free the map registers.
            //

            IoFreeMapRegisters(
                deviceExtension->DmaAdapterObject,
                luExtension->MapRegisterBase,
                luExtension->NumberOfMapRegisters
                );

            //
            // Clear the MapRegisterBase.
            //

            luExtension->MapRegisterBase = NULL;

        }

        //
        // Set IRP status. Class drivers will reset IRP status based
        // on request sense if error.
        //

        if (SRB_STATUS(Srb->SrbStatus) == SRB_STATUS_SUCCESS) {
            Irp->IoStatus.Status = STATUS_SUCCESS;
        } else {
            Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        }

        //
        // Move bytes transfered to IRP.
        //

        Irp->IoStatus.Information = Srb->DataTransferLength;

        //
        // If success then start next packet.
        // Not starting packet effectively
        // freezes the queue.
        //

        if (SRB_STATUS(Srb->SrbStatus) == SRB_STATUS_SUCCESS) {

            DebugPrint((
                2,
                "ScsiPortCompletionDpc: Iocompletion IRP %lx\n",
                Irp));

            //
            // Free SrbExtension if allocated.
            //

            if (Srb->SrbExtension == (deviceExtension->SrbExtensionPointer -
                                      deviceExtension->SrbExtensionSize) ) {

                Srb->SrbExtension = NULL;

                (PCCHAR) deviceExtension->SrbExtensionPointer -=
                                            deviceExtension->SrbExtensionSize;
            }

            IoCompleteRequest(Irp, 2);

        } else {

            if ( Srb->ScsiStatus == SCSISTAT_BUSY &&
                (luExtension->RetryCount++ < 20)) {
                //
                // If busy status is returned, then indicate that the logical
                // unit is busy.  The timeout code will restart the request
                // when it fires. Reset the status to pending.
                //
                Srb->SrbStatus = SRB_STATUS_PENDING;
                luExtension->CurrentRequest = Irp;
                luExtension->Flags |= PD_LOGICAL_UNIT_IS_BUSY;

                //
                // Restore the data transfer length.
                //

                if (Irp->MdlAddress != NULL) {
                    Srb->DataTransferLength = Irp->MdlAddress->ByteCount;
                }

                DebugPrint((1, "ScsiPortCompletionDpc: Busy returned.  Length = %lx\n", Srb->DataTransferLength));

            } else {


                DebugPrint((
                    3,
                    "ScsiPortCompletionDpc: Iocompletion IRP %lx\n",
                    Irp));

                //
                // Free SrbExtension if allocated.
                //

                if (Srb->SrbExtension == (deviceExtension->SrbExtensionPointer -
                                          deviceExtension->SrbExtensionSize) ) {

                    Srb->SrbExtension = NULL;

                    (PCCHAR) deviceExtension->SrbExtensionPointer -=
                                            deviceExtension->SrbExtensionSize;
                }

                IoCompleteRequest(Irp, 2);
            }
        }
    }

    //
    // Release the spinlock.
    //

    KeReleaseSpinLock(&deviceExtension->SpinLock, currentIrql);

    return;

} // end ScsiPortCompletionDpc()


ARC_STATUS
IssueInquiry(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PLUNINFO LunInfo
    )

/*++

Routine Description:

    Build IRP, SRB and CDB for SCSI INQUIRY command.

Arguments:

    DeviceExtension - address of adapter's device object extension.
    LunInfo - address of buffer for INQUIRY information.

Return Value:

    ARC_STATUS

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpstack;
    PCDB cdb;
    PSCSI_REQUEST_BLOCK srb;
    ARC_STATUS status;
    ULONG retryCount = 0;

    DebugPrint((3,"IssueInquiry: Enter routine\n"));

    if (InquiryDataBuffer == NULL) {
        return ENOMEM;
    }

inquiryRetry:

    //
    // Build IRP for this request.
    //

    irp = InitializeIrp(
                &PrimarySrb,
                IRP_MJ_SCSI,
                DeviceExtension->DeviceObject,
                (PVOID)InquiryDataBuffer,
                INQUIRYDATABUFFERSIZE
                );

    irpstack = IoGetNextIrpStackLocation(irp);

    //
    // Set major and minor codes.
    //

    irpstack->MajorFunction = IRP_MJ_SCSI;

    //
    // Fill in SRB fields.
    //

    irpstack->Parameters.Others.Argument1 = &PrimarySrb;
    srb = &PrimarySrb.Srb;

    srb->Length = sizeof(SCSI_REQUEST_BLOCK);
    srb->PathId = LunInfo->PathId;
    srb->TargetId = LunInfo->TargetId;
    srb->Lun = LunInfo->Lun;

    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER | SRB_FLAGS_DISABLE_DISCONNECT;

    srb->SrbStatus = srb->ScsiStatus = 0;

    srb->OriginalRequest = irp;

    srb->NextSrb = 0;

    //
    // Set timeout to 5 seconds.
    //

    srb->TimeOutValue = 5;

    srb->CdbLength = 6;

    srb->SenseInfoBufferLength = 0;
    srb->SenseInfoBuffer = 0;

    srb->DataBuffer = MmGetMdlVirtualAddress(irp->MdlAddress);
    srb->DataTransferLength = INQUIRYDATABUFFERSIZE;

    cdb = (PCDB)srb->Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set CDB LUN.
    //

    cdb->CDB6INQUIRY.LogicalUnitNumber = LunInfo->Lun;
    cdb->CDB6INQUIRY.Reserved1 = 0;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = INQUIRYDATABUFFERSIZE;

    //
    // Zero reserve field and
    // Set EVPD Page Code to zero.
    // Set Control field to zero.
    // (See SCSI-II Specification.)
    //

    cdb->CDB6INQUIRY.PageCode = 0;
    cdb->CDB6INQUIRY.IReserved = 0;
    cdb->CDB6INQUIRY.Control = 0;

    //
    // Call port driver to handle this request.
    //

    (VOID)IoCallDriver(DeviceExtension->DeviceObject, irp);


    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        DebugPrint((2,"IssueInquiry: Inquiry failed SRB status %x\n",
            srb->SrbStatus));

        //
        // NOTE: if INQUIRY fails with a data underrun,
        //      indicate success and let the class drivers
        //      determine whether the inquiry information
        //      is useful.
        //

        if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

            //
            // Copy INQUIRY buffer to LUNINFO.
            //

            DebugPrint((1,"IssueInquiry: Data underrun at TID %d\n",
                LunInfo->TargetId));

            RtlMoveMemory(LunInfo->InquiryData,
                      InquiryDataBuffer,
                      INQUIRYDATABUFFERSIZE);

            status = STATUS_SUCCESS;

        } else if ((SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SELECTION_TIMEOUT) && (retryCount++ < 2)) {

            //
            // If the selection did not time out then retry the request.
            //

            DebugPrint((2,"IssueInquiry: Retry %d\n", retryCount));
            goto inquiryRetry;

        } else {

            status = EIO;

        }

    } else {

        //
        // Copy INQUIRY buffer to LUNINFO.
        //

        RtlMoveMemory(LunInfo->InquiryData,
                      InquiryDataBuffer,
                      INQUIRYDATABUFFERSIZE);

        status = STATUS_SUCCESS;
    }

    return status;

} // end IssueInquiry()


PSCSI_BUS_SCAN_DATA
ScsiBusScan(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN UCHAR ScsiBus,
    IN UCHAR InitiatorBusId
    )

/*++

Routine Description:

Arguments:

    DeviceExtension
    ScsiBus

Return Value:

    SCSI configuration information


--*/
{
    PSCSI_BUS_SCAN_DATA busScanData;
    PLUNINFO lunInfo;
    UCHAR target;
    UCHAR device = 0;
    PLOGICAL_UNIT_EXTENSION nextLogicalUnitExtension;

    DebugPrint((3,"ScsiBusScan: Enter routine\n"));

    busScanData = ExAllocatePool(NonPagedPool,
                                 sizeof(SCSI_BUS_SCAN_DATA));

    if (busScanData == NULL) {

        //
        // Insufficient system resources to complete bus scan.
        //

        return NULL;
    }

    RtlZeroMemory(busScanData,sizeof(SCSI_BUS_SCAN_DATA));

    busScanData->Length = sizeof(SCSI_CONFIGURATION_INFO);

    //
    // Create first LUNINFO.
    //

    lunInfo = ExAllocatePool(NonPagedPool, sizeof(LUNINFO));

    if (lunInfo == NULL) {

        //
        // Insufficient system resources to complete bus scan.
        //

        return NULL;
    }

    RtlZeroMemory(lunInfo, sizeof(LUNINFO));

    //
    // Create first logical unit extension.
    //

    nextLogicalUnitExtension = CreateLogicalUnitExtension(DeviceExtension);

    if (nextLogicalUnitExtension == NULL) {
        return(NULL);
    }

    //
    // Link logical unit extension on list.
    //

    nextLogicalUnitExtension->NextLogicalUnit = DeviceExtension->LogicalUnitList;

    DeviceExtension->LogicalUnitList = nextLogicalUnitExtension;

    //
    // Issue inquiry command to each target id to find devices.
    //
    // NOTE: Does not handle multiple logical units per target id.
    //

    for (target = DeviceExtension->MaximumTargetIds; target > 0; target--) {

        if (InitiatorBusId == target-1) {
            continue;
        }

        //
        // Record address.
        //

        nextLogicalUnitExtension->PathId = lunInfo->PathId = ScsiBus;

        nextLogicalUnitExtension->TargetId = lunInfo->TargetId = target-1;

        nextLogicalUnitExtension->Lun = lunInfo->Lun = 0;

         //
         // Rezero hardware logigal unit extension if it's being recycled.
         //

         if (DeviceExtension->HwLogicalUnitExtensionSize) {

             if (nextLogicalUnitExtension->SpecificLuExtension) {

                 RtlZeroMemory(nextLogicalUnitExtension->SpecificLuExtension,
                             DeviceExtension->HwLogicalUnitExtensionSize);
             }

        }

        //
        // Issue inquiry command.
        //

        DebugPrint((2,"ScsiBusScan: Try TargetId %d LUN 0\n", target-1));

        if (IssueInquiry(DeviceExtension, lunInfo) == ESUCCESS) {

            PINQUIRYDATA inquiryData = (PINQUIRYDATA)lunInfo->InquiryData;

            //
            // Make sure we can use the device.
            //

            if (inquiryData->DeviceTypeQualifier & 0x04) {

              //
              // This device is not supported; continue looking for
              // other devices.
              //

              continue;
            }

            DebugPrint((1,
                       "ScsiBusScan: Found Device %d at TID %d LUN %d\n",
                       device,
                       lunInfo->TargetId,
                       lunInfo->Lun));

            //
            // Link LUN information on list.
            //

            lunInfo->NextLunInfo = busScanData->LunInfoList;
            busScanData->LunInfoList = lunInfo;

            //
            // This buffer is used. Get another.
            //

            lunInfo = ExAllocatePool(NonPagedPool, sizeof(LUNINFO));

            if (lunInfo == NULL) {

                //
                // Insufficient system resources to complete bus scan.
                //

                return busScanData;
            }

            RtlZeroMemory(lunInfo, sizeof(LUNINFO));

            //
            // Current logical unit extension claimed.
            // Create next logical unit.
            //

            nextLogicalUnitExtension =
                CreateLogicalUnitExtension(DeviceExtension);

            if (nextLogicalUnitExtension == NULL) {
                return busScanData;
            }

            //
            // Link logical unit extension on list.
            //

            nextLogicalUnitExtension->NextLogicalUnit =
                DeviceExtension->LogicalUnitList;

            DeviceExtension->LogicalUnitList = nextLogicalUnitExtension;

            device++;
        }

    } // end for (target ...

    //
    // Remove unused logicalunit extension from list.
    //

    DeviceExtension->LogicalUnitList =
        DeviceExtension->LogicalUnitList->NextLogicalUnit;

    ExFreePool(nextLogicalUnitExtension);
    ExFreePool(lunInfo);

    busScanData->NumberOfLogicalUnits = device;
    DebugPrint((1,
               "ScsiBusScan: Found %d devices on SCSI bus %d\n",
               device,
               ScsiBus));

    return busScanData;

} // end ScsiBusScan()


PLOGICAL_UNIT_EXTENSION
CreateLogicalUnitExtension(
    IN PDEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    Create logical unit extension.

Arguments:

    DeviceExtension
    PathId

Return Value:

    Logical unit extension


--*/
{
    PLOGICAL_UNIT_EXTENSION logicalUnitExtension;

            //
            // Create logical unit extension and link in chain.
            //

            logicalUnitExtension =
                ExAllocatePool(NonPagedPool, sizeof(LOGICAL_UNIT_EXTENSION));

            if (logicalUnitExtension == NULL) {
                return(NULL);
            }

            //
            // Zero logical unit extension.
            //

            RtlZeroMemory(logicalUnitExtension, sizeof(LOGICAL_UNIT_EXTENSION));

            //
            // Allocate miniport driver logical unit extension if necessary.
            //

            if (DeviceExtension->HwLogicalUnitExtensionSize) {

                logicalUnitExtension->SpecificLuExtension =
                    ExAllocatePool(NonPagedPool,
                    DeviceExtension->HwLogicalUnitExtensionSize);

                if (logicalUnitExtension->SpecificLuExtension == NULL) {
                    return(NULL);
                }

                //
                // Zero hardware logical unit extension.
                //

                RtlZeroMemory(logicalUnitExtension->SpecificLuExtension,
                    DeviceExtension->HwLogicalUnitExtensionSize);
            }

            //
            // Set timer counters in LogicalUnits to -1 to indicate no
            // outstanding requests.
            //

            logicalUnitExtension->RequestTimeoutCounter = -1;

            //
            // Clear the current request field.
            //

            logicalUnitExtension->CurrentRequest = NULL;

            return logicalUnitExtension;

} // end CreateLogicalUnitExtension()


//
// Routines providing service to hardware dependent driver.
//

SCSI_PHYSICAL_ADDRESS
ScsiPortGetPhysicalAddress(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID VirtualAddress,
    OUT ULONG *Length
)

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PDEVICE_EXTENSION deviceExtension =
        ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;
    PSRB_SCATTER_GATHER scatterList;
    PIRP irp;
    PMDL mdl;
    ULONG byteOffset;
    ULONG whichPage;
    PULONG pages;
    ULONG_PTR address;

    if (Srb == NULL) {

        //
        // The virtual address is required to be within the non-cached extension
        // and we can't allocate 4GB of non-cached extension in the loader so 
        // truncate the offset to a ULONG.
        //

        byteOffset = (ULONG) ((PUCHAR) deviceExtension->NonCachedExtension - 
                              (PUCHAR) VirtualAddress);

        if (deviceExtension->SrbExtensionZonePool) {

            address = (PUCHAR) VirtualAddress - 
                      (PUCHAR) deviceExtension->SrbExtensionZonePool +
                      deviceExtension->PhysicalZoneBase;

        } else {

            address = MmGetPhysicalAddress(VirtualAddress).LowPart;
        }

        //
        // Return the requested length.
        //

        *Length = deviceExtension->NonCachedExtensionSize - byteOffset;

    } else if (deviceExtension->MasterWithAdapter) {

        //
        // A scatter/gather list has already been allocated use it to determine
        // the physical address and length.  Get the scatter/gather list.
        //

        scatterList = GetLogicalUnitExtension(deviceExtension, Srb->TargetId)
            ->ScatterGather;

        //
        // Calculate byte offset into the data buffer.
        //

        byteOffset = (ULONG)((PCHAR) VirtualAddress - (PCHAR) Srb->DataBuffer);

        //
        // Find the appropirate entry in the scatter/gatter list.
        //

        while (byteOffset >= scatterList->Length) {

            byteOffset -= scatterList->Length;
            scatterList++;
        }

        //
        // Calculate the physical address and length to be returned.
        //

        *Length = scatterList->Length - byteOffset;
        return(ScsiPortConvertUlongToPhysicalAddress(scatterList->PhysicalAddress + byteOffset));

    } else {

        //
        // Get IRP from SRB.
        //

        irp = Srb->OriginalRequest;

        //
        // Get MDL from IRP.
        //

        mdl = irp->MdlAddress;

        //
        // Calculate byte offset from
        // beginning of first physical page.
        //

        byteOffset = (ULONG)((PCHAR)VirtualAddress - (PCHAR)mdl->StartVa);

        //
        // Calculate which physical page.
        //

        whichPage = byteOffset >> PAGE_SHIFT;

        //
        // Calculate beginning of physical page array.
        //

        pages = (PULONG)(mdl + 1);

        //
        // Calculate physical address.
        //

        address = (pages[whichPage] << PAGE_SHIFT) +
            BYTE_OFFSET(VirtualAddress);

        //
        // Assume the buffer is contiguous.  Just return the requested length.
        //
    }

    return ScsiPortConvertUlongToPhysicalAddress(address);

} // end ScsiPortGetPhysicalAddress()


PVOID
ScsiPortGetVirtualAddress(
    IN PVOID HwDeviceExtension,
    IN SCSI_PHYSICAL_ADDRESS PhysicalAddress
    )

/*++

Routine Description:

    This routine is returns a virtual address associated with a
    physical address, if the physical address was obtained by a
    call to ScsiPortGetPhysicalAddress.

Arguments:

    PhysicalAddress

Return Value:

    Virtual address if physical page hashed.
    NULL if physical page not found in hash.

--*/

{
    PDEVICE_EXTENSION deviceExtension =
        ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;
    PVOID address;



    address = ScsiPortConvertPhysicalAddressToUlong(PhysicalAddress)
        - deviceExtension->PhysicalZoneBase +
        (PUCHAR)deviceExtension->SrbExtensionZonePool;

    return address;

} // end ScsiPortGetVirtualAddress()


PVOID
ScsiPortGetLogicalUnit(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )

/*++

Routine Description:

    Walk port driver's logical unit extension list searching
    for entry.

Arguments:

    HwDeviceExtension - The port driver's device extension follows
        the miniport's device extension and contains a pointer to
        the logical device extension list.

    PathId, TargetId and Lun - identify which logical unit on the
        SCSI buses.

Return Value:

    If entry found return miniport driver's logical unit extension.
    Else, return NULL.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PLOGICAL_UNIT_EXTENSION logicalUnit;

    //
    // Get pointer to port driver device extension.
    //

    deviceExtension = (PDEVICE_EXTENSION)HwDeviceExtension -1;

    //
    // Get pointer to logical unit list.
    //

    logicalUnit = deviceExtension->LogicalUnitList;

    //
    // Walk list looking at target id for requested logical unit extension.
    //

    while (logicalUnit != NULL) {

        if ((logicalUnit->TargetId == TargetId) &&
            (logicalUnit->PathId == PathId) &&
            (logicalUnit->Lun == Lun)) {

            //
            // Logical unit extension found.
            // Return specific logical unit extension.
            //

            return logicalUnit->SpecificLuExtension;
        }

        //
        // Get next logical unit.
        //

        logicalUnit = logicalUnit->NextLogicalUnit;
    }

    //
    // Requested logical unit extension not found.
    //

    return NULL;

} // end ScsiPortGetLogicalUnit()

VOID
ScsiPortNotification(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PDEVICE_EXTENSION deviceExtension =
        (PDEVICE_EXTENSION) HwDeviceExtension - 1;
    PIO_STACK_LOCATION irpstack;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSCSI_REQUEST_BLOCK srb;
    va_list(ap);

    va_start(ap, HwDeviceExtension);

    switch (NotificationType) {

        case NextLuRequest:
        case NextRequest:

            //
            // Start next packet on adapter's queue.
            //

            deviceExtension->InterruptFlags |= PD_READY_FOR_NEXT_REQUEST;
            break;

        case RequestComplete:

            srb = va_arg(ap, PSCSI_REQUEST_BLOCK);

            if (srb->SrbStatus == SRB_STATUS_ERROR) {
            }

            //
            // Link the completed request into a forward-linked list of IRPs.
            //

            irpstack = IoGetCurrentIrpStackLocation(
                ((PIRP) srb->OriginalRequest)
                );

            irpstack->Parameters.Others.Argument3 =
                deviceExtension->CompletedRequests;

            deviceExtension->CompletedRequests = srb->OriginalRequest;

            //
            // Set logical unit current request to NULL
            // to prevent race condition.
            //

            logicalUnit = GetLogicalUnitExtension(deviceExtension, srb->TargetId);

            if (logicalUnit != NULL) {
                logicalUnit->CurrentRequest = NULL;
            } else {
                ASSERT(logicalUnit != NULL); // Logic error, must debug this.
            }

            break;

        case ResetDetected:

                 deviceExtension->PortTimeoutCounter = PD_TIMER_RESET_HOLD_TIME;
            break;

        case CallDisableInterrupts:

            ASSERT(deviceExtension->Flags & PD_DISABLE_INTERRUPTS);

            //
            // The mini-port wants us to call the specified routine
            // with interrupts disabled.  This is done after the current
            // HwRequestInterrutp routine completes. Indicate the call is
            // needed and save the routine to be called.
            //

            deviceExtension->Flags |= PD_DISABLE_CALL_REQUEST;

            deviceExtension->HwRequestInterrupt = va_arg(ap, PHW_INTERRUPT);

            break;

        case CallEnableInterrupts:

            ASSERT(!(deviceExtension->Flags & PD_DISABLE_INTERRUPTS));

            //
            // The mini-port wants us to call the specified routine
            // with interrupts enabled this is done from the DPC.
            // Disable calls to the interrupt routine, indicate the call is
            // needed and save the routine to be called.
            //

            deviceExtension->Flags |= PD_DISABLE_INTERRUPTS | PD_ENABLE_CALL_REQUEST;

            deviceExtension->HwRequestInterrupt = va_arg(ap, PHW_INTERRUPT);

            break;

        case RequestTimerCall:

            deviceExtension->HwTimerRequest = va_arg(ap, PHW_INTERRUPT);
            deviceExtension->TimerValue = va_arg(ap, ULONG);

            if (deviceExtension->TimerValue) {

                //
                // Round up the timer value to the stall time.
                //

                deviceExtension->TimerValue = (deviceExtension->TimerValue
                  + PD_INTERLOOP_STALL - 1)/ PD_INTERLOOP_STALL;
            }

            break;
    }

    va_end(ap);

    //
    // Check to see if the last DPC has been processed yet.  If so
    // queue another DPC.
    //

    ScsiPortCompletionDpc(
        NULL,                           // Dpc
        deviceExtension->DeviceObject,  // DeviceObject
        NULL,                           // Irp
        NULL                            // Context
        );

} // end ScsiPortNotification()


VOID
ScsiPortFlushDma(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine checks to see if the perivious IoMapTransfer has been done
    started.  If it has not, then the PD_MAP_TRANSER flag is cleared, and the
    routine returns; otherwise, this routine schedules a DPC which will call
    IoFlushAdapter buffers.

Arguments:

    HwDeviceExtension - Supplies a the hardware device extension for the
        host bus adapter which will be doing the data transfer.


Return Value:

    None.

--*/

{

    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;

    if (deviceExtension->InterruptFlags & PD_MAP_TRANSFER) {

        //
        // The transfer has not been started so just clear the map transfer
        // flag and return.
        //

        deviceExtension->InterruptFlags &= ~PD_MAP_TRANSFER;
        return;
    }

    deviceExtension->InterruptFlags |= PD_FLUSH_ADAPTER_BUFFERS;

    //
    // Check to see if the last DPC has been processed yet.  If so
    // queue another DPC.
    //

    ScsiPortCompletionDpc(
        NULL,                           // Dpc
        deviceExtension->DeviceObject,  // DeviceObject
        NULL,                           // Irp
        NULL                            // Context
        );

    return;

}

VOID
ScsiPortIoMapTransfer(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID LogicalAddress,
    IN ULONG Length
    )
/*++

Routine Description:

    Saves the parameters for the call to IoMapTransfer and schedules the DPC
    if necessary.

Arguments:

    HwDeviceExtension - Supplies a the hardware device extension for the
        host bus adapter which will be doing the data transfer.

    Srb - Supplies the particular request that data transfer is for.

    LogicalAddress - Supplies the logical address where the transfer should
        begin.

    Length - Supplies the maximum length in bytes of the transfer.

Return Value:

   None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;

    //
    // Make sure this host bus adapter has an Dma adapter object.
    //

    if (deviceExtension->DmaAdapterObject == NULL) {
        //
        // No DMA adapter, no work.
        //
        return;
    }

    deviceExtension->MapTransferParameters.Srb = Srb;
    deviceExtension->MapTransferParameters.LogicalAddress = LogicalAddress;
    deviceExtension->MapTransferParameters.Length = Length;

    deviceExtension->InterruptFlags |= PD_MAP_TRANSFER;

    //
    // Check to see if the last DPC has been processed yet.  If so
    // queue another DPC.
    //

    ScsiPortCompletionDpc(
        NULL,                           // Dpc
        deviceExtension->DeviceObject,  // DeviceObject
        NULL,                           // Irp
        NULL                            // Context
        );

} // end ScsiPortIoMapTransfer()


VOID
IssueRequestSense(
    IN PDEVICE_EXTENSION deviceExtension,
    IN PSCSI_REQUEST_BLOCK FailingSrb
    )

/*++

Routine Description:

    This routine creates a REQUEST SENSE request and uses IoCallDriver to
    renter the driver.  The completion routine cleans up the data structures
    and processes the logical unit queue according to the flags.

    A pointer to failing SRB is stored at the end of the request sense
    Srb, so that the completion routine can find it.

Arguments:

    DeviceExension - Supplies a pointer to the device extension for this
        SCSI port.

    FailingSrb - Supplies a pointer to the request that the request sense
        is being done for.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION irpstack;
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    PCDB cdb;
    PVOID *Pointer;

    //
    // Allocate Srb from non-paged pool
    // plus room for a pointer to the failing IRP.
    // Since this routine is in an error-handling
    // path and a shortterm allocation
    // NonPagedMustSucceed is requested.
    //

    Srb = &RequestSenseSrb.Srb;

    //
    // Allocate an IRP to issue the REQUEST SENSE request.
    //

    Irp = InitializeIrp(
        &RequestSenseSrb,
        IRP_MJ_READ,
        deviceExtension->DeviceObject,
        FailingSrb->SenseInfoBuffer,
        FailingSrb->SenseInfoBufferLength
        );

    irpstack = IoGetNextIrpStackLocation(Irp);

    irpstack->MajorFunction = IRP_MJ_SCSI;

    //
    // Save the Failing SRB after the request sense Srb.
    //

    Pointer = (PVOID *) (Srb+1);
    *Pointer = FailingSrb;

    //
    // Build the REQUEST SENSE CDB.
    //

    Srb->CdbLength = 6;
    cdb = (PCDB)Srb->Cdb;

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
    cdb->CDB6INQUIRY.LogicalUnitNumber = 0;
    cdb->CDB6INQUIRY.Reserved1 = 0;
    cdb->CDB6INQUIRY.PageCode = 0;
    cdb->CDB6INQUIRY.IReserved = 0;
    cdb->CDB6INQUIRY.AllocationLength =
        (UCHAR)FailingSrb->SenseInfoBufferLength;
    cdb->CDB6INQUIRY.Control = 0;

    //
    // Save SRB address in next stack for port driver.
    //

    irpstack->Parameters.Others.Argument1 = (PVOID)Srb;

    //
    // Set up IRP Address.
    //

    Srb->OriginalRequest = Irp;

    Srb->NextSrb = 0;

    //
    // Set up SCSI bus address.
    //

    Srb->TargetId = FailingSrb->TargetId;
    Srb->Lun = FailingSrb->Lun;
    Srb->PathId = FailingSrb->PathId;
    Srb->Length = sizeof(SCSI_REQUEST_BLOCK);
    Srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    //
    // Set timeout value to 2 seconds.
    //

    Srb->TimeOutValue = 2;

    //
    // Disable auto request sense.
    //

    Srb->SenseInfoBufferLength = 0;

    //
    // Sense buffer is in stack.
    //

    Srb->SenseInfoBuffer = NULL;

    //
    // Set read and bypass frozen queue bits in flags.
    //

    //
    // Set a speical flags to indicate the logical unit queue should be by
    // passed and that no queue processing should be done when the request
    // completes.
    //

    Srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_BYPASS_FROZEN_QUEUE |
        SRB_FLAGS_DISABLE_SYNCH_TRANSFER | SRB_FLAGS_DISABLE_DISCONNECT;

    Srb->DataBuffer = FailingSrb->SenseInfoBuffer;

    //
    // Set the transfer length.
    //

    Srb->DataTransferLength = FailingSrb->SenseInfoBufferLength;

    //
    // Zero out status.
    //

    Srb->ScsiStatus = Srb->SrbStatus = 0;

    (VOID)IoCallDriver(deviceExtension->DeviceObject, Irp);

    ScsiPortInternalCompletion(deviceExtension->DeviceObject, Irp, Srb);

    return;

} // end IssueRequestSense()


VOID
ScsiPortInternalCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )

/*++

Routine Description:

Arguments:

    Device object
    IRP
    Context - pointer to SRB

Return Value:

    None.

--*/

{
    PSCSI_REQUEST_BLOCK srb = Context;
    PSCSI_REQUEST_BLOCK failingSrb;
    PIRP failingIrp;

    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(DeviceObject);

    //
    // Request sense completed. If successful or data over/underrun
    // get the failing SRB and indicate that the sense information
    // is valid. The class driver will check for underrun and determine
    // if there is enough sense information to be useful.
    //

    if ((SRB_STATUS(srb->SrbStatus) == SRB_STATUS_SUCCESS) ||
        (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN)) {

        //
        // Get a pointer to failing Irp and Srb.
        //

        failingSrb = *((PVOID *) (srb+1));
        failingIrp = failingSrb->OriginalRequest;

        //
        // Report sense buffer is valid.
        //

        failingSrb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;

        //
        // Copy bytes transferred to failing SRB
        // request sense length field to communicate
        // to the class drivers the number of valid
        // sense bytes.
        //

        failingSrb->SenseInfoBufferLength = (UCHAR) srb->DataTransferLength;

    }

} // ScsiPortInternalCompletion()


VOID
ScsiPortTickHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension =
        (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    PLOGICAL_UNIT_EXTENSION logicalUnit;

    UNREFERENCED_PARAMETER(Context);

    logicalUnit = deviceExtension->LogicalUnitList;

    //
    // NOTE: The use of Current request needs to be synchronized with the
    // clearing of current request.
    //

    while (logicalUnit != NULL) {

        //
        // Check for busy requests.
        //

        if (logicalUnit->Flags & PD_LOGICAL_UNIT_IS_BUSY) {

            DebugPrint((1,"ScsiPortTickHandler: Retrying busy status request\n"));

            //
            // Clear the busy flag and retry the request.
            //

            logicalUnit->Flags &= ~PD_LOGICAL_UNIT_IS_BUSY;

            ScsiPortStartIo(DeviceObject, logicalUnit->CurrentRequest);

        } else if (logicalUnit->RequestTimeoutCounter == 0) {

            //
            // Request timed out.
            //

            DebugPrint((1, "ScsiPortTickHandler: Request timed out\n"));

            //
            // Reset request timeout counter to unused state.
            //

            logicalUnit->RequestTimeoutCounter = -1;

            //
            // Build and send request to abort command.
            //

            IssueAbortRequest(deviceExtension, logicalUnit->CurrentRequest);
        } else if (logicalUnit->RequestTimeoutCounter != -1) {

            DebugPrint((1, "ScsiPortTickHandler: Timeout value %lx\n",logicalUnit->RequestTimeoutCounter));
            logicalUnit->RequestTimeoutCounter--;
        }

        logicalUnit = logicalUnit->NextLogicalUnit;
    }

    return;

} // end ScsiPortTickHandler()


VOID
IssueAbortRequest(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP FailingIrp
    )

/*++

Routine Description:

    A request timed out and to clear the request at the HBA
    an ABORT request is issued. But first, if the request
    that timed out was an ABORT command, then reset the
    adapter instead.

Arguments:

    DeviceExension - Supplies a pointer to the device extension for this
        SCSI port.

    FailingIrp - Supplies a pointer to the request that is to be aborted.

Return Value:

    None.

--*/

{

    ULONG j;

    UNREFERENCED_PARAMETER(FailingIrp);

    //
    // A request to abort failed.
    // Need to reset the adapter.
    //

    DebugPrint((1,"IssueAbort: Request timed out, resetting the bus.\n"));


    if (!DeviceExtension->HwReset(
        DeviceExtension->HwDeviceExtension,
        0)){

        DebugPrint((1,"Reset SCSI bus failed\n"));
    }

    //
    // Call the interupt handler for a few microseconds to clear any reset
    // interrupts.
    //

    for (j = 0; j < 1000 * 100; j++) {

        FwStallExecution(10);
        if (DeviceExtension->HwInterrupt != NULL) {
            DeviceExtension->HwInterrupt(DeviceExtension->HwDeviceExtension);
        }

    }

    DeviceExtension->PortTimeoutCounter = PD_TIMER_RESET_HOLD_TIME;
    SpCheckResetDelay( DeviceExtension );

    return;


} // end IssueAbortRequest()


VOID
SpCheckResetDelay(
    IN PDEVICE_EXTENSION deviceExtension
    )

/*++

Routine Description:

    If there is a pending reset delay, this routine stalls the execution
    for the specified number of seconds.  During the delay the timer
    routines are called at the appropriate times.

Arguments:

    DeviceExension - Supplies a pointer to the device extension for this
        SCSI port.

Return Value:

    Nothing.

--*/

{
    ULONG milliSecondTime;

    //
    // Check if the adapter is ready to accept requests.
    //

    while (deviceExtension->PortTimeoutCounter) {

        deviceExtension->PortTimeoutCounter--;

        //
        // One second delay.
        //

        for ( milliSecondTime = 0;
              milliSecondTime < ((1000*1000)/PD_INTERLOOP_STALL);
              milliSecondTime++ ) {

            FwStallExecution(PD_INTERLOOP_STALL);

            //
            // Check the miniport timer.
            //

            if (deviceExtension->TimerValue != 0) {

                deviceExtension->TimerValue--;

                if (deviceExtension->TimerValue == 0) {

                    //
                    // The timer timed out so called requested timer routine.
                    //

                    deviceExtension->HwTimerRequest(deviceExtension->HwDeviceExtension);
                }
            }
        }
    }

    return;
}

BOOLEAN
SpGetInterruptState(
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This routine saves the InterruptFlags, MapTransferParameters and
    CompletedRequests fields and clears the InterruptFlags.

Arguments:

    ServiceContext - Supplies a pointer to the device extension for this
        SCSI port.

Return Value:

    Always returns TRUE.

Notes:

    Called via KeSynchronizeExecution.

--*/
{
    PDEVICE_EXTENSION deviceExtension = ServiceContext;

    //
    // Move the interrupt state to save area.
    //

    deviceExtension->InterruptFlags = deviceExtension->InterruptFlags;
    deviceExtension->CompletedRequests = deviceExtension->CompletedRequests;
    deviceExtension->MapTransferParameters = deviceExtension->MapTransferParameters;

    //
    // Clear the interrupt state.
    //

    deviceExtension->InterruptFlags = 0;
    deviceExtension->CompletedRequests = NULL;

    return(TRUE);
}

VOID
ScsiDebugPause(
    VOID
    )
{
#if DBG
#define SCSIDEBUG_PAUSE 0x100
#define SCSIDEBUG_PAUSE_LIMIT 20

    static ULONG ScsiDebugPauseCount;

    if (++ScsiDebugPauseCount > SCSIDEBUG_PAUSE_LIMIT) {
        ScsiDebugPauseCount = 0;
        if (ScsiDebug & SCSIDEBUG_PAUSE) {
            DebugPrint((1, "Hit any key.\n"));
            while(!GET_KEY()); // DEBUG Only!
        }
    }
#endif
}

VOID
ScsiPortLogError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb OPTIONAL,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied text
    to it, and requests that it be written to the error log file.

Arguments:

    DeviceExtenson - Supplies the HBA mini-port driver's adapter data storage.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    ErrorCode - Supplies an error code indicating the type of error.

    UniqueId - Supplies a unique identifier for the error.

Return Value:

    None.

--*/

{
    PCHAR errorCodeString;

    UNREFERENCED_PARAMETER( HwDeviceExtension );
    UNREFERENCED_PARAMETER( Srb );
#ifndef DEBUG
    UNREFERENCED_PARAMETER( UniqueId );
    UNREFERENCED_PARAMETER( Lun );
    UNREFERENCED_PARAMETER( PathId );
    UNREFERENCED_PARAMETER( TargetId );
#endif

    switch (ErrorCode) {
    case SP_BUS_PARITY_ERROR:
        errorCodeString = "SCSI bus partity error";
        break;

    case SP_UNEXPECTED_DISCONNECT:
        errorCodeString = "Unexpected disconnect";
        break;

    case SP_INVALID_RESELECTION:
        errorCodeString = "Invalid reselection";
        break;

    case SP_BUS_TIME_OUT:
        errorCodeString = "SCSI bus time out";
        break;

    case SP_PROTOCOL_ERROR:
        errorCodeString = "SCSI protocol error";
        break;

    case SP_INTERNAL_ADAPTER_ERROR:
        errorCodeString = "Internal adapter error";
        break;

    default:
        errorCodeString = "Unknown error code";
        break;

    }

    DebugPrint((1,"\n\nLogErrorEntry: Logging SCSI error packet. ErrorCode = %s.\n",
        errorCodeString));
    DebugPrint((1,
        "PathId = %2x, TargetId = %2x, Lun = %2x, UniqueId = %x.\n\n",
        PathId,
        TargetId,
        Lun,
        UniqueId));

#if DBG
    ScsiDebugPause();
#endif

    return;

} // end ScsiPortLogError()


VOID
ScsiPortCompleteRequest(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    )

/*++

Routine Description:

    Complete all active requests for the specified logical unit.

Arguments:

    DeviceExtenson - Supplies the HBA mini-port driver's adapter data storage.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    SrbStatus - Status to be returned in each completed SRB.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension =
        ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;
    PSCSI_REQUEST_BLOCK Srb;
    PSCSI_REQUEST_BLOCK failingSrb;
    PLOGICAL_UNIT_EXTENSION luExtension;
    PIRP nextIrp;
    PIO_STACK_LOCATION irpstack;

    UNREFERENCED_PARAMETER(PathId);
    UNREFERENCED_PARAMETER(Lun);

    if (TargetId == (UCHAR)(-1)) {

        //
        // Complete requests for all units on this bus.
        //

        luExtension = deviceExtension->LogicalUnitList;

        while (luExtension != NULL) {

            //
            // Complete requests until queue is empty.
            //

            if ((nextIrp = luExtension->CurrentRequest) != NULL &&
                !(luExtension->Flags & PD_LOGICAL_UNIT_IS_BUSY)) {

                //
                // Get SRB address from current IRP stack.
                //

                irpstack = IoGetCurrentIrpStackLocation(nextIrp);

                Srb = (PSCSI_REQUEST_BLOCK)irpstack->Parameters.Others.Argument1;

                //
                // Just in case this is an abort request,
                // get pointer to failingSrb.
                //

                failingSrb = Srb->NextSrb;

                //
                // Update SRB status.
                //

                Srb->SrbStatus = SrbStatus;

                //
                // Indicate no bytes transferred.
                //

                Srb->DataTransferLength = 0;

                //
                // Set IRP status.
                //

                nextIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

                //
                // Move bytes transferred to IRP.
                //

                nextIrp->IoStatus.Information = Srb->DataTransferLength;

                //
                // Call notification routine.
                //

                ScsiPortNotification(RequestComplete,
                            (PVOID)HwDeviceExtension,
                            Srb);

                if (failingSrb) {

                    //
                    // This was an abort request. The failing
                    // SRB must also be completed.
                    //

                    failingSrb->SrbStatus = SrbStatus;
                    failingSrb->DataTransferLength = 0;

                    //
                    // Get IRP from SRB.
                    //

                    nextIrp = failingSrb->OriginalRequest;

                    //
                    // Set IRP status.
                    //

                    nextIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

                    //
                    // Move bytes transferred to IRP.
                    //

                    nextIrp->IoStatus.Information =
                        failingSrb->DataTransferLength;

                    //
                    // Call notification routine.
                    //

                    ScsiPortNotification(RequestComplete,
                            (PVOID)HwDeviceExtension,
                            failingSrb);
                }

            } // end if

            luExtension = luExtension->NextLogicalUnit;

        } // end while

    } else {

        //
        // Complete all requests for this logical unit.
        //

        luExtension =
                GetLogicalUnitExtension(deviceExtension, TargetId);

        ASSERT(luExtension != NULL);

        //
        // Complete requests until queue is empty.
        //

        if ((luExtension != NULL) && ((nextIrp = luExtension->CurrentRequest) != NULL)) {

            //
            // Get SRB address from current IRP stack.
            //

            irpstack = IoGetCurrentIrpStackLocation(nextIrp);

            Srb = (PSCSI_REQUEST_BLOCK)irpstack->Parameters.Others.Argument1;

            //
            // Update SRB status.
            //

            Srb->SrbStatus = SrbStatus;

            //
            // Indicate no bytes transferred.
            //

            Srb->DataTransferLength = 0;

            //
            // Set IRP status.
            //

            nextIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

            //
            // Move bytes transferred to IRP.
            //

            nextIrp->IoStatus.Information = Srb->DataTransferLength;

            //
            // Call notification routine.
            //

            ScsiPortNotification(RequestComplete,
                            (PVOID)HwDeviceExtension,
                            Srb);

        } // end if

    } // end if ... else

    return;


} // end ScsiPortCompleteRequest()


VOID
ScsiPortMoveMemory(
    IN PVOID WriteBuffer,
    IN PVOID ReadBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    Copy from one buffer into another.

Arguments:

    ReadBuffer - source
    WriteBuffer - destination
    Length - number of bytes to copy

Return Value:

    None.

--*/

{
    RtlMoveMemory(WriteBuffer, ReadBuffer, Length);

} // end ScsiPortMoveMemory()


VOID
ScsiPortStallExecution(
    ULONG Delay
    )
/*++

Routine Description:

    Wait number of microseconds in tight processor loop.

Arguments:

    Delay - number of microseconds to wait.

Return Value:

    None.

--*/

{
    FwStallExecution(Delay);

} // end ScsiPortStallExecution()


PLOGICAL_UNIT_EXTENSION
GetLogicalUnitExtension(
    PDEVICE_EXTENSION deviceExtension,
    UCHAR TargetId
    )

/*++

Routine Description:

    Walk logical unit extension list looking for
    extension with matching target id.

Arguments:

    deviceExtension
    TargetId

Return Value:

    Requested logical unit extension if found,
    else NULL.

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnit = deviceExtension->LogicalUnitList;

    while (logicalUnit != NULL) {

        if (logicalUnit->TargetId == TargetId) {

            return logicalUnit;
        }

        logicalUnit = logicalUnit->NextLogicalUnit;
    }

    //
    // Logical unit extension not found.
    //

    return (PLOGICAL_UNIT_EXTENSION)NULL;

} // end GetLogicalUnitExtension()

#if DBG


VOID
ScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all SCSI drivers

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    va_start( ap, DebugMessage );

    if (DebugPrintLevel <= (ScsiDebug & (SCSIDEBUG_PAUSE-1))) {

        char buffer[256];

        _vsnprintf(buffer, sizeof(buffer), DebugMessage, ap);
#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
        FwPrint(buffer);
        FwPrint("\r");
#else
        BlPrint(buffer);
        BlPrint("\r");
#endif
        DbgPrint(buffer);
    }

    va_end(ap);
}

#else

//
// ScsiDebugPrint stub
//

VOID
ScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
{
    UNREFERENCED_PARAMETER(DebugPrintLevel);
    UNREFERENCED_PARAMETER(DebugMessage);
}

#endif


UCHAR
ScsiPortReadPortUchar(
    IN PUCHAR Port
    )

/*++

Routine Description:

    Read from the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{

#ifdef MIPS

    return(READ_REGISTER_UCHAR(Port));

#else

    return(READ_PORT_UCHAR(Port));

#endif
}

USHORT
ScsiPortReadPortUshort(
    IN PUSHORT Port
    )

/*++

Routine Description:

    Read from the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{

#ifdef MIPS

    return(READ_REGISTER_USHORT(Port));

#else

    return(READ_PORT_USHORT(Port));

#endif
}

ULONG
ScsiPortReadPortUlong(
    IN PULONG Port
    )

/*++

Routine Description:

    Read from the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{

#ifdef MIPS

    return(READ_REGISTER_ULONG(Port));

#else

    return(READ_PORT_ULONG(Port));

#endif
}

UCHAR
ScsiPortReadRegisterUchar(
    IN PUCHAR Register
    )

/*++

Routine Description:

    Read from the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_UCHAR(Register));

}

USHORT
ScsiPortReadRegisterUshort(
    IN PUSHORT Register
    )

/*++

Routine Description:

    Read from the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_USHORT(Register));

}

ULONG
ScsiPortReadRegisterUlong(
    IN PULONG Register
    )

/*++

Routine Description:

    Read from the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_ULONG(Register));

}

VOID
ScsiPortReadRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);

}

VOID
ScsiPortReadRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_USHORT(Register, Buffer, Count);

}

VOID
ScsiPortReadRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_ULONG(Register, Buffer, Count);

}

VOID
ScsiPortWritePortUchar(
    IN PUCHAR Port,
    IN UCHAR Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

#ifdef MIPS

    WRITE_REGISTER_UCHAR(Port, Value);

#else

    WRITE_PORT_UCHAR(Port, Value);

#endif
}

VOID
ScsiPortWritePortUshort(
    IN PUSHORT Port,
    IN USHORT Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

#ifdef MIPS

    WRITE_REGISTER_USHORT(Port, Value);

#else

    WRITE_PORT_USHORT(Port, Value);

#endif
}

VOID
ScsiPortWritePortUlong(
    IN PULONG Port,
    IN ULONG Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

#ifdef MIPS

    WRITE_REGISTER_ULONG(Port, Value);

#else

    WRITE_PORT_ULONG(Port, Value);

#endif
}

VOID
ScsiPortWriteRegisterUchar(
    IN PUCHAR Register,
    IN UCHAR Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_UCHAR(Register, Value);

}

VOID
ScsiPortWriteRegisterUshort(
    IN PUSHORT Register,
    IN USHORT Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_USHORT(Register, Value);

}

VOID
ScsiPortWriteRegisterUlong(
    IN PULONG Register,
    IN ULONG Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_ULONG(Register, Value);

}

VOID
ScsiPortWriteRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);

}

VOID
ScsiPortWriteRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_USHORT(Register, Buffer, Count);

}

VOID
ScsiPortWriteRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_ULONG(Register, Buffer, Count);

}

SCSI_PHYSICAL_ADDRESS
ScsiPortConvertUlongToPhysicalAddress(
    ULONG_PTR UlongAddress
    )

{
    SCSI_PHYSICAL_ADDRESS physicalAddress;

    physicalAddress.QuadPart = UlongAddress;
    return(physicalAddress);
}

#undef ScsiPortConvertPhysicalAddressToUlong

ULONG
ScsiPortConvertPhysicalAddressToUlong(
    SCSI_PHYSICAL_ADDRESS Address
    )
{

    return(Address.LowPart);
}



PIRP
InitializeIrp(
   PFULL_SCSI_REQUEST_BLOCK FullSrb,
   CCHAR MajorFunction,
   PVOID DeviceObject,
   PVOID Buffer,
   ULONG Length
   )
/*++

Routine Description:

    This funcition builds an IRP for use by the SCSI port driver and builds a
    MDL list.

Arguments:

    FullSrb - Supplies a pointer to the full srb structure which contains the
        Irp and Mdl.

    MajorFunction - Supplies the major function code to initialize the Irp
        entry.

    DeviceObject - Supplies the device Object pointer to initialize the Irp
        with.

    Buffer - Supplies the virual address of the buffer for which the
        Mdl should be built.

    Length - Supplies the size of buffer for which the Mdl should be built.

Return Value:

    Returns a pointer to the initialized IRP.

--*/

{
    PIRP irp;
    PMDL mdl;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( MajorFunction );

    irp = &FullSrb->Irp;
    mdl = &FullSrb->Mdl;

    irp->Tail.Overlay.CurrentStackLocation = &FullSrb->IrpStack[IRP_STACK_SIZE];

    if (Buffer != NULL && Length != 0) {

        //
        // Build the memory descriptor list.
        //

        irp->MdlAddress = mdl;
        mdl->Next = NULL;
        mdl->Size = (CSHORT)(sizeof(MDL) +
                  ADDRESS_AND_SIZE_TO_SPAN_PAGES(Buffer, Length) * sizeof(ULONG));
        mdl->StartVa = (PVOID)PAGE_ALIGN(Buffer);
        mdl->ByteCount = Length;
        mdl->ByteOffset = BYTE_OFFSET(Buffer);
        mdl->MappedSystemVa = Buffer;
        mdl->MdlFlags = MDL_MAPPED_TO_SYSTEM_VA;
        ScsiPortInitializeMdlPages (mdl);

    } else {
        irp->MdlAddress = NULL;
    }

    return(irp);
}

PVOID
ScsiPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    SCSI_PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfBytes,
    BOOLEAN InMemorySpace
    )

/*++

Routine Description:

    This routine maps an IO address to system address space.
    Use ScsiPortFreeDeviceBase to unmap address.

Arguments:

    HwDeviceExtension - used to find port device extension.
    BusType - what type of bus - eisa, mca, isa
    SystemIoBusNumber - which IO bus (for machines with multiple buses).
    IoAddress - base device address to be mapped.
    NumberOfBytes - number of bytes for which address is valid.

Return Value:

    Mapped address

--*/

{
    PHYSICAL_ADDRESS cardAddress;
    ULONG addressSpace = InMemorySpace;
    PVOID mappedAddress;

    UNREFERENCED_PARAMETER( HwDeviceExtension );

    if (!HalTranslateBusAddress(
            BusType,                // AdapterInterfaceType
            SystemIoBusNumber,      // SystemIoBusNumber
            IoAddress,              // Bus Address
            &addressSpace,          // AddressSpace
            &cardAddress            // Translated address
            )) {
        return NULL;
    }

    //
    // Map the device base address into the virtual address space
    // if the address is in memory space.
    //

    if (!addressSpace) {

        mappedAddress = MmMapIoSpace(cardAddress,
                                 NumberOfBytes,
                                 FALSE);


    } else {

        mappedAddress = (PVOID)((ULONG_PTR)cardAddress.LowPart);
    }

    return mappedAddress;

} // end ScsiPortGetDeviceBase()

VOID
ScsiPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    )

/*++

Routine Description:

    This routine unmaps an IO address that has been previously mapped
    to system address space using ScsiPortGetDeviceBase().

Arguments:

    HwDeviceExtension - used to find port device extension.
    MappedAddress - address to unmap.
    NumberOfBytes - number of bytes mapped.
    InIoSpace - addresses in IO space don't get mapped.

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER(HwDeviceExtension);
    UNREFERENCED_PARAMETER(MappedAddress);

    return;

} // end ScsiPortFreeDeviceBase()

ARC_STATUS
GetAdapterCapabilities(
    IN PDEVICE_OBJECT PortDeviceObject,
    OUT PIO_SCSI_CAPABILITIES *PortCapabilities
    )

/*++

Routine Description:

Arguments:

Return Value:

    Status is returned.

--*/

{
    *PortCapabilities = &((PDEVICE_EXTENSION)PortDeviceObject->DeviceExtension)
        ->Capabilities;

    return(ESUCCESS);
} // end GetAdapterCapabilities()


ARC_STATUS
GetInquiryData(
    IN PDEVICE_OBJECT PortDeviceObject,
    OUT PSCSI_CONFIGURATION_INFO *ConfigInfo
    )

/*++

Routine Description:

    This routine sends a request to a port driver to return
    configuration information.

Arguments:

    The address of the configuration information is returned in
    the formal parameter ConfigInfo.

Return Value:

    Status is returned.

--*/
{
    *ConfigInfo = ((PDEVICE_EXTENSION)PortDeviceObject->DeviceExtension)
        ->ScsiInfo;
    return(ESUCCESS);
} // end GetInquiryData()

NTSTATUS
SpInitializeConfiguration(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PHW_INITIALIZATION_DATA HwInitData,
    OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN BOOLEAN InitialCall
    )
/*++

Routine Description:

    This routine initializes the port configuration information structure.
    Any necessary information is extracted from the registery.

Arguments:

    DeviceExtension - Supplies the device extension.

    HwInitializationData - Supplies the initial miniport data.

    ConfigInfo - Supplies the configuration information to be
        initialized.

    InitialCall - Indicates that this is first call to this function.
        If InitialCall is FALSE, then the perivous configuration information
        is used to determine the new information.

Return Value:

    Returns a status indicating the success or fail of the initializaiton.

--*/

{
#ifdef i386
    extern ULONG MachineType;
#endif

    ULONG j;

    UNREFERENCED_PARAMETER( DeviceExtension );

    //
    // If this is the initial call then zero the information and set
    // the structure to the uninitialized values.
    //

    if (InitialCall) {

        RtlZeroMemory(ConfigInfo, sizeof(PORT_CONFIGURATION_INFORMATION));

        ConfigInfo->Length = sizeof(PORT_CONFIGURATION_INFORMATION);
        ConfigInfo->AdapterInterfaceType = HwInitData->AdapterInterfaceType;
        ConfigInfo->InterruptMode = Latched;
        ConfigInfo->MaximumTransferLength = 0xffffffff;
//        ConfigInfo->NumberOfPhysicalBreaks = 0x17;
        ConfigInfo->NumberOfPhysicalBreaks = 0xffffffff;
        ConfigInfo->DmaChannel = 0xffffffff;
        ConfigInfo->NumberOfAccessRanges = HwInitData->NumberOfAccessRanges;
        ConfigInfo->MaximumNumberOfTargets = 8;

#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
        {
            PCONFIGURATION_COMPONENT Component;
            PCM_SCSI_DEVICE_DATA ScsiDeviceData;
            UCHAR Buffer[sizeof(CM_PARTIAL_RESOURCE_LIST) +
                         (sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * 5) +
                         sizeof(CM_SCSI_DEVICE_DATA)];
            PCM_PARTIAL_RESOURCE_LIST Descriptor = (PCM_PARTIAL_RESOURCE_LIST)&Buffer;
            ULONG Count;
            ULONG ScsiHostId;

            if (((Component = ArcGetComponent("scsi(0)")) != NULL) &&
                (Component->Class == AdapterClass) && (Component->Type == ScsiAdapter) &&
                (ArcGetConfigurationData((PVOID)Descriptor, Component) == ESUCCESS) &&
                ((Count = Descriptor->Count) < 6)) {

                ScsiDeviceData = (PCM_SCSI_DEVICE_DATA)&Descriptor->PartialDescriptors[Count];

                if (ScsiDeviceData->HostIdentifier > 7) {
                    ScsiHostId = 7;
                } else {
                    ScsiHostId = ScsiDeviceData->HostIdentifier;
                }
            } else {
                ScsiHostId = 7;
            }

            for (j = 0; j < 8; j++) {
                ConfigInfo->InitiatorBusId[j] = ScsiHostId;
            }
        }

#else

        for (j = 0; j < 8; j++) {
            ConfigInfo->InitiatorBusId[j] = (UCHAR)~0;
        }

#endif

#if defined(i386)
        switch (HwInitData->AdapterInterfaceType) {
            case Isa:
                if ((MachineType & 0xff) == MACHINE_TYPE_ISA) {
                    return(STATUS_SUCCESS);
                }
            case Eisa:
                if ((MachineType & 0xff) == MACHINE_TYPE_EISA) {
                    return(STATUS_SUCCESS);
                } else {
                    return(STATUS_DEVICE_DOES_NOT_EXIST);
                }
            case MicroChannel:
                if ((MachineType & 0xff) == MACHINE_TYPE_MCA) {
                    return(STATUS_SUCCESS);
                } else {
                    return(STATUS_DEVICE_DOES_NOT_EXIST);
                }
            case PCIBus:
                return(STATUS_SUCCESS);
            default:
                return(STATUS_DEVICE_DOES_NOT_EXIST);
        }
#elif defined(_MIPS_)
      if (HwInitData->AdapterInterfaceType != Internal) {
                return(STATUS_DEVICE_DOES_NOT_EXIST);
      }
#elif defined(_ALPHA_)
      if ( (HwInitData->AdapterInterfaceType != Internal) &&
           (HwInitData->AdapterInterfaceType != Eisa) &&
           (HwInitData->AdapterInterfaceType != PCIBus) &&
           (HwInitData->AdapterInterfaceType != Isa) ) {
          return(STATUS_DEVICE_DOES_NOT_EXIST);
      }
#elif defined(_PPC_)
      if ( (HwInitData->AdapterInterfaceType != Internal) &&
           (HwInitData->AdapterInterfaceType != Eisa) &&
           (HwInitData->AdapterInterfaceType != Isa) ) {
          return(STATUS_DEVICE_DOES_NOT_EXIST);
      }
#else 
        return(STATUS_SUCCESS);
#endif
    } else {

        return(STATUS_DEVICE_DOES_NOT_EXIST);
    }
}


NTSTATUS
SpGetCommonBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    ULONG NonCachedExtensionSize
    )
/*++

Routine Description:

    This routine determines the required size of the common buffer.  Allocates
    the common buffer and finally sets up the srb extension zone.  This routine
    expects that the adapter object has already been allocated.

Arguments:

    DeviceExtension - Supplies a pointer to the device extension.

    NonCachedExtensionSize - Supplies the size of the noncached device
        extension for the mini-port driver.

Return Value:

    Returns the status of the allocate operation.

--*/

{
#ifdef AXP_FIRMWARE    
    PHYSICAL_ADDRESS pAddress;
#endif
    PVOID buffer;
    ULONG length;
    ULONG blockSize;

    //
    // Calculate the block size for the zone elements based on the Srb
    // Extension.
    //

    blockSize = DeviceExtension->SrbExtensionSize;

    //
    // Last three bits of blocksize must be zero.
    // Round blocksize up.
    //

    blockSize = (blockSize + 7) &  ~7;

    //
    // Same for the noncached extension size.
    //

    NonCachedExtensionSize += 7;
    NonCachedExtensionSize &= ~7;

    length = NonCachedExtensionSize + blockSize * MINIMUM_SRB_EXTENSIONS;

    //
    // Round the length up to a page size, since HalGetCommonBuffer allocates
    // in pages anyway.
    //

    length = (ULONG)ROUND_TO_PAGES(length);

    //
    // Allocate one page for noncached deviceextension
    // and srbextension zoned pool.
    //

    if (DeviceExtension->DmaAdapterObject == NULL) {

        //
        // Since there is no adapter just allocate from non-paged pool.
        //

        if ((buffer = MmAllocateNonCachedMemory(length)) != NULL) {
            DeviceExtension->PhysicalZoneBase = MmGetPhysicalAddress(buffer).LowPart;
        }

    } else {
#ifdef AXP_FIRMWARE
        buffer = HalAllocateCommonBuffer(DeviceExtension->DmaAdapterObject,
                                         length,
                                         &pAddress,
                                         FALSE );
        DeviceExtension->PhysicalZoneBase = pAddress.LowPart;
#else
        if ((buffer = MmAllocateNonCachedMemory(length)) != NULL) {
            DeviceExtension->PhysicalZoneBase = MmGetPhysicalAddress(buffer).LowPart;
        }
#endif
    }

    if (buffer == NULL) {
        return ENOMEM;
    }

    //
    // Truncate Physical address to 32 bits.
    //
    // Determine length and starting address of zone.
    // If noncached device extension required then
    // subtract size from page leaving rest for zone.
    //

    length -= NonCachedExtensionSize;

    DeviceExtension->NonCachedExtension = (PUCHAR)buffer + length;
    DeviceExtension->NonCachedExtensionSize = NonCachedExtensionSize;

    if (DeviceExtension->SrbExtensionSize) {

        //
        // Get block size.
        //

        blockSize = DeviceExtension->SrbExtensionSize;

        //
        // Record starting virtual address of zone.
        //

        DeviceExtension->SrbExtensionZonePool = buffer;
        DeviceExtension->SrbExtensionPointer = buffer;
        DeviceExtension->SrbExtensionSize = blockSize;


    } else {
        DeviceExtension->SrbExtensionZonePool = NULL;
    }

    return(ESUCCESS);
}

PVOID
ScsiPortGetUncachedExtension(
    IN PVOID HwDeviceExtension,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN ULONG NumberOfBytes
    )
/*++

Routine Description:

    This function allocates a common buffer to be used as the uncached device
    extension for the mini-port driver.  This function will also allocate any
    required SRB extensions.  The DmaAdapter is allocated if it has not been
    allocated previously.

Arguments:

    DeviceExtension - Supplies a pointer to the mini-ports device extension.

    ConfigInfo - Supplies a pointer to the partially initialized configuraiton
        information.  This is used to get an DMA adapter object.

    NumberOfBytes - Supplies the size of the extension which needs to be
        allocated

Return Value:

    A pointer to the uncached device extension or NULL if the extension could
    not be allocated or was previously allocated.

--*/

{
    DEVICE_DESCRIPTION deviceDescription;
    PDEVICE_EXTENSION deviceExtension =
        ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;
    NTSTATUS status;
    ULONG numberOfPageBreaks;

    //
    // Make sure that an common buffer  has not already been allocated.
    //

    if (deviceExtension->SrbExtensionZonePool != NULL) {
        return(NULL);
    }

    if ( deviceExtension->DmaAdapterObject == NULL ) {

        RtlZeroMemory( &deviceDescription, sizeof(DEVICE_DESCRIPTION) );

        deviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
        deviceDescription.DmaChannel = ConfigInfo->DmaChannel;
        deviceDescription.InterfaceType = ConfigInfo->AdapterInterfaceType;
        deviceDescription.BusNumber = ConfigInfo->SystemIoBusNumber;
        deviceDescription.DmaWidth = ConfigInfo->DmaWidth;
        deviceDescription.DmaSpeed = ConfigInfo->DmaSpeed;
        deviceDescription.DmaPort = ConfigInfo->DmaPort;
        deviceDescription.Dma32BitAddresses = ConfigInfo->Dma32BitAddresses;
        deviceDescription.MaximumLength = ConfigInfo->MaximumTransferLength;
        deviceDescription.ScatterGather = ConfigInfo->ScatterGather;
        deviceDescription.Master = ConfigInfo->Master;
        deviceDescription.AutoInitialize = FALSE;
        deviceDescription.DemandMode = FALSE;

        if (ConfigInfo->MaximumTransferLength > 0x11000) {

            deviceDescription.MaximumLength = 0x11000;

        } else {

            deviceDescription.MaximumLength = ConfigInfo->MaximumTransferLength;

        }

        deviceExtension->DmaAdapterObject = HalGetAdapter(
            &deviceDescription,
            &numberOfPageBreaks
            );

        //
        // Set maximum number of page breaks.
        //

        if (numberOfPageBreaks > ConfigInfo->NumberOfPhysicalBreaks) {
            deviceExtension->Capabilities.MaximumPhysicalPages =
                                        ConfigInfo->NumberOfPhysicalBreaks;
        } else {
            deviceExtension->Capabilities.MaximumPhysicalPages =
                                        numberOfPageBreaks;
        }

    }

    //
    // Allocate the common buffer.
    //

    status = SpGetCommonBuffer( deviceExtension, NumberOfBytes);

    if (status != ESUCCESS) {
        return(NULL);
    }

    return(deviceExtension->NonCachedExtension);
}

ULONG
ScsiPortGetBusData(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the bus data for an adapter slot or CMOS address.

Arguments:

    BusDataType - Supplies the type of bus.

    BusNumber - Indicates which bus.

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/

{
    ULONG DataLength = 0;

    PDEVICE_EXTENSION deviceExtension =
        (PDEVICE_EXTENSION) DeviceExtension - 1;

    //
    // If the length is non-zero, the the requested data.
    //

    if (Length != 0) {

        ULONG ret;

        ret = HalGetBusData( BusDataType,
                             SystemIoBusNumber,
                             SlotNumber,
                             Buffer,
                             Length
                             );
        return ret;
    }

    //
    // Free any previously allocated data.
    //

    if (deviceExtension->MapRegisterBase != NULL) {
        ExFreePool(deviceExtension->MapRegisterBase);
    }

    if (BusDataType == EisaConfiguration) {

#if 0
        //
        // Deteremine the length to allocate based on the number of functions
        // for the slot.
        //

        Length = HalGetBusData( BusDataType,
                               SystemIoBusNumber,
                               SlotNumber,
                               &slotInformation,
                               sizeof(CM_EISA_SLOT_INFORMATION));


        if (Length < sizeof(CM_EISA_SLOT_INFORMATION)) {

            //
            // The data is messed up since this should never occur
            //

            DebugPrint((1, "ScsiPortGetBusData: Slot information not returned. Length = %d\n", Length));
            return(0);
        }

        //
        // Calculate the required length based on the number of functions.
        //

        Length = sizeof(CM_EISA_SLOT_INFORMATION) +
            (sizeof(CM_EISA_FUNCTION_INFORMATION) * slotInformation.NumberFunctions);

#else

        //
        // Since the loader does not really support freeing data and the EISA
        // configuration data can be very large.  Hal get bus data has be changed
        // to accept a length of zero for EIAS configuration data.
        //

        DataLength = HalGetBusData( BusDataType,
                                    SystemIoBusNumber,
                                    SlotNumber,
                                    Buffer,
                                    Length
                                    );

        DebugPrint((1, "ScsiPortGetBusData: Returning data. Length = %d\n", DataLength));
        return(DataLength);
#endif

    } else {

        Length = PAGE_SIZE;
    }

    deviceExtension->MapRegisterBase = ExAllocatePool(NonPagedPool, Length);

    if (deviceExtension->MapRegisterBase == NULL) {
        DebugPrint((1, "ScsiPortGetBusData: Memory allocation failed. Length = %d\n", Length));
        return(0);
    }

    //
    // Return the pointer to the mini-port driver.
    //

    *((PVOID *)Buffer) = deviceExtension->MapRegisterBase;

    DataLength = HalGetBusData( BusDataType,
                                SystemIoBusNumber,
                                SlotNumber,
                                deviceExtension->MapRegisterBase,
                                Length
                                );

    return(DataLength);
}

PSCSI_REQUEST_BLOCK
ScsiPortGetSrb(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN LONG QueueTag
    )

/*++

Routine Description:

    This routine retrieves an active SRB for a particuliar logical unit.

Arguments:

    HwDeviceExtension
    PathId, TargetId, Lun - identify logical unit on SCSI bus.
    QueueTag - -1 indicates request is not tagged.

Return Value:

    SRB, if one exists. Otherwise, NULL.

--*/

{
    PDEVICE_EXTENSION deviceExtension =
        ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;
    PLOGICAL_UNIT_EXTENSION luExtension;
    PIRP irp;
    PIO_STACK_LOCATION irpstack;

    UNREFERENCED_PARAMETER( PathId );
    UNREFERENCED_PARAMETER( Lun );
    UNREFERENCED_PARAMETER( QueueTag );

    luExtension = GetLogicalUnitExtension(deviceExtension, TargetId);


    if (luExtension == NULL) {
        return(NULL);
    }

    irp = luExtension->CurrentRequest;
    irpstack = IoGetCurrentIrpStackLocation(irp);
    return ((PSCSI_REQUEST_BLOCK)irpstack->Parameters.Others.Argument1);

} // end ScsiPortGetSrb()

BOOLEAN
ScsiPortValidateRange(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN SCSI_PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    )

/*++

Routine Description:

    This routine should take an IO range and make sure that it is not already
    in use by another adapter. This allows miniport drivers to probe IO where
    an adapter could be, without worrying about messing up another card.

Arguments:

    HwDeviceExtension - Used to find scsi managers internal structures
    BusType - EISA, PCI, PC/MCIA, MCA, ISA, what?
    SystemIoBusNumber - Which system bus?
    IoAddress - Start of range
    NumberOfBytes - Length of range
    InIoSpace - Is range in IO space?

Return Value:

    TRUE if range not claimed by another driver.

--*/

{
    
    UNREFERENCED_PARAMETER( HwDeviceExtension );
    UNREFERENCED_PARAMETER( BusType );
    UNREFERENCED_PARAMETER( SystemIoBusNumber );
    UNREFERENCED_PARAMETER( IoAddress );
    UNREFERENCED_PARAMETER( NumberOfBytes );
    UNREFERENCED_PARAMETER( InIoSpace );

    //
    // This is not implemented in NT.
    //

    return TRUE;
}

VOID
ScsiPortReadPortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_UCHAR(Port, Buffer, Count);

}

VOID
ScsiPortReadPortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_USHORT(Port, Buffer, Count);

}

VOID
ScsiPortReadPortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_ULONG(Port, Buffer, Count);

}

VOID
ScsiPortWritePortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_UCHAR(Port, Buffer, Count);

}

VOID
ScsiPortWritePortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_USHORT(Port, Buffer, Count);

}

VOID
ScsiPortWritePortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_ULONG(Port, Buffer, Count);

}

VOID
ScsiPortQuerySystemTime(
    OUT PLARGE_INTEGER Port
    )

/*++

Routine Description:

    Return a dummy system time to caller.  This routine is present only to
    satisfy scsi miniport drivers that require the export.

Arguments:

    CurrentTime - Supplies a pointer to a data buffer into which
                  to copy the system time.

Return Value:

    None

--*/

{

    Port->QuadPart = 0;

}


BOOLEAN
GetPciConfiguration(
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT DeviceObject,
    PPORT_CONFIGURATION_INFORMATION ConfigInformation,
    ULONG NumberOfAccessRanges,
    PVOID RegistryPath,
    BOOLEAN IsMultiFunction,
    PULONG BusNumber,
    PULONG SlotNumber,
    PULONG FunctionNumber
    )

/*++

Routine Description:

    Uses the Bus/Slot/Function numbers provided and gets slot information for 
    the device and register with hal for the resources.

Arguments:

    DriverObject - Miniport driver object.
    DeviceObject - Represents this adapter.
    ConfigInformation - Template for configuration information passed to a
                        miniport driver via the FindAdapter routine.
    NumberOfAccessRanges - from the HwInitializationData provided by the 
                           miniport
    RegistryPath - Service key path.
    IsMultiFunctionDevice - as returned by FindPciDevice.
    BusNumber - PCI Bus number provided by FindPciDevice.
    SlotNumber - Slot number provided by FindPciDevice.
    FunctionNumber - FunctionNumber provided by FindPciDevice.

Return Value:

    TRUE if card found. BusNumber and Slotnumber will return values that
    should be used to continue the search for additional cards, when a card
    is found.

--*/

{
    PCI_SLOT_NUMBER     slotData;
    PPCI_COMMON_CONFIG  pciData;
    PCI_COMMON_CONFIG   pciBuffer;
    ULONG               pciBus = *BusNumber;
    ULONG               slotNumber = *SlotNumber;
    ULONG               functionNumber = *FunctionNumber;
    ULONG               i;
    ULONG               length;
    ULONG               rangeNumber = 0;
    PACCESS_RANGE       accessRange;
    ULONG               status;
    PCM_RESOURCE_LIST   resourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resourceDescriptor;
    UNICODE_STRING      unicodeString;
    CHAR                vendorString[5];
    CHAR                deviceString[5];

    pciData = &pciBuffer;

    //
    //
    // typedef struct _PCI_SLOT_NUMBER {
    //     union {
    //         struct {
    //             ULONG   DeviceNumber:5;
    //             ULONG   FunctionNumber:3;
    //             ULONG   Reserved:24;
    //         } bits;
    //         ULONG   AsULONG;
    //     } u;
    // } PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;
    //

    slotData.u.AsULONG = 0;

    //
    // Search each PCI bus.
    //

    //
    // Look at each device.
    //

    slotData.u.bits.DeviceNumber = slotNumber;
    slotData.u.bits.FunctionNumber = functionNumber;

    //
    // Look at each function.
    //

    length = HalGetBusDataByOffset(
                PCIConfiguration,
                pciBus,
                slotData.u.AsULONG,
                pciData,
                0,
                FIELD_OFFSET(PCI_COMMON_CONFIG, DeviceSpecific));

    ASSERT(length != 0);
    ASSERT(pciData->VendorID != PCI_INVALID_VENDORID);

    //
    // Translate hex ids to strings.
    //

    sprintf(vendorString, "%04x", pciData->VendorID);
    sprintf(deviceString, "%04x", pciData->DeviceID);

    DebugPrint((1,
               "GetPciConfiguration: Bus %x Slot %x Function %x Vendor %s Product %s %s\n",
               pciBus,
               slotNumber,
               functionNumber,
               vendorString,
               deviceString,
               (IsMultiFunction ? "MF" : "")));

    //
    // This is the miniport drivers slot. Allocate the
    // resources.
    //

    RtlInitUnicodeString(&unicodeString, L"ScsiAdapter");

    status = HalAssignSlotResources(RegistryPath,
                                    &unicodeString,
                                    DriverObject,
                                    DeviceObject,
                                    PCIBus,
                                    pciBus,
                                    slotData.u.AsULONG,
                                    &resourceList);

    if(!NT_SUCCESS(status)) {
        DebugPrint((0, "GetPciConfiguration: HalAssignSlotResources failed with %x\n", status));
        return FALSE;
    }

    //
    // Walk resource list to update configuration information.
    //

    for (i = 0;
         i < resourceList->List->PartialResourceList.Count;
         i++) {

       //
       // Get resource descriptor.
       //

       resourceDescriptor =
           &resourceList->List->PartialResourceList.PartialDescriptors[i];

       //
       // Check for interrupt descriptor.
       //

       if (resourceDescriptor->Type == CmResourceTypeInterrupt) {
           ConfigInformation->BusInterruptLevel =
               resourceDescriptor->u.Interrupt.Level;
           ConfigInformation->BusInterruptVector =
               resourceDescriptor->u.Interrupt.Vector;

           //
           // Check interrupt mode.
           //

           if ((resourceDescriptor->Flags ==
               CM_RESOURCE_INTERRUPT_LATCHED)) {
               ConfigInformation->InterruptMode = Latched;
           } else if (resourceDescriptor->Flags ==
                      CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) {
               ConfigInformation->InterruptMode = LevelSensitive;
           }
       }

       //
       // Check for port descriptor.
       //

       if (resourceDescriptor->Type == CmResourceTypePort) {

          //
          // Verify range count does not exceed what the
          // miniport indicated.
          //

          if (NumberOfAccessRanges > rangeNumber) {

              //
              // Get next access range.
              //

              accessRange =
                  &((*(ConfigInformation->AccessRanges))[rangeNumber]);

              accessRange->RangeStart =
                  resourceDescriptor->u.Port.Start;
              accessRange->RangeLength =
                  resourceDescriptor->u.Port.Length;

              accessRange->RangeInMemory = FALSE;
              rangeNumber++;
          }
       }

       //
       // Check for memory descriptor.
       //

       if (resourceDescriptor->Type == CmResourceTypeMemory) {

          //
          // Verify range count does not exceed what the
          // miniport indicated.
          //

          if (NumberOfAccessRanges > rangeNumber) {

              //
              // Get next access range.
              //

              accessRange =
                  &((*(ConfigInformation->AccessRanges))[rangeNumber]);

              accessRange->RangeStart =
                  resourceDescriptor->u.Memory.Start;
              accessRange->RangeLength =
                  resourceDescriptor->u.Memory.Length;

              accessRange->RangeInMemory = TRUE;
              rangeNumber++;
          }
       }

       //
       // Check for DMA descriptor.
       //

       if (resourceDescriptor->Type == CmResourceTypeDma) {
          ConfigInformation->DmaChannel =
              resourceDescriptor->u.Dma.Channel;
          ConfigInformation->DmaPort =
              resourceDescriptor->u.Dma.Port;
       }

    } // next resource descriptor

    ExFreePool(resourceList);

    //
    // Update bus and slot numbers.
    //

    *BusNumber = pciBus;
    *SlotNumber = slotNumber;

    if(IsMultiFunction) {
        //
        // Save away the next function number to check.
        //

        *FunctionNumber = functionNumber + 1;
    } else {
        //
        // this isn't multifunction so make sure we loop around 
        // to the next one.
        //

        *FunctionNumber = PCI_MAX_FUNCTION;
    }

    ConfigInformation->SystemIoBusNumber = pciBus;
    ConfigInformation->SlotNumber = slotData.u.AsULONG;

    return TRUE;

} // GetPciConfiguration()


ULONG
ScsiPortSetBusDataByOffset(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns writes bus data to a specific offset within a slot.

Arguments:

    DeviceExtension - State information for a particular adapter.

    BusDataType - Supplies the type of bus.

    SystemIoBusNumber - Indicates which system IO bus.

    SlotNumber - Indicates which slot.

    Buffer - Supplies the data to write.

    Offset - Byte offset to begin the write.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Number of bytes written.

--*/

{
    UNREFERENCED_PARAMETER( DeviceExtension );

    return(HalSetBusDataByOffset(BusDataType,
                                 SystemIoBusNumber,
                                 SlotNumber,
                                 Buffer,
                                 Offset,
                                 Length));

} // end ScsiPortSetBusDataByOffset()


BOOLEAN
FindPciDevice(
    PHW_INITIALIZATION_DATA HwInitializationData,
    PULONG BusNumber,
    PULONG SlotNumber,
    PULONG FunctionNumber,
    PBOOLEAN IsMultiFunction
    )

/*++

Routine Description:

    Walk PCI slot information looking for Vendor and Product ID matches.

Arguments:

    HwInitializationData - Miniport description.
    BusNumber - Starting PCI bus for this search.
    SlotNumber - Starting slot number for this search.
    FunctionNumber - Starting function number for this search.

Return Value:

    TRUE if card found.

    Bus, Slot and Function number will contain the address of the adapter 
    found once this routine completes.  These values should be provided to 
    GetPciConfiguration.

--*/

{
    PCI_SLOT_NUMBER     slotData;
    PPCI_COMMON_CONFIG  pciData;
    PCI_COMMON_CONFIG   pciBuffer;
    ULONG               pciBus;
    ULONG               slotNumber;
    ULONG               functionNumber;
    ULONG               length;
    BOOLEAN             moreSlots = TRUE;
    CHAR                vendorString[5];
    CHAR                deviceString[5];

    pciData = &pciBuffer;

    //
    //
    // typedef struct _PCI_SLOT_NUMBER {
    //     union {
    //         struct {
    //             ULONG   DeviceNumber:5;
    //             ULONG   FunctionNumber:3;
    //             ULONG   Reserved:24;
    //         } bits;
    //         ULONG   AsULONG;
    //     } u;
    // } PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;
    //

    slotData.u.AsULONG = 0;

    //
    // Search each PCI bus.
    //

    for (pciBus = *BusNumber; moreSlots && pciBus < 256; pciBus++) {

        //
        // Look at each device.
        //

        for (slotNumber = *SlotNumber;
             moreSlots  &&  slotNumber < PCI_MAX_DEVICES;
             slotNumber++) {

            slotData.u.bits.DeviceNumber = slotNumber;
            *IsMultiFunction = FALSE;

            //
            // Look at each function.
            //

            for (functionNumber = *FunctionNumber;
                moreSlots  &&  functionNumber < PCI_MAX_FUNCTION;
                functionNumber++) {

                slotData.u.bits.FunctionNumber = functionNumber;

                length = HalGetBusDataByOffset(
                            PCIConfiguration,
                            pciBus,
                            slotData.u.AsULONG,
                            pciData,
                            0,
                            FIELD_OFFSET(PCI_COMMON_CONFIG, DeviceSpecific));

                if (length == 0) {

                    //
                    // Out of PCI buses, all done.
                    //

                    moreSlots = FALSE;
                    break;
                }

                if (pciData->VendorID == PCI_INVALID_VENDORID) {
                    if(*IsMultiFunction) {
                        //
                        // Of course function numbers may be sparse - keep 
                        // checking anyway.
                        //
                        continue;
                    } else {
                        //
                        // But since this isn't a multifunction card there's
                        // nothing else to check in this slot.  Or if the 
                        // function is zero then it's not MF.
                        //
                        break;
                    }
                }

                if((slotData.u.bits.FunctionNumber == 0) &&
                   PCI_MULTIFUNCTION_DEVICE(pciData)) {
                    *IsMultiFunction = TRUE;
                }
                    
                //
                // Translate hex ids to strings.
                //

                sprintf(vendorString, "%04x", pciData->VendorID);
                sprintf(deviceString, "%04x", pciData->DeviceID);

                DebugPrint((1,
                           "FindPciDevice: Bus %x Slot %x Function %x Vendor %s Product %s %s\n",
                           pciBus,
                           slotNumber,
                           functionNumber,
                           vendorString,
                           deviceString,
                           (*IsMultiFunction ? "MF" : "")));

                //
                // Compare strings.
                //

                if (_strnicmp(vendorString,
                            HwInitializationData->VendorId,
                            HwInitializationData->VendorIdLength) ||
                    _strnicmp(deviceString,
                            HwInitializationData->DeviceId,
                            HwInitializationData->DeviceIdLength)) {

                    //
                    // Not our PCI device. Try next device/function
                    //

                    if(*IsMultiFunction) {
                        // check next function.
                        continue;
                    } else {
                        // check next slot.
                        break;
                    }
                }

                *BusNumber = pciBus;
                *SlotNumber = slotNumber;
                *FunctionNumber = functionNumber;

                return TRUE;

            }   // next PCI function

            *FunctionNumber = 0;

        }   // next PCI slot

        *SlotNumber = 0;

    }   // next PCI bus

    return FALSE;

} // GetPciConfiguration()



VOID
SpGetSupportedAdapterControlFunctions(
    PDEVICE_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine will query the miniport to determine which adapter control 
    types are supported for the specified adapter.  The 
    SupportedAdapterControlBitmap in the adapter extension will be updated with
    the data returned by the miniport.  These flags are used to determine 
    what functionality (for power management and such) the miniport will support
    
Arguments:    

    Adapter - the adapter to query
    
Return Value:

    none
    
--*/        

{
    UCHAR buffer[sizeof(SCSI_SUPPORTED_CONTROL_TYPE_LIST) + 
                 (sizeof(BOOLEAN) * (ScsiAdapterControlMax + 1))];

    PSCSI_SUPPORTED_CONTROL_TYPE_LIST typeList = 
        (PSCSI_SUPPORTED_CONTROL_TYPE_LIST) buffer;

    SCSI_ADAPTER_CONTROL_STATUS status;

    if(Adapter->HwAdapterControl == NULL) {

        //
        // Adapter control is not supported by the miniport or the miniport 
        // isn't pnp (in which case it's not supported by scsiport) - the 
        // supported array has already been cleared so we can just quit now.
        //
        return;
    }

    RtlZeroMemory(typeList, (sizeof(SCSI_SUPPORTED_CONTROL_TYPE_LIST) + 
                             sizeof(BOOLEAN) * (ScsiAdapterControlMax + 1)));

    typeList->MaxControlType = ScsiAdapterControlMax;

#if DBG
    typeList->SupportedTypeList[ScsiAdapterControlMax] = 0x63;
#endif

    status = SpCallAdapterControl(Adapter,
                                  ScsiQuerySupportedControlTypes,
                                  typeList);

    if(status == ScsiAdapterControlSuccess) {

        Adapter->HasShutdown = typeList->SupportedTypeList[ScsiStopAdapter];
        Adapter->HasSetBoot = typeList->SupportedTypeList[ScsiSetBootConfig];
    }
    return;
}

SCSI_ADAPTER_CONTROL_STATUS 
SpCallAdapterControl(
    IN PDEVICE_EXTENSION Adapter,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    )
{
    DebugPrint((2, "SpCallAdapterControl: Calling adapter control %x for adapter %#08lx with param %#08lx\n", ControlType, Adapter, Parameters));
    return Adapter->HwAdapterControl(
                Adapter->HwDeviceExtension,
                ControlType,
                Parameters);
}


VOID
SpUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    ULONG i;

    UNREFERENCED_PARAMETER( DriverObject );

    for(i = 0; i < MAXIMUM_NUMBER_OF_SCSIPORT_OBJECTS; i++) {
        PDEVICE_OBJECT deviceObject;

        deviceObject = ScsiPortDeviceObject[i];
        
        if(deviceObject != NULL) {

            PDEVICE_EXTENSION deviceExtension;

            deviceExtension = deviceObject->DeviceExtension;

            if(deviceExtension->HasShutdown) {
                SpCallAdapterControl(deviceExtension, ScsiStopAdapter, NULL);

                if(deviceExtension->HasSetBoot) {
                    SpCallAdapterControl(deviceExtension,
                                         ScsiSetBootConfig,
                                         NULL);
                }
            }
        }
        
        //
        // Now that we've shut this one down we can't use it anymore.
        // Since the memory will be reclaimed by the OS we can just throw it 
        // away.
        //

        ScsiPortDeviceObject[i] = NULL;
    }
    return;
}
#endif /* DECSTATION */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\peldr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    peldr.c

Abstract:

    This module implements the code to load a PE format image into memory
    and relocate it if necessary.

Author:

    David N. Cutler (davec) 10-May-1991

Environment:

    Kernel mode only.

Revision History:

--*/

#include "bldr.h"
#include "string.h"
#include "ntimage.h"

#if defined(_GAMBIT_)
#include "ssc.h"
#endif // defined(_GAMBIT_)

//
// Define image prefetch cache structure used in BlLoadImage. Images
// are read as a whole into an allocated buffer and read requests in
// BlLoadImage are satisfied by copying from this buffer if the
// prefetch is successful. I chose to read the whole file in at once
// to simplify code but it limits [although not in practice] the size of
// files that can be prefetched this way, as opposed to prefetching chunks
// of the file at a time.
//

typedef struct _IMAGE_PREFETCH_CACHE {
    ULONG FileId;               // FileId that has been prefetched.
    LARGE_INTEGER Position;     // Current position in the file.
    ULONG ValidDataLength;      // Length of data that was prefetched.
    PUCHAR Data;                // Pointer to cached data.
} IMAGE_PREFETCH_CACHE, *PIMAGE_PREFETCH_CACHE;

//
// The next two defines are used in allocating memory for the image
// cache to direct the allocator into using memory above 1MB and to make
// the allocated memory 64KB aligned. They are in terms of number of pages.
//

#define BL_IMAGE_ABOVE_1MB        (0x200000 >> PAGE_SHIFT)
#define BL_IMAGE_64KB_ALIGNED     (0x10000 >> PAGE_SHIFT)

//
// Define forward referenced prototypes.
//

USHORT
ChkSum(
    ULONG PartialSum,
    PUSHORT Source,
    ULONG Length
    );

ARC_STATUS
BlImageInitCache(
    IN PIMAGE_PREFETCH_CACHE pCache,
    ULONG FileId
    );

ARC_STATUS
BlImageRead(
    IN PIMAGE_PREFETCH_CACHE pCache,
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG pCount
    );

ARC_STATUS
BlImageSeek(
    IN PIMAGE_PREFETCH_CACHE pCache,
    IN ULONG FileId,
    IN PLARGE_INTEGER pOffset,
    IN SEEK_MODE SeekMode
    );

VOID
BlImageFreeCache(
    IN PIMAGE_PREFETCH_CACHE pCache,
    ULONG FileId
    );

#if defined(_X86AMD64_)

//
// Build the 32-bit version of BlLoadImage
// 

#undef  IMAGE_DEFINITIONS
#define IMAGE_DEFINITIONS 32

#undef  BlLoadImageEx
#define BlLoadImageEx BlLoadImage32Ex

#include <ximagdef.h>
#include "amd64\amd64prv.h"
#include "peldrt.c"

//
// Build the 64-bit version of BlLoadImage
// 

#undef  IMAGE_DEFINITIONS
#define IMAGE_DEFINITIONS 64

#undef  BlLoadImageEx
#define BlLoadImageEx BlLoadImage64Ex

#include <ximagdef.h>
#include "peldrt.c"

#undef  BlLoadImageEx

#else   // _X86AMD64_

//
// Non-x86 platforms build only the native version
//

#define IMAGE_NT_HEADER(x) RtlImageNtHeader(x)
#include "peldrt.c"

#endif  // _X86AMD64_



ARC_STATUS
BlImageInitCache(
    IN PIMAGE_PREFETCH_CACHE pCache,
    ULONG FileId
    )

/*++

Routine Description:

    Attempt to allocate memory and prefetch a file. Setup pCache
    structure so it can be passed to BlImageRead/Seek to either copy
    from the cache if prefetch was successful or read from the disk as
    normal. The file must be opened read only and should not be closed
    or modified before calling BlImageFreeCache. The file position of
    FileId is reset to the beginning of the file on success, and is
    undefined on failure. pCache is always setup so it can be used in
    BlImage* I/O functions. If the file could not be prefetched, the
    cache's ValidDataLength will be set to 0 and the I/O functions
    will simply call the Bl* I/O functions [e.g. BlImageRead calls
    BlRead]. Note that the whole file is prefetched at once and this
    puts a limit on the size of files that can be prefetched via this
    cache since boot loader memory is limited. This limit is not hit
    in practice though.

Arguments:

    pCache - Cache structure to setup.

    FileId - File to prefetch.

Return Value:

    ESUCCESS if everything was successful .
    Appropriate ARC_STATUS if there was a problem.

--*/

{
    ARC_STATUS Status = ESUCCESS;
    FILE_INFORMATION FileInfo;
    ULONG FileSize;
    ULONG ActualBase = 0;
    PVOID CacheBufBase = NULL;
    ULONG ReadCount;
    LARGE_INTEGER SeekPosition;

    //
    // Initialize fields of the cache structure.
    //

    pCache->Data = 0;
    pCache->ValidDataLength = 0;
    pCache->Position.QuadPart = 0;
    pCache->FileId = FileId;

    //
    // Get file size.
    //

    Status = BlGetFileInformation(FileId, &FileInfo);

    if (Status != ESUCCESS) {
        goto cleanup;
    }

    //
    // Check if file is too big. File size is at
    // FileInfo.EndingAddress.
    //

    if (FileInfo.EndingAddress.HighPart != 0) {
        Status = E2BIG;
        goto cleanup;
    }

    FileSize = FileInfo.EndingAddress.LowPart;

    //
    // Allocate memory for the cache. In order to avoid fragmenting memory
    // terribly, temporarily change the allocation policy to HighestFit. This
    // causes the drivers to get loaded from the bottom up, while the cache
    // is always at the top of free memory.
    //

    Status = BlAllocateAlignedDescriptor(LoaderFirmwareTemporary,
                                         0,
                                         (FileSize >> PAGE_SHIFT) + 1,
                                         BL_IMAGE_64KB_ALIGNED,
                                         &ActualBase);

    if (Status != ESUCCESS) {
        Status = ENOMEM;
        goto cleanup;
    }

    CacheBufBase = (PVOID) (KSEG0_BASE | (ActualBase << PAGE_SHIFT));

    //
    // Read the file into the prefetch buffer.
    //

    SeekPosition.QuadPart = 0;
    Status = BlSeek(FileId, &SeekPosition, SeekAbsolute);
    if (Status != ESUCCESS) {
        goto cleanup;
    }

    Status = BlRead(FileId, CacheBufBase, FileSize, &ReadCount);
    if (Status != ESUCCESS) {
        goto cleanup;
    }

    if (ReadCount != FileSize) {
        Status = EIO;
        goto cleanup;
    }

    //
    // Reset file position back to beginning.
    //

    SeekPosition.QuadPart = 0;
    Status = BlSeek(FileId, &SeekPosition, SeekAbsolute);
    if (Status != ESUCCESS) {
        goto cleanup;
    }

    //
    // The file was successfully prefetched.
    //

    pCache->Data = CacheBufBase;
    CacheBufBase = NULL;
    pCache->ValidDataLength = FileSize;

 cleanup:
    if ((CacheBufBase != NULL) && (ActualBase != 0)) {
        BlFreeDescriptor(ActualBase);
    }

    return Status;
}

ARC_STATUS
BlImageRead(
    IN PIMAGE_PREFETCH_CACHE pCache,
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG pCount
    )

/*++

Routine Description:

    A wrapper for BlRead. Checks to see if the request can be
    satisfied from pCache first. If not calls BlRead.

Arguments:

    pCache - Prefetch Cache for FileId

    FileId, Buffer, Length, Count - BlRead parameters

Return Value:

    Status that would be returned by BlRead.

--*/

{
    LONG AdjustedLength;

    //
    // If the cache buffer does not exist or the cached size is 0,
    // hand over the call to BlRead.
    //

    if (!pCache->Data || !pCache->ValidDataLength) {
        return BlRead(FileId, Buffer, Length, pCount);
    }

    //
    // Clear read bytes count.
    //

    *pCount = 0;

    //
    // Determine how many bytes we can copy from our current position till
    // EOF, if there is not Length bytes.
    //

    AdjustedLength = (LONG)pCache->ValidDataLength - (LONG)pCache->Position.LowPart;
    if (AdjustedLength < 0) {
        AdjustedLength = 0;
    }
    AdjustedLength = ((ULONG)AdjustedLength < Length) ? AdjustedLength : Length;

    //
    // Copy AdjustedLength bytes into target buffer and advance the file position.
    //

    RtlCopyMemory(Buffer, pCache->Data + pCache->Position.LowPart, AdjustedLength);
    pCache->Position.LowPart += AdjustedLength;

    //
    // Update number of bytes read.
    //

    *pCount = AdjustedLength;

    return ESUCCESS;
}

ARC_STATUS
BlImageSeek(
    IN PIMAGE_PREFETCH_CACHE pCache,
    IN ULONG FileId,
    IN PLARGE_INTEGER pOffset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    A wrapper for BlSeek. Calls BlSeek and if successful, updates the
    position in the cache structure as well. We call BlSeek to update
    the file position as well because at any time the cache may be
    freed or invalidated and we have to be able to continue calling on
    Bl* I/O functions transparently.

Arguments:

    pCache - Prefetch Cache for FileId.

    FileId, Offset, SeekMode - BlSeek parameters.

Return Value:

    Status that would be returned by BlSeek.

--*/

{
    ARC_STATUS Status;

    //
    // Do not allow setting position to too big. We do not open such
    // files anyway and the boot loader file systems and other places
    // in the boot loader I/O system do not handle it.
    //

    if (pOffset->HighPart != 0) {
        return E2BIG;
    }

    //
    // Try to update file position.
    //

    Status = BlSeek(FileId, pOffset, SeekMode);

    if (Status != ESUCCESS) {
        return Status;
    }

    //
    // Update the position in cached buffer. We don't perform
    // checks since BlSeek accepted the new offset.
    //

    pCache->Position.QuadPart = pOffset->QuadPart;

    return Status;
}

VOID
BlImageFreeCache(
    IN PIMAGE_PREFETCH_CACHE pCache,
    ULONG FileId
    )

/*++

Routine Description:

    Free the memory allocated for the prefetch cache for FileId in
    pCache. Sets ValidDataLength to 0 to stop caching.

Arguments:

    pCache - Cache structure to setup

    FileId - File that was opened read-only to be cached.

Return Value:

    None.

--*/

{
    ULONG DescBase;

    UNREFERENCED_PARAMETER( FileId );

    //
    // NOTE: ValidDataLength may be zero, but we still allocate at least
    // a page and we have to free that.
    //

    if (pCache->Data) {
        DescBase = (ULONG)((ULONG_PTR)pCache->Data & (~KSEG0_BASE));
        BlFreeDescriptor(DescBase >> PAGE_SHIFT);
        pCache->Data = NULL;
    }

    pCache->ValidDataLength = 0;

    return;
}

#if defined(_X86AMD64_)


ARC_STATUS
BlLoadImageEx(
    IN ULONG DeviceId,
    IN TYPE_OF_MEMORY MemoryType,
    IN PCHAR LoadFile,
    IN USHORT ImageType,
    IN OPTIONAL ULONG PreferredAlignment,
    IN OPTIONAL ULONG PreferredBasePage,
    OUT PVOID *ImageBase
    )

/*++

Routine Description:

    This routine attempts to load the specified file from the specified
    device.

Arguments:

    DeviceId - Supplies the file table index of the device to load the
        specified image file from.

    MemoryType - Supplies the type of memory to to be assigned to the
        allocated memory descriptor.

    BootFile - Supplies a pointer to string descriptor for the name of
        the file to load.

    ImageType - Supplies the type of image that is expected.

    PreferredAlignment - If present, supplies the preferred image alignment.

    PreferredBasePage - If present, supplies the preferred base page which will
        override the image base address

    ImageBase - Supplies a pointer to a variable that receives the
        address of the image base.

Return Value:

    ESUCCESS is returned if the specified image file is loaded
    successfully. Otherwise, an unsuccessful status is returned
    that describes the reason for failure.

--*/

{
    ARC_STATUS status;

    if (BlAmd64UseLongMode == FALSE) {

        status = BlLoadImage32Ex( DeviceId,
                                  MemoryType,
                                  LoadFile,
                                  ImageType,
                                  PreferredAlignment,
                                  PreferredBasePage,
                                  ImageBase );
    } else {

        status = BlLoadImage64Ex( DeviceId,
                                  MemoryType,
                                  LoadFile,
                                  ImageType,
                                  PreferredAlignment,
                                  PreferredBasePage,
                                  ImageBase );
    }

    return status;
}


#endif  // _X86AMD64_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\parseini.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    parseini.c

Abstract:

    This module implements functions to parse a .INI file

Author:

    John Vert (jvert) 7-Oct-1993

Revision History:

    John Vert (jvert) 7-Oct-1993 - largely lifted from splib\spinf.c

--*/

#include "parseini.h"
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

#define SpFree(x)

// what follows was alpar.h

//
//   EXPORTED BY THE PARSER AND USED BY BOTH THE PARSER AND
//   THE INF HANDLING COMPONENTS
//

// typedefs exported
//

typedef struct _value {
    struct _value *pNext;
    PCHAR  pName;
#ifdef UNICODE
    PWCHAR  pNameW;
#endif
    } VALUE, *PVALUE;

#define NUMBER_OF_INTERNAL_VALUES 10

typedef struct _line {
    struct _line *pNext;
    PCHAR   pName;
    PCHAR   InternalValues[NUMBER_OF_INTERNAL_VALUES];
#ifdef  UNICODE
    PWCHAR  pNameW;
    PWCHAR  InternalValuesW[NUMBER_OF_INTERNAL_VALUES];
#endif
    PVALUE  pFirstExternalValue;
    } LINE, *PLINE;

typedef struct _section {
    struct _section *pNext;
    PCHAR    pName;
#ifdef UNICODE
    PWCHAR   pNameW;
#endif
    PLINE    pLine;
    } SECTION, *PSECTION;

typedef struct _inf {
    PSECTION pSection;
    } INF, *PINF;

//
// Routines exported
//

PVOID
ParseInfBuffer(
    PCHAR INFFile,
    PCHAR Buffer,
    ULONG Size,
    PULONG ErrorLine
    );

//
// DEFINES USED FOR THE PARSER INTERNALLY
//
//
// typedefs used
//

typedef enum _tokentype {
    TOK_EOF,
    TOK_EOL,
    TOK_LBRACE,
    TOK_RBRACE,
    TOK_STRING,
    TOK_EQUAL,
    TOK_COMMA,
    TOK_ERRPARSE,
    TOK_ERRNOMEM
    } TOKENTYPE, *PTOKENTTYPE;


typedef struct _token {
    TOKENTYPE Type;
    PCHAR     pValue;
    } TOKEN, *PTOKEN;


//
// Routine defines
//

ARC_STATUS
SpAppendSection(
    IN PCHAR pSectionName
#ifdef UNICODE 
    , IN PWCHAR pSectionNameW
#endif
    );

ARC_STATUS
SpAppendLine(
    IN PCHAR pLineKey
#ifdef UNICODE 
    , IN PWCHAR pLineKeyW
#endif
    );

ARC_STATUS
SpAppendValue(
    IN PCHAR pValueString
#ifdef UNICODE 
    , IN PWCHAR pValueStringW
#endif
    );

TOKEN
SpGetToken(
    IN OUT PCHAR *Stream,
    IN PCHAR     MaxStream
    );

// Global added to provide INF filename for friendly error messages.
PCHAR pchINFName = NULL;

// what follows was alinf.c

//
// Internal Routine Declarations for freeing inf structure members
//

VOID
FreeSectionList (
   IN PSECTION pSection
   );

VOID
FreeLineList (
   IN PLINE pLine
   );

VOID
FreeValueList (
   IN PVALUE pValue
   );


//
// Internal Routine declarations for searching in the INF structures
//


PCHAR
SearchValueInLine(
   IN PLINE pLine,
   IN ULONG ValueIndex
   );

PLINE
SearchLineInSectionByKey(
   IN  PSECTION pSection,
   IN  PCHAR    Key,
   OUT PULONG   pOrdinal    OPTIONAL
   );

PLINE
SearchLineInSectionByIndex(
   IN PSECTION pSection,
   IN ULONG    LineIndex
   );

PSECTION
SearchSectionByName(
   IN PINF  pINF,
   IN PCHAR SectionName
   );

PCHAR
ProcessForStringSubs(
    IN PINF  pInf,
    IN PCHAR String
    );

#ifdef UNICODE
PWCHAR
SearchValueInLineW(
   IN PLINE pLine,
   IN ULONG ValueIndex
   );

PWCHAR
ProcessForStringSubsW(
    IN PINF  pInf,
    IN PWCHAR String
    );
#endif


//
// ROUTINE DEFINITIONS
//


PCHAR
SlGetIniValue(
    IN PVOID InfHandle,
    IN PCHAR SectionName,
    IN PCHAR KeyName,
    IN PCHAR Default
    )

/*++

Routine Description:

    Searches an INF handle for a given section/key value.

Arguments:

    InfHandle - Supplies a handle returned by SlInitIniFile.

    SectionName - Supplies the name of the section to search

    KeyName - Supplies the name of the key whose value should be returned.

    Default - Supplies the default setting, returned if the specified key
            is not found.

Return Value:

    Pointer to the value of the key, if the key is found

    Default, if the key is not found.

--*/

{
    PCHAR Value;

    Value = SlGetSectionKeyIndex(InfHandle,
                                 SectionName,
                                 KeyName,
                                 0);
    if (Value==NULL) {
        Value = Default;
    }

    return(Value);

}

#ifdef UNICODE

PWCHAR
SlGetIniValueW(
    IN PVOID InfHandle,
    IN PCHAR SectionName,
    IN PCHAR KeyName,
    IN PWCHAR Default
    )

/*++

Routine Description:

    Searches an INF handle for a given section/key value.

Arguments:

    InfHandle - Supplies a handle returned by SlInitIniFile.

    SectionName - Supplies the name of the section to search

    KeyName - Supplies the name of the key whose value should be returned.

    Default - Supplies the default setting, returned if the specified key
            is not found.

Return Value:

    Pointer to the value of the key, if the key is found

    Default, if the key is not found.

--*/

{
    PWCHAR Value;

    Value = SlGetSectionKeyIndexW(InfHandle,
                                  SectionName,
                                  KeyName,
                                  0);
    if (Value==NULL) {
        Value = Default;
    }

    return(Value);

}
#endif

//
// returns a handle to use for further inf parsing
//

ARC_STATUS
SlInitIniFile(
   IN  PCHAR   DevicePath,
   IN  ULONG   DeviceId,
   IN  PCHAR   INFFile,
   OUT PVOID  *pINFHandle,
   OUT PVOID  *pINFBuffer OPTIONAL,
   OUT PULONG  INFBufferSize OPTIONAL,
   OUT PULONG  ErrorLine
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    ARC_STATUS Status;
    ULONG      DeviceID,FileID;
    PCHAR      Buffer;
    ULONG      Size, SizeRead;
    FILE_INFORMATION FileInfo;
    ULONG       PageCount;
    ULONG       ActualBase;

    *ErrorLine = BL_INF_FILE_ERROR;

    //
    // If required, open the device
    //

    if(DevicePath) {
        Status = ArcOpen(DevicePath,ArcOpenReadOnly,&DeviceID);
        if (Status != ESUCCESS) {
            return( Status );
        }
    } else {
        DeviceID = DeviceId;
    }

    //
    // Open the file
    //

    Status = BlOpen(DeviceID,INFFile,ArcOpenReadOnly,&FileID);
    if (Status != ESUCCESS) {
        // We report better error messages elsewhere
        // SlMessageBox(SL_FILE_LOAD_FAILED,INFFile,Status);
        pchINFName = NULL;
        goto xx0;
    } else {
        pchINFName = INFFile;
    }

    //
    // find out size of INF file
    //

    Status = BlGetFileInformation(FileID, &FileInfo);
    if (Status != ESUCCESS) {
        BlClose(FileID);
        goto xx0;
    }
    Size = FileInfo.EndingAddress.LowPart;

    //
    // Allocate a descriptor large enough to hold the entire file.
    // On x86 this has an unfortunate tendency to slam txtsetup.sif
    // into a free block at 1MB, which means the kernel can't be
    // loaded (it's linked for 0x100000 without relocations).
    // On x86 this has an unfortunate tendency to slam txtsetup.sif
    // into a free block at 1MB, which means the kernel can't be
    // loaded (it's linked for 0x100000 without relocations).
    //
    // (tedm) we're also seeing a similar problem on alphas now
    // because txtsetup.sif has grown too large, so this code has been
    // made non-conditional.
    //
    {

        PageCount = (ULONG)(ROUND_TO_PAGES(Size) >> PAGE_SHIFT);

        Status = BlAllocateDescriptor(LoaderOsloaderHeap,
                                      0,
                                      PageCount,
                                      &ActualBase);

    }

    if (Status != ESUCCESS) {
        BlClose(FileID);
        goto xx0;
    }

    Buffer = (PCHAR)(KSEG0_BASE | (ActualBase << PAGE_SHIFT));

    //
    // read the file in
    //

    Status = BlRead(FileID, Buffer, Size, &SizeRead);
    if (Status != ESUCCESS) {
        BlClose(FileID);
        goto xx0;
    }

    if ( pINFBuffer != NULL ) {
        *pINFBuffer = Buffer;
        *INFBufferSize = SizeRead;
    }

    //
    // parse the file
    //
    if((*pINFHandle = ParseInfBuffer(INFFile, Buffer, SizeRead, ErrorLine)) == (PVOID)NULL) {
        Status = EBADF;
    } else {
        Status = ESUCCESS;
    }

    //
    // Clean up and return
    //
    BlClose(FileID);

    xx0:

    if(DevicePath) {
        ArcClose(DeviceID);
    }

    return( Status );

}

//
// frees an INF Buffer
//
ARC_STATUS
SpFreeINFBuffer (
   IN PVOID INFHandle
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PINF       pINF;

   //
   // Valid INF Handle?
   //

   if (INFHandle == (PVOID)NULL) {
       return ESUCCESS;
   }

   //
   // cast the buffer into an INF structure
   //

   pINF = (PINF)INFHandle;

   FreeSectionList(pINF->pSection);

   //
   // free the inf structure too
   //

   SpFree(pINF);

   return( ESUCCESS );
}


VOID
FreeSectionList (
   IN PSECTION pSection
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PSECTION Next;

    while(pSection) {
        Next = pSection->pNext;
        FreeLineList(pSection->pLine);
        if(pSection->pName) {
            SpFree(pSection->pName);
        }
#ifdef UNICODE
        if(pSection->pNameW) {
            SpFree(pSection->pNameW);
        }
#endif
        SpFree(pSection);
        pSection = Next;
    }
}


VOID
FreeLineList (
   IN PLINE pLine
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PLINE Next;

    while(pLine) {
        Next = pLine->pNext;
        FreeValueList(pLine->pFirstExternalValue);
        if(pLine->pName) {
            SpFree(pLine->pName);
        }
#ifdef UNICODE
        if(pLine->pNameW) {
            SpFree(pLine->pNameW);
        }
#endif
        SpFree(pLine);
        pLine = Next;
    }
}

VOID
FreeValueList (
   IN PVALUE pValue
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PVALUE Next;

    while(pValue) {
        Next = pValue->pNext;
        if(pValue->pName) {
            SpFree(pValue->pName);
        }
#ifdef UNICODE
        if(pValue->pNameW) {
            SpFree(pValue->pNameW);
        }
#endif
        SpFree(pValue);
        pValue = Next;
    }
}


//
// searches for the existance of a particular section
//
BOOLEAN
SpSearchINFSection (
   IN PVOID INFHandle,
   IN PCHAR SectionName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;

   //
   // if search for section fails return false
   //

   if ((pSection = SearchSectionByName(
                       (PINF)INFHandle,
                       SectionName
                       )) == (PSECTION)NULL) {
       return( FALSE );
   }

   //
   // else return true
   //
   return( TRUE );

}




//
// given section name, line number and index return the value.
//
PCHAR
SlGetSectionLineIndex (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN ULONG LineIndex,
   IN ULONG ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE    pLine;
   PCHAR    pName;

   if((pSection = SearchSectionByName(
                      (PINF)INFHandle,
                      SectionName
                      ))
                      == (PSECTION)NULL)
       return((PCHAR)NULL);

   if((pLine = SearchLineInSectionByIndex(
                      pSection,
                      LineIndex
                      ))
                      == (PLINE)NULL)
       return((PCHAR)NULL);

   if((pName = SearchValueInLine(
                      pLine,
                      ValueIndex
                      ))
                      == (PCHAR)NULL)
       return((PCHAR)NULL);

   return(ProcessForStringSubs(INFHandle,pName));

}


#ifdef UNICODE
//
// given section name, line number and index return the value.
//
PWCHAR
SlGetSectionLineIndexW (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN ULONG LineIndex,
   IN ULONG ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE    pLine;
   PWCHAR    pName;

   if((pSection = SearchSectionByName(
                      (PINF)INFHandle,
                      SectionName
                      ))
                      == (PSECTION)NULL)
       return((PWCHAR)NULL);

   if((pLine = SearchLineInSectionByIndex(
                      pSection,
                      LineIndex
                      ))
                      == (PLINE)NULL)
       return((PWCHAR)NULL);

   if((pName = SearchValueInLineW(
                      pLine,
                      ValueIndex
                      ))
                      == (PWCHAR)NULL)
       return((PWCHAR)NULL);

   return(ProcessForStringSubsW(INFHandle,pName));

}
#endif


BOOLEAN
SpGetSectionKeyExists (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN PCHAR Key
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;

   if((pSection = SearchSectionByName(
                      (PINF)INFHandle,
                      SectionName
                      ))
              == (PSECTION)NULL) {
       return( FALSE );
   }

   if (SearchLineInSectionByKey(pSection, Key, NULL) == (PLINE)NULL) {
       return( FALSE );
   }

   return( TRUE );
}


PCHAR
SlGetKeyName(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex
    )
{
    PSECTION pSection;
    PLINE    pLine;

    pSection = SearchSectionByName((PINF)INFHandle,SectionName);
    if(pSection == NULL) {
        return(NULL);
    }

    pLine = SearchLineInSectionByIndex(pSection,LineIndex);
    if(pLine == NULL) {
        return(NULL);
    }

    return(pLine->pName);
}

#ifdef UNICODE
PWCHAR
SlGetKeyNameW(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex
    )
{
    PSECTION pSection;
    PLINE    pLine;

    pSection = SearchSectionByName((PINF)INFHandle,SectionName);
    if(pSection == NULL) {
        return(NULL);
    }

    pLine = SearchLineInSectionByIndex(pSection,LineIndex);
    if(pLine == NULL) {
        return(NULL);
    }

    return(pLine->pNameW);
}
#endif


//
// given section name and key, return (0-based) ordinal for this entry
// (returns -1 on error)
//
ULONG
SlGetSectionKeyOrdinal(
    IN  PVOID INFHandle,
    IN  PCHAR SectionName,
    IN  PCHAR Key
    )
{
    PSECTION pSection;
    PLINE    pLine;
    ULONG    Ordinal;


    pSection = SearchSectionByName(
                      (PINF)INFHandle,
                      SectionName
                      );

    pLine = SearchLineInSectionByKey(
                pSection,
                Key,
                &Ordinal
                );

    if(pLine == (PLINE)NULL) {
        return BL_INF_FILE_ERROR;
    } else {
        return Ordinal;
    }
}


//
// given section name, key and index return the value
//
PCHAR
SlGetSectionKeyIndex (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN PCHAR Key,
   IN ULONG ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE    pLine;
   PCHAR    pName;

   if((pSection = SearchSectionByName(
                      (PINF)INFHandle,
                      SectionName
                      ))
                      == (PSECTION)NULL)
       return((PCHAR)NULL);

   if((pLine = SearchLineInSectionByKey(
                      pSection,
                      Key,
                      NULL
                      ))
                      == (PLINE)NULL)
       return((PCHAR)NULL);

   if((pName = SearchValueInLine(
                      pLine,
                      ValueIndex
                      ))
                      == (PCHAR)NULL)
       return((PCHAR)NULL);

   return(ProcessForStringSubs(INFHandle,pName));
}

#ifdef UNICODE
//
// given section name, key and index return the value
//
PWCHAR
SlGetSectionKeyIndexW (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN PCHAR Key,
   IN ULONG ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE    pLine;
   PWCHAR    pName;

   if((pSection = SearchSectionByName(
                      (PINF)INFHandle,
                      SectionName
                      ))
                      == (PSECTION)NULL)
       return((PWCHAR)NULL);

   if((pLine = SearchLineInSectionByKey(
                      pSection,
                      Key,
                      NULL
                      ))
                      == (PLINE)NULL)
       return((PWCHAR)NULL);

   if((pName = SearchValueInLineW(
                      pLine,
                      ValueIndex
                      ))
                      == (PWCHAR)NULL)
       return((PWCHAR)NULL);

   return(ProcessForStringSubsW(INFHandle,pName));
}
#endif


ULONG
SlCountLinesInSection(
    IN PVOID INFHandle,
    IN PCHAR SectionName
    )
{
    PSECTION pSection;
    PLINE    pLine;
    ULONG    Count;

    if((pSection = SearchSectionByName((PINF)INFHandle,SectionName)) == NULL) {
        return(BL_INF_FILE_ERROR);
    }

    for(pLine = pSection->pLine, Count = 0;
        pLine;
        pLine = pLine->pNext, Count++
       );

    return(Count);
}


PCHAR
SearchValueInLine(
   IN PLINE pLine,
   IN ULONG ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PVALUE pValue;
   ULONG  i;

   if (pLine == (PLINE)NULL)
       return ((PCHAR)NULL);

   if (ValueIndex < NUMBER_OF_INTERNAL_VALUES) {
       return pLine->InternalValues[ValueIndex];
   }

   pValue = pLine->pFirstExternalValue;
   for (i = NUMBER_OF_INTERNAL_VALUES;
        i < ValueIndex && ((pValue = pValue->pNext) != (PVALUE)NULL);
        i++)
      ;

   return (PCHAR)((pValue != NULL) ? pValue->pName : NULL);

}

#ifdef UNICODE
PWCHAR
SearchValueInLineW(
   IN PLINE pLine,
   IN ULONG ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PVALUE pValue;
   ULONG  i;

   if (pLine == (PLINE)NULL)
       return ((PWCHAR)NULL);

   if (ValueIndex < NUMBER_OF_INTERNAL_VALUES) {
       return pLine->InternalValuesW[ValueIndex];
   }

   pValue = pLine->pFirstExternalValue;
   for (i = NUMBER_OF_INTERNAL_VALUES;
        i < ValueIndex && ((pValue = pValue->pNext) != (PVALUE)NULL);
        i++)
      ;

   return (PWCHAR)((pValue != NULL) ? pValue->pNameW : NULL);

}
#endif


PLINE
SearchLineInSectionByKey(
   IN  PSECTION pSection,
   IN  PCHAR    Key,
   OUT PULONG   pOrdinal    OPTIONAL
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PLINE pLine;
   ULONG LineOrdinal;

   if (pSection == (PSECTION)NULL || Key == (PCHAR)NULL) {
       return ((PLINE)NULL);
   }

   pLine = pSection->pLine;
   LineOrdinal = 0;
   while ((pLine != (PLINE)NULL) && (pLine->pName == NULL || _stricmp(pLine->pName, Key))) {
       pLine = pLine->pNext;
       LineOrdinal++;
   }

   if(pLine && pOrdinal) {
       *pOrdinal = LineOrdinal;
   }

   return pLine;

}


PLINE
SearchLineInSectionByIndex(
   IN PSECTION pSection,
   IN ULONG    LineIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PLINE pLine;
   ULONG  i;

   //
   // Validate the parameters passed in
   //

   if (pSection == (PSECTION)NULL) {
       return ((PLINE)NULL);
   }

   //
   // find the start of the line list in the section passed in
   //

   pLine = pSection->pLine;

   //
   // traverse down the current line list to the LineIndex th line
   //

   for (i = 0; i < LineIndex && ((pLine = pLine->pNext) != (PLINE)NULL); i++) {
      ;
   }

   //
   // return the Line found
   //

   return pLine;

}


PSECTION
SearchSectionByName(
   IN PINF  pINF,
   IN PCHAR SectionName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;

   //
   // validate the parameters passed in
   //

   if (pINF == (PINF)NULL || SectionName == (PCHAR)NULL) {
       return ((PSECTION)NULL);
   }

   //
   // find the section list
   //
   pSection = pINF->pSection;

   //
   // traverse down the section list searching each section for the section
   // name mentioned
   //

   while ((pSection != (PSECTION)NULL) && _stricmp(pSection->pName, SectionName)) {
       pSection = pSection->pNext;
   }

   //
   // return the section at which we stopped (either NULL or the section
   // which was found
   //

   return pSection;

}


PCHAR
ProcessForStringSubs(
    IN PINF  pInf,
    IN PCHAR String
    )
{
    unsigned Len;
    PCHAR ReturnString;
    PSECTION pSection;
    PLINE pLine;

    //
    // Assume no substitution necessary.
    //
    ReturnString = String;

    //
    // If it starts and ends with % then look it up in the
    // strings section. Note the initial check before doing a
    // strlen, to preserve performance in the 99% case where
    // there is no substitution.
    //
    if((String[0] == '%') && ((Len = (ULONG)strlen(String)) > 2) && (String[Len-1] == '%')) {

        for(pSection = pInf->pSection; pSection; pSection=pSection->pNext) {
            if(pSection->pName && !_stricmp(pSection->pName,"Strings")) {
                break;
            }
        }

        if(pSection) {

            for(pLine = pSection->pLine; pLine; pLine=pLine->pNext) {
                if(pLine->pName
                && !_strnicmp(pLine->pName,String+1,Len-2)
                && (pLine->pName[Len-2] == 0))
                {
                    break;
                }
            }

            if(pLine && pLine->InternalValues[0]) {
                ReturnString = pLine->InternalValues[0];
            }
        }
    }

    return(ReturnString);
}

#ifdef UNICODE
PWCHAR
ProcessForStringSubsW(
    IN PINF  pInf,
    IN PWCHAR String
    )
{
    unsigned Len;
    PWCHAR ReturnString;
    PSECTION pSection;
    PLINE pLine;

    //
    // Assume no substitution necessary.
    //
    ReturnString = String;

    //
    // If it starts and ends with % then look it up in the
    // strings section. Note the initial check before doing a
    // strlen, to preserve performance in the 99% case where
    // there is no substitution.
    //
    if((String[0] == L'%') && ((Len = (ULONG)wcslen(String)) > 2) && (String[Len-1] == L'%')) {

        for(pSection = pInf->pSection; pSection; pSection=pSection->pNext) {
            if(pSection->pName && !_stricmp(pSection->pName,"Strings")) {
                break;
            }
        }

        if(pSection) {

            for(pLine = pSection->pLine; pLine; pLine=pLine->pNext) {
                if(pLine->pName
                && !_tcsnicmp(pLine->pNameW,String+1,Len-2)
                && (pLine->pName[Len-2] == 0))
                {
                    break;
                }
            }

            if(pLine && pLine->InternalValuesW[0]) {
                ReturnString = pLine->InternalValuesW[0];
            }
        }
    }

    return(ReturnString);
}
#endif



// what follows was alparse.c


//
//  Globals used to make building the lists easier
//

PINF     pINF;
PSECTION pSectionRecord;
PLINE    pLineRecord;
PVALUE   pValueRecord;
PCHAR *  pInternalValue;
PCHAR *  pLastInternalValue;

#ifdef UNICODE
PWCHAR *  pInternalValueW;
PWCHAR *  pLastInternalValueW;
#endif


//
// Globals used by the token parser
//

// string terminators are the whitespace characters (isspace: space, tab,
// linefeed, formfeed, vertical tab, carriage return) or the chars given below

CHAR  StringTerminators[] = "[]=,\t \"\n\f\v\r";
PCHAR QStringTerminators = StringTerminators+6;
PCHAR EmptyValue;

#define STRING_HEAP_SIZE 1024

ULONG_PTR StringHeapFree = 0;
ULONG_PTR StringHeapLimit = 0;

#if 0 && DBG

#define HEAP_SIZE(_size) (((_size) + BL_GRANULARITY - 1) & ~(BL_GRANULARITY - 1))
#define MAX(_a,_b) (((_a) > (_b)) ? (_a) : (_b))
#define MIN(_a,_b) (((_a) < (_b)) ? (_a) : (_b))

ULONG nStrings = 0;
ULONG maxString = 0;
ULONG bytesStrings = 0;
ULONG wasteStrings = 0;
ULONG stringsWithNLength[12] = {0};

VOID
GetStatistics (
    PINF pINF
    )
{
    ULONG nSections = 0;
    ULONG nLines = 0;
    ULONG nValues = 0;
    ULONG maxLinesPerSection = 0;
    ULONG maxValuesPerLine = 0;
    ULONG maxValuesPerSection = 0;
    ULONG bytesSections = 0;
    ULONG bytesLines = 0;
    ULONG bytesValues = 0;

    ULONG sectionsWithNLines[12] = {0};
    ULONG linesWithNValues[12] = {0};
    ULONG sectionsWithNValues[12] = {0};

    ULONG linesThisSection;
    ULONG valuesThisLine;
    ULONG valuesThisSection;

    PSECTION section;
    PLINE line;
    PVALUE value;

    ULONG i;

    section = pINF->pSection;
    while ( section != NULL ) {
        nSections++;
        bytesSections += HEAP_SIZE(sizeof(SECTION));
        linesThisSection = 0;
        valuesThisSection = 0;
        line = section->pLine;
        while ( line != NULL ) {
            linesThisSection++;
            bytesLines += HEAP_SIZE(sizeof(LINE));
            valuesThisLine = 0;
            for ( i = 0; i < NUMBER_OF_INTERNAL_VALUES; i++ ) {
                if ( line->InternalValues[i] != NULL ) {
                    valuesThisLine++;
                }
            }
            value = line->pFirstExternalValue;
            while ( value != NULL ) {
                valuesThisLine++;
                bytesValues += HEAP_SIZE(sizeof(VALUE));
                value = value->pNext;
            }
            nValues += valuesThisLine;
            valuesThisSection += valuesThisLine;
            maxValuesPerLine = MAX(maxValuesPerLine, valuesThisLine);
            linesWithNValues[MIN(valuesThisLine,11)]++;
            line = line->pNext;
        }
        nLines += linesThisSection;
        maxLinesPerSection = MAX(maxLinesPerSection, linesThisSection);
        sectionsWithNLines[MIN(linesThisSection,11)]++;
        maxValuesPerSection = MAX(maxValuesPerSection, valuesThisSection);
        sectionsWithNValues[MIN(valuesThisSection,11)]++;
        section = section->pNext;
    }

    DbgPrint( "Number of sections = %d\n", nSections );
    DbgPrint( "Bytes in sections  = %d\n", bytesSections );
    DbgPrint( "\n" );
    DbgPrint( "Number of lines    = %d\n", nLines );
    DbgPrint( "Bytes in lines     = %d\n", bytesLines );
    DbgPrint( "\n" );
    DbgPrint( "Number of values    = %d\n", nValues );
    DbgPrint( "Bytes in values     = %d\n", bytesValues );
    DbgPrint( "\n" );
    DbgPrint( "Max lines/section   = %d\n", maxLinesPerSection );
    DbgPrint( "Max values/line     = %d\n", maxValuesPerLine );
    DbgPrint( "Max values/section  = %d\n", maxValuesPerSection );
    DbgPrint( "\n" );
    DbgPrint( "Number of strings          = %d\n", nStrings );
    DbgPrint( "Bytes in strings           = %d\n", bytesStrings );
    DbgPrint( "Wasted bytes in strings    = %d\n", wasteStrings + (StringHeapLimit - StringHeapFree) );
    DbgPrint( "Longest string             = %d\n", maxString );
    DbgPrint( "\n" );
    DbgPrint( "Sections with N lines  =" );
    for ( i = 0; i < 12; i++ ) {
        DbgPrint( " %5d", sectionsWithNLines[i] );
    }
    DbgPrint( "\n" );
    DbgPrint( "Sections with N values =" );
    for ( i = 0; i < 12; i++ ) {
        DbgPrint( " %5d", sectionsWithNValues[i] );
    }
    DbgPrint( "\n" );
    DbgPrint( "Lines with N values    =" );
    for ( i = 0; i < 12; i++ ) {
        DbgPrint( " %5d", linesWithNValues[i] );
    }
    DbgPrint( "\n" );
    DbgPrint( "String with length N   =" );
    for ( i = 0; i < 12; i++ ) {
        DbgPrint( " %5d", stringsWithNLength[i] );
    }
    DbgPrint( "\n" );

    DbgBreakPoint();
}

#endif // DBG

//
// Main parser routine
//

PVOID
ParseInfBuffer(
    PCHAR INFFile,
    PCHAR Buffer,
    ULONG Size,
    PULONG ErrorLine
    )

/*++

Routine Description:

   Given a character buffer containing the INF file, this routine parses
   the INF into an internal form with Section records, Line records and
   Value records.

Arguments:

   Buffer - contains to ptr to a buffer containing the INF file

   Size - contains the size of the buffer.

   ErrorLine - if a parse error occurs, this variable receives the line
        number of the line containing the error.


Return Value:

   PVOID - INF handle ptr to be used in subsequent INF calls.

--*/

{
    PCHAR      Stream, MaxStream, pchSectionName = NULL, pchValue = NULL;
    ULONG      State, InfLine;
    TOKEN      Token;
    BOOLEAN       Done;
    BOOLEAN       Error;
    ARC_STATUS ErrorCode = ESUCCESS;

    //
    // Initialise the globals
    //
    pINF            = (PINF)NULL;
    pSectionRecord  = (PSECTION)NULL;
    pLineRecord     = (PLINE)NULL;
    pValueRecord    = (PVALUE)NULL;
    pInternalValue  = NULL;
    pLastInternalValue = NULL;
#ifdef UNICODE
    pInternalValueW  = NULL;
    pLastInternalValueW = NULL;
#endif

    //
    // Need EmptyValue to point at a nul character
    //
    EmptyValue = StringTerminators + strlen(StringTerminators);

    //
    // Get INF record
    //
    if ((pINF = (PINF)BlAllocateHeap(sizeof(INF))) == NULL) {
        SlNoMemoryError();
        return NULL;
    }
    pINF->pSection = NULL;

    //
    // Set initial state
    //
    State     = 1;
    InfLine   = 1;
    Stream    = Buffer;
    MaxStream = Buffer + Size;
    Done      = FALSE;
    Error     = FALSE;

    //
    // Enter token processing loop
    //

    while (!Done)       {

       Token = SpGetToken(&Stream, MaxStream);

       switch (State) {
       //
       // STATE1: Start of file, this state remains till first
       //         section is found
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_LBRACE
       case 1:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  SlBadInfLineError(InfLine, INFFile);
                  break;
           }
           break;

       //
       // STATE 2: Section LBRACE has been received, expecting STRING
       //
       // Valid Tokens: TOK_STRING
       //
       case 2:
           switch (Token.Type) {
              case TOK_STRING:
                  State = 3;
                  pchSectionName = Token.pValue;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  SlBadInfLineError(InfLine, INFFile);
                  break;

           }
           break;

       //
       // STATE 3: Section Name received, expecting RBRACE
       //
       // Valid Tokens: TOK_RBRACE
       //
       case 3:
           switch (Token.Type) {
              case TOK_RBRACE:
                State = 4;
                break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  SlBadInfLineError(InfLine, INFFile);
                  break;
           }
           break;
       //
       // STATE 4: Section Definition Complete, expecting EOL
       //
       // Valid Tokens: TOK_EOL, TOK_EOF
       //
       case 4:
           switch (Token.Type) {
              case TOK_EOL:
                  if ((ErrorCode = SpAppendSection(
                                        pchSectionName
#ifdef UNICODE
                                        ,SlCopyStringAW(pchSectionName)
#endif
                                        )) != ESUCCESS) {

                    Error = Done = TRUE;
                  } else {
                    pchSectionName = NULL;
                    State = 5;
                  }
                  break;

              case TOK_EOF:
                  if ((ErrorCode = SpAppendSection(
                                        pchSectionName
#ifdef UNICODE
                                        ,SlCopyStringAW(pchSectionName)
#endif                                        
                                        )) != ESUCCESS)
                    Error = Done = TRUE;
                  else {
                    pchSectionName = NULL;
                    Done = TRUE;
                  }
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;

       //
       // STATE 5: Expecting Section Lines
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_STRING, TOK_LBRACE
       //
       case 5:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_STRING:
                  pchValue = Token.pValue;
                  State = 6;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  SlBadInfLineError(InfLine, INFFile);
                  break;
           }
           break;

       //
       // STATE 6: String returned, not sure whether it is key or value
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA, TOK_EQUAL
       //
       case 6:
           switch (Token.Type) {
              case TOK_EOL:
                  if ( (ErrorCode = SpAppendLine(
                                            NULL
#ifdef UNICODE
                                            ,NULL
#endif
                                            )) != ESUCCESS ||
                       (ErrorCode = SpAppendValue(
                                            pchValue
#ifdef UNICODE
                                            ,SlCopyStringAW(pchValue)
#endif
                                            )) !=ESUCCESS )
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      State = 5;
                  }
                  break;

              case TOK_EOF:
                  if ( (ErrorCode = SpAppendLine(
                                            NULL
#ifdef UNICODE
                                            ,NULL
#endif
                                            )) != ESUCCESS ||
                       (ErrorCode = SpAppendValue(
                                            pchValue
#ifdef UNICODE
                                            ,SlCopyStringAW(pchValue)
#endif
                                            )) !=ESUCCESS )
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      Done = TRUE;
                  }
                  break;

              case TOK_COMMA:
                  if ( (ErrorCode = SpAppendLine(
                                            NULL
#ifdef UNICODE
                                            ,NULL
#endif
                                            )) != ESUCCESS ||
                       (ErrorCode = SpAppendValue(
                                            pchValue
#ifdef UNICODE
                                            ,SlCopyStringAW(pchValue)
#endif
                                            )) !=ESUCCESS )
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      State = 7;
                  }
                  break;

              case TOK_EQUAL:
                  if ( (ErrorCode = SpAppendLine(
                                            pchValue
#ifdef UNICODE
                                            ,SlCopyStringAW(pchValue)
#endif
                                            )) !=ESUCCESS)
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      State = 8;
                  }
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  SlBadInfLineError(InfLine, INFFile);
                  break;
           }
           break;

       //
       // STATE 7: Comma received, Expecting another string
       //
       // Valid Tokens: TOK_STRING TOK_COMMA
       //   A comma means we have an empty value.
       //
       case 7:
           switch (Token.Type) {
              case TOK_COMMA:
                  Token.pValue = EmptyValue;
                  if ((ErrorCode = SpAppendValue(
                                        Token.pValue
#ifdef UNICODE
                                        ,SlCopyStringAW(Token.pValue)
#endif
                                        )) != ESUCCESS) {
                      Error = Done = TRUE;
                  }
                  //
                  // State stays at 7 because we are expecting a string
                  //
                  break;

              case TOK_STRING:
                  if ((ErrorCode = SpAppendValue(
                                            Token.pValue
#ifdef UNICODE
                                            ,SlCopyStringAW(Token.pValue)
#endif
                                            )) != ESUCCESS)
                      Error = Done = TRUE;
                  else
                     State = 9;

                  break;

              case TOK_EOL:
              case TOK_EOF:
                  Token.pValue = EmptyValue;
                  if ((ErrorCode = SpAppendValue(
                                            Token.pValue
#ifdef UNICODE
                                            ,SlCopyStringAW(Token.pValue)
#endif
                                            )) != ESUCCESS)
                      Error = Done = TRUE;
                  else
                     State = 9;

                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  SlBadInfLineError(InfLine, INFFile);
                  break;
           }
           break;
       //
       // STATE 8: Equal received, Expecting another string
       //          If none, assume there is a single empty string on the RHS
       //
       // Valid Tokens: TOK_STRING, TOK_EOL, TOK_EOF
       //
       case 8:
           switch (Token.Type) {
              case TOK_EOF:
                  Token.pValue = EmptyValue;
                  if((ErrorCode = SpAppendValue(
                                            Token.pValue
#ifdef UNICODE
                                            ,SlCopyStringAW(Token.pValue)
#endif
                                            )) != ESUCCESS) {
                      Error = TRUE;
                  }
                  Done = TRUE;
                  break;

              case TOK_EOL:
                  Token.pValue = EmptyValue;
                  if((ErrorCode = SpAppendValue(
                                            Token.pValue
#ifdef UNICODE
                                            ,SlCopyStringAW(Token.pValue)
#endif
                                            )) != ESUCCESS) {
                      Error = TRUE;
                      Done = TRUE;
                  } else {
                      State = 5;
                  }
                  break;

              case TOK_STRING:
                  if ((ErrorCode = SpAppendValue(
                                            Token.pValue
#ifdef UNICODE
                                            ,SlCopyStringAW(Token.pValue)
#endif
                                            )) != ESUCCESS)
                      Error = Done = TRUE;
                  else
                      State = 9;

                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  SlBadInfLineError(InfLine, INFFile);
                  break;
           }
           break;
       //
       // STATE 9: String received after equal, value string
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 9:
           switch (Token.Type) {
              case TOK_EOL:
                  State = 5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  SlBadInfLineError(InfLine, INFFile);
                  break;
           }
           break;
       //
       // STATE 10: Value string definitely received
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 10:
           switch (Token.Type) {
              case TOK_EOL:
                  State =5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  SlBadInfLineError(InfLine, INFFile);
                  break;
           }
           break;

       default:
           Error = Done = TRUE;
           ErrorCode = EINVAL;
           break;

       } // end switch(State)


       if (Error) {

           switch (ErrorCode) {
               case EINVAL:
                  *ErrorLine = InfLine;
                  break;
               case ENOMEM:
	         SlBadInfLineError(InfLine, INFFile);
                  break;
               default:
                  break;
           }

           ErrorCode = SpFreeINFBuffer((PVOID)pINF);
           if (pchSectionName != (PCHAR)NULL) {
               SpFree(pchSectionName);
           }

           if (pchValue != (PCHAR)NULL) {
               SpFree(pchValue);
           }

           pINF = (PINF)NULL;
       }
       else {

          //
          // Keep track of line numbers so that we can display Errors
          //

          if (Token.Type == TOK_EOL)
              InfLine++;
       }

    } // End while

#if 0 && DBG
    GetStatistics(pINF);
#endif

    return((PVOID)pINF);
}



ARC_STATUS
SpAppendSection(
    IN PCHAR pSectionName
#ifdef UNICODE 
    , IN PWCHAR pSectionNameW
#endif
    )

/*++

Routine Description:

    This appends a new section to the section list in the current INF.
    All further lines and values pertain to this new section, so it resets
    the line list and value lists too.

Arguments:

    pSectionName - Name of the new section. ( [SectionName] )

Return Value:

    ESUCCESS - if successful.
    ENOMEM   - if memory allocation failed.
    EINVAL   - if invalid parameters passed in or the INF buffer not
               initialised

--*/

{
    PSECTION pNewSection;

    //
    // Check to see if INF initialised and the parameter passed in is valid
    //

    if (pINF == (PINF)NULL || pSectionName == (PCHAR)NULL) {
        if(pchINFName) {
            SlFriendlyError(
                EINVAL,
                pchINFName,
                __LINE__,
                __FILE__
                );
        } else {
            SlError(EINVAL);
        }
        return EINVAL;
    }

    //
    // See if we already have a section by this name. If so we want
    // to merge sections.
    //
    for(pNewSection=pINF->pSection; pNewSection; pNewSection=pNewSection->pNext) {
        if(pNewSection->pName && !_stricmp(pNewSection->pName,pSectionName)) {
            break;
        }
    }
    if(pNewSection) {
        //
        // Set pLineRecord to point to the list line currently in the section.
        //
        for(pLineRecord = pNewSection->pLine;
            pLineRecord && pLineRecord->pNext;
            pLineRecord = pLineRecord->pNext)
            ;

    } else {
        //
        // Allocate memory for the new section
        //

        if ((pNewSection = (PSECTION)BlAllocateHeap(sizeof(SECTION))) == (PSECTION)NULL) {
            SlNoMemoryError();
            return ENOMEM;
        }

        //
        // initialise the new section
        //
        pNewSection->pNext = NULL;
        pNewSection->pLine = NULL;
        pNewSection->pName = pSectionName;
#ifdef UNICODE
        pNewSection->pNameW = pSectionNameW;
#endif

        //
        // link it in
        //
        pNewSection->pNext = pINF->pSection;
        pINF->pSection = pNewSection;

        //
        // reset the current line record
        //
        pLineRecord = NULL;
    }

    pSectionRecord = pNewSection;
    pValueRecord = NULL;
    pInternalValue = NULL;
    pLastInternalValue = NULL;
#ifdef UNICODE
    pInternalValueW = NULL;
    pLastInternalValueW = NULL;
#endif

    return ESUCCESS;
}


ARC_STATUS
SpAppendLine(
    IN PCHAR pLineKey
#ifdef UNICODE 
    , IN PWCHAR pLineKeyW
#endif
    )

/*++

Routine Description:

    This appends a new line to the line list in the current section.
    All further values pertain to this new line, so it resets
    the value list too.

Arguments:

    pLineKey - Key to be used for the current line, this could be NULL.

Return Value:

    ESUCCESS - if successful.
    ENOMEM   - if memory allocation failed.
    EINVAL   - if invalid parameters passed in or current section not
               initialised


--*/


{
    PLINE pNewLine;
    ULONG i;

    //
    // Check to see if current section initialised
    //

    if (pSectionRecord == (PSECTION)NULL) {
        if(pchINFName) {
            SlFriendlyError(
                EINVAL,
                pchINFName,
                __LINE__,
                __FILE__
                );
        } else {
            SlError(EINVAL);
        }
        return EINVAL;
    }

    //
    // Allocate memory for the new Line
    //

    if ((pNewLine = (PLINE)BlAllocateHeap(sizeof(LINE))) == (PLINE)NULL) {
        SlNoMemoryError();
        return ENOMEM;
    }

    //
    // Link it in
    //
    pNewLine->pNext  = (PLINE)NULL;
    for ( i = 0; i < NUMBER_OF_INTERNAL_VALUES; i++ ) {
        pNewLine->InternalValues[i] = NULL;
#ifdef UNICODE
        pNewLine->InternalValuesW[i] = NULL;
#endif
    }
    pNewLine->pFirstExternalValue = (PVALUE)NULL;
    pNewLine->pName  = pLineKey;
#ifdef UNICODE    
    pNewLine->pNameW = pLineKeyW;
#endif

    if (pLineRecord == (PLINE)NULL) {
        pSectionRecord->pLine = pNewLine;
    }
    else {
        pLineRecord->pNext = pNewLine;
    }

    pLineRecord  = pNewLine;

    //
    // Reset the current value record
    //

    pValueRecord = (PVALUE)NULL;
    pInternalValue = &pNewLine->InternalValues[0];
    pLastInternalValue = &pNewLine->InternalValues[NUMBER_OF_INTERNAL_VALUES];

#ifdef UNICODE
    pInternalValueW = &pNewLine->InternalValuesW[0];
    pLastInternalValueW = &pNewLine->InternalValuesW[NUMBER_OF_INTERNAL_VALUES];
#endif

    return ESUCCESS;
}



ARC_STATUS
SpAppendValue(
    IN PCHAR pValueString
#ifdef UNICODE 
    , IN PWCHAR pValueStringW
#endif
    )

/*++

Routine Description:

    This appends a new value to the value list in the current line.

Arguments:

    pValueString - The value string to be added.

Return Value:

    ESUCCESS - if successful.
    ENOMEM   - if memory allocation failed.
    EINVAL   - if invalid parameters passed in or current line not
               initialised.

--*/

{
    PVALUE pNewValue;

    //
    // Check to see if current line record has been initialised and
    // the parameter passed in is valid
    //

    if (pLineRecord == (PLINE)NULL || pValueString == (PCHAR)NULL) {
        if(pchINFName) {
            SlFriendlyError(
                EINVAL,
                pchINFName,
                __LINE__,
                __FILE__
                );
        } else {
            SlError(EINVAL);
        }
        return EINVAL;
    }

    if (pInternalValue != NULL) {

        *pInternalValue++ = pValueString;
        if (pInternalValue >= pLastInternalValue) {
            pInternalValue = NULL;
        }

#ifdef UNICODE
        *pInternalValueW++ = pValueStringW;
        if (pInternalValueW >= pLastInternalValueW) {
            pInternalValueW = NULL;
        }
#endif


        return ESUCCESS;
    }

    //
    // Allocate memory for the new value record
    //

    if ((pNewValue = (PVALUE)BlAllocateHeap(sizeof(VALUE))) == (PVALUE)NULL) {
        SlNoMemoryError();
        return ENOMEM;
    }

    //
    // Link it in.
    //

    pNewValue->pNext  = (PVALUE)NULL;
    pNewValue->pName  = pValueString;
#ifdef UNICODE
    pNewValue->pNameW = pValueStringW;    
#endif

    if (pValueRecord == (PVALUE)NULL)
        pLineRecord->pFirstExternalValue = pNewValue;
    else
        pValueRecord->pNext = pNewValue;

    pValueRecord = pNewValue;
    return ESUCCESS;
}

PVOID
SpAllocateStringHeap (
    IN ULONG Size
    )

/*++

Routine Description:

    This routine allocates memory from the OS loader heap.

Arguments:

    Size - Supplies the size of block required in bytes.

Return Value:

    If a free block of memory of the specified size is available, then
    the address of the block is returned. Otherwise, NULL is returned.

--*/

{
    PVOID HeapBlock;
    ULONG_PTR Block;

    if (Size >= STRING_HEAP_SIZE) {
        return BlAllocateHeap(Size);
    }

    if ((StringHeapFree + Size) >= StringHeapLimit) {

#if 0 && DBG
        wasteStrings += (StringHeapLimit - StringHeapFree);
#endif

        HeapBlock = BlAllocateHeap( STRING_HEAP_SIZE );
        if ( HeapBlock == NULL ) {
            return NULL;
        }

        StringHeapFree = (ULONG_PTR)HeapBlock;
        StringHeapLimit = StringHeapFree + STRING_HEAP_SIZE;
    }

    Block = StringHeapFree;
    StringHeapFree += Size;

#if 0 && DBG
    nStrings++;
    bytesStrings += Size;
    stringsWithNLength[MIN(Size,11)]++;
    maxString = MAX(maxString, Size);
#endif
    return (PVOID)Block;
}

TOKEN
SpGetToken(
    IN OUT PCHAR *Stream,
    IN PCHAR      MaxStream
    )

/*++

Routine Description:

    This function returns the Next token from the configuration stream.

Arguments:

    Stream - Supplies the address of the configuration stream.  Returns
        the address of where to start looking for tokens within the
        stream.

    MaxStream - Supplies the address of the last character in the stream.


Return Value:

    TOKEN - Returns the next token

--*/

{

    PCHAR pch, pchStart, pchNew;
    ULONG  Length;
    TOKEN Token;

    //
    //  Skip whitespace (except for eol)
    //

    pch = *Stream;
    while (pch < MaxStream && *pch != '\n' && isspace(*pch))
        pch++;


    //
    // Check for comments and remove them
    //

    if (pch < MaxStream &&
        ((*pch == '#') ||
         (*pch == ';') ||
         (*pch == '/' && pch+1 < MaxStream && *(pch+1) =='/')))
        while (pch < MaxStream && *pch != '\n')
            pch++;

    //
    // Check to see if EOF has been reached, set the token to the right
    // value
    //

    if ((pch >= MaxStream) || (*pch == 26)) {
        *Stream = pch;
        Token.Type  = TOK_EOF;
        Token.pValue = NULL;
        return Token;
    }


    switch (*pch) {

    case '[' :
        pch++;
        Token.Type  = TOK_LBRACE;
        Token.pValue = NULL;
        break;

    case ']' :
        pch++;
        Token.Type  = TOK_RBRACE;
        Token.pValue = NULL;
        break;

    case '=' :
        pch++;
        Token.Type  = TOK_EQUAL;
        Token.pValue = NULL;
        break;

    case ',' :
        pch++;
        Token.Type  = TOK_COMMA;
        Token.pValue = NULL;
        break;

    case '\n' :
        pch++;
        Token.Type  = TOK_EOL;
        Token.pValue = NULL;
        break;

    case '\"':
        pch++;
        //
        // determine quoted string
        //
        pchStart = pch;
        while (pch < MaxStream && (strchr(QStringTerminators,*pch) == NULL)) {
            pch++;
        }

        if (pch >=MaxStream || *pch != '\"') {
            Token.Type   = TOK_ERRPARSE;
            Token.pValue = NULL;
        } else {
            //
            // We require a quoted string to end with a double-quote.
            // (If the string ended with anything else, the if() above
            // would not have let us into the else clause.) The quote
            // character is irrelevent, however, and can be overwritten.
            // So we'll save some heap and use the string in-place.
            // No need to make a copy.
            //
            // Note that this alters the image of txtsetup.sif we pass
            // to setupdd.sys. Thus the inf parser in setupdd.sys must
            // be able to treat a nul character as if it were a terminating
            // double quote.
            //
            *pch++ = 0;
            Token.Type = TOK_STRING;
            Token.pValue = pchStart;
        }
        break;

    default:
        //
        // determine regular string
        //
        pchStart = pch;
        while (pch < MaxStream && (strchr(StringTerminators,*pch) == NULL)) {
            pch++;
        }

        if (pch == pchStart) {
            pch++;
            Token.Type  = TOK_ERRPARSE;
            Token.pValue = NULL;
        }
        else {
            Length = (ULONG)(pch - pchStart);
            if ((pchNew = SpAllocateStringHeap(Length + 1)) == NULL) {
                Token.Type = TOK_ERRNOMEM;
                Token.pValue = NULL;
            }
            else {
                strncpy(pchNew, pchStart, Length);
                pchNew[Length] = 0;
                Token.Type = TOK_STRING;
                Token.pValue = pchNew;
            }
        }
        break;
    }

    *Stream = pch;
    return (Token);
}

PCHAR
SlSearchSection(
    IN PCHAR SectionName,
    IN PCHAR TargetName
    )

/*++

Routine Description:

    Searches a section in the INF file to match a name from the ARC identifier
    with the canonical shortname.

    If a string starts with *, then use strstr to find it in the node's id
    string, else use stricmp.

    [Map.Computer]
        msjazz_up   = *Jazz
        desksta1_up = "DESKTECH-ARCStation I"
        pica61_up   = "PICA-61"
        duo_mp      = *Duo

    [Map.Computer]
        DECjensen = "DEC-20Jensen"
        DECjensen = "DEC-10Jensen"

Arguments:

    SectionName - Supplies the name of the section ("Map.Computer")

    TargetName - Supplies the ARC string to be matched ("DEC-20Jensen")

Return Value:

    NULL - No match was found.

    PCHAR - Pointer to the canonical shortname of the device.

--*/

{
    ULONG i;
    PCHAR SearchName;

    //
    // Enumerate the entries in the section.  If the 0 value
    // begins with a *, then see if the system name contains the string that
    // follows.  Otherwise, do a case-insensitive compare on the name.
    //
    for (i=0;;i++) {
        SearchName = SlGetSectionLineIndex(InfFile,
                                           SectionName,
                                           i,
                                           0);
        if (SearchName==NULL) {
            //
            // we have enumerated the entire section without finding a match,
            // return failure.
            //
            return(NULL);
        }

        if (SearchName[0]=='*') {
            if (strstr(TargetName,SearchName+1) != 0) {
                //
                // we have a match
                //
                break;
            }
        } else {
            if (_stricmp(TargetName, SearchName) == 0) {
                //
                // we have a match
                //
                break;
            }
        }
    }

    //
    // i is the index into the section of the short machine name
    //
    return(SlGetKeyName(InfFile,
                        SectionName,
                        i));


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\scsidisk.c ===
#if defined(JAZZ) || defined(i386) || defined(_ALPHA_) || defined(_IA64_)
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    scsidisk.c

Abstract:

    This module implements the hard disk boot driver for the Jazz system.

Author:

    Jeff Havens (jhavens) 8-12-1991

Environment:

    Kernel mode

Revision History:

    Vijay Jayaseelan (vijayj) 2-April-2000

        -   Add GPT support

--*/


#ifdef MIPS
#include "..\fw\mips\fwp.h"
#undef KeGetDcacheFillSize
#define KeGetDcacheFillSize() BlDcacheFillSize
#elif defined(_ALPHA_)
#include "..\fw\alpha\fwp.h"
#undef KeGetDcacheFillSize
#define KeGetDcacheFillSize() BlDcacheFillSize
#elif defined(_IA64_)
#include "bootia64.h"
#else
#include "bootx86.h"
#undef KeGetDcacheFillSize
#define KeGetDcacheFillSize() 4
#endif
#include "ntdddisk.h"
#include "scsi.h"
#include "scsiboot.h"
#include "stdio.h"
#include "string.h"

#if defined(SETUP) && i386
#include "spscsi.h"
#endif



//
// SCSI driver constants.
//

#define MAXIMUM_NUMBER_SECTORS 128      // maximum number of transfer sector
#define MAXIMUM_NUMBER_RETRIES 8        // maximum number of read/write retries
#define MAXIMUM_SECTOR_SIZE 2048        // define the maximum supported sector size
#define MODE_DATA_SIZE 192
#define HITACHI_MODE_DATA_SIZE 12

CHAR ScsiTempBuffer[MAXIMUM_SECTOR_SIZE + 128];

//
// Define device driver prototypes.
//

NTSTATUS
ScsiDiskBootPartitionOpen(
    IN ULONG   FileId,
    IN UCHAR   DeviceUnit,
    IN UCHAR   PartitionNumber
    );

NTSTATUS
ScsiGPTDiskBootPartitionOpen(
    IN ULONG   FileId,
    IN UCHAR   DeviceUnit,
    IN UCHAR   PartitionNumber
    );
    

ARC_STATUS
ScsiDiskClose (
    IN ULONG FileId
    );

ARC_STATUS
ScsiDiskMount (
    IN PCHAR MountPath,
    IN MOUNT_OPERATION Operation
    );

ARC_STATUS
ScsiDiskOpen (
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
ScsiDiskRead (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
ScsiDiskGetReadStatus (
    IN ULONG FileId
    );

ARC_STATUS
ScsiDiskSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
ScsiDiskWrite (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
ScsiDiskGetFileInformation (
    IN ULONG FileId,
    OUT PFILE_INFORMATION Finfo
    );

NTSTATUS
ScsiDiskBootIO (
    IN PMDL MdlAddress,
    IN ULONG LogicalBlock,
    IN PPARTITION_CONTEXT PartitionContext,
    IN BOOLEAN Operation
    );

VOID
ScsiDiskBootSetup (
    VOID
    );

VOID
ScsiPortExecute(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ScsiDiskStartUnit(
    IN PPARTITION_CONTEXT PartitionContext
    );

VOID
ScsiDiskFilterBad(
    IN PPARTITION_CONTEXT PartitionContext
    );

ULONG
ClassModeSense(
    IN PPARTITION_CONTEXT Context,
    IN PCHAR ModeSenseBuffer,
    IN ULONG Length,
    IN UCHAR PageMode
    );

PVOID
ClassFindModePage(
    IN PCHAR ModeSenseBuffer,
    IN ULONG Length,
    IN UCHAR PageMode
    );
BOOLEAN
IsFloppyDevice(
    PPARTITION_CONTEXT Context
    );

BOOLEAN
CheckFileId(
    ULONG FileId
    );

VOID
ScsiPortInitializeMdlPages (
    IN OUT PMDL Mdl
    );


//
// Define static data.
//

BL_DEVICE_ENTRY_TABLE ScsiDiskEntryTable = {
    ScsiDiskClose,
    ScsiDiskMount,
    ScsiDiskOpen,
    ScsiDiskRead,
    ScsiDiskGetReadStatus,
    ScsiDiskSeek,
    ScsiDiskWrite,
    ScsiDiskGetFileInformation,
    (PARC_SET_FILE_INFO_ROUTINE)NULL
    };


//
// Global poiter for buffers.
//

PREAD_CAPACITY_DATA ReadCapacityBuffer;
PUCHAR SenseInfoBuffer;

#define SECTORS_IN_LOGICAL_VOLUME   0x20


ARC_STATUS
ScsiDiskGetFileInformation (
    IN ULONG FileId,
    OUT PFILE_INFORMATION Finfo
    )

/*++

Routine Description:

    This routine returns information on the scsi partition.

Arguments:

    FileId - Supplies the file table index.

    Finfo - Supplies a pointer to where the File Informatino is stored.

Return Value:

    ESUCCESS is returned.

--*/

{

    PPARTITION_CONTEXT Context;

    RtlZeroMemory(Finfo, sizeof(FILE_INFORMATION));

    Context = &BlFileTable[FileId].u.PartitionContext;

    Finfo->StartingAddress.QuadPart = Context->StartingSector;
    Finfo->StartingAddress.QuadPart <<= Context->SectorShift;

    Finfo->EndingAddress.QuadPart = Finfo->StartingAddress.QuadPart + Context->PartitionLength.QuadPart;

    Finfo->Type = DiskPeripheral;

    return ESUCCESS;
}


ARC_STATUS
ScsiDiskClose (
    IN ULONG FileId
    )

/*++

Routine Description:

    This function closes the file table entry specified by the file id.

Arguments:

    FileId - Supplies the file table index.

Return Value:

    ESUCCESS is returned.

--*/

{

    BlFileTable[FileId].Flags.Open = 0;
    return ESUCCESS;
}

ARC_STATUS
ScsiDiskMount (
    IN PCHAR MountPath,
    IN MOUNT_OPERATION Operation
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    UNREFERENCED_PARAMETER( MountPath );
    UNREFERENCED_PARAMETER( Operation );

    return ESUCCESS;
}


#ifdef EFI_PARTITION_SUPPORT

#define STR_PREFIX      
#define DBG_PRINT(x)    

/*
#if defined(_IA64_)

#define STR_PREFIX      L
#define DBG_PRINT(x)    DbgOut(x);

#else

#define STR_PREFIX      

#define DBG_PRINT(x)    \
{\
    BlPrint(x); \
    while (!BlGetKey()); \
}    

#endif  // _IA64_
*/

#endif

ARC_STATUS
ScsiDiskOpen (
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    This routine fills in the file table entry.  In particular the Scsi address
    of the device is determined from the name.  The block size of device is
    queried from the target controller, and the partition information is read
    from the device.

Arguments:

    OpenPath - Supplies the name of the device being opened.

    OpenMode - Unused.

    FileId - Supplies the index to the file table entry to be initialized.

Return Value:

    Retruns the arc status of the operation.

--*/

{
    ULONG Partition;
    ULONG Id;
    BOOLEAN IsCdRom;
    BOOLEAN IsFloppy;
    PPARTITION_CONTEXT Context;

    UNREFERENCED_PARAMETER( OpenMode );

    Context = &BlFileTable[*FileId].u.PartitionContext;

    //
    // Determine the scsi port device object.
    //
    if (FwGetPathMnemonicKey(OpenPath, "signature", &Id)) {
        if (FwGetPathMnemonicKey(OpenPath, "scsi", &Id)) {
            return ENODEV;
        }
    } else {
        PCHAR  DiskStart = strstr(OpenPath, ")disk");

        if (DiskStart) {
            DiskStart++;
            strcpy(OpenPath, "scsi(0)");
            strcat(OpenPath, DiskStart);
        }            
            
        Id = 0; // only the first SCSI card is supported        
    }        

    if (ScsiPortDeviceObject[Id] == NULL) {
        return ENODEV;
    }

    Context->PortDeviceObject = ScsiPortDeviceObject[Id];

    //
    // Get the logical unit, path Id and target id from the name.
    // NOTE: FwGetPathMnemonicKey returns 0 for success.
    //

    if (FwGetPathMnemonicKey(OpenPath, "rdisk", &Id)) {
        if (FwGetPathMnemonicKey(OpenPath, "fdisk", &Id)) {
            return ENODEV;
        } else {
            IsFloppy = TRUE;
        }
    } else {
        IsFloppy = FALSE;
    }

    //
    // Booting is only allowed on LUN 0 since the scsibus
    // scan in the loader only searches for LUN 0.
    //

    if (Id != 0) {
        return ENODEV;
    }

    Context->DiskId = (UCHAR)Id;

    if (!FwGetPathMnemonicKey(OpenPath, "cdrom", &Id)) {
        IsCdRom = TRUE;
    } else if (!FwGetPathMnemonicKey(OpenPath, "disk", &Id)) {
        IsCdRom = FALSE;
    } else {
        return ENODEV;
    }

    SCSI_DECODE_BUS_TARGET( Id, Context->PathId, Context->TargetId );

    //
    // Initialize any bad devices.
    //

    ScsiDiskFilterBad(Context);

    //
    // Read the capacity of the disk to determine the block size.
    //

    if (ReadDriveCapacity(Context)) {
        return ENODEV;
    }

    //
    // This is all that needs to be done for floppies and harddisks.
    //

    if (IsCdRom || IsFloppy) {
        return(ESUCCESS);
    }

    if (FwGetPathMnemonicKey(OpenPath,
                             "partition",
                             &Partition
                             )) {
        return ENODEV;
    }

    if (Partition != 0) {
        //
        // First try to open the MBR partition
        //
        DBG_PRINT(STR_PREFIX"Trying to open SCSI MBR partition\r\n");
        
        if (ScsiDiskBootPartitionOpen(*FileId,0,(UCHAR)Partition) != STATUS_SUCCESS) {

#ifdef EFI_PARTITION_SUPPORT
            //
            // Since we failed with MBR open now try GPT partition
            //
            DBG_PRINT(STR_PREFIX"Trying to open SCSI GPT partition\r\n");
            
            if (ScsiGPTDiskBootPartitionOpen(*FileId,0,(UCHAR)(Partition -1)) != STATUS_SUCCESS) {
                return ENODEV;
            }
#else

            return ENODEV;
            
#endif // EFI_PARTITION_SUPPORT            
        }
    }

    DBG_PRINT(STR_PREFIX"Opened the SCSI partition successfully\r\n");
    
    //
    // Initialize partition table
    //
    return ESUCCESS;
}

ARC_STATUS
ScsiDiskRead (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    This function reads data from the hard disk starting at the position
    specified in the file table.


Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a poiner to the buffer that receives the data
        read.

    Length - Supplies the number of bytes to be read.

    Count - Supplies a pointer to a variable that receives the number of
        bytes actually read.

Return Value:

    The read operation is performed and the read completion status is
    returned.

--*/


{

    ARC_STATUS ArcStatus;
    ULONG Index;
    ULONG Limit;
    PMDL MdlAddress;
    UCHAR MdlBuffer[sizeof(MDL) + ((64 / 4) + 1) * sizeof(ULONG)];
    NTSTATUS NtStatus;
    ULONG Offset;
    LARGE_INTEGER Position;
    LARGE_INTEGER LogicalBlock;
    PCHAR TempPointer;
    PIO_SCSI_CAPABILITIES PortCapabilities;
    ULONG adapterLimit;
    ULONG alignmentMask;
    ULONG SectorSize;
    ULONG TransferCount;
    ULONG BytesToTransfer;

    //
    // If the requested size of the transfer is zero return ESUCCESS
    //
    if (Length==0) {
        return ESUCCESS;
    }

    if (!CheckFileId(FileId)) {
        return(ENODEV);
    }

    //
    // Compute a Dcache aligned pointer into the temporary buffer.
    //

    TempPointer =  (PVOID)((ULONG_PTR)(ScsiTempBuffer +
        KeGetDcacheFillSize() - 1) & ~((LONG)KeGetDcacheFillSize() - 1));


    //
    // Calculate the actual sector size.
    //

    SectorSize = 1 << BlFileTable[FileId].u.PartitionContext.SectorShift;

    ArcStatus = GetAdapterCapabilities(
        BlFileTable[FileId].u.PartitionContext.PortDeviceObject,
        &PortCapabilities
        );

    if (ArcStatus != ESUCCESS) {

        adapterLimit = 0x10000;
        alignmentMask = KeGetDcacheFillSize();

    } else {

        if (PortCapabilities->MaximumTransferLength < 0x1000 ||
            PortCapabilities->MaximumTransferLength > 0x10000) {

            adapterLimit = 0x10000;

        } else {

            adapterLimit = PortCapabilities->MaximumTransferLength;

        }

        alignmentMask = PortCapabilities->AlignmentMask;
    }

    //
    // If the current position is not at a sector boundary or if the data
    // buffer is not properly aligned, then read the first sector separately
    // and copy the data.
    //

    Offset = BlFileTable[FileId].Position.LowPart & (SectorSize - 1);
    *Count = 0;
    while (Offset != 0 || (ULONG_PTR) Buffer & alignmentMask) {

        Position = BlFileTable[FileId].Position;
        BlFileTable[FileId].Position.QuadPart = Position.QuadPart - Offset;

        ArcStatus = ScsiDiskRead(FileId, TempPointer, SectorSize, &TransferCount);
        if (ArcStatus != ESUCCESS) {
            BlFileTable[FileId].Position = Position;
            return ArcStatus;
        }

        //
        // Copy the data to the specified buffer.
        //

        if ((SectorSize - Offset) > Length) {
            Limit = Offset + Length;

        } else {
            Limit = SectorSize;
        }

        for (Index = Offset; Index < Limit; Index += 1) {
            ((PCHAR)Buffer)[Index - Offset] = TempPointer[Index];
        }

        //
        // Update transfer parameters.
        //

        *Count += Limit - Offset;
        Length -= Limit - Offset;
        Buffer = (PVOID)((PCHAR)Buffer + Limit - Offset);
        BlFileTable[FileId].Position.QuadPart = Position.QuadPart + (Limit - Offset);

        Offset = BlFileTable[FileId].Position.LowPart & (SectorSize - 1);

        if (Length == 0) {
            break;
        }

    }

    //
    // The position is aligned on a sector boundary. Read as many sectors
    // as possible in a contiguous run in 64Kb chunks.
    //

    BytesToTransfer = Length & (~(SectorSize - 1));
    while (BytesToTransfer != 0) {

        //
        // The scsi controller doesn't support transfers bigger than 64Kb.
        // Transfer the maximum number of bytes possible.
        //

        Limit = (BytesToTransfer > adapterLimit ? adapterLimit : BytesToTransfer);

        //
        // Build the memory descriptor list.
        //


        MdlAddress = (PMDL)&MdlBuffer[0];
        MdlAddress->Next = NULL;
        MdlAddress->Size = (CSHORT)(sizeof(MDL) +
                  ADDRESS_AND_SIZE_TO_SPAN_PAGES(Buffer, Limit) * sizeof(ULONG));
        MdlAddress->MdlFlags = 0;
        MdlAddress->StartVa = (PVOID)PAGE_ALIGN(Buffer);
        MdlAddress->ByteCount = Limit;
        MdlAddress->ByteOffset = BYTE_OFFSET(Buffer);
        ScsiPortInitializeMdlPages (MdlAddress);

        //
        // Flush I/O buffers and read from the boot device.
        //

        KeFlushIoBuffers(MdlAddress, TRUE, TRUE);
        LogicalBlock.QuadPart = BlFileTable[FileId].Position.QuadPart >>
                                    BlFileTable[FileId].u.PartitionContext.SectorShift;
        LogicalBlock.LowPart += BlFileTable[FileId].u.PartitionContext.StartingSector;
        NtStatus = ScsiDiskBootIO(MdlAddress,
            LogicalBlock.LowPart,
            &BlFileTable[FileId].u.PartitionContext,
            TRUE);

        if (NtStatus != ESUCCESS) {
            return EIO;
        }

        *Count += Limit;
        Length -= Limit;
        Buffer = (PVOID)((PCHAR)Buffer + Limit);
        BytesToTransfer -= Limit;
        BlFileTable[FileId].Position.QuadPart = BlFileTable[FileId].Position.QuadPart + Limit;
    }

    //
    // If there is any residual data to read, then read the last sector
    // separately and copy the data.
    //

    if (Length != 0) {
        Position = BlFileTable[FileId].Position;
        ArcStatus = ScsiDiskRead(FileId, TempPointer, SectorSize, &TransferCount);
        if (ArcStatus != ESUCCESS) {
            BlFileTable[FileId].Position = Position;
            return ArcStatus;
        }

        //
        // Copy the data to the specified buffer.
        //
        RtlCopyMemory(Buffer,TempPointer,Length);

        //
        // Update transfer parameters.
        //

        *Count += Length;
        BlFileTable[FileId].Position.QuadPart = Position.QuadPart + Length;
    }

    return ESUCCESS;

}

ARC_STATUS
ScsiDiskGetReadStatus (
    IN ULONG FileId
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    UNREFERENCED_PARAMETER( FileId );

    return ESUCCESS;
}

ARC_STATUS
ScsiDiskSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    This function sets the device position to the specified offset for
    the specified file id.

Arguments:

    FileId - Supplies the file table index.

    Offset - Supplies to new device position.

    SeekMode - Supplies the mode for the position.

Return Value:

    ESUCCESS is returned.

--*/

{

    //
    // Set the current device position as specifed by the seek mode.
    //

    if (SeekMode == SeekAbsolute) {
        BlFileTable[FileId].Position = *Offset;

    } else if (SeekMode == SeekRelative) {
        BlFileTable[FileId].Position.QuadPart = BlFileTable[FileId].Position.QuadPart + Offset->QuadPart;
    }

    return ESUCCESS;
}

ARC_STATUS
ScsiDiskWrite (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    This function writes data to the hard disk starting at the position
    specified in the file table.


Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a poiner to the buffer that contains the write data.

    Length - Supplies the number of bytes to be written.

    Count - Supplies a pointer to a variable that receives the number of
        bytes actually written.

Return Value:

    The write operation is performed and the write completion status is
    returned.

--*/

{

    ARC_STATUS ArcStatus;
    ULONG Index;
    ULONG Limit;
    PMDL MdlAddress;
    UCHAR MdlBuffer[sizeof(MDL) + ((64 / 4) + 1) * sizeof(ULONG)];
    NTSTATUS NtStatus;
    ULONG Offset;
    LARGE_INTEGER Position;
    LARGE_INTEGER WritePosition;
    LARGE_INTEGER LogicalBlock;
    CHAR TempBuffer[MAXIMUM_SECTOR_SIZE + 128];
    PIO_SCSI_CAPABILITIES PortCapabilities;
    ULONG adapterLimit;
    PCHAR TempPointer;
    ULONG SectorSize;
    ULONG TransferCount;
    ULONG BytesToTransfer;
    ULONG alignmentMask;
    //
    // If the requested size of the transfer is zero return ESUCCESS
    //

    if (Length==0) {
        return ESUCCESS;
    }

    if (!CheckFileId(FileId)) {
        return(ENODEV);
    }

    //
    // Compute a Dcache aligned pointer into the temporary buffer.
    //

    TempPointer =  (PVOID)((ULONG_PTR)(TempBuffer +
                        KeGetDcacheFillSize() - 1) & ~((LONG)KeGetDcacheFillSize() - 1));


    //
    // Calculate the actual sector size.
    //

    SectorSize = 1 << BlFileTable[FileId].u.PartitionContext.SectorShift;

    ArcStatus = GetAdapterCapabilities(
        BlFileTable[FileId].u.PartitionContext.PortDeviceObject,
        &PortCapabilities
        );

    if (ArcStatus != ESUCCESS) {

        adapterLimit = 0x10000;
        alignmentMask = KeGetDcacheFillSize();

    } else {

        if (PortCapabilities->MaximumTransferLength < 0x1000 ||
            PortCapabilities->MaximumTransferLength > 0x10000) {

            adapterLimit = 0x10000;

        } else {

            adapterLimit = PortCapabilities->MaximumTransferLength;

        }

        alignmentMask = PortCapabilities->AlignmentMask;
    }

    //
    // If the current position is not at a sector boundary or if the data
    // buffer is not properly aligned, then read the first sector separately
    // and copy the data.
    //

    Offset = BlFileTable[FileId].Position.LowPart & (SectorSize - 1);
    *Count = 0;
    while (Offset != 0 || (ULONG_PTR) Buffer & alignmentMask) {

        Position = BlFileTable[FileId].Position;
        BlFileTable[FileId].Position.QuadPart = Position.QuadPart - Offset;
        WritePosition = BlFileTable[FileId].Position;
        ArcStatus = ScsiDiskRead(FileId, TempPointer, SectorSize, &TransferCount);
        if (ArcStatus != ESUCCESS) {
            BlFileTable[FileId].Position = Position;
            return ArcStatus;
        }
        //
        // Reset the position as it was before the read.
        //

        BlFileTable[FileId].Position = WritePosition;

        //
        // If the length of write is less than the number of bytes from
        // the offset to the end of the sector, then copy only the number
        // of bytes required to fulfil the request. Otherwise copy to the end
        // of the sector and, read the remaining data.
        //

        if ((SectorSize - Offset) > Length) {
            Limit = Offset + Length;

        } else {
            Limit = SectorSize;
        }

        //
        // Merge the data from the specified buffer.
        //
        for (Index = Offset; Index < Limit; Index += 1) {
            TempPointer[Index] = ((PCHAR)Buffer)[Index-Offset];
        }

        //
        // Write the modified sector.
        //
        ArcStatus = ScsiDiskWrite(FileId, TempPointer, SectorSize, &TransferCount);

        if (ArcStatus != ESUCCESS) {
            return ArcStatus;
        }

        //
        // Update transfer parameters.
        //

        *Count += Limit - Offset;
        Length -= Limit - Offset;
        Buffer = (PVOID)((PCHAR)Buffer + Limit - Offset);
        BlFileTable[FileId].Position.QuadPart = Position.QuadPart + (Limit - Offset);

        Offset = BlFileTable[FileId].Position.LowPart & (SectorSize - 1);

        if (Length == 0) {
            break;
        }
    }


    //
    // The position is aligned on a sector boundary. Write as many sectors
    // as possible in a contiguous run.
    //

    BytesToTransfer = Length & (~(SectorSize - 1));
    while (BytesToTransfer != 0) {

        //
        // The scsi controller doesn't support transfers bigger than 64Kb.
        // Transfer the maximum number of bytes possible.
        //
        Limit = (BytesToTransfer > adapterLimit ? adapterLimit : BytesToTransfer);

        //
        // Build the memory descriptor list.
        //

        MdlAddress = (PMDL)&MdlBuffer[0];
        MdlAddress->Next = NULL;
        MdlAddress->Size = (CSHORT)(sizeof(MDL) +
                  ADDRESS_AND_SIZE_TO_SPAN_PAGES(Buffer, Limit) * sizeof(ULONG));
        MdlAddress->MdlFlags = 0;
        MdlAddress->StartVa = (PVOID)PAGE_ALIGN(Buffer);
        MdlAddress->ByteCount = Limit;
        MdlAddress->ByteOffset = BYTE_OFFSET(Buffer);
        ScsiPortInitializeMdlPages (MdlAddress);

        //
        // Flush I/O buffers and write to the boot device.
        //

        KeFlushIoBuffers(MdlAddress, FALSE, TRUE);
        LogicalBlock.QuadPart = BlFileTable[FileId].Position.QuadPart >>
                                    BlFileTable[FileId].u.PartitionContext.SectorShift;
        LogicalBlock.LowPart += BlFileTable[FileId].u.PartitionContext.StartingSector;
        NtStatus = ScsiDiskBootIO(MdlAddress,
            LogicalBlock.LowPart,
            &BlFileTable[FileId].u.PartitionContext,
            FALSE);

        if (NtStatus != ESUCCESS) {
            return EIO;
        }

        *Count += Limit;
        Length -= Limit;
        Buffer = (PVOID)((PCHAR)Buffer + Limit);
        BytesToTransfer -= Limit;
        BlFileTable[FileId].Position.QuadPart = BlFileTable[FileId].Position.QuadPart + Limit;
    }

    //
    // If there is any residual data to write, then read the last sector
    // separately merge the write data and write it.
    //

    if (Length != 0) {
        Position = BlFileTable[FileId].Position;
        ArcStatus = ScsiDiskRead(FileId, TempPointer, SectorSize, &TransferCount);

        //
        // Reset the position as it was before the read.
        //

        BlFileTable[FileId].Position = Position;

        if (ArcStatus != ESUCCESS) {
            return ArcStatus;
        }
        //
        // Merge the data with the read sector from the buffer.
        //

        for (Index = 0; Index < Length; Index += 1) {
            TempPointer[Index] = ((PCHAR)Buffer)[Index];
        }

        //
        // Write the merged sector
        //

        ArcStatus = ScsiDiskWrite(FileId, TempPointer, SectorSize, &TransferCount);

        //
        // Reset the postion.
        //

        BlFileTable[FileId].Position = Position;

        //
        // Update transfer parameters.
        //

        *Count += Length;

        //
        // Position is aligned to a sector boundary and Length is less than
        // a sector, therefore the addition will never overflow.
        //

        BlFileTable[FileId].Position.LowPart += Length;
    }

    return ESUCCESS;

}

#ifdef EFI_PARTITION_SUPPORT

BOOLEAN
ScsiGPTDiskReadCallback(
    ULONGLONG StartingLBA,
    ULONG    BytesToRead,
    PVOID     pContext,
    UNALIGNED PVOID OutputBuffer
    )
{
    PMDL MdlAddress;    
    PUSHORT DataPointer;
    ULONG DummyMdl[(sizeof(MDL) + 16) / sizeof(ULONG)];
    NTSTATUS Status;
    ULONG PartitionOffset;
    PPARTITION_CONTEXT Context;
    
    DBG_PRINT(STR_PREFIX"Trying to read SCSI GPT partition\r\n");

    Context = (PPARTITION_CONTEXT)pContext;
    
    DataPointer = OutputBuffer;

    //
    // Initialize a memory descriptor list to read the master boot record
    // from the specified hard disk drive.
    //
    MdlAddress = (PMDL)&DummyMdl[0];
    MdlAddress->StartVa = (PVOID)(((ULONG_PTR)DataPointer) & (~(PAGE_SIZE - 1)));
    MdlAddress->ByteCount = BytesToRead;
    MdlAddress->ByteOffset = (ULONG)((ULONG_PTR)DataPointer & (PAGE_SIZE - 1));

    ScsiPortInitializeMdlPages(MdlAddress);

    //
    // cast this to a ULONG because that's all we support in this stack.
    //
    PartitionOffset = (ULONG)StartingLBA;

    DBG_PRINT(STR_PREFIX"Reading SCSI GPT block\r\n");
    
    Status = ScsiDiskBootIO(MdlAddress, PartitionOffset, Context, TRUE);

    return ((BOOLEAN)(NT_SUCCESS(Status) != FALSE));

}


#define DATA_BUFF_SIZE  ((MAXIMUM_SECTOR_SIZE * 2 / sizeof(USHORT)) + 128)
                            
NTSTATUS
ScsiGPTDiskBootPartitionOpen(
    IN ULONG   FileId,
    IN UCHAR   DeviceUnit,
    IN UCHAR   PartitionNumber
    )
{
    PMDL MdlAddress;
    UNALIGNED USHORT DataBuffer[DATA_BUFF_SIZE];
    PUSHORT DataPointer;
    ULONG DummyMdl[(sizeof(MDL) + 16) / sizeof(ULONG)];
    PPARTITION_CONTEXT Context;
    NTSTATUS Status;
    ULONG PartitionOffset;
    ULONG SectorSize;
    UCHAR ValidPartitions;
    UCHAR PartitionCount;
    UCHAR PartitionsPerSector = 0;

    UNREFERENCED_PARAMETER( DeviceUnit );

    DBG_PRINT(STR_PREFIX"Trying to open SCSI GPT partition\r\n");

    Context = &BlFileTable[FileId].u.PartitionContext;

    if (PartitionNumber > 128)
        return EINVAL;

    //
    // Calculate the actual sector size
    //

    SectorSize = 1 << Context->SectorShift;

    RtlZeroMemory(DataBuffer, sizeof(DataBuffer));

    //
    // Make the sector size the minimum of 512 or the sector size.
    //
    if (SectorSize < 512) {
        SectorSize = 512;
    }

    //
    // Align the buffer on a Dcache line size.
    //
    DataPointer =  (PVOID) ((ULONG_PTR) ((PCHAR) DataBuffer +
        KeGetDcacheFillSize() - 1) & ~((LONG)KeGetDcacheFillSize() - 1));

    //
    // Initialize a memory descriptor list to read the master boot record
    // from the specified hard disk drive.
    //
    MdlAddress = (PMDL)&DummyMdl[0];
    MdlAddress->StartVa = (PVOID)(((ULONG_PTR)DataPointer) & (~(PAGE_SIZE - 1)));
    MdlAddress->ByteCount = SectorSize;
    MdlAddress->ByteOffset = (ULONG)((ULONG_PTR)DataPointer & (PAGE_SIZE - 1));

    ScsiPortInitializeMdlPages(MdlAddress);

    PartitionOffset = 1;

    DBG_PRINT(STR_PREFIX"Reading SCSI GPT block 1\r\n");
    
    Status = ScsiDiskBootIO(MdlAddress, PartitionOffset, Context, TRUE);
    
    if (NT_SUCCESS(Status) != FALSE) {        
        UNALIGNED EFI_PARTITION_TABLE  *EfiHdr;
        ULONGLONG StartLBA;

        EfiHdr = (UNALIGNED EFI_PARTITION_TABLE *)DataPointer;
                                                              
        if (!BlIsValidGUIDPartitionTable(
                                    EfiHdr,
                                    1,
                                    Context,
                                    ScsiGPTDiskReadCallback)) {
            Status = STATUS_UNSUCCESSFUL;

            return Status;
        }                

        //
        // Read the partition entries
        //
        StartLBA = EfiHdr->PartitionEntryLBA;
        PartitionOffset = (ULONG)StartLBA;
        ValidPartitions = 0;
        PartitionCount = 0;
        PartitionsPerSector = (UCHAR)(SectorSize / sizeof(EFI_PARTITION_ENTRY));

        while ((PartitionCount < 128)) {                 
#if 0
            BlPrint("Reading %d at %d block offset of blk size %d %d \r\n", 
                MdlAddress->ByteCount, PartitionOffset, SectorSize,
                PartitionsPerSector);
#endif                

            RtlZeroMemory(DataPointer, SectorSize);                

            DBG_PRINT(STR_PREFIX"Reading GPT partition entries\r\n");
            
            Status = ScsiDiskBootIO(MdlAddress, PartitionOffset, Context, TRUE);

            if (NT_SUCCESS(Status)) {
                UNALIGNED EFI_PARTITION_ENTRY *PartEntry = NULL;

                RtlZeroMemory(EfiPartitionBuffer, SectorSize);                
                
                //
                // Move the read content to EfiPartitionBuffer
                //
                RtlCopyMemory(EfiPartitionBuffer, DataPointer, SectorSize);

                DBG_PRINT(STR_PREFIX"Locating the requested GPT partition\r\n");
                
                //
                // Locate the GPT partition requested
                //
                PartEntry = (UNALIGNED EFI_PARTITION_ENTRY *)
                                BlLocateGPTPartition(PartitionNumber, 
                                        PartitionsPerSector, 
                                        &ValidPartitions);                            

                if (PartEntry) {                
                    PPARTITION_CONTEXT PartContext = &(BlFileTable[FileId].u.PartitionContext);
                    ULONG   SectorCount = (ULONG)(PartEntry->EndingLBA - PartEntry->StartingLBA);

                    DBG_PRINT(STR_PREFIX"Initializing GPT Partition Entry Context\r\n");

                    //
                    // Fill the partition context structure
                    //
                    PartContext->PartitionLength.QuadPart = SectorCount * SECTOR_SIZE;
                    PartContext->StartingSector = (ULONG)(PartEntry->StartingLBA);
                    PartContext->EndingSector = (ULONG)(PartEntry->EndingLBA);


#if 0
                    BlPrint("Start:%d,End:%d\r\n", PartContext->StartingSector,
                            PartContext->EndingSector);
                    while (!BlGetKey());                            
#endif                    

                    BlFileTable[FileId].Position.QuadPart = 0;

                    Status = ESUCCESS;
                    
                    break;
                } else {
                    //
                    // Get hold of the next set of
                    // partition entries in the next block
                    //
                    PartitionCount = PartitionCount + PartitionsPerSector;
                    PartitionOffset++;
                }                    
            } else {
                break;  // I/O Error
            }
        }
    }

    DBG_PRINT(STR_PREFIX"Returning from ScsiGPTDiskBootPartitionOpen(...)\r\n");

    return Status;
}

#endif  // for EFI_PARTITION_SUPPORT


NTSTATUS
ScsiDiskBootPartitionOpen(
    IN ULONG   FileId,
    IN UCHAR   DeviceUnit,
    IN UCHAR   PartitionNumber
    )

/*++

Routine Description:

    This is the initialization routine for the hard disk boot driver
    for the given partition. It sets the partition info in the
    FileTable at the specified index and initializes the Device entry
    table to point to the table of ScsiDisk routines.

    It reads the partition information until the requested partition
    is found or no more partitions are defined.

Arguments:

    FileId - Supplies the file id for the file table entry.

    DeviceUnit - Supplies the device number in the scis bus.

    PartitionNumber - Supplies the partition number must be bigger than zero.
                      To get the size of the disk call ReadDriveCapacity.


Return Value:

    If a valid FAT file system structure is found on the hard disk, then
    STATUS_SUCCESS is returned. Otherwise, STATUS_UNSUCCESSFUL is returned.

--*/

{

    PMDL MdlAddress;
    USHORT DataBuffer[MAXIMUM_SECTOR_SIZE / sizeof(USHORT) + 128];
    PUSHORT DataPointer;
    ULONG DummyMdl[(sizeof(MDL) + 16) / sizeof(ULONG)];
    PPARTITION_DESCRIPTOR Partition;
    PPARTITION_CONTEXT Context;
    ULONG PartitionLength;
    ULONG StartingSector;
    ULONG VolumeOffset;
    NTSTATUS Status;
    BOOLEAN PrimaryPartitionTable;
    ULONG PartitionOffset=0;
    ULONG PartitionIndex,PartitionCount=0;
    ULONG SectorSize;

    UNREFERENCED_PARAMETER( DeviceUnit );

    BlFileTable[FileId].Position.LowPart = 0;
    BlFileTable[FileId].Position.HighPart = 0;

    VolumeOffset=0;
    PrimaryPartitionTable=TRUE;

    Context = &BlFileTable[FileId].u.PartitionContext;

    //
    // Calculate the actual sector size
    //

    SectorSize = 1 << Context->SectorShift;

    RtlZeroMemory(DataBuffer, sizeof(DataBuffer));

    //
    // Make the sector size the minimum of 512 or the sector size.
    //

    if (SectorSize < 512) {
        SectorSize = 512;
    }

    //
    // Align the buffer on a Dcache line size.
    //

    DataPointer =  (PVOID) ((ULONG_PTR) ((PCHAR) DataBuffer +
        KeGetDcacheFillSize() - 1) & ~((LONG)KeGetDcacheFillSize() - 1));

    //
    // Initialize a memory descriptor list to read the master boot record
    // from the specified hard disk drive.
    //

    MdlAddress = (PMDL)&DummyMdl[0];
    MdlAddress->StartVa = (PVOID)(((ULONG_PTR)DataPointer) & (~(PAGE_SIZE - 1)));
    MdlAddress->ByteCount = SectorSize;
    MdlAddress->ByteOffset = (ULONG)((ULONG_PTR)DataPointer & (PAGE_SIZE - 1));
    ScsiPortInitializeMdlPages (MdlAddress);
    do {
        Status = ScsiDiskBootIO(MdlAddress,PartitionOffset,Context,TRUE);
        if (NT_SUCCESS(Status) != FALSE) {

            //
            // If sector zero is not a master boot record, then return failure
            // status. Otherwise return success.
            //

            if (*(DataPointer + BOOT_SIGNATURE_OFFSET) != BOOT_RECORD_SIGNATURE) {
                // This DbgPrint has been commented out.  On IA64 and AXP64,
                // it crashes unless booted with a boot debugger.
                //DbgPrint("Boot record signature not found\n");
                return STATUS_UNSUCCESSFUL;
            }

            //
            // Read the partition information until the four entries are
            // checked or until we found the requested one.
            //
            Partition = (PPARTITION_DESCRIPTOR)(DataPointer+PARTITION_TABLE_OFFSET);
            for (PartitionIndex=0;
                PartitionIndex < NUM_PARTITION_TABLE_ENTRIES;
                PartitionIndex++,Partition++) {
                //
                // Count first the partitions in the MBR. The units
                // inside the extended partition are counted later.
                //
                if (!IsContainerPartition(Partition->PartitionType) &&
                    (Partition->PartitionType != STALE_GPT_PARTITION_ENTRY) &&
                    (Partition->PartitionType != PARTITION_ENTRY_UNUSED)) {
                    PartitionCount++;   // another partition found.
                }

                //
                // Check if the requested partition has already been found.
                // set the partition info in the file table and return.
                //
                if (PartitionCount == (ULONG)PartitionNumber) {
                    StartingSector = (ULONG)(Partition->StartingSectorLsb0) |
                                     (ULONG)(Partition->StartingSectorLsb1 << 8) |
                                     (ULONG)(Partition->StartingSectorMsb0 << 16) |
                                     (ULONG)(Partition->StartingSectorMsb1 << 24);
                    PartitionLength = (ULONG)(Partition->PartitionLengthLsb0) |
                                      (ULONG)(Partition->PartitionLengthLsb1 << 8) |
                                      (ULONG)(Partition->PartitionLengthMsb0 << 16) |
                                      (ULONG)(Partition->PartitionLengthMsb1 << 24);

                    Context->PartitionLength.QuadPart = PartitionLength;
                    Context->PartitionLength.QuadPart <<= Context->SectorShift;
                    Context->StartingSector = PartitionOffset + StartingSector;
                    Context->EndingSector = Context->StartingSector + PartitionLength;
                    return Status;
                }
            }

            //
            //  If requested partition was not yet found.
            //  Look for an extended partition.
            //
            Partition = (PPARTITION_DESCRIPTOR)(DataPointer + PARTITION_TABLE_OFFSET);
            PartitionOffset = 0;
            for (PartitionIndex=0;
                PartitionIndex < NUM_PARTITION_TABLE_ENTRIES;
                PartitionIndex++,Partition++) {
                if (IsContainerPartition(Partition->PartitionType)) {
                    StartingSector = (ULONG)(Partition->StartingSectorLsb0) |
                                     (ULONG)(Partition->StartingSectorLsb1 << 8) |
                                     (ULONG)(Partition->StartingSectorMsb0 << 16) |
                                     (ULONG)(Partition->StartingSectorMsb1 << 24);
                    PartitionOffset = VolumeOffset+StartingSector;
                    if (PrimaryPartitionTable) {
                        VolumeOffset = StartingSector;
                    }
                    break;      // only one partition can be extended.
                }
            }
        }
        PrimaryPartitionTable=FALSE;
    } while (PartitionOffset != 0);
    return STATUS_UNSUCCESSFUL;
}

VOID
ScsiPortInitializeMdlPages (
    IN OUT PMDL Mdl
    )
/*++

Routine Description:

    This routine fills in the physical pages numbers for the virtual
    addresses specified in the passed in Mdl.

Arguments:

    Mdl     - On input contains the StartVa, ByteCount and  ByteOffset
              of the Mdl.

Return Value:

    Mdl     - The physical page array referenced by the mdl is completed

--*/

{
    PULONG PageFrame;
    PUCHAR PageVa;
    ULONG Index;
    ULONG NumberOfPages;

    PageFrame = (PULONG)(Mdl + 1);
    PageVa = (PUCHAR) Mdl->StartVa;
    NumberOfPages = (Mdl->ByteCount + Mdl->ByteOffset + PAGE_SIZE - 1) >> PAGE_SHIFT;
    for (Index = 0; Index < NumberOfPages; Index += 1) {
        PageFrame[Index] = (ULONG)(MmGetPhysicalAddress(PageVa).QuadPart >> PAGE_SHIFT);
        PageVa += PAGE_SIZE;
    }
}

BOOLEAN
ScsiGetDevicePath(
    IN ULONG ScsiNumber,
    IN PCONFIGURATION_COMPONENT TargetComponent,
    IN PCONFIGURATION_COMPONENT LunComponent,
    OUT PCHAR DevicePath
    )
/*++

Routine Description:

    This routine constructs the device path for the device identified
    by the supplied parameters.

Arguments:

    ScsiNumber      - Identifies the scis bus on which the device resides.

    TargetComponent - Points to a CONFIGURATION_COMPONENT structure that
                      describes the target.

    LunComponent    - Points to a CONFIGURATION_COMPONENT structure that
                      describes the lun.

    DevicePath      - Points to the output buffer into which the device path
                      is copied.

Return Value:

    TRUE if a valid device path is copied into the output buffer.

    FALSE if the supplied parameters do not represent a valid device. If
    the return value is FALSE, nothing copied into the output buffer.

--*/
{
    if (TargetComponent->Type == DiskController) {

        //
        // This is either a hard disk or a floppy floppy disk. Construct
        // the appropriate device path depending on which.
        //

        if (LunComponent->Type == FloppyDiskPeripheral) {
            sprintf(DevicePath, "scsi(%d)disk(%d)fdisk(%d)",
                    ScsiNumber,
                    TargetComponent->Key,
                    LunComponent->Key);
        } else if (LunComponent->Type == DiskPeripheral) {
            sprintf(DevicePath, "scsi(%d)disk(%d)rdisk(%d)",
                    ScsiNumber,
                    TargetComponent->Key,
                    LunComponent->Key);
        } else {
            ASSERT(FALSE);
            return FALSE;
        }

    } else if (TargetComponent->Type == CdromController) {

        //
        // This is a cdrom device. Construct an appropriate device path.
        //

        sprintf(DevicePath, "scsi(%d)cdrom(%d)fdisk(%d)",
                ScsiNumber,
                TargetComponent->Key,
                LunComponent->Key);
    } else {

        //
        // Unexpected device path.
        //

        ASSERT(FALSE);
        return FALSE;
    }

    return TRUE;
}

PCONFIGURATION_COMPONENT
ScsiGetNextConfiguredLunComponent(
    IN PCONFIGURATION_COMPONENT LunComponent
    )
/*++

Routine Description:

    Given a lun that exists on one of the system's SCSI buses, this 
    routine returns the next sequential lun identified on the same
    target.

Arguments:

    LunComponent - Pointer to a CONFIGURATION_COMPONENT structure that
                   describes an existing lun.

Return Value:

    If one or more luns were identified on the same target as supplied 
    lun, this function returns a pointer to a CONFIGURATION_COMPONTENT       
    structure that describes the next sequential lun on the same target.

--*/
{
    PCONFIGURATION_COMPONENT nextLunComponent;

    nextLunComponent = FwGetPeer(LunComponent);
    if (nextLunComponent != NULL) {
        if (nextLunComponent->Type != FloppyDiskPeripheral &&
            nextLunComponent->Type != DiskPeripheral) {
            nextLunComponent = NULL;
        }
    }
    return nextLunComponent;
}

PCONFIGURATION_COMPONENT
ScsiGetFirstConfiguredLunComponent(
    IN PCONFIGURATION_COMPONENT TargetComponent
    )
/*++

Routine Description:

    Given a target that exists on one of the system's SCSI buses, this
    routine returns the first LUN identified on that target.

Arguments:

    TargetComponent - Pointer to a CONFIGURATION_COMPONENT structure that
                      describes an existing SCSI target.

Return Value:

    If any lun was identified on given target, this function returns a pointer
    to a CONFIGURATION_COMPONENT structure that describes the lun.  If no
    LUNs were found on the target, NULL is returned.

--*/
{
    PCONFIGURATION_COMPONENT lunComponent;

    lunComponent = FwGetChild(TargetComponent);
    if (lunComponent != NULL) {
        if (lunComponent->Type != FloppyDiskPeripheral &&
            lunComponent->Type != DiskPeripheral) {
            lunComponent = NULL;
        }
    }
    return lunComponent;
}

PCONFIGURATION_COMPONENT
ScsiGetNextConfiguredTargetComponent(
    IN PCONFIGURATION_COMPONENT TargetComponent
    )
/*++

Routine Description:

    Given a target that exists on one of the system's SCSI buses, this
    routine returns the next numerically sequestial target found on the 
    same bus.  

Arguments:

    TargetComponent - Pointer to a CONFIGURATION_COMPONENT structure
                      that describes a SCSI target.    

Return Value:

    If one or more targets were identified on the same SCSI bus as the 
    supplied target, a pointer to a CONFIGURATION_COMPONENT structure
    that describes the next sequential target is returned.  If there
    are no targets following the one supplied, NULL is returned.

--*/
{
    PCONFIGURATION_COMPONENT nextTarget;

    nextTarget = FwGetPeer(TargetComponent);
    if (nextTarget != NULL) {
        if (nextTarget->Type != DiskController && 
            nextTarget->Type != CdromController) {
            nextTarget = NULL;
        }
    }
    return nextTarget;
}

PCONFIGURATION_COMPONENT
ScsiGetFirstConfiguredTargetComponent(
    ULONG ScsiNumber 
    )
/*++

Routine Description:

    This routine returns the first configured target on the specified SCSI bus.

Arguments:

    ScsiNumber - Identifies the SCSI bus for which the first target is requested.

Return Value:

    If any target was detected on the specified bus, a pointer to a
    CONFIGURATION_COMPONENT structure describing the target is returned.  If no 
    targets were detected on the speicified bus, the funtion returns NULL.

--*/
{
    PCONFIGURATION_COMPONENT scsiComponent;
    PCONFIGURATION_COMPONENT controllerComponent;
    CHAR componentPath[10];

    //
    // Get the requested scsi adapter component.  If no match, return NULL.
    //

    sprintf(componentPath, "scsi(%1d)", ScsiNumber);
    scsiComponent = FwGetComponent(componentPath);
    if (scsiComponent == NULL) {
        return NULL;
    }

    //
    // If returned the component is not a SCSI adapter, return NULL.
    //
  
    if (scsiComponent->Type != ScsiAdapter) {
        return NULL;
    }

    //
    // Get the first configured target on the adapter.
    //

    controllerComponent = FwGetChild(scsiComponent);
        
    if ((controllerComponent != NULL) &&
         ((controllerComponent->Type == DiskController) ||
         (controllerComponent->Type == CdromController))) {
        return controllerComponent;
    } else {
        //
        // We got back an unexpected controller type.
        //

        ASSERT(FALSE);
    }
    
    return NULL;
}

//
// This callback messes a lot of things up.  There is no clean definition
// for it anywhere, so it has to be defined in all modules that reference it.
//

#ifndef SCSI_INFO_CALLBACK_DEFINED

typedef
VOID
(*PSCSI_INFO_CALLBACK_ROUTINE) (
    IN ULONG AdapterNumber,
    IN ULONG ScsiId,
    IN ULONG Lun,
    IN BOOLEAN Cdrom
    );
#endif

VOID
HardDiskInitialize(
    IN OUT PDRIVER_LOOKUP_ENTRY LookupTable,
    IN ULONG Entries,
    IN PSCSI_INFO_CALLBACK_ROUTINE DeviceFound
    )

/*++

Routine Description:

    This routine initializes the scsi controller and the
    device entry table for the scsi driver.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG lookupTableIndex = 0;
    ULONG scsiNumber;
    ULONG busNumber;
    PCHAR Identifier;
    PLUNINFO lunInfo;
    PSCSI_CONFIGURATION_INFO configInfo;
    PSCSI_BUS_SCAN_DATA busScanData;
    PDEVICE_EXTENSION scsiPort;
    PINQUIRYDATA inquiryData;
    PCONFIGURATION_COMPONENT RootComponent;
    PCONFIGURATION_COMPONENT ScsiComponent;
    PCONFIGURATION_COMPONENT ControllerComponent;
    PCONFIGURATION_COMPONENT PeripheralComponent;
    PCONFIGURATION_COMPONENT NextComponent;
    CHAR ComponentPath[10];
    CONFIGURATION_COMPONENT ControllerEntry;
    CONFIGURATION_COMPONENT AdapterEntry;
    CONFIGURATION_COMPONENT PeripheralEntry;
    PARTITION_CONTEXT Context;
    BOOLEAN IsFloppy;

    RtlZeroMemory(&Context, sizeof(PARTITION_CONTEXT));

    //
    // Initialize the common buffers.
    //

    ReadCapacityBuffer = ExAllocatePool( NonPagedPool, sizeof(READ_CAPACITY_DATA));

    SenseInfoBuffer = ExAllocatePool( NonPagedPool, SENSE_BUFFER_SIZE);

    if (ReadCapacityBuffer == NULL || SenseInfoBuffer == NULL) {
        return;
    }

    //
    // Scan the scsi ports looking for disk devices.
    //

    for (scsiNumber = 0; ScsiPortDeviceObject[scsiNumber]; scsiNumber++) {

        scsiPort = ScsiPortDeviceObject[scsiNumber]->DeviceExtension;
        configInfo = scsiPort->ScsiInfo;
        Context.PortDeviceObject = ScsiPortDeviceObject[scsiNumber];

        //
        // Search the configuration database for scsi disk and cdrom devices and
        // delete them.
        //

        sprintf(ComponentPath,"scsi(%1d)", scsiNumber);
        ScsiComponent = FwGetComponent(ComponentPath);

        if (ScsiComponent != NULL) {
            if (ScsiComponent->Type == ScsiAdapter) {
                ControllerComponent = FwGetChild(ScsiComponent);

                while (ControllerComponent != NULL) {
                    NextComponent = FwGetPeer(ControllerComponent);

                    if ((ControllerComponent->Type == DiskController) ||
                        (ControllerComponent->Type == CdromController)) {

                        PeripheralComponent = FwGetChild(ControllerComponent);
                        if (FwDeleteComponent(PeripheralComponent) == ESUCCESS) {
                            FwDeleteComponent(ControllerComponent);
                        }
                    }
                    ControllerComponent = NextComponent;
                }
            } else {
                RootComponent = FwGetChild(NULL);
                AdapterEntry.Class = AdapterClass;
                AdapterEntry.Type = ScsiAdapter;
                AdapterEntry.Flags.ReadOnly = 0;
                AdapterEntry.Flags.Removable = 0;
                AdapterEntry.Flags.ConsoleIn = 0;
                AdapterEntry.Flags.ConsoleOut = 0;
                AdapterEntry.Flags.Output = 1;
                AdapterEntry.Flags.Input = 1;
                AdapterEntry.Version = 0;
                AdapterEntry.Revision = 0;
                AdapterEntry.Key = scsiNumber;
                AdapterEntry.AffinityMask = 0xffffffff;
                AdapterEntry.ConfigurationDataLength = 0;
                AdapterEntry.IdentifierLength = 0;
                AdapterEntry.Identifier = 0;
                ScsiComponent = FwAddChild(RootComponent, &AdapterEntry, NULL);
            }
        }

        for (busNumber=0; busNumber < (ULONG)configInfo->NumberOfBuses; busNumber++) {

            busScanData = configInfo->BusScanData[busNumber];

            //
            // Set LunInfo to beginning of list.
            //

            lunInfo = busScanData->LunInfoList;

            while (lunInfo != NULL) {

                inquiryData = (PVOID)lunInfo->InquiryData;

                ScsiDebugPrint(3,"FindScsiDevices: Inquiry data at %lx\n",
                    inquiryData);

                if ((inquiryData->DeviceType == DIRECT_ACCESS_DEVICE
                    || inquiryData->DeviceType == OPTICAL_DEVICE) &&
                    !lunInfo->DeviceClaimed) {

                    ScsiDebugPrint(1,
                                   "FindScsiDevices: Vendor string is %.24s\n",
                                   inquiryData->VendorId);

                    IsFloppy = FALSE;

                    //
                    // Create a dummy paritition context so that I/O can be
                    // done on the device.  SendSrbSynchronous only uses the
                    // port device object pointer and the scsi address of the
                    // logical unit.
                    //

                    Context.PathId = lunInfo->PathId;
                    Context.TargetId = lunInfo->TargetId;
                    Context.DiskId = lunInfo->Lun;

                    //
                    // Create name for disk object.
                    //

                    LookupTable->DevicePath =
                        ExAllocatePool(NonPagedPool,
                                       sizeof("scsi(%d)disk(%d)rdisk(%d)"));

                    if (LookupTable->DevicePath == NULL) {
                        return;
                    }

                    //
                    // If this is a removable.  Check to see if the device is
                    // a floppy.
                    //

                    if (inquiryData->RemovableMedia  &&
                        inquiryData->DeviceType == DIRECT_ACCESS_DEVICE &&
                        IsFloppyDevice(&Context) ) {

                        sprintf(LookupTable->DevicePath,
                            "scsi(%d)disk(%d)fdisk(%d)",
                            scsiNumber,
                            SCSI_COMBINE_BUS_TARGET( lunInfo->PathId, lunInfo->TargetId ),
                            lunInfo->Lun
                            );

                        IsFloppy = TRUE;
                    } else {

                        sprintf(LookupTable->DevicePath,
                            "scsi(%d)disk(%d)rdisk(%d)",
                            scsiNumber,
                            SCSI_COMBINE_BUS_TARGET( lunInfo->PathId, lunInfo->TargetId ),
                            lunInfo->Lun
                            );

                        if (DeviceFound) {
                            DeviceFound( scsiNumber,
                            SCSI_COMBINE_BUS_TARGET( lunInfo->PathId, lunInfo->TargetId ),
                                 lunInfo->Lun,
                                 FALSE
                               );
                        }
                    }

                    LookupTable->DispatchTable = &ScsiDiskEntryTable;

                    //
                    // If the disk controller entry does not exist, add it to
                    // the configuration database.
                    //

                    ControllerComponent = FwGetComponent(LookupTable->DevicePath);

                    if (ControllerComponent != NULL) {
                        if (ControllerComponent->Type != DiskController) {

                            ControllerEntry.Class = ControllerClass;
                            ControllerEntry.Type = DiskController;
                            ControllerEntry.Flags.Failed = 0;
                            ControllerEntry.Flags.ReadOnly = 0;
                            ControllerEntry.Flags.Removable = 0;
                            ControllerEntry.Flags.ConsoleIn = 0;
                            ControllerEntry.Flags.ConsoleOut = 0;
                            ControllerEntry.Flags.Output = 1;
                            ControllerEntry.Flags.Input = 1;
                            ControllerEntry.Version = 0;
                            ControllerEntry.Revision = 0;
                            ControllerEntry.Key = SCSI_COMBINE_BUS_TARGET( lunInfo->PathId, lunInfo->TargetId );
                            ControllerEntry.AffinityMask = 0xffffffff;
                            ControllerEntry.ConfigurationDataLength = 0;

                            Identifier =
                                ExAllocatePool(NonPagedPool,
                                               strlen((PCHAR) inquiryData->VendorId) + 1
                                               );

                            if (Identifier == NULL) {
                                return;
                            }

                            strcpy( Identifier, (PCHAR) inquiryData->VendorId);

                            ControllerEntry.IdentifierLength = strlen(Identifier);
                            ControllerEntry.Identifier = Identifier;

                            ControllerComponent = FwAddChild(ScsiComponent, &ControllerEntry, NULL);
                        }
                    }

                    //
                    // Add disk peripheral entry to the configuration database.
                    //

                    PeripheralEntry.Class = PeripheralClass;
                    PeripheralEntry.Type = IsFloppy ? FloppyDiskPeripheral : DiskPeripheral;
                    PeripheralEntry.Flags.Failed = 0;
                    PeripheralEntry.Flags.ReadOnly = 0;
                    PeripheralEntry.Flags.Removable = IsFloppy;
                    PeripheralEntry.Flags.ConsoleIn = 0;
                    PeripheralEntry.Flags.ConsoleOut = 0;
                    PeripheralEntry.Flags.Output = 1;
                    PeripheralEntry.Flags.Input = 1;
                    PeripheralEntry.Version = 0;
                    PeripheralEntry.Revision = 0;
                    PeripheralEntry.Key = lunInfo->Lun;
                    PeripheralEntry.AffinityMask = 0xffffffff;
                    PeripheralEntry.ConfigurationDataLength = 0;
                    PeripheralEntry.IdentifierLength = 0;
                    PeripheralEntry.Identifier = NULL;

                    FwAddChild(ControllerComponent, &PeripheralEntry, NULL);

                    //
                    // Increment to the next entry.
                    //

                    LookupTable++;
                    lookupTableIndex++;
                    if (lookupTableIndex >= Entries) {

                        //
                        // There is no more space in the caller provided buffer
                        // for disk information.  Return.
                        //
                        return;
                    }

                    //
                    // Claim disk device by marking configuration
                    // record owned.
                    //

                    lunInfo->DeviceClaimed = TRUE;

                }

                if ((inquiryData->DeviceType == READ_ONLY_DIRECT_ACCESS_DEVICE) &&
                    (!lunInfo->DeviceClaimed)) {

                    ScsiDebugPrint(1,"FindScsiDevices: Vendor string is %s\n", inquiryData->VendorId);

                    //
                    // Create name for cdrom object.
                    //

                    LookupTable->DevicePath =
                        ExAllocatePool( NonPagedPool, sizeof("scsi(%d)cdrom(%d)fdisk(%d)"));

                    if (LookupTable->DevicePath == NULL) {
                        return;
                    }

                    sprintf(LookupTable->DevicePath,
                        "scsi(%d)cdrom(%d)fdisk(%d)",
                        scsiNumber,
                        SCSI_COMBINE_BUS_TARGET( lunInfo->PathId, lunInfo->TargetId ),
                        lunInfo->Lun
                        );

                    LookupTable->DispatchTable = &ScsiDiskEntryTable;

                    if (DeviceFound) {
                        DeviceFound( scsiNumber,
                                 SCSI_COMBINE_BUS_TARGET( lunInfo->PathId, lunInfo->TargetId ),
                                 lunInfo->Lun,
                                 TRUE
                               );
                    }

                    //
                    // If the cdrom controller entry does not exist, add it to
                    // the configuration database.
                    //

                    ControllerComponent = FwGetComponent(LookupTable->DevicePath);

                    if (ControllerComponent != NULL) {
                        if (ControllerComponent->Type != CdromController) {

                            ControllerEntry.Class = ControllerClass;
                            ControllerEntry.Type = CdromController;
                            ControllerEntry.Flags.Failed = 0;
                            ControllerEntry.Flags.ReadOnly = 1;
                            ControllerEntry.Flags.Removable = 1;
                            ControllerEntry.Flags.ConsoleIn = 0;
                            ControllerEntry.Flags.ConsoleOut = 0;
                            ControllerEntry.Flags.Output = 0;
                            ControllerEntry.Flags.Input = 1;
                            ControllerEntry.Version = 0;
                            ControllerEntry.Revision = 0;
                            ControllerEntry.Key = SCSI_COMBINE_BUS_TARGET( lunInfo->PathId, lunInfo->TargetId );
                            ControllerEntry.AffinityMask = 0xffffffff;
                            ControllerEntry.ConfigurationDataLength = 0;

                            Identifier =
                                ExAllocatePool( NonPagedPool,
                                                strlen((PCHAR)inquiryData->VendorId) + 1
                                                );

                            if (Identifier == NULL) {
                                return;
                            }

                            strcpy(Identifier, (PCHAR)inquiryData->VendorId);

                            ControllerEntry.IdentifierLength = strlen(Identifier);
                            ControllerEntry.Identifier = Identifier;

                            ControllerComponent = FwAddChild(ScsiComponent, &ControllerEntry, NULL);
                        }
                    }

                    //
                    // Add disk peripheral entry to the configuration database.
                    //

                    PeripheralEntry.Class = PeripheralClass;
                    PeripheralEntry.Type = FloppyDiskPeripheral;
                    PeripheralEntry.Flags.Failed = 0;
                    PeripheralEntry.Flags.ReadOnly = 1;
                    PeripheralEntry.Flags.Removable = 1;
                    PeripheralEntry.Flags.ConsoleIn = 0;
                    PeripheralEntry.Flags.ConsoleOut = 0;
                    PeripheralEntry.Flags.Output = 0;
                    PeripheralEntry.Flags.Input = 1;
                    PeripheralEntry.Version = 0;
                    PeripheralEntry.Revision = 0;
                    PeripheralEntry.Key = lunInfo->Lun;
                    PeripheralEntry.AffinityMask = 0xffffffff;
                    PeripheralEntry.ConfigurationDataLength = 0;
                    PeripheralEntry.IdentifierLength = 0;
                    PeripheralEntry.Identifier = NULL;

                    FwAddChild(ControllerComponent, &PeripheralEntry, NULL);

                    //
                    // Increment to the next entry.
                    //

                    LookupTable++;
                    lookupTableIndex++;
                    if (lookupTableIndex >= Entries) {

                        //
                        // There is no more space in the caller provided buffer
                        // for disk information.  Return.
                        //
                        return;
                    }


                    //
                    // Claim disk device by marking configuration
                    // record owned.
                    //

                    lunInfo->DeviceClaimed = TRUE;

                }

                //
                // Get next LunInfo.
                //

                lunInfo = lunInfo->NextLunInfo;
            }
        }
    }

//    ScsiDebugPrint(1,"FindScsiDevices: Hit any key\n");
//    PAUSE;

}

NTSTATUS
ScsiDiskBootIO (
    IN PMDL MdlAddress,
    IN ULONG LogicalBlock,
    IN PPARTITION_CONTEXT PartitionContext,
    IN BOOLEAN Operation
    )

/*++

Routine Description:

    This routine is the read/write routine for the hard disk boot driver.

Arguments:

    MdlAddress - Supplies a pointer to an MDL for the IO operation.

    LogicalBlock - Supplies the starting block number.

    DeviceUnit  - Supplies the SCSI Id number.

    Operation - Specifies the IO operation to perform
                TRUE  =  SCSI_READ
                FALSE =  SCSI_WRITE.

Return Value:

    The final status of the read operation (STATUS_UNSUCCESSFUL or
    STATUS_SUCCESS).

--*/

{
    ARC_STATUS Status;
    PIRP Irp;
    PIO_STACK_LOCATION NextIrpStack;
    PSCSI_REQUEST_BLOCK Srb;
    ULONG RetryCount = MAXIMUM_RETRIES;

    //
    // Check that the request is within the limits of the partition.
    //
    if (PartitionContext->StartingSector > LogicalBlock) {
        return STATUS_UNSUCCESSFUL;
    }
    if (PartitionContext->EndingSector <
        LogicalBlock + (MdlAddress->ByteCount >> PartitionContext->SectorShift)) {
        return STATUS_UNSUCCESSFUL;
    }

Retry:

    //
    // Build the I/O Request.
    //

    Irp = BuildRequest(PartitionContext, MdlAddress, LogicalBlock, Operation);

    NextIrpStack = IoGetNextIrpStackLocation(Irp);
    Srb = NextIrpStack->Parameters.Others.Argument1;

    //
    // Call the port driver.
    //

    IoCallDriver(PartitionContext->PortDeviceObject, Irp);

    //
    // Check the status.
    //

    if (SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        //
        // Determine the cause of the error.
        //

        if (InterpretSenseInfo(Srb, &Status, PartitionContext) && RetryCount--) {

            goto Retry;
        }

        if (Status == EAGAIN) {
            Status = EIO;
        }

        DebugPrint((1, "SCSI: Read request failed.  Arc Status: %d, Srb Status: %x\n",
            Status,
            Srb->SrbStatus
            ));

    } else {

        Status = ESUCCESS;

    }

    return(Status);
}

ARC_STATUS
ReadDriveCapacity(
    IN PPARTITION_CONTEXT PartitionContext
    )

/*++

Routine Description:

    This routine sends a read capacity to a target id and returns
    when it is complete.

Arguments:

Return Value:

    Status is returned.

--*/
{
    PCDB Cdb;
    PSCSI_REQUEST_BLOCK Srb = &PrimarySrb.Srb;
    ULONG LastSector;
    ULONG retries = 1;
    ARC_STATUS status;
    ULONG BytesPerSector;

    ScsiDebugPrint(3,"SCSI ReadCapacity: Enter routine\n");


    //
    // Build the read capacity CDB.
    //

    Srb->CdbLength = 10;
    Cdb = (PCDB)Srb->Cdb;

    //
    // Zero CDB in SRB on stack.
    //

    RtlZeroMemory(Cdb, MAXIMUM_CDB_SIZE);

    Cdb->CDB10.OperationCode = SCSIOP_READ_CAPACITY;

Retry:

    status = SendSrbSynchronous(PartitionContext,
                  Srb,
                  ReadCapacityBuffer,
                  sizeof(READ_CAPACITY_DATA),
                  FALSE);

    if (status == ESUCCESS) {

#if 0
        //
        // Copy sector size from read capacity buffer to device extension
        // in reverse byte order.
        //

        deviceExtension->DiskGeometry->BytesPerSector = 0;

        ((PFOUR_BYTE)&deviceExtension->DiskGeometry->BytesPerSector)->Byte0 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->BytesPerBlock)->Byte3;

        ((PFOUR_BYTE)&deviceExtension->DiskGeometry->BytesPerSector)->Byte1 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->BytesPerBlock)->Byte2;

        if (BytesPerSector == 0) {

            //
            // Assume this is a bad cd-rom and the sector size is 2048.
            //

            BytesPerSector = 2048;

        }

        //
        // Make sure the sector size is less than the maximum expected.
        //

        ASSERT(BytesPerSector <= MAXIMUM_SECTOR_SIZE);

        if (BytesPerSector > MAXIMUM_SECTOR_SIZE) {
            return(EINVAL);
        }

        //
        // Copy last sector in reverse byte order.
        //

        ((PFOUR_BYTE)&LastSector)->Byte0 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->LogicalBlockAddress)->Byte3;

        ((PFOUR_BYTE)&LastSector)->Byte1 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->LogicalBlockAddress)->Byte2;

        ((PFOUR_BYTE)&LastSector)->Byte2 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->LogicalBlockAddress)->Byte1;

        ((PFOUR_BYTE)&LastSector)->Byte3 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->LogicalBlockAddress)->Byte0;

        //
        // Calculate sector to byte shift.
        //

        WHICH_BIT(deviceExtension->DiskGeometry->BytesPerSector, deviceExtension->SectorShift);

        ScsiDebugPrint(2,"SCSI ReadDriveCapacity: Sector size is %d\n",
            deviceExtension->DiskGeometry->BytesPerSector);

        ScsiDebugPrint(2,"SCSI ReadDriveCapacity: Number of Sectors is %d\n",
            LastSector + 1);

        //
        // Calculate media capacity in bytes.
        //

        deviceExtension->PartitionLength = LastSector + 1;

        deviceExtension->PartitionLength.QuadPart <<= deviceExtension->SectorShift.QuadPart;

        //
        // Assume media type is fixed disk.
        //

        deviceExtension->DiskGeometry->MediaType = FixedMedia;

        //
        // Assume sectors per track are 32;
        //

        deviceExtension->DiskGeometry->SectorsPerTrack = 32;

        //
        // Assume tracks per cylinder (number of heads) is 64.
        //

        deviceExtension->DiskGeometry->TracksPerCylinder = 64;
#else

        BytesPerSector = 0;

        //
        // Copy sector size from read capacity buffer to device extension
        // in reverse byte order.
        //

        ((PFOUR_BYTE)&BytesPerSector)->Byte0 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->BytesPerBlock)->Byte3;

        ((PFOUR_BYTE)&BytesPerSector)->Byte1 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->BytesPerBlock)->Byte2;

        if (BytesPerSector == 0) {

            //
            // Assume this is a bad cd-rom and the sector size is 2048.
            //

            BytesPerSector = 2048;

        }

        //
        // Calculate sector to byte shift.
        //

        WHICH_BIT(BytesPerSector, PartitionContext->SectorShift);

        //
        // Copy last sector in reverse byte order.
        //

        ((PFOUR_BYTE)&LastSector)->Byte0 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->LogicalBlockAddress)->Byte3;

        ((PFOUR_BYTE)&LastSector)->Byte1 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->LogicalBlockAddress)->Byte2;

        ((PFOUR_BYTE)&LastSector)->Byte2 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->LogicalBlockAddress)->Byte1;

        ((PFOUR_BYTE)&LastSector)->Byte3 =
            ((PFOUR_BYTE)&ReadCapacityBuffer->LogicalBlockAddress)->Byte0;


        PartitionContext->PartitionLength.QuadPart = LastSector + 1;
        PartitionContext->PartitionLength.QuadPart <<= PartitionContext->SectorShift;

        PartitionContext->StartingSector=0;
        PartitionContext->EndingSector = LastSector + 1;

        ScsiDebugPrint(2,"SCSI ReadDriveCapacity: Sector size is %d\n",
            BytesPerSector);

        ScsiDebugPrint(2,"SCSI ReadDriveCapacity: Number of Sectors is %d\n",
            LastSector + 1);


#endif
    }

    if (status == EAGAIN || status == EBUSY) {

        if (retries--) {

            //
            // Retry request.
            //

            goto Retry;
        }
    }

    return status;

} // end ReadDriveCapacity()


ARC_STATUS
SendSrbSynchronous(
    PPARTITION_CONTEXT PartitionContext,
    PSCSI_REQUEST_BLOCK Srb,
    PVOID BufferAddress,
    ULONG BufferLength,
    BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine is called by SCSI device controls to complete an
    SRB and send it to the port driver synchronously (ie wait for
    completion).
    The CDB is already completed along with the SRB CDB size and
    request timeout value.

Arguments:

    PartitionContext
    SRB
    Buffer address and length (if transfer)

    WriteToDevice - Indicates the direction of the transfer.

Return Value:

    ARC_STATUS

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION IrpStack;
    ULONG retryCount = 1;
    ARC_STATUS status;

    //
    // Write length to SRB.
    //

    Srb->Length = SCSI_REQUEST_BLOCK_SIZE;

    //
    // Set SCSI bus address.
    //

    Srb->PathId = PartitionContext->PathId;
    Srb->TargetId = PartitionContext->TargetId;
    Srb->Lun = PartitionContext->DiskId;

    Srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    //
    // Enable auto request sense.
    //

    Srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    if (SenseInfoBuffer == NULL) {
        // This DbgPrint has been commented out.  On IA64 and AXP64,
        // it crashes unless booted with a boot debugger.
        //("SendSrbSynchronous: Can't allocate request sense buffer\n");
        return(ENOMEM);
    }

    Srb->SenseInfoBuffer = SenseInfoBuffer;

    Srb->DataBuffer = BufferAddress;

    //
    // Start retries here.
    //

retry:

    Irp = InitializeIrp(
        &PrimarySrb,
        IRP_MJ_SCSI,
        PartitionContext->PortDeviceObject,
        BufferAddress,
        BufferLength
        );

    if (BufferAddress != NULL) {

        if (WriteToDevice) {

            Srb->SrbFlags = SRB_FLAGS_DATA_OUT;

        } else {

            Srb->SrbFlags = SRB_FLAGS_DATA_IN;

        }

    } else {

        //
        // Clear flags.
        //

        Srb->SrbFlags = SRB_FLAGS_NO_DATA_TRANSFER;
    }

    //
    // Disable synchronous transfers.
    //

    Srb->SrbFlags |= SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Set the transfer length.
    //

    Srb->DataTransferLength = BufferLength;

    //
    // Zero out status.
    //

    Srb->ScsiStatus = Srb->SrbStatus = 0;

    //
    // Get next stack location and
    // set major function code.
    //

    IrpStack = IoGetNextIrpStackLocation(Irp);


    //
    // Set up SRB for execute scsi request.
    // Save SRB address in next stack for port driver.
    //

    IrpStack->Parameters.Others.Argument1 = (PVOID)Srb;

    //
    // Set up IRP Address.
    //

    Srb->OriginalRequest = Irp;

    Srb->NextSrb = 0;

    //
    // No need to check the following 2 returned statuses as
    // SRB will have ending status.
    //

    (VOID)IoCallDriver(PartitionContext->PortDeviceObject, Irp);

    //
    // Check that request completed without error.
    //

    if (SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        //
        // Update status and determine if request should be retried.
        //

        if (InterpretSenseInfo(Srb, &status, PartitionContext)) {

            //
            // If retries are not exhausted then
            // retry this operation.
            //

            if (retryCount--) {
                goto retry;
            }
        }

    } else {

        status = ESUCCESS;
    }

    return status;

} // end SendSrbSynchronous()


BOOLEAN
InterpretSenseInfo(
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT ARC_STATUS *Status,
    PPARTITION_CONTEXT PartitionContext
    )

/*++

Routine Description:

    This routine interprets the data returned from the SCSI
    request sense. It determines the status to return in the
    IRP and whether this request can be retried.

Arguments:

    DeviceObject
    SRB
    ARC_STATUS to update IRP

Return Value:

    BOOLEAN TRUE: Drivers should retry this request.
            FALSE: Drivers should not retry this request.

--*/

{
    PSENSE_DATA SenseBuffer = Srb->SenseInfoBuffer;
    BOOLEAN retry;

    //
    // Check that request sense buffer is valid.
    //

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        ScsiDebugPrint(2,"InterpretSenseInfo: Error code is %x\n",
                SenseBuffer->ErrorCode);

        ScsiDebugPrint(2,"InterpretSenseInfo: Sense key is %x\n",
                SenseBuffer->SenseKey);

        ScsiDebugPrint(2,"InterpretSenseInfo: Additional sense code is %x\n",
                SenseBuffer->AdditionalSenseCode);

        ScsiDebugPrint(2,"InterpretSenseInfo: Additional sense code qualifier is %x\n",
                SenseBuffer->AdditionalSenseCodeQualifier);

            switch (SenseBuffer->SenseKey) {

                case SCSI_SENSE_NOT_READY:

                    ScsiDebugPrint(1,"InterpretSenseInfo: Device not ready\n");

                    ScsiDebugPrint(1,"InterpretSenseInfo: Waiting for device\n");

                    *Status = EBUSY;

                    retry = TRUE;

                    switch (SenseBuffer->AdditionalSenseCode) {

                    case SCSI_ADSENSE_LUN_NOT_READY:

                        ScsiDebugPrint(1,"InterpretSenseInfo: Lun not ready\n");

                        switch (SenseBuffer->AdditionalSenseCodeQualifier) {

                        case SCSI_SENSEQ_BECOMING_READY:

                            ScsiDebugPrint(1,
                                        "InterpretSenseInfo:"
                                        " In process of becoming ready\n");

                            FwStallExecution( 1000 * 1000 * 3 );

                            break;

                        case SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED:

                            ScsiDebugPrint(1,
                                        "InterpretSenseInfo:"
                                        " Manual intervention required\n");
                           *Status = (ARC_STATUS)STATUS_NO_MEDIA_IN_DEVICE;
                            retry = FALSE;
                            break;

                        case SCSI_SENSEQ_FORMAT_IN_PROGRESS:

                            ScsiDebugPrint(1,
                                        "InterpretSenseInfo:"
                                        " Format in progress\n");
                            retry = FALSE;
                            break;

                        default:

                            FwStallExecution( 1000 * 1000 * 3 );

                            //
                            // Try a start unit too.
                            //

                        case SCSI_SENSEQ_INIT_COMMAND_REQUIRED:

                            ScsiDebugPrint(1,
                                        "InterpretSenseInfo:"
                                        " Initializing command required\n");

                            //
                            // This sense code/additional sense code
                            // combination may indicate that the device
                            // needs to be started.
                            //

                            ScsiDiskStartUnit(PartitionContext);
                            break;

                        }

                    } // end switch

                    break;

                case SCSI_SENSE_DATA_PROTECT:

                    ScsiDebugPrint(1,"InterpretSenseInfo: Media write protected\n");

                    *Status = EACCES;

                    retry = FALSE;

                    break;

                case SCSI_SENSE_MEDIUM_ERROR:

                    ScsiDebugPrint(1,"InterpretSenseInfo: Bad media\n");
                    *Status = EIO;

                    retry = TRUE;

                    break;

                case SCSI_SENSE_HARDWARE_ERROR:

                    ScsiDebugPrint(1,"InterpretSenseInfo: Hardware error\n");
                    *Status = EIO;

                    retry = TRUE;

                    break;

                case SCSI_SENSE_ILLEGAL_REQUEST:

                    ScsiDebugPrint(1,"InterpretSenseInfo: Illegal SCSI request\n");

                    switch (SenseBuffer->AdditionalSenseCode) {

                        case SCSI_ADSENSE_ILLEGAL_COMMAND:
                            ScsiDebugPrint(1,"InterpretSenseInfo: Illegal command\n");
                            break;

                        case SCSI_ADSENSE_ILLEGAL_BLOCK:
                            ScsiDebugPrint(1,"InterpretSenseInfo: Illegal block address\n");
                            break;

                        case SCSI_ADSENSE_INVALID_LUN:
                            ScsiDebugPrint(1,"InterpretSenseInfo: Invalid LUN\n");
                            break;

                        case SCSI_ADSENSE_MUSIC_AREA:
                            ScsiDebugPrint(1,"InterpretSenseInfo: Music area\n");
                            break;

                        case SCSI_ADSENSE_DATA_AREA:
                            ScsiDebugPrint(1,"InterpretSenseInfo: Data area\n");
                            break;

                        case SCSI_ADSENSE_VOLUME_OVERFLOW:
                            ScsiDebugPrint(1,"InterpretSenseInfo: Volume overflow\n");

                    } // end switch ...

                    *Status = EINVAL;

                    retry = FALSE;

                    break;

                case SCSI_SENSE_UNIT_ATTENTION:

                    ScsiDebugPrint(3,"InterpretSenseInfo: Unit attention\n");

                    switch (SenseBuffer->AdditionalSenseCode) {

                        case SCSI_ADSENSE_MEDIUM_CHANGED:
                            ScsiDebugPrint(1,"InterpretSenseInfo: Media changed\n");
                            break;

                        case SCSI_ADSENSE_BUS_RESET:
                            ScsiDebugPrint(1,"InterpretSenseInfo: Bus reset\n");

                    }

                    *Status = EAGAIN;

                    retry = TRUE;

                    break;

                case SCSI_SENSE_ABORTED_COMMAND:

                    ScsiDebugPrint(1,"InterpretSenseInfo: Command aborted\n");

                    *Status = EIO;

                    retry = TRUE;

                    break;

                case SCSI_SENSE_NO_SENSE:

                    ScsiDebugPrint(1,"InterpretSenseInfo: No specific sense key\n");

                    *Status = EIO;

                    retry = TRUE;

                    break;

                default:

                    ScsiDebugPrint(1,"InterpretSenseInfo: Unrecognized sense code\n");

                    *Status = (ARC_STATUS)STATUS_UNSUCCESSFUL;

                    retry = TRUE;

        } // end switch

    } else {

        //
        // Request sense buffer not valid. No sense information
        // to pinpoint the error. Return general request fail.
        //

        ScsiDebugPrint(1,"InterpretSenseInfo: Request sense info not valid\n");

        *Status = EIO;

        retry = TRUE;
    }

    //
    // If this is the primary srb, then reinitialize any bad scsi devices.
    //

    if (Srb == &PrimarySrb.Srb) {

        ScsiDiskFilterBad(PartitionContext);
    }

    return retry;

} // end InterpretSenseInfo()


VOID
RetryRequest(
    PPARTITION_CONTEXT PartitionContext,
    PIRP Irp
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PIO_STACK_LOCATION NextIrpStack = IoGetNextIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK Srb = &PrimarySrb.Srb;
    PMDL Mdl = Irp->MdlAddress;
    ULONG TransferByteCount = Mdl->ByteCount;


    //
    // Reset byte count of transfer in SRB Extension.
    //

    Srb->DataTransferLength = TransferByteCount;

    //
    // Zero SRB statuses.
    //

    Srb->SrbStatus = Srb->ScsiStatus = 0;

    //
    // Set up major SCSI function.
    //

    NextIrpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Save SRB address in next stack for port driver.
    //

    NextIrpStack->Parameters.Others.Argument1 = (PVOID)Srb;

    //
    // Return the results of the call to the port driver.
    //

    (PVOID)IoCallDriver(PartitionContext->PortDeviceObject, Irp);

    return;

} // end RetryRequest()

PIRP
BuildRequest(
    IN PPARTITION_CONTEXT PartitionContext,
    IN PMDL Mdl,
    IN ULONG LogicalBlockAddress,
    IN BOOLEAN Operation
    )

/*++

Routine Description:

Arguments:

Note:

If the IRP is for a disk transfer, the byteoffset field
will already have been adjusted to make it relative to
the beginning of the disk. In this way, this routine can
be shared between the disk and cdrom class drivers.

    - Operation  TRUE specifies that this is a READ operation
                 FALSE specifies that this is a WRITE operation

Return Value:

--*/

{
    PIRP Irp = &PrimarySrb.Irp;
    PIO_STACK_LOCATION NextIrpStack;
    PSCSI_REQUEST_BLOCK Srb = &PrimarySrb.Srb;
    PCDB Cdb;
    USHORT TransferBlocks;

    //
    // Initialize the rest of the IRP.
    //

    Irp->MdlAddress = Mdl;

    Irp->Tail.Overlay.CurrentStackLocation = &PrimarySrb.IrpStack[IRP_STACK_SIZE];

    NextIrpStack = IoGetNextIrpStackLocation(Irp);

    //
    // Write length to SRB.
    //

    Srb->Length = SCSI_REQUEST_BLOCK_SIZE;

    //
    // Set up IRP Address.
    //

    Srb->OriginalRequest = Irp;

    Srb->NextSrb = 0;

    //
    // Set up target id and logical unit number.
    //

    Srb->PathId = PartitionContext->PathId;
    Srb->TargetId = PartitionContext->TargetId;
    Srb->Lun = PartitionContext->DiskId;

    Srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    Srb->DataBuffer = MmGetMdlVirtualAddress(Mdl);

    //
    // Save byte count of transfer in SRB Extension.
    //

    Srb->DataTransferLength = Mdl->ByteCount;

    //
    // Indicate auto request sense by specifying buffer and size.
    //

    Srb->SenseInfoBuffer = SenseInfoBuffer;

    Srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    //
    // Set timeout value in seconds.
    //

    Srb->TimeOutValue = SCSI_DISK_TIMEOUT;

    //
    // Zero statuses.
    //

    Srb->SrbStatus = Srb->ScsiStatus = 0;

    //
    // Indicate that 10-byte CDB's will be used.
    //

    Srb->CdbLength = 10;

    //
    // Fill in CDB fields.
    //

    Cdb = (PCDB)Srb->Cdb;

    Cdb->CDB10.LogicalUnitNumber = PartitionContext->DiskId;

    TransferBlocks = (USHORT)(Mdl->ByteCount >> PartitionContext->SectorShift);

    //
    // Move little endian values into CDB in big endian format.
    //

    Cdb->CDB10.LogicalBlockByte0 = ((PFOUR_BYTE)&LogicalBlockAddress)->Byte3;
    Cdb->CDB10.LogicalBlockByte1 = ((PFOUR_BYTE)&LogicalBlockAddress)->Byte2;
    Cdb->CDB10.LogicalBlockByte2 = ((PFOUR_BYTE)&LogicalBlockAddress)->Byte1;
    Cdb->CDB10.LogicalBlockByte3 = ((PFOUR_BYTE)&LogicalBlockAddress)->Byte0;

    Cdb->CDB10.Reserved2 = 0;

    Cdb->CDB10.TransferBlocksMsb = ((PFOUR_BYTE)&TransferBlocks)->Byte1;
    Cdb->CDB10.TransferBlocksLsb = ((PFOUR_BYTE)&TransferBlocks)->Byte0;

    Cdb->CDB10.Control = 0;

    //
    // Set transfer direction flag and Cdb command.
    //

    if (Operation) {
        ScsiDebugPrint(3, "BuildRequest: Read Command\n");

        Srb->SrbFlags = SRB_FLAGS_DATA_IN;

        Cdb->CDB10.OperationCode = SCSIOP_READ;
    } else {
        ScsiDebugPrint(3, "BuildRequest: Write Command\n");

        Srb->SrbFlags = SRB_FLAGS_DATA_OUT;

        Cdb->CDB10.OperationCode = SCSIOP_WRITE;
    }

    //
    // Disable synchronous transfers.
    //

    Srb->SrbFlags |= SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Set up major SCSI function.
    //

    NextIrpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Save SRB address in next stack for port driver.
    //

    NextIrpStack->Parameters.Others.Argument1 = (PVOID)Srb;

    return(Irp);

} // end BuildRequest()

VOID
ScsiDiskStartUnit(
    IN PPARTITION_CONTEXT PartitionContext
    )

/*++

Routine Description:

    Send command to SCSI unit to start or power up.
    Because this command is issued asynchronounsly, that is without
    waiting on it to complete, the IMMEDIATE flag is not set. This
    means that the CDB will not return until the drive has powered up.
    This should keep subsequent requests from being submitted to the
    device before it has completely spun up.
    This routine is called from the InterpretSense routine, when a
    request sense returns data indicating that a drive must be
    powered up.

Arguments:

    PartitionContext - structure containing pointer to port device driver.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION irpStack;
    PIRP irp;
    PSCSI_REQUEST_BLOCK srb = &AbortSrb.Srb;
    PSCSI_REQUEST_BLOCK originalSrb = &PrimarySrb.Srb;
    PCDB cdb;

    ScsiDebugPrint(1,"StartUnit: Enter routine\n");

    //
    // Write length to SRB.
    //

    srb->Length = SCSI_REQUEST_BLOCK_SIZE;

    //
    // Set up SCSI bus address.
    //

    srb->PathId = originalSrb->PathId;
    srb->TargetId = originalSrb->TargetId;
    srb->Lun = originalSrb->Lun;

    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    //
    // Zero out status.
    //

    srb->ScsiStatus = srb->SrbStatus = 0;

    //
    // Set timeout value large enough for drive to spin up.
    // NOTE: This value is arbitrary.
    //

    srb->TimeOutValue = 30;

    //
    // Set the transfer length.
    //

    srb->DataTransferLength = 0;
    srb->SrbFlags = SRB_FLAGS_NO_DATA_TRANSFER | SRB_FLAGS_DISABLE_AUTOSENSE;
    srb->SenseInfoBufferLength = 0;
    srb->SenseInfoBuffer = NULL;

    //
    // Build the start unit CDB.
    //

    srb->CdbLength = 6;
    cdb = (PCDB)srb->Cdb;

    RtlZeroMemory(cdb, sizeof(CDB));

    cdb->CDB10.OperationCode = SCSIOP_START_STOP_UNIT;
    cdb->START_STOP.Start = 1;

    //
    // Build the IRP
    // to be sent to the port driver.
    //

    irp = InitializeIrp(
        &AbortSrb,
        IRP_MJ_SCSI,
        PartitionContext->PortDeviceObject,
        NULL,
        0
        );

    irpStack = IoGetNextIrpStackLocation(irp);

    irpStack->MajorFunction = IRP_MJ_SCSI;

    srb->OriginalRequest = irp;

    //
    // Save SRB address in next stack for port driver.
    //

    irpStack->Parameters.Others.Argument1 = srb;

    //
    // No need to check the following 2 returned statuses as
    // SRB will have ending status.
    //

    IoCallDriver(PartitionContext->PortDeviceObject, irp);

} // end StartUnit()


ULONG
ClassModeSense(
    IN PPARTITION_CONTEXT Context,
    IN PCHAR ModeSenseBuffer,
    IN ULONG Length,
    IN UCHAR PageMode
    )

/*++

Routine Description:

    This routine sends a mode sense command to a target id and returns
    when it is complete.

Arguments:

Return Value:

    Length of the transferred data is returned.

--*/
{
    PCDB cdb;
    PSCSI_REQUEST_BLOCK Srb = &PrimarySrb.Srb;
    ULONG retries = 1;
    NTSTATUS status;

    DebugPrint((3,"SCSI ModeSense: Enter routine\n"));

    //
    // Build the read capacity CDB.
    //

    Srb->CdbLength = 6;
    cdb = (PCDB)Srb->Cdb;

    //
    // Set timeout value.
    //

    Srb->TimeOutValue = 2;

    RtlZeroMemory(cdb, MAXIMUM_CDB_SIZE);

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = PageMode;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)Length;

Retry:

    status = SendSrbSynchronous(Context,
                                Srb,
                                ModeSenseBuffer,
                                Length,
                                FALSE);


    if (status == EAGAIN || status == EBUSY) {

        //
        // Routine SendSrbSynchronous does not retry
        // requests returned with this status.
        // Read Capacities should be retried
        // anyway.
        //

        if (retries--) {

            //
            // Retry request.
            //

            goto Retry;
        }
    } else if (SRB_STATUS(Srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) {
        status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(status)) {
        return(Srb->DataTransferLength);
    } else {
        return(0);
    }

} // end ClassModeSense()

PVOID
ClassFindModePage(
    IN PCHAR ModeSenseBuffer,
    IN ULONG Length,
    IN UCHAR PageMode
    )

/*++

Routine Description:

    This routine scans through the mode sense data and finds the requested
    mode sense page code.

Arguments:
    ModeSenseBuffer - Supplies a pointer to the mode sense data.

    Length - Indicates the length of valid data.

    PageMode - Supplies the page mode to be searched for.

Return Value:

    A pointer to the the requested mode page.  If the mode page was not found
    then NULL is return.

--*/
{
    PCHAR limit;

    limit = ModeSenseBuffer + Length;

    //
    // Skip the mode select header and block descriptors.
    //

    if (Length < sizeof(MODE_PARAMETER_HEADER)) {
        return(NULL);
    }

    ModeSenseBuffer += sizeof(MODE_PARAMETER_HEADER) +
        ((PMODE_PARAMETER_HEADER) ModeSenseBuffer)->BlockDescriptorLength;

    //
    // ModeSenseBuffer now points at pages walk the pages looking for the
    // requested page until the limit is reached.
    //

    while (ModeSenseBuffer < limit) {

        if (((PMODE_DISCONNECT_PAGE) ModeSenseBuffer)->PageCode == PageMode) {
            return(ModeSenseBuffer);
        }

        //
        // Adavance to the next page.
        //

        ModeSenseBuffer += ((PMODE_DISCONNECT_PAGE) ModeSenseBuffer)->PageLength + 2;
    }

    return(NULL);

}

BOOLEAN
IsFloppyDevice(
    PPARTITION_CONTEXT Context
    )
/*++

Routine Description:

    The routine performs the necessary functioons to determinee if a device is
    really a floppy rather than a harddisk.  This is done by a mode sense
    command.  First, a check is made to see if the medimum type is set.  Second
    a check is made for the flexible parameters mode page.

Arguments:

    Context - Supplies the device object to be tested.

Return Value:

    Return TRUE if the indicated device is a floppy.

--*/
{

    PVOID modeData;
    PUCHAR pageData;
    ULONG length;

    modeData = ExAllocatePool(NonPagedPoolCacheAligned, MODE_DATA_SIZE);

    if (modeData == NULL) {
        return(FALSE);
    }

    RtlZeroMemory(modeData, MODE_DATA_SIZE);

    length = ClassModeSense(Context,
                            modeData,
                            MODE_DATA_SIZE,
                            MODE_SENSE_RETURN_ALL);

    if (length < sizeof(MODE_PARAMETER_HEADER)) {

        //
        // Retry the request in case of a check condition.
        //

        length = ClassModeSense(Context,
                                modeData,
                                MODE_DATA_SIZE,
                                MODE_SENSE_RETURN_ALL);

        if (length < sizeof(MODE_PARAMETER_HEADER)) {

            ExFreePool(modeData);
            return(FALSE);

        }
    }
#if 0
    if (((PMODE_PARAMETER_HEADER) modeData)->MediumType >= MODE_FD_SINGLE_SIDE
        && ((PMODE_PARAMETER_HEADER) modeData)->MediumType <= MODE_FD_MAXIMUM_TYPE) {

        DebugPrint((1, "Scsidisk: MediumType value %2x, This is a floppy.\n", ((PMODE_PARAMETER_HEADER) modeData)->MediumType));
        ExFreePool(modeData);
        return(TRUE);
    }
#endif

    //
    // Look for the flexible disk mode page.
    //

    pageData = ClassFindModePage( modeData, length, MODE_PAGE_FLEXIBILE);

    if (pageData != NULL) {

        DebugPrint((1, "Scsidisk: Flexible disk page found, This is a floppy.\n"));
        ExFreePool(modeData);
        return(TRUE);

    }

    ExFreePool(modeData);
    return(FALSE);

} // end IsFloppyDevice()

VOID
ScsiDiskFilterBad(
    IN PPARTITION_CONTEXT PartitionContext
    )

/*++

Routine Description:

    This routine looks for SCSI units which need special initialization
    to operate correctly.

Arguments:

    PartitionContext - structure containing pointer to port device driver.

Return Value:

    None.

--*/
{
    PSCSI_REQUEST_BLOCK srb = &AbortSrb.Srb;
    PCDB cdb;
    PDEVICE_EXTENSION scsiPort;
    PSCSI_CONFIGURATION_INFO configInfo;
    PSCSI_BUS_SCAN_DATA busScanData;
    PUCHAR modePage;
    ULONG busNumber;
    PLUNINFO lunInfo;
    PINQUIRYDATA inquiryData;

    ScsiDebugPrint(3,"FilterBad: Enter routine\n");

    scsiPort = PartitionContext->PortDeviceObject->DeviceExtension;
    configInfo = scsiPort->ScsiInfo;

    //
    // Search the configuration database for scsi disk and cdrom devices
    // which require special initializaion.
    //

    for (busNumber=0; busNumber < (ULONG)configInfo->NumberOfBuses; busNumber++) {

        busScanData = configInfo->BusScanData[busNumber];

        //
        // Set LunInfo to beginning of list.
        //

        lunInfo = busScanData->LunInfoList;

        while (lunInfo != NULL) {

            inquiryData = (PVOID)lunInfo->InquiryData;

            //
            // Determin if this is the correct lun.
            //

            if (PartitionContext->PathId == lunInfo->PathId &&
                PartitionContext->TargetId == lunInfo->TargetId &&
                PartitionContext->DiskId == lunInfo->Lun) {

                goto FoundOne;
            }

            //
            // Get next LunInfo.
            //

            lunInfo = lunInfo->NextLunInfo;
        }
    }

    return;

FoundOne:



    //
    // Zero out status.
    //

    srb->ScsiStatus = srb->SrbStatus = 0;

    //
    // Set timeout value.
    //

    srb->TimeOutValue = 2;

    //
    // Look for a bad devices.
    //

    if (strncmp((PCHAR)inquiryData->VendorId, "HITACHI CDR-1750S", strlen("HITACHI CDR-1750S")) == 0 ||
        strncmp((PCHAR)inquiryData->VendorId, "HITACHI CDR-3650/1650S", strlen("HITACHI CDR-3650/1650S")) == 0) {

        ScsiDebugPrint(1, "ScsiDiskFilterBad:  Found Hitachi CDR-1750S.\n");

        //
        // Found a bad HITACHI cd-rom.  These devices do not work with PIO
        // adapters when read-ahead is enabled.  Read-ahead is disabled by
        // a mode select command.  The mode select page code is zero and the
        // length is 6 bytes.  All of the other bytes should be zero.
        //

        modePage = ExAllocatePool(NonPagedPool, HITACHI_MODE_DATA_SIZE);

        if (modePage == NULL) {
            return;
        }

        RtlZeroMemory(modePage, HITACHI_MODE_DATA_SIZE);

        //
        // Set the page length field to 6.
        //

        modePage[5] = 6;

        //
        // Build the mode select CDB.
        //

        srb->CdbLength = 6;
        cdb = (PCDB)srb->Cdb;

        RtlZeroMemory(cdb, sizeof(CDB));

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.ParameterListLength = HITACHI_MODE_DATA_SIZE;

        //
        // Send the request to the device.
        //

        SendSrbSynchronous(PartitionContext,
                           srb,
                           modePage,
                           HITACHI_MODE_DATA_SIZE,
                           TRUE);

        ExFreePool(modePage);
    }

} // end ScsiDiskFilterBad()

BOOLEAN
CheckFileId(
    ULONG FileId
    )
{

    if (BlFileTable[FileId].u.PartitionContext.PortDeviceObject != NULL) {
        return TRUE;
    }

#if 0
    DbgPrint("\n\rScsidisk: Bad file id passed to read or write.  FileId = %lx\n", FileId);
    DbgPrint("Start sector = %lx; Ending sector = %lx; Disk Id = %x; DeviceUnit = %x\n",
        BlFileTable[FileId].u.PartitionContext.StartingSector,
        BlFileTable[FileId].u.PartitionContext.EndingSector,
        BlFileTable[FileId].u.PartitionContext.DiskId,
        BlFileTable[FileId].u.PartitionContext.DeviceUnit
        );

   DbgPrint("Target Id = %d; Path Id = %d; Sector Shift = %lx; Size = %lx\n",
        BlFileTable[FileId].u.PartitionContext.TargetId,
        BlFileTable[FileId].u.PartitionContext.PathId,
        BlFileTable[FileId].u.PartitionContext.SectorShift,
        BlFileTable[FileId].u.PartitionContext.Size
        );

   DbgPrint("Hit any key\n");
   while(!GET_KEY());  // DEBUG ONLY!
#endif
   return FALSE;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\vga.c ===
//
// vga routines
//

#include "bldr.h"
#include "vga.h"
#include "cmdcnst.h"

PUCHAR VgaBase = (PUCHAR)0xa0000;
PUCHAR VgaRegisterBase = (PUCHAR)0;

//
// globals to track screen position
//

#define DELTA 80L

BOOLEAN
VgaInterpretCmdStream(
    PUSHORT pusCmdStream
    );

UCHAR lMaskTable[8] = {0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01};
UCHAR rMaskTable[8] = {0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff};
UCHAR PixelMask[8]  = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};

//
// Initialize AT registers
//

USHORT AT_Initialization[] = {

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    16,                             // count
    0,                              // start index
    0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    EOD

};

ULONG lookup[16] =
{
    0x00000000,
    0x00000100,
    0x00001000,
    0x00001100,
    0x00000001,
    0x00000101,
    0x00001001,
    0x00001101,
    0x00000010,
    0x00000110,
    0x00001010,
    0x00001110,
    0x00000011,
    0x00000111,
    0x00001011,
    0x00001111
};

void __outpw(int p, int v)
{
    WRITE_PORT_USHORT((PUSHORT)(p+VgaRegisterBase), (USHORT)v);
}

void __outpb(int p, int v)
{
    WRITE_PORT_UCHAR((PUCHAR)(p+VgaRegisterBase), (UCHAR)v);
}

VOID
ReadWriteMode(
    ULONG mode
    )
{
    UCHAR value;

    WRITE_PORT_UCHAR((PUCHAR)(VgaRegisterBase+0x3ce), 5);
    value = READ_PORT_UCHAR((PUCHAR)(VgaRegisterBase+0x3cf));

    value &= 0xf4;
    value |= mode;

    WRITE_PORT_UCHAR((PUCHAR)(VgaRegisterBase+0x3cf), value);
}

VOID
SetPixel(
    ULONG x,
    ULONG y,
    ULONG color
    )
{
    PUCHAR pDst;
    ULONG  bank;

    bank = x >> 3;

    pDst = (PUCHAR)(VgaBase + y * DELTA + bank);

    ReadWriteMode(0x8 | 0x2);
    __outpw(0x3c4, 0x0f02); // enable all write planes
    __outpw(0x3ce, 0x0007); // set color don't care register to zero
    __outpw(0x3ce, (PixelMask[x & 0x7] << 8) | 8);

    WRITE_REGISTER_UCHAR(pDst, (UCHAR)(READ_REGISTER_UCHAR(pDst) & ((UCHAR)color)));
}

VOID
VidSolidColorFill(
    ULONG x1,
    ULONG y1,
    ULONG x2,
    ULONG y2,
    ULONG color
    )
{
    PUCHAR pDst;
    ULONG x, y;
    ULONG bank1, bank2, count;
    ULONG lMask, rMask;

    lMask = (lMaskTable[x1 & 0x7] << 8) | 8;
    rMask = (rMaskTable[x2 & 0x7] << 8) | 8;

    bank1 = x1 >> 3;
    bank2 = x2 >> 3;
    count = bank2 - bank1;

    if (!count) {
        lMask = lMask & rMask;
    }

    ReadWriteMode(0x8 | 0x2);

    __outpw(0x3c4, 0x0f02); // enable writing to all color planes
    __outpw(0x3ce, 0x0007); // set color don't care register to zero

    //
    // Do the left edge
    //

    pDst = (PUCHAR)(VgaBase + y1 * DELTA + bank1);

    __outpw(0x3ce, lMask);

    for (y=y1; y<=y2; y++) {

	WRITE_REGISTER_UCHAR(pDst, (UCHAR)(READ_REGISTER_UCHAR(pDst) & (UCHAR) color));
        pDst += DELTA;
    }

    if (count) {

        //
        // Do the right edge
        //

        pDst = (PUCHAR)(VgaBase + y1 * DELTA + bank2);
        count--;
        __outpw(0x3ce, rMask);

        for (y=y1; y<=y2; y++) {
	    WRITE_REGISTER_UCHAR(pDst, (UCHAR)(READ_REGISTER_UCHAR(pDst) & (UCHAR) color));
            pDst += DELTA;
        }

        //
        // Do the center section
        //

        if (count) {

            pDst = (PUCHAR)(VgaBase + y1 * DELTA + bank1 + 1);
            __outpw(0x3ce, 0xff08);

            for (y=y1; y<=y2; y++) {

                for (x=0; x<count; x++) {
		    WRITE_REGISTER_UCHAR(pDst++,  (unsigned char) color);
                }
                pDst += DELTA - count;
            }

        }
    }
}

VOID
RleBitBlt(
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    PUCHAR Buffer
    )

/*++

Routine Description:

    This routine displays an RLE 4 bitmap.

Arguments:

    x, y - location at which to display the bitmap.

    width, height - height of the bitmap

    Buffer - Pointer to the compressed bitmap data.

--*/

{
    BOOLEAN Done = FALSE;
    PUCHAR p = Buffer;
    ULONG RunLength;
    LONG RunExtra;
    ULONG curr_x, curr_y;
    ULONG Color1, Color2;

    curr_x = x;
    curr_y = y + height - 1;

    while (!Done) {

        if (*p) {

            RunLength = (ULONG) *p++;

            //
            // Make sure we don't draw past end of scan.
            //

            if ((curr_x + RunLength) > (x + width))
                RunLength -= (curr_x + RunLength) - (width + x);

            Color1 = (*p   & 0xf0) >> 4;
            Color2 = (*p++ & 0x0f);

            if (Color1 == Color2) {

                ULONG end_x = curr_x + RunLength - 1;

                VidSolidColorFill(curr_x,
                                  curr_y,
                                  end_x,
                                  curr_y,
                                  Color1);

                curr_x += RunLength;

            } else {

                while (RunLength > 1) {
                    SetPixel(curr_x++, curr_y, Color1);
                    SetPixel(curr_x++, curr_y, Color2);
                    RunLength -= 2;
                }

                if (RunLength) {
                    SetPixel(curr_x, curr_y, Color1);
                    curr_x++;
                }
            }

        } else {

            p++;

            switch (*p) {

            case 0:  curr_x = x;
                     curr_y--;
                     p++;
                     break;

            case 1:  Done = TRUE;
                     p++;
                     break;

            case 2:  p++;
                     curr_x += (ULONG) *p++;
                     curr_y -= (ULONG) *p++;
                     break;

            default: RunLength = (ULONG) *p++;

                     //
                     // Make sure we don't draw past end of scan.
                     //

                     if ((curr_x + RunLength) > (x + width)) {
                         RunExtra = (curr_x + RunLength) - (width + x);
                         RunLength -= RunExtra;
                     } else {
                         RunExtra = 0;
                     }

                     while (RunLength > 1) {

                         Color1 = (*p   & 0xf0) >> 4;
                         Color2 = (*p++ & 0x0f);

                         SetPixel(curr_x++, curr_y, Color1);
                         SetPixel(curr_x++, curr_y, Color2);

                         RunLength -= 2;
                     }

                     if (RunLength) {
                         Color1 = (*p++ & 0xf0) >> 4;
                         SetPixel(curr_x++, curr_y, Color1);
                         RunExtra--;
                     }

                     //
                     // Read any remaining "extra" run data.
                     //

                     while (RunExtra > 0) {
                         p++;
                         RunExtra -= 2;
                     }

                     if ((ULONG_PTR)p & 1) p++;  // make sure we are word aligned

                     break;
            }
        }
    }
}

VOID
BitBlt(
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    PUCHAR Buffer,
    ULONG bpp,
    LONG ScanWidth
    )
{
    ULONG i, j;
    ULONG color=8;

    if (bpp == 4) {

        UCHAR Plane[81];
        ULONG lMask, rMask, count;
        ULONG bank1, bank2, bank;
        ULONG bRightEdge = FALSE, bCenterSection = FALSE;
        UCHAR value;
        ULONG plane;
        UCHAR Mask;
        ULONG toggle;
        PUCHAR pSrc, pSrcTemp;
        PUCHAR pDst, pDstTemp;
        UCHAR PlaneMask;

        lMask = lMaskTable[x & 0x7];
        rMask = rMaskTable[(x + width - 1) & 0x7];

        bank1 = x >> 3;
        bank2 = (x + width - 1) >> 3;

        count = bank2 - bank1;

        if (bank1 == bank2) {

            lMask = lMask & rMask;

        }

        if (count) {

            bRightEdge = TRUE;

            count--;

            if (count) {

                bCenterSection = TRUE;
            }
        }

        pDst = (PUCHAR)(VgaBase + (y * DELTA) + (x / 8));
        pSrc = Buffer;

        ReadWriteMode(0x0 | 0x0);

        for (j=0; j<height; j++) {

            for (plane=0; plane<4; plane++) {

                pSrcTemp = pSrc;
                pDstTemp = pDst;

                PlaneMask = (UCHAR) (1 << plane);

                //
                // Convert the packed bitmap data into planar data
                // for this plane.
                //
                // BUGBUG: My guess this is going to be a hot spot, so
                // I need to revist this and optimize!!  But for now
                // make it work.
                //

                bank = bank1;
                Plane[bank] = 0;
                Mask = PixelMask[x & 0x7];
                toggle = 0;

                for (i=0; i<width; i++) {

                    if (toggle++ & 0x1) {

                        if (*pSrcTemp & PlaneMask) {
                            Plane[bank] |= Mask;
                        }

                        pSrcTemp++;

                    } else {

                        if (((*pSrcTemp) >> 4) & PlaneMask) {
                            Plane[bank] |= Mask;
                        }
                    }

                    Mask >>= 1;

                    if (!Mask) {

                        bank++;
                        Plane[bank] = 0;
                        Mask = 0x80;
                    }
                }

                //
                // Set up the vga so that we see the correct bit plane.
                //

                __outpw(0x3c4, (1 << (plane + 8)) | 2);

                //
                // bank will go from bank1 to bank2
                //

                bank = bank1;
                pDstTemp = pDst;


                //
                // Set Bitmask for left edge.
                //

                __outpw(0x3ce, (lMask << 8) | 8);

		value = READ_REGISTER_UCHAR(pDstTemp);

                value &= ~lMask;
                value |= Plane[bank++];

		WRITE_REGISTER_UCHAR(pDstTemp++, value);

                if (bCenterSection) {

                    __outpw(0x3ce, 0xff08);  // enable writing to all bits

                    for (i=0; i<count; i++) {

			WRITE_REGISTER_UCHAR(pDstTemp++, Plane[bank++]);
                    }
                }

                if (bRightEdge) {

                    //
                    // Set bitmask for right edge.
                    //

                    __outpw(0x3ce, (rMask << 8) | 8);

		    value = READ_REGISTER_UCHAR(pDstTemp);

                    value &= ~rMask;
                    value |= Plane[bank];

		    WRITE_REGISTER_UCHAR(pDstTemp, value);
                }
            }

            pDst += DELTA;
            pSrc += ScanWidth;
        }

    } else {

        PUCHAR pDst, pDstTemp;
        PUCHAR pSrc, pSrcTemp;
        ULONG count;
        UCHAR Value;
        ULONG lMask, rMask;
        ULONG bank1, bank2;
        ULONG plane;
        UCHAR colorMask;

        bank1 = x >> 8;
        bank2 = (x + width - 1) >> 8;

        lMask = lMaskTable[x & 7];
        rMask = rMaskTable[(x + width - 1) & 7];

        if (bank1 == bank2) {

            lMask &= rMask;
        }

        lMask = ~lMask;
        rMask = ~rMask;

        pSrc = Buffer;
        pDst = (PUCHAR)(VgaBase + (y * DELTA) + (x / 8));

        ReadWriteMode(0x0 | 0x0);

        for (j=0; j<height; j++) {

            plane = 1;
            for (i=0; i<4; i++) {

                pDstTemp = pDst;
                pSrcTemp = pSrc;

                __outpw(0x3c4, (plane << 8) | 2);

                colorMask = (UCHAR)((color & plane) ? 0xff : 0x00);

                plane <<= 1;  // bump up each time through loop

                count = width;

                //
                // non aligned case
                //

                if (x & 7) {

                    //
                    // Left Edge.
                    //

		    Value = READ_REGISTER_UCHAR(pDstTemp);

                    Value &= lMask;
                    Value |= (*pSrcTemp >> x) & colorMask;

		    WRITE_REGISTER_UCHAR(pDstTemp++, Value);

                    count -= (8 - x);

                    //
                    // Now do center section
                    //

                    while (count > 7) {

                        Value = (UCHAR) ((*pSrcTemp << (8 - x)) | (*(pSrcTemp+1) >> x));
                        Value &= colorMask;

			WRITE_REGISTER_UCHAR(pDstTemp++, Value);

                        pSrcTemp++;
                        count -= 8;
                    }

                    //
                    // Now do the right edge.
                    //

                    if (count) {

			Value = READ_REGISTER_UCHAR(pDstTemp);

                        Value &= rMask;
                        Value |= *pSrcTemp << (8 - x) & colorMask;

			WRITE_REGISTER_UCHAR(pDstTemp++, Value);
                    }

                } else {

                    //
                    // Aligned case.
                    //

                    ULONG  ulColorMask = colorMask ? 0xffffffff : 0x00000000;
                    USHORT usColorMask = colorMask ? 0xffff : 0x0000;

                    while (count > 31) {

			WRITE_REGISTER_ULONG((PULONG)pDstTemp, (ULONG)(*((PULONG)pSrcTemp) & ulColorMask));
                        count -= 32;
                        pDstTemp += sizeof(ULONG)/sizeof(UCHAR);
                        pSrcTemp += sizeof(ULONG)/sizeof(UCHAR);
                    }

                    while (count > 15) {

			WRITE_REGISTER_USHORT((PUSHORT)pDstTemp, (USHORT)(*((PUSHORT)pSrcTemp) & usColorMask));
                        count -= 16;
                        pDstTemp += sizeof(USHORT)/sizeof(UCHAR);
                        pSrcTemp += sizeof(USHORT)/sizeof(UCHAR);
                    }

                    if (count > 7) {

			WRITE_REGISTER_UCHAR(pDstTemp++, (UCHAR)(*pSrcTemp++ & colorMask));
                        count -= 8;
                    }

                    //
                    // Now do any remaining bits.
                    //

                    if (count) {

			Value = READ_REGISTER_UCHAR(pDstTemp);

                        Value &= rMask;
                        Value |= *pSrcTemp & colorMask;

			WRITE_REGISTER_UCHAR(pDstTemp++, Value);
                    }
                }
            }

            pSrc += ScanWidth;
            pDst += DELTA;
        }
    }
}

VOID
VidBitBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y
    )

/*++

Routine Description:

    This routine takes a bitmap resource and displays it at a given
    location.

Arguments:

    Buffer - Pointer to the bitmap resource.

    x, y - The position at which to display the bitmap.

--*/

{
    PBITMAPINFOHEADER bih;
    PRGBQUAD          Palette;

    LONG lDelta;
    PUCHAR pBuffer;
    LONG cbScanLine;

    bih = (PBITMAPINFOHEADER) Buffer;

    Palette = (PRGBQUAD)(((PUCHAR)bih) + bih->biSize);

    //
    // BUGBUG: I need to add some bitmap validation code here!
    //

    cbScanLine = (((bih->biWidth * bih->biBitCount) + 31) & ~31) >> 3;

    pBuffer = (PUCHAR)(Buffer + sizeof(BITMAPINFOHEADER) + 64);

    if (bih->biCompression == BI_RLE4) {

        if (bih->biWidth && bih->biHeight) {
            RleBitBlt(x,
                      y,
                      bih->biWidth,
                      bih->biHeight,
                      pBuffer);
        }

    } else {

        if (bih->biHeight < 0) {

            // top down bitmap
            lDelta = cbScanLine;
            bih->biHeight = -bih->biHeight;

        } else {

            // bottom up bitmap
            pBuffer += cbScanLine * (bih->biHeight - 1);
            lDelta = -cbScanLine;
        }

        if (bih->biWidth && bih->biHeight) {
            BitBlt(x,
                   y,
                   bih->biWidth,
                   bih->biHeight,
                   pBuffer,
                   bih->biBitCount,
                   lDelta);
        }
    }

}

VOID
VidScreenToBufferBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    ULONG lDelta
    )

/*++

Routine Description:

    This routine allows you to copy a portion of video memory into
    system memory.

Arguments:

    Buffer - Points to system memory where the video image should be copied.

    x, y - X,Y coordinates in video memory of top-left portion of image.

    width, height - width and height of the image in pixels.

    lDelta - width of the buffer in bytes.

Notes:

    Upon completion, the video memory image will be in system memory.  Each
    plane of the image are stored seperately, so the first scan line of
    plane 0 will be followed by the first scan line of plane 1, etc.  Then
    the second scan of plane 0, plane 1, and so on.

--*/

{
    ULONG Plane, i, j, BankStart, BankEnd;
    PUCHAR pSrc, pSrcTemp, pDst;
    PULONG pulDstTemp;
    UCHAR Val1, Val2;
    ULONG Shift1, Shift2;
    UCHAR ucCombined;
    ULONG ulCombined;

    BankStart = x >> 3;
    BankEnd = (x + width - 1) >> 3;
    Shift1 = x & 7;
    Shift2 = 8 - Shift1;

    //
    // Zero initialize the buffer so we can or in the bits later!
    //

    pDst = Buffer;
    memset(pDst, 0, lDelta * height);

    for (Plane=0; Plane<4; Plane++) {

        pSrc = (PUCHAR)(VgaBase + (DELTA * y) + BankStart);
        pDst = Buffer;

        ReadWriteMode(0x0 | 0x0);            // set read mode 0
        __outpw(0x3ce, (Plane << 8) | 0x04); // read from given plane

        for (j=0; j<height; j++) {

            pSrcTemp = pSrc;
            pulDstTemp = (PULONG)pDst;

	    Val1 = READ_REGISTER_UCHAR(pSrcTemp++);

            for (i=BankStart; i<=BankEnd; i++) {

		Val2 = READ_REGISTER_UCHAR(pSrcTemp++);

                ucCombined = (UCHAR) ((Val1 << Shift1) | (Val2 >> Shift2));
                ulCombined = ((lookup[(ucCombined & 0x0f) >> 0] << 16) |
                               lookup[(ucCombined & 0xf0) >> 4]) << Plane;


                *pulDstTemp++ |= ulCombined;

                Val1 = Val2;
            }

            pSrc += DELTA;   // go to next video memory scan line
            pDst += lDelta;  // go to next scan for this plane in buffer
        }
    }
}

void VidBufferToScreenBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    ULONG lDelta
    )

/*++

Routine Description:

    This routine allows you to copy a portion of video memory into
    system memory.

Arguments:

    Buffer - Points to system memory where the video image should be copied
             from.

    x, y - X,Y coordinates in video memory of top-left portion of image.

    width, height - width and height of the image in pixels.

    lDelta - width of the buffer in bytes.

Notes:

    This routine will allow you to blt from a buffer filled by
    VidScreenToBufferBlt.

--*/

{
    if (width && height) {
        BitBlt(x,
               y,
               width,
               height,
               Buffer,
               4,
               lDelta);
    }
}


#pragma optimize( "", off )

VOID
SetPaletteEntryRGB(
    ULONG index,
    RGBQUAD rgb
    )
{
    __outpb(0x3c8, index);
    __outpb(0x3c9, rgb.rgbRed   >> 2);
    __outpb(0x3c9, rgb.rgbGreen >> 2);
    __outpb(0x3c9, rgb.rgbBlue  >> 2);
}

VOID
VgaEnableVideo()
{
	VgaInterpretCmdStream (AT_Initialization);
}

VOID
InitPaletteConversionTable()
{
	/*
	UCHAR n;

	READ_PORT_UCHAR((PUCHAR)(VgaRegisterBase+INPUT_STATUS_1_COLOR));

	for (n=0; n<16; n++) {	//	Initializing table of active palette entries.
		WRITE_PORT_UCHAR((PUCHAR)(VgaRegisterBase+ATT_ADDRESS_PORT), n);
		WRITE_PORT_UCHAR((PUCHAR)(VgaRegisterBase+ATT_ADDRESS_PORT), n);
	}
	*/
	VgaEnableVideo();
}

VOID
InitializePalette(
    VOID
    )
{
    ULONG Palette[] =
    {
        0x00000000,
        0x00000020,
        0x00002000,
        0x00002020,
        0x00200000,
        0x00200020,
        0x00202000,
        0x00202020,
        0x00303030,
        0x0000003f,
        0x00003f00,
        0x00003f3f,
        0x003f0000,
        0x003f003f,
        0x003f3f00,
        0x003f3f3f,
    };
    ULONG i;

    for (i=0; i<16; i++) {
		PRGBQUAD p = (PRGBQUAD)(Palette+i);
        SetPaletteEntryRGB(i, *p);
    }

}

VOID
InitPaletteWithTable(
    PRGBQUAD Palette,
    ULONG count
    )
{
    UCHAR i;
	InitPaletteConversionTable();
	count = 16;
    for (i=0; i<count; i++)
        SetPaletteEntryRGB (i, *Palette++);
}

VOID
InitPaletteWithBlack(
    VOID
    )
{
    ULONG i;
	// RGBQUAD black = {0x3f,0x3f,0x3f,0x3f};
	RGBQUAD black = {0,0,0,0};
	InitPaletteConversionTable();
	//InitializePalette();

    for (i=0; i<16; i++)
        SetPaletteEntryRGB(i, black);
}

VOID
WaitForVsync(
    VOID
    )

/*++

Routine Description:

    Wait for a v-sync

--*/

{
    //
    // Check to see if vsync's are being generated.
    //

    WRITE_PORT_UCHAR((VgaRegisterBase+0x3c4), 00);

    if (READ_PORT_UCHAR(VgaRegisterBase+0x3c5) & 0x2) {

        ULONG MaxDelay;

        //
        // Slight delay.  Wait for one vsync.
        //

        MaxDelay = 100000;
	while (((READ_PORT_UCHAR(VgaRegisterBase+0x3da) & 0x08) == 0x08) && MaxDelay--);
        MaxDelay = 100000;
	while (((READ_PORT_UCHAR(VgaRegisterBase+0x3da) & 0x08) == 0x00) && MaxDelay--);
    }
}

BOOLEAN
VgaInterpretCmdStream(
    PUSHORT pusCmdStream
    )

/*++

Routine Description:

    Interprets the appropriate command array to set up VGA registers for the
    requested mode. Typically used to set the VGA into a particular mode by
    programming all of the registers

Arguments:

    pusCmdStream - array of commands to be interpreted.

Return Value:

    The status of the operation (can only fail on a bad command); TRUE for
    success, FALSE for failure.

--*/

{
    ULONG ulCmd;
    ULONG_PTR ulPort;
    UCHAR jValue;
    USHORT usValue;
    ULONG culCount;
    ULONG ulIndex;
    ULONG_PTR ulBase;

    if (pusCmdStream == NULL) {

        //KdPrint(("VgaInterpretCmdStream: pusCmdStream == NULL\n"));
        return TRUE;
    }

    ulBase = (ULONG_PTR) VgaRegisterBase;

    //
    // Now set the adapter to the desired mode.
    //

    while ((ulCmd = *pusCmdStream++) != EOD) {

        WaitForVsync();

        //
        // Determine major command type
        //

        switch (ulCmd & 0xF0) {

            //
            // Basic input/output command
            //

            case INOUT:

                //
                // Determine type of inout instruction
                //

                if (!(ulCmd & IO)) {

                    //
                    // Out instruction. Single or multiple outs?
                    //

                    if (!(ulCmd & MULTI)) {

                        //
                        // Single out. Byte or word out?
                        //

                        if (!(ulCmd & BW)) {

                            //
                            // Single byte out
                            //

                            ulPort = *pusCmdStream++;
                            jValue = (UCHAR) *pusCmdStream++;
                            WRITE_PORT_UCHAR((PUCHAR)(ulBase+ulPort),
                                    jValue);

                        } else {

                            //
                            // Single word out
                            //

                            ulPort = *pusCmdStream++;
                            usValue = *pusCmdStream++;
                            WRITE_PORT_USHORT((PUSHORT)(ulBase+ulPort),
                                    usValue);

                        }

                    } else {

                        //
                        // Output a string of values
                        // Byte or word outs?
                        //

                        if (!(ulCmd & BW)) {

                            //
                            // String byte outs. Do in a loop; can't use
                            // VideoPortWritePortBufferUchar because the data
                            // is in USHORT form
                            //

                            ulPort = ulBase + *pusCmdStream++;
                            culCount = *pusCmdStream++;

                            while (culCount--) {
                                jValue = (UCHAR) *pusCmdStream++;
                                WRITE_PORT_UCHAR((PUCHAR)ulPort,
                                        jValue);

                            }

                        } else {

                            //
                            // String word outs
                            //

                            ulPort = *pusCmdStream++;
                            culCount = *pusCmdStream++;
                            WRITE_PORT_BUFFER_USHORT((PUSHORT)
                                    (ulBase + ulPort), pusCmdStream, culCount);
                            pusCmdStream += culCount;

                        }
                    }

                } else {

                    // In instruction
                    //
                    // Currently, string in instructions aren't supported; all
                    // in instructions are handled as single-byte ins
                    //
                    // Byte or word in?
                    //

                    if (!(ulCmd & BW)) {
                        //
                        // Single byte in
                        //

                        ulPort = *pusCmdStream++;
                        jValue = READ_PORT_UCHAR((PUCHAR)ulBase+ulPort);

                    } else {

                        //
                        // Single word in
                        //

                        ulPort = *pusCmdStream++;
                        usValue = READ_PORT_USHORT((PUSHORT)
                                (ulBase+ulPort));

                    }

                }

                break;

            //
            // Higher-level input/output commands
            //

            case METAOUT:

                //
                // Determine type of metaout command, based on minor
                // command field
                //
                switch (ulCmd & 0x0F) {

                    //
                    // Indexed outs
                    //

                    case INDXOUT:

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            usValue = (USHORT) (ulIndex +
                                      (((ULONG)(*pusCmdStream++)) << 8));
                            WRITE_PORT_USHORT((PUSHORT)ulPort, usValue);

                            ulIndex++;

                        }

                        break;

                    //
                    // Masked out (read, AND, XOR, write)
                    //

                    case MASKOUT:

                        ulPort = *pusCmdStream++;
                        jValue = READ_PORT_UCHAR((PUCHAR)ulBase+ulPort);
                        jValue &= *pusCmdStream++;
                        jValue ^= *pusCmdStream++;
                        WRITE_PORT_UCHAR((PUCHAR)ulBase + ulPort,
                                jValue);
                        break;

                    //
                    // Attribute Controller out
                    //

                    case ATCOUT:

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            // Write Attribute Controller index
                            WRITE_PORT_UCHAR((PUCHAR)ulPort,
                                    (UCHAR)ulIndex);

                            // Write Attribute Controller data
                            jValue = (UCHAR) *pusCmdStream++;
                            WRITE_PORT_UCHAR((PUCHAR)ulPort, jValue);

                            ulIndex++;

                        }

                        break;

                    //
                    // None of the above; error
                    //
                    default:

                        return FALSE;

                }


                break;

            //
            // NOP
            //

            case NCMD:

                break;

            //
            // Unknown command; error
            //

            default:

                return FALSE;

        }

    }
    return TRUE;

} // end VgaInterpretCmdStream()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=boot
TARGETPATH=obj
TARGETTYPE=LIBRARY

BUILD_PRODUCES=BOOTLIB$(BUILD_DEBUG_LOADER)

!IF "$(BUILD_DEBUG_LOADER)" != ""
!include $(PROJECT_ROOT)\boot\loader_dbg.inc
!ELSE
!include $(PROJECT_ROOT)\boot\loader.inc
!ENDIF

INCLUDES= \
    $(SDK_INC_PATH);\
    $(PROJECT_ROOT)\boot\inc;\
    $(DS_INC_PATH);\
    $(DS_INC_PATH)\crypto;\
    $(PROJECT_ROOT)\hals;\
    $(PROJECT_ROOT)\hals\inc;\
    $(PROJECT_ROOT)\ntos\inc;\
    $(PROJECT_ROOT)\fs\fastfat;\
    $(PROJECT_ROOT)\fs\cdfs;\
    $(PROJECT_ROOT)\fs\udfs;\
    $(PROJECT_ROOT)\fs\ntfs;\
    $(PROJECT_ROOT)\ntos\config;\
    ..\$(TARGET_DIRECTORY);\
    $(DDK_INC_PATH);\
    $(HALKIT_INC_PATH);

!IF $(386)
INCLUDES = $(INCLUDES);$(PROJECT_ROOT)\tools\bldrthnk
!ENDIF

!IF 0
NOTE : To force CD/DVD boot while starting setupldr from harddisk use
       FORCE_CD_BOOT

C_DEFINES=$(C_DEFINES) -DFORCE_CD_BOOT
!ENDIF

MSC_WARNING_LEVEL=/W4 /WX

SOURCES=..\arcdisk.c  \
        ..\blmemory.c \
        ..\blbind.c   \
        ..\blconfig.c \
        ..\blgpt.c    \
        ..\blio.c     \
        ..\blload.c   \
        ..\blres.c    \
        ..\debug.c    \
        ..\etfsboot.c \
        ..\fatboot.c  \
        ..\ntfsboot.c \
        ..\cdfsboot.c \
        ..\udfsboot.c \
        ..\netboot.c  \
        ..\nlsboot.c  \
        ..\parseini.c \
        ..\hdlsterm.c \
        ..\peldr.c    \
        ..\bllog.c    \
        ..\blmisc.c   \
        ..\blcache.c  \
        ..\blrange.c  \
        ..\vmode.c    \
        ..\vga.c      \
        ..\blsecret.c \
        ..\blstring.c \
        ..\ramdisk.c


!IF $(386)
!IF exist(..\amd64\amd64.c)

C_DEFINES=$(C_DEFINES) -D_X86AMD64_
ASM_DEFINES=$(ASM_DEFINES) -D_X86AMD64_
NTTARGETFILE0=amd64thk

!ENDIF
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\vga.h ===
/*++

Copyright (c) 1990-1997  Microsoft Corporation

Module Name:

    vga.h

Author:

    Erick Smith (ericks) Oct. 1997

Environment:

    kernel mode only

Revision History:

--*/

//
// VGA register definitions
//

#define CRTC_ADDRESS_PORT_MONO      0x03b4  // CRT Controller Address and
#define CRTC_DATA_PORT_MONO         0x03b5  // Data registers in mono mode
#define FEAT_CTRL_WRITE_PORT_MONO   0x03bA  // Feature Control write port
                                            // in mono mode
#define INPUT_STATUS_1_MONO         0x03bA  // Input Status 1 register read
                                            // port in mono mode
#define ATT_INITIALIZE_PORT_MONO    INPUT_STATUS_1_MONO
                                            // Register to read to reset
                                            // Attribute Controller index/data

#define ATT_ADDRESS_PORT            0x03c0  // Attribute Controller Address and
#define ATT_DATA_WRITE_PORT         0x03c0  // Data registers share one port
                                            // for writes, but only Address is
                                            // readable at 0x3C0
#define ATT_DATA_READ_PORT          0x03c1  // Attribute Controller Data reg is
                                            // readable here
#define MISC_OUTPUT_REG_WRITE_PORT  0x03c2  // Miscellaneous Output reg write
                                            // port
#define INPUT_STATUS_0_PORT         0x03c2  // Input Status 0 register read
                                            // port
#define VIDEO_SUBSYSTEM_ENABLE_PORT 0x03c3  // Bit 0 enables/disables the
                                            // entire VGA subsystem
#define SEQ_ADDRESS_PORT            0x03c4  // Sequence Controller Address and
#define SEQ_DATA_PORT               0x03c5  // Data registers
#define DAC_PIXEL_MASK_PORT         0x03c6  // DAC pixel mask reg
#define DAC_ADDRESS_READ_PORT       0x03c7  // DAC register read index reg,
                                            // write-only
#define DAC_STATE_PORT              0x03c7  // DAC state (read/write),
                                            // read-only
#define DAC_ADDRESS_WRITE_PORT      0x03c8  // DAC register write index reg
#define DAC_DATA_REG_PORT           0x03c9  // DAC data transfer reg
#define FEAT_CTRL_READ_PORT         0x03cA  // Feature Control read port
#define MISC_OUTPUT_REG_READ_PORT   0x03cC  // Miscellaneous Output reg read
                                            // port
#define GRAPH_ADDRESS_PORT          0x03cE  // Graphics Controller Address
#define GRAPH_DATA_PORT             0x03cF  // and Data registers

#define CRTC_ADDRESS_PORT_COLOR     0x03d4  // CRT Controller Address and
#define CRTC_DATA_PORT_COLOR        0x03d5  // Data registers in color mode
#define FEAT_CTRL_WRITE_PORT_COLOR  0x03dA  // Feature Control write port
#define INPUT_STATUS_1_COLOR        0x03dA  // Input Status 1 register read
                                            // port in color mode
#define ATT_INITIALIZE_PORT_COLOR   INPUT_STATUS_1_COLOR
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in color mode

//
// VGA indexed register indexes.
//

#define IND_CURSOR_START        0x0A    // index in CRTC of the Cursor Start
#define IND_CURSOR_END          0x0B    //  and End registers
#define IND_CURSOR_HIGH_LOC     0x0E    // index in CRTC of the Cursor Location
#define IND_CURSOR_LOW_LOC      0x0F    //  High and Low Registers
#define IND_VSYNC_END           0x11    // index in CRTC of the Vertical Sync
                                        //  End register, which has the bit
                                        //  that protects/unprotects CRTC
                                        //  index registers 0-7
#define IND_SET_RESET_ENABLE    0x01    // index of Set/Reset Enable reg in GC
#define IND_DATA_ROTATE         0x03    // index of Data Rotate reg in GC
#define IND_READ_MAP            0x04    // index of Read Map reg in Graph Ctlr
#define IND_GRAPH_MODE          0x05    // index of Mode reg in Graph Ctlr
#define IND_GRAPH_MISC          0x06    // index of Misc reg in Graph Ctlr
#define IND_BIT_MASK            0x08    // index of Bit Mask reg in Graph Ctlr
#define IND_SYNC_RESET          0x00    // index of Sync Reset reg in Seq
#define IND_MAP_MASK            0x02    // index of Map Mask in Sequencer
#define IND_MEMORY_MODE         0x04    // index of Memory Mode reg in Seq
#define IND_CRTC_PROTECT        0x11    // index of reg containing regs 0-7 in
                                        //  CRTC

#define START_SYNC_RESET_VALUE  0x01    // value for Sync Reset reg to start
                                        //  synchronous reset
#define END_SYNC_RESET_VALUE    0x03    // value for Sync Reset reg to end
                                        //  synchronous reset

//
// Values for Attribute Controller Index register to turn video off
// and on, by setting bit 5 to 0 (off) or 1 (on).
//

#define VIDEO_DISABLE 0
#define VIDEO_ENABLE  0x20

#define VGA_NUM_SEQUENCER_PORTS     5
#define VGA_NUM_CRTC_PORTS         25
#define VGA_NUM_GRAPH_CONT_PORTS    9
#define VGA_NUM_ATTRIB_CONT_PORTS  21
#define VGA_NUM_DAC_ENTRIES       256

//
// Value written to the Read Map register when identifying the existence of
// a VGA in VgaInitialize. This value must be different from the final test
// value written to the Bit Mask in that routine.
//

#define READ_MAP_TEST_SETTING 0x03

//
// Masks to keep only the significant bits of the Graphics Controller and
// Sequencer Address registers. Masking is necessary because some VGAs, such
// as S3-based ones, don't return unused bits set to 0, and some SVGAs use
// these bits if extensions are enabled.
//

#define GRAPH_ADDR_MASK 0x0F
#define SEQ_ADDR_MASK   0x07

//
// Mask used to toggle Chain4 bit in the Sequencer's Memory Mode register.
//

#define CHAIN4_MASK 0x08

//
// Default text mode setting for various registers, used to restore their
// states if VGA detection fails after they've been modified.
//

#define MEMORY_MODE_TEXT_DEFAULT 0x02
#define BIT_MASK_DEFAULT 0xFF
#define READ_MAP_DEFAULT 0x00

//
// prototypes
//

#define BI_RLE4 2

#pragma pack(1)

typedef struct _BITMAPFILEHEADER {

    USHORT bfType;
    ULONG bfSize;
    USHORT bfReserved1;
    USHORT bfReserved2;
    ULONG bfOffBits;
} BITMAPFILEHEADER, *PBITMAPFILEHEADER;

typedef struct _BITMAPINFOHEADER {

    ULONG biSize;
    LONG biWidth;
    LONG biHeight;
    USHORT biPlanes;
    USHORT biBitCount;
    ULONG biCompression;
    ULONG biSizeImage;
    LONG biXPelsPerMeter;
    LONG biYPelsPerMeter;
    ULONG biClrUsed;
    ULONG biClrImportant;
} BITMAPINFOHEADER, *PBITMAPINFOHEADER;

typedef struct _RGBQUAD {

    UCHAR rgbBlue;
    UCHAR rgbGreen;
    UCHAR rgbRed;
    UCHAR rgbReserved;
} RGBQUAD, *PRGBQUAD;

typedef struct _NTLDRGRAPHICSCONTEXT {
	UCHAR		VgaGfxProgressBarColor;
	PUCHAR		BmpBuffer;				//	Bitmap buffer
	PUCHAR		DotBuffer;				//	Dots bitmap buffer
	ULONG		ColorsUsed;
	RGBQUAD*	Palette;				//	pointer to the palette in BmpBuffer (dots MUST have the same palette)
} NTLDRGRAPHICSCONTEXT;

#pragma pack()

////////////////////////////////////////////////////////////////////////////////

VOID
SetPixel(
    ULONG x,
    ULONG y,
    ULONG color
    );

VOID
BitBlt(
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    PUCHAR Buffer,
    ULONG bpp,
    LONG ScanWidth
    );

VOID
SetPaletteEntryRGB(
    ULONG index,
    RGBQUAD rgb
    );

VOID
InitPaletteConversionTable();


VOID
InitPaletteWithBlack(
    VOID
    );

VOID
InitPaletteWithTable(
    PRGBQUAD Palette,
    ULONG count
    );

VOID
VidBitBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y
    );

VOID
VidScreenToBufferBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    ULONG lDelta
    );

void
VidBufferToScreenBlt(
    PUCHAR Buffer,
    ULONG x,
    ULONG y,
    ULONG width,
    ULONG height,
    ULONG lDelta
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\udfsboot.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

  UdfsBoot.c

Abstract:

  Implements UDF File System Reader for reading UDF volumes from DVD/CD.

  Note : Read ISO-13346(ECMA-167) and UDF 2.0 document to understand the
  UDF format. UDF is a subset for ECMA-167 standard.

Author:

  Vijayachandran Jayaseelan (vijayj@microsoft.com)

Revision History:

  None

--*/

#define INVALID_CACHE_ID (ULONG) -1

#ifdef UDF_TESTING

#include <tbldr.h>    // to test this code from user mode

#else

#include "bootlib.h"
#include "blcache.h"

//#define UDF_DEBUG  1
//#define SHOW_UDF_USAGE 1
#endif // for UDF_TESTING

#include "udfsboot.h"

#include <udf.h>    // predefined IS0-13346 & UDF structures

#define UDFS_ALIGN_BUFFER(Buffer, Size) (PVOID) \
        ((((ULONG_PTR)(Buffer) + Size - 1)) & (~((ULONG_PTR)Size - 1)))

#ifndef UNALIGNED
#define UNALIGNED
#endif

#ifdef UDF_DEBUG

ULONG
BlGetKey(
    VOID
    );

#define DBG_PAUSE while (!BlGetKey())

VOID
BlClearScreen(
    VOID
    );

    VOID
BlPositionCursor(
    IN ULONG Column,
    IN ULONG Row
    );

#endif // for UDF_DEBUG

//
// Global Data
//
BOOTFS_INFO UdfsBootFsInfo = {L"udfs"};

//
// Volume table(s) for all the volumes on different devices
//
UDF_VOLUME                  UDFVolumes[UDF_MAX_VOLUMES];

//
// UDF file system methods
//
BL_DEVICE_ENTRY_TABLE   UDFSMethods;

//
// Per Volume Cache which contains the traversed UDF directories and currently
// opened UDF files.
//
// N.B. Its being assumed here that this reader would be reading files from
// relatively few (may be 1 or 2) directorie(s) which are not nested deeply
//
UDF_CACHE_ENTRY           UDFCache[UDF_MAX_VOLUMES][UDF_MAX_CACHE_ENTRIES];


#ifdef __cplusplus
#define extern "C" {
#endif

//
// Internal Types
//
typedef enum _COMPARISON_RESULTS {
    LessThan = -1,
    EqualTo = 0,
    GreaterThan = 1
} COMPARISON_RESULTS;

//
// Macros
//
#define MIN(_a,_b) (((_a) <= (_b)) ? (_a) : (_b))
#define UDF_ROUND_TO(X, Y)  (((X) % (Y)) ? (X) + (Y) - ((X) % (Y)) : (X))
#define TOUPPER(C) ((((C) >= 'a') && ((C) <= 'z')) ? (C) - 'a' + 'A' : (C))

// file entry operations
#define FILE_ENTRY_TO_VOLUME(X) (((PUDFS_STRUCTURE_CONTEXT)((X)->StructureContext))->\
                                      Volume)
#define FILE_ENTRY_TO_FILE_CONTEXT(X) ((PUDFS_FILE_CONTEXT)&((X)->u.UdfsFileContext))

// NSR_FID operations
#define UDF_FID_NAME(X) (((PUCHAR)(X)) + 38 + (X)->ImpUseLen)
#define UDF_FID_LEN(X)  UDF_ROUND_TO((X)->FileIDLen + (X)->ImpUseLen + 38, 4)
#define UDF_BLOCK_TO_FID(X, Y) ((NSR_FID UNALIGNED *)(((PUCHAR)(X)) + (Y)->Offset))
#define UDF_FID_IS_DIRECTORY(X) ((((NSR_FID UNALIGNED *)(X))->Flags & NSR_FID_F_DIRECTORY) ? TRUE : FALSE)
#define UDF_FID_IS_PARENT(X) ((((NSR_FID UNALIGNED *)(X))->Flags & NSR_FID_F_PARENT) ? TRUE : FALSE)
#define UDF_FID_IS_DELETED(X) ((((NSR_FID UNALIGNED *)(X))->Flags & NSR_FID_F_DELETED) ? TRUE : FALSE)
#define UDF_FID_IS_HIDDEN(X) ((((NSR_FID UNALIGNED *)(X))->Flags & NSR_FID_F_HIDDEN) ? TRUE : FALSE)
#define UDF_FID_SKIP(X) (UDF_FID_IS_PARENT(X) || UDF_FID_IS_DELETED(X) || UDF_FID_IS_HIDDEN(X))

// ICBFILE operations
#define UDF_ICB_IS_DIRECTORY(X) ((X)->Icbtag.FileType == ICBTAG_FILE_T_DIRECTORY)
#define UDF_ICB_NUM_ADS(X) ((X)->AllocLength / sizeof(SHORTAD))
#define UDF_ICB_GET_AD_BUFFER(X) (((PUCHAR)&((X)->AllocLength)) + 4 + (X)->EALength)
#define UDF_ICB_GET_AD(X, Y) (((SHORTAD UNALIGNED *)UDF_ICB_GET_AD_BUFFER(X)) + (Y))

//
//  Local procedure prototypes.
//
ARC_STATUS
UDFSReadDisk(
    IN ULONG DeviceId,
    IN ULONG BlockIdx,
    IN ULONG Size,
    IN OUT PVOID Buffer,
    IN BOOLEAN CacheNewData
    );

COMPARISON_RESULTS
UDFSCompareAnsiNames(
    IN PSTRING Name1,
    IN PSTRING Name2
    );

COMPARISON_RESULTS
UDFSCompareStrings(
    IN PCHAR Str1,
    IN PCHAR Str2
    );

BOOLEAN
UDFSVerifyPathName(
  IN PCHAR Name
  );

BOOLEAN
UDFSGetPathComponent(
  IN PCHAR Name,
  IN USHORT ComponentIdx,
  OUT PCHAR ReqComponent
  );

USHORT
UDFSCountPathComponents(
  IN PCHAR Name
  );

ULONG
UDFCacheGetBestEntryByName(
  IN PUDF_CACHE_ENTRY,
  IN PCHAR Name
  );

VOID
UDFSInitUniStrFromDString(
  OUT PUNICODE_STRING UniStr,
  IN PUCHAR Buffer,
  IN ULONG Length
  );

int
UDFSCompareAnsiUniNames(
    IN CSTRING AnsiString,
    IN UNICODE_STRING UnicodeString
    );

#ifdef __cplusplus
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Implementation
//
/////////////////////////////////////////////////////////////////////////////

ARC_STATUS
UDFSInitialize(
    VOID
    )
/*++

Routine Description:

  Initialize file system specific data structures.

Arguments:

  None

Return Value:

  ESUCCESS if successful otherwise appropriate error code

--*/
{
  //
  // fill in the global device entry table
  //
  UDFSMethods.Open = UDFSOpen;
  UDFSMethods.Close = UDFSClose;
  UDFSMethods.Read = UDFSRead;
  UDFSMethods.Write = UDFSWrite;
  UDFSMethods.Seek = UDFSSeek;
  UDFSMethods.GetFileInformation = UDFSGetFileInformation;
  UDFSMethods.SetFileInformation = UDFSSetFileInformation;

  return ESUCCESS;
}


PBL_DEVICE_ENTRY_TABLE
IsUDFSFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    )

/*++

Routine Description:

    This routine determines if the partition on the specified channel
    contains a UDF file system volume.

Arguments:

    DeviceId - Supplies the file table index for the device on which
        read operations are to be performed.

    StructureContext - Supplies a pointer to a UDFS file structure context.

Return Value:

    A pointer to the UDFS entry table is returned if the partition is
    recognized as containing a UDFS volume. Otherwise, NULL is returned.

--*/

{
  PBL_DEVICE_ENTRY_TABLE  DevMethods = 0;
  ULONG Index;
  ULONG FreeSlot = UDF_MAX_VOLUMES;

  //
  // make sure that we have not mounted the file system on
  // the device already
  //
  for (Index=0; Index < UDF_MAX_VOLUMES; Index++) {
      if ((UDFVolumes[Index].DeviceId == DeviceId) &&
                  (UDFVolumes[Index].Cache != 0)) {
          break;
      }

      if ((!UDFVolumes[Index].Cache) && (FreeSlot == UDF_MAX_VOLUMES))
          FreeSlot = Index;
  }

  if ((Index == UDF_MAX_VOLUMES) && (FreeSlot != UDF_MAX_VOLUMES)) {
    if (UDFSVolumeOpen(UDFVolumes + FreeSlot, DeviceId) == ESUCCESS) {
      UDF_FILE_DIRECTORY  RootDir;
      PUDF_VOLUME Volume = UDFVolumes + FreeSlot;
      UCHAR UBlock[UDF_BLOCK_SIZE + 256] = {0};
      PUCHAR Block = ALIGN_BUFFER(UBlock);
      BOOLEAN Result = FALSE;

      DevMethods = &UDFSMethods;

      // save off the volume context
      ((PUDFS_STRUCTURE_CONTEXT)StructureContext)->Volume = Volume;

      // initialize cache
      Volume->Cache = UDFCache[FreeSlot];

      //
      // Read and Cache the root directory
      //
      RootDir.Volume = Volume;
      RootDir.FileId.BlockIdx = (ULONG)-1;   // invalid
      RootDir.FileId.Offset =  (USHORT)-1;   // invalid
      RootDir.IsDirectory = TRUE;
      RootDir.IcbBlk = Volume->RootDirBlk;

      if (UDFSReadDisk(Volume->DeviceId, Volume->StartBlk + RootDir.IcbBlk,
                              UDF_BLOCK_SIZE, Block, CACHE_NEW_DATA) == ESUCCESS) {
        ICBFILE UNALIGNED *Icb = (ICBFILE UNALIGNED *)Block;

        if (Icb->Destag.Ident == DESTAG_ID_NSR_FILE) {
          RootDir.Size = Icb->InfoLength;
          RootDir.StartDataBlk = UDF_ICB_GET_AD(Icb, 0)->Start;
          RootDir.NumExtents = (UCHAR)UDF_ICB_NUM_ADS(Icb);
          Result = (BOOLEAN) (UDFCachePutEntry(Volume->Cache, "\\", &RootDir) != -1);
        }
      }

      if (!Result) {
        memset(Volume, 0, sizeof(UDF_VOLUME));
        DevMethods = 0;
      }
    }
  }
  else {
    // use already mounted volume
      if (Index != UDF_MAX_VOLUMES) {
          DevMethods = &UDFSMethods;
          ((PUDFS_STRUCTURE_CONTEXT)StructureContext)->Volume =
              UDFVolumes + Index;
      }
  }

  return DevMethods;
}

//
// Volume methods
//
ARC_STATUS
UDFSVolumeOpen(
    IN PUDF_VOLUME  Volume,
    IN ULONG        DeviceId
    )
/*++

Routine Description:

  Mounts the UDFS Volume on the device and updates the
  file system state (global data structures)

Arguments:

  Volume - UDF Volume pointer
  DeviceId - Device on which the Volume may be residing

Return Value:

  ESUCCESS if successful otherwise EBADF (if no UDF volume was found)

--*/
{
  ARC_STATUS  Status = ESUCCESS;
  UCHAR       UBlock[UDF_BLOCK_SIZE+256] = {0};
  PUCHAR      Block = ALIGN_BUFFER(UBlock);
  ULONG       BlockIdx = 256;
  // ULONG       LastBlock = 0;

  while (Status == ESUCCESS) {
    // get hold of Anchor Volume Descriptor
        Status = UDFSReadDisk(DeviceId, BlockIdx, UDF_BLOCK_SIZE, Block, CACHE_NEW_DATA);

    if (Status == ESUCCESS) {
      NSR_ANCHOR  UNALIGNED *Anchor = (NSR_ANCHOR UNALIGNED *)Block;

      Status = EBADF;

      if (Anchor->Destag.Ident == DESTAG_ID_NSR_ANCHOR) {
          // get partition descriptor
          NSR_PART UNALIGNED *Part;
          WCHAR    UNALIGNED *TagID;
          BlockIdx = Anchor->Main.Lsn;

        do {
          Status = UDFSReadDisk(DeviceId, BlockIdx++, UDF_BLOCK_SIZE, Block, CACHE_NEW_DATA);
          TagID = (WCHAR UNALIGNED *)Block;
        }
        while ((Status == ESUCCESS) && (*TagID) &&
               (*TagID != DESTAG_ID_NSR_TERM) && (*TagID != DESTAG_ID_NSR_PART));

        if ((Status == ESUCCESS) && (*TagID == DESTAG_ID_NSR_PART)){
          Part = (NSR_PART UNALIGNED *)Block;

          if (strstr((PCHAR)Part->ContentsID.Identifier, "+NSR")){
            Volume->DeviceId = DeviceId;
            Volume->StartBlk = Part->Start;
            Volume->BlockSize = UDF_BLOCK_SIZE;

            // get FSD at partition starting
            if (UDFSVolumeReadBlock(Volume, 0, Block) == ESUCCESS) {
              NSR_FSD UNALIGNED *FileSet = (NSR_FSD UNALIGNED *)Block;
              ULONG RootDirBlk = FileSet->IcbRoot.Start.Lbn;

              // get hold of root directory entry
              if (UDFSVolumeReadBlock(Volume, RootDirBlk, Block) == ESUCCESS) {
                  ICBFILE UNALIGNED *RootDir = (ICBFILE UNALIGNED *)Block;

                if (RootDir->Destag.Ident == DESTAG_ID_NSR_FILE) {
                    Volume->RootDirBlk = RootDirBlk;
                    Status = ESUCCESS;

                    break;
                }
              }
            }
          }
        }
      }
    }

    /*
    //
    // AVD should be at atleast two of the following locations
    // 256, N and N - 256
    //
    if (Status != ESUCCESS) {
      if (BlockIdx == 256) {
        FILE_INFORMATION  FileInfo;

        Status = BlGetFileInformation(DeviceId, &FileInfo);

        if (Status == ESUCCESS) {
          LastBlock = (ULONG)((FileInfo.EndingAddress.QuadPart - FileInfo.StartingAddress.QuadPart) /
                          UDF_BLOCK_SIZE);

          if (LastBlock) {
            LastBlock--;
            BlockIdx = LastBlock;
            Status = ESUCCESS;
          }
        }
      } else {
        if (LastBlock > 256) {
          BlockIdx = LastBlock - 256;
          Status = ESUCCESS;
        }
      }
    }
    */
  }

  return Status;
}

ARC_STATUS
UDFSVolumeReadBlock(
    IN PUDF_VOLUME Volume,
    IN ULONG BlockIdx,
    OUT PUDF_BLOCK Block
    )
/*++

Routine Description:

  Reads a logical UDF block w.r.t to the given Volume

Arguments:

  Volume - Pointer to UDF_VOLUME on which the block is to
           be read
  BlockIdx - Logical (zero based) index w.r.t to Volume start
  Block - Buffer to read the block into.

Return Value:

  ESSUCESS if the block is read successfully otherwise appropriate
  error code.

--*/
{
    ARC_STATUS  Result;

  // TBD : add range checking
    Result = UDFSReadDisk(
                Volume->DeviceId,
                Volume->StartBlk + BlockIdx,
                UDF_BLOCK_SIZE,
                Block,
                DONT_CACHE_NEW_DATA
                );

    return Result;
}

ARC_STATUS
UDFSOpen (
    IN CHAR * FIRMWARE_PTR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT ULONG * FIRMWARE_PTR FileId
    )
/*++

Routine Description:

  Opens the required file/directory on a UDF volume residing
  on the specified device.

Arguments:

  OpenPath  - Fully qualified path to the file/directory to open
  OpenMode  - Required Open Mode
  FileId    - File identifier as an index to BlFileTable which
              has to be updated for file/dir properties

Return Value:

  ESUCCESS if successful otherwise appropriate error code.

--*/
{
  ARC_STATUS Status;
  PBL_FILE_TABLE FileEntry = BlFileTable + (*FileId);
  PUDF_VOLUME Volume = FILE_ENTRY_TO_VOLUME(FileEntry);
  PUDF_CACHE_ENTRY    Cache = Volume->Cache;
  ULONG CacheIdx = UDFCacheGetEntryByName(Cache, OpenPath, TRUE);
  PUDFS_FILE_CONTEXT FileContext = FILE_ENTRY_TO_FILE_CONTEXT(FileEntry);

#ifdef UDF_DEBUG
  BlClearScreen();
  BlPrint("UDFSOpen(%s)\r\n", OpenPath);
#else
#ifdef SHOW_UDF_USAGE
  BlPositionCursor(1, 22);
  BlPrint("                                                               ", OpenPath);
  BlPositionCursor(1, 22);
  BlPrint("UDFSOpen( %s )", OpenPath);
#endif // for SHOW_UDF_USAGE
#endif // for UDF_DEBUG

    if (UDFSVerifyPathName(OpenPath)) {
    if (CacheIdx == INVALID_CACHE_ID) {
      //
      // create an entry and cache it
      //
      CacheIdx = UDFCacheGetBestEntryByName(Cache, OpenPath);

      if (CacheIdx != INVALID_CACHE_ID) {
        ULONG PathSize = (ULONG)strlen(OpenPath);
        ULONG BestSize = (ULONG)strlen(Cache[CacheIdx].Name);

        if (BestSize == 1)  // root directory
          BestSize--;

        if ((BestSize < PathSize) && (OpenPath[BestSize] == '\\')) {
          CHAR FullPath[256];
          CHAR Component[256];
          PUDF_FILE_DIRECTORY Entry = &(Cache[CacheIdx].File);
          UDF_FILE_DIRECTORY NewId;

          if (BestSize > 1)
            strcpy(FullPath, Cache[CacheIdx].Name);
          else
            FullPath[0] = 0;

          BestSize++;
          UDFSGetPathComponent(OpenPath + BestSize, 0, Component);
          Status = Component[0] ? ESUCCESS : ENOENT;

          while ((CacheIdx != INVALID_CACHE_ID) && (Status == ESUCCESS) && Component[0]) {

            Status = UDFSDirGetFile(Entry, Component, &NewId);

            if (Status == ESUCCESS) {
              strcat(FullPath, "\\");
              strcat(FullPath, Component);

              // cache the directory entry
              CacheIdx = UDFCachePutEntry(Cache, FullPath, &NewId);

              BestSize += (ULONG)strlen(Component);

              if (OpenPath[BestSize] == '\\')
                BestSize++;

              UDFSGetPathComponent(OpenPath + BestSize, 0, Component);

              if (CacheIdx != INVALID_CACHE_ID) {
                  Entry = &(Cache[CacheIdx].File);
              }
            }
          }

          if ((Status == ESUCCESS) && !Component[0] && (CacheIdx != INVALID_CACHE_ID)) {
            if (OpenMode != ArcOpenReadOnly)
              Status = EACCES;
          }
          else
            Status = ENOENT;
        }
        else
          Status = ENOENT;
      }
      else
        Status = EINVAL;
    } else {
      //
      // use the already cached entry
      //
      if (OpenMode == ArcOpenReadOnly) {
        Status = ESUCCESS;
      } else {
        Status = EACCES;
      }
    }
  } else {
    Status = EINVAL;
  }

  if (Status == ESUCCESS) {
    FileContext->CacheIdx = CacheIdx;
    FileEntry->Position.QuadPart = 0;
    FileEntry->Flags.Open = 1;
    FileEntry->Flags.Read = 1;
    FileEntry->Flags.Write = 0;
    FileEntry->Flags.Firmware = 0;
  }

#ifdef UDF_DEBUG
  if (Status) {
    BlPrint("UDFSOpen() error : %d. Press any key to Continue.\r\n", Status);
    DBG_PAUSE;
  }
#endif

  return Status;
}

ARC_STATUS
UDFSClose (
    IN ULONG FileId
    )
/*++

Routine Description:

  Closes the given file/directory.

Arguments:

  FileId - The file identifier, as an index into the BlFileTable

Return Value:

  ESUCCESS if successful otherwise appropriate error code

--*/
{
  PBL_FILE_TABLE FileEntry = BlFileTable + FileId;
  PUDF_VOLUME Volume = FILE_ENTRY_TO_VOLUME(FileEntry);
  PUDF_CACHE_ENTRY    Cache = Volume->Cache;
  PUDFS_FILE_CONTEXT FileContext = FILE_ENTRY_TO_FILE_CONTEXT(FileEntry);
  ULONG CacheIdx = FileContext->CacheIdx;

  // decrement usage from cache
  UDFCacheDecrementUsage(Cache, CacheIdx);
  FileEntry->Flags.Open = 0;

  return ESUCCESS;
}

ARC_STATUS
UDFSRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    )
/*++

Routine Description:

   Reads the contents of the specified file.

Arguments:

  FileId - File identifier as an index into BlFileTable
  Buffer - The location where the data has to be read into
  Length - The amount of data to read
  Count - The amount of data read

Return Value:

  ESUCCESS if successful otherwise appropriate error code

--*/
{
  ARC_STATUS Status = ESUCCESS;
  PBL_FILE_TABLE FileEntry = BlFileTable + FileId;
  PUDF_VOLUME Volume = FILE_ENTRY_TO_VOLUME(FileEntry);
  PUDF_CACHE_ENTRY    Cache = Volume->Cache;
  PUDFS_FILE_CONTEXT FileContext = FILE_ENTRY_TO_FILE_CONTEXT(FileEntry);
  ULONG CacheIdx = FileContext->CacheIdx;
  PUDF_FILE_DIRECTORY File = &(Cache[CacheIdx].File);
  UCHAR UBlock[UDF_BLOCK_SIZE+256] = {0};
  PUCHAR Block = ALIGN_BUFFER(UBlock);
  ULONGLONG Position = FileEntry->Position.QuadPart;
  ULONG BytesRead = 0;
  ULONG BlkIdx;

  if (Buffer) {
    ULONG CopyCount = 0;

    while ((Status == ESUCCESS) && (BytesRead < Length) &&
              (Position < File->Size)) {
      BlkIdx = (ULONG)(Position / UDF_BLOCK_SIZE);
      Status = UDFSFileReadBlock(File, BlkIdx, UDF_BLOCK_SIZE, Block);

      if (Status == ESUCCESS) {
        // must be amount requested
        CopyCount = MIN(Length - BytesRead, UDF_BLOCK_SIZE);
        // provided data is there
        CopyCount = (ULONG) MIN(CopyCount, File->Size - Position);
        // in case the position is not aligned at block boundaries
        CopyCount = MIN(CopyCount, UDF_BLOCK_SIZE - (ULONG)(Position % UDF_BLOCK_SIZE));

        memcpy((PUCHAR)Buffer + BytesRead, (PUCHAR)Block + (Position % UDF_BLOCK_SIZE),
                  CopyCount);

        BytesRead += CopyCount;
        Position += CopyCount;
      }
    }
  }
  else
    Status = EINVAL;

  if (Status == ESUCCESS) {
    FileEntry->Position.QuadPart = Position;
    *Count = BytesRead;
  }

  return Status;
}


ARC_STATUS
UDFSSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    )
/*++

Routine Description:

  Changes the file's pointer (for random access)

Arguments:

  FileId : File identifier as an index into the BlFileTable
  Offset : Seek amount
  SeekMode : Type of seek (absolute, relative, from end)

Return Value:

  ESUCCESS if successful otherwise appropriate error code

--*/
{
  ARC_STATUS Status = ESUCCESS;
  PBL_FILE_TABLE FileEntry = BlFileTable + FileId;
  PUDF_VOLUME Volume = FILE_ENTRY_TO_VOLUME(FileEntry);
  PUDF_CACHE_ENTRY    Cache = Volume->Cache;
  PUDFS_FILE_CONTEXT FileContext = FILE_ENTRY_TO_FILE_CONTEXT(FileEntry);
  ULONG CacheIdx = FileContext->CacheIdx;
  PUDF_FILE_DIRECTORY File = &(Cache[CacheIdx].File);
  ULONGLONG Position = FileEntry->Position.QuadPart;

  switch (SeekMode) {
    case SeekAbsolute:
      Position = Offset->QuadPart;
      break;

    case SeekRelative:
      Position += Offset->QuadPart;
      break;

    case SeekMaximum:
      Position = File->Size + Offset->QuadPart;
      break;

    default:
      Status = EINVAL;
      break;
  }

  if ((Status == ESUCCESS) && (Position < File->Size))
    FileEntry->Position.QuadPart = Position;
  else
    Status = EINVAL;

  return Status;
}


ARC_STATUS
UDFSWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    )
/*++

Routine Description:

  Write the specified data to the given file.

Arguments:

  FileId : File identifier as an index into BlFileTable
  Buffer : Pointer to the data, which has to be written
  Length : The amount of data to be written
  Count  : The amount of data written.

Return Value:

  ESUCCESS if successful otherwise appropriate error code

--*/
{
    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( Count );

    return EACCES;
}


ARC_STATUS
UDFSGetFileInformation (
    IN ULONG FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
    )
/*++

Routine Description:

  Gets the file information as required by FILE_INFORMATION
  fields.

Arguments:

  FileId : File identifier as an index into BlFileTable
  Buffer : FILE_INFORMATION structure pointer, to be filled in.

Return Value:

  ESUCCESS if successful otherwise appropriate error code

--*/
{
  PBL_FILE_TABLE FileEntry = BlFileTable + FileId;
  PUDF_VOLUME Volume = FILE_ENTRY_TO_VOLUME(FileEntry);
  PUDF_CACHE_ENTRY    Cache = Volume->Cache;
  PUDFS_FILE_CONTEXT FileContext = FILE_ENTRY_TO_FILE_CONTEXT(FileEntry);
  ULONG CacheIdx = FileContext->CacheIdx;
  PUDF_FILE_DIRECTORY File = &(Cache[CacheIdx].File);
  PCHAR Name;
  PCHAR Component;

  memset(Buffer, 0, sizeof(FILE_INFORMATION));
  Buffer->EndingAddress.QuadPart = File->Size;
  Buffer->CurrentPosition = FileEntry->Position;

  if (File->IsDirectory)
    Buffer->Attributes |= ArcDirectoryFile;

  //
  // get hold of the last component in the path name
  //
  Name = Cache[CacheIdx].Name;
  Component = 0;

  while (Name) {
    Component = Name + 1; // skip '\\'
    Name = strchr(Component, '\\');
  }

  if (Component) {
    Buffer->FileNameLength = (ULONG)strlen(Component);
    strncpy(Buffer->FileName, Component, sizeof(Buffer->FileName) - 1);
    Buffer->FileName[sizeof(Buffer->FileName) - 1] = 0; // null terminate
  }

  return ESUCCESS;
}


ARC_STATUS
UDFSSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    )
/*++

Routine Description:

  Sets the given file information for the specified file.

Arguments:

  FileId        : File identifier as an index into BlFileTable
  AttributeFlags: The flags to be set for the file (like read only
                  hidden, system etc.)
  AttributeMas  : Mask to be used for the attributes

Return Value:

  ESUCCESS if successful otherwise appropriate error code

--*/
{
    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( AttributeFlags );
    UNREFERENCED_PARAMETER( AttributeMask );

    return EACCES;
}

//
// file / directory method implementations
//
ARC_STATUS
UDFSFileReadBlock(
  IN PUDF_FILE_DIRECTORY  File,
  IN ULONG BlockIdx,
  IN ULONG Size,
  OUT PUDF_BLOCK Block
  )
/*++

Routine Description:

  Reads a file/directory data block relative to the start of
  the file/directory's data extent.

Arguments:

  File - UDF_FILE_DIRECTORY pointer indicating the file to
         be operated upon.
  BlockIdx - Zero based block index (w.r.t. to file's data extent)
  Size - Size of the block in bytes
  Block - Buffer where the data has to be read in.

Return Value:

  ESUCCESS if successful otherwise appropriate error code

--*/
{
  ARC_STATUS  Status;

  if (File->NumExtents > 1) {
    //
    // map the logical file block to the acutal volume logical block
    //
    Status = UDFSVolumeReadBlock(File->Volume, File->IcbBlk, Block);

    if (Status == ESUCCESS) {
      ICBFILE UNALIGNED *Icb = (ICBFILE UNALIGNED *)Block;
      ULONG ExtentIdx = 0;
      SHORTAD UNALIGNED *Extent = UDF_ICB_GET_AD(Icb, ExtentIdx);
      ULONG ExtentLength = 0;
      ULONG NumBlocks = 0;

      while (ExtentIdx < File->NumExtents) {
        Extent = UDF_ICB_GET_AD(Icb, ExtentIdx);
        ExtentLength = (Extent->Length.Length / Size);
        NumBlocks += ExtentLength;

        if (NumBlocks > BlockIdx)
          break;

        ExtentIdx++;
      }

      if (Extent) {
        ULONG StartBlock = Extent->Start + (BlockIdx - (NumBlocks - ExtentLength));
        Status = UDFSVolumeReadBlock(File->Volume, StartBlock, Block);
      } else {
        Status = EIO;
      }
    }
  } else {
    Status = UDFSVolumeReadBlock(File->Volume, File->StartDataBlk + BlockIdx, Block);
  }

  return Status;
}

ARC_STATUS
UDFSDirGetFirstFID(
    IN PUDF_FILE_DIRECTORY Dir,
    OUT PUDF_FILE_IDENTIFIER File,
    OUT PUDF_BLOCK Block
    )
/*++

Routine Description:

  Gets the first FID (file identifier descriptor) for the given
  directory.

Arguments:

  Dir : The directory whose first FID is to be read.
  File : The file identifier descriptor which has to be update
  Block : The block in the actual UDF NSR_FID will reside

Return Value:

  ESUCCESS if successful otherwise appropriate error code

--*/
{
  ARC_STATUS Status = ENOENT;
  UDF_FILE_IDENTIFIER Ident = {0};
  NSR_FID UNALIGNED *Fid;

  Status = UDFSFileReadBlock(Dir, 0, UDF_BLOCK_SIZE, Block);

  Fid = UDF_BLOCK_TO_FID(Block, &Ident);

  if ((Status == ESUCCESS) && (Fid->Destag.Ident == DESTAG_ID_NSR_FID)) {
    File->BlockIdx = 0; // relative to the file's data
    File->Offset = 0;
  }

  return Status;
}

#define UDF_NEXT_BLOCK(_Block) ((PUDF_BLOCK)((PUCHAR)_Block + UDF_BLOCK_SIZE))

BOOLEAN
UDFSCurrentFIDSpansBlock(
  IN NSR_FID UNALIGNED *Fid,
    IN PUDF_FILE_IDENTIFIER File
  )
{
  BOOLEAN Result = ((File->Offset + UDF_FID_LEN(Fid)) > UDF_BLOCK_SIZE) ? TRUE : FALSE;

#ifdef UDF_DEBUG
  if (Result)
    BlPrint("Current Fid Spans block\r\n");
#endif

  return Result;
}

BOOLEAN
UDFSNextFidSpansBlock(
  IN PUDF_FILE_IDENTIFIER CurrFile,
  IN PUDF_BLOCK Block
  )
{
  BOOLEAN Result = FALSE;
  NSR_FID UNALIGNED *CurrFid = UDF_BLOCK_TO_FID(Block, CurrFile);

  if (!UDFSCurrentFIDSpansBlock(CurrFid, CurrFile)) {
    ULONG RemainingSize = UDF_BLOCK_SIZE - (CurrFile->Offset + UDF_FID_LEN(CurrFid));

    if (RemainingSize < 38)
      Result = TRUE;
    else {
      UDF_FILE_IDENTIFIER NextFile = *CurrFile;
      NSR_FID UNALIGNED *NextFid = 0;

      NextFile.Offset += UDF_FID_LEN(CurrFid);
      NextFid = UDF_BLOCK_TO_FID(Block, &NextFile);

      if (NextFile.Offset + UDF_FID_LEN(NextFid) > UDF_BLOCK_SIZE)
        Result = TRUE;
    }
  }

#ifdef UDF_DEBUG
  if (Result)
    BlPrint("Next Fid Spans block\r\n");
#endif

  return Result;
}


ARC_STATUS
UDFSDirGetNextFID(
    IN PUDF_FILE_DIRECTORY Dir,
    OUT PUDF_FILE_IDENTIFIER File,
    IN OUT PUDF_BLOCK Block
    )
/*++

Routine Description:

  Reads the next FID, for the specified Directory. The next FID
  is based on contents of the "File" and "Block" arguments.

Arguments:

  Dir : The directory whose next FID is to be found
  File : The FID returned from previous UDFSDirGetFirstFID() or
         UDFSDirGetNextFID() call.
  Block : The block returned from previous UDFSDirGetFirstFID() or
          UDFSDirGetNextFID() call.

Return Value:

  Both File and Block arguments are updated as neccessary.
  ESUCCESS if successful otherwise appropriate error code

--*/
{
  ARC_STATUS  Status = ESUCCESS;
  NSR_FID UNALIGNED *Fid = UDF_BLOCK_TO_FID(Block, File);
  USHORT      FidLen = UDF_FID_LEN(Fid);
  UDF_FILE_IDENTIFIER FileId = *File;

  if (UDFSCurrentFIDSpansBlock(Fid, &FileId)) {
    FileId.BlockIdx++;
    FileId.Offset = (FileId.Offset + FidLen) % UDF_BLOCK_SIZE;
    memcpy(Block, (PUCHAR)Block + UDF_BLOCK_SIZE, UDF_BLOCK_SIZE);
  } else {
    if (UDFSNextFidSpansBlock(File, Block)) {
      Status = UDFSFileReadBlock(Dir, FileId.BlockIdx + 1, UDF_BLOCK_SIZE,
                          UDF_NEXT_BLOCK(Block));
    }

    FileId.Offset = FileId.Offset + FidLen;
  }

  //
  // make sure that the FID is valid
  //
  if (Status == ESUCCESS) {
    Fid = UDF_BLOCK_TO_FID(Block, &FileId);
    Status = (Fid->Destag.Ident == DESTAG_ID_NSR_FID) ? ESUCCESS : ENOENT;
  }

  if (Status == ESUCCESS) {
    *File = FileId;
  }


  return Status;
}

ARC_STATUS
UDFSDirGetFileByEntry(
    IN PUDF_FILE_DIRECTORY Dir,
    IN PUDF_FILE_IDENTIFIER Fid,
  IN PUDF_BLOCK Block,
    OUT PUDF_FILE_DIRECTORY File
    )
{
  ARC_STATUS Status = ESUCCESS;
  NSR_FID UNALIGNED *FileId = UDF_BLOCK_TO_FID(Block, Fid);
  PUCHAR UBlock[UDF_BLOCK_SIZE+256] = {0};
  PUCHAR IcbBlock = ALIGN_BUFFER(UBlock);

  File->Volume = Dir->Volume;
  File->FileId = *Fid;
  File->IsDirectory = UDF_FID_IS_DIRECTORY(FileId);
  File->IcbBlk = FileId->Icb.Start.Lbn;

  //
  // Get Hold of the ICB block and find the starting extent
  //
  Status = UDFSVolumeReadBlock(Dir->Volume, File->IcbBlk, IcbBlock);

  if (Status == ESUCCESS) {
    ICBFILE  UNALIGNED *Icb = (ICBFILE UNALIGNED *)(IcbBlock);

    File->StartDataBlk = (UDF_ICB_GET_AD(Icb, 0))->Start;
    File->Size = Icb->InfoLength;
    File->NumExtents = (UCHAR)UDF_ICB_NUM_ADS(Icb);
  }

  return Status;
}

ARC_STATUS
UDFSDirGetFile(
    IN PUDF_FILE_DIRECTORY Dir,
    IN PCHAR Name,
    OUT PUDF_FILE_DIRECTORY File
    )
/*++

Routine Description:

  Given an UDF directory gets the file/directory with the
  specified name.

Arguments:

  Dir : The directory which contains the required file/directory
  Name : The directory/file which has to be looked for.
  File : The directory or file which was requested.

Return Value:

  ESUCCESS if successful otherwise an approriate error code.

--*/
{
  UCHAR  UBlock[UDF_BLOCK_SIZE * 2 + 256] = {0};
  PUCHAR Block = ALIGN_BUFFER(UBlock);
  UDF_FILE_IDENTIFIER  Fid;
  ARC_STATUS  Status; //UDFSDirGetFirstFID(Dir, &Fid, Block);
  BOOLEAN Found = FALSE;
  NSR_FID UNALIGNED *FileId;
  WCHAR UUniBuffer[257];
  PWCHAR UniBuffer = UDFS_ALIGN_BUFFER(UUniBuffer, sizeof(WCHAR));
  UNICODE_STRING UniName;
  CSTRING AnsiName;

  Status = UDFSDirGetFirstFID(Dir, &Fid, Block);

  UniName.Buffer = UniBuffer;
  AnsiName.Buffer = Name;
  AnsiName.Length = (USHORT) strlen(Name);

  while(!Found && (Status == ESUCCESS)) {
    FileId = UDF_BLOCK_TO_FID(Block, &Fid);

    if (!UDF_FID_SKIP(FileId)) {
      UDFSInitUniStrFromDString(&UniName, UDF_FID_NAME(FileId), FileId->FileIDLen);
      Found = (BOOLEAN) (UDFSCompareAnsiUniNames(AnsiName, UniName) == EqualTo);
    }

    if (!Found) {
      Status = UDFSDirGetNextFID(Dir, &Fid, Block);
    }
  }

  if (!Found)
    Status = ENOENT;
  else {
    Status = UDFSDirGetFileByEntry(Dir, &Fid, Block, File);
  }

  return Status;
}

//
// Cache method implementations
//
ULONG
UDFCachePutEntry(
    IN OUT PUDF_CACHE_ENTRY Cache,
    IN PCHAR Name,
    IN PUDF_FILE_DIRECTORY File
    )
/*++

Routine Description:

  Puts the given file entry into the specified cache,
  using the given name as key.

Arguments:

  Cache - The cache to be operated upon
  Name - The key for the entry to be put in
  File - The file entry to be cached.

Return Value:

  If successful, Index for the entry into the Cache table
  where the given entry was cached otherwise -1.

--*/
{
  ULONG Index;

  for (Index=0; Index < UDF_MAX_CACHE_ENTRIES; Index++) {
      if (Cache[Index].Usage == 0)
          break;
  }

  if (Index == UDF_MAX_CACHE_ENTRIES)
      Index = INVALID_CACHE_ID;
  else {
      strcpy(Cache[Index].Name, Name);
      Cache[Index].File = *File;
      Cache[Index].Usage = 1;
  }

  return Index;
}

ULONG
UDFCacheGetEntryByName(
    IN OUT PUDF_CACHE_ENTRY Cache,
    IN PCHAR Name,
    IN BOOLEAN Increment
    )
/*++

Routine Description:

  Searches for a given entry in the Cache and returns
  the index to that entry if found.

Arguments:

  Cache - The cache to the operated upon
  Name - The key (name of file/directory) to be used
         for searching
  Increment - Indicates whether to increment the usage
              of the entry if one is found

Return Value:

  If successful, Index for the entry into the Cache table
  where the given entry was cached otherwise -1.

--*/
{
  ULONG   Index;

  for (Index=0; Index < UDF_MAX_CACHE_ENTRIES; Index++) {
    if ((Cache[Index].Usage) &&
            (UDFSCompareStrings(Name, Cache[Index].Name) == EqualTo)) {
      //
      // found the required entry
      //
      if (Increment)
        Cache[Index].Usage++;

      break;
    }
  }

  if (Index == UDF_MAX_CACHE_ENTRIES)
      Index = INVALID_CACHE_ID;

  return Index;
}

ULONG
UDFCacheGetBestEntryByName(
  IN PUDF_CACHE_ENTRY Cache,
  IN PCHAR Name
  )
/*++

Routine Description:

  Searches for a closest matching entry in the Cache
  and returns the index to that entry if found.

  For e.g. if the cache contains "\", "\a", "\a\b",
  "\a\b\e\f\g" entries and "\a\b\c\d" is requested then
  "\a\b" entry will be returned

Arguments:

  Cache - The cache to the operated upon
  Name - The key (name of file/directory) to be used
         for searching

Return Value:

  If successful, Index for the entry into the Cache table
  where the matched entry was cached otherwise -1.

--*/
{
  ULONG   Index = INVALID_CACHE_ID;
  CHAR    NameBuff[256];
  STRING  Str;

  if (Name)
    strcpy(NameBuff, Name);
  else
    NameBuff[0] = 0;

  Str.Buffer = NameBuff;
  Str.Length = (USHORT) strlen(NameBuff);

  while (Str.Length && (Index == INVALID_CACHE_ID)) {
    Index = UDFCacheGetEntryByName(Cache, Str.Buffer, FALSE);

    if (Index == INVALID_CACHE_ID) {
      while (Str.Length && (Str.Buffer[Str.Length-1] != '\\'))
        Str.Length--;

      if (Str.Length) {
        if (Str.Length != 1)
          Str.Buffer[Str.Length-1] = 0;
        else
          Str.Buffer[Str.Length] = 0;
      }
    }
  }

  return Index;
}

VOID
UDFCacheFreeEntry(
    IN OUT PUDF_CACHE_ENTRY Cache,
    IN ULONG Idx
    )
/*++

Routine Description:

  Decrements the usage count for an entry in the
  Cache.

  Note : All the traversed directories are always
  cached permanently so this method as no effect on directories.

Arguments:

  Cache - Cache to be operated upon
  Idx - Index of the Cache entry which has to be freed


Return Value:

  None.

--*/
{
  if (!Cache[Idx].File.IsDirectory) {
    if (Cache[Idx].Usage)
      Cache[Idx].Usage--;
  }
}

VOID
UDFCacheIncrementUsage(
    IN OUT PUDF_CACHE_ENTRY Cache,
    IN ULONG Idx
    )
/*++

Routine Description:

  Increments the usage for the given entry in the cache.

  Note: Multiple open calls for the same file will result
  in the cache entry being resued and hence the usage will
  also be incremented.

Arguments:

  Cache - The Cache to the operated upon.
  Idx - Index to the cache entry which has to incremented

Return Value:

  None

--*/
{
  if (!Cache[Idx].File.IsDirectory)
    Cache[Idx].Usage++;
}

VOID
UDFCacheDecrementUsage(
    IN OUT PUDF_CACHE_ENTRY Cache,
    IN ULONG Idx
    )
/*++

Routine Description:

  Decrements the usage for the given entry in the cache.

  Note: Multiple open calls for the same file will result
  in the cache entry being resued and hence the usage will
  also be incremented. Each successive close call of the
  same file will result in this usage count to be decremented
  until it becomes 0, when the cache slot can be reused
  for other file/directory.

Arguments:

  Cache - Cache to be operated upon.
  Idx - Index to the Cache entry, whose usage count is
        to be decremented

Return Value:

  None

--*/
{
  if (!Cache[Idx].File.IsDirectory && Cache[Idx].Usage)
    Cache[Idx].Usage--;
}

#ifdef UDF_TESTING

//
// These are the temporary functions needed for testing
// this code in the user mode
//
ARC_STATUS
W32DeviceReadDisk(
      IN ULONG DeviceId,
      IN ULONG Lbo,
      IN ULONG ByteCount,
      IN OUT PVOID Buffer
      );

ARC_STATUS
UDFSReadDisk(
    IN ULONG DeviceId,
    IN ULONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer,
    IN BOOLEAN CacheNewData
    )
{
  return W32DeviceReadDisk(DeviceId, Lbo, ByteCount, Buffer);
}
#else

//
//  Internal support routine
//

ARC_STATUS
UDFSReadDisk(
    IN ULONG DeviceId,
    IN ULONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer,
    IN BOOLEAN CacheNewData
    )

/*++

Routine Description:

    This routine reads in zero or more sectors from the specified device.

Arguments:

    DeviceId - Supplies the device id to use in the arc calls.

    Lbo - Supplies the LBO to start reading from.

    ByteCount - Supplies the number of bytes to read.

    Buffer - Supplies a pointer to the buffer to read the bytes into.

    CacheNewData - Whether to cache new data read from the disk.

Return Value:

    ESUCCESS is returned if the read operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    LARGE_INTEGER LargeLbo;
    ARC_STATUS Status;
    ULONG i;
    LONGLONG  Offset = Lbo * UDF_BLOCK_SIZE;

#ifdef UDF_DEBUG
    BlPrint("UDFSReadDisk(%d, %d, %d)\r\n", DeviceId, Lbo, ByteCount);
#endif

    //
    //  Special case the zero byte read request
    //

    if (ByteCount == 0) {

        return ESUCCESS;
    }

    //
    // Issue the read through the cache.
    //

    LargeLbo.QuadPart = Offset;
    Status = BlDiskCacheRead(DeviceId,
                             &LargeLbo,
                             Buffer,
                             ByteCount,
                             &i,
                             CacheNewData);

    if (Status != ESUCCESS) {

        return Status;
    }

    //
    //  Make sure we got back the amount requested
    //

    if (ByteCount != i) {

        return EIO;
    }

    //
    //  Everything is fine so return success to our caller
    //
    return ESUCCESS;
}

#endif // for UDF_TESTING


COMPARISON_RESULTS
UDFSCompareStrings(
    IN PCHAR Str1,
    IN PCHAR Str2
    )
/*++

Routine Description:

  Compares to single byte strings (pointers).

Arguments:

  Str1 : first string
  Str2 : second string

Return Value:

    LessThan    if Str1 is lexically less than Str2
    EqualTo     if Str1 is lexically equal to Str2
    GreaterThan if Str1 is lexically greater than Str2

--*/
{
    STRING  Obj1, Obj2;

    Obj1.Buffer = Str1;
    Obj1.Length = Str1 ? TRUNCATE_SIZE_AT_USHORT_MAX(strlen(Str1)) : 0;

    Obj2.Buffer = Str2;
    Obj2.Length = Str2 ? TRUNCATE_SIZE_AT_USHORT_MAX(strlen(Str2)) : 0;

    return UDFSCompareAnsiNames(&Obj1, &Obj2);
}

COMPARISON_RESULTS
UDFSCompareAnsiNames(
    IN PSTRING Name1,
    IN PSTRING Name2
    )

/*++

Routine Description:

    This routine takes two names and compare them ignoring case.  This
    routine does not do implied dot or dbcs processing.

Arguments:

    Name1 - Supplies the first name to compare

    Name2 - Supplies the second name to compare

Return Value:

    LessThan    if Name1 is lexically less than Name2
    EqualTo     if Name1 is lexically equal to Name2
    GreaterThan if Name1 is lexically greater than Name2

--*/

{
    ULONG i;
    ULONG MinimumLength;

    //
    //  Compute the smallest of the two name lengths
    //

    MinimumLength = (Name1->Length < Name2->Length ? Name1->Length : Name2->Length);

    //
    //  Now compare each character in the names.
    //

    for (i = 0; i < MinimumLength; i += 1) {

        if (TOUPPER(Name1->Buffer[i]) < TOUPPER(Name2->Buffer[i])) {

            return LessThan;
        }

        if (TOUPPER(Name1->Buffer[i]) > TOUPPER(Name2->Buffer[i])) {

            return GreaterThan;
        }
    }

    //
    //  The names compared equal up to the smallest name length so
    //  now check the name lengths
    //

    if (Name1->Length < Name2->Length) {

        return LessThan;
    }

    if (Name1->Length > Name2->Length) {

        return GreaterThan;
    }

    return EqualTo;
}


BOOLEAN
UDFSVerifyPathName(
  IN PCHAR  Name
  )
/*++

Routine Description:

  Checks to see if the given path name is valid.

Arguments:

  Name : path name to the verified.

Return Value:

  TRUE if the path name is valid otherwise false

--*/
{
  BOOLEAN Result = Name ? TRUE : FALSE;

  if (Result) {
    USHORT  Length = (USHORT) strlen(Name);

    if (Length && (Length <= 256)) {
      if (Length == 1) {
        Result = (Name[0] == '\\');
      } else {
        Result = (Name[Length-1] != '\\') &&
                  (Name[0] == '\\');
      }
    }
    else
      Result = FALSE;
  }

  return Result;
}

USHORT
UDFSCountPathComponents(
  IN PCHAR Name
  )
/*++

Routine Description:

  Counts the number of the components making
  up the path, separated by '\\' separator

Arguments:

  Name : The path name whose components are to be
  counted

Return Value:

  The number of components which make up the
  given path.

--*/
{
  USHORT Result = (USHORT)-1;

  if (Name && Name[0]) {
    PCHAR Temp = strchr(Name + 1, '\\');

    if (Temp) {
      Result = 0;

      while (Temp) {
        Result++;
        Temp = strchr(Temp + 1, '\\');
      }
    } else {
      Result = 1; // no separators
    }
  }

  return Result;
}

BOOLEAN
UDFSGetPathComponent(
  IN PCHAR Name,
  IN USHORT ComponentIdx,
  OUT PCHAR ReqComponent
  )
/*++

Routine Description:

  Retrieves the requested component from the given
  path name.

Arguments:

  Name : The path name whose component is to be returned
  ComponentIdx : The index (zero based) for the requested
                 component
  RequiredComponent : The requested component, if found.

Return Value:

  TRUE if the component was found other wise FALSE

--*/
{
  PCHAR   Component = 0;
  USHORT  Count = 0;

  //
  // get hold of the component starting position
  //
  if (Name && Name[0]) {
    if (ComponentIdx) {
      Component = Name;

      while (Component && (Count < ComponentIdx)) {
        Component = strchr(Component + 1, '\\');
        Count++;
      }

      if (Component && (Component[0] == '\\'))
        Component++;
    } else {
      Component = (Name[0] == '\\') ? Name + 1 : Name;
    }
  }

  //
  // get ending position of the component
  //
  if (Component && Component[0] && (Component[0] != '\\')) {
    PCHAR Temp = strchr(Component, '\\');
    ULONG Length = Temp ? (ULONG)(Temp - Component) : (ULONG)strlen(Component);

    strncpy(ReqComponent, Component, Length);
    ReqComponent[Length] = 0;
  }
  else {
    ReqComponent[0] = 0;
  }

  return (ReqComponent[0] != 0);
}


VOID
UDFSInitUniStrFromDString(
  OUT PUNICODE_STRING UniStr,
  IN PUCHAR Buffer,
  IN ULONG Length
  )
/*++

Routine Description:

  Initializes a given unicode string.

Arguments:

  UniStr - The unicode string to initialize
  Buffer - The buffer pointing to the unicode string
  Length - The length of the d-string as recorded

Return Value:

  Initialized unicode string in "UniStr"

--*/
{
  UCHAR Step = 0;
  PUCHAR End = Buffer + Length;
  PUCHAR Curr;
  PWCHAR Dest = UniStr->Buffer;
  ULONG DestLen = 0;
  BOOLEAN Swap = FALSE;

  if (Buffer && Length) {
    if (*Buffer == 0x10) {
      Step = 2;
      Swap = (Buffer[1] == 0);  // hack for ISO long file names + UDF bridge sessions
    } else {
      Step = 1;
    }

    for (Curr = Buffer + 1; Curr < End; Curr += Step, Dest++, DestLen += Step) {
      if (Swap) {
        // swap copy !!!
        *((UCHAR *)(Dest)) = *((UCHAR *)(Curr) + 1);
        *((UCHAR *)(Dest) + 1) = *((UCHAR *)(Curr));
      } else {
        if (Step == 1)
          *Dest = *Curr;
        else
          *Dest = *(PWCHAR)Curr;  // erroneous media ???
      }
    }

    UniStr->Length = (USHORT)DestLen;
    ((PWCHAR)UniStr->Buffer)[DestLen/2] = 0;  // null terminate the string
  }
}

VOID
UDFSToAnsiString(
  OUT PSTRING     AnsiStr,
  IN PUNICODE_STRING  UniStr
  )
/*++

Routine Description:

  Converts an single byte string to unicode string.

Arguments:

  AnsiStr - The convereted single byte string
  UniStr  - The unicode string which has to be converted

  Note : Each most significant byte of the Unicode characters
  is simply discarded.

Return Value:

  None

--*/
{
  ULONG Index;

  AnsiStr->Length = UniStr->Length / sizeof(WCHAR);

  for (Index=0; Index < AnsiStr->Length; Index++)
    AnsiStr->Buffer[Index] = (CHAR)(UniStr->Buffer[Index]);

  AnsiStr->Buffer[Index] = 0;
}

VOID
UDFSToUniString(
  OUT PUNICODE_STRING  UniStr,
  OUT PSTRING         AnsiStr
  )
/*++

Routine Description:

  Converts a given single byte string to an Unicode string.

Arguments:

  AnsiStr : The single byte string which has to be converted
  UniStr : The converted unicode string.

Return Value:

  None

--*/
{
  ULONG Index;

  UniStr->Length = AnsiStr->Length * sizeof(WCHAR);

  for (Index=0; Index < AnsiStr->Length; Index++)
    UniStr->Buffer[Index] = (WCHAR)(AnsiStr->Buffer[Index]);

  UniStr->Buffer[Index] = 0; // unicode null
}


int
UDFSCompareAnsiUniNames(
    IN CSTRING AnsiString,
    IN UNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine compares two names (one ansi and one unicode) for equality.

Arguments:

    AnsiString - Supplies the ansi string to compare

    UnicodeString - Supplies the unicode string to compare

Return Value:

    < 0 if AnsiString is approximately < than UnicodeString
    = 0 if AnsiString is approximately == UnicodeString
    > 0 otherwise

--*/

{
    ULONG i;
    ULONG Length;

#ifdef UDF_DEBUG
    {
      char    TempBuff[256] = {0};
      STRING  TempStr;

      TempStr.Buffer = TempBuff;
      UDFSToAnsiString(&TempStr, &UnicodeString);
      BlPrint("Comparing %s - %s\r\n", AnsiString.Buffer, TempStr.Buffer);
    }
#endif


    //
    //  Determine length for compare
    //

    if (AnsiString.Length * sizeof( WCHAR ) < UnicodeString.Length) {
        Length = AnsiString.Length;
    } else {
        Length = UnicodeString.Length / sizeof( WCHAR );
    }

    i = 0;
    while (i < Length) {

        //
        //  If the current char is a mismatch, return the difference
        //

        if (TOUPPER( (USHORT)AnsiString.Buffer[i] ) != TOUPPER( UnicodeString.Buffer[i] )) {
            return TOUPPER( (USHORT)AnsiString.Buffer[i] ) - TOUPPER( UnicodeString.Buffer[i] );
        }

        i++;
    }

    //
    //  We've compared equal up to the length of the shortest string.  Return
    //  based on length comparison now.
    //

    return AnsiString.Length - UnicodeString.Length / sizeof( WCHAR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\amd64\amd64.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    amd64.c

Abstract:

    This module contains routines necessary to support loading and
    transitioning into an AMD64 kernel.  The code in this module has
    access to amd64-specific defines found in amd64.h but not to i386-
    specific declarations found in i386.h.

Author:

    Forrest Foltz (forrestf) 20-Apr-2000

Environment:


Revision History:

--*/

//
// Here, we want the header files to be processed as though building for
// AMD64.  Make appropriate definitions and undefs.
//

#define _AMD64_
#define _M_AMD64
#define _WIN64

#undef _X86_
#undef X86
#undef _M_X86_
#undef _M_IX86

//
// Warning 4163 is "function unavailable as intrinsic"
//

#pragma warning(disable:4163)

//
// Warning 4235 is "nonstandard extension used", referring to __unaligned
//

#pragma warning(disable:4235)

//
// Warning 4391 is "incorrect return type for intrinsi function"
//

#pragma warning(disable:4391)

//
// Warning 4305 is "type cast truncation.  this stuff is compiled for 32
//                  bit, but requires 64 bit structures.  we should build
//                  a seperate header for amd64 that includes only the
//                  64 bit structures required and include them only for
//                  amd64
//
#pragma warning(disable:4305)


#include "bootx86.h"
#include "amd64prv.h"
#include <pcmp.inc>
#include <ntapic.inc>

//
// GDT: functino to convert selector to GDT entry.
//

PKGDTENTRY64
__inline
GDT_PTR (
    PGDT_64 Gdt,
    ULONG Selector
    )
{
    ULONG index;
    PKGDTENTRY64 entry;

    index = Selector & ~7;

    entry = (PKGDTENTRY64)((PUCHAR)Gdt + index);

    return entry;
}


//
// Interrupt descriptor table
//

typedef struct _IDT_64 {
    KIDTENTRY64 Entries[ MAXIMUM_IDTVECTOR + 1 ];
} IDT_64, *PIDT_64;

#define VIRTUAL_ADDRESS_BITS 48
#define VIRTUAL_ADDRESS_MASK (((ULONGLONG)1 << VIRTUAL_ADDRESS_BITS) - 1)

//
// Longmode ring0 code selector.  This actually lives in the middle of the
// transition data stream in amd64s.asm
//

extern USHORT BlAmd64_KGDT64_R0_CODE;

//
// Data values exported to amd64x86.c
//

const ULONG BlAmd64DoubleFaultStackSize = DOUBLE_FAULT_STACK_SIZE;
const ULONG BlAmd64KernelStackSize = KERNEL_STACK_SIZE;
const ULONG BlAmd64McaExceptionStackSize = KERNEL_MCA_EXCEPTION_STACK_SIZE;
const ULONG BlAmd64GdtSize = KGDT64_LAST;
const ULONG BlAmd64IdtSize = sizeof(IDT_64);

#define CONST_EXPORT(x) const ULONG BlAmd64_##x = x;
CONST_EXPORT(MSR_FS_BASE)
CONST_EXPORT(MSR_GS_BASE)
CONST_EXPORT(KGDT64_SYS_TSS)
CONST_EXPORT(MSR_EFER)
CONST_EXPORT(TSS_IST_PANIC)
CONST_EXPORT(TSS_IST_MCA)

const ULONG64 BlAmd64_LOCALAPIC = LOCALAPIC;
const ULONG64 BlAmd64UserSharedData = KI_USER_SHARED_DATA;

//
// Flags to be enabled in the EFER MSR before transitioning to long mode
//

const ULONG BlAmd64_MSR_EFER_Flags = MSR_LME | MSR_SCE | MSR_NXE;

//
// Array of address bit decode counts and recursive mapping bases,
// one for each level of the mapping
// 

AMD64_MAPPING_INFO BlAmd64MappingLevels[ AMD64_MAPPING_LEVELS ] = 
    {
      { PTE_BASE, PTI_MASK_AMD64, PTI_SHIFT },
      { PDE_BASE, PDI_MASK_AMD64, PDI_SHIFT },
      { PPE_BASE, PPI_MASK,       PPI_SHIFT },
      { PXE_BASE, PXI_MASK,       PXI_SHIFT }
    };

//
// BlAmd64TopLevelPte refers to the physical page number of the Page Map
// Level 4 (PML4) table.
//
// BlAmd64TopLevelPte is not really a page table entry and so does not
// actually exist as an element within a page table.  It exists only as
// a convenience to BlAmd64CreateAmd64Mapping().
//

HARDWARE_PTE BlAmd64TopLevelPte;

//
// PAGE_MAP_LEVEL_4 yields the identity-mapped (physical) address of the
// PML4 table.
//

#define PAGE_MAP_LEVEL_4 \
    ((PPAGE_TABLE)(BlAmd64TopLevelPte.PageFrameNumber << PAGE_SHIFT))

//
// Special PFN for BlAmd64CreateMapping
//

#define PFN_NO_MAP ((PFN_NUMBER)-1)

//
// Size of the VA mapped by a level 0 page table
//

#define PAGE_TABLE_VA ((POINTER64)(PTES_PER_PAGE * PAGE_SIZE))

//
// Prototypes for local functions
//

ARC_STATUS
BlAmd64CreateMappingWorker(
    IN     ULONGLONG Va,
    IN     PFN_NUMBER Pfn,
    IN     ULONG MappingLevel,
    IN OUT PHARDWARE_PTE UpperLevelPte
    );

VOID
BlAmd64MakePteValid(
    IN PHARDWARE_PTE Pte,
    IN PFN_NUMBER Pfn
    );

VOID
BlAmd64ClearTopLevelPte(
    VOID
    )

/*++

Routine Description:

    This routine simply clears BlAmd64TopLevelPte.

Arguments:

    None.

Return Value:

    None.

--*/

{

    *(PULONG64)&BlAmd64TopLevelPte = 0;
}

ARC_STATUS
BlAmd64CreateMapping(
    IN ULONGLONG Va,
    IN PFN_NUMBER Pfn
    )

/*++

Routine Description:

    This function maps a virtual address into a 4-level AMD64 page mapping
    structure.

Arguments:

    Va - Supplies the 64-bit virtual address to map

    Pfn - Supplies the 64-bit physical page number to map the address to

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    ARC_STATUS status;

    status = BlAmd64CreateMappingWorker( Va & VIRTUAL_ADDRESS_MASK,
                                         Pfn,
                                         AMD64_MAPPING_LEVELS - 1,
                                         &BlAmd64TopLevelPte );

    return status;
}

ARC_STATUS
BlAmd64CreateMappingWorker(
    IN     ULONGLONG Va,
    IN     PFN_NUMBER Pfn,
    IN     ULONG MappingLevel,
    IN OUT PHARDWARE_PTE UpperLevelPte
    )

/*++

Routine Description:

    This function creates an address mapping in a single level of an AMD64
    4-level mapping structure.  It is called only by BlCreateMapping
    and by itself, recursively.

Arguments:

    Va - Supplies the 64-bit virtual address to map.  This address has already
         had any insignificant upper bits masked via VIRTUAL_ADDRESS_MASK.

    Pfn - Supplies the 64-bit physical page number to map the address to.  If
          Pfn == PFN_NO_MAP, then all of the page tables are put into
          place to support the mapping but the level 0 pte itself is not
          actually filled in.  This is used to create the HAL's VA mapping
          area.

    MappingLevel - The mapping level in which to create the appropriate
        mapping.  Must be 0, 1, 2 or 3.

    UpperLevelPte - A pointer to the parent PTE that refers to the page
        at this mapping level.  If no page exists at this level for this
        address, then this routine will allocate one and modify
        UpperLevelPte appropriately.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    PFN_NUMBER pageTablePfn;
    PAMD64_PAGE_TABLE pageTable;
    ULONGLONG va;
    PAMD64_MAPPING_INFO mappingInfo;
    ULONG pteIndex;
    PHARDWARE_PTE pte;
    ARC_STATUS status;
    BOOLEAN newPage;

    mappingInfo = &BlAmd64MappingLevels[ MappingLevel ];

    if (UpperLevelPte->Valid == 0) {

        //
        // A new page table must be allocated.
        //

        newPage = TRUE;
        pageTable = BlAmd64AllocatePageTable();
        if (pageTable == NULL) {
            return ENOMEM;
        }

        //
        // Reference the new page table with the parent PTE
        // 

        pageTablePfn = (ULONG)pageTable >> PAGE_SHIFT;
        BlAmd64MakePteValid( UpperLevelPte, pageTablePfn );

        if (MappingLevel == (AMD64_MAPPING_LEVELS - 1)) {

            //
            // We have just allocated the top-level page.  Insert a
            // recursive mapping here.
            //

            pteIndex = (ULONG)((mappingInfo->RecursiveMappingBase >>
                                mappingInfo->AddressShift) &
                               mappingInfo->AddressMask);

            pte = &pageTable->PteArray[ pteIndex ];

            BlAmd64MakePteValid( pte, pageTablePfn );
        }

    } else {

        //
        // A page table structure already exists for this level.
        //

        newPage = FALSE;
        pageTablePfn = UpperLevelPte->PageFrameNumber;
        pageTable = (PAMD64_PAGE_TABLE)((ULONG)pageTablePfn << PAGE_SHIFT);
    }

    //
    // Derive a pointer to the appropriate PTE within the page table
    // 

    pteIndex =
        (ULONG)(Va >> mappingInfo->AddressShift) & mappingInfo->AddressMask;

    pte = &pageTable->PteArray[ pteIndex ];

    if (MappingLevel == 0) {

        if (Pfn != PFN_NO_MAP) {

            //
            // This is an actual level 0, or PTE, entry.  Just set it with
            // the Pfn that was passed in.
            //
    
            BlAmd64MakePteValid( pte, Pfn );

        } else {

            //
            // This is a special HAL mapping, one that ensures that all
            // levels of page table are in place to support this mapping
            // but doesn't actually fill in the level 0 PTE.
            //
            // So do nothing here except break the recursion.
            //
        }

    } else {

        //
        // More mapping levels to go, call this function recursively and
        // process the next level.
        //

        status = BlAmd64CreateMappingWorker( Va,
                                             Pfn,
                                             MappingLevel - 1,
                                             pte );
        if (status != ESUCCESS) {
            return status;
        }
    }

    if (newPage != FALSE) {

        //
        // A new page table was allocated, above.  Recursively map
        // it within the PTE_BASE region.
        //

        va = (Va >> mappingInfo->AddressShift);
        va *= sizeof(HARDWARE_PTE);
        va += mappingInfo->RecursiveMappingBase;

        status = BlAmd64CreateMapping( va, pageTablePfn );
        if (status != ESUCCESS) {
            return status;
        }
    }

    return ESUCCESS;
}


VOID
BlAmd64MakePteValid(
    IN OUT PHARDWARE_PTE Pte,
    IN PFN_NUMBER Pfn
    )

/*++

Routine Description:

    This routine fills an AMD64 Pte with the supplied Pfn and makes it
    valid.

Arguments:

    Pte - Supplies a pointer to the Pte to make valid.

    Pfn - Supplies the page frame number to set in the Pte.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    //
    // Make sure we're not just overwriting a PFN in an already
    // valid PTE.
    //

    ASSERT( Pte->Valid == 0 || Pte->PageFrameNumber == Pfn );

    Pte->PageFrameNumber = Pfn;
    Pte->Valid = 1;
    Pte->Write = 1;
    Pte->Accessed = 1;
    Pte->Dirty = 1;
}

VOID
BlAmd64BuildGdtEntry(
    IN PGDT_64 Gdt,
    IN USHORT Selector,
    IN POINTER64 Base,
    IN ULONGLONG Limit,
    IN ULONG Type,
    IN ULONG Dpl,
    IN BOOLEAN LongMode,
    IN BOOLEAN DefaultBig
    )

/*++

Routine Description:

    This routine fills in an AMD64 GDT entry.

Arguments:

    Gdt - Supplies a pointer to the GDT.

    Selector - Segment selector of the GDT entry within Gdt.

    Base - Base address value of the descriptor.

    Limit - Limit value of the descriptor.

    Type - 5-bit type value of the descriptor.

    Dpl - Priviledge value of the descriptor.

    LongMode - Indicates whether this is a longmode descriptor (valid only
               for code segment descriptors).

    DefaultBig - Supplies the value for the default/big field in the
                 descriptor.

Return Value:

    None.

--*/

{
    ULONG limit20;
    PKGDTENTRY64 gdtEntry;

    KGDT_BASE gdtBase;
    KGDT_LIMIT gdtLimit;

    gdtEntry = GDT_PTR(Gdt,Selector);

    //
    // Set the Base and LongMode fields
    //

    gdtBase.Base = Base;

    gdtEntry->BaseLow = gdtBase.BaseLow;
    gdtEntry->Bits.BaseMiddle = gdtBase.BaseMiddle;
    gdtEntry->Bits.BaseHigh = gdtBase.BaseHigh;
    gdtEntry->Bits.LongMode = 0;

    if ((LongMode != FALSE) || (Type == TYPE_TSS64)) {

        //
        // All long GDT entries use a 64-bit base and have the longmode bit
        // set.
        //
        // In addition, a TSS GDT entry uses a 64-bit but does *not* set the
        // longmode bit.  This applies to an LDT entry as well, which is not
        // used in this OS.
        //

        if (Type != TYPE_TSS64) {
            gdtEntry->Bits.LongMode = 1;
        }

        gdtEntry->MustBeZero = 0;
        gdtEntry->BaseUpper = gdtBase.BaseUpper;
    }

    //
    // Set the Limit and Granularity fields
    //

    if (Limit > (1 << 20)) {
        limit20 = (ULONG)(Limit / PAGE_SIZE);
        gdtEntry->Bits.Granularity = 1;
    } else {
        limit20 = (ULONG)Limit;
        gdtEntry->Bits.Granularity = 0;
    }
    gdtLimit.Limit = limit20;
    gdtEntry->LimitLow = gdtLimit.LimitLow;
    gdtEntry->Bits.LimitHigh = gdtLimit.LimitHigh;

    //
    // Set Present = 1 unless this is a NULL descriptor
    //

    if (Type == 0) {
        gdtEntry->Bits.Present = 0;
    } else {
        gdtEntry->Bits.Present = 1;
    }

    //
    // Set remaining fields
    // 

    gdtEntry->Bits.Type = Type;
    gdtEntry->Bits.Dpl = Dpl;
    gdtEntry->Bits.DefaultBig = DefaultBig;
    gdtEntry->Bits.System = 0;
}


VOID
BlAmd64BuildAmd64GDT(
    IN PVOID SysTss,
    OUT PVOID Gdt
    )

/*++

Routine Description:

    This routine initializes the longmode Global Descriptor Table.

Arguments:

    SysTss - Supplies a 32-bit KSEG0_X86 pointer to the system TSS.

    Gdt - Supplies a 32-bit pointer to the Gdt to fill in.

Return Value:

    None.

--*/

{
    PGDT_64 gdt64;
    POINTER64 sysTss64;

    gdt64 = (PGDT_64)Gdt;

    //
    // KGDT64_NULL: NULL descriptor
    //

    BlAmd64BuildGdtEntry(gdt64,KGDT64_NULL,
             0,0,0,0,0,0);                  // Null selector, all zeros

    //
    // KGDT_R0_CODE: Kernel mode code
    //

    BlAmd64BuildGdtEntry(gdt64,KGDT64_R0_CODE,
             0,                             // Base and limit are ignored
             0,                             //  in a long-mode code selector
             TYPE_CODE,                     // Code segment: Execute/Read
             DPL_SYSTEM,                    // Kernel only
             TRUE,                          // Longmode
             FALSE);                        // Not 32-bit default

    //
    // KGDT_R0_STACK: Kernel mode stack
    //

    BlAmd64BuildGdtEntry(gdt64,KGDT64_R0_DATA,
             0,                             // Base and limit are ignored
             0,                             //  when in long-mode
             TYPE_DATA,                     // Data segment: Read/Write
             DPL_SYSTEM,                    // Kernel only
             FALSE,                         // Not longmode
             TRUE);                         // 32-bit default

    //
    // KDT_SYS_TSS: Kernel mode system task state
    //

    sysTss64 = PTR_64(SysTss);
    BlAmd64BuildGdtEntry(gdt64,KGDT64_SYS_TSS,
             sysTss64,                      // Base to be filled in at runtime
             sizeof(KTSS64),                // Contains only a KTSS64
             TYPE_TSS64,                    // Not busy TSS
             DPL_SYSTEM,                    // Kernel only
             FALSE,                         // Not longmode
             FALSE);                        // Not 32-bit default

    //
    // KGDT64_R3_CODE: User mode 64-bit code
    //

    BlAmd64BuildGdtEntry(gdt64,KGDT64_R3_CODE,
             0,                             // Base and limit are ignored
             0,                             //  in a long-mode code selector
             TYPE_CODE,                     // Code segment: Execute/Read
             DPL_USER,                      // User mode
             TRUE,                          // Longmode
             FALSE);                        // Not 32-bit default

    //
    // KGDT64_R3_CMCODE: User-mode 32-bit code. Flat 4 gig.  Note that we may
    // give Wow64 apps almost the entire 4GB address space.
    //

    BlAmd64BuildGdtEntry(gdt64,KGDT64_R3_CMCODE,
             0,                             // Base
             0xFFFFFFFF,                    // 4G limit
             TYPE_CODE,                     // Code segment: Execute/Read
             DPL_USER,                      // User mode
             FALSE,                         // Not longmode
             TRUE);                         // 32-bit default

    //
    // KGDT64_R3_DATA: User-mode 32-bit data.  Flat 4 gig.
    //                     

    BlAmd64BuildGdtEntry(gdt64,KGDT64_R3_DATA,
             0,                             // Base
             0xFFFFFFFF,                    // 4G limit
             TYPE_DATA,                     // Data segment: Read/Write
             DPL_USER,                      // User mode
             FALSE,                         // Not longmode
             TRUE);                         // 32-bit default

    //
    // KGDT64_R3_CMTEB: User-mode 32-bit TEB.  Flat 4K.
    //

    BlAmd64BuildGdtEntry(gdt64,KGDT64_R3_CMTEB,
             0,                             // Base
             0x0FFF,                        // 4K limit
             TYPE_DATA,                     // Data segment: Read/Write
             DPL_USER,                      // User mode
             FALSE,                         // Not longmode
             TRUE);                         // 32-bit default

    //
    // Set the code selector
    //

    BlAmd64_KGDT64_R0_CODE = KGDT64_R0_CODE;
}


ARC_STATUS
BlAmd64MapHalVaSpace(
    VOID
    )

/*++

Routine Description:

    This routine initializes the VA space reserved for the HAL.  This
    involves building all page tables necessary to support the mappings
    but not actually filling in any level 0 PTEs.

Arguments:

    None.

Return Value:

    ARC_STATUS - Status of operation.

--*/


{
    POINTER64 va;
    ULONG round;
    ULONG vaRemaining;
    ARC_STATUS status;

    //
    // The hal has a piece of VA space reserved for it, from HAL_VA_START to
    // HAL_VA_START + HAL_VA_SIZE - 1.
    //
    // This routine ensures that all necessary levels of page tables are
    // present to support any mappings that the hal might put there.
    //

    vaRemaining = HAL_VA_SIZE;
    va = HAL_VA_START;

    //
    // Round VA down to a page table boundary.
    //

    round = (ULONG)(va & (PAGE_TABLE_VA-1));
    va -= round;
    vaRemaining += round;

    while (TRUE) {

        //
        // Perform a "mapping".  The special PFN_NUMBER sets up all of
        // the page tables necessary to support the mapping, without
        // actually filling in a level 0 PTE.
        // 

        status = BlAmd64CreateMapping(va, PFN_NO_MAP);
        if (status != ESUCCESS) {
            return status;
        }

        if (vaRemaining <= PAGE_TABLE_VA) {
            break;
        }

        vaRemaining -= PAGE_TABLE_VA;
        va += PAGE_TABLE_VA;
    }

    return ESUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\vmode.c ===
#include "bldrx86.h"
#include "vmode.h"
#include "vga.h"

#define	SCREEN_WIDTH			(640)					/*	gfx mode resolution: width		*/
#define	SCREEN_HEIGHT			(480)					/*	gfx mode resolution: height		*/
#define	SCREEN_PIXELS			(SCREEN_WIDTH * SCREEN_HEIGHT)

#define VGA_ADR					((UCHAR*)0xA0000)		/*	beginning of VGA memory			*/
#define LINE_MEM_LENGTH			(SCREEN_WIDTH / 8)		/*	1 bit per pixel in every map	*/
#define MAP_PAGE_SZ				(64*1024)               /*	size of single map				*/

#define PROGRESS_BAR_MEM_OFS	(LINE_MEM_LENGTH * (SCREEN_HEIGHT - 40))	/*	starts at 20th line from the bottom	*/

#define BOOTBMP_FNAME "boot.bmp"
#define DOTSBMP_FNAME "dots.bmp"

BOOLEAN DisplayLogoOnBoot = FALSE;
BOOLEAN GraphicsMode = FALSE;

VOID
GrDisplayMBCSChar(
    IN PUCHAR   image,
    IN unsigned width,
    IN UCHAR    top,
    IN UCHAR    bottom
    );

extern unsigned CharacterImageHeight;

extern BOOLEAN  BlShowProgressBar;
extern int      BlMaxFilesToLoad;
extern int      BlNumFilesLoaded;


NTLDRGRAPHICSCONTEXT LoaderGfxContext = {0,0L,0L,0L,NULL /*,EINVAL,EINVAL*/};

#define DIAMETER (6)

VOID BlRedrawGfxProgressBar(VOID)	//	Redraws the progress bar (with the last percentage) 
{   
    if (BlShowProgressBar && BlMaxFilesToLoad) {
        BlUpdateProgressBar((BlNumFilesLoaded * 100) / BlMaxFilesToLoad);
	}
}    

#define	BMP_FILE_SIZE		(1024*1024)

#define	SMALL_BMP_SIZE		(1024)

UCHAR	empty_circle	[SMALL_BMP_SIZE];
UCHAR	simple_circle	[SMALL_BMP_SIZE];
UCHAR	left_2_circles	[SMALL_BMP_SIZE];
UCHAR	left_3_circles	[SMALL_BMP_SIZE];
UCHAR	left_4_circles	[SMALL_BMP_SIZE];
UCHAR	right_2_circles	[SMALL_BMP_SIZE];
UCHAR	right_3_circles	[SMALL_BMP_SIZE];
UCHAR	right_4_circles	[SMALL_BMP_SIZE];

#define	DOT_WIDTH	(13)
#define	DOT_HEIGHT	(13)
#define DOT_BLANK	(7)

#define	PROGRESS_BAR_Y_OFS	(340)
#define	PROGRESS_BAR_X_OFS	(130)
#define DOTS_IN_PBAR		(20)

#define	BITS(w)			((w)*4)
#define	BYTES(b)		(((b)/8)+(((b)%8)?1:0))
#define	DOTS(n)			(((n)*DOT_WIDTH)+(((n)-1)*DOT_BLANK))
#define	DOTS2BYTES(n)	(BYTES(BITS(DOTS(n))))

#define	SCANLINE	(7)

// #define INC_MOD(x) x = (x + 1) % (DOTS_IN_PBAR+5)
#define INC_MOD(x) x = (x + 1)

VOID PrepareGfxProgressBar (VOID)
{

    if (DisplayLogoOnBoot) {

		PaletteOff ();
        /*
		VidBitBlt (LoaderGfxContext.DotBuffer + sizeof(BITMAPFILEHEADER), 0, 0);

		VidScreenToBufferBlt (simple_circle,	0,							0,	DOTS(1),	DOT_HEIGHT,	 DOTS2BYTES(1));
		VidScreenToBufferBlt (left_2_circles,	0,							0,	DOTS(2),	DOT_HEIGHT,	 DOTS2BYTES(2));
		VidScreenToBufferBlt (left_3_circles,	0,							0,	DOTS(3),	DOT_HEIGHT,	 DOTS2BYTES(3));
		VidScreenToBufferBlt (left_4_circles,	0,							0,	DOTS(4),	DOT_HEIGHT,	 DOTS2BYTES(4));
		VidScreenToBufferBlt (right_2_circles,	3*(DOT_WIDTH+DOT_BLANK),	0,	DOTS(2),	DOT_HEIGHT,	 DOTS2BYTES(2));
		VidScreenToBufferBlt (right_3_circles,	2*(DOT_WIDTH+DOT_BLANK),	0,	DOTS(3),	DOT_HEIGHT,	 DOTS2BYTES(3));
		VidScreenToBufferBlt (right_4_circles,	DOT_WIDTH+DOT_BLANK,		0,	DOTS(4),	DOT_HEIGHT,	 DOTS2BYTES(4));
        */
		DrawBitmap ();
		// VidScreenToBufferBlt (empty_circle, PROGRESS_BAR_X_OFS, PROGRESS_BAR_Y_OFS, DOTS(1), DOT_HEIGHT, DOTS2BYTES(1));
		PaletteOn();

	}
	
}

VOID BlUpdateGfxProgressBar(ULONG fPercentage)
{
	static ULONG current = 0;
	static ULONG delay = 5;
	// ULONG x, xl;

    UNREFERENCED_PARAMETER( fPercentage );

    /*
    if (delay && delay--)
        return;

    if (DisplayLogoOnBoot && (current<(DOTS_IN_PBAR+5))) {

        x  = PROGRESS_BAR_X_OFS + ((current-5) * (DOT_WIDTH+DOT_BLANK));

		switch (current) {

		case 0:
   			VidBufferToScreenBlt (simple_circle,	PROGRESS_BAR_X_OFS,	PROGRESS_BAR_Y_OFS,	DOTS(1), DOT_HEIGHT, DOTS2BYTES(1));
            break;

		case 1:
   			VidBufferToScreenBlt (right_2_circles,	PROGRESS_BAR_X_OFS,	PROGRESS_BAR_Y_OFS,	DOTS(2), DOT_HEIGHT, DOTS2BYTES(2));
            break;

		case 2:
   			VidBufferToScreenBlt (right_3_circles,	PROGRESS_BAR_X_OFS,	PROGRESS_BAR_Y_OFS,	DOTS(3), DOT_HEIGHT, DOTS2BYTES(3));
            break;

		case 3:
   			VidBufferToScreenBlt (right_4_circles,	PROGRESS_BAR_X_OFS,	PROGRESS_BAR_Y_OFS,	DOTS(4), DOT_HEIGHT, DOTS2BYTES(4));
            break;

        case DOTS_IN_PBAR:
            xl = PROGRESS_BAR_X_OFS + ((DOTS_IN_PBAR-4) * (DOT_WIDTH+DOT_BLANK));
   			VidBufferToScreenBlt (left_4_circles,	xl,	PROGRESS_BAR_Y_OFS,	DOTS(4),	DOT_HEIGHT, DOTS2BYTES(4));
            VidBufferToScreenBlt (empty_circle,	x,	PROGRESS_BAR_Y_OFS,	DOTS(1),	    DOT_HEIGHT,	DOTS2BYTES(1));
            break;

        case DOTS_IN_PBAR+1:
            xl = PROGRESS_BAR_X_OFS + ((DOTS_IN_PBAR-3) * (DOT_WIDTH+DOT_BLANK));
   			VidBufferToScreenBlt (left_3_circles,	xl,	PROGRESS_BAR_Y_OFS,	DOTS(3),	DOT_HEIGHT, DOTS2BYTES(3));
            VidBufferToScreenBlt (empty_circle,	x,	PROGRESS_BAR_Y_OFS,	DOTS(1),	    DOT_HEIGHT,	DOTS2BYTES(1));
            break;

        case DOTS_IN_PBAR+2:
            xl = PROGRESS_BAR_X_OFS + ((DOTS_IN_PBAR-2) * (DOT_WIDTH+DOT_BLANK));
   			VidBufferToScreenBlt (left_2_circles,	xl,	PROGRESS_BAR_Y_OFS,	DOTS(2),	DOT_HEIGHT, DOTS2BYTES(2));
            VidBufferToScreenBlt (empty_circle,	x,	PROGRESS_BAR_Y_OFS,	DOTS(1),	    DOT_HEIGHT,	DOTS2BYTES(1));
            break;

        case DOTS_IN_PBAR+3:
            xl = PROGRESS_BAR_X_OFS + ((DOTS_IN_PBAR-1) * (DOT_WIDTH+DOT_BLANK));
   			VidBufferToScreenBlt (simple_circle,	xl,	PROGRESS_BAR_Y_OFS,	DOTS(1),	DOT_HEIGHT, DOTS2BYTES(1));
            VidBufferToScreenBlt (empty_circle,	x,	PROGRESS_BAR_Y_OFS,	DOTS(1),	    DOT_HEIGHT,	DOTS2BYTES(1));
            break;

        case DOTS_IN_PBAR+4:
            VidBufferToScreenBlt (empty_circle,	x,	PROGRESS_BAR_Y_OFS,	DOTS(1),	    DOT_HEIGHT,	DOTS2BYTES(1));
            break;

		default:
			xl = PROGRESS_BAR_X_OFS + ((current-4) * (DOT_WIDTH+DOT_BLANK));
			VidBitBlt (LoaderGfxContext.DotBuffer + sizeof(BITMAPFILEHEADER),	xl,	PROGRESS_BAR_Y_OFS);
            VidBufferToScreenBlt (empty_circle,	x,	PROGRESS_BAR_Y_OFS,	DOTS(1),	    DOT_HEIGHT,	DOTS2BYTES(1));
			break;

		}

		INC_MOD(current);

	}
    */

}

PUCHAR LoadBitmapFile (IN ULONG DriveId, PCHAR path)
{
    ULONG bmp_file = (ULONG)-1;
    ULONG file_size, size_read, page_count, actual_base;
	FILE_INFORMATION FileInfo;
	ARC_STATUS status = EINVAL;
	PUCHAR buffer = NULL;

    status = BlOpen (DriveId, path, ArcOpenReadOnly, &bmp_file);

	if (status==ESUCCESS) {	//	file opened Ok

	    status = BlGetFileInformation(bmp_file, &FileInfo);

		if (status == ESUCCESS) {
			
			file_size = FileInfo.EndingAddress.LowPart;
			page_count = (ULONG)(ROUND_TO_PAGES(file_size) >> PAGE_SHIFT);
			status = BlAllocateDescriptor ( MemoryFirmwareTemporary,
											0,
											page_count,
											&actual_base);

			if (status == ESUCCESS) {
				buffer = (PUCHAR)((ULONG_PTR)actual_base << PAGE_SHIFT);
				status = BlRead(bmp_file, buffer, file_size, &size_read);
			}

		} // getting file information

		BlClose(bmp_file);

	} // file opening

	return buffer;
}

VOID PaletteOff (VOID)
{
    if (DisplayLogoOnBoot) {
		InitPaletteConversionTable();
		InitPaletteWithBlack ();
	}
}

VOID PaletteOn (VOID)
{
    if (DisplayLogoOnBoot) {
		InitPaletteConversionTable();
		InitPaletteWithTable(LoaderGfxContext.Palette, LoaderGfxContext.ColorsUsed);
	}
}

VOID LoadBootLogoBitmap (IN ULONG DriveId, PCHAR path)	//	Loads ntldr bitmap and initializes
{														//	loader graphics context.
    PBITMAPINFOHEADER bih;
	CHAR path_fname [256];

    while (*path !='\\')
        path++;

	strcpy (path_fname, path);
	strcat (path_fname, "\\" BOOTBMP_FNAME);

	LoaderGfxContext.BmpBuffer = LoadBitmapFile (DriveId, path_fname);

	// read bitmap palette
	if (LoaderGfxContext.BmpBuffer != NULL) {	//	bitmap data read Ok
		bih = (PBITMAPINFOHEADER) (LoaderGfxContext.BmpBuffer + sizeof(BITMAPFILEHEADER));
		LoaderGfxContext.Palette = (PRGBQUAD)(((PUCHAR)bih) + bih->biSize);
		LoaderGfxContext.ColorsUsed = bih->biClrUsed ? bih->biClrUsed : 16;

        /*
		strcpy (path_fname, path);
		strcat (path_fname, "\\" DOTSBMP_FNAME);
		LoaderGfxContext.DotBuffer = LoadBitmapFile (DriveId, path_fname);
        */
	}

	DisplayLogoOnBoot = (BOOLEAN) ((LoaderGfxContext.BmpBuffer!=NULL)	&&
						         // (LoaderGfxContext.DotBuffer!=NULL)	&&
                                   (LoaderGfxContext.Palette!=NULL));
	
}

VOID DrawBitmap (VOID)
{
    if (DisplayLogoOnBoot)
		VidBitBlt (LoaderGfxContext.BmpBuffer + sizeof(BITMAPFILEHEADER), 0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\amd64\amd64prv.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    amd64prv.h

Abstract:

    This header file defines private interfaces shared between the following
    modules:

    amd64.c
    amd64s.asm
    amd64x86.c

Author:

    Forrest Foltz (forrestf) 20-Apr-00


Revision History:

--*/

#if !defined(_AMD64PRV_H_)
#define _AMD64PRV_H_

//
// 64-bit pointer and LONG_PTR fields are changed to this
//

typedef LONGLONG POINTER64;

//
// KSEG0 definitions for both the AMD64 and X86 platforms.  Note that
// these are duplicated from amd64.h and i386.h, respectively.
// 

#define KSEG0_BASE_AMD64  0xFFFFF80000000000UI64
#define KSEG0_SIZE_AMD64  0x0000000040000000UI64
#define KSEG0_LIMIT_AMD64 (KSEG0_BASE_AMD64 + KSEG0_SIZE_AMD64)

#define KSEG0_BASE_X86   0x80000000
#define KSEG0_SIZE_X86   0x40000000
#define KSEG0_LIMIT_X86  (KSEG0_BASE_X86 + KSEG0_SIZE_X86)

#define IS_KSEG0_PTR_X86(x)   (((x) >= KSEG0_BASE_X86)   && ((x) < KSEG0_LIMIT_X86))
#define IS_KSEG0_PTR_AMD64(x) (((x) >= KSEG0_BASE_AMD64) && ((x) < KSEG0_LIMIT_AMD64))

__inline
POINTER64
PTR_64(
    IN PVOID Pointer32
    )

/*++

Routine Description:

    This function is used by the loader to convert a 32-bit X86 KSEG0 pointer
    to a 64-bit AMD64 KSEG0 pointer.

Arguments:

    Pointer32 - Supplies the 32-bit KSEG0 pointer to convert.

Return value:

    Returns the equivalent 64-bit KSEG0 pointer.

--*/

{
    ULONG pointer32;
    ULONGLONG pointer64;

    if (Pointer32 == NULL) {
        return 0;
    }

    ASSERT( IS_KSEG0_PTR_X86((ULONG)Pointer32) != FALSE );

    pointer32 = (ULONG)Pointer32 - KSEG0_BASE_X86;
    pointer64 = KSEG0_BASE_AMD64 + pointer32;
    return (POINTER64)pointer64;
}

__inline
PVOID
PTR_32(
    IN POINTER64 Pointer64
    )

/*++

Routine Description:

    This function is used by the loader to convert a 64-bit AMD64 KSEG0
    pointer to a 32-bit X86 KSEG0 pointer.

Arguments:

    Pointer64 - Supplies the 64-bit KSEG0 pointer to convert.

Return value:

    Returns the equivalent 32-bit KSEG0 pointer.

--*/

{
    ULONG pointer32;

    if (Pointer64 == 0) {
        return NULL;
    }

    ASSERT( IS_KSEG0_PTR_AMD64(Pointer64) != FALSE );

    pointer32 = (ULONG)(Pointer64 - KSEG0_BASE_AMD64 + KSEG0_BASE_X86);
    return (PVOID)pointer32;
}

//
// Macros
//

#define PAGE_MASK ((1 << PAGE_SHIFT) - 1)

#define ROUNDUP_X(x,m) (((x)+(m)-1) & ~((m)-1))

//
// Size round up
//

#define ROUNDUP16(x)     ROUNDUP_X(x,16)
#define ROUNDUP_PAGE(x)  ROUNDUP_X(x,PAGE_SIZE)

//
// Shared PTE, PFN types
//

typedef ULONG PFN_NUMBER32, *PPFN_NUMBER32;
typedef ULONGLONG PFN_NUMBER64, *PPFN_NUMBER64;

#if defined(_AMD64_)

typedef ULONG        PTE_X86,    *PPTE_X86;
typedef HARDWARE_PTE PTE_AMD64,  *PPTE_AMD64;

#elif defined(_X86_)

typedef ULONGLONG    PTE_AMD64, *PPTE_AMD64;
typedef HARDWARE_PTE PTE_X86,   *PPTE_X86;

#else

#error "Target architecture not defined"

#endif

//
// Descriptor table descriptor
//

#pragma pack(push,1)
typedef struct DESCRIPTOR_TABLE_DESCRIPTOR {
    USHORT Limit;
    POINTER64 Base;
} DESCRIPTOR_TABLE_DESCRIPTOR, *PDESCRIPTOR_TABLE_DESCRIPTOR;
#pragma pack(pop)

//
// Structures found within the CM_PARTIAL_RESOURCE_DESCRIPTOR union
//

typedef struct _CM_PRD_GENERIC {
    PHYSICAL_ADDRESS Start;
    ULONG Length;
} CM_PRD_GENERIC, *PCM_PRD_GENERIC;

typedef struct _CM_PRD_PORT {
    PHYSICAL_ADDRESS Start;
    ULONG Length;
} CM_PRD_PORT, *PCM_PRD_PORT;

typedef struct _CM_PRD_INTERRUPT {
    ULONG Level;
    ULONG Vector;
    KAFFINITY Affinity;
} CM_PRD_INTERRUPT, *PCM_PRD_INTERRUPT;

typedef struct _CM_PRD_MEMORY {
    PHYSICAL_ADDRESS Start;
    ULONG Length;
} CM_PRD_MEMORY, *PCM_PRD_MEMORY;

typedef struct _CM_PRD_DMA {
    ULONG Channel;
    ULONG Port;
    ULONG Reserved1;
} CM_PRD_DMA, *PCM_PRD_DMA;

typedef struct _CM_PRD_DEVICEPRIVATE {
    ULONG Data[3];
} CM_PRD_DEVICEPRIVATE, *PCM_PRD_DEVICEPRIVATE;

typedef struct _CM_PRD_BUSNUMBER {
    ULONG Start;
    ULONG Length;
    ULONG Reserved;
} CM_PRD_BUSNUMBER, *PCM_PRD_BUSNUMBER;

typedef struct _CM_PRD_DEVICESPECIFICDATA {
    ULONG DataSize;
    ULONG Reserved1;
    ULONG Reserved2;
} CM_PRD_DEVICESPECIFICDATA, *PCM_PRD_DEVICESPECIFICDATA;

//
// Define page table structure.
//

#define PTES_PER_PAGE (PAGE_SIZE / sizeof(HARDWARE_PTE))

typedef HARDWARE_PTE  PAGE_TABLE[ PTES_PER_PAGE ];
typedef HARDWARE_PTE *PPAGE_TABLE;

typedef struct _AMD64_PAGE_TABLE {
    PTE_AMD64 PteArray[ PTES_PER_PAGE ];
} AMD64_PAGE_TABLE, *PAMD64_PAGE_TABLE;

//
// Constants that are already defined in other header files but are not
// (yet) included here
//

#define LU_BASE_ADDRESS (ULONG)0xFEE00000

//
// Inclusion of this header file by both amd64.c and amd64x86.c ensures that
// a PAGE_TABLE is the same size for both platforms.
//

C_ASSERT( sizeof(PAGE_TABLE) == PAGE_SIZE );

//
// 64-bit GDT entry
//

typedef struct _GDT_64 *PGDT_64;

//
// We keep some information for each AMD64 mapping level
//

typedef struct _AMD64_MAPPING_LEVEL {
    ULONGLONG RecursiveMappingBase;
    ULONG AddressMask;
    ULONG AddressShift;
} CONST AMD64_MAPPING_INFO, *PAMD64_MAPPING_INFO;

//
// Routines and data found in amd64.c and referenced in amd64x86.c
//

#define AMD64_MAPPING_LEVELS 4
extern AMD64_MAPPING_INFO BlAmd64MappingLevels[ AMD64_MAPPING_LEVELS ];

extern const ULONG BlAmd64DoubleFaultStackSize;
#define DOUBLE_FAULT_STACK_SIZE_64 BlAmd64DoubleFaultStackSize

extern const ULONG BlAmd64KernelStackSize;
#define KERNEL_STACK_SIZE_64 BlAmd64KernelStackSize

extern const ULONG BlAmd64McaExceptionStackSize;
#define MCA_EXCEPTION_STACK_SIZE_64 BlAmd64McaExceptionStackSize

extern const ULONG BlAmd64GdtSize;
#define GDT_64_SIZE BlAmd64GdtSize

extern const ULONG BlAmd64IdtSize;
#define IDT_64_SIZE BlAmd64IdtSize

extern const ULONG BlAmd64_TSS_IST_PANIC;
#define TSS64_IST_PANIC BlAmd64_TSS_IST_PANIC

extern const ULONG BlAmd64_TSS_IST_MCA;
#define TSS64_IST_MCA BlAmd64_TSS_IST_MCA

extern const ULONG64 BlAmd64UserSharedData;
#define KI_USER_SHARED_DATA_64 BlAmd64UserSharedData

VOID
BlAmd64ClearTopLevelPte(
    VOID
    );

VOID
BlAmd64BuildAmd64GDT(
    IN PVOID SysTss,
    OUT PVOID Gdt
    );

VOID
BlAmd64BuildGdtEntry(
    IN PGDT_64 Gdt,
    IN USHORT Selector,
    IN POINTER64 Base,
    IN ULONGLONG Limit,
    IN ULONG Type,
    IN ULONG Dpl,
    IN BOOLEAN LongMode,
    IN BOOLEAN DefaultBig
    );

ARC_STATUS
BlAmd64CreateMapping(
    IN ULONGLONG Va,
    IN ULONGLONG Pfn
    );

ARC_STATUS
BlAmd64MapHalVaSpace(
    VOID
    );

//
// Routines and data found in amd64x86.c and referenced in amd64.c
//

PAMD64_PAGE_TABLE
BlAmd64AllocatePageTable(
    VOID
    );

VOID
BlAmd64InitializePageTable(
    IN PPAGE_TABLE PageTable
    );

ARC_STATUS
BlAmd64PrepForTransferToKernelPhase1(
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    );

VOID
BlAmd64PrepForTransferToKernelPhase2(
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    );


ARC_STATUS
BlAmd64TransferToKernel(
    IN PTRANSFER_ROUTINE SystemEntry,
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    );

//
// Routines and data found in amd64s.asm and referenced elsewhere
//

BOOLEAN
BlIsAmd64Supported (
    VOID
    );

//
// Shared data
//

#endif  // _AMD64PRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\amd64\amd64s.asm ===
;++
;
;Copyright (c) 2000  Microsoft Corporation
;
;Module Name:
;
;    amd64s.asm
;
;Abstract:
;
;    Contains routines to aid in detecting and enabling Amd64 long mode.
;
;Author:
;
;    Forrest Foltz (forrestf) 04-20-00
;
;
;Revision History:
;
;--


.586p
        .xlist
include ks386.inc
        .list

	extrn   _BlAmd64GdtDescriptor:QWORD
	extrn   _BlAmd64IdtDescriptor:QWORD
	extrn   _BlAmd64IdleStack64:QWORD
	extrn   _BlAmd64TopLevelPte:QWORD
	extrn   _BlAmd64KernelEntry:QWORD
	extrn   _BlAmd64LoaderParameterBlock:QWORD
	extrn   _BlAmd64_MSR_EFER:DWORD
	extrn   _BlAmd64_MSR_EFER_Flags:DWORD
	extrn	_BlAmd64_MSR_GS_BASE:DWORD
	extrn   _BlAmd64_KGDT64_SYS_TSS:WORD
	extrn   _BlAmd32GdtDescriptor:QWORD
        extrn   _HiberInProgress:DWORD

OP64    macro
        db      048h
endm

ICEBP   macro
        db      0f1h
endm

;
; LOADREG loads the 64-bit contents of a memory location specified by
; a 32-bit immediate address.
;
; The resultant 64-bit address is zero-extended, as a result this macro
; only works with addresses < 2^32.
;
; This macro also assumes that esi is zero.
;

LDREG64 macro reg, address
        OP64
	mov     reg, ds:[esi + offset address]
endm


_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

EFLAGS_ID	equ 	200000h

;++
;
; BOOLEAN
; BlIsAmd64Supported (
;     VOID
; )
;
; Routine Description:
;
;      This rouine determines whether the current processor supports AMD64
;      mode, a.k.a. "long mode".
;
;   Arguments:
;
;      None.
;
;   Return value:
;
;      0 if long mode is not supported, non-zero otherwise.
;
;--

public _BlIsAmd64Supported@0
_BlIsAmd64Supported@0 proc

	;
	; First determine whether the CPUID instruction is supported.  If
	; the EFLAGS_ID bit "sticks" when popped into the flags
	; register then the CPUID instruction is available.
	;

	mov	ecx, EFLAGS_ID
	pushfd
	pop	eax		; eax == flags
	xor	ecx, eax	; ecx == flags ^ EFLAGS_ID
	push	ecx
	popfd			; load new flags
	pushfd
	pop	ecx		; ecx == result of flag load
	xor	eax, ecx	; Q: did the EFLAGS_ID bit stick?
	jz	done            ; N: CPUID is not available

	;
	; We can use the CPUID instruction.  Detect whether this is an
	; AMD processor and if so whether long mode is supported.
	;

	push	ebx		; CPUID steps on eax, ebx, ecx, edx
	xor     eax, eax        ; eax = 0
	cpuid
	xor	eax, eax        ; Assume no long mode
	cmp     ebx, 'htuA'     ; Q: ebx == 'Auth' ?
	jne     nolong          ; N: no long mode

	;
	; We have an AMD processor, now determine whether long mode is
	; available.
	;

	mov     eax, 80000001h
	xor	edx, edx
	cpuid
	bt      edx, 29         ; Q: Bit 29 is long mode bit, is it set?
	sbb	eax, eax       	; Yes (eax != 0) if carry set, else eax == 0
nolong: pop	ebx
done:   ret

_BlIsAmd64Supported@0 endp

;++
;
; VOID
; BlAmd64SwitchToLongMode (
;     VOID 
; )
;
; Routine Description:
;
;  Arguments:
;
;   None.
;
;  Return value:
;
;   None.
;
;--

public _BlAmd64SwitchToLongMode@0
_BlAmd64SwitchToLongMode@0 proc
public _BlAmd64SwitchToLongModeStart
_BlAmd64SwitchToLongModeStart label dword

        ;
        ; Save the value of _HiberInProgress before disabling paging
        ; 

        mov     ebx, dword ptr [_HiberInProgress]

        cli

	;
	; Disable paging
	;

	mov	eax, cr0
	and     eax, NOT CR0_PG
	mov     cr0, eax
	jmp     $+2

	;
	; Enable XMM and physical address extensions (paging still off)
	;

	mov     eax, cr4
	or      eax, CR4_PAE OR CR4_FXSR OR CR4_XMMEXCPT OR CR4_PGE
	mov     cr4, eax

	;
	; Reference the four-level paging structure.  This must exist
	; below 4G physical (in fact it is somewhere in the low 32MB)
        ;

        mov     eax, DWORD PTR [_BlAmd64TopLevelPte]
        and     eax, 0FFFFF000h
	mov     cr3, eax

	;
	; Set Long Mode enable and enable syscall
	;

	mov     ecx, [_BlAmd64_MSR_EFER]
	rdmsr
	or      eax, [_BlAmd64_MSR_EFER_Flags]
	wrmsr

        ;
	; Turn paging on.  Also turn on the write protect and alignment mask
        ; bits
	;

	mov     eax, cr0
	or      eax, CR0_PG OR CR0_WP OR CR0_AM OR CR0_NE
	mov     cr0, eax
	jmp     $+2

        ;
        ; Return if we are waking up from hibernate.
        ;

        cmp     ebx, 1
        jnz     @f
        ret

	;
	; Load the new global descriptor table.  Note that because we're
	; not in long mode (current code selector indicates compatibility
	; mode), only a 32-bit base is loaded here.
	;

@@:     lgdt    fword ptr _BlAmd32GdtDescriptor 

	;
	; Far jump to the 64-bit code segment.
	;

	db	0eah
	dd	start64

	;
	; The following selector is set in amd64.c, BlAmd64BuildAmd64GDT, and
	; is included as part of the far jump instruction.
	; 

	public _BlAmd64_KGDT64_R0_CODE
_BlAmd64_KGDT64_R0_CODE:
	dw	?

start64:

	;
	; Zero rsi so that the LDREG64 macros work
	; 

	sub	esi, esi        ; zero rsi (zeroed esi is sign extended)

        ;
	; Running in long mode now.  Execute another lgdt, this one
	; referencing the 64-bit mapping of the gdt.
	;
	; Note that an esi-relative address is used to avoid RIP-relative
	; addressing.
        ;
        ; Keep in mind that a 32-bit assembler is used here to generate
        ; long-mode code.
	;

	lgdt	fword ptr ds:[esi + offset _BlAmd64GdtDescriptor]

	;
	; Load the new interrupt descriptor table
	;

	lidt    fword ptr ds:[esi + offset _BlAmd64IdtDescriptor]

        ;
	; Switch stacks to the 64-bit idle stack
	;

	LDREG64 esp, _BlAmd64IdleStack64
				   
	;
	; Set the current TSS
	;

        LDREG64 eax, _BlAmd64_KGDT64_SYS_TSS
	ltr     ax

	;
	; Set ss to the kernel-mode SS value (0)
	;

	sub	eax, eax        ; zero rax
	mov	ss, ax

	;
	; Allocate space on the stack for a parameter target area and jump
	; to the kernel entrypoint.  Rather than a call, we push a return
        ; address of zero to indicate to any stack walkers that this is the
        ; end.
	;

        push    eax             ; push null return address

	LDREG64 ecx, _BlAmd64LoaderParameterBlock
	LDREG64 eax, _BlAmd64KernelEntry

	jmp     eax             ; jmp rax


public  _BlAmd64SwitchToLongModeEnd
_BlAmd64SwitchToLongModeEnd label dword
_BlAmd64SwitchToLongMode@0 endp
_TEXT	ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\amd64\amd64x86.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    amd64x86.c

Abstract:

    This module contains routines necessary to support loading and
    transitioning into an AMD64 kernel.  The code in this module has
    access to x86-specific defines found in i386.h but not to amd64-
    specific declarations found in amd64.h.

Author:

    Forrest Foltz (forrestf) 20-Apr-2000

Environment:


Revision History:

--*/

#include "amd64prv.h"
#include <pcmp.inc>
#include <ntapic.inc>

#if defined(ROUND_UP)
#undef ROUND_UP
#endif

#include "cmp.h"
#include "arc.h"

#define WANT_BLDRTHNK_FUNCTIONS
#define COPYBUF_MALLOC BlAllocateHeap
#include <amd64thk.h>

#define IMAGE_DEFINITIONS 0
#include <ximagdef.h>

//
// Warning 4152 is "nonstandard extension, function/data pointer conversion
//
#pragma warning(disable:4152)

//
// Private, tempory memory descriptor type
//

#define LoaderAmd64MemoryData (LoaderMaximum + 10)

//
// Array of 64-bit memory descriptors
//

PMEMORY_ALLOCATION_DESCRIPTOR_64 BlAmd64DescriptorArray;
LONG BlAmd64DescriptorArraySize;

//
// Forward declarations for functions local to this module
//

ARC_STATUS
BlAmd64AllocateMemoryAllocationDescriptors(
    VOID
    );

ARC_STATUS
BlAmd64BuildLdrDataTableEntry64(
    IN  PLDR_DATA_TABLE_ENTRY     DataTableEntry32,
    OUT PLDR_DATA_TABLE_ENTRY_64 *DataTableEntry64
    );

ARC_STATUS
BlAmd64BuildLoaderBlock64(
    VOID
    );

ARC_STATUS
BlAmd64BuildLoaderBlockExtension64(
    VOID
    );

ARC_STATUS
BlAmd64BuildMappingPhase1(
    VOID
    );

ARC_STATUS
BlAmd64BuildMappingPhase2(
    VOID
    );

ARC_STATUS
BlAmd64BuildMappingWorker(
    VOID
    );

BOOLEAN
BlAmd64ContainsResourceList(
    IN PCONFIGURATION_COMPONENT_DATA ComponentData32,
    OUT PULONG ResourceListSize64
    );

ARC_STATUS
BlAmd64FixSharedUserPage(
    VOID
    );

BOOLEAN
BlAmd64IsPageMapped(
    IN ULONG Va,
    OUT PFN_NUMBER *Pfn,
    OUT PBOOLEAN PageTableMapped
    );

ARC_STATUS
BlAmd64PrepareSystemStructures(
    VOID
    );

VOID
BlAmd64ReplaceMemoryDescriptorType(
    IN TYPE_OF_MEMORY Target,
    IN TYPE_OF_MEMORY Replacement,
    IN BOOLEAN Coallesce
    );

VOID
BlAmd64ResetPageTableHeap(
    VOID
    );

VOID
BlAmd64SwitchToLongMode(
    VOID
    );

ARC_STATUS
BlAmd64TransferArcDiskInformation(
    VOID
    );

ARC_STATUS
BlAmd64TransferBootDriverNodes(
    VOID
    );

ARC_STATUS
BlAmd64TransferConfigurationComponentData(
    VOID
    );

PCONFIGURATION_COMPONENT_DATA_64
BlAmd64TransferConfigWorker(
    IN PCONFIGURATION_COMPONENT_DATA    ComponentData32,
    IN PCONFIGURATION_COMPONENT_DATA_64 ComponentDataParent64
    );

ARC_STATUS
BlAmd64TransferHardwareIdList(
    IN  PPNP_HARDWARE_ID HardwareId,
    OUT POINTER64 *HardwareIdDatabaseList64
    );

ARC_STATUS
BlAmd64TransferLoadedModuleState(
    VOID
    );

ARC_STATUS
BlAmd64TransferMemoryAllocationDescriptors(
    VOID
    );

ARC_STATUS
BlAmd64TransferNlsData(
    VOID
    );

VOID
BlAmd64TransferResourceList(
    IN  PCONFIGURATION_COMPONENT_DATA ComponentData32,
    OUT PCONFIGURATION_COMPONENT_DATA_64 ComponentData64
    );

ARC_STATUS
BlAmd64TransferSetupLoaderBlock(
    VOID
    );

#if DBG

PCHAR BlAmd64MemoryDescriptorText[] = {
    "LoaderExceptionBlock",
    "LoaderSystemBlock",
    "LoaderFree",
    "LoaderBad",
    "LoaderLoadedProgram",
    "LoaderFirmwareTemporary",
    "LoaderFirmwarePermanent",
    "LoaderOsloaderHeap",
    "LoaderOsloaderStack",
    "LoaderSystemCode",
    "LoaderHalCode",
    "LoaderBootDriver",
    "LoaderConsoleInDriver",
    "LoaderConsoleOutDriver",
    "LoaderStartupDpcStack",
    "LoaderStartupKernelStack",
    "LoaderStartupPanicStack",
    "LoaderStartupPcrPage",
    "LoaderStartupPdrPage",
    "LoaderRegistryData",
    "LoaderMemoryData",
    "LoaderNlsData",
    "LoaderSpecialMemory",
    "LoaderBBTMemory",
    "LoaderReserve"
};

#endif


VOID
NSUnmapFreeDescriptors(
    IN PLIST_ENTRY ListHead
    );

//
// Data declarations
//

PLOADER_PARAMETER_BLOCK    BlAmd64LoaderBlock32;
PLOADER_PARAMETER_BLOCK_64 BlAmd64LoaderBlock64;


//
// Pointer to the top of the 64-bit stack frame to use upon transition
// to long mode.
//

POINTER64 BlAmd64IdleStack64;

//
// GDT and IDT pseudo-descriptor for use with LGDT/LIDT
//

DESCRIPTOR_TABLE_DESCRIPTOR BlAmd64GdtDescriptor;
DESCRIPTOR_TABLE_DESCRIPTOR BlAmd64IdtDescriptor;
DESCRIPTOR_TABLE_DESCRIPTOR BlAmd32GdtDescriptor;

//
// 64-bit pointers to the loader parameter block and kernel
// entry routine
//

POINTER64 BlAmd64LoaderParameterBlock;
POINTER64 BlAmd64KernelEntry;

//
// A private list of page tables used to build the long mode paging
// structures is kept.  This is in order to avoid memory allocations while
// the structures are being assembled.
//
// The PT_NODE type as well as the BlAmd64FreePfnList and BlAmd64BusyPfnList
// globals are used to that end.
//

typedef struct _PT_NODE *PPT_NODE;
typedef struct _PT_NODE {
    PPT_NODE Next;
    PAMD64_PAGE_TABLE PageTable;
} PT_NODE;

PPT_NODE BlAmd64FreePfnList = NULL;
PPT_NODE BlAmd64BusyPfnList = NULL;

//
// Indicate if the system is waking up from hibernate
//

ULONG HiberInProgress = 0;

//
// External data
//

extern ULONG64 BlAmd64_LOCALAPIC;

ARC_STATUS
BlAmd64MapMemoryRegion(
    IN ULONG RegionVa,
    IN ULONG RegionSize
    )

/*++

Routine Description:

    This function creates long mode mappings for all valid x86 mappings
    within the region described by RegionVa and RegionSize.

Arguments:

    RegionVa - Supplies the starting address of the VA region.

    RegionSize - Supplies the size of the VA region.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    ULONG va32;
    ULONG va32End;
    POINTER64 va64;
    ARC_STATUS status;
    PFN_NUMBER pfn;
    BOOLEAN pageMapped;
    BOOLEAN pageTableMapped;
    ULONG increment;

    va32 = RegionVa;
    va32End = va32 + RegionSize;
    while (va32 < va32End) {

        pageMapped = BlAmd64IsPageMapped( va32, &pfn, &pageTableMapped );
        if (pageTableMapped != FALSE) {

            //
            // The page table corresponding to this address is present.
            //

            if (pageMapped != FALSE) {

                //
                // The page corresponding to this address is present.
                //

                if ((va32 & KSEG0_BASE_X86) != 0) {

                    //
                    // The address lies within the X86 KSEG0 region.  Map
                    // it to the corresponding address within the AMD64
                    // KSEG0 region.
                    //

                    va64 = PTR_64( (PVOID)va32 );

                } else {

                    //
                    // Map the VA directly.
                    //

                    va64 = (POINTER64)va32;
                }

                //
                // Now create the mapping in the AMD64 page table structure.
                //

                status = BlAmd64CreateMapping( va64, pfn );
                if (status != ESUCCESS) {
                    return status;
                }
            }

            //
            // Check the next page.
            //

            increment = PAGE_SIZE;

        } else {

            //
            // Not only is the page not mapped but neither is the page table.
            // Skip to the next page table address boundary.
            //

            increment = 1 << PDI_SHIFT;
        }

        //
        // Advance to the next VA to check, checking for overflow.
        //

        va32 = (va32 + increment) & ~(increment - 1);
        if (va32 == 0) {
            break;
        }
    }

    return ESUCCESS;
}

BOOLEAN
BlAmd64IsPageMapped(
    IN ULONG Va,
    OUT PFN_NUMBER *Pfn,
    OUT PBOOLEAN PageTableMapped
    )

/*++

Routine Description:

    This function accepts a 32-bit virtual address, determines whether it
    is a valid address, and if so returns the Pfn associated with it.

    Addresses that are within the recursive mapping are treated as NOT
    mapped.

Arguments:

    None.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    ULONG pdeIndex;
    ULONG pteIndex;
    PHARDWARE_PTE pde;
    PHARDWARE_PTE pte;
    BOOLEAN dummy;
    PBOOLEAN pageTableMapped;

    //
    // Point the output parameter pointer as appropriate.
    //

    if (ARGUMENT_PRESENT(PageTableMapped)) {
        pageTableMapped = PageTableMapped;
    } else {
        pageTableMapped = &dummy;
    }

    //
    // Pages that are a part of the X86 32-bit mapping structure ARE
    // IGNORED.
    //

    if (Va >= PTE_BASE && Va <= PTE_TOP) {
        *pageTableMapped = TRUE;
        return FALSE;
    }

    //
    // Determine whether the mapping PDE is present
    //

    pdeIndex = Va >> PDI_SHIFT;
    pde = &((PHARDWARE_PTE)PDE_BASE)[ pdeIndex ];

    if (pde->Valid == 0) {
        *pageTableMapped = FALSE;
        return FALSE;
    }

    //
    // Indicate that the page table for this address is mapped.
    //

    *pageTableMapped = TRUE;

    //
    // It is, now get the page present status
    //

    pteIndex = Va >> PTI_SHIFT;
    pte = &((PHARDWARE_PTE)PTE_BASE)[ pteIndex ];

    if (pte->Valid == 0) {
        return FALSE;
    }

    *Pfn = pte->PageFrameNumber;
    return TRUE;
}


PAMD64_PAGE_TABLE
BlAmd64AllocatePageTable(
    VOID
    )

/*++

Routine Description:

    This function allocates and initializes a PAGE_TABLE structure.

Arguments:

    None.

Return Value:

    Returns a pointer to the allocated page table structure, or NULL
    if the allocation failed.

--*/

{
    ARC_STATUS status;
    ULONG descriptor;
    PPT_NODE ptNode;
    PAMD64_PAGE_TABLE pageTable;

    //
    // Pull a page table off of the free list, if one exists
    //

    ptNode = BlAmd64FreePfnList;
    if (ptNode != NULL) {

        BlAmd64FreePfnList = ptNode->Next;

    } else {

        //
        // The free page table list is empty, allocate a new
        // page table and node to track it with.
        //

        status = BlAllocateDescriptor( LoaderAmd64MemoryData,
                                       0,
                                       1,
                                       &descriptor );
        if (status != ESUCCESS) {
            return NULL;
        }

        ptNode = BlAllocateHeap( sizeof(PT_NODE) );
        if (ptNode == NULL) {
            return NULL;
        }

        ptNode->PageTable = (PAMD64_PAGE_TABLE)(descriptor << PAGE_SHIFT);
    }

    ptNode->Next = BlAmd64BusyPfnList;
    BlAmd64BusyPfnList = ptNode;

    pageTable = ptNode->PageTable;
    RtlZeroMemory( pageTable, PAGE_SIZE );

    return pageTable;
}

ARC_STATUS
BlAmd64TransferToKernel(
    IN PTRANSFER_ROUTINE SystemEntry,
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    )

/*++

Routine Description:

    This routine prepares the AMD64 data structures required for kernel
    execution, including page table structures and 64-bit loader block,
    and transfers control to the kernel.

    This routine returns only upon an error.

Arguments:

    SystemEntry - Pointer to the kernel entry point.

    BlLoaderBlock - Pointer to the 32-bit loader block structure.

Return Value:

    No return on success.  On failure, returns the status of the operation.

--*/

{
    UNREFERENCED_PARAMETER( BlLoaderBlock );

    BlAmd64LoaderParameterBlock = PTR_64(BlAmd64LoaderBlock64);
    BlAmd64KernelEntry = PTR_64(SystemEntry);
    BlAmd64SwitchToLongMode();

    return EINVAL;
}


ARC_STATUS
BlAmd64PrepForTransferToKernelPhase1(
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    )

/*++

Routine Description:

    This routine prepares the AMD64 data structures required for kernel
    execution, including page table structures and 64-bit loader block.

    This is the first of two phases of preperation.  This phase is executed
    while heap and descriptor allocations are still permitted.

Arguments:

    BlLoaderBlock - Pointer to the 32-bit loader block structure.

Return Value:

    No return on success.  On failure, returns the status of the operation.

--*/

{
    ARC_STATUS status;

    //
    // This is the main routine called to do preperatory work before
    // transitioning into the AMD64 kernel.
    //

    BlAmd64LoaderBlock32 = BlLoaderBlock;

    //
    // Build a 64-bit copy of the loader parameter block.
    //

    status = BlAmd64BuildLoaderBlock64();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Process the loaded modules.
    //

    status = BlAmd64TransferLoadedModuleState();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Next the boot driver nodes
    //

    status = BlAmd64TransferBootDriverNodes();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // NLS data
    //

    status = BlAmd64TransferNlsData();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Configuration component data tree
    //

    status = BlAmd64TransferConfigurationComponentData();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // ARC disk information
    //

    status = BlAmd64TransferArcDiskInformation();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Setup loader block
    //

    status = BlAmd64TransferSetupLoaderBlock();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Allocate structures needed by the kernel: TSS, stacks etc.
    //

    status = BlAmd64PrepareSystemStructures();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Mark the descriptor for the shared user page so that it will
    // not be freed by the kernel.
    //

    status = BlAmd64FixSharedUserPage();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Pre-allocate any pages needed for the long mode paging structures.
    //

    status = BlAmd64BuildMappingPhase1();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Pre-allocate the 64-bit memory allocation descriptors that will be
    // used by BlAmd64TransferMemoryAllocationDescriptors().
    //

    status = BlAmd64AllocateMemoryAllocationDescriptors();
    if (status != ESUCCESS) {
        return status;
    }

    return status;
}

VOID
BlAmd64PrepForTransferToKernelPhase2(
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    )

/*++

Routine Description:

    This routine prepares the AMD64 data structures required for kernel
    execution, including page table structures and 64-bit loader block.

    This is the second of two phases of preperation.  This phase is executed
    after the 32-bit page tables have been purged of any unused mappings.

    Note that descriptor and heap allocations are not permitted at this
    point.  Any necessary storage must have been preallocated during phase 1.


Arguments:

    BlLoaderBlock - Pointer to the 32-bit loader block structure.

Return Value:

    No return on success.  On failure, returns the status of the operation.

--*/

{
    PLOADER_PARAMETER_EXTENSION_64 extension;
    ARC_STATUS status;

    UNREFERENCED_PARAMETER( BlLoaderBlock );

    //
    // At this point everything has been preallocated, nothing can fail.
    //

    status = BlAmd64BuildMappingPhase2();
    ASSERT(status == ESUCCESS);

    //
    // Transfer the memory descriptor state.
    //

    status = BlAmd64TransferMemoryAllocationDescriptors();
    ASSERT(status == ESUCCESS);

    //
    // Set LoaderPagesSpanned in the 64-bit loader block.
    //

    extension = PTR_32(BlAmd64LoaderBlock64->Extension);
    extension->LoaderPagesSpanned = BlHighestPage+1;
}

ARC_STATUS
BlAmd64BuildMappingPhase1(
    VOID
    )

/*++

Routine Description:

    This routine performs the first of the two-phase long mode mapping
    structure creation process now, while memory allocations are still
    possible.  It simply calls BlAmd64BuilMappingWorker() which in fact
    creates the mapping structures, and (more importantly) allocates all
    of the page tables required to do so.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ARC_STATUS status;

    //
    // While it is possible to perform memory allocations, reserve enough
    // page tables to build the AMD64 paging structures.
    //
    // The easiest way to calculate the maximum number of pages needed is
    // to actually build the structures.  We do that now with the first of
    // two calls to BlAmd64BuildMappingWorker().
    //

    status = BlAmd64BuildMappingWorker();
    if (status != ESUCCESS) {
        return status;
    }

    return ESUCCESS;
}

ARC_STATUS
BlAmd64BuildMappingPhase2(
    VOID
    )

/*++

Routine Description:

    This routine performs the second of the two-phase long mode mapping
    structure creation process.  All page tables will have been preallocated
    as a result of the work performed by BlAmd64BuildMappingPhase1().

Arguments:

    None.

Return Value:

    None.

--*/

{
    ARC_STATUS status;

    //
    // Reset the Amd64 paging structures
    //

    BlAmd64ResetPageTableHeap();

    //
    // All necessary page tables can now be found on BlAmd64FreePfnList.
    // On this, the second call to BlAmd64BuildMappingWorker(), those are the
    // pages that will be used to perform the mapping.
    //

    status = BlAmd64BuildMappingWorker();
    if (status != ESUCCESS) {
        return status;
    }

    return ESUCCESS;
}

ARC_STATUS
BlAmd64BuildMappingWorker(
    VOID
    )

/*++

Routine Description:

    This routine creates any necessary memory mappings in the long-mode
    page table structure.  It is called twice, once from
    BlAmd64BuildMappingPhase1() and again from BlAmd64BuildMappingPhase2().

    Any additional memory mapping that must be carried out should go in
    this routine.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ARC_STATUS status;
    PFN_NUMBER pfn;

    //
    // Any long mode mapping code goes here.  This routine is called twice:
    // once from BlAmd64BuildMappingPhase1(), and again from
    // BlAmd64BuildMappingPhase2().
    //

    //
    // Transfer any mappings in the first 32MB of identity mapping.
    //

    status = BlAmd64MapMemoryRegion( 0,
                                     32 * 1024 * 1024 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Transfer any mappings in the 1GB region starting at KSEG0_BASE_X86.
    //

    status = BlAmd64MapMemoryRegion( KSEG0_BASE_X86,
                                     0x40000000 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // "Map" the HAL va
    //

    status = BlAmd64MapHalVaSpace();
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Map the shared user data page
    //

    BlAmd64IsPageMapped( KI_USER_SHARED_DATA, &pfn, NULL );

    status = BlAmd64CreateMapping( KI_USER_SHARED_DATA_64, pfn );
    if (status != ESUCCESS) {
        return status;
    }

    return ESUCCESS;
}


VOID
BlAmd64ResetPageTableHeap(
    VOID
    )

/*++

Routine Description:

    This function is called as part of the two-phase page table creation
    process.  Its purpose is to move all of the PFNs required to build
    the long mode page tables back to the free list, and to otherwise
    initialize the long mode paging structure.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PPT_NODE ptNodeLast;

    //
    // Move the page table nodes from the busy list to the free list.
    //

    if (BlAmd64BusyPfnList != NULL) {

        //
        // A tail pointer is not kept, so find the tail node here.
        //

        ptNodeLast = BlAmd64BusyPfnList;
        while (ptNodeLast->Next != NULL) {
            ptNodeLast = ptNodeLast->Next;
        }

        ptNodeLast->Next = BlAmd64FreePfnList;
        BlAmd64FreePfnList = BlAmd64BusyPfnList;
        BlAmd64BusyPfnList = NULL;
    }

    //
    // Zero the top-level pte declared in amd64.c
    //

    BlAmd64ClearTopLevelPte();
}

ARC_STATUS
BlAmd64TransferHardwareIdList(
    IN  PPNP_HARDWARE_ID HardwareId,
    OUT POINTER64 *HardwareIdDatabaseList64
    )

/*++

Routine Description:

    This routine walks the singly-linked list of PNP_HARDWARE_ID structures
    and for each one found, creates a 64-bit PNP_HARDWARE_ID_64 structure and
    inserts it on a list of same.

    The resultant 64-bit list is in the same order as the supplied 32-bit
    list.

Arguments:

    HardwareId - Supplies a pointer to the head of the singly-linked list of
                 PNP_HARDWARE_ID structures.

    HardwareIdDatabaseList64 -
                 Supplies a pointer to a POINTER64 which upon successful
                 completion of this routine will contain a 64-bit KSEG0
                 pointer to the created 64-bit PNP_HARDWARE_ID_64 list.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    PPNP_HARDWARE_ID_64 hardwareId64;
    ARC_STATUS status;

    //
    // Walk the id list backwards.  To do this we call ourselves
    // recursively until we find the end of the list, then process the nodes
    // on the way back up.
    //

    if (HardwareId == NULL) {
        return ESUCCESS;
    }

    status = BlAmd64TransferHardwareIdList( HardwareId->Next,
                                            HardwareIdDatabaseList64 );
    if (status != ESUCCESS) {
        return status;
    }

    hardwareId64 = BlAllocateHeap(sizeof(PNP_HARDWARE_ID_64));
    if (hardwareId64 == NULL) {
        return ENOMEM;
    }

    status = Copy_PNP_HARDWARE_ID( HardwareId, hardwareId64 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Link it into the front of the 64-bit list.
    //

    hardwareId64->Next = *HardwareIdDatabaseList64;
    *HardwareIdDatabaseList64 = PTR_64(hardwareId64);

    return ESUCCESS;
}


ARC_STATUS
BlAmd64TransferDeviceRegistryList(
    IN  PDETECTED_DEVICE_REGISTRY DetectedDeviceRegistry32,
    OUT POINTER64 *DetectedDeviceRegistry64
    )

/*++

Routine Description:

    This routine walks the singly-linked list of DETECTED_DEVICE_REGISTRY
    structures and for each one found, creates a 64-bit
    DETECTED_DEVICE_REGISTRY_64 structure and inserts it on a list of same.

    The resultant 64-bit list is in the same order as the supplied 32-bit
    list.

Arguments:

    DetectedDeviceRegistry32 - Supplies a pointer to the head of the singly-linked list of
                 DETECTED_DEVICE_REGISTRY structures.

    DetectedDeviceRegistry64 -
                 Supplies a pointer to a POINTER64 which upon successful
                 completion of this routine will contain a 64-bit KSEG0
                 pointer to the created 64-bit DETECTED_DEVICE_REGISTRY_64
                 list.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    PDETECTED_DEVICE_REGISTRY_64 registry64;
    ARC_STATUS status;

    //
    // Walk the registry list backwards.  To do this we call ourselves
    // recursively until we find the end of the list, then process the nodes
    // on the way back up.
    //

    if (DetectedDeviceRegistry32 == NULL) {
        return ESUCCESS;
    }

    status = BlAmd64TransferDeviceRegistryList( DetectedDeviceRegistry32->Next,
                                                DetectedDeviceRegistry64 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Allocate a 64-bit registry structure and copy the contents
    // of the 32-bit one in.
    //

    registry64 = BlAllocateHeap(sizeof(DETECTED_DEVICE_REGISTRY_64));
    if (registry64 == NULL) {
        return ENOMEM;
    }

    status = Copy_DETECTED_DEVICE_REGISTRY( DetectedDeviceRegistry32, registry64 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Link it into the front of the 64-bit list.
    //

    registry64->Next = *DetectedDeviceRegistry64;
    *DetectedDeviceRegistry64 = PTR_64(registry64);

    return ESUCCESS;
}

ARC_STATUS
BlAmd64TransferDeviceFileList(
    IN  PDETECTED_DEVICE_FILE DetectedDeviceFile32,
    OUT POINTER64 *DetectedDeviceFile64
    )

/*++

Routine Description:

    This routine walks the singly-linked list of DETECTED_DEVICE_FILE
    structures and for each one found, creates a 64-bit
    DETECTED_DEVICE_FILE_64 structure and inserts it on a list of same.

    The resultant 64-bit list is in the same order as the supplied 32-bit
    list.

Arguments:

    DetectedDeviceFile32 - Supplies a pointer to the head of the singly-linked
                 list of DETECTED_DEVICE_FILE structures.

    DetectedDeviceFile64 -
                 Supplies a pointer to a POINTER64 which upon successful
                 completion of this routine will contain a 64-bit KSEG0
                 pointer to the created 64-bit DETECTED_DEVICE_FILE_64
                 list.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    PDETECTED_DEVICE_FILE_64 file64;
    ARC_STATUS status;

    //
    // Walk the file list backwards.  To do this we call ourselves
    // recursively until we find the end of the list, then process the nodes
    // on the way back up.
    //

    if (DetectedDeviceFile32 == NULL) {
        return ESUCCESS;
    }

    status = BlAmd64TransferDeviceFileList( DetectedDeviceFile32->Next,
                                            DetectedDeviceFile64 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Allocate a 64-bit file structure and copy the contents
    // of the 32-bit one in.
    //

    file64 = BlAllocateHeap(sizeof(DETECTED_DEVICE_FILE_64));
    if (file64 == NULL) {
        return ENOMEM;
    }

    status = Copy_DETECTED_DEVICE_FILE( DetectedDeviceFile32, file64 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Transfer the singly-linked list of DETECTED_DEVICE_REGISTRY structures
    // linked to this DETECTED_DEVICE_FILE structure.
    //

    status = BlAmd64TransferDeviceRegistryList(
                    DetectedDeviceFile32->RegistryValueList,
                    &file64->RegistryValueList );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Link it into the front of the 64-bit list.
    //

    file64->Next = *DetectedDeviceFile64;
    *DetectedDeviceFile64 = PTR_64(file64);

    return ESUCCESS;
}

ARC_STATUS
BlAmd64TransferDeviceList(
    IN  PDETECTED_DEVICE  DetectedDevice32,
    OUT POINTER64        *DetectedDeviceList64
    )

/*++

Routine Description:

    This routine walks the singly-linked list of DETECTED_DEVICE
    structures and for each one found, creates a 64-bit
    DETECTED_DEVICE_64 structure and inserts it on a list of same.

    The resultant 64-bit list is in the same order as the supplied 32-bit
    list.

Arguments:

    DetectedDevice32 - Supplies a pointer to the head of the singly-linked
                 list of DETECTED_DEVICE structures.

    DetectedDeviceList64 -
                 Supplies a pointer to a POINTER64 which upon successful
                 completion of this routine will contain a 64-bit KSEG0
                 pointer to the created 64-bit DETECTED_DEVICE_64
                 list.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    PDETECTED_DEVICE_64 device64;
    ARC_STATUS status;

    //
    // Walk the device list backwards.  To do this we call ourselves
    // recursively until we find the end of the list, then process the nodes
    // on the way back up.
    //

    if (DetectedDevice32 == NULL) {
        return ESUCCESS;
    }

    status = BlAmd64TransferDeviceList( DetectedDevice32->Next,
                                        DetectedDeviceList64 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Allocate a 64-bit device structure and copy the contents
    // of the 32-bit one in.
    //

    device64 = BlAllocateHeap(sizeof(DETECTED_DEVICE_64));
    if (device64 == NULL) {
        return ENOMEM;
    }

    status = Copy_DETECTED_DEVICE( DetectedDevice32, device64 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Transfer any PROTECTED_DEVICE_FILE structures
    //

    status = BlAmd64TransferDeviceFileList( DetectedDevice32->Files,
                                            &device64->Files );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Link it into the front of the 64-bit list.
    //

    device64->Next = *DetectedDeviceList64;
    *DetectedDeviceList64 = PTR_64(device64);

    return ESUCCESS;
}

ARC_STATUS
BlAmd64TransferSetupLoaderBlock(
    VOID
    )

/*++

Routine Description:

    This routine creates a SETUP_LOADER_BLOCK_64 structure that is the
    equivalent of the 32-bit SETUP_LOADER_BLOCK structure referenced within
    the 32-bit setup loader block.

Arguments:

    None.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    PSETUP_LOADER_BLOCK    setupBlock32;
    PSETUP_LOADER_BLOCK_64 setupBlock64;
    ARC_STATUS status;

    setupBlock32 = BlAmd64LoaderBlock32->SetupLoaderBlock;
    if (setupBlock32 == NULL) {
        return ESUCCESS;
    }

    setupBlock64 = BlAllocateHeap(sizeof(SETUP_LOADER_BLOCK_64));
    if (setupBlock64 == NULL) {
        return ENOMEM;
    }

    status = Copy_SETUP_LOADER_BLOCK( setupBlock32, setupBlock64 );
    if (status != ESUCCESS) {
        return status;
    }

    {
        #define TRANSFER_DEVICE_LIST(x)                             \
            setupBlock64->x = PTR_64(NULL);                         \
            status = BlAmd64TransferDeviceList( setupBlock32->x,    \
                                                &setupBlock64->x ); \
            if (status != ESUCCESS) return status;

        TRANSFER_DEVICE_LIST(KeyboardDevices);
        TRANSFER_DEVICE_LIST(ScsiDevices);
        TRANSFER_DEVICE_LIST(BootBusExtenders);
        TRANSFER_DEVICE_LIST(BusExtenders);
        TRANSFER_DEVICE_LIST(InputDevicesSupport);

        #undef TRANSFER_DEVICE_LIST
    }

    setupBlock64->HardwareIdDatabase = PTR_64(NULL);
    status = BlAmd64TransferHardwareIdList( setupBlock32->HardwareIdDatabase,
                                            &setupBlock64->HardwareIdDatabase );
    if (status != ESUCCESS) {
        return status;
    }

    BlAmd64LoaderBlock64->SetupLoaderBlock = PTR_64(setupBlock64);

    return status;
}

ARC_STATUS
BlAmd64TransferArcDiskInformation(
    VOID
    )

/*++

Routine Description:

    This routine creates an ARC_DISK_INFORMATION_64 structure that is the
    equivalent of the 32-bit ARC_DISK_INFORMATION structure referenced within
    the 32-bit loader block.

Arguments:

    None.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    ARC_STATUS status;

    PLIST_ENTRY listHead;
    PLIST_ENTRY listEntry;

    PARC_DISK_INFORMATION diskInfo32;
    PARC_DISK_INFORMATION_64 diskInfo64;

    PARC_DISK_SIGNATURE diskSignature32;
    PARC_DISK_SIGNATURE_64 diskSignature64;

    //
    // Create a 64-bit ARC_DISK_INFORMATION structure
    //

    diskInfo32 = BlAmd64LoaderBlock32->ArcDiskInformation;
    if (diskInfo32 == NULL) {
        return ESUCCESS;
    }

    diskInfo64 = BlAllocateHeap(sizeof(ARC_DISK_INFORMATION_64));
    if (diskInfo64 == NULL) {
        return ENOMEM;
    }

    status = Copy_ARC_DISK_INFORMATION( diskInfo32, diskInfo64 );
    if (status != ESUCCESS) {
        return status;
    }

    InitializeListHead64( &diskInfo64->DiskSignatures );

    //
    // Walk the 32-bit list of ARC_DISK_SIGNATURE nodes and create
    // a 64-bit version of each
    //

    listHead = &diskInfo32->DiskSignatures;
    listEntry = listHead->Flink;
    while (listEntry != listHead) {

        diskSignature32 = CONTAINING_RECORD( listEntry,
                                             ARC_DISK_SIGNATURE,
                                             ListEntry );

        diskSignature64 = BlAllocateHeap(sizeof(ARC_DISK_SIGNATURE_64));
        if (diskSignature64 == NULL) {
            return ENOMEM;
        }

        status = Copy_ARC_DISK_SIGNATURE( diskSignature32, diskSignature64 );
        if (status != ESUCCESS) {
            return status;
        }

        InsertTailList64( &diskInfo64->DiskSignatures,
                          &diskSignature64->ListEntry );

        listEntry = listEntry->Flink;
    }

    BlAmd64LoaderBlock64->ArcDiskInformation = PTR_64(diskInfo64);

    return ESUCCESS;
}


ARC_STATUS
BlAmd64TransferConfigurationComponentData(
    VOID
    )

/*++

Routine Description:

    This routine creates a CONFIGURATION_COMPONENT_DATA_64 structure tree
    that is the equivalent of the 32-bit CONFIGURATION_COMPONENT_DATA
    structure tree referenced within the 32-bit loader block.

Arguments:

    None.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    PCONFIGURATION_COMPONENT_DATA_64 rootComponent64;

    if (BlAmd64LoaderBlock32->ConfigurationRoot == NULL) {
        return ESUCCESS;
    }

    rootComponent64 =
        BlAmd64TransferConfigWorker( BlAmd64LoaderBlock32->ConfigurationRoot,
                                     NULL );

    if (rootComponent64 == NULL) {
        return ENOMEM;
    }

    BlAmd64LoaderBlock64->ConfigurationRoot = PTR_64(rootComponent64);
    return ESUCCESS;
}

PCONFIGURATION_COMPONENT_DATA_64
BlAmd64TransferConfigWorker(
    IN PCONFIGURATION_COMPONENT_DATA    ComponentData32,
    IN PCONFIGURATION_COMPONENT_DATA_64 ComponentDataParent64
    )

/*++

Routine Description:

    Given a 32-bit CONFIGURATION_COMPONENT_DATA structure, this routine
    creates an equivalent 64-bit CONFIGURATION_COMPONENT_DATA structure
    for the supplied structure, as well as for all of its children and
    siblings.

    This routine calls itself recursively for each sibling and child.

Arguments:

    ComponentData32 - Supplies a pointer to the 32-bit structure to transfer.

    ComponentDataParent64 - Supplies a pointer to the current 64-bit parent
    structure.

Return Value:

    Returns a pointer to the created 64-bit structure, or NULL if a failure
    was encountered.

--*/

{
    ARC_STATUS status;
    ULONG componentDataSize64;
    ULONG partialResourceListSize64;
    BOOLEAN thunkResourceList;

    PCONFIGURATION_COMPONENT_DATA_64 componentData64;
    PCONFIGURATION_COMPONENT_DATA_64 newCompData64;

    //
    // Create and copy configuration component data node
    //

    componentDataSize64 = sizeof(CONFIGURATION_COMPONENT_DATA_64);
    thunkResourceList = BlAmd64ContainsResourceList(ComponentData32,
                                                    &partialResourceListSize64);

    if (thunkResourceList != FALSE) {

        //
        // This node contains a CM_PARTIAL_RESOURCE_LIST structure.
        // partialResourceListSize64 contains the number of bytes beyond the
        // CONFIGURATION_COMPONENT_DATA header that must be allocated in order to
        // thunk the CM_PARTIAL_RESOURCE_LIST into a 64-bit version.
        //

        componentDataSize64 += partialResourceListSize64;
    }

    componentData64 = BlAllocateHeap(componentDataSize64);
    if (componentData64 == NULL) {
        return NULL;
    }

    status = Copy_CONFIGURATION_COMPONENT_DATA( ComponentData32,
                                                componentData64 );
    if (status != ESUCCESS) {
        return NULL;
    }

    if (thunkResourceList != FALSE) {

        //
        // Update the configuration component data size
        //

        componentData64->ComponentEntry.ConfigurationDataLength =
            partialResourceListSize64;
    }

    componentData64->Parent = PTR_64(ComponentDataParent64);

    if (thunkResourceList != FALSE) {

        //
        // Now transfer the resource list.
        //

        BlAmd64TransferResourceList(ComponentData32,componentData64);
    }

    //
    // Process the child (and recursively, all children)
    //

    if (ComponentData32->Child != NULL) {

        newCompData64 = BlAmd64TransferConfigWorker( ComponentData32->Child,
                                                     componentData64 );
        if (newCompData64 == NULL) {
            return newCompData64;
        }

        componentData64->Child = PTR_64(newCompData64);
    }

    //
    // Process the sibling (and recursively, all siblings)
    //

    if (ComponentData32->Sibling != NULL) {

        newCompData64 = BlAmd64TransferConfigWorker( ComponentData32->Sibling,
                                                     ComponentDataParent64 );
        if (newCompData64 == NULL) {
            return newCompData64;
        }

        componentData64->Sibling = PTR_64(newCompData64);
    }

    return componentData64;
}


VOID
BlAmd64TransferResourceList(
    IN  PCONFIGURATION_COMPONENT_DATA ComponentData32,
    OUT PCONFIGURATION_COMPONENT_DATA_64 ComponentData64
    )

/*++

Routine Description:

    This routine transfers the 32-bit CM_PARTIAL_RESOURCE_LIST structure that
    immediately follows ComponentData32 to the memory immediately after
    ComponentData64.

Arguments:

    ComponentData32 - Supplies a pointer to the 32-bit structure to transfer from.

    ComponentData64 - Supplies a pointer to the 64-bit structure to transfer to.

Return Value:

    None.

--*/

{
    PCM_PARTIAL_RESOURCE_LIST resourceList32;
    PCM_PARTIAL_RESOURCE_LIST_64 resourceList64;

    PCM_PARTIAL_RESOURCE_DESCRIPTOR resourceDesc32;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR_64 resourceDesc64;

    PVOID descBody32;
    PVOID descBody64;

    PUCHAR tail32;
    PUCHAR tail64;
    ULONG tailSize;

    ULONG descriptorCount;

    //
    // Calculate pointers to the source and target descriptor lists.
    //

    resourceList32 = (PCM_PARTIAL_RESOURCE_LIST)ComponentData32->ConfigurationData;
    resourceList64 = (PCM_PARTIAL_RESOURCE_LIST_64)(ComponentData64 + 1);

    //
    // Update ComponentData64 to refer to it's new data area, which will be immediately
    // following the component data structure.
    //

    ComponentData64->ConfigurationData = PTR_64(resourceList64);

    //
    // Copy the resource list header information
    //

    Copy_CM_PARTIAL_RESOURCE_LIST(resourceList32,resourceList64);

    //
    // Now thunk each of the resource descriptors
    //

    descriptorCount = resourceList32->Count;
    resourceDesc32 = resourceList32->PartialDescriptors;
    resourceDesc64 = &resourceList64->PartialDescriptors;

    while (descriptorCount > 0) {

        //
        // Transfer the common header information
        //

        Copy_CM_PARTIAL_RESOURCE_DESCRIPTOR(resourceDesc32,resourceDesc64);
        descBody32 = &resourceDesc32->u;
        descBody64 = &resourceDesc64->u;

        RtlZeroMemory(descBody64,
                      sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR_64) -
                      FIELD_OFFSET(CM_PARTIAL_RESOURCE_DESCRIPTOR_64,u));

        //
        // Transfer the body according to the type
        //

        switch(resourceDesc32->Type) {

            case CmResourceTypeNull:
                break;

            case CmResourceTypePort:
                Copy_CM_PRD_PORT(descBody32,descBody64);
                break;

            case CmResourceTypeInterrupt:
                Copy_CM_PRD_INTERRUPT(descBody32,descBody64);
                break;

            case CmResourceTypeMemory:
                Copy_CM_PRD_MEMORY(descBody32,descBody64);
                break;

            case CmResourceTypeDma:
                Copy_CM_PRD_DMA(descBody32,descBody64);
                break;

            case CmResourceTypeDeviceSpecific:
                Copy_CM_PRD_DEVICESPECIFICDATA(descBody32,descBody64);
                break;

            case CmResourceTypeBusNumber:
                Copy_CM_PRD_BUSNUMBER(descBody32,descBody64);
                break;

            default:
                Copy_CM_PRD_GENERIC(descBody32,descBody64);
                break;
        }

        resourceDesc32 += 1;
        resourceDesc64 += 1;
        descriptorCount -= 1;
    }

    //
    // Calculate how much data, if any, is appended to the resource list.
    //

    tailSize = ComponentData32->ComponentEntry.ConfigurationDataLength +
               (PUCHAR)resourceList32 -
               (PUCHAR)resourceDesc32;

    if (tailSize > 0) {

        //
        // Some data is there, append it as-is to the 64-bit structure.
        //

        tail32 = (PUCHAR)resourceDesc32;
        tail64 = (PUCHAR)resourceDesc64;
        RtlCopyMemory(tail64,tail32,tailSize);
    }
}


BOOLEAN
BlAmd64ContainsResourceList(
    IN PCONFIGURATION_COMPONENT_DATA ComponentData32,
    OUT PULONG ResourceListSize64
    )

/*++

Routine Description:

    Given a 32-bit CONFIGURATION_COMPONENT_DATA structure, this routine
    determines whether the data associated with the structure contains a
    CM_PARTIAL_RESOURCE_LIST structure.

    If it does, the size of the 64-bit representation of this structure is calculated,
    added to any data that might be appended to the resource list structure, and
    returned in ResourceListSize64.

Arguments:

    ComponentData32 - Supplies a pointer to the 32-bit structure to transfer.

    ResourceListSize64 - Supplies a pointer to a ULONG in which the necessary
                         additional data size is returned.

Return Value:

    Returns TRUE if the CONFIGURATION_COMPONENT_DATA stucture refers to a
    CM_PARTIAL_RESOURCE_LIST structure, FALSE otherwise.

--*/

{
    ULONG configDataLen;
    PCM_PARTIAL_RESOURCE_LIST resourceList;
    ULONG resourceCount;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resourceDescriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR lastResourceDescriptor;

    configDataLen = ComponentData32->ComponentEntry.ConfigurationDataLength;
    if (configDataLen < sizeof(CM_PARTIAL_RESOURCE_LIST)) {

        //
        // Data not large enough to contain the smallest possible resource list
        //

        return FALSE;
    }

    resourceList = (PCM_PARTIAL_RESOURCE_LIST)ComponentData32->ConfigurationData;
    if (resourceList->Version != 0 || resourceList->Revision != 0) {

        //
        // Unrecognized version.
        //

        return FALSE;
    }

    configDataLen -= FIELD_OFFSET(CM_PARTIAL_RESOURCE_LIST,PartialDescriptors);

    resourceCount = resourceList->Count;
    if (configDataLen < sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * resourceCount) {

        //
        // Config data len is not large enough to contain a CM_PARTIAL_RESOURCE_LIST
        // as large as this one claims to be.
        //

        return FALSE;
    }

    //
    // Validate each of the CM_PARTIAL_RESOURCE_DESCRIPTOR structures in the list
    //

    resourceDescriptor = resourceList->PartialDescriptors;
    lastResourceDescriptor = resourceDescriptor + resourceCount;

    while (resourceDescriptor < lastResourceDescriptor) {

        if (resourceDescriptor->Type > CmResourceTypeMaximum) {
            return FALSE;
        }

        resourceDescriptor += 1;
    }

    //
    // Looks like this is an actual resource list.  Calculate the size of any remaining
    // data after the CM_PARTIAL_RESOURCE_LIST structure.
    //

    configDataLen -= sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * resourceCount;

    *ResourceListSize64 = sizeof(CM_PARTIAL_RESOURCE_LIST_64) +
                          sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR_64) * (resourceCount - 1) +
                          configDataLen;

    return TRUE;
}

ARC_STATUS
BlAmd64TransferNlsData(
    VOID
    )

/*++

Routine Description:

    This routine creates an NLS_DATA_BLOCK64 structure that is the
    equivalent of the 32-bit NLS_DATA_BLOCK structure referenced within
    the 32-bit loader block.

Arguments:

    None.

Return Value:

    ARC_STATUS - Status of operation.

--*/

{
    ARC_STATUS status;
    PNLS_DATA_BLOCK    nlsDataBlock32;
    PNLS_DATA_BLOCK_64 nlsDataBlock64;

    nlsDataBlock32 = BlAmd64LoaderBlock32->NlsData;
    if (nlsDataBlock32 == NULL) {
        return ESUCCESS;
    }

    nlsDataBlock64 = BlAllocateHeap(sizeof(NLS_DATA_BLOCK_64));
    if (nlsDataBlock64 == NULL) {
        return ENOMEM;
    }

    status = Copy_NLS_DATA_BLOCK( nlsDataBlock32, nlsDataBlock64 );
    if (status != ESUCCESS) {
        return status;
    }

    BlAmd64LoaderBlock64->NlsData = PTR_64( nlsDataBlock64 );

    return ESUCCESS;
}

ARC_STATUS
BlAmd64BuildLoaderBlock64(
    VOID
    )

/*++

Routine Description:

    This routine allocates a 64-bit loader parameter block and copies the
    contents of the 32-bit loader parameter block into it.

Arguments:

    None.

Return Value:

    The status of the operation.

--*/

{
    ARC_STATUS status;

    //
    // Allocate the loader block and extension
    //

    BlAmd64LoaderBlock64 = BlAllocateHeap(sizeof(LOADER_PARAMETER_BLOCK_64));
    if (BlAmd64LoaderBlock64 == NULL) {
        return ENOMEM;
    }

    //
    // Copy the contents of the 32-bit loader parameter block to the
    // 64-bit version
    //

    status = Copy_LOADER_PARAMETER_BLOCK( BlAmd64LoaderBlock32, BlAmd64LoaderBlock64 );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Build the loader block extension
    //

    status = BlAmd64BuildLoaderBlockExtension64();
    if (status != ESUCCESS) {
        return status;
    }

    return ESUCCESS;
}

ARC_STATUS
BlAmd64TransferMemoryAllocationDescriptors(
    VOID
    )

/*++

Routine Description:

    This routine transfers all of the 32-bit memory allocation descriptors
    to a 64-bit list.

    The storage for the 64-bit memory allocation descriptors has been
    preallocated by a previous call to
    BlAmd64AllocateMemoryAllocationDescriptors().  This memory is described
    by BlAmd64DescriptorArray and BlAmd64DescriptorArraySize.

Arguments:

    None.

Return Value:

    The status of the operation.

--*/

{
    ARC_STATUS status;
    PMEMORY_ALLOCATION_DESCRIPTOR    memDesc32;
    PMEMORY_ALLOCATION_DESCRIPTOR_64 memDesc64;
    PLIST_ENTRY listHead;
    PLIST_ENTRY listEntry;
    LONG descriptorCount;

    //
    // Modify some descriptor types.  All of the descriptors of type
    // LoaderMemoryData really contain things that won't be used in 64-bit
    // mode, such as 32-bit page tables and the like.
    //
    // The descriptors that we really want to stick around are allocated with
    // LoaderAmd64MemoryData.
    //
    // Perform two memory descriptor list search-and-replacements:
    //
    //  LoaderMemoryData      -> LoaderOSLoaderHeap
    //
    //      These desriptors will be freed during kernel init phase 1
    //
    //  LoaderAmd64MemoryData -> LoaderMemoryData
    //
    //      This stuff will be kept around
    //

    //
    // All existing LoaderMemoryData refers to structures that are not useful
    // once running in long mode.  However, we're using some of the structures
    // now (32-bit page tables for example), so convert them to
    // type LoaderOsloaderHeap, which will be eventually freed by the kernel.
    //

    BlAmd64ReplaceMemoryDescriptorType(LoaderMemoryData,
                                       LoaderOsloaderHeap,
                                       TRUE);

    //
    // Same for LoaderStartupPcrPage
    //

    BlAmd64ReplaceMemoryDescriptorType(LoaderStartupPcrPage,
                                       LoaderOsloaderHeap,
                                       TRUE);

    //
    // All of the permanent structures that need to be around for longmode
    // were temporarily allocated with LoaderAmd64MemoryData.  Convert all
    // of those to LoaderMemoryData now.
    //

    BlAmd64ReplaceMemoryDescriptorType(LoaderAmd64MemoryData,
                                       LoaderMemoryData,
                                       TRUE);


    //
    // Now walk the 32-bit memory descriptors, filling in and inserting a
    // 64-bit version into BlAmd64LoaderBlock64.
    //

    InitializeListHead64( &BlAmd64LoaderBlock64->MemoryDescriptorListHead );
    memDesc64 = BlAmd64DescriptorArray;
    descriptorCount = BlAmd64DescriptorArraySize;

    listHead = &BlAmd64LoaderBlock32->MemoryDescriptorListHead;
    listEntry = listHead->Flink;
    while (listEntry != listHead && descriptorCount > 0) {

        memDesc32 = CONTAINING_RECORD( listEntry,
                                       MEMORY_ALLOCATION_DESCRIPTOR,
                                       ListEntry );

        status = Copy_MEMORY_ALLOCATION_DESCRIPTOR( memDesc32, memDesc64 );
        if (status != ESUCCESS) {
            return status;
        }

#if DBG
        DbgPrint("Base 0x%08x size 0x%02x %s\n",
                 memDesc32->BasePage,
                 memDesc32->PageCount,
                 BlAmd64MemoryDescriptorText[memDesc32->MemoryType]);
#endif

        InsertTailList64( &BlAmd64LoaderBlock64->MemoryDescriptorListHead,
                          &memDesc64->ListEntry );

        listEntry = listEntry->Flink;
        memDesc64 = memDesc64 + 1;
        descriptorCount -= 1;
    }

    ASSERT( descriptorCount >= 0 && listEntry == listHead );

    return ESUCCESS;
}


ARC_STATUS
BlAmd64AllocateMemoryAllocationDescriptors(
    VOID
    )

/*++

Routine Description:

    This routine preallocates a quantity of memory sufficient to contain
    a 64-bit version of each memory allocation descriptor.

    The resultant memory is described in two globals: BlAmd64DescriptorArray
    and BlAmd64DescriptorArrayCount.

Arguments:

    None.

Return Value:

    The status of the operation.

--*/

{
    PLIST_ENTRY listHead;
    PLIST_ENTRY listEntry;
    ULONG descriptorCount;
    ULONG arraySize;
    PMEMORY_ALLOCATION_DESCRIPTOR_64 descriptorArray;

    //
    // Count the number of descriptors needed.
    //

    descriptorCount = 0;
    listHead = &BlAmd64LoaderBlock32->MemoryDescriptorListHead;
    listEntry = listHead->Flink;
    while (listEntry != listHead) {
        descriptorCount += 1;
        listEntry = listEntry->Flink;
    }

    //
    // Allocate memory sufficient to contain them all in 64-bit form.
    //

    arraySize = descriptorCount *
                sizeof(MEMORY_ALLOCATION_DESCRIPTOR_64);

    descriptorArray = BlAllocateHeap(arraySize);
    if (descriptorArray == NULL) {
        return ENOMEM;
    }

    BlAmd64DescriptorArray = descriptorArray;
    BlAmd64DescriptorArraySize = descriptorCount;

    return ESUCCESS;
}

ARC_STATUS
BlAmd64TransferLoadedModuleState(
    VOID
    )

/*++

Routine Description:

    This routine transfers the 32-bit list of LDR_DATA_TABLE_ENTRY structures
    to an equivalent 64-bit list.

Arguments:

    None.

Return Value:

    The status of the operation.

--*/

{
    PLDR_DATA_TABLE_ENTRY dataTableEntry32;
    PLDR_DATA_TABLE_ENTRY_64 dataTableEntry64;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY listHead;
    ARC_STATUS status;

    InitializeListHead64( &BlAmd64LoaderBlock64->LoadOrderListHead );

    //
    // For each of the LDR_DATA_TABLE_ENTRY structures in the 32-bit
    // loader parameter block, create a 64-bit LDR_DATA_TABLE_ENTRY
    // and queue it on the 64-bit loader parameter block.
    //

    listHead = &BlAmd64LoaderBlock32->LoadOrderListHead;
    listEntry = listHead->Flink;
    while (listEntry != listHead) {

        dataTableEntry32 = CONTAINING_RECORD( listEntry,
                                              LDR_DATA_TABLE_ENTRY,
                                              InLoadOrderLinks );

        status = BlAmd64BuildLdrDataTableEntry64( dataTableEntry32,
                                                  &dataTableEntry64 );
        if (status != ESUCCESS) {
            return status;
        }

        //
        // Insert it into the 64-bit loader block's data table queue.
        //

        InsertTailList64( &BlAmd64LoaderBlock64->LoadOrderListHead,
                          &dataTableEntry64->InLoadOrderLinks );

        listEntry = listEntry->Flink;
    }
    return ESUCCESS;
}

ARC_STATUS
BlAmd64BuildLdrDataTableEntry64(
    IN  PLDR_DATA_TABLE_ENTRY     DataTableEntry32,
    OUT PLDR_DATA_TABLE_ENTRY_64 *DataTableEntry64
    )

/*++

Routine Description:

    This routine transfers the contents of a single 32-bit
    LDR_DATA_TABLE_ENTRY structure to the 64-bit equivalent.

Arguments:

    DataTableEntry32 - Supplies a pointer to the source structure.

    DataTableEntry64 - Supplies a pointer to the destination pointer to
                       the created structure.

Return Value:

    The status of the operation.

--*/

{
    ARC_STATUS status;
    PLDR_DATA_TABLE_ENTRY_64 dataTableEntry64;

    //
    // Allocate a 64-bit data table entry and transfer the 32-bit
    // contents
    //

    dataTableEntry64 = BlAllocateHeap( sizeof(LDR_DATA_TABLE_ENTRY_64) );
    if (dataTableEntry64 == NULL) {
        return ENOMEM;
    }

    status = Copy_LDR_DATA_TABLE_ENTRY( DataTableEntry32, dataTableEntry64 );
    if (status != ESUCCESS) {
        return status;
    }

    *DataTableEntry64 = dataTableEntry64;

    //
    // Later on, we'll need to determine the 64-bit copy of this data
    // table entry.  Store the 64-bit pointer to the copy here.
    //

    *((POINTER64 *)&DataTableEntry32->DllBase) = PTR_64(dataTableEntry64);

    return ESUCCESS;
}


ARC_STATUS
BlAmd64BuildLoaderBlockExtension64(
    VOID
    )

/*++

Routine Description:

    This routine transfers the contents of the 32-bit loader block
    extension to a 64-bit equivalent.

Arguments:

    None.

Return Value:

    The status of the operation.

--*/

{
    PLOADER_PARAMETER_EXTENSION_64 loaderExtension;
    ARC_STATUS status;

    //
    // Allocate the 64-bit extension and transfer the contents of the
    // 32-bit block.
    //

    loaderExtension = BlAllocateHeap( sizeof(LOADER_PARAMETER_EXTENSION_64) );
    if (loaderExtension == NULL) {
        return ENOMEM;
    }

    //
    // Perform automatic copy of most fields
    //

    status = Copy_LOADER_PARAMETER_EXTENSION( BlLoaderBlock->Extension,
                                              loaderExtension );
    if (status != ESUCCESS) {
        return status;
    }

    //
    // Initialize Symbol list head properly
    //
    InitializeListHead64( &loaderExtension->FirmwareDescriptorListHead );

    //
    // Manually fix up remaining fields
    //

    loaderExtension->Size = sizeof(LOADER_PARAMETER_EXTENSION_64);

    BlAmd64LoaderBlock64->Extension = PTR_64(loaderExtension);

    return ESUCCESS;
}


ARC_STATUS
BlAmd64TransferBootDriverNodes(
    VOID
    )

/*++

Routine Description:

    This routine transfers the 32-bit list of BOOT_DRIVER_NODE structures
    to an equivalent 64-bit list.

Arguments:

    None.

Return Value:

    The status of the operation.

--*/

{
    PBOOT_DRIVER_LIST_ENTRY driverListEntry32;
    PBOOT_DRIVER_NODE driverNode32;
    PBOOT_DRIVER_NODE_64 driverNode64;
    POINTER64 dataTableEntry64;
    PKLDR_DATA_TABLE_ENTRY dataTableEntry;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY listHead;
    ARC_STATUS status;

    InitializeListHead64( &BlAmd64LoaderBlock64->BootDriverListHead );

    //
    // For each of the BOOT_DRIVER_NODE structures in the 32-bit
    // loader parameter block, create a 64-bit BOOT_DRIVER_NODE
    // and (possibly) associated LDR_DATA_TABLE_ENTRY structure.
    //

    listHead = &BlAmd64LoaderBlock32->BootDriverListHead;
    listEntry = listHead->Flink;
    while (listEntry != listHead) {

        driverListEntry32 = CONTAINING_RECORD( listEntry,
                                               BOOT_DRIVER_LIST_ENTRY,
                                               Link );

        driverNode32 = CONTAINING_RECORD( driverListEntry32,
                                          BOOT_DRIVER_NODE,
                                          ListEntry );

        driverNode64 = BlAllocateHeap( sizeof(BOOT_DRIVER_NODE_64) );
        if (driverNode64 == NULL) {
            return ENOMEM;
        }

        status = Copy_BOOT_DRIVER_NODE( driverNode32, driverNode64 );
        if (status != ESUCCESS) {
            return status;
        }

        dataTableEntry = driverNode32->ListEntry.LdrEntry;
        if (dataTableEntry != NULL) {

            //
            // There is already a 64-bit copy of this table entry, and we
            // stored a pointer to it at DllBase.
            //

            dataTableEntry64 = *((POINTER64 *)&dataTableEntry->DllBase);
            driverNode64->ListEntry.LdrEntry = dataTableEntry64;
        }

        //
        // Now insert the driver list entry into the 64-bit loader block.
        //

        InsertTailList64( &BlAmd64LoaderBlock64->BootDriverListHead,
                          &driverNode64->ListEntry.Link );

        listEntry = listEntry->Flink;
    }
    return ESUCCESS;
}

ARC_STATUS
BlAmd64CheckForLongMode(
    IN     ULONG LoadDeviceId,
    IN OUT PCHAR KernelPath,
    IN     PCHAR KernelFileName
    )

/*++

Routine Description:

    This routine examines a kernel image and determines whether it was
    compiled for AMD64.  The global BlAmd64UseLongMode is set to non-zero
    if a long-mode kernel is discovered.

Arguments:

    LoadDeviceId - Supplies the load device identifier.

    KernelPath - Supplies a pointer to the path to the kernel directory.
                 Upon successful return, KernelFileName will be appended
                 to this path.

    KernelFileName - Supplies a pointer to the name of the kernel file.

    Note: If KernelPath already contains the full path and filename of
          the kernel image to check, pass a pointer to "\0" for
          KernelFileName.

Return Value:

    The status of the operation.  Upon successful completion ESUCCESS
    is returned, whether long mode capability was detected or not.

--*/

{
    CHAR localBufferSpace[ SECTOR_SIZE * 2 + SECTOR_SIZE - 1 ];
    PCHAR localBuffer;
    ULONG fileId;
    PIMAGE_NT_HEADERS32 ntHeaders;
    ARC_STATUS status;
    ULONG bytesRead;
    PCHAR kernelNameTarget;

    //
    // File I/O here must be sector-aligned.
    //

    localBuffer = (PCHAR)
        (((ULONG)localBufferSpace + SECTOR_SIZE - 1) & ~(SECTOR_SIZE - 1));

    //
    // Build the path to the kernel and open it.
    //

    kernelNameTarget = KernelPath + strlen(KernelPath);
    strcpy(kernelNameTarget, KernelFileName);
    status = BlOpen( LoadDeviceId, KernelPath, ArcOpenReadOnly, &fileId );
    *kernelNameTarget = '\0';       // Restore the kernel path, assuming
                                    // failure.

    if (status != ESUCCESS) {
        return status;
    }

    //
    // Read the PE image header
    //

    status = BlRead( fileId, localBuffer, SECTOR_SIZE * 2, &bytesRead );
    BlClose( fileId );

    //
    // Determine whether the image header is valid, and if so whether
    // the image is AMD64, I386 or something else.
    //

    ntHeaders = RtlImageNtHeader( localBuffer );
    if (ntHeaders == NULL) {
        return EBADF;
    }

    if (IMAGE_64BIT(ntHeaders)) {

        //
        // Return with the kernel name appended to the path
        //

        if (BlIsAmd64Supported() != FALSE) {

            strcpy(kernelNameTarget, KernelFileName);
            BlAmd64UseLongMode = TRUE;
            status = ESUCCESS;

        } else {

            //
            // We have an AMD64 image, but the processor does not support
            // AMD64.  There is nothing we can do.
            //

            status = EBADF;
        }

    } else if (IMAGE_32BIT(ntHeaders)) {

        ASSERT( BlAmd64UseLongMode == FALSE );
        status = ESUCCESS;

    } else {

        status = EBADF;
    }

    return status;
}

ARC_STATUS
BlAmd64PrepareSystemStructures(
    VOID
    )

/*++

Routine Description:

    This routine allocates and initializes several structures necessary
    for transfer to an AMD64 kernel.  These structures include:

        GDT
        IDT
        KTSS64
        Idle thread stack
        DPC stack
        Double fault stack
        MCA exception stack

Arguments:

    None.

Return Value:

    The status of the operation.

--*/

{
    PCHAR processorData;
    ULONG dataSize;
    ULONG descriptor;
    ULONG stackOffset;

    PKTSS64_64 sysTss64;
    PCHAR idleStack;
    PCHAR dpcStack;
    PCHAR doubleFaultStack;
    PCHAR mcaStack;

    PVOID gdt64;
    PVOID idt64;

    ARC_STATUS status;

    //
    // Calculate the cumulative, rounded size of the various structures that
    // we need, and allocate a sufficient number of pages.
    //

    dataSize = ROUNDUP16(GDT_64_SIZE)                       +
               ROUNDUP16(IDT_64_SIZE)                       +
               ROUNDUP16(sizeof(KTSS64_64));

    dataSize = ROUNDUP_PAGE(dataSize);
    stackOffset = dataSize;

    dataSize += KERNEL_STACK_SIZE_64 +          // Idle thread stack
                KERNEL_STACK_SIZE_64 +          // DPC stack
                DOUBLE_FAULT_STACK_SIZE_64 +    // Double fault stack
                MCA_EXCEPTION_STACK_SIZE_64;    // MCA exception stack

    //
    // dataSize is still page aligned.
    //

    status = BlAllocateDescriptor( LoaderAmd64MemoryData,
                                   0,
                                   dataSize / PAGE_SIZE,
                                   &descriptor );
    if (status != ESUCCESS) {
        return status;
    }

    processorData = (PCHAR)(descriptor * PAGE_SIZE | KSEG0_BASE_X86);

    //
    // Zero the block that was just allocated, then get local pointers to the
    // various structures within.
    //

    RtlZeroMemory( processorData, dataSize );

    //
    // Assign the stack pointers.  Stack pointers start at the TOP of their
    // respective stack areas.
    //

    idleStack = processorData + stackOffset + KERNEL_STACK_SIZE_64;
    dpcStack = idleStack + KERNEL_STACK_SIZE_64;
    doubleFaultStack = dpcStack + DOUBLE_FAULT_STACK_SIZE_64;
    mcaStack = doubleFaultStack + MCA_EXCEPTION_STACK_SIZE_64;

    //
    // Record the idle stack base so that we can switch to it in amd64s.asm
    //

    BlAmd64IdleStack64 = PTR_64(idleStack);

    //
    // Assign pointers to GDT, IDT and KTSS64.
    //

    gdt64 = (PVOID)processorData;
    processorData += ROUNDUP16(GDT_64_SIZE);

    idt64 = (PVOID)processorData;
    processorData += ROUNDUP16(IDT_64_SIZE);

    sysTss64 = (PKTSS64_64)processorData;
    processorData += ROUNDUP16(sizeof(KTSS64_64));

    //
    // Build the GDT.  This is done in amd64.c as it involves AMD64
    // structure definitions.  The IDT remains zeroed.
    //

    BlAmd64BuildAmd64GDT( sysTss64, gdt64 );

    //
    // Build the pseudo-descriptors for the GDT and IDT.  These will
    // be referenced during the long-mode transition in amd64s.asm.
    //

    BlAmd64GdtDescriptor.Limit = (USHORT)(GDT_64_SIZE - 1);
    BlAmd64GdtDescriptor.Base = PTR_64(gdt64);

    BlAmd64IdtDescriptor.Limit = (USHORT)(IDT_64_SIZE - 1);
    BlAmd64IdtDescriptor.Base = PTR_64(idt64);

    //
    // Build another GDT pseudo-descriptor, this one with a 32-bit
    // base.  This base address must be a 32-bit address that is addressible
    // from long mode during init, so use the mapping in the identity mapped
    // region.
    //

    BlAmd32GdtDescriptor.Limit = (USHORT)(GDT_64_SIZE - 1);
    BlAmd32GdtDescriptor.Base = (ULONG)gdt64 ^ KSEG0_BASE_X86;

    //
    // Initialize the system TSS
    //

    sysTss64->Rsp0 = PTR_64(idleStack);
    sysTss64->Ist[TSS64_IST_PANIC] = PTR_64(doubleFaultStack);
    sysTss64->Ist[TSS64_IST_MCA] = PTR_64(mcaStack);

    //
    // Fill required fields within the loader block
    //

    BlAmd64LoaderBlock64->KernelStack = PTR_64(dpcStack);

    return ESUCCESS;
}

VOID
BlAmd64ReplaceMemoryDescriptorType(
    IN TYPE_OF_MEMORY Target,
    IN TYPE_OF_MEMORY Replacement,
    IN BOOLEAN Coallesce
    )

/*++

Routine Description:

    This routine walks the 32-bit memory allocation descriptor list and
    performs a "search and replace" of the types therein.

    Optionally, it will coallesce each successful replacement with
    adjacent descriptors of like type.

Arguments:

    Target - The descriptor type to search for

    Replacement - The type with which to replace each located Target type.

    Coallesce - If !FALSE, indicates that each successful replacement should
                be coallesced with any like-typed neighbors.

Return Value:

    None.

--*/

{
    PMEMORY_ALLOCATION_DESCRIPTOR descriptor;
    PMEMORY_ALLOCATION_DESCRIPTOR adjacentDescriptor;
    PLIST_ENTRY listHead;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY adjacentListEntry;

    listHead = &BlAmd64LoaderBlock32->MemoryDescriptorListHead;
    listEntry = listHead;
    while (TRUE) {

        listEntry = listEntry->Flink;
        if (listEntry == listHead) {
            break;
        }

        descriptor = CONTAINING_RECORD(listEntry,
                                       MEMORY_ALLOCATION_DESCRIPTOR,
                                       ListEntry);
        if (descriptor->MemoryType != Target) {
            continue;
        }

        descriptor->MemoryType = Replacement;
        if (Coallesce == FALSE) {

            //
            // Do not attempt to coallesce
            //

            continue;
        }

        //
        // Now attempt to coallesce the descriptor.  First try the
        // next descriptor.
        //

        adjacentListEntry = listEntry->Flink;
        if (adjacentListEntry != listHead) {

            adjacentDescriptor = CONTAINING_RECORD(adjacentListEntry,
                                                   MEMORY_ALLOCATION_DESCRIPTOR,
                                                   ListEntry);

            if (adjacentDescriptor->MemoryType == descriptor->MemoryType &&
                descriptor->BasePage + descriptor->PageCount ==
                adjacentDescriptor->BasePage) {

                descriptor->PageCount += adjacentDescriptor->PageCount;
                BlRemoveDescriptor(adjacentDescriptor);
            }
        }

        //
        // Now try the previous descriptor.
        //

        adjacentListEntry = listEntry->Blink;
        if (adjacentListEntry != listHead) {

            adjacentDescriptor = CONTAINING_RECORD(adjacentListEntry,
                                                   MEMORY_ALLOCATION_DESCRIPTOR,
                                                   ListEntry);

            if (adjacentDescriptor->MemoryType == descriptor->MemoryType &&
                adjacentDescriptor->BasePage + adjacentDescriptor->PageCount ==
                descriptor->BasePage) {

                descriptor->PageCount += adjacentDescriptor->PageCount;
                descriptor->BasePage -= adjacentDescriptor->PageCount;
                BlRemoveDescriptor(adjacentDescriptor);
            }
        }
    }
}

ARC_STATUS
BlAmd64FixSharedUserPage(
    VOID
    )
{
    PFN_NUMBER pfn;
    PMEMORY_ALLOCATION_DESCRIPTOR descriptor;
    ARC_STATUS status;

    //
    // The shared user page is allocated as LoaderMemoryData.  All
    // LoaderMemoryData descriptors will be converted to LoaderOsloaderHeap
    // during the transition to 64-bit mode, as the assumption is made that
    // all of the old structures will no longer be needed.
    //
    // The shared user page is the exception to this rule, so it must be
    // found and placed into an appropriately marked descriptor.
    //

    //
    // Get the pfn of the shared user page, find its descriptor,
    // carve out a new descriptor that contains just that page and give
    // it a type of LoaderAmd64MemoryData.
    //

    BlAmd64IsPageMapped( KI_USER_SHARED_DATA, &pfn, NULL );
    descriptor = BlFindMemoryDescriptor( pfn );
    status = BlGenerateDescriptor(descriptor,
                                  LoaderAmd64MemoryData,
                                  pfn,
                                  1);
    return status;
}

BOOLEAN
BlAmd64Setup (
    IN PCHAR SetupDevice
    )

/*++

Routine Description:

    This routine determines whether we are installing an I386 or AMD64 build.
    If the directory "\\AMD64" exists at the root of DriveId then it is
    assumed that an AMD64 installation is being performed.

Arguments:

    SetupDevice - Supplies the ARC path to the setup device.  This parameter
        need only be supplied on the first invocation of this routine.  The
        result of the first call is cached for subsequent invocations.

Return Value:

    TRUE  - An AMD64 installation is being performed.
    FALSE - An I386 installation is being performed.

--*/

{
    ULONG deviceId;
    ULONG dirId;
    ARC_STATUS status;

    static BOOLEAN alreadyDetected = FALSE;
    static BOOLEAN detectedAmd64 = FALSE;

    if (alreadyDetected == FALSE) {

        ASSERT(SetupDevice != NULL);

        status = ArcOpen(SetupDevice, ArcOpenReadOnly, &deviceId);
        if (status == ESUCCESS) {
            status = BlOpen(deviceId, "\\AMD64", ArcOpenDirectory, &dirId);
            if (status == ESUCCESS) {
                detectedAmd64 = TRUE;
                BlClose(dirId);
            }
            ArcClose(deviceId);
        }
        alreadyDetected = TRUE;
    }

    return detectedAmd64;
}

VOID   
BlCheckForAmd64Image(
    PPO_MEMORY_IMAGE MemImage
    )

/*++

Routine Description:

    This routine determines whether a hibernate file was created for
    Amd64 platform. BlAmd64UseLongMode will be set accordingly.

Arguments:

    MemImage - Header of hibernate image file.

Return Value:

    None.

--*/

{
    
    //
    // It is assumed that "version" and "LengthSelf" field can be reference 
    // in same way between a x86 and an Amd64 image header.
    //

    if((MemImage->Version == 0) && 
       (MemImage->LengthSelf == sizeof(PO_MEMORY_IMAGE_64))) {
        BlAmd64UseLongMode = TRUE;
    }
}

ULONG
BlAmd64FieldOffset_PO_MEMORY_IMAGE(
    ULONG offset32
    ) 

/*++

Routine Description:

    This routine helps to access 64-bit version of PO_MEMORY_IMAGE from
    its 32-bit definition. It calculates the offset of a field in 64-bit 
    definition from the offset of same field in 32-bit definiation.
    

Arguments:

    offset32 - Field offset of 32-bit definiation.

Return Value:

    Field offset of 64-bit definiation.

--*/

{
    PCOPY_REC copyRec;

    copyRec = cr3264_PO_MEMORY_IMAGE;

    while (copyRec->Size32 != 0) {
        if (copyRec->Offset32 == offset32) {
            return copyRec->Offset64;
        }
        copyRec++;
    }
    return 0;
}

ULONG
BlAmd64FieldOffset_PO_MEMORY_RANGE_ARRAY_LINK(
    ULONG offset32
    ) 

/*++

Routine Description:

    This routine helps to access 64-bit version of PO_MEMORY_RANGE_ARRAY_LINK 
    from its 32-bit definition. It calculates the offset of a field in 64-bit 
    definition from the offset of same field in 32-bit definiation.
    

Arguments:

    offset32 - Field offset of 32-bit definiation.

Return Value:

    Field offset of 64-bit definiation.

--*/

{
    PCOPY_REC copyRec;

    copyRec = cr3264_PO_MEMORY_RANGE_ARRAY_LINK;

    while (copyRec->Size32 != 0) {
        if (copyRec->Offset32 == offset32) {
            return copyRec->Offset64;
        }
        copyRec++;
    }
    return 0;
}

ULONG
BlAmd64FieldOffset_PO_MEMORY_RANGE_ARRAY_RANGE(
    ULONG offset32
    ) 

/*++

Routine Description:

    This routine helps to access 64-bit version of PO_MEMORY_RANGE_ARRAY_RANGE
    from its 32-bit definition. It calculates the offset of a field in 64-bit 
    definition from the offset of same field in 32-bit definiation.

Arguments:

    offset32 - Field offset of 32-bit definiation.

Return Value:

    Field offset of 64-bit definiation.

--*/

{
    PCOPY_REC copyRec;

    copyRec = cr3264_PO_MEMORY_RANGE_ARRAY_RANGE;

    while (copyRec->Size32 != 0) {
        if (copyRec->Offset32 == offset32) {
            return copyRec->Offset64;
        }
        copyRec++;
    }
    return 0;
}

ULONG
BlAmd64ElementOffset_PO_MEMORY_RANGE_ARRAY_LINK(
    ULONG index
    )

/*++

Routine Description:

    This routine calculates the offset of a element in a structure array. 
    Each element in this array is defined as PO_MORY_RANGE_ARRAY_LINK in
    it 64-bit format.

Arguments:

    index - Supplies the index of a element.

Return Value:

    Offset of the element from base address of the array.

--*/

{
    return (ULONG)(&(((PO_MEMORY_RANGE_ARRAY_LINK_64 *)0)[index]));
}

ULONG
BlAmd64ElementOffset_PO_MEMORY_RANGE_ARRAY_RANGE(
    ULONG index
    )

/*++

Routine Description:

    This routine calculates the offset of a element in a structure array. 
    Each element in this array is defined as PO_MEMORY_RANGE_ARRAY_RANGE
    in its 64-bit format.

Arguments:

    index - Supplies the index of a element.

Return Value:

    Offset of the element from base address of the array.

--*/

{
    return (ULONG)(&(((PO_MEMORY_RANGE_ARRAY_RANGE_64 *)0)[index]));
}


#define BL_ENABLE_REMAP

#if defined(BL_ENABLE_REMAP)

#include "hammernb.h"
#include "acpitabl.h"
#include "pci.h"
#include "ntacpi.h"

#if !defined(_4G)
#define _4G (1UI64 << 32)
#endif

extern PRSDP BlRsdp;
extern PRSDT BlRsdt;
extern PXSDT BlXsdt;

BOOLEAN
BlAmd64GetNode1Info (
    OUT ULONG *Base,
    OUT ULONG *Size
    );

BOOLEAN
BlAmd64RelocateAcpi (
    ULONG Node0Base,
    ULONG Node0Limit,
    ULONG Node1Base,
    ULONG Node1Limit
    );

BOOLEAN
BlAmd64RemapMTRRs (
    IN ULONG OldBase,
    IN ULONG NewBase,
    IN ULONG Size
    );

BOOLEAN
BlAmd64RemapNode1Dram (
    IN ULONG NewBase
    );

ULONG
StringToUlong (
    IN PCHAR String
    );


BOOLEAN
BlAmd64RemapDram (
    IN PCHAR LoaderOptions
    )

/*++

Routine Description:

    This routine looks for the /RELOCATEPHYSICAL= switch supplied as a loader
    option.  The option directs the loader to relocate node 1's physical memory
    to the address supplied.

    The address represents the new physical memory base in 1GB units.
    For example, to relocate node 1's physical memory to 128GB, use:

    /RELOCATEPHYSICAL=128

Arguments:

    LoaderOptions - Supplies a pointer to the loader option string

Return Value:

    TRUE if the relocation was performed, FALSE otherwise

--*/

{
    BOOLEAN result;
    ULONG oldBase;
    ULONG oldLimit;
    ULONG newBase;
    ULONG newBasePage;
    ULONG size;
    PMEMORY_ALLOCATION_DESCRIPTOR descriptor;
    PLIST_ENTRY listHead;
    PLIST_ENTRY listEntry;
    ULONG descriptorBase;
    ULONG descriptorLimit;
    ARC_STATUS status;
    PCHAR pch;
    ULONG type;

    newBase = 0;
    if (LoaderOptions != NULL) {

        pch = strstr(LoaderOptions,"RELOCATEPHYSICAL=");
        if (pch != NULL) {
            newBase = StringToUlong( pch + strlen( "RELOCATEPHYSICAL=" ));
        }
    }
    if (newBase == 0) {
        return FALSE;
    }

    //
    // The parameter is supplied in GB, convert to 16MB chunks for internal
    // use
    //

    newBase *= 64;

    //
    // Determine the chunk of physical memory associated with node 1.
    // Note that this routine will relocate the ACPI tables if a suitable
    // node 1 bridge device was found.
    //

    result = BlAmd64GetNode1Info( &oldBase, &size );
    if (result == FALSE) {
        return FALSE;
    }

    newBasePage = newBase << (24 - 12);
    oldLimit = oldBase + size - 1;

    //
    // Make sure that the descriptors describing that physical memory
    // haven't already been allocated.  Acceptable descriptor
    // types are Free, LoaderReserve and SpecialMemory.
    //

    listHead = &BlLoaderBlock->MemoryDescriptorListHead;
    listEntry = listHead->Flink;
    while (listEntry != listHead) {

        descriptor = CONTAINING_RECORD(listEntry,
                                       MEMORY_ALLOCATION_DESCRIPTOR,
                                       ListEntry);

        descriptorBase = descriptor->BasePage;
        descriptorLimit = descriptorBase + descriptor->PageCount - 1;

        if ((descriptorBase <= oldLimit) && (descriptorLimit >= oldBase)) {
        
            //
            // Some or all of this memory descriptor lies within the
            // relocated region.
            //

            if (descriptor->MemoryType != LoaderFree &&
                descriptor->MemoryType != LoaderSpecialMemory &&
                descriptor->MemoryType != LoaderReserve) {

                return FALSE;
            }
        }

        listEntry = listEntry->Flink;
    }

    //
    // From the loader perspective everything looks good, perform the remap.
    //

    result = BlAmd64RemapNode1Dram( newBase );
    if (result == FALSE) {
        return FALSE;
    }

    //
    // The bridge(s) have been reprogrammed.  Now walk the memory descriptor
    // lists, performing necessary relocations.
    //

    listHead = &BlLoaderBlock->MemoryDescriptorListHead;
    listEntry = listHead->Flink;
    while (listEntry != listHead) {

        descriptor = CONTAINING_RECORD(listEntry,
                                       MEMORY_ALLOCATION_DESCRIPTOR,
                                       ListEntry);

        descriptorBase = descriptor->BasePage;
        descriptorLimit = descriptorBase + descriptor->PageCount - 1;

        if ((descriptorBase <= oldLimit) && (descriptorLimit >= oldBase)) {

            //
            // Some or all of this memory descriptor lies within the
            // relocated region.
            //

            if (descriptorBase >= oldBase && descriptorLimit <= oldLimit) {

                //
                // The descriptor lies entirely within the relocation range
                // so relocate the whole thing.
                //

            } else {

                //
                // Only part of the descriptor lies within the relocation
                // range, so a new descriptor must be allocated.
                //

                if (descriptorBase < oldBase) {
                    descriptorBase = oldBase;
                }

                if (descriptorLimit > oldLimit) {
                    descriptorLimit = oldLimit;
                }

                type = descriptor->MemoryType;

                status = BlGenerateDescriptor( descriptor,
                                               LoaderSpecialMemory,
                                               descriptorBase,
                                               descriptorLimit - descriptorBase + 1 );
                ASSERT(status == ESUCCESS);

                listEntry = listEntry->Flink;
                descriptor = CONTAINING_RECORD(listEntry,
                                               MEMORY_ALLOCATION_DESCRIPTOR,
                                               ListEntry);
                descriptor->MemoryType = type;
            }

            listEntry = listEntry->Flink;

            BlRemoveDescriptor( descriptor );
            descriptor->BasePage = descriptor->BasePage - oldBase + newBasePage;
            BlInsertDescriptor( descriptor );

        } else {

            listEntry = listEntry->Flink;
        }
    }

    //
    // Recalculate BlHighestPage
    //

    BlHighestPage = 0;
    listHead = &BlLoaderBlock->MemoryDescriptorListHead;
    listEntry = listHead->Flink;
    while (listEntry != listHead) {

        descriptor = CONTAINING_RECORD(listEntry,
                                       MEMORY_ALLOCATION_DESCRIPTOR,
                                       ListEntry);

        descriptorBase = descriptor->BasePage;
        descriptorLimit = descriptorBase + descriptor->PageCount - 1;

        if (descriptor->MemoryType != LoaderSpecialMemory &&
            descriptor->MemoryType != LoaderReserve &&
            descriptorLimit > BlHighestPage) {

            BlHighestPage = descriptorLimit;
        }

        listEntry = listEntry->Flink;
    }

    //
    // Remap the MTRRs
    //

    result = BlAmd64RemapMTRRs( oldBase, newBase, oldLimit - oldBase + 1 );
    if (result == FALSE) {
        return FALSE;
    }

    return TRUE;
}


ULONG
StringToUlong (
    IN PCHAR String
    )

/*++

Routine Description:

    This routine converts a hexadecimal or decimal string to
    a 32-bit unsigned integer.

Arguments:

    String - Supplies a null-terminated ASCII string in decimal or
             hexadecimal format.

             01234567 - decimal format
             0x01234567 - hexadecimal format

             The input string is processed until an invalid character or
             the end of the string is encountered.

Return Value:

    Returns the value of the parsed string.

--*/

{
    CHAR ch;
    PCHAR pch;
    ULONG result;
    int radix;
    UCHAR digit;

    pch = String;
    result = 0;
    radix = 10;
    while (TRUE) {
        ch = (char)toupper(*pch);

        if ((ch >= '0' && ch <= '9') ||
            (ch >= 'A' && ch <= 'F')) {

            if (ch >= '0' && ch <= '9') {
                digit = ch - '0';
            } else {
                digit = ch - 'A' + 10;
            }
            result = result * radix + digit;
        } else if (ch == 'X') {
            if (result == 0) {
                radix = 16;
            } else {
                break;
            }
        } else {
            break;
        }

        pch += 1;
    }

    return result;
}


BOOLEAN
BlAmd64RemapNode1Dram (
    IN ULONG NewBase
    )

/*++

Routine Description:

    Relocates node 1 memory to a new physical address and reprograms
    MSRs related to the physical memory map.

Arguments:

    NewBase - Supplies bits [39:24] of the desired new physical base address
              of the memory associated with node 1.

Return Value:

    TRUE if the operation was successful, FALSE otherwise.

--*/

{
    AMD_NB_FUNC1_CONFIG nodeConfigArray[8];
    PAMD_NB_FUNC1_CONFIG nodeConfig;
    PAMD_NB_DRAM_MAP dramMap;
    ULONG length;
    PCI_SLOT_NUMBER slotNumber;
    ULONG nodeCount;
    ULONG nodeIndex;
    ULONG span;
    ULONG oldBase;
    ULONG oldLimit;
    ULONG newLimit;
    ULONG64 topMem;
    ULONG64 topMem4G;
    ULONG64 msrValue;
    ULONG64 base64;
    ULONG64 limit64;

    //
    // NewBase supplies the new DRAM base[39:24]
    //

    nodeCount = 0;
    nodeConfig = nodeConfigArray;
    do {

        slotNumber.u.AsULONG = 0;
        slotNumber.u.bits.DeviceNumber = NB_DEVICE_BASE + nodeCount;
        slotNumber.u.bits.FunctionNumber = 1;
    
        length = HalGetBusDataByOffset( PCIConfiguration,
                                        0,
                                        slotNumber.u.AsULONG,
                                        nodeConfig,
                                        0,
                                        sizeof(*nodeConfig) );
        if (length != sizeof(*nodeConfig)) {
            break;
        }

        if (BlAmd64ValidateBridgeDevice( nodeConfig ) == FALSE) {
            break;
        }

#if 0
        for (mapIndex = 0; mapIndex < 8; mapIndex += 1) {

            if (nodeConfig->DRAMMap[mapIndex].ReadEnable != 0) {

                limit = nodeConfig->DRAMMap[mapIndex].Limit;
                if (limit > NewBase) {

                    //
                    // The new base was found to conflict with existing
                    // ram.
                    //

                    return FALSE;
                }
            }
        }
#endif

        nodeCount += 1;
        nodeConfig += 1;

    } while  (nodeCount <= 8);

    if (nodeCount < 2) {

        //
        // This remap can only be performed on systems with more than
        // two nodes.
        //

        return FALSE;
    }

    //
    // We always remap the second node's memory (node 1).
    //

    nodeConfig = nodeConfigArray;
    dramMap = &nodeConfig->DRAMMap[1];
    oldBase = dramMap->Base;
    oldLimit = dramMap->Limit;
    span = oldLimit - oldBase;
    newLimit = NewBase + span;

    for (nodeIndex = 0; nodeIndex < nodeCount; nodeIndex += 1) {

        ASSERT(dramMap->Base == oldBase);
        ASSERT(dramMap->Limit == oldLimit);

        dramMap->Base = NewBase;
        dramMap->Limit = newLimit;

        slotNumber.u.AsULONG = 0;
        slotNumber.u.bits.DeviceNumber = NB_DEVICE_BASE + nodeIndex;
        slotNumber.u.bits.FunctionNumber = 1;
    
        length = HalSetBusDataByOffset( PCIConfiguration,
                                        0,
                                        slotNumber.u.AsULONG,
                                        dramMap,
                                        FIELD_OFFSET(AMD_NB_FUNC1_CONFIG,DRAMMap[1]),
                                        sizeof(*dramMap) );
        if (length != sizeof(*dramMap)) {

            //
            // We may be severely hosed here, if we have already
            // reprogrammed some of the bridges.
            //

            return FALSE;
        }

        nodeConfig += 1;
        dramMap = &nodeConfig->DRAMMap[1];
    }

    //
    // Determine the address of the last byte of ram under 4G and the last
    // byte of ram overall.
    //

    topMem = 0;
    topMem4G = 0;
    for (nodeIndex = 0; nodeIndex < nodeCount; nodeIndex += 1) {

        base64 = nodeConfigArray[0].DRAMMap[nodeIndex].Base;
        base64 <<= 24;

        limit64 = nodeConfigArray[0].DRAMMap[nodeIndex].Limit;
        limit64 = (limit64 + 1) << 24;

        if (base64 < _4G) {
            if (topMem4G < limit64) {
                topMem4G = limit64;
            }
        }

        if (topMem < limit64) {
            topMem = limit64;
        }
    }

    //
    // Indicate whether a memory hole exists below 4G.
    //

    if (topMem4G < _4G) {
        msrValue = RDMSR(MSR_TOP_MEM);
        WRMSR(MSR_TOP_MEM,topMem4G & MSR_TOP_MEM_MASK);
    }

    //
    // If memory above _4G was located then enable and program TOP_MEM_2
    //

    if (topMem > _4G) {
        msrValue = RDMSR(MSR_SYSCFG);
        msrValue |= SYSCFG_MTRRTOM2EN;
        WRMSR(MSR_TOP_MEM_2, topMem & MSR_TOP_MEM_MASK);
        WRMSR(MSR_SYSCFG,msrValue);
    }

    return TRUE;
}


BOOLEAN
BlAmd64GetNode1Info (
    OUT ULONG *Base,
    OUT ULONG *Size
    )

/*++

Routine Description:

    This routine determines the configuration of the block of physical
    memory associated with node 1 (the second northbridge).

    It also relocates the ACPI tables in node 1 to memory in node 0.

Arguments:

    Base - supplies a pointer to the location in which to store the base
           PFN of the node 1 memory block.

    Size - supplies a pointer to the location in which to store the size,
           in pages, of the node 1 memory block.

Return Value:

    TRUE - A suitable second northbridge was found and the ACPI tables therein
           were relocated if necessary.

    FALSE - A suitable second northbridge was not found.

--*/

{
    AMD_NB_FUNC1_CONFIG nodeConfig;
    PCI_SLOT_NUMBER slotNumber;
    ULONG length;
    ULONG base;
    ULONG size;
    ULONG node0Base;
    ULONG node0Size;

    //
    // Get the configuration of northbridge 1.
    //

    slotNumber.u.AsULONG = 0;
    slotNumber.u.bits.DeviceNumber = NB_DEVICE_BASE + 1;
    slotNumber.u.bits.FunctionNumber = 1;

    length = HalGetBusDataByOffset( PCIConfiguration,
                                    0,
                                    slotNumber.u.AsULONG,
                                    &nodeConfig,
                                    0,
                                    sizeof(nodeConfig) );
    if (length != sizeof(nodeConfig)) {
        return FALSE;
    }

    if (BlAmd64ValidateBridgeDevice( &nodeConfig ) == FALSE) {
        return FALSE;
    }

    //
    // A second northbridge exists, the relocation can be performed.
    // 

    base = nodeConfig.DRAMMap[1].Base;
    size = nodeConfig.DRAMMap[1].Limit - base + 1;

    *Base = base << (24 - 12);
    *Size = size << (24 - 12);

    node0Base = nodeConfig.DRAMMap[0].Base;
    node0Size = nodeConfig.DRAMMap[0].Limit - node0Base + 1;

    node0Base <<= (24 - 12);
    node0Size <<= (24 - 12);

    BlAmd64RelocateAcpi( node0Base,
                         node0Base + node0Size - 1,
                         *Base,
                         *Base + *Size - 1 );

    return TRUE;
}


BOOLEAN
BlAmd64RemapMTRRs (
    IN ULONG OldBase,
    IN ULONG NewBase,
    IN ULONG Size
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    //
    // All parameters expressed in pages
    //

    ULONG mtrrCount;
    ULONG index;
    MTRR_CAPABILITIES mtrrCapabilities;
    PMTRR_VARIABLE_BASE baseArray;
    PMTRR_VARIABLE_MASK maskArray;
    ULONG allocationSize;

    UNREFERENCED_PARAMETER(Size);
    UNREFERENCED_PARAMETER(OldBase);
    UNREFERENCED_PARAMETER(NewBase);

    //
    // Determine how many variable MTRRs are supported and
    // allocate enough storage for all of them
    //

    mtrrCapabilities.QuadPart = RDMSR(MTRR_MSR_CAPABILITIES);
    mtrrCount = (ULONG)mtrrCapabilities.Vcnt;

    allocationSize = sizeof(*baseArray) * mtrrCount * 2;
    baseArray = _alloca(allocationSize);
    maskArray = (PMTRR_VARIABLE_MASK)(baseArray + mtrrCount);
    RtlZeroMemory(baseArray,allocationSize);

    //
    // Read the variable MTRRSs.  At the same time, look for the
    // MTRR register that contains the old region, and a free
    // one as well.
    //

    for (index = 0; index < mtrrCount; index += 1) {
        baseArray[index].QuadPart = RDMSR(MTRR_MSR_VARIABLE_BASE + index * 2);
        maskArray[index].QuadPart = RDMSR(MTRR_MSR_VARIABLE_MASK + index * 2);
    }

    //
    // For now just clear the mask bits in MTRR register 0.  This expands the
    // first MTRR region so that it covers all memory.
    //

    maskArray[0].Mask = 0;

    //
    // Now reprogram the modified MTRR table
    //

    for (index = 0; index < mtrrCount; index += 1) {

        WRMSR(MTRR_MSR_VARIABLE_BASE + index * 2,baseArray[index].QuadPart);
        WRMSR(MTRR_MSR_VARIABLE_MASK + index * 2,maskArray[index].QuadPart);
    }

    return TRUE;
}


BOOLEAN
BlAmd64UpdateAcpiConfigurationEntry (
    ULONG NewPhysical
    )

/*++

Routine Description:

    NTDETECT located the physical pointer to the ACPI RSDT table and passed it
    up as a configuration node.

    This routine finds that configuration node and replaces the physical address
    therein with a new address.

    This routine would be called after relocating the ACPI tables.

Arguments:

    NewPhysical - Supplies the new physical address of the relocated ACPI tables.

Return Value:

    TRUE if the relocation was performed, FALSE otherwise.

--*/

{
    PCONFIGURATION_COMPONENT_DATA component;
    PCONFIGURATION_COMPONENT_DATA resume;
    PCM_PARTIAL_RESOURCE_LIST prl;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR prd;
    PACPI_BIOS_MULTI_NODE rsdp;

    resume = NULL;
    while (TRUE) {
        component = KeFindConfigurationNextEntry( BlLoaderBlock->ConfigurationRoot,
                                                  AdapterClass,
                                                  MultiFunctionAdapter,
                                                  NULL,
                                                  &resume );
        if (component == NULL) {
            return FALSE;
        }

        if (strcmp(component->ComponentEntry.Identifier,"ACPI BIOS") == 0) {
            break;
        }

        resume = component;
    }

    prl = (PCM_PARTIAL_RESOURCE_LIST)component->ConfigurationData;
    prd = prl->PartialDescriptors;

    rsdp = (PACPI_BIOS_MULTI_NODE)(prd + 1);
    rsdp->RsdtAddress.QuadPart = NewPhysical;

    return TRUE;
}


BOOLEAN
BlAmd64RelocateAcpi (
    ULONG Node0Base,
    ULONG Node0Limit,
    ULONG Node1Base,
    ULONG Node1Limit
    )

/*++

Routine Description:

    This routine looks for ACPI tables within node 1's physical memory and,
    if found, relocates them to node 0 memory.

Arguments:

    Node0Base - Supplies the lowest PFN of node 0 memory

    Node0Limit - Supplies the highest PFN of node 0 memory

    Node1Base - Supplies the lowest PFN of node 1 memory (before relocation)

    Node1Limit - Supplies the highest PFN of node 1 memory (before relocation)

Return Value:

    Returns TRUE if successful, FALSE if a problem was encountered.

--*/

{
    ULONG oldRsdtPhysical;
    ULONG oldRsdtPhysicalPage;
    ULONG newBasePage;
    ULONG descriptorSize;
    PLIST_ENTRY listHead;
    PLIST_ENTRY listEntry;
    PMEMORY_ALLOCATION_DESCRIPTOR oldAcpiDescriptor;
    PMEMORY_ALLOCATION_DESCRIPTOR newAcpiDescriptor;
    PMEMORY_ALLOCATION_DESCRIPTOR descriptor;
    PCHAR oldAcpiVa;
    PCHAR newAcpiVa;
    PHYSICAL_ADDRESS physicalAddress;
    ULONG vaBias;
    PDESCRIPTION_HEADER descriptionHeader;
    ULONG physAddr;
    PFADT fadt;
    ARC_STATUS status;
    ULONG index;
    ULONG rsdtPhysical;
    ULONG rsdtLength;

    //
    // Add physicalBias to an ACPI physical pointer to relocate it
    //

    ULONG physicalBias;

    oldRsdtPhysical = BlRsdp->RsdtAddress;
    oldRsdtPhysicalPage = oldRsdtPhysical >> PAGE_SHIFT;

    //
    // Determine whether the descriptor resides in node 1's physical memory.
    // If it does not then it does not need to be relocated.
    //

    if (oldRsdtPhysicalPage < Node1Base ||
        oldRsdtPhysicalPage > Node1Limit) {

        return TRUE;
    }

    //
    // Find the descriptor that contains the ACPI tables
    //

    oldAcpiDescriptor = BlFindMemoryDescriptor( oldRsdtPhysicalPage );

    //
    // Find a descriptor in node 0 memory that is suitable for
    // allocating the new ACPI tables from
    //

    listHead = &BlLoaderBlock->MemoryDescriptorListHead;
    listEntry = listHead->Blink;
    while (TRUE) {

        descriptor = CONTAINING_RECORD(listEntry,
                                       MEMORY_ALLOCATION_DESCRIPTOR,
                                       ListEntry);

        if ((descriptor->MemoryType == LoaderReserve) &&
            (descriptor->BasePage > Node0Base) &&
            ((descriptor->BasePage + oldAcpiDescriptor->PageCount) < Node0Limit)) {

            break;
        }

        listEntry = listEntry->Blink;
        if (listEntry == listHead) {
            return FALSE;
        }
    }

    //
    // Carve out the new ACPI descriptor
    //

    newBasePage = Node0Limit - oldAcpiDescriptor->PageCount + 1;
    if ((newBasePage + oldAcpiDescriptor->PageCount) >
        (descriptor->BasePage + descriptor->PageCount)) {

        newBasePage = descriptor->BasePage +
                      descriptor->PageCount -
                      oldAcpiDescriptor->PageCount;
    }

    status = BlGenerateDescriptor( descriptor,
                                   LoaderSpecialMemory,
                                   newBasePage,
                                   oldAcpiDescriptor->PageCount );
    ASSERT( status == ESUCCESS );

    newAcpiDescriptor = BlFindMemoryDescriptor( newBasePage );
    ASSERT( newAcpiDescriptor != NULL );

    //
    // Unmap the old RSDT
    //

    MmUnmapIoSpace( BlRsdt, BlRsdt->Header.Length );

    //
    // Map both descriptors, copy data from new to old, then unmap
    // and free the old descriptor.
    //

    descriptorSize = oldAcpiDescriptor->PageCount << PAGE_SHIFT;

    physicalAddress.QuadPart = oldAcpiDescriptor->BasePage << PAGE_SHIFT;
    oldAcpiVa = MmMapIoSpace (physicalAddress, descriptorSize, MmCached);

    physicalAddress.QuadPart = newAcpiDescriptor->BasePage << PAGE_SHIFT;
    newAcpiVa = MmMapIoSpace (physicalAddress, descriptorSize, MmCached);

    RtlCopyMemory( newAcpiVa, oldAcpiVa, descriptorSize );
    MmUnmapIoSpace( oldAcpiVa, descriptorSize );
    oldAcpiDescriptor->MemoryType = LoaderReserve;

    //
    // Now thunk the new ACPI tables.
    //

    physicalBias = (newAcpiDescriptor->BasePage - oldAcpiDescriptor->BasePage) << PAGE_SHIFT;
    vaBias = (ULONG)newAcpiVa - (newAcpiDescriptor->BasePage << PAGE_SHIFT);

    #define PHYS_TO_VA(p) (PVOID)(p + vaBias)

    rsdtPhysical = BlRsdp->RsdtAddress + physicalBias;
    BlRsdp->RsdtAddress = rsdtPhysical;

    ASSERT(BlXsdt == NULL);
    BlRsdt = (PRSDT)PHYS_TO_VA(rsdtPhysical);

    //
    // Thunk the phys mem pointer array at the end of the RSDT
    //

    for (index = 0; index < NumTableEntriesFromRSDTPointer(BlRsdt); index += 1) {

        physAddr = BlRsdt->Tables[index];
        physAddr += physicalBias;
        BlRsdt->Tables[index] = physAddr;

        //
        // Look for tables that themselves have physical pointers that require thunking
        //

        descriptionHeader = (PDESCRIPTION_HEADER)(PHYS_TO_VA(physAddr));
        if (descriptionHeader->Signature == FADT_SIGNATURE) {

            fadt = (PFADT)descriptionHeader;
            fadt->facs += physicalBias;
            fadt->dsdt += physicalBias;
        }
    }

    //
    // Now unmap the ACPI tables and remap just the RSDT table
    //

    rsdtLength = BlRsdt->Header.Length;
    MmUnmapIoSpace( newAcpiVa, descriptorSize );

    physicalAddress.QuadPart = rsdtPhysical;
    BlRsdt = MmMapIoSpace( physicalAddress, rsdtLength, MmCached );

    //
    // Find the ACPI BIOS configuration entry and update it with the new
    // RSDT physical address
    //

    BlAmd64UpdateAcpiConfigurationEntry( rsdtPhysical );

    //
    // That's it.
    //

    return TRUE;
}

#else   // BL_ENABLE_REMAP

BOOLEAN
BlAmd64RemapDram (
    IN PCHAR LoaderOptions
    )
{
    return FALSE;
}

#endif  // BL_ENABLE_REMAP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\amd64\wake64.asm ===
;++
;
;Copyright (c) 1997-2002  Microsoft Corporation
;
;Module Name:
;
;    wake64.asm
;
;Abstract:
;
;   This module contains relocatable code to perform tasks necessary
;   at the final stage of waking process on Amd64.
;
;Author:
;
;   Ken Reneris (kenr) 05-May-1997
;
;Revision History:
;
;   Steve Deng (sdeng) 27-Aug-2002 
;      Initial Amd64 version
;
;--

.586p
        .xlist
include ksamd64.inc
include callconv.inc
        .list

        extrn  _HiberPtes:DWORD
        extrn  _HiberVa:DWORD
        extrn  _HiberFirstRemap:DWORD
        extrn  _HiberLastRemap:DWORD
        extrn  _HiberPageFrames:DWORD
        extrn  _HiberTransVaAmd64:QWORD
        extrn  _HiberIdentityVaAmd64:QWORD
        extrn  _HiberImageFeatureFlags:DWORD
        extrn  _HiberBreakOnWake:BYTE
        extrn  _HiberImagePageSelf:DWORD
        extrn  _HiberNoHiberPtes:DWORD
        extrn  _HiberNoExecute:DWORD
        extrn  _BlAmd64TopLevelPte:DWORD
        extrn  _HiberInProgress:DWORD
        extrn  _BlAmd64GdtSize:DWORD
        EXTRNP _BlAmd64SwitchToLongMode,0
        EXTRNP _BlAmd64BuildAmd64GDT,2
; 
; These equates define the usuage of reserved hiber PTEs. They must match
; the definitions in bldr.h
;

PTE_SOURCE           equ    0
PTE_DEST             equ    1
PTE_MAP_PAGE         equ    2
PTE_REMAP_PAGE       equ    3
PTE_HIBER_CONTEXT    equ    4
PTE_TRANSFER_PDE     equ    5
PTE_WAKE_PTE         equ    6
PTE_DISPATCHER_START equ    7

;
; Processor paging defines
;

PAGE_SIZE            equ    4096
PAGE_MASK            equ    (PAGE_SIZE - 1)
PAGE_SHIFT           equ    12
PTE_VALID            equ    23h
PTI_MASK_AMD64       equ    1ffh
PDI_MASK_AMD64       equ    1ffh
PPI_MASK_AMD64       equ    1ffh
PXI_MASK_AMD64       equ    1ffh
PTI_SHIFT_AMD64      equ    12
PDI_SHIFT_AMD64      equ    21
PPI_SHIFT_AMD64      equ    30
PXI_SHIFT_AMD64      equ    39

;
; Part of the code in this module runs in 64-bit mode. But everything 
; is compiled by 32-bit compiler. The equates and macros defined here are 
; used to indicate the actual behavior of the intructions in 64-bit mode.
; 

rax     equ     eax
rcx     equ     ecx
rdx     equ     edx
rbx     equ     ebx
rsp     equ     esp
rbp     equ     ebp
rsi     equ     esi
rdi     equ     edi
r8      equ     eax
r9      equ     ecx
r10     equ     edx
r11     equ     ebx
r12     equ     esp
r13     equ     ebp
r14     equ     esi
r15     equ     edi

PREFIX64 macro
        db     048h
endm
MOV64   macro  a, b
        PREFIX64
        mov    dword ptr a, dword ptr b
endm
LEA64   macro  a, b
        PREFIX64
        lea    a, b
endm
SHL64   macro  a, b
        PREFIX64
        shl    a, b
endm
ADD64   macro  a, b
        PREFIX64
        add    a, b
endm
RETF64  macro  a, b
        PREFIX64
        retf
endm
IRET64  macro  a, b
        PREFIX64
        iretd
endm
LDRX64 macro  a, b
        db    04ch
        mov   a, dword ptr b
endm
LDCR8  macro  a
        db    44h
        mov   cr0, a
endm

;
; Private data structures
;

STACK_SIZE              equ     1024

HbGdt   struc
        Limit           dw      0
        Base            dd      0
        BaseHigh        dd      0
        Pad             dw      0 
HbGdt   ends

HbContextBlock struc
        ProcessorState  db      processorstatelength dup (?)
        OldEsp          dd      ?
        PteVa           dd      ?   
        pteVaHigh       dd      ?
        TransCr3        dd      ?
        TransPteVa      dd      ? 
        TransPteVaHigh  dd      ?
        WakeHiberVa     dd      ?
        WakeHiberVaHigh dd      ?
        Buffer          dd      ?
        MapIndex        dd      ?
        LastMapIndex    dd      ? 
        FeatureFlags    dd      ?
        NoExecute       dd      ?
        Gdt32           db      size HbGdt dup (0)
        Gdt64           db      size HbGdt dup (0)
        Stack           db      STACK_SIZE dup (?)
        BufferData      db      ?
HbContextBlock ends

;
; Addresses based from ebp
;

SourcePage        equ    [ebp + PAGE_SIZE * PTE_SOURCE]
DestPage          equ    [ebp + PAGE_SIZE * PTE_DEST]
Map               equ    [ebp + PAGE_SIZE * PTE_MAP_PAGE]
Remap             equ    [ebp + PAGE_SIZE * PTE_REMAP_PAGE]
Context           equ    [ebp + PAGE_SIZE * PTE_HIBER_CONTEXT].HbContextBlock
ContextFrame      equ    Context.ProcessorState.PsContextFrame
SpecialRegisters  equ    Context.ProcessorState.PsSpecialRegisters


_TEXT   SEGMENT PARA PUBLIC 'CODE' 
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
;++
;
; VOID
; WakeDispatcherAmd64 (
; )
;
; Routine Description:
;
;   Relocatable code which copies any remap page to it's final resting
;   place and then restores the processors wake context.
;
; Arguments:
;
;   None
;
; Return
;
;   Only returns if there's an internal failure
;
;--

cPublicProc _WakeDispatcherAmd64, 0
        public  _WakeDispatcherAmd64Start
_WakeDispatcherAmd64Start   label   dword

        ;
        ; Save nonvolatile registers on stack. The saved values are 
        ; only used when wake process failed.
        ;

        push    ebp
        push    ebx
        push    esi
        push    edi

        ;
        ; Load ebp with base of hiber va. Everything will be relative 
        ; from ebp
        ;

        mov     ebp, _HiberVa
        mov     Context.OldEsp, esp   ; save esp value in case of failure

        ;
        ; Make a private copy of the data we need to HbContextBlock. 
        ; We'll not have access to these globals after switching to
        ; long mode. 
        ;

        lea     edx, Context.BufferData
        mov     eax, _HiberFirstRemap
        mov     ecx, _HiberLastRemap
        mov     esi, _HiberPtes
        mov     Context.MapIndex, eax
        mov     Context.LastMapIndex, ecx
        mov     Context.Buffer, edx
        mov     Context.PteVa, esi

        mov     eax, _HiberPageFrames [PTE_TRANSFER_PDE * 4]
        mov     edx, dword ptr _HiberIdentityVaAmd64
        mov     esi, dword ptr _HiberIdentityVaAmd64 + 4
        mov     Context.TransCr3, eax
        mov     Context.WakeHiberVa, edx
        mov     Context.WakeHiberVaHigh, esi

        mov     eax, _HiberImageFeatureFlags
        mov     ecx, _HiberNoExecute
        mov     edx, dword ptr _HiberTransVaAmd64
        mov     esi, dword ptr _HiberTransVaAmd64+4
        mov     Context.FeatureFlags, eax
        mov     Context.NoExecute, ecx
        mov     Context.TransPteVa, edx
        mov     Context.TransPteVaHigh, esi

        ;
        ; Copy current GDT to private buffer
        ;

        sgdt    fword ptr Context.Gdt32 ; save current GDTR 
        movzx   ecx, Context.Gdt32.Limit; ecx = GDT limit
        inc     ecx                     ; ecx = size to allocate
        push    ecx                     ; save size value on stack
        call    AllocateHeap            ; allocate a buffer for GDT table
        pop     ecx                     ; restore GDT size to ecx
        mov     edi, eax                ; edi = address of allocated buffer
        mov     esi, Context.Gdt32.Base ; esi = address of current GDT table
        rep     movsb                   ; copy GDT to allocated buffer
        mov     Context.Gdt32.Base, eax ; set GDT new base

        ;
        ; Build  64-bit Global Descriptor Table
        ;

        mov     ecx, _BlAmd64GdtSize    ; specify allocate size in ecx
        call    AllocateHeap            ; allocate a buffer for 64-bit GDT
        push    eax                     ; eax has base of alloctated buffer
        mov     Context.Gdt64.Base, eax ; set the base of 64-bit GDT
        mov     ax, word ptr _BlAmd64GdtSize 
        mov     Context.Gdt64.Limit, ax ; set the limit of 64-bit GDT
        push    0                       ; specify SysTss = 0 for the call below
        mov     ebx, _BlAmd64BuildAmd64GDT@8
        call    dword ptr ebx           ; build 64-bit GDT in allocated buffer

        ;
        ; Now we'll locate hiber ptes in hiber image and set them to the
        ; values of current HiberPtes
        ;

        mov     eax, dword ptr SpecialRegisters.PsCr3
        shr     eax, PAGE_SHIFT         ; eax = page number of PML4 table
        call    LocatePage              ; locate the page described by eax
        push    eax                     ; eax has the pfn of the page located
        push    PTE_SOURCE              ; specify which PTE to use
        call    SetPteX86               ; map the located page 

        ;
        ; Locate the PDPT page and map it
        ;

        mov     ecx, Context.WakeHiberVaHigh
        shr     ecx, PXI_SHIFT_AMD64 - 32
        and     ecx, PXI_MASK_AMD64     ; ecx = PML4E index of WakeHiberVa
        mov     eax, [eax+ecx*8]        ; get PML4E entry 
        shr     eax, PAGE_SHIFT         ; eax = page frame number of PDPT
        call    LocatePage              ; locate the page described by eax
        push    eax                     ; eax has the pfn of the page located
        push    PTE_SOURCE              ; specify which PTE to use
        call    SetPteX86               ; map the located page 

        ;
        ; Locate the PDE page and map it
        ;

        mov     ecx, Context.WakeHiberVa; 
        mov     edx, Context.WakeHiberVaHigh
        shrd    ecx, edx, PPI_SHIFT_AMD64 ; shift right to PPI part
        and     ecx, PPI_MASK_AMD64     ; ecx = PDPT index of WakeHiberVa
        mov     eax, [eax+ecx*8]        ; get PDPT entry
        shr     eax, PAGE_SHIFT         ; eax = page frame number of PDE
        call    LocatePage              ; locate the page described by eax
        push    eax                     ; eax has the pfn of the page located
        push    PTE_SOURCE              ; specify which PTE to use
        call    SetPteX86               ; map the located page 

        ;
        ; Locate the PTE page and map it
        ;

        mov     ecx, Context.WakeHiberVa; 
        shr     ecx, PDI_SHIFT_AMD64    ; shift right to PDE part
        and     ecx, PDI_MASK_AMD64     ; ecx = PDE index
        mov     eax, [eax+ecx*8]        ; get PDE entry
        shr     eax, PAGE_SHIFT         ; eax = page frame number of PTE
        call    LocatePage              ; locate the page described by eax
        push    eax                     ; eax has the pfn of the page located
        push    PTE_SOURCE              ; specify which PTE to use
        call    SetPteX86               ; map the located page

        ;
        ; Calculate the address of wake image hiber ptes 
        ;

        mov     ecx, Context.WakeHiberVa;
        shr     ecx, PTI_SHIFT_AMD64    ; shift right to PTE part
        and     ecx, PTI_MASK_AMD64     ; ecx = PTE index
        lea     edi, [eax+ecx*8]        ; edi = address of wake hiber PTEs

        ;
        ; Copy current HiberPtes to the wake image Ptes
        ; 

        xor     eax, eax                ; set eax to 0 for stosd below
        mov     esi, Context.PteVa      ; current HiberPte address
        mov     ecx, _HiberNoHiberPtes  ; Number of PTEs to copy
@@:     movsd                           ; translate 32-bit PTE to 64-bit PTE
        stosd                           ; Assume the high dword of 64-bit
        dec ecx                         ; pte is zero. Otherwise hibernation
        jnz short @b                    ; should be disabled
                
        ;
        ; If break on wake, set the image header signature in destionation
        ;

        cmp     _HiberBreakOnWake, 0
        jz      short @f                ; skip this step if flag is not set
        mov     eax, _HiberImagePageSelf; eax = page number of image header
        call    LocatePage              ; locate the page described by eax
        push    eax                     ; eax has the pfn of the page located
        push    PTE_DEST                ; specify which PTE to use
        call    SetPteX86               ; map the located page
        mov     [eax], 706B7262h        ; set signature to 'brkp'

        ;
        ; Switch to long mode
        ;

@@:     lgdt    fword ptr Context.Gdt32 ; switch GDT to the one in our buffer
        lea     esp, Context.Stack + STACK_SIZE ; move stack to safe place
        and     esp, 0fffffff8h         ; align to 16 byte boundary
        mov     eax, Context.TransCr3   ; eax = pfn of transition CR3
        shl     eax, PAGE_SHIFT         ; eax = transition CR3
        mov     [_BlAmd64TopLevelPte], eax ; initialize these two globals
        mov     [_HiberInProgress], 1   ; for use in BlAmd64SwitchToLongMode 
        mov     eax, _BlAmd64SwitchToLongMode@0
        call    dword ptr eax           ; switch to long mode

        ;
        ; Now we are in 32-bit compatible mode. 
        ;

        mov     ebx, ebp                ; ebx = Hiberva
        add     ebx, PTE_DISPATCHER_START * PAGE_SIZE ; add dispatch code address
        add     ebx, in_64bit_mode - _WakeDispatcherAmd64Start ; ebx = Hiberva 
                                                               ; relative new IP 
        push    word ptr KGDT64_R0_CODE ; push code selector 
        push    ebx                     ; push new IP address
        lgdt    fword ptr Context.Gdt64 ; load 64-bit GDTR
        retf                            ; jump to next instruction and reload cs

in_64bit_mode:

        ;
        ; At this point we are in 64 bit mode. 
        ; We now move everything to WakeHiberVa relative address.
        ;

        mov     eax, Context.Gdt64.Base ; get HiberVa relative GDT base 
        sub     eax, ebp                ; eax = offset of GDT base to HiberVa
        ADD64   rax, Context.WakeHiberVa; rax = WakeHiberVa relative GDT base
        MOV64   Context.Gdt64.Base, rax ; set GDT base 

        MOV64   rbx, Context.WakeHiberVa; get WakeHiberVa
        MOV64   rbp, rbx                ; switch rbp from HiberVa to WakeHiberVa

        MOV64   rax, Context.TransPteVa ; rax = HiberTransVaAmd64
        MOV64   Context.PteVa, rax      ; Pteva = pte address of WakeHiberVa

        LEA64   rsp, Context.Stack+STACK_SIZE ; move stack to safe place

        ADD64   rbx, PTE_DISPATCHER_START*PAGE_SIZE ; rbx = dispatch code base
        ADD64   rbx, wd10-_WakeDispatcherAmd64Start ; rbx = WakeHiberVa rela-
                                                    ; tive address of "wd10"

        lgdt    fword ptr Context.Gdt64 ; switch to WakeHiberVa relative GDT
        push    dword ptr KGDT64_R0_CODE; code selector
        push    rbx                     ; rip address
        RETF64                          ; jump to WakeHiberVa relative code address

        ;
        ; Copy all pages to final locations
        ;

wd10:   mov     ebx, Context.MapIndex   ; get initial map index
wd20:   cmp     ebx, Context.LastMapIndex ; check if any pages left
        jnc     short wd30              ; we are done!

        mov     edx, Map.[ebx*4]        ; edx = page number to be copied
        mov     ecx, PTE_SOURCE         ; use hiber pte PTE_SOURCE
        call    SetPteAmd64             ; map the source page
        MOV64   rsi, rax                ; rsi = address of source page

        mov     edx, Remap.[ebx*4]      ; edx = dest page number
        mov     ecx, PTE_DEST           ; use hiber pte PTE_DEST 
        call    SetPteAmd64             ; map the dest page
        MOV64   rdi, rax                ; rdi = address of dest page

        mov     ecx, PAGE_SIZE / 4      ; set copy size to one page
        rep     movsd                   ; coping ...
        add     ebx, 1	                ; increment ebx to next index
        jmp     short wd20              ; 

        ;
        ; Restore processors wake context
        ;

wd30:   LEA64   rsi, SpecialRegisters   ; rsi = base of special registers
        MOV64   rax, cr3                ; flush before enabling kernel paging
        MOV64   cr3, rax                ; 
        MOV64   rax, [rsi].PsCr4        ; get saved CR4
        MOV64   cr4, rax                ; restore CR4
        MOV64   rax, [rsi].PsCr3        ; get saved CR3
        MOV64   cr3, rax                ; restore CR3
        MOV64   rcx, [rsi].PsCr0        ; get saved CR0
        MOV64   cr0, rcx                ; restore CR0

        ;
        ; On kernel's paging now
        ;

        MOV64   rax, [rsi].PsCr8        ; get saved CR8
        LDCR8   rax                     ; restore CR8
        lgdt    fword ptr [rsi].PsGdtr  ; restore GDTR 
        lidt    fword ptr [rsi].PsIdtr  ; restore IDTR
        lldt    word  ptr [rsi].PsLdtr  ; restore LDTR

        mov     ds, word ptr ContextFrame.CxSegDs ; restore segment registers
        mov     es, word ptr ContextFrame.CxSegEs ;
        mov     ss, word ptr ContextFrame.CxSegSs ;
        mov     fs, word ptr ContextFrame.CxSegFs ; 
        mov     gs, word ptr ContextFrame.CxSegGs ;

        MOV64   rcx, [rsi].PsGdtr+2     ; rcx = base of kernel GDT
        movzx   eax, word ptr [rsi].PsTr; TSS selector
        and     byte ptr [rax+rcx+5], NOT 2; clear busy bit in the TSS
        ltr     word ptr [rsi].PsTr     ; restore TR

        mov     ecx, MSR_GS_BASE        ; restore MSRs
        mov     eax, [rsi].SrMsrGsBase  ;
        mov     edx, [rsi].SrMsrGsBase + 4
        wrmsr                           ;
        mov     ecx, MSR_GS_SWAP        ;
        mov     eax, [rsi].SrMsrGsSwap  ;
        mov     edx, [rsi].SrMsrGsSwap + 4
        wrmsr                           ;
        mov     ecx, MSR_STAR           ;
        mov     eax, [rsi].SrMsrStar    ;
        mov     edx, [rsi].SrMsrStar + 4;
        wrmsr                           ;
        mov     ecx, MSR_LSTAR          ;
        mov     eax, [rsi].SrMsrLStar   ;
        mov     edx, [rsi].SrMsrLStar + 4
        wrmsr                  
        mov     ecx, MSR_CSTAR          ;
        mov     eax, [rsi].SrMsrCStar   ;
        mov     edx, [rsi].SrMsrCStar + 4
        wrmsr                           ;
        mov     ecx, MSR_SYSCALL_MASK   ;
        mov     eax, [rsi].SrMsrSyscallMask
        mov     edx, [rsi].SrMsrSyscallMask + 4
        wrmsr                           ;

        ;
        ; No-execute should be enabled while switching to long mode.
        ; If this option was disabled in OS, we should disable it here.
        ;

        cmp     Context.NoExecute, 0    ; check no-execute bit
        jnz     short wd40              ; if it is enabled, do nothing 
        mov     ecx, MSR_EFER           ; ecx = EFER address
        rdmsr                           ; read current value of EFER
        and     eax, NOT 800h           ; clear NXE bit of EFER
        wrmsr                           ; write EFER

wd40:   MOV64   rbx, ContextFrame.CxRbx ; restore general purpose registers
        MOV64   rcx, ContextFrame.CxRcx ;
        MOV64   rdx, ContextFrame.CxRdx ;
        MOV64   rdi, ContextFrame.CxRdi ;
        LDRX64  r8,  ContextFrame.CxR8  ;
        LDRX64  r9,  ContextFrame.CxR9  ;
        LDRX64  r10, ContextFrame.CxR10 ; 
        LDRX64  r11, ContextFrame.CxR11 ; 
        LDRX64  r12, ContextFrame.CxR12 ; 
        LDRX64  r13, ContextFrame.CxR13 ; 
        LDRX64  r14, ContextFrame.CxR14 ; 
        LDRX64  r15, ContextFrame.CxR15 ; 

        xor     eax, eax                ; restore debug registers
        mov     dr7, rax                ;
        MOV64   rax, [esi].PsKernelDr0  ;
        mov     dr0, rax                ;
        MOV64   rax, [esi].PsKernelDr1  ;
        mov     dr1, rax                ;
        MOV64   rax, [esi].PsKernelDr2  ;
        mov     dr2, rax                ;
        MOV64   rax, [esi].PsKernelDr3  ;
        mov     dr3, rax                ;
        xor     eax, eax                ;
        mov     dr6, rax                ;
        MOV64   rax, [esi].PsKernelDr7  ;
        mov     dr7, rax                ;

        ; 
        ; Prepare stack content for the iret. 
        ; N.B. Every "push" below stores a qword on stack in 64-bit mode. 
        ;     

        movzx   eax,  word ptr ContextFrame.CxSegSs
        push    rax   
        push    dword ptr ContextFrame.CxRsp 
        push    dword ptr ContextFrame.CxEFlags
        movzx   eax, word ptr ContextFrame.CxSegCs
        push    rax                               
        push    dword ptr ContextFrame.CxRip      

        ; 
        ; Restore the last few registers
        ; 

        push    dword ptr ContextFrame.CxRbp
        push    dword ptr ContextFrame.CxRsi
        push    dword ptr ContextFrame.CxRax
        pop     rax
        pop     rsi
        pop     rbp

        ; 
        ; Pass control to kernel
        ; 
     
        IRET64 

        ; 
        ; This exit is only used in the shared buffer overflows
        ;

Abort:  mov     esp, Context.OldEsp
        pop     edi
        pop     esi
        pop     ebx
        pop     ebp
        stdRET  _WakeDispatcherAmd64

;++
;
; PUCHAR
; AllocateHeap (
;    IN ULONG Length
;    )
;
; Routine Description:
;
;   Allocates the specified bytes from the wake context page.
;
;   This function runs in legacy 32-bit mode. 
;
;   N.B. This function is part of WakeDispatcher.
;
;  Arguments:
;
;   ECX     - Length to allocate
;
;  Returns:
;
;   EAX     - Virtual address of bytes allocated
;
;  Register modified:
;
;   EAX, ECX, EDX
;
;--

AllocateHeap  label   proc
        mov     eax, Context.Buffer     ; eax = base address of free memory
        mov     edx, eax                ; 
        test    eax, 01fh               ; check if it is at 32 byte boundary
        jz      short ah20              ; if yes, do nothing
        and     eax, not 01fh           ; 
        add     eax, 20h                ; round to next 32 byte boundary 
ah20:   add     ecx, eax                ; ecx = base address + allocate length 
        mov     Context.Buffer, ecx     ; update ase address of free memory
        xor     ecx, edx                ;
        and     ecx, 0ffffffffh - PAGE_MASK
        jnz     short Abort             ; abort wake process if allocation fail
        ret                             ; return on success

;++
;
; PUCHAR
; SetPteX86 (
;    IN ULONG   PteIndex
;    IN ULONG   PageFrameNumber
;    )
;
; Routine Description:
;
;   This function create a legacy 32-bit mapping with one of the hiber PTEs.
;
;   This function runs in legacy 32-bit mode.   
;
;   N.B. This function is part of WakeDispatcher.
;
;  Arguments:
;
;    PteIndex -  Specify a PTE in HiberPtes list
;
;    PageFrameNumber - the page frame number of the page to be mapped
;
;  Returns:
;
;    EAX - va of mapped pte
;
;  Registers modified:
;
;    EAX 
;
;--

SetPteX86 label proc

        push    ecx                     ; save ecx

        ; 
        ; Calculate the address of the given PTE
        ;

        mov     eax, [esp+8]            ; eax = pte index
        shl     eax, 2                  ; times the size of PTE
        add     eax, Context.PteVa      ; add pte base address

        ; 
        ; Initialize the PTE entry to the given page
        ;

        mov     ecx, [esp+12]           ; ecx = page frame number
        shl     ecx, PAGE_SHIFT         ;
        or      ecx, PTE_VALID          ; make a valid PTE entry
        mov     [eax], ecx              ; set the PTE

        ; 
        ; Calcuate the virtual address and flush its TLB
        ;

        mov     eax, [esp+8]            ; eax = pte index
        shl     eax, PAGE_SHIFT         ;
        add     eax, ebp                ; eax = va mapped by pte
        invlpg  [eax]                   ; 
        pop     ecx                     ; restore ecx
        ret     8

;
; PUCHAR
; SetPteAmd64 (
;    IN ULONG   PteIndex
;    IN ULONG   PageFrameNumber
;    )
;
; Routine Description:
;
;   This function maps a page into 4-level Amd64 mapping structure with one
;   of the hiber PTEs. 
; 
;   This function runs in long mode. 
;
;   N.B. This function is part of WakeDispatcher.
;
; Arguments:
;
;   ECX - Specify a PTE in HiberPtes list  
;
;   EDX - the page frame number of the page to be mapped
;
; Returns:
;
;   EAX - va of mapped pte
;
; Register modified:
;
;   EAX, EDX
;
;--

SetPteAmd64 label  proc

        ; 
        ; Calculate the address of given PTE
        ;

        mov     eax, ecx                ; eax =  pte index
        shl     eax, 3                  ; eax = eax * 8
        ADD64   rax, Context.PteVa      ; add pte base address

        ; 
        ; Initialize the PTE entry 
        ;

        SHL64   rdx, PAGE_SHIFT         ; 
        or      edx, PTE_VALID          ; make it a valid pte entry
        MOV64   [rax], rdx              ; set the 64-bit Pte

        ; 
        ; Calcuate the virtual address and flush its TLB
        ;

        mov     eax, ecx                ; eax =  pte index
        SHL64   rax, PAGE_SHIFT         ;      
        ADD64   rax, rbp                ; eax = va mapped by pte
        invlpg  [eax]                   ; flush TLB of this va
        ret     

;++
;
; ULONG
; LocatePage (
;    IN ULONG PageNumber
;    )
;
; Routine Description:
;
;   Find the page specified by PageNumber in the wake context.
;   The page number must be a valid page.
;
;   This function works in 32-bit legacy mode. 
;
;   N.B. This function is part of WakeDispatcher.
;
;  Arguments:
;
;   EAX  - Page frame number of the page we try to locate.
;
;  Returns:
;
;   EAX  - Page frame number of the page which is holding the content
;          of the page of interest. This number could be different from 
;          the page number passed in if the requested page is in the 
;          remap list.
;
;  Uses:
;
;   EAX, EDX
;
;--

LocatePage label    proc

        ;
        ; Scan the remap entries for this page.  If it's found, get the
        ; source address.  If it's not found, then it's already at it's
        ; proper address
        ;

        mov     edx, Context.MapIndex   ; edx = initial index 
        dec     edx                     ; 

lp10:   inc     edx                     ;
        cmp     edx, Context.LastMapIndex ; check if we've searched to the end
        jnc     short lp20              ; if yes, return
        cmp     eax, Remap.[edx*4]      ; is this the page we try to locate ?
        jnz     short lp10              ; if not, try next one

        mov     eax, Map.[edx*4]        ; we found our page, retrun its clone
lp20:   ret

        public  _WakeDispatcherAmd64End
_WakeDispatcherAmd64End   label   dword
stdENDP _WakeDispatcherAmd64

_TEXT   ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\daytona\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\daytona_dbg\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\acpidtct.c ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved

Module Name:

    acpisetd.c

Abstract:

    This module detects an ACPI system.  It
    is included into setup so that setup
    can figure out which HAL to load

Author:

    Jake Oshins (jakeo) - Feb. 7, 1997.

Environment:

    Textmode setup.

Revision History:


--*/
#include "bootx86.h"

#include "stdlib.h"
#include "string.h"

VOID
BlPrint(
    PCHAR cp,
    ...
    );


#ifdef DEBUG
#undef DEBUG_PRINT
#define DEBUG_PRINT BlPrint
#else
#define DEBUG_PRINT
#endif

typedef struct _ACPI_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[8];             // "RSD PTR" (ascii)
    UCHAR Checksum;
    UCHAR OemId[6];                 // An OEM-supplied string
    UCHAR reserved;                 // must be 0
    ULONG RsdtAddress;              // 32-bit physical address of RSDT
} ACPI_BIOS_INSTALLATION_CHECK, *PACPI_BIOS_INSTALLATION_CHECK;

#include "acpitabl.h"

PRSDP   BlRsdp;
PRSDT   BlRsdt;
PXSDT   BlXsdt;
BOOLEAN BlLegacyFree = FALSE;

PDESCRIPTION_HEADER
BlFindACPITable(
    IN PCHAR TableName,
    IN ULONG TableLength
    );

// from boot\detect\i386\acpibios.h
//
// Acpi BIOS Installation check
//
#define ACPI_BIOS_START            0xE0000
#define ACPI_BIOS_END              0xFFFFF
#define ACPI_BIOS_HEADER_INCREMENT 16

VOID
BlFindRsdp (
    VOID
    )
#define EBDA_SEGMENT_PTR    0x40e
{
    ULONG romAddr = 0;
    ULONG romEnd = 0;
    PACPI_BIOS_INSTALLATION_CHECK header;
    UCHAR sum;
    USHORT i;
    ULONG EbdaSegmentPtr;
    ULONG EbdaPhysicalAdd = 0;
    PUCHAR EbdaVirtualAdd = 0;
    PHYSICAL_ADDRESS paddr;
    enum PASS { PASS1 = 0, PASS2, MAX_PASSES } pass;

    //
    // Search on 16 byte boundaries for the signature of the
    // Root System Description Table structure.
    //
    for (pass = PASS1; pass < MAX_PASSES; pass++) {

        if (pass == PASS1) {

            //
            // On the first pass, we search the first 1K of the
            // Extended BIOS data area.  The EBDA segment address
            // is available at physical address 40:0E.
            //

            paddr.QuadPart = 0;
            EbdaSegmentPtr = (ULONG) MmMapIoSpace( paddr,
                                                   PAGE_SIZE,
                                                   TRUE);

            EbdaSegmentPtr += EBDA_SEGMENT_PTR;
            EbdaPhysicalAdd = *((PUSHORT)EbdaSegmentPtr);
            EbdaPhysicalAdd = EbdaPhysicalAdd << 4;

            if (EbdaPhysicalAdd) {
                paddr.HighPart = 0;
                paddr.LowPart = EbdaPhysicalAdd;
                EbdaVirtualAdd = MmMapIoSpace( paddr,
                                               2 * PAGE_SIZE,
                                               TRUE);
            }

            if (!EbdaVirtualAdd) {
                continue;
            }

            romAddr = (ULONG)EbdaVirtualAdd;
            romEnd  = romAddr + 1024;

        } else {
            //
            // On the second pass, we search (physical) memory 0xE0000
            // to 0xF0000.

            paddr.LowPart = ACPI_BIOS_START;
            romAddr = (ULONG)MmMapIoSpace(paddr,
                                          ACPI_BIOS_END - ACPI_BIOS_START,
                                          TRUE);

            romEnd  = romAddr + (ACPI_BIOS_END - ACPI_BIOS_START);
        }

        while (romAddr < romEnd) {

            header = (PACPI_BIOS_INSTALLATION_CHECK)romAddr;

            //
            // Signature to match is the string "RSD PTR ".
            //

            if (header->Signature[0] == 'R' && header->Signature[1] == 'S' &&
                header->Signature[2] == 'D' && header->Signature[3] == ' ' &&
                header->Signature[4] == 'P' && header->Signature[5] == 'T' &&
                header->Signature[6] == 'R' && header->Signature[7] == ' ' ) {

                sum = 0;
                for (i = 0; i < sizeof(ACPI_BIOS_INSTALLATION_CHECK); i++) {
                    sum = sum + ((PUCHAR) romAddr)[i];
                }
                if (sum == 0) {
                    pass = MAX_PASSES; // leave 'for' loop
                    break;    // leave 'while' loop
                }
            }

            romAddr += ACPI_BIOS_HEADER_INCREMENT;
        }
    }

    if (romAddr >= romEnd) {
        BlRsdp = NULL;
        BlRsdt = NULL;
        return;
    }

    BlRsdp = (PRSDP)romAddr;
    paddr.LowPart = BlRsdp->RsdtAddress;
    BlRsdt = MmMapIoSpace(paddr, sizeof(RSDT), TRUE);
    BlRsdt = MmMapIoSpace(paddr, BlRsdt->Header.Length, TRUE);

#ifdef ACPI_20_COMPLIANT
    if (BlRsdp->Revision > 1) {

        //
        // ACPI 2.0 BIOS
        //

        BlXsdt = MmMapIoSpace(paddr, sizeof(XSDT), TRUE);
        BlXsdt = MmMapIoSpace(paddr, BlXsdt->Header.Length, TRUE);
    }
#endif
    return;
}


//
// Make the FADT table global.  
// It will be used when resetting legacy free machines.
//
PFADT   fadt = NULL;


BOOLEAN
BlDetectLegacyFreeBios(
    VOID
    )
{

    if (BlLegacyFree) {
        return TRUE;
    }

    BlFindRsdp();

    if (BlRsdt) {

        fadt = (PFADT)BlFindACPITable("FACP", sizeof(FADT));

        if (fadt == NULL) {
            return FALSE;
        }

        if ((fadt->Header.Revision < 2) ||
            (fadt->Header.Length <= 116)) {

            //
            // The BIOS is earlier than the legacy-free
            // additions.
            //
            return FALSE;
        }

        if (!(fadt->boot_arch & I8042)) {
            BlLegacyFree = TRUE;
            return TRUE;
        }
    }

    return FALSE;
}

PDESCRIPTION_HEADER
BlFindACPITable(
    IN PCHAR TableName,
    IN ULONG TableLength
    )
/*++

Routine Description:

    Given a table name, finds that table in the ACPI BIOS

Arguments:

    TableName - Supplies the table name

    TableLength - Supplies the length of the table to map

Return Value:

    Pointer to the table if found

    NULL if the table is not found

--*/

{
    ULONG Signature;
    PFADT Fadt;
    PDESCRIPTION_HEADER Header;
    ULONG TableCount;
    ULONG i;
    PHYSICAL_ADDRESS paddr = {0};

    Signature = *((ULONG UNALIGNED *)TableName);
    if (Signature == RSDT_SIGNATURE) {
        return(&BlRsdt->Header);
    } else if (Signature == XSDT_SIGNATURE) {
        return(&BlXsdt->Header);
    } else if (Signature == DSDT_SIGNATURE) {
        Fadt = (PFADT)BlFindACPITable("FACP", sizeof(PFADT));
        if (Fadt == NULL) {
            return(NULL);
        }
        if (BlXsdt) {
            paddr = Fadt->x_dsdt;
        } else {
#if defined(_X86_)
            paddr.LowPart = Fadt->dsdt;
#else
            paddr.QuadPart = Fadt->dsdt;
#endif
        }
        Header = MmMapIoSpace(paddr, TableLength, TRUE);
        return(Header);
    } else {

        //
        // Make sure...
        //
        if( !BlRsdt ) {
            BlFindRsdp();
        }

        if( BlRsdt ) {

            TableCount = BlXsdt ?
                NumTableEntriesFromXSDTPointer(BlXsdt) :
                NumTableEntriesFromRSDTPointer(BlRsdt);

            //
            // Sanity check.
            //
            if( TableCount > 0x100 ) {
                return(NULL);
            }

            for (i=0;i<TableCount;i++) {


                if (BlXsdt) {

                    paddr = BlXsdt->Tables[i];

                } else {

#if defined(_X86_)
                    paddr.HighPart = 0;
                    paddr.LowPart = BlRsdt->Tables[i];
#else
                    paddr.QuadPart = BlRsdt->Tables[i];
#endif
                }

                Header = MmMapIoSpace(paddr, sizeof(DESCRIPTION_HEADER), TRUE);
                if (Header == NULL) {
                    return(NULL);
                }
                if (Header->Signature == Signature) {
                    //
                    // if we need to map more than just the DESCRIPTION_HEADER, do that before
                    // returning.  Check to see if the end of the table lies past the page 
                    // boundary the header lies on.  If so, we will have to map it.
                    //
                    if ( ((paddr.LowPart + TableLength) & ~(PAGE_SIZE - 1)) >
                         ((paddr.LowPart + sizeof(DESCRIPTION_HEADER)) & ~(PAGE_SIZE - 1)) ) {
                        Header = MmMapIoSpace(paddr, TableLength, TRUE);
                    }
                    return(Header);
                }
            }
        }
    }

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\amd64.c ===
#if defined(_X86AMD64_)
#include "..\amd64\amd64.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\amd64s.asm ===
ifdef _X86AMD64_
include ..\amd64\amd64s.asm
endif

    END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\bootfont.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    bootfint.h

Abstract:

    Header file describing the bootfont.bin file used to provide
    dbcs support during system or setup bootstrap.

Author:

    tedm 11-July-1995

Revision History:

--*/


//
// Define maximum number of dbcs lead byte ranges we support.
//
#define MAX_DBCS_RANGE  5

//
// Define signature value.
//
#define BOOTFONTBIN_SIGNATURE 0x5465644d

//
// Define structure used as a header for the bootfont.bin file.
//
typedef struct _BOOTFONTBIN_HEADER {

    //
    // Signature. Must be BOOTFONTBIN_SIGNATURE.
    //
    ULONG Signature;

    //
    // Language id of the language supported by this font.
    // This should match the language id of resources in msgs.xxx.
    //
    ULONG LanguageId;

    //
    // Number of sbcs characters and dbcs characters contained in the file.
    //
    unsigned NumSbcsChars;
    unsigned NumDbcsChars;

    //
    // Offsets within the file to the images.
    //
    unsigned SbcsOffset;
    unsigned DbcsOffset;

    //
    // Total sizes of the images.
    //
    unsigned SbcsEntriesTotalSize;
    unsigned DbcsEntriesTotalSize;

    //
    // Dbcs lead byte table. Must contain a pair of 0's to indicate the end.
    //
    UCHAR DbcsLeadTable[(MAX_DBCS_RANGE+1)*2];

    //
    // Height values for the font.
    // CharacterImageHeight is the height in scan lines/pixels of the
    // font image. Each character is drawn with additional 'padding'
    // lines on the top and bottom, whose sizes are also contained here.
    //
    UCHAR CharacterImageHeight;
    UCHAR CharacterTopPad;
    UCHAR CharacterBottomPad;

    //
    // Width values for the font. These values contain the width in pixels
    // of a single byte character and double byte character.
    //
    // NOTE: CURRENTLY THE SINGLE BYTE WIDTH *MUST* BE 8 AND THE DOUBLE BYTE
    // WIDTH *MUST* BE 16!!!
    //
    UCHAR CharacterImageSbcsWidth;
    UCHAR CharacterImageDbcsWidth;

} BOOTFONTBIN_HEADER, *PBOOTFONTBIN_HEADER;

//
// Images themselves follow.
//
// First there are SbcsCharacters entries for single-byte chars.
// The first byte in each entry is the ascii char code. The next n bytes are
// the image. n is dependent on the width and height of an sbcs char.
//
// Following these are the dbcs images. The first 2 bytes are the dbcs
// character code (highbyte lowbyte) and the next n bytes are the image.
// n is dependent on the width and height of a dbcs char.
//
// Important note: the characters must be sorted in ascending order!
//

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\amd64x86.c ===
#include "bootx86.h"

//
// Data declarations
//

BOOLEAN BlAmd64UseLongMode = FALSE;

#if defined(_X86AMD64_)

#include "..\amd64\amd64x86.c"

#else

ARC_STATUS
BlAmd64CheckForLongMode(
    IN     ULONG LoadDeviceId,
    IN OUT PCHAR KernelPath,
    IN     PCHAR KernelFileName
    )

/*++

Routine Description:

    This routine examines a kernel image and determines whether it was
    compiled for AMD64.  The global BlAmd64UseLongMode is set to non-zero
    if a long-modekernel is discovered.

Arguments:

    LoadDeviceId - Supplies the load device identifier.

    KernelPath - Supplies a pointer to the path to the kernel directory.
                 Upon successful return, KernelFileName will be appended
                 to this path.

    KernelFileName - Supplies a pointer to the name of the kernel file.

Return Value:

    The status of the operation.  Upon successful completion ESUCCESS
    is returned, whether long mode capability was detected or not.

--*/

{
    //
    // This version leaves BlAmd64UseLongMode set to FALSE.
    //

    return ESUCCESS;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\arcemul.c ===
/*++


Copyright (c) 1991  Microsoft Corporation

Module Name:

    arcemul.c

Abstract:

    This module provides the x86 emulation for the Arc routines which are
    built into the firmware on ARC machines.

    N. B.   This is where all the initialization of the SYSTEM_PARAMETER_BLOCK
            takes place.  If there is any non-standard hardware, some of the
            vectors may have to be changed.  This is where to do it.


Author:

    John Vert (jvert) 13-Jun-1991

Environment:

    x86 only

Revision History:

--*/

#include "arccodes.h"
#include "bootx86.h"
#include "ntdddisk.h"
#include "string.h"
#include "stdio.h"
#include "stdlib.h"
#include "scsi.h"
#include "scsiboot.h"
#include "ramdisk.h"
#include "acpitabl.h"
#include "pci.h"


#define CMOS_CONTROL_PORT ((PUCHAR)0x70)
#define CMOS_DATA_PORT    ((PUCHAR)0x71)
#define CMOS_STATUS_B     0x0B
#define CMOS_DAYLIGHT_BIT 1

extern PCHAR MnemonicTable[];
extern PFADT fadt;


//
// Size definitions for HardDiskInitialize()
//

#define SUPPORTED_NUMBER_OF_DISKS 32
#define SIZE_FOR_SUPPORTED_DISK_STRUCTURE (SUPPORTED_NUMBER_OF_DISKS*sizeof(DRIVER_LOOKUP_ENTRY))

BOOLEAN AEBiosDisabled = FALSE;

// spew UTF8 data over the headless port on FE builds.
#define UTF8_CLIENT_SUPPORT (1)


BOOLEAN AEArcDiskInformationInitialized = FALSE;
ARC_DISK_INFORMATION AEArcDiskInformation;

PDRIVER_UNLOAD AEDriverUnloadRoutine = NULL;

#define PORT_BUFFER_SIZE 10
UCHAR PortBuffer[PORT_BUFFER_SIZE];
ULONG PortBufferStart = 0;
ULONG PortBufferEnd = 0;

//
// Macro for aligning buffers. It returns the aligned pointer into the
// buffer. Buffer should be of size you want to use + alignment.
//

#define ALIGN_BUFFER_ON_BOUNDARY(Buffer,Alignment) ((PVOID) \
 ((((ULONG_PTR)(Buffer) + (Alignment) - 1)) & (~((ULONG_PTR)(Alignment) - 1))))

//
// Miniport DriverEntry typedef
//

typedef NTSTATUS
(*PDRIVER_ENTRY) (
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Parameter2
    );

typedef
BOOLEAN
(*PFWNODE_CALLBACK)(
    IN PCONFIGURATION_COMPONENT FoundComponent
    );

//
// Private function prototypes
//

ARC_STATUS
BlArcNotYetImplemented(
    IN ULONG FileId
    );

PCONFIGURATION_COMPONENT
AEComponentInfo(
    IN PCONFIGURATION_COMPONENT Current
    );

PCONFIGURATION_COMPONENT
FwGetChild(
    IN PCONFIGURATION_COMPONENT Current
    );

BOOLEAN
FwSearchTree(
    IN PCONFIGURATION_COMPONENT Node,
    IN CONFIGURATION_CLASS Class,
    IN CONFIGURATION_TYPE Type,
    IN ULONG Key,
    IN PFWNODE_CALLBACK CallbackRoutine
    );

PCHAR
AEGetEnvironment(
    IN PCHAR Variable
    );

PCONFIGURATION_COMPONENT
FwGetPeer(
    IN PCONFIGURATION_COMPONENT Current
    );

BOOLEAN
AEEnumerateDisks(
    PCONFIGURATION_COMPONENT Disk
    );

VOID
AEGetArcDiskInformation(
    VOID
    );

VOID
AEGetPathnameFromComponent(
    IN PCONFIGURATION_COMPONENT Component,
    OUT PCHAR ArcName
    );

PCONFIGURATION_COMPONENT
AEGetParent(
    IN PCONFIGURATION_COMPONENT Current
    );

ARC_STATUS
AEGetConfigurationData(
    IN PVOID ConfigurationData,
    IN PCONFIGURATION_COMPONENT Current
    );

PMEMORY_DESCRIPTOR
AEGetMemoryDescriptor(
    IN PMEMORY_DESCRIPTOR MemoryDescriptor OPTIONAL
    );

ARC_STATUS
AEOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
AEClose(
    IN ULONG FileId
    );

ARC_STATUS
AERead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
AEReadStatus (
    IN ULONG FileId
    );

VOID
AEReboot(
    VOID
    );

ARC_STATUS
AESeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
AEWrite (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
AEWriteEx (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
AEGetFileInformation(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInformation
    );

PTIME_FIELDS
AEGetTime(
    VOID
    );

ULONG
AEGetRelativeTime(
    VOID
    );

ARC_STATUS
ScsiDiskClose (
    IN ULONG FileId
    );

ARC_STATUS
ScsiDiskMount (
    IN PCHAR MountPath,
    IN MOUNT_OPERATION Operation
    );

ARC_STATUS
ScsiDiskOpen (
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
ScsiDiskRead (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
ScsiDiskSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
ScsiDiskWrite (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

VOID
HardDiskInitialize(
    IN OUT PVOID LookupTable,
    IN ULONG Entries,
    IN PVOID DeviceFoundCallback
    );

BOOLEAN
AEReadDiskSignature(
    IN PCHAR DiskName,
    IN BOOLEAN IsCdRom
    );

//
// This is the x86 version of the system parameter block on the ARC machines.
// It lives here, and any module that uses an ArcXXXX routine must declare
// it external.  Machines that have other than very plain-vanilla hardware
// may have to replace some of the hard-wired vectors with different
// procedures.
//

PVOID GlobalFirmwareVectors[MaximumRoutine];

SYSTEM_PARAMETER_BLOCK GlobalSystemBlock =
    {
        0,                              // Signature??
        sizeof(SYSTEM_PARAMETER_BLOCK), // Length
        0,                              // Version
        0,                              // Revision
        NULL,                           // RestartBlock
        NULL,                           // DebugBlock
        NULL,                           // GenerateExceptionVector
        NULL,                           // TlbMissExceptionVector
        MaximumRoutine,                 // FirmwareVectorLength
        GlobalFirmwareVectors,          // Pointer to vector block
        0,                              // VendorVectorLength
        NULL                            // Pointer to vendor vector block
    };


extern BL_FILE_TABLE BlFileTable[BL_FILE_TABLE_SIZE];

//
// temptemp John Vert (jvert) 6-Sep-1991
//      Just do this until we can make our device driver interface look
//      like the ARC firmware one.
//

extern BL_DEVICE_ENTRY_TABLE ScsiDiskEntryTable;

ULONG FwStallCounter;



//
// This table provides a quick lookup conversion between ASCII values
// that fall between 128 and 255, and their UNICODE counterpart.
//
// Note that ASCII values between 0 and 127 are equvilent to their
// unicode counter parts, so no lookups would be required.
//
// Therefore when using this table, remove the high bit from the ASCII
// value and use the resulting value as an offset into this array.  For
// example, 0x80 ->(remove the high bit) 00 -> 0x00C7.
//
USHORT PcAnsiToUnicode[0xFF] = {
        0x00C7,
        0x00FC,
        0x00E9,
        0x00E2,
        0x00E4,
        0x00E0,
        0x00E5,
        0x0087,
        0x00EA,
        0x00EB,
        0x00E8,
        0x00EF,
        0x00EE,
        0x00EC,
        0x00C4,
        0x00C5,
        0x00C9,
        0x00E6,
        0x00C6,
        0x00F4,
        0x00F6,
        0x00F2,
        0x00FB,
        0x00F9,
        0x00FF,
        0x00D6,
        0x00DC,
        0x00A2,
        0x00A3,
        0x00A5,
        0x20A7,
        0x0192,
        0x00E1,
        0x00ED,
        0x00F3,
        0x00FA,
        0x00F1,
        0x00D1,
        0x00AA,
        0x00BA,
        0x00BF,
        0x2310,
        0x00AC,
        0x00BD,
        0x00BC,
        0x00A1,
        0x00AB,
        0x00BB,
        0x2591,
        0x2592,
        0x2593,
        0x2502,
        0x2524,
        0x2561,
        0x2562,
        0x2556,
        0x2555,
        0x2563,
        0x2551,
        0x2557,
        0x255D,
        0x255C,
        0x255B,
        0x2510,
        0x2514,
        0x2534,
        0x252C,
        0x251C,
        0x2500,
        0x253C,
        0x255E,
        0x255F,
        0x255A,
        0x2554,
        0x2569,
        0x2566,
        0x2560,
        0x2550,
        0x256C,
        0x2567,
        0x2568,
        0x2564,
        0x2565,
        0x2559,
        0x2558,
        0x2552,
        0x2553,
        0x256B,
        0x256A,
        0x2518,
        0x250C,
        0x2588,
        0x2584,
        0x258C,
        0x2590,
        0x2580,
        0x03B1,
        0x00DF,
        0x0393,
        0x03C0,
        0x03A3,
        0x03C3,
        0x00B5,
        0x03C4,
        0x03A6,
        0x0398,
        0x03A9,
        0x03B4,
        0x221E,
        0x03C6,
        0x03B5,
        0x2229,
        0x2261,
        0x00B1,
        0x2265,
        0x2264,
        0x2320,
        0x2321,
        0x00F7,
        0x2248,
        0x00B0,
        0x2219,
        0x00B7,
        0x221A,
        0x207F,
        0x00B2,
        0x25A0,
        0x00A0
        };



VOID
AEInitializeStall(
    VOID
    )
{
    FwStallCounter = GET_STALL_COUNT();

    return;
}

//
// structure used to get typecast to
// function pointer from data pointer
// to compile w4
// (PKLDR_DATA_TABLE_ENTRY)
//
typedef struct {
    PDRIVER_ENTRY DriverEntry;
} _DRIVER_ENTRY, * _PDRIVER_ENTRY;


ARC_STATUS
AEInitializeIo(
    IN ULONG DriveId
    )

/*++

Routine Description:

    Initializes SCSI boot driver, if any.  Loads ntbootdd.sys from the
    boot partition, binds it to the osloader, and initializes it.

Arguments:

    DriveId - file id of the opened boot partition

Return Value:

    ESUCCESS - Drivers successfully initialized

--*/

{
    extern ULONG ScsiPortCount;
    extern ULONG MachineType;
    ARC_STATUS Status;
    PVOID Buffer;
    PVOID ImageBase;
    PKLDR_DATA_TABLE_ENTRY DriverDataTableEntry;
    PDRIVER_ENTRY Entry;
    extern MEMORY_DESCRIPTOR MDArray[];

    ScsiPortCount = 0;

    FwStallCounter = GET_STALL_COUNT();

    //
    // Hack: Win2K does not like it if the NTBOOTDD.SYS file is located at
    // page 0 or 1. So, put it at page 2
    //
    Status = BlLoadImageEx(
        DriveId,
        MemoryFirmwarePermanent,
        "\\NTBOOTDD.SYS",
        TARGET_IMAGE,
        0,
        2,
        &ImageBase
        );

    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // Find the memory descriptor for this entry in the table in the loader
    // block and then allocate it in the MD array.
    //

    {
        ULONG imageBasePage;
        ULONG imageEndPage = 0;
        PLIST_ENTRY entry;

        imageBasePage = (((ULONG)ImageBase) & 0x7fffffff) >> PAGE_SHIFT;

        entry = BlLoaderBlock->MemoryDescriptorListHead.Flink;

        while(entry != &(BlLoaderBlock->MemoryDescriptorListHead)) {
            PMEMORY_ALLOCATION_DESCRIPTOR descriptor;

            descriptor = CONTAINING_RECORD(entry,
                                           MEMORY_ALLOCATION_DESCRIPTOR,
                                           ListEntry);

            if(descriptor->BasePage == imageBasePage) {
                imageEndPage = imageBasePage + descriptor->PageCount;
                break;
            }

            entry = entry->Flink;
        }

        if(imageEndPage == 0) {
            return EINVAL;
        }

        Status = MempAllocDescriptor(imageBasePage,
                                     imageEndPage,
                                     MemoryFirmwareTemporary);

        if(Status != ESUCCESS) {
            return EINVAL;
        }
    }

    Status = BlAllocateDataTableEntry("NTBOOTDD.SYS",
                                      "\\NTBOOTDD.SYS",
                                      ImageBase,
                                      &DriverDataTableEntry);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // [ChuckL 2001-Dec-04]
    // BlAllocateDataTableEntry inserts the data table entry for NTBOOTDD.SYS
    // into BlLoaderBlock->LoadOrderListHead. We don't want this, for at least
    // two reasons:
    //
    //      1) This entry is only temporarily loaded for use by the loader. We
    //         don't want the kernel to think that it's loaded.
    //
    //      2) There is code in the kernel (MM) that assumes that the first two
    //         entries in the list are the kernel and HAL. But we've just
    //         inserted ntbootdd.sys as the first entry. This really screws up
    //         MM, because it ends up moving the HAL as if it were a loaded
    //         driver.
    //
    // Prior to a change to boot\bldr\osloader.c, the routine BlMemoryInitialize()
    // was called twice during loader init. The second call occurred after ntbootdd
    // was loaded, and reinitialized the LoadOrderListHead, thereby eliminating (by
    // accident) ntbootdd from the module list. Now we don't do the second memory
    // initialization, so we have to explicitly remove ntbootdd from the list.
    //

    RemoveEntryList(&DriverDataTableEntry->InLoadOrderLinks);

    //
    // Scan the import table and bind to osloader
    //

    Status = BlScanOsloaderBoundImportTable(DriverDataTableEntry);

    if (Status != ESUCCESS) {
        return(Status);
    }

    Entry = ((_PDRIVER_ENTRY)(&(DriverDataTableEntry->EntryPoint)))->DriverEntry;

    //
    // Before calling into the driver we need to collect ARC info blocks
    // for all the bios based devices.
    //

    AEGetArcDiskInformation();

    //
    // Zero out the driver object.
    //

    Status = (*Entry)(NULL, NULL);

    if (Status == ESUCCESS) {

        Buffer = FwAllocateHeap(SIZE_FOR_SUPPORTED_DISK_STRUCTURE);

        if(Buffer == NULL) {
            return ENOMEM;
        }

        HardDiskInitialize(Buffer, SUPPORTED_NUMBER_OF_DISKS, NULL);
    }

    if(Status == ESUCCESS) {
        AEBiosDisabled = TRUE;
    }
    return(Status);
}


VOID
BlFillInSystemParameters(
    IN PBOOT_CONTEXT BootContextRecord
    )
/*++

Routine Description:

    This routine fills in all the fields in the Global System Parameter Block
    that it can.  This includes all the firmware vectors, the vendor-specific
    information, and anything else that may come up.

Arguments:

    None.


Return Value:

    None.

--*/

{

    UNREFERENCED_PARAMETER( BootContextRecord );

    //
    // Fill in the pointers to the firmware functions which we emulate.
    // Those which we don't emulate are stubbed by BlArcNotYetImplemented,
    // which will print an error message if it is accidentally called.
    //

    FIRMWARE_VECTOR_BLOCK->LoadRoutine               = (PARC_LOAD_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->InvokeRoutine             = (PARC_INVOKE_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->ExecuteRoutine            = (PARC_EXECUTE_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->HaltRoutine               = (PARC_HALT_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->PowerDownRoutine          = (PARC_POWERDOWN_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->InteractiveModeRoutine    = (PARC_INTERACTIVE_MODE_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->AddChildRoutine           = (PARC_ADD_CHILD_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->SaveConfigurationRoutine  = (PARC_SAVE_CONFIGURATION_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->GetSystemIdRoutine        = (PARC_GET_SYSTEM_ID_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->MountRoutine              = (PARC_MOUNT_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->SetFileInformationRoutine = (PARC_SET_FILE_INFO_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->GetDirectoryEntryRoutine  = (PARC_GET_DIRECTORY_ENTRY_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->SetEnvironmentRoutine     = (PARC_SET_ENVIRONMENT_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->FlushAllCachesRoutine     = (PARC_FLUSH_ALL_CACHES_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->TestUnicodeCharacterRoutine = (PARC_TEST_UNICODE_CHARACTER_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->GetDisplayStatusRoutine   = (PARC_GET_DISPLAY_STATUS_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->DeleteComponentRoutine    = (PARC_DELETE_COMPONENT_ROUTINE)BlArcNotYetImplemented;

    FIRMWARE_VECTOR_BLOCK->CloseRoutine              = AEClose;
    FIRMWARE_VECTOR_BLOCK->OpenRoutine               = AEOpen;

    FIRMWARE_VECTOR_BLOCK->MemoryRoutine             = AEGetMemoryDescriptor;
    FIRMWARE_VECTOR_BLOCK->SeekRoutine               = AESeek;
    FIRMWARE_VECTOR_BLOCK->ReadRoutine               = AERead;
    FIRMWARE_VECTOR_BLOCK->ReadStatusRoutine         = AEReadStatus;
    FIRMWARE_VECTOR_BLOCK->WriteRoutine              = AEWrite;
    FIRMWARE_VECTOR_BLOCK->GetFileInformationRoutine = AEGetFileInformation;
    FIRMWARE_VECTOR_BLOCK->GetTimeRoutine            = AEGetTime;
    FIRMWARE_VECTOR_BLOCK->GetRelativeTimeRoutine    = AEGetRelativeTime;

    FIRMWARE_VECTOR_BLOCK->GetPeerRoutine            = FwGetPeer;
    FIRMWARE_VECTOR_BLOCK->GetChildRoutine           = FwGetChild;
    FIRMWARE_VECTOR_BLOCK->GetParentRoutine          = AEGetParent;
    FIRMWARE_VECTOR_BLOCK->GetComponentRoutine       = FwGetComponent;
    FIRMWARE_VECTOR_BLOCK->GetDataRoutine            = AEGetConfigurationData;
    FIRMWARE_VECTOR_BLOCK->GetEnvironmentRoutine     = AEGetEnvironment;

    FIRMWARE_VECTOR_BLOCK->RestartRoutine            = AEReboot;
    FIRMWARE_VECTOR_BLOCK->RebootRoutine             = AEReboot;

}


PMEMORY_DESCRIPTOR
AEGetMemoryDescriptor(
    IN PMEMORY_DESCRIPTOR MemoryDescriptor OPTIONAL
    )

/*++

Routine Description:

    Emulates the Arc GetMemoryDescriptor call.  This must translate
    between the memory description passed to us by the SU module and
    the MEMORYDESCRIPTOR type defined by ARC.

Arguments:

    MemoryDescriptor - Supplies current memory descriptor.
        If MemoryDescriptor==NULL, return the first memory descriptor.
        If MemoryDescriptor!=NULL, return the next memory descriptor.

Return Value:

    Next memory descriptor in the list.
    NULL if MemoryDescriptor is the last descriptor in the list.

--*/

{
    extern MEMORY_DESCRIPTOR MDArray[];
    extern ULONG NumberDescriptors;
    PMEMORY_DESCRIPTOR Return;
    if (MemoryDescriptor==NULL) {
        Return=MDArray;
    } else {
        if((ULONG)(MemoryDescriptor-MDArray) >= (NumberDescriptors-1)) {
            return NULL;
        } else {
            Return = ++MemoryDescriptor;
        }
    }
    return(Return);

}


ARC_STATUS
BlArcNotYetImplemented(
    IN ULONG FileId
    )

/*++

Routine Description:

    This is a stub routine used to fill in the firmware vectors which haven't
    been defined yet.  It uses BlPrint to print a message on the screen.

Arguments:

    None.

Return Value:

    EINVAL

--*/

{
    BlPrint("ERROR - Unimplemented Firmware Vector called (FID %lx)\n",
            FileId );
    return(EINVAL);
}

//
// these routines will all point
// to BlArcNotYetImplemented, but are needed
// to get the loader to compiler /W4
//
ARC_STATUS
BlDefaultMountRoutine(
    IN CHAR * FIRMWARE_PTR MountPath,
    IN MOUNT_OPERATION Operation
    )
{
    UNREFERENCED_PARAMETER(Operation);

    return BlArcNotYetImplemented((ULONG) MountPath);
}



PCONFIGURATION_COMPONENT
FwGetChild(
    IN PCONFIGURATION_COMPONENT Current
    )

/*++

Routine Description:

    This is the arc emulation routine for GetChild.  Based on the current
    component, it returns the component's child component.

Arguments:

    Current - Supplies pointer to the current configuration component

Return Value:

    A pointer to a CONFIGURATION_COMPONENT structure OR
    NULL - No more configuration information


--*/

{
    PCONFIGURATION_COMPONENT_DATA CurrentEntry;

    //
    // if current component is NULL, return a pointer to first system
    // component; otherwise return current component's child component.
    //

    if (Current) {
        CurrentEntry = CONTAINING_RECORD(Current,
                                         CONFIGURATION_COMPONENT_DATA,
                                         ComponentEntry);
        if (CurrentEntry->Child) {
            return(&(CurrentEntry->Child->ComponentEntry));
        } else {
            return(NULL);
        }
    } else {
        if (FwConfigurationTree) {
            return(&(FwConfigurationTree->ComponentEntry));
        } else {
            return(NULL);
        }
    }

}


PCONFIGURATION_COMPONENT
FwGetPeer(
    IN PCONFIGURATION_COMPONENT Current
    )

/*++

Routine Description:

    This is the arc emulation routine for GetPeer.  Based on the current
    component, it returns the component's sibling.

Arguments:

    Current - Supplies pointer to the current configuration component

Return Value:

    A pointer to a CONFIGURATION_COMPONENT structure OR
    NULL - No more configuration information


--*/

{
    PCONFIGURATION_COMPONENT_DATA CurrentEntry;


    if (Current) {
        CurrentEntry = CONTAINING_RECORD(Current,
                                         CONFIGURATION_COMPONENT_DATA,
                                         ComponentEntry);
        if (CurrentEntry->Sibling) {
            return(&(CurrentEntry->Sibling->ComponentEntry));
        } else {
            return(NULL);
        }
    } else {
        return(NULL);
    }

}


PCONFIGURATION_COMPONENT
AEGetParent(
    IN PCONFIGURATION_COMPONENT Current
    )

/*++

Routine Description:

    This is the arc emulation routine for GetParent.  Based on the current
    component, it returns the component's parent.

Arguments:

    Current - Supplies pointer to the current configuration component

Return Value:

    A pointer to a CONFIGURATION_COMPONENT structure OR
    NULL - No more configuration information


--*/

{
    PCONFIGURATION_COMPONENT_DATA CurrentEntry;


    if (Current) {
        CurrentEntry = CONTAINING_RECORD(Current,
                                         CONFIGURATION_COMPONENT_DATA,
                                         ComponentEntry);
        if (CurrentEntry->Parent) {
            return(&(CurrentEntry->Parent->ComponentEntry));
        } else {
            return(NULL);
        }
    } else {
        return(NULL);
    }

}


ARC_STATUS
AEGetConfigurationData(
    IN PVOID ConfigurationData,
    IN PCONFIGURATION_COMPONENT Current
    )

/*++

Routine Description:

    This is the arc emulation routine for GetParent.  Based on the current
    component, it returns the component's parent.

Arguments:

    Current - Supplies pointer to the current configuration component

Return Value:

    ESUCCESS - Data successfully returned.


--*/

{
    PCONFIGURATION_COMPONENT_DATA CurrentEntry;


    if (Current) {
        CurrentEntry = CONTAINING_RECORD(Current,
                                         CONFIGURATION_COMPONENT_DATA,
                                         ComponentEntry);
        RtlMoveMemory(ConfigurationData,
                      CurrentEntry->ConfigurationData,
                      Current->ConfigurationDataLength);
        return(ESUCCESS);
    } else {
        return(EINVAL);
    }

}


PCHAR
AEGetEnvironment(
    IN PCHAR Variable
    )

/*++

Routine Description:

    This is the arc emulation routine for ArcGetEnvironment.  It returns
    the value of the specified NVRAM environment variable.

    NOTE John Vert (jvert) 23-Apr-1992
        This particular implementation uses the Daylight Savings Bit on
        the Real Time Clock to reflect the state of the LastKnownGood
        environment variable.  This is the only variable we support.

Arguments:

    Variable - Supplies the name of the environment variable to look up.

Return Value:

    A pointer to the specified environment variable's value, or
    NULL if the variable does not exist.

--*/

{
    UCHAR StatusByte;

    if (_stricmp(Variable, "LastKnownGood") != 0) {
        return(NULL);
    }

    //
    // Read the Daylight Savings Bit out of the RTC to determine whether
    // the LastKnownGood environment variable is TRUE or FALSE.
    //

    WRITE_PORT_UCHAR(CMOS_CONTROL_PORT, CMOS_STATUS_B);
    StatusByte = READ_PORT_UCHAR(CMOS_DATA_PORT);
    if (StatusByte & CMOS_DAYLIGHT_BIT) {
        return("TRUE");
    } else {
        return(NULL);
    }


}


ARC_STATUS
AEOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Opens the file or device specified by OpenPath.

Arguments:

    OpenPath - Supplies a pointer to the fully-qualified path name.

    OpenMode - Supplies the mode to open the file.
                0 - Read Only
                1 - Write Only
                2 - Read/Write

    FileId - Returns the file descriptor for use with the Close, Read, Write,
             and Seek routines

Return Value:

    ESUCCESS - File successfully opened.

--*/

{
    ARC_STATUS Status;
    CHAR Buffer[128];

    Status = RamdiskOpen( OpenPath,
                          OpenMode,
                          FileId );

    if (Status == ESUCCESS) {
        return(ESUCCESS);
    }

    Status = BiosConsoleOpen( OpenPath,
                              OpenMode,
                              FileId );

    if (Status == ESUCCESS) {
        return(ESUCCESS);
    }

    //
    // Once a disk driver has been loaded we need to disable bios access to
    // all drives to avoid mixing bios & driver i/o operations.
    //

    if(AEBiosDisabled == FALSE) {
        Status = BiosPartitionOpen( OpenPath,
                                    OpenMode,
                                    FileId );

        if (Status == ESUCCESS) {
            return(ESUCCESS);
        }
    }

    //
    // It's not the console or a BIOS partition, so let's try the SCSI
    // driver.
    //

    //
    // Find a free FileId
    //

    *FileId = 2;
    while (BlFileTable[*FileId].Flags.Open == 1) {
        *FileId += 1;
        if (*FileId == BL_FILE_TABLE_SIZE) {
            return(ENOENT);
        }
    }

    strcpy(Buffer,OpenPath);

    Status = ScsiDiskOpen( Buffer,
                           OpenMode,
                           FileId );

    if (Status == ESUCCESS) {

        //
        // SCSI successfully opened it.  For now, we stick the appropriate
        // SCSI DeviceEntryTable into the BlFileTable.  This is temporary.
        //

        BlFileTable[*FileId].Flags.Open = 1;
        BlFileTable[*FileId].DeviceEntryTable = &ScsiDiskEntryTable;
        return(ESUCCESS);
    }

    return(Status);
}


ARC_STATUS
AESeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    Changes the current offset of the file specified by FileId

Arguments:

    FileId - specifies the file on which the current offset is to
             be changed.

    Offset - New offset into file.

    SeekMode - Either SeekAbsolute or SeekRelative
               SeekEndRelative is not supported

Return Value:

    ESUCCESS - Operation completed succesfully

    EBADF - Operation did not complete successfully.

--*/

{
    return(BlFileTable[FileId].DeviceEntryTable->Seek)( FileId,
                                                        Offset,
                                                        SeekMode );
}


ARC_STATUS
AEClose (
    IN ULONG FileId
    )

/*++

Routine Description:

    Closes the file specified by FileId

Arguments:

    FileId - specifies the file to close

Return Value:

    ESUCCESS - Operation completed succesfully

    EBADF - Operation did not complete successfully.

--*/

{

    return(BlFileTable[FileId].DeviceEntryTable->Close)(FileId);

}


ARC_STATUS
AEReadStatus(
    IN ULONG FileId
    )

/*++

Routine Description:

    Determines if data is available on the specified device

Arguments:

    FileId - Specifies the device to check for data.

Return Value:

    ESUCCESS - At least one byte is available.

    EAGAIN - No data is available

--*/

{
    //
    // Special case for console input
    //
    if (FileId == 0) {

        //
        // Give priority to dumb terminal
        //
        if (BlIsTerminalConnected() && (PortBufferStart != PortBufferEnd)) {
            return(ESUCCESS);
        }

        if (BlIsTerminalConnected() && (BlPortPollOnly(BlTerminalDeviceId) == CP_GET_SUCCESS)) {
            return(ESUCCESS);
        }
        return(BiosConsoleReadStatus(FileId));
    } else {
        return(BlArcNotYetImplemented(FileId));
    }

}


ARC_STATUS
AERead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Reads from the specified file or device

Arguments:

    FileId - specifies the file to read from

    Buffer - Address of buffer to hold the data that is read

    Length - Maximum number of bytes to read

    Count -  Address of location in which to store the actual bytes read.

Return Value:

    ESUCCESS - Read completed successfully

    !ESUCCESS - Read failed.

--*/

{
    ARC_STATUS Status;
    ULONG Limit;
    ULONG PartCount;
    PUCHAR TmpBuffer;
    ULONG StartTime;
    ULONG LastTime;
    UCHAR Ch;

    //
    // Special case console input
    //
    if (FileId == 0) {

RetryRead:

        if (BlIsTerminalConnected()) {

            *Count = 0;
            TmpBuffer = (PUCHAR)Buffer;

            while (*Count < Length) {

                //
                // First return any buffered input
                //
                if (PortBufferStart != PortBufferEnd) {
                    TmpBuffer[*Count] = PortBuffer[PortBufferStart];
                    PortBufferStart++;
                    PortBufferStart = PortBufferStart % PORT_BUFFER_SIZE;
                    *Count = *Count + 1;
                    continue;
                }

                //
                // Now check for new input
                //
                if (BlPortPollByte(BlTerminalDeviceId, TmpBuffer + *Count) != CP_GET_SUCCESS) {
                    break;
                }

                //
                // Convert ESC key to the local equivalent
                //
                if (TmpBuffer[*Count] == 0x1b) {
                    TmpBuffer[*Count] = (UCHAR)ASCI_CSI_IN;

                    //
                    // Wait for the user to type a key.
                    //
                    StartTime = AEGetRelativeTime();

                    while (BlPortPollOnly(BlTerminalDeviceId) != CP_GET_SUCCESS) {
                        LastTime = AEGetRelativeTime();

                        //
                        // if the counter wraps back to zero, just restart the wait.
                        //
                        if (LastTime < StartTime) {
                            StartTime = LastTime;
                        }

                        //
                        // If one second has passed, the user must have just wanted a single
                        // escape key, so return with that.
                        //
                        if ((LastTime - StartTime) > 1) {
                            *Count = *Count + 1;
                            return (ESUCCESS);
                        }

                    }

                    //
                    // We have another key, get it and translate the escape sequence.
                    //
                    if (BlPortPollByte(BlTerminalDeviceId, &Ch) != CP_GET_SUCCESS) {
                        *Count = *Count + 1;
                        return (ESUCCESS);
                    }


                    switch (Ch) {
                    case '@': // F12 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'B';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '!': // F11 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'A';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '0': // F10 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'M';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '9': // F9 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'p';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '8': // F8 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'r';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '7': // F7 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'q';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '6': // F6 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'u';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '5': // F5 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 't';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '4': // F4 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'x';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '3': // F3 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'w';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '2': // F2 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'Q';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '1': // F1 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'P';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case 'H': // Home key
                    case 'h': // Home key
                        PortBuffer[PortBufferEnd] = 'H';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case 'K': // End key
                    case 'k': // End key
                        PortBuffer[PortBufferEnd] = 'K';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '+': // Insert key
                        PortBuffer[PortBufferEnd] = '@';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '-': // Del key
                        PortBuffer[PortBufferEnd] = 'P';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case (UCHAR)TAB_KEY: // Tab key
                        PortBuffer[PortBufferEnd] = (UCHAR)TAB_KEY;
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '[': // Cursor movement key

                        //
                        // The local computer can run a lot faster than the serial port can give bytes,
                        // so spin, polling, for a second.
                        //
                        StartTime = AEGetRelativeTime();
                        while (BlPortPollOnly(BlTerminalDeviceId) != CP_GET_SUCCESS) {
                            LastTime = AEGetRelativeTime();

                            //
                            // if the counter wraps back to zero, just restart the wait.
                            //
                            if (LastTime < StartTime) {
                                StartTime = LastTime;
                            }

                            //
                            // If one second has passed, we must be done.
                            //
                            if ((LastTime - StartTime) > 1) {
                                break;
                            }

                        }

                        if (BlPortPollByte(BlTerminalDeviceId, &Ch) != CP_GET_SUCCESS) {
                            PortBuffer[PortBufferEnd] = '[';
                            PortBufferEnd++;
                            PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                            break;
                        }

                        if ((Ch == 'A') || (Ch == 'B') || (Ch == 'C') || (Ch == 'D')) { // Arrow key.

                            PortBuffer[PortBufferEnd] = Ch;
                            PortBufferEnd++;
                            PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;

                        } else {

                            //
                            // Leave it as is
                            //
                            PortBuffer[PortBufferEnd] = '[';
                            PortBufferEnd++;
                            PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                            PortBuffer[PortBufferEnd] = Ch;
                            PortBufferEnd++;
                            PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        }
                        break;

                    default:
                        PortBuffer[PortBufferEnd] = Ch;
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;
                    }

                } else if (TmpBuffer[*Count] == 0x7F) { // DEL key
                    TmpBuffer[*Count] = (UCHAR)ASCI_CSI_IN;
                    PortBuffer[PortBufferEnd] = 'P';
                    PortBufferEnd++;
                    PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                }

                *Count = *Count + 1;
            }

            if (*Count != 0) {
                return(ESUCCESS);
            }

        }

        if (BiosConsoleReadStatus(FileId) == ESUCCESS) {
            return(BiosConsoleRead(FileId,Buffer,Length,Count));
        }

        goto RetryRead;

    } else {

        //
        // Declare a local 64KB aligned buffer, so we don't have to
        // break up I/Os of size less than 64KB, because the buffer
        // crosses a 64KB boundary.
        //
        static PCHAR AlignedBuf = 0;
        BOOLEAN fUseAlignedBuf;

        //
        // Initialize the AlignedBuf once from the pool.
        //

        if (!AlignedBuf) {
            AlignedBuf = FwAllocatePool(128 * 1024);
            AlignedBuf = ALIGN_BUFFER_ON_BOUNDARY(AlignedBuf, 64 * 1024);
        }

        *Count = 0;

        TmpBuffer = (PUCHAR) Buffer;

        do {
            fUseAlignedBuf = FALSE;

            if (((ULONG) TmpBuffer & 0xffff0000) !=
               (((ULONG) TmpBuffer + Length - 1) & 0xffff0000)) {

                //
                // If the buffer crosses the 64KB boundary use our
                // aligned buffer instead. If we don't have an aligned
                // buffer, adjust the read size.
                //

                if (AlignedBuf) {
                    fUseAlignedBuf = TRUE;

                    //
                    // We can read max 64KB into our aligned
                    // buffer.
                    //

                    Limit = Length;

                    if (Limit > (ULONG) 0xFFFF) {
                        Limit = (ULONG) 0xFFFF;
                    }

                } else {
                    Limit = (64 * 1024) - ((ULONG_PTR) TmpBuffer & 0xFFFF);
                }

            } else {

                Limit = Length;
            }

            Status = (BlFileTable[FileId].DeviceEntryTable->Read)( FileId,
                                                                (fUseAlignedBuf) ? AlignedBuf : (PCHAR)TmpBuffer,
                                                                Limit,
                                                                &PartCount  );

            //
            // If we used our aligned buffer, copy the read data
            // to the callers buffer.
            //

            if (fUseAlignedBuf) {
                RtlCopyMemory(TmpBuffer, AlignedBuf, PartCount);
            }

            *Count += PartCount;
            Length -= Limit;
            TmpBuffer += Limit;

            if (Status != ESUCCESS) {
#if DBG
                BlPrint("Disk I/O error: Status = %lx\n",Status);
#endif
                return(Status);
            }

        } while (Length > 0);

        return(Status);
    }
}


ARC_STATUS
AEWrite (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Writes to the specified file or device

Arguments:

    FileId - Supplies the file or device to write to

    Buffer - Supplies address of the data to be written

    Length - Supplies number of bytes to write

    Count -  Address of location in which to store the actual bytes written.

Return Value:

    ESUCCESS - Read completed successfully

    !ESUCCESS - Read failed.

--*/

{
    ARC_STATUS Status = ESUCCESS;

    if (FileId != 1) {
        //
        // if this is not stdio, just
        // pass to the real Write function
        //
        Status = AEWriteEx(FileId,
                           Buffer,
                           Length,
                           Count
                           );
    }
    else {
        //
        // special handler for stdio
        // to eat bad characters
        //

        ULONG      i, pos;
        ULONG      BytesWrote = 0;
        UCHAR      TmpBuffer[64];
        PUCHAR     String;

        RtlZeroMemory(TmpBuffer, sizeof(TmpBuffer));
        String = (PUCHAR) Buffer;

        for (i = 0, pos = 0; i < Length; /* nothing */) {

            if (String[i] != 0) {

                ULONG NumCharsToWrite;

                //
                // if the current character is a double byte character
                // both bytes must be added now.  the character is
                // displayed incorrectly if the two bytes are split
                // between the two buffers
                //
                NumCharsToWrite = 1;
                if (GrIsDBCSLeadByte(String[i]) && 
                    i + 1 < Length ) {
                    NumCharsToWrite = 2;
                }
                
                //
                // write TmpBuffer, if it is full
                //
                if (pos > sizeof(TmpBuffer) - NumCharsToWrite) {
                    Status = AEWriteEx(FileId,
                                       TmpBuffer,
                                       pos,
                                       &BytesWrote
                                       );

                    if (Count) {
                        *Count += BytesWrote;
                    }

                    //
                    // check to make sure write was successful,
                    // if not, return the error
                    //
                    if (Status != ESUCCESS) {
                        return Status;
                    }

                    //
                    // clean our buffer and reset pos
                    //
                    RtlZeroMemory(TmpBuffer, sizeof(TmpBuffer));
                    pos = 0;

                }
                //
                // otherwise, put the next char
                // into the buffer
                //
                else {

                    ULONG j;

                    for (j = 0; j < NumCharsToWrite; j++) {
                        TmpBuffer[pos++] = String[i++];
                    }
                }
            }
            else {
                //
                // eat all null characters.
                //
                i++;
            }
        }

        if (pos) {
            Status = AEWriteEx(FileId,
                               TmpBuffer,
                               pos,
                               &BytesWrote
                               );

            if (Count) {
                *Count += BytesWrote;
            }
        }
    }

    return Status;
}



ARC_STATUS
AEWriteEx (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Writes to the specified file or device

Arguments:

    FileId - Supplies the file or device to write to

    Buffer - Supplies address of the data to be written

    Length - Supplies number of bytes to write

    Count -  Address of location in which to store the actual bytes written.

Return Value:

    ESUCCESS - Read completed successfully

    !ESUCCESS - Read failed.

--*/

{
    ARC_STATUS Status;
    ULONG Limit;
    ULONG PartCount;
    PCHAR TmpBuffer;
    PUCHAR String;
    UCHAR Char;

    //
    // Special case for console output
    //
    if (FileId == 1) {

        if (BlIsTerminalConnected()) {

            //
            // Translate ANSI codes to vt100 escape sequences
            //
            TmpBuffer = (PCHAR)Buffer;
            Limit = Length;
            if (Length == 4) {
                if (strncmp(TmpBuffer, "\033[2J", Length)==0) {
                    //
                    // <CSI>2J turns into <CSI>H<CSI>J
                    //
                    // (erase entire screen)
                    //
                    TmpBuffer = "\033[H\033[J";
                    Limit = 6;
                } else if (strncmp(TmpBuffer, "\033[0J", Length)==0) {
                    //
                    // <CSI>0J turns into <CSI>J
                    //
                    // (erase to end of screen)
                    //
                    TmpBuffer = "\033[J";
                    Limit = 3;
                } else if (strncmp(TmpBuffer, "\033[0K", Length)==0) {
                    //
                    // <CSI>0K turns into <CSI>K
                    //
                    // (erase to end of the line)
                    //
                    TmpBuffer = "\033[K";
                    Limit = 3;
                } else if (strncmp(TmpBuffer, "\033[0m", Length)==0) {
                    //
                    // <CSI>0m turns into <CSI>m
                    //
                    // (turn attributes off)
                    //
                    TmpBuffer = "\033[m";
                    Limit = 3;
                }
            }

            //
            // loop through the string to be output, printing data to the
            // headless terminal.
            //
            String = (PUCHAR)TmpBuffer;
            for (PartCount = 0; PartCount < Limit; PartCount++, String++) {

#if UTF8_CLIENT_SUPPORT

                //
                // check if we're in a DBCS language.  If we are, then we
                // need to translate the characters into UTF8 codes by
                // referencing a lookup table in bootfont.bin
                //
                if (DbcsLangId) {
                    UCHAR  UTF8Encoding[3];
                    ULONG  i;

                    if (GrIsDBCSLeadByte(*String)) {

                        //
                        // double byte characters have their own separate table
                        // from the SBCS characters.
                        //
                        // we need to advance the string forward 2 characters
                        // for double byte characters.
                        //
                        GetDBCSUtf8Translation(String,UTF8Encoding);
                        String += 1;
                        PartCount += 1;

                    } else {
                        //
                        // single byte characters have their own separate table
                        // from the DBCS characters.
                        //
                        GetSBCSUtf8Translation(String,UTF8Encoding);
                    }


                    for( i = 0; i < 3; i++ ) {
                        if( UTF8Encoding[i] != 0 ) {
                            BlPortPutByte( BlTerminalDeviceId, UTF8Encoding[i] );
                            FwStallExecution(BlTerminalDelay);
                        }
                    }


                } else
#endif
                {
                    //
                    // standard ASCII character
                    //
                    Char = *String;
#if 1
                    //
                    // filter some characters that aren't printable in VT100
                    // into substitute characters which are printable
                    //
                    if (Char & 0x80) {

                        switch (Char) {
                        case 0xB0:  // Light shaded block
                        case 0xB3:  // Light vertical
                        case 0xBA:  // Double vertical line
                            Char = '|';
                            break;
                        case 0xB1:  // Middle shaded block
                        case 0xDC:  // Lower half block
                        case 0xDD:  // Right half block
                        case 0xDE:  // Left half block
                        case 0xDF:  // Upper half block
                            Char = '%';
                            break;
                        case 0xB2:  // Dark shaded block
                        case 0xDB:  // Full block
                            Char = '#';
                            break;
                        case 0xA9: // Reversed NOT sign
                        case 0xAA: // NOT sign
                        case 0xBB: // ''
                        case 0xBC: // ''
                        case 0xBF: // ''
                        case 0xC0: // ''
                        case 0xC8: // ''
                        case 0xC9: // ''
                        case 0xD9: // ''
                        case 0xDA: // ''
                            Char = '+';
                            break;
                        case 0xC4: // ''
                            Char = '-';
                            break;
                        case 0xCD: // ''
                            Char = '=';
                            break;
                        }

                    }
#endif

                    //
                    // If the high-bit is still set, and we're here, then we  know we're
                    // not doing DBCS/SBCS characters.  We need to convert this
                    // 8bit ANSI character into unicode, then UTF8 encode that, then send
                    // it over the wire.
                    //
                    if( Char & 0x80 ) {

                        UCHAR  UTF8Encoding[3] = {0};
                        ULONG  i;

                        //
                        // Lookup the Unicode equivilent of this 8-bit ANSI value.
                        //
                        UTF8Encode( PcAnsiToUnicode[(Char & 0x7F)],
                                    UTF8Encoding );

                        for( i = 0; i < 3; i++ ) {
                            if( UTF8Encoding[i] != 0 ) {
                                BlPortPutByte( BlTerminalDeviceId, UTF8Encoding[i] );
                                FwStallExecution(BlTerminalDelay);
                            }
                        }


                    } else {

                        //
                        // write the data to the port.  Note that we write an 8 bit
                        // character to the terminal, and that the remote display
                        // must correctly interpret the code for it to display
                        // properly.
                        //
                        BlPortPutByte(BlTerminalDeviceId, Char);
                        FwStallExecution(BlTerminalDelay);
                    }
                }
            }
        }

        return (BiosConsoleWrite(FileId,Buffer,Length,Count));

    } else {

        *Count = 0;
        String = (PUCHAR)Buffer;

        do {

            if (((ULONG) String & 0xffff0000) !=
               (((ULONG) String + Length) & 0xffff0000)) {

                Limit = 0x10000 - ((ULONG) String & 0x0000ffff);
            } else {

                Limit = Length;

            }

            Status = (BlFileTable[FileId].DeviceEntryTable->Write)( FileId,
                                                                String,
                                                                Limit,
                                                                &PartCount  );
            *Count += PartCount;
            Length -= Limit;
            String += Limit;

            if (Status != ESUCCESS) {
#if DBG
                BlPrint("AERead: Status = %lx\n",Status);
#endif
                return(Status);
            }

        } while (Length > 0);

        return(Status);
    }
}

ARC_STATUS
AEGetFileInformation(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInformation
    )
{
    return(BlFileTable[FileId].DeviceEntryTable->GetFileInformation)( FileId,
                                                                      FileInformation);
}


TIME_FIELDS AETime;

PTIME_FIELDS
AEGetTime(
    VOID
    )
{
    ULONG Date,Time;

    GET_DATETIME(&Date,&Time);

    //
    // Date and time are filled as as follows:
    //
    // Date:
    //
    //    bits 0  - 4  : day
    //    bits 5  - 8  : month
    //    bits 9  - 31 : year
    //
    // Time:
    //
    //    bits 0  - 5  : second
    //    bits 6  - 11 : minute
    //    bits 12 - 16 : hour
    //

    AETime.Second = (CSHORT)((Time & 0x0000003f) >> 0);
    AETime.Minute = (CSHORT)((Time & 0x00000fc0) >> 6);
    AETime.Hour   = (CSHORT)((Time & 0x0001f000) >> 12);

    AETime.Day    = (CSHORT)((Date & 0x0000001f) >> 0);
    AETime.Month  = (CSHORT)((Date & 0x000001e0) >> 5);
    AETime.Year   = (CSHORT)((Date & 0xfffffe00) >> 9);

    AETime.Milliseconds = 0;        // info is not available
    AETime.Weekday = 7;             // info is not available - set out of range

    return(&AETime);
}


ULONG
AEGetRelativeTime(
    VOID
    )

/*++

Routine Description:

    Returns the time in seconds since some arbitrary starting point.

Arguments:

    None

Return Value:

    Time in seconds since some arbitrary starting point.

--*/

{
    ULONG TimerTicks;

    TimerTicks = GET_COUNTER();

    return((TimerTicks*10) / 182);
}


VOID
AEReboot(
    VOID
    )

/*++

Routine Description:

    Reboots the machine.

Arguments:

    None

Return Value:

    Does not return

--*/

{
    ULONG DriveId;
    ULONG Status;

    TextGrTerminate();

    //
    // HACKHACK John Vert (jvert)
    //     Some SCSI drives get really confused and return zeroes when
    //     you use the BIOS to query their size after the AHA driver has
    //     initialized.  This can completely tube OS/2 or DOS.  So here
    //     we try and open both BIOS-accessible hard drives.  Our open
    //     code is smart enough to retry if it gets back zeros, so hopefully
    //     this will give the SCSI drives a chance to get their act together.
    //
    Status = ArcOpen("multi(0)disk(0)rdisk(0)partition(0)",
                     ArcOpenReadOnly,
                     &DriveId);
    if (Status == ESUCCESS) {
        ArcClose(DriveId);
    }

    Status = ArcOpen("multi(0)disk(0)rdisk(1)partition(0)",
                     ArcOpenReadOnly,
                     &DriveId);
    if (Status == ESUCCESS) {
        ArcClose(DriveId);
    }

    //
    // Check to see if this is a legacy free machine.  If so, use the ACPI 
    // specificed RESET_REG.  BlDetectLegacyFreeBios will read the FACP 
    // table.  We don't care if we decide if the bios is legacy free.  But
    // we need the contents of the table to do our own checks.
    //
    BlDetectLegacyFreeBios();
    if ( fadt && 
         (fadt->Header.Revision >= 2) && 
         (fadt->flags & RESET_CAP) ) {
    
        switch (fadt->reset_reg.AddressSpaceID) {
        case 0:
            // 
            // MEMORY
            //

            {
                PUCHAR ResetAddress;
            
                //
                // Make sure memory address is mapped.
                //
                ResetAddress = MmMapIoSpace(fadt->reset_reg.Address,
                                            1,
                                            MmNonCached
                                            );

                if (ResetAddress) {
                    WRITE_REGISTER_UCHAR(ResetAddress,
                                         fadt->reset_val
                                         );
                }

                break;
            }
        case 1:
            //
            // I/O
            //

            WRITE_PORT_UCHAR((PUCHAR)(ULONG_PTR)fadt->reset_reg.Address.LowPart,
                             fadt->reset_val
                             );
            break;
        case 2:
            //
            // PCI Config
            //
            {
                PCI_SLOT_NUMBER Slot;
                Slot.u.AsULONG = 0;
                Slot.u.bits.DeviceNumber = fadt->reset_reg.Address.HighPart;
                Slot.u.bits.FunctionNumber = fadt->reset_reg.Address.LowPart >> 16;

                HalSetBusDataByOffset(PCIBus,
                                      0,
                                      Slot.u.AsULONG,
                                      &fadt->reset_val,
                                      fadt->reset_reg.Address.LowPart & 0xff,
                                      1
                                      );

            }
            break;
        }
    }

    //
    // Legacy machines will reboot by writing to the keyboard controller.
    // 
    REBOOT_PROCESSOR();
}




ARC_STATUS
HardDiskPartitionOpen(
    IN ULONG   FileId,
    IN ULONG   DiskId,
    IN UCHAR   PartitionNumber
    )

/*++

Routine Description:

    This routine opens the specified partition and sets the partition info
    in the FileTable at the specified index.  It does not fill in the
    Device Entry table.

    It reads the partition information until the requested partition
    is found or no more partitions are defined.

Arguments:

    FileId - Supplies the file id for the file table entry.

    DiskId - Supplies the file id for the physical device.

    PartitionNumber - Supplies the zero-based partition number

Return Value:

    If a valid partition is found on the hard disk, then ESUCCESS is
    returned. Otherwise, EIO is returned.

--*/

{

    USHORT DataBuffer[SECTOR_SIZE / sizeof(USHORT)];
    PPARTITION_DESCRIPTOR Partition;
    ULONG PartitionLength;
    ULONG StartingSector;
    ULONG VolumeOffset;
    ARC_STATUS Status;
    BOOLEAN PrimaryPartitionTable;
    ULONG PartitionOffset=0;
    ULONG PartitionIndex,PartitionCount=0;
    ULONG Count;
    LARGE_INTEGER SeekPosition;

    BlFileTable[FileId].u.PartitionContext.DiskId=(UCHAR)DiskId;
    BlFileTable[FileId].Position.QuadPart=0;

    VolumeOffset=0;
    PrimaryPartitionTable=TRUE;

    //
    // Change to a 1-based partition number
    //
    PartitionNumber++;

    do {
        SeekPosition.QuadPart = (LONGLONG)PartitionOffset * SECTOR_SIZE;
        Status = (BlFileTable[DiskId].DeviceEntryTable->Seek)(DiskId,
                                                              &SeekPosition,
                                                              SeekAbsolute );
        if (Status != ESUCCESS) {
            return(Status);
        }
        Status = (BlFileTable[DiskId].DeviceEntryTable->Read)(DiskId,
                                                              DataBuffer,
                                                              SECTOR_SIZE,
                                                              &Count );

        if (Status != ESUCCESS) {
            return Status;
        }

        //
        // If sector zero is not a master boot record, then return failure
        // status. Otherwise return success.
        //

        if (DataBuffer[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {
#if DBG
            BlPrint("Boot record signature %x not found (%x found)\n",
                    BOOT_RECORD_SIGNATURE,
                    DataBuffer[BOOT_SIGNATURE_OFFSET] );
#endif
            Status = EIO;
            break;
        }

        //
        // Read the partition information until the four entries are
        // checked or until we found the requested one.
        //
        Partition = (PPARTITION_DESCRIPTOR)&DataBuffer[PARTITION_TABLE_OFFSET];
        for (PartitionIndex=0;
             PartitionIndex < NUM_PARTITION_TABLE_ENTRIES;
             PartitionIndex++,Partition++) {

            //
            // Count first the partitions in the MBR. The units
            // inside the extended partition are counted later.
            //
            if ((Partition->PartitionType != PARTITION_ENTRY_UNUSED) &&
                (Partition->PartitionType != STALE_GPT_PARTITION_ENTRY) &&
                !IsContainerPartition(Partition->PartitionType))
            {
                PartitionCount++;   // another partition found.
            }

            //
            // Check if the requested partition has already been found.
            // set the partition info in the file table and return.
            //
            if (PartitionCount == PartitionNumber) {
                StartingSector = (ULONG)(Partition->StartingSectorLsb0) |
                                 (ULONG)(Partition->StartingSectorLsb1 << 8) |
                                 (ULONG)(Partition->StartingSectorMsb0 << 16) |
                                 (ULONG)(Partition->StartingSectorMsb1 << 24);
                PartitionLength = (ULONG)(Partition->PartitionLengthLsb0) |
                                  (ULONG)(Partition->PartitionLengthLsb1 << 8) |
                                  (ULONG)(Partition->PartitionLengthMsb0 << 16) |
                                  (ULONG)(Partition->PartitionLengthMsb1 << 24);
                BlFileTable[FileId].u.PartitionContext.PartitionLength.QuadPart =
                        ((ULONGLONG)PartitionLength << SECTOR_SHIFT);
                BlFileTable[FileId].u.PartitionContext.StartingSector=PartitionOffset + StartingSector;
                return ESUCCESS;
            }
        }

        //
        //  If requested partition was not yet found.
        //  Look for an extended partition.
        //
        Partition = (PPARTITION_DESCRIPTOR)&DataBuffer[PARTITION_TABLE_OFFSET];
        PartitionOffset = 0;
        for (PartitionIndex=0;
            PartitionIndex < NUM_PARTITION_TABLE_ENTRIES;
            PartitionIndex++,Partition++) {
            if (IsContainerPartition(Partition->PartitionType)) {
                StartingSector = (ULONG)(Partition->StartingSectorLsb0) |
                                 (ULONG)(Partition->StartingSectorLsb1 << 8) |
                                 (ULONG)(Partition->StartingSectorMsb0 << 16) |
                                 (ULONG)(Partition->StartingSectorMsb1 << 24);
                PartitionOffset = VolumeOffset+StartingSector;
                if (PrimaryPartitionTable) {
                    VolumeOffset = StartingSector;
                }
                break;      // only one partition can be extended.
            }
        }

        PrimaryPartitionTable=FALSE;
    } while (PartitionOffset != 0);

    return EBADF;
}


VOID
BlpTranslateDosToArc(
    IN PCHAR DosName,
    OUT PCHAR ArcName
    )

/*++

Routine Description:

    This routine takes a DOS drive name ("A:" "B:" "C:" etc.) and translates
    it into an ARC name.  ("multi(0)disk(0)rdisk(0)partition(1)")

    N.B.    This will always return some sort of name suitable for passing
            to BiosPartitionOpen.  The name it constructs may not be an
            actual partition.  BiosPartitionOpen is responsible for
            determining whether the partition actually exists.

            Since no other driver should ever use ARC names beginning with
            "multi(0)disk(0)..." this will not be a problem.  (there is no
            way this routine will construct a name that BiosPartitionOpen
            will not open, but some other random driver will grab and
            successfully open)

Arguments:

    DosName - Supplies the DOS name of the drive.

    ArcName - Returns the ARC name of the drive.

Return Value:

--*/

{
    ARC_STATUS Status;
    ULONG DriveId;
    ULONG PartitionNumber;
    ULONG PartitionCount;
    ULONG Count;
    USHORT DataBuffer[SECTOR_SIZE / sizeof(USHORT)];
    PPARTITION_DESCRIPTOR Partition;
    ULONG PartitionIndex;
    BOOLEAN HasPrimary;
    LARGE_INTEGER SeekPosition;

    //
    // Eliminate the easy ones first.
    //    A: is always "multi(0)disk(0)fdisk(0)partition(0)"
    //    B: is always "multi(0)disk(0)fdisk(1)partition(0)"
    //    C: is always "multi(0)disk(0)rdisk(0)partition(1)"
    //

    if (_stricmp(DosName,"A:")==0) {
        strcpy(ArcName,"multi(0)disk(0)fdisk(0)partition(0)");
        return;
    }
    if (_stricmp(DosName,"B:")==0) {
        strcpy(ArcName,"multi(0)disk(0)fdisk(1)partition(0)");
        return;
    }
    if (_stricmp(DosName,"C:")==0) {
        strcpy(ArcName,"multi(0)disk(0)rdisk(0)partition(1)");
        return;
    }

    //
    // Now things get more unpleasant.  If there are two drives, then
    // D: is the primary partition on the second drive.  Successive letters
    // are the secondary partitions on the first drive, then back to the
    // second drive when that runs out.
    //
    // The exception to this is when there is no primary partition on the
    // second drive.  Then, we letter the partitions on the first driver
    // consecutively, and when those partitions run out, we letter the
    // partitions on the second drive.
    //
    // I have no idea who came up with this wonderful scheme, but we have
    // to live with it.
    //

    //
    // Try to open the second drive.  If this doesn't work, we only have
    // one drive and life is easy.
    //
    Status = ArcOpen("multi(0)disk(0)rdisk(1)partition(0)",
                     ArcOpenReadOnly,
                     &DriveId );

    if (Status != ESUCCESS) {

        //
        // We only have one drive, so whatever drive letter he's requesting
        // has got to be on it.
        //

        sprintf(ArcName,
                "multi(0)disk(0)rdisk(0)partition(%d)",
                toupper(DosName[0]) - 'C' + 1 );

        return;
    } else {

        //
        // Now we read the partition table off the second drive, so we can
        // tell if there is a primary partition or not.
        //
        SeekPosition.QuadPart = 0;

        Status = ArcSeek(DriveId,
                         &SeekPosition,
                         SeekAbsolute);
        if (Status != ESUCCESS) {
            ArcName[0]='\0';
            return;
        }

        Status = ArcRead(DriveId, DataBuffer, SECTOR_SIZE, &Count);
        ArcClose(DriveId);

        if (Status != ESUCCESS) {
            ArcName[0] = '\0';
            return;
        }

        HasPrimary = FALSE;

        Partition = (PPARTITION_DESCRIPTOR)&DataBuffer[PARTITION_TABLE_OFFSET];
        for (PartitionIndex = 0;
             PartitionIndex < NUM_PARTITION_TABLE_ENTRIES;
             PartitionIndex++,Partition++) {
            if (IsRecognizedPartition(Partition->PartitionType)) {
                HasPrimary = TRUE;
            }
        }

        //
        // Now we have to go through and count
        // the partitions on the first drive.  We do this by just constructing
        // ARC names for each successive partition until one BiosPartitionOpen
        // call fails.
        //

        PartitionCount = 0;
        do {
            ++PartitionCount;
            sprintf(ArcName,
                    "multi(0)disk(0)rdisk(0)partition(%d)",
                    PartitionCount+1);

            Status = BiosPartitionOpen( ArcName,
                                        ArcOpenReadOnly,
                                        &DriveId );

            if (Status==ESUCCESS) {
                BiosPartitionClose(DriveId);
            }
        } while ( Status == ESUCCESS );

        PartitionNumber = toupper(DosName[0])-'C' + 1;

        if (HasPrimary) {

            //
            // There is Windows NT primary partition on the second drive.
            //
            // If the DosName is "D:" then we know
            // this is the first partition on the second drive.
            //

            if (_stricmp(DosName,"D:")==0) {
                strcpy(ArcName,"multi(0)disk(0)rdisk(1)partition(1)");
                return;
            }

            if (PartitionNumber-1 > PartitionCount) {
                PartitionNumber -= PartitionCount;
                sprintf(ArcName,
                        "multi(0)disk(0)rdisk(1)partition(%d)",
                        PartitionNumber );
            } else {
                sprintf(ArcName,
                        "multi(0)disk(0)rdisk(0)partition(%d)",
                        PartitionNumber-1);
            }

        } else {

            //
            // There is no primary partition on the second drive, so we
            // consecutively letter the partitions on the first drive,
            // then the second drive.
            //

            if (PartitionNumber > PartitionCount) {
                PartitionNumber -= PartitionCount;
                sprintf(ArcName,
                        "multi(0)disk(0)rdisk(1)partition(%d)",
                        PartitionNumber );
            } else {
                sprintf(ArcName,
                        "multi(0)disk(0)rdisk(0)partition(%d)",
                        PartitionNumber);
            }

        }


        return;
    }
}


VOID
FwStallExecution(
    IN ULONG Microseconds
    )

/*++

Routine Description:

    Does a busy wait for a specified number of microseconds (very approximate!)

Arguments:

    Microseconds - Supplies the number of microseconds to busy wait.

Return Value:

    None.

--*/

{
    ULONG FinalCount;

    FinalCount = Microseconds * FwStallCounter;

    _asm {
        mov eax,FinalCount
looptop:
        sub eax,1
        jnz short looptop
    }
}


BOOLEAN
FwGetPathMnemonicKey(
    IN PCHAR OpenPath,
    IN PCHAR Mnemonic,
    IN PULONG Key
    )

/*++

Routine Description:

    This routine looks for the given Mnemonic in OpenPath.
    If Mnemonic is a component of the path, then it converts the key
    value to an integer wich is returned in Key.

Arguments:

    OpenPath - Pointer to a string that contains an ARC pathname.

    Mnemonic - Pointer to a string that contains a ARC Mnemonic

    Key      - Pointer to a ULONG where the Key value is stored.


Return Value:

    FALSE  if mnemonic is found in path and a valid key is converted.
    TRUE   otherwise.

--*/

{
    return(BlGetPathMnemonicKey(OpenPath,Mnemonic,Key));
}


PCONFIGURATION_COMPONENT
FwAddChild (
    IN PCONFIGURATION_COMPONENT Component,
    IN PCONFIGURATION_COMPONENT NewComponent,
    IN PVOID ConfigurationData OPTIONAL
    )
{
    ULONG Size;
    PCONFIGURATION_COMPONENT_DATA NewEntry;
    PCONFIGURATION_COMPONENT_DATA Parent;

    UNREFERENCED_PARAMETER(ConfigurationData);

    if (Component==NULL) {
        return(NULL);
    }

    Parent = CONTAINING_RECORD(Component,
                               CONFIGURATION_COMPONENT_DATA,
                               ComponentEntry);

    Size = sizeof(CONFIGURATION_COMPONENT_DATA) +
           NewComponent->IdentifierLength + 1;

    NewEntry = FwAllocateHeap(Size);
    if (NewEntry==NULL) {
        return(NULL);
    }

    RtlCopyMemory(&NewEntry->ComponentEntry,
                  NewComponent,
                  sizeof(CONFIGURATION_COMPONENT));
    NewEntry->ComponentEntry.Identifier = (PCHAR)(NewEntry+1);
    NewEntry->ComponentEntry.ConfigurationDataLength = 0;
    strncpy(NewEntry->ComponentEntry.Identifier,
            NewComponent->Identifier,
            NewComponent->IdentifierLength);

    //
    // Add the new component as the first child of its parent.
    //
    NewEntry->Child = NULL;
    NewEntry->Sibling = Parent->Child;
    Parent->Child = NewEntry;

    return(&NewEntry->ComponentEntry);

}

PCONFIGURATION_COMPONENT
FwGetComponent(
    IN PCHAR Pathname
    )
{
    PCONFIGURATION_COMPONENT Component;
    PCONFIGURATION_COMPONENT MatchComponent;
    PCHAR PathString;
    PCHAR MatchString;
    PCHAR Token;
    ULONG Key;

    PathString = Pathname;

    //
    // Get the the root component.
    //

    MatchComponent = FwGetChild(NULL);

    //
    // Repeat search for each new match component.
    //

    do {

        //
        // Get the first child of the current match component.
        //

        Component = FwGetChild( MatchComponent );

        //
        // Search each child of the current match component for the next match.
        //

        while ( Component != NULL ) {

            //
            // Reset Token to be the current position on the pathname.
            //

            Token = PathString;

            MatchString = MnemonicTable[Component->Type];

            //
            // Compare strings.
            //

            while (*MatchString == tolower(*Token)) {
                MatchString++;
                Token++;
            }

            //
            // Strings compare if the first mismatch is the terminator for
            // each.
            //

            if ((*MatchString == 0) && (*Token == '(')) {

                //
                // Form key.
                //

                Key = 0;
                Token++;
                while ((*Token != ')') && (*Token != 0)) {
                    Key = (Key * 10) + *Token++ - '0';
                }

                //
                // If the key matches the component matches, so update
                // pointers and break.
                //

                if (Component->Key == Key) {
                    PathString = Token + 1;
                    MatchComponent = Component;
                    break;
                }
            }

            Component = FwGetPeer( Component );
        }

    } while ((Component != NULL) && (*PathString != 0));

    return MatchComponent;
}
/**********************
*
* The following are just stubs for the MIPS firmware.  They all return NULL
*
***********************/



ARC_STATUS
FwDeleteComponent (
    IN PCONFIGURATION_COMPONENT Component
    )
{
    UNREFERENCED_PARAMETER(Component);

    return(ESUCCESS);
}


VOID
AEGetArcDiskInformation(
    VOID
    )
{
    InitializeListHead(&(AEArcDiskInformation.DiskSignatures));
    AEArcDiskInformationInitialized = TRUE;

    //
    // Scan through each node of the hardware tree - look for disk type
    // devices hanging off of multi-function controllers.
    //

    FwSearchTree(FwGetChild(NULL),
                 PeripheralClass,
                 DiskPeripheral,
                 (ULONG)-1,
                 AEEnumerateDisks);
    return;
}


BOOLEAN
FwSearchTree(
    IN PCONFIGURATION_COMPONENT Node,
    IN CONFIGURATION_CLASS Class,
    IN CONFIGURATION_TYPE Type,
    IN ULONG Key,
    IN PFWNODE_CALLBACK CallbackRoutine
    )
/*++

Routine Description:

    Conduct a depth-first search of the firmware configuration tree starting
    at a given node, looking for nodes that match a given class and type.
    When a matching node is found, call a callback routine.

Arguments:

    CurrentNode - node at which to begin the search.

    Class - configuration class to match, or -1 to match any class

    Type - configuration type to match, or -1 to match any class

    Key - key to match, or -1 to match any key

    FoundRoutine - pointer to a routine to be called when a node whose
        class and type match the class and type passed in is located.
        The routine takes a pointer to the configuration node and must
        return a boolean indicating whether to continue with the traversal.

Return Value:

    FALSE if the caller should abandon the search.
--*/
{
    PCONFIGURATION_COMPONENT child;

    do {
        if ( (child = FwGetChild(Node)) != 0) {
            if ( (FwSearchTree(child,
                               Class,
                               Type,
                               Key,
                               CallbackRoutine)) == 0) {
                return(FALSE);
            }
        }

        if (((Class == -1) || (Node->Class == Class)) &&
            ((Type == -1) || (Node->Type == Type)) &&
            ((Key == (ULONG)-1) || (Node->Key == Key))) {

            if (!CallbackRoutine(Node)) {
                return(FALSE);
            }
        }

        Node = FwGetPeer(Node);

    } while ( Node != NULL );

    return(TRUE);
}


VOID
AEGetPathnameFromComponent(
    IN PCONFIGURATION_COMPONENT Component,
    OUT PCHAR ArcName
    )

/*++

Routine Description:

    This function builds an ARC pathname for the specified component.

Arguments:

    Component - Supplies a pointer to a configuration component.

    ArcName - Returns the ARC name of the specified component.  Caller must
        provide a large enough buffer.

Return Value:

    None.

--*/
{

    if (AEGetParent(Component) != NULL) {
        AEGetPathnameFromComponent(AEGetParent(Component),ArcName);

        //
        // append our segment to the arcname
        //

        sprintf(ArcName+strlen(ArcName),
                "%s(%d)",
                MnemonicTable[Component->Type],
                Component->Key);

    } else {
        //
        // We are the parent, initialize the string and return
        //
        ArcName[0] = '\0';
    }

    return;
}


BOOLEAN
AEEnumerateDisks(
    IN PCONFIGURATION_COMPONENT Disk
    )

/*++

Routine Description:

    Callback routine for enumerating the disks in the ARC firmware tree.  It
    reads all the necessary information from the disk to uniquely identify
    it.

Arguments:

    ConfigData - Supplies a pointer to the disk's ARC component data.

Return Value:

    TRUE - continue searching

    FALSE - stop searching tree.

--*/

{
    CHAR path[100] = "";
#if 0
    ULONG key;
#endif

    AEGetPathnameFromComponent(Disk, path);

#if 0
    if(BlGetPathMnemonicKey(path, "multi", &key) == FALSE) {
        DbgPrint("Found multi disk %s\n", path);
    } else {
        DbgPrint("Found disk %s\n", path);
    }
#endif

    AEReadDiskSignature(path, FALSE);

    return TRUE;
}


BOOLEAN
AEReadDiskSignature(
    IN PCHAR DiskName,
    IN BOOLEAN IsCdRom
    )

/*++

Routine Description:

    Given an ARC disk name, reads the MBR and adds its signature to the list of
    disks.

Arguments:

    Diskname - Supplies the name of the disk.

    IsCdRom - Indicates whether the disk is a CD-ROM.

Return Value:

    TRUE - Success

    FALSE - Failure

--*/

{
    PARC_DISK_SIGNATURE signature;
    BOOLEAN status;

    signature = FwAllocateHeap(sizeof(ARC_DISK_SIGNATURE));
    if (signature==NULL) {
        return(FALSE);
    }

    signature->ArcName = FwAllocateHeap(strlen(DiskName)+2);
    if (signature->ArcName==NULL) {
        return(FALSE);
    }

    status = BlGetDiskSignature(DiskName, IsCdRom, signature);
    if (status) {
        InsertHeadList(&(AEArcDiskInformation.DiskSignatures),
                       &(signature->ListEntry));

    }

    return(TRUE);
}


BOOLEAN
BlFindDiskSignature(
    IN PCHAR DiskName,
    IN PARC_DISK_SIGNATURE Signature
    )
{
    PARC_DISK_SIGNATURE match;
    CHAR buffer[] = "multi(xxx)disk(xxx)rdisk(xxx)";

    if(AEArcDiskInformationInitialized == FALSE) {
        return FALSE;
    }

    //
    // If the disk name passed in contains an eisa component then convert
    // the entire string into one with a multi component.
    //

    if(strncmp(DiskName, "eisa", strlen("eisa")) == 0) {
        strcpy(&(buffer[1]), DiskName);
        RtlCopyMemory(buffer, "multi", 5);
        DiskName = buffer;
    }

    match = CONTAINING_RECORD(AEArcDiskInformation.DiskSignatures.Flink,
                              ARC_DISK_SIGNATURE,
                              ListEntry);


    while(&(match->ListEntry) != &(AEArcDiskInformation.DiskSignatures)) {

        if(strcmp(DiskName, match->ArcName) == 0) {

            //
            // We found a match.  Copy all the information out of this node.
            //

            // DbgPrint("BlFindDiskSignature found a match for %s - %#08lx\n", DiskName, match);

            Signature->CheckSum = match->CheckSum;
            Signature->Signature = match->Signature;
            Signature->ValidPartitionTable = match->ValidPartitionTable;

            strcpy(Signature->ArcName, match->ArcName);

            return TRUE;
        }

        match = CONTAINING_RECORD(match->ListEntry.Flink,
                                  ARC_DISK_SIGNATURE,
                                  ListEntry);
    }

    DbgPrint("BlFindDiskSignature found no match for %s\n", DiskName);
    return FALSE;
}

VOID
AETerminateIo(
    VOID
    )
{
    if(AEDriverUnloadRoutine != NULL) {
        AEDriverUnloadRoutine(NULL);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\decode.inc ===
;**     Decoding macros
;
;       These walk a state machine based on where a command (i.e., char or string)
;       begins.  


;**     BitsAt - Extract from bit position n some bits
;
;       Macro parameter:
;               n       bit position to begin extract
;               cbits   number of bits to extract
;       Entry:  eax     working data
;               esi     input stream
;               edi     output stream
;       Exit:   eax     updated so that next data begins in al
;               esi/edi updated
;               ecx     contains data
;       Uses:   none

BitsAt  macro   n,cbits
        .errnz  n eq 0
        if      (n+cbits) lt 8          ; entire operation occurs in low byte
                CopyBits cx,ax,n,cbits  ; (cx) = desired bits rightmost
        elseif (n+cbits) lt 16          ; operation consumes byte
                CopyBits cx,ax,n,cbits  ; (cx) = desired bits rightmost
                lodsb                   ; (ah/al) = next input
                xchg    al,ah           ; (al/ah) = next input
        elseif (n+cbits) eq 16          ; operation consumes remainder of buffered data
                CopyBits cx,ax,n,cbits  ; (cx) = desired bits rightmost
                lodsw                   ; (al/ah) = next input
        else                            ; operation consumes into unbuffered data
                mov     ecx,eax
                lodsw
                shrd    cx,ax,n
                and     ecx,(1 shl cbits)-1
        endif
endm
                

;**     CmdAt - macro that processes a command at a bit position
;
;       Macro parameter:
;               n       bit position where command is expected
;       Entry:  eax     working data, command begins in al
;               esi     points to input stream
;               edi     points to output stream
;       Exit:   eax     updated so that next command begins in al
;               esi/edi updated
;               EXPECTS FALL-THROUGH TO NEXT CmdAT
;       Uses:   ecx, edx (not directly, but by virtue of OffsetAt, which
;               in turn calls LengthAt....)

CmdAt   macro   n
        local   ca1

        align4
        public  CmdAt&n
CmdAt&n:
    if n eq 7
        ror     eax,1
        test    al,11b shl 6
        rol     eax,1
    else
        test    al,11b shl n
    endif
        jpo     ca1

        OffsetAt %(n+1)
        align4                          ; note that OffsetAt jumps away
ca1:                                    ; so there is no fall-through penalty
        CharAt  %(n+1)
endm


;**     CharAt - macro that processes a character at a bit position
;
;       Macro parameter:
;               n       bit position where char is expected
;       Entry:  eax     working data, char may be in ah
;               esi     input stream
;               edi     output stream
;       Exit:   eax     updated so that next command begins in al
;               esi/edi updated
;       Uses:   ch

CharAt  macro   n
        if n eq 8
                mov     al,ah           ; (al) = char for output
                XlatChr
                CheckOffset
                stosb                   ; store it
                lodsw                   ; (al/ah) = next input
        else
                if n eq 1
                        shr     eax,1   ; (al) = byte for output
                        XlatChr
                        CheckOffset
                        stosb           ; store it
                        add     eax,eax ; (ah) = next byte
                        lodsb           ; (ah/al) = next input
                else
                        mov     ch,ah   ; (ch) = saved next input
                        shr     eax,n   ; (al) = byte for output
                        XlatChr
                        CheckOffset
                        stosb           ; store it
                        lodsb           ; (al) = byte-after-next
                        mov     ah,ch   ; (ah/al) = next input
                endif
                xchg    al,ah           ; (al/ah) = next input
        endif
endm


;**     OffsetAt - Parse an offset at a bit position
;
;       Macro parameter:
;               n       bit position where offset is expected
;       Entry:  cbits   number of bits in offset
;               eax     working data, offset may begin in ah
;               esi     input stream
;               edi     output stream
;       Exit:   eax     updated so that length begins in al
;               ecx     offset
;               esi/edi updated
;       Uses:   ecx

OffsetAt macro  n
        local   try8,try12

        public  OffsetAt&n
OffsetAt&n:
        CheckBit a,n                    ; does a 6-bit offset follow?
        jnz     try8                    ; no, try an 8-bit offset
        BitsAt  %(n+1),6                ; yes, load it into (ecx) and go
        Jump    LengthAt,%((n+7) mod 8)
        align4
try8:
        CheckBit a,%(n+1)               ; does an 8-bit offset follow?
        jnz     try12                   ; no, must be a 12-bit offset
        BitsAt  %(n+2),8                ; yes, load it into (ecx)
        add     ecx,MAX_6BIT_OFFSET+1   ;
        Jump    LengthAt,%((n+10) mod 8); go process the following length
        align4
try12:
        BitsAt  %(n+2),12               ; load 12-bit offset into (ecx)
        add     ecx,MAX_8BIT_OFFSET+1   ;
        Jump    LengthAt,%((n+14) mod 8); go process the following length
endm


;**     LengthAt - parse off a length at a position and move the bytes
;
;       LengthAt parses off a length (gamma-prime encoded), moves the
;       relevant string, and dispatches to the next command.
;
;       Macro parameter:
;               n       bit position to begin extract
;       Entry:  eax     working data
;               ecx     offset for string
;               esi     input stream
;               edi     output stream
;       Exit:   eax     updated so that next data begins in al
;               esi/edi updated
;       Uses:   ecx, edx

LengthAt macro  n
        local   try3,try5,try7,try9,tryGeneral,done,error

      % ifidni  <LastErrBJump>,<DecodeError>
        LastErrBJump equ <error>
        endif

        align4
        public  LengthAt&n
LengthAt&n:
        jecxz   error                   ; check for 0 offset (illegal)
        cmp     ecx,SPECIAL_EOS         ; check end-of-segment offset
        je      done                    ; that's our EOS, so get out
        CheckBit a,n                    ; is this a degenerate encoding?
        jz      try3                    ; no, go for a wider encoding
        DoMovs  short,2
        if n eq 7                       ; are we finished with this byte?
                lodsb                   ; (ah/al) is next input
                xchg    al,ah           ; (al/ah) is next input
        endif
        Jump    CmdAt,%((n + 1) mod 8)  ; go process next command
done:
        mov     dl,n                    ; DL == current state
        jmp     DecodeDone              ; exit
error:
;;        Debug_Out "MRCI32 Decompress32: bad offset in LengthAt&n"
        jmp     DecodeError

        align4
try3:
        mov     edx,ecx                 ; save delta
        CheckBit a,%(n + 1)             ; is this a 3-bit encoding?
        jz      try5                    ; no, go for wider still
        BitsAt  %(n+2),1
        DoMovs  short,ecx,3
        Jump    CmdAt,%((n + 3) mod 8)  ; go process next command

        align4
try5:
        CheckBit a,%(n + 2)             ; is this a 5-bit encoding?
        jz      try7                    ; no, go test for wider STILL
        BitsAt  %(n+3),2
        DoMovs  short,ecx,5
        Jump    CmdAt,%((n + 5) mod 8)  ; go process next command

        align4
try7:
        CheckBit a,%(n + 3)             ; is this a 7 bit encoding?
        jz      try9                    ; no, go test for wider STILL
        BitsAt  %(n+4),3
        DoMovs  long,ecx,9
        Jump    CmdAt,%((n + 7) mod 8)  ; go process next command

        align4
try9:
        CheckBit a,%(n + 4)             ; is this a 9 bit encoding?
        jz      tryGeneral              ; no, go handle generically
        BitsAt  %(n+5),4
        DoMovs  long,ecx,17
        Jump    CmdAt,%((n + 9) mod 8) ; go process next command
;
;       Length exception handling code goes here
;
        align4
tryGeneral:
        mov     cl,n+5                  ; CL == # of bits to eat to yield
        if      n NE 7
        jmp     LengthAbove32           ; gamma length with 5 leading zeros stripped
        else
;;        .errnz  $-GeneralLength         ; assert that we'll fall through
        endif
endm


DoGeneralLength macro
        local   try11,try13,try15,try17

        public  LengthAbove32,CopyString

GeneralLength:
        align4

LengthAbove32:
        shl     eax,16                  ;
        mov     ax,[esi]                ; get 16 more bits
        add     cl,16                   ;
        ror     eax,cl                  ; (eax) is filled, time to party
;
;   Figure out the length and do a string op
;
try11:
        shr     eax,1                   ; is it an 11-bit encoding?
        jnc     try13                   ; no
        and     eax,1Fh                 ; mask off the numeric value
        add     eax,33                  ;
        xchg    ecx,eax                 ; (ecx) now has string length
        sub     al,10                   ; record # extra bits in this length
;
;   At this point, (ecx) is the # of bytes to copy and (al) is the number of
;   additional bits to eat for the particular gamma length.
;
;   Good coding practices suggest that CopyString be at the end so that the
;   other gamma decoders need not jump backwards to it, but if we assume
;   that the longer strings are marginally less common, then it is marginally
;   better to fall through on this, the smallest of the general cases.
;
        align4

CopyString:
        DoMovs  long,ecx

        mov     dl,al                   ; (dl) == bit position in old ax
        cmp     dl,24                   ; is it the max?
        jb      @F                      ; no
        inc     esi                     ; yes, need to skip 1 more whole byte
        lodsw                           ; get new (ax) to restart state machine
        sub     dl,24                   ; (dl) == new state
        DecodeRestart

        align4
@@:
        cmp     dl,16                   ; did we exhaust the old ax?
        jae     @F                      ; yes
        dec     esi                     ; no,
        add     dl,8                    ;  but we know we exhausted the low byte
@@:
        lodsw                           ; get new (ax) to restart state machine
        sub     dl,16                   ; (dl) == new state
        DecodeRestart

        align4
try13:
        shr     eax,1                   ; is it an 13-bit encoding?
        jnc     try15                   ; no
        and     eax,3Fh                 ; mask off the numeric value
        add     eax,65                  ;
        xchg    ecx,eax                 ; (cx) now has string length
        sub     al,8                    ; record # extra bits in this length
        jmp     CopyString              ;

        align4
try15:
        shr     eax,1                   ; is it an 15-bit encoding?
        jnc     try17                   ; no
        and     eax,7Fh                 ; mask off the numeric value
        add     eax,129                 ;
        xchg    ecx,eax                 ; (ecx) now has string length
        sub     al,6                    ; record # extra bits in this length
        jmp     CopyString              ;

        align4
try17:
        shr     eax,1                   ; is it an 17-bit encoding?
;;        Debug_OutNC "MRCI32 Decompress32: invalid length"
        jnc     DecodeError             ; no, ERROR
        and     eax,0FFh                ; mask off the numeric value
        add     eax,257                 ;
        xchg    ecx,eax                 ; (ecx) now has string length
        sub     al,4                    ; record # extra bits in this length
        jmp     CopyString              ;
endm


;**     DoMovs - worker macro for LengthAt and DoGeneralLength
;
;       <size> is either "short" or "long";  if short, then we don't
;       bother trying to do a movsw/movsb combo (overhead swamps benefit);
;       if long, we do.
;
;       If <len> == 2, the offset to use is in (ecx).  (edx) is trashed.
;
;       Otherwise, the offset has been saved in (edx), and <len>
;       is the size of the string to move (normally ecx).  (ecx) and (edx)
;       are trashed.
;
;       <errjmp> is where to go if the expansion is going to overflow the
;       destination buffer.  DoMovs just passes this parameter along to the
;       CheckOffset macro.
;
DoMovs  macro   size,len,extra,errjmp
        local   slower

    ifidni <len>,<2>

        mov     edx,esi                 ; save (esi) in (edx)
        mov     esi,edi
        sub     esi,ecx
        CheckOffset 2,errjmp            ; check target offset
        movsb                           ; don't do movsw,
        movsb                           ; that doesn't handle overlap!
        mov     esi,edx                 ; restore (esi) from (edx)

    else

     ifnb <len>
      ifdifi <len>,<ecx>
       ifb <extra>
        mov     ecx,len
       else
        lea     ecx,[len+extra]
       endif
      else
       ifnb <extra>
        add     ecx,extra
       endif
      endif
     endif

        mov     ebx,esi                 ; save (esi) in (ebx)
        mov     esi,edi                 ;
        sub     esi,edx                 ; (esi) points to string to move
        CheckOffset ecx,errjmp          ; check target offset

      ifidni <size>,<short>
        rep     movsb
      elseifidni <size>,<long>
        cmp     edx,1                   ; if the offset is 1,
        je      short slower            ; then overlap forces us to do movsb
        shr     ecx,1
        rep     movsw
        adc     ecx,ecx
slower: rep     movsb
      else
        .err    <Bad DoMovs parameter: size>
      endif

        mov     esi,ebx                 ; restore (esi) from (ebx)

    endif
endm


;**     CheckOffset - Verify offsets in ESI and EDI are ok for len bytes
;
;       If "len" is blank, then CheckOffset simply does a 1-byte check.
;       In the event of an error in any case, it branches to DecodeError.
;
LastErrSJump    equ <DecodeError>
LastErrBJump    equ <DecodeError>


CheckOffset macro   len,errjmp
        local   tmp,jsjmp,jbjmp

IFDEF   MAXDEBUG
        cmp     edi,[maxOffset]
        jb      short tmp
        int 3
tmp:
ENDIF

    ifnb    <errjmp>
        ErrSJump    equ     <errjmp>
    else
        ErrSJump    catstr  LastErrSJump
        LastErrSJump equ    <jsjmp>
    endif

    ifb     <len>
        dec     ebp             ; space remaining in destination buffer?
    else
        sub     ebp,len         ; space remaining in destination buffer?
    endif

;;        Debug_OutS "MRCI32 Decompress32: target buffer overflow"

jsjmp:  js      ErrSJump

IFDEF   INLINE_LOWER_BOUND_CHECKING
;
;   In-line bounds checking is disabled in favor of an invalid page fault
;   handler.  To use this code, be aware that EBX cannot be used by the
;   decoding macros above (and it currently is!)
;
    ifnb    <len>
        ifnb    <errjmp>
            ErrBJump    equ     <errjmp>
        else
            ErrBJump    catstr  LastErrBJump
            LastErrBJump equ    <jbjmp>
        endif

        cmp     esi,ebx         ; have we ventured before start of dest. buffer?

;;        Debug_OutB "MRCI32 Decompress32: target buffer underflow"

jbjmp:  jb      ErrBJump
    endif

ENDIF   ;INLINE_LOWER_BOUND_CHECKING

endm


;*      Misc. macros

Jump    macro   lab,tag
        jmp     lab&tag
endm


XlatChr macro   ch
        ror     al,1
        xor     al,80h
endm


align4  macro
;
;   This actually slowed down the real-mode decompressor, so some
;   time will need to be spent verifying this is a real win... -JP
;
        align   4
endm


CheckBit macro  reg,bit
        if bit lt 8
                test    reg&l,(1 shl bit)
        else
                test    reg&h,(1 shl (bit-8))
        endif
endm


CopyBits macro  dst,src,n,cbits
        shld    dst,src,16-n
        and     e&dst,(1 shl cbits)-1
endm


;
;   AX has the remaining bits, DL has the next state
;
DecodeRestart macro

IFDEF   DEBUG
        cmp     dl,8
;;        Debug_OutAE "MRCI32 Decompress32: bad decode state in DL"
ENDIF
        movzx   edx,dl
        jmp     aCmdAt[edx*4]   ; go to correct state handler
endm


IFDEF   MAXDEBUG
        public  maxOffset
maxOffset       dd      -1      ; handy for getting control at a specific point
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\detmach.asm ===
SETUP equ 1

;**
;
; Machine-specific detection code
;
;--

.386p

include hal386.inc
include callconv.inc

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;
; Thunk functions.
; Equivalent Hal functions which various detection code may use
;

;++
;
; CMOS space read  functions.
;
;--

CMOSAddressPort equ     70H
CMOSDataPort    equ     71H

CMOSExAddressLSBPort    equ     74H
CMOSExAddressMSBPort    equ     75H
CMOSExDataPort          equ     76H

;++
;
;   VOID
;   ReadCMOS(
;       ULONG   StartingOffset
;       ULONG   Count
;       PUCHAR  ReturnValuePtr
;       )
;
;   Read CMOS starting at the given offset for the given number of
;   bytes putting the bytes read into the buffer pointed to by the
;   given address.
;
;   Arguments:
;
;       StartingOffset  : where to start in CMOS
;
;       Count           : how many bytes to read
;
;       ReturnValuePtr  : where to put bytes read
;
;   Returns:
;       None.
;
;--
StartingOffset  equ     2*4[ebp]
Count           equ     3*4[ebp]
ReturnValuePtr  equ     4*4[ebp]

cPublicProc _ReadCMOS,3

        push    ebp
        mov     ebp, esp
        push    ebx             ; caller's reg
        push    edi             ; caller's reg

        mov     ebx, StartingOffset
        mov     ecx, Count
        mov     edi, ReturnValuePtr

        align   dword
NextByte:
        cmp     bh, 0
        jne     ExCMOSRead

        mov     al, bl
        out     CMOSAddressPort, al
        in      al, CMOSDataPort
        mov     [edi], al

        add     ebx, 1
        add     edi, 1
        sub     ecx, 1
        jg      NextByte

        pop     edi             ; restore caller's reg
        pop     ebx             ; restore caller's reg
        pop     ebp
        stdRET  _ReadCmos

        align   dword
ExCMOSRead:

        mov     al, bl
        out     CMOSExAddressLSBPort, al
        mov     al, bh
        out     CMOSExAddressMSBPort, al
        in      al, CMOSExDataPort
        mov     [edi], al

        add     ebx, 1
        add     edi, 1
        sub     ecx, 1
        jg      ExCMOSRead

        pop     edi             ; restore caller's reg
        pop     ebx             ; restore caller's reg
        pop     ebp
        stdRET  _ReadCMOS

stdENDP _ReadCMOS


; 486 C step CPU detection code.

CR0_ET          equ     10h
CR0_TS          equ     08H
CR0_EM          equ     04H
CR0_MP          equ     02H

;
; The following equates define the control bits of EFALGS register
;

EFLAGS_AC       equ     40000h
EFLAGS_ID       equ     200000h

;
; Constants for Floating Point test
;

REALLONG_LOW          equ     00000000
REALLONG_HIGH         equ     3FE00000h
PSEUDO_DENORMAL_LOW   equ     00000000h
PSEUDO_DENORMAL_MID   equ     80000000h
PSEUDO_DENORMAL_HIGH  equ     0000h

;
; Define the iret frame
;

IretFrame       struc

IretEip        dd      0
IretCs         dd      0
IretEFlags     dd      0

IretFrame       ends

;++
;
; BOOLEAN
; Detect486CStep (
;    IN PBOOLEAN Dummy
;    )
;
; Routine Description:
;
;   Returns TRUE if the processor is a 486 C stepping.  We detect the CPU
;   in order to use a specific HAL.  This HAL attempts to work around
;   a 486 C stepping bug which the normal HAL tends to aggravate.
;

cPublicProc _Detect486CStep,1
        push    edi
        push    esi
        push    ebx                     ; Save C registers
        mov     eax, cr0
        push    eax
        pushfd                          ; save Cr0 & flags

        pop     ebx                     ; Get flags into eax
        push    ebx                     ; Save original flags

        mov     ecx, ebx
        xor     ecx, EFLAGS_AC          ; flip AC bit
        push    ecx
        popfd                           ; load it into flags
        pushfd                          ; re-save flags
        pop     ecx                     ; get flags into eax
        cmp     ebx, ecx                ; did bit stay flipped?
        je      short Not486C           ; No, then this is a 386

        mov     ecx, ebx
        xor     ecx, EFLAGS_ID          ; flip ID bit
        push    ecx
        popfd                           ; load it into flags
        pushfd                          ; re-save flags
        pop     ecx                     ; get flags into eax
        cmp     ebx, ecx                ; did bit stay flipped?
        jne     short Not486C           ; Yes, then this >= 586

        mov     eax, cr0
        and     eax, NOT (CR0_ET+CR0_MP+CR0_TS+CR0_EM)
        mov     cr0, eax

        call    IsNpxPresent            ; Check if cpu has coprocessor support?
        or      ax, ax
        jz      short Is486C            ; it is actually 486sx, assume C step

        call    Check486CStepping       ; Check for <= C stepping
        jnc     short Not486C           ; if nc, it is NOT a C stepping

Is486C:
        mov     eax, 1                  ; Return TRUE
        jmp     short DetectCpuExit

Not486C:
        xor     eax, eax

DetectCpuExit:
        popfd
        pop     ebx
        mov     cr0, ebx
        pop     ebx
        pop     esi
        pop     edi
        stdRET  _Detect486CStep

stdENDP _Detect486CStep

;++
;
; BOOLEAN
; Check486CStepping (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 486 C Stepping.
;
;    This routine takes advantage of the fact that FSCALE produces
;    wrong result with Denormal or Pseudo-denormal operand on 486
;    C and earlier steps.
;
;    If the value contained in ST(1), second location in the floating
;    point stack, is between 1 and 11, and the value in ST, top of the
;    floating point stack, is either a pseudo-denormal number or a
;    denormal number with the underflow exception unmasked, the FSCALE
;    instruction produces an incorrect result.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if D or later stepping.
;    Carry Flag set if C stepping.
;
;--

FpControl       equ     [ebp - 2]
RealLongSt1     equ     [ebp - 10]
PseudoDenormal  equ     [ebp - 20]
FscaleResult    equ     [ebp - 30]

        public  Check486CStepping
Check486CStepping       proc

        push    ebp
        mov     ebp, esp
        sub     esp, 30                 ; Allocate space for temp real variables

;
; Initialize the local FP variables to predefined values.
; RealLongSt1 = 1.0 * (2 ** -1) = 0.5 in normalized double precision FP form
; PseudoDenormal =  a unsupported format by IEEE.
;                   Sign bit = 0
;                   Exponent = 000000000000000B
;                   Significand = 100000...0B
; FscaleResult = The result of FSCALE instruction.  Depending on 486 step,
;                the value will be different:
;                Under C and earlier steps, 486 returns the original value
;                in ST as the result.  The correct returned value should be
;                original significand and an exponent of 0...01.
;

        mov     dword ptr RealLongSt1, REALLONG_LOW
        mov     dword ptr RealLongSt1 + 4, REALLONG_HIGH
        mov     dword ptr PseudoDenormal, PSEUDO_DENORMAL_LOW
        mov     dword ptr PseudoDenormal + 4, PSEUDO_DENORMAL_MID
        mov     word ptr PseudoDenormal + 8, PSEUDO_DENORMAL_HIGH

.387
        fnstcw  FpControl               ; Get FP control word
        or      word ptr FpControl, 0FFh ; Mask all the FP exceptions
        fldcw   FpControl               ; Set FP control

        fld     qword ptr RealLongSt1   ; 0 < ST(1) = RealLongSt1 < 1
        fld     tbyte ptr PseudoDenormal; Denormalized operand. Note, i486
                                        ; won't report denormal exception
                                        ; on 'FLD' instruction.
                                        ; ST(0) = Extended Denormalized operand
        fscale                          ; try to trigger 486Cx errata
        fstp    tbyte ptr FscaleResult  ; Store ST(0) in FscaleResult
        cmp     word ptr FscaleResult + 8, PSEUDO_DENORMAL_HIGH
                                        ; Is Exponent changed?
        jz      short c4ds00            ; if z, no, it is C step
        clc
        jmp     short c4ds10
c4ds00: stc
c4ds10: mov     esp, ebp
        pop     ebp
        ret

Check486CStepping       endp

;++
;
; BOOLEAN
; IsNpxPresent(
;     VOID
;     );
;
; Routine Description:
;
;     This routine determines if there is any Numeric coprocessor
;     present.
;
; Arguments:
;
;     None.
;
; Return:
;
;     TRUE - If NPX is present.  Else a value of FALSE is returned.
;
;--

        public  IsNpxPresent
IsNpxPresent   proc    near

        push    ebp                     ; Save caller's bp
        xor     edx, edx
.287
        fninit                          ; Initialize NPX
        mov     ecx, 5A5A5A5Ah          ; Put non-zero value
        push    ecx                     ;   into the memory we are going to use
        mov     ebp, esp
        fnstsw  word ptr [ebp]          ; Retrieve status - must use non-wait
        cmp     byte ptr [ebp], 0       ; All bits cleared by fninit?
        jne     Inp10

        mov     edx, 1

Inp10:
        pop     eax                     ; clear scratch value
        pop     ebp                     ; Restore caller's bp
        mov     eax, edx
        ret

IsNpxPresent   endp


_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\cpu386.asm ===
title  "Processor type and stepping detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    cpu.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to determine
;    cpu type and stepping information.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 28-Oct-1991.
;
; Environment:
;
;    80x86
;
; Revision History:
;
;--

.586p
        .xlist
include mac386.inc
include callconv.inc
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

CR0_AM          equ     40000h
EFLAGS_AC       equ     40000h

        subttl  "Is386"
;++
;
; BOOLEAN
; BlIs386(
;    VOID
;    )
;
; Routine Description:
;
;    This function determines whether the processor we're running on
;    is a 386. If not a 386, it is assumed that the processor is
;    a 486 or greater.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    (al) = 1 - processor is a 386
;    (al) = 0 - processor is a 486 or greater.
;
;--
        public  _BlIs386@0
_BlIs386@0 proc

        mov     eax,cr0
        push    eax                         ; save current cr0
        and     eax,not CR0_AM              ; mask out alignment check bit
        mov     cr0,eax                     ; disable alignment check
        pushfd                              ; save flags
        pushfd                              ; turn on alignment check bit in
        or      dword ptr [esp],EFLAGS_AC   ; a copy of the flags register
        popfd                               ; and try to load flags
        pushfd
        pop     ecx                         ; get new flags into ecx
        popfd                               ; restore original flags
        pop     eax                         ; restore original cr0
        mov     cr0,eax
        xor     al,al                       ; prepare for return, assume not 386
        and     ecx,EFLAGS_AC               ; did AC bit get set?
        jnz     short @f                    ; yes, we don't have a 386
        inc     al                          ; we have a 386
@@:     ret

_BlIs386@0 endp

        subttl  "IsCpuidPresent"
;++
;
; BOOLEAN
; BlIsCpuidPresent(
;     VOID
;     )
;
; Routine Description:
;
;    If bit 21 of the EFLAGS register is writable, CPUID is supported on
;    this processor.   If not writable, CPUID is not supported.  
;
;    Note: It is expected that this routine is "locked" onto a single
;    processor when run.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    TRUE  if CPUID is supported, 
;    FALSE otherwise.
;
;--

EFLAGS_ID   equ 200000h             ; bit 21


cPublicProc _BlIsCpuidPresent ,0
        pushfd                      ; save EFLAGS
        pop     ecx                 ; get current value
        xor     ecx, EFLAGS_ID      ; flip bit 21
        push    ecx                 ; set flipped value in EFLAGS
        popfd
        pushfd                      ; read it back again
        pop     eax
        xor     eax, ecx            ; if new value is what we set
        shr     eax, 21             ; then these two are the same
        and     eax, 1              ; isolate bit 21 (in bit 0)
        xor     eax, 1              ; and flip it

        stdRET _BlIsCpuidPresent

stdENDP _BlIsCpuidPresent


        page
        subttl  "GetFeatureBits"
;++
;
; VOID
; BlGetFeatureBits(
;     VOID
;     )
;
; Routine Description:
;
;    Execute the CPUID instruction to get the feature bits supported
;    by this processor.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Returns the set of feature bits supported by this processor or
;    0 if this processor does not support the CPUID instruction.
;
;--


cPublicProc _BlGetFeatureBits ,0
        stdCall _BlIsCpuidPresent   ; Does this processor do CPUID?
        test    eax, 1
        jnz     short @f            ; Jif yes.
        xor     eax, eax            ; No, return 0.
        stdRet  _BlGetFeatureBits

@@:     mov     eax, 1              ; CPUID function 1 gets feature bits.
        push    ebx                 ; save ebx
        cpuid                       ; execute 

        ;
        ; Due to a bug in NT 4, some processors report that they do
        ; not support cmpxchg8b even though they do.   Win2K doesn't
        ; care but cmpxchg8b is a requirement for Whistler. 
        ;
        ; Check to see if this is one of those processors and if we
        ; have been told by the processor manufacturer how to reenable
        ; cmpxchg8b, do so.
        ;

        test    edx, 0100h          ; is cmpxchg8b present?
        jnz     short gfb90         ; yes, skip

        ;
        ; cmpxchg8b not present, check for recognized processor
        ;

        push    eax                 ; save Family, Model, Stepping
        mov     eax, 0
        cpuid
        pop     eax
        
        cmp     ebx, 0746e6543h     ; Cyrix III = 'CentaurHauls'
        jnz     short gfb30
        cmp     edx, 048727561h
        jnz     short gfb80
        cmp     ecx, 0736c7561h
        jnz     short gfb80
        cmp     eax, 0600h          ; consider Cyrix III F/M/S 600 and above

        ;
        ; Cyrix (Centaur) Set MSR 1107h bit 1 to 1.
        ;

        mov     ecx, 01107h
        jae     gfb20
        cmp     eax, 0500h          ; consider IDT/Centaur F/M/S 500 and above
        jb      short gfb80

        ;
        ; Centaur family 5, set MSR 107h bit 1 to 1.
        ;

        mov     ecx, 0107h

gfb20:  rdmsr
        or      eax, 2
        wrmsr
        jmp     short gfb80


gfb30:  cmp     ebx, 0756e6547h     ; Transmeta = 'GenuineTMx86'
        jnz     short gfb80
        cmp     edx, 054656e69h
        jnz     short gfb80
        cmp     ecx, 03638784dh
        jnz     short gfb80
        cmp     eax, 0542h          ; consider Transmeta F/M/S 542 and above
        jb      short gfb80

        ;
        ; Transmeta MSR 80860004h is a mask applied to the feature bits.
        ;

        mov     ecx, 080860004h
        rdmsr
        or      eax, 0100h
        wrmsr


gfb80:  mov     eax, 1              ; reexecute CPUID function 1
        cpuid
gfb90:  mov     eax, edx            ; return feature bits 
        pop     ebx                 ; restore ebx, esi

        stdRET _BlGetFeatureBits

stdENDP _BlGetFeatureBits

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\displayp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    displayp.h

Abstract:

    Private header file for display routines.

Author:

    Ted Miller (tedm) 7-July-1995

Revision History:

--*/

//
// NOTICE
//
// Under no circumstances is anyone besides display.c to call these routines
// directly. This would break DBCS display for Far Eastern locales.
//

//
// Globals
//
extern USHORT TextColumn;
extern USHORT TextRow;
extern UCHAR TextCurrentAttribute;

//
// Vga text mode stuff
//
VOID
TextTmScrollDisplay(
    VOID
    );

VOID
TextTmClearDisplay(
    VOID
    );

VOID
TextTmClearToEndOfDisplay(
    VOID
    );

VOID
TextTmClearFromStartOfLine(
    VOID
    );

VOID
TextTmClearToEndOfLine(
    VOID
    );

VOID
TextTmFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    );

PUCHAR
TextTmCharOut(
    PUCHAR pc
    );

VOID
TextTmStringOut(
    IN PUCHAR String
    );

VOID
TextTmPositionCursor(
    USHORT Row,
    USHORT Column
    );

VOID
TextTmSetCurrentAttribute(
    IN UCHAR Attribute
    );

UCHAR
TextTmGetGraphicsChar(
    IN GraphicsChar WhichOne
    );

//
// Vga graphics mode stuff
//

VOID
TextGrScrollDisplay(
    VOID
    );

VOID
TextGrClearDisplay(
    VOID
    );

VOID
TextGrClearToEndOfDisplay(
    VOID
    );

VOID
TextGrClearFromStartOfLine(
    VOID
    );

VOID
TextGrClearToEndOfLine(
    VOID
    );

VOID
TextGrFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    );

PUCHAR
TextGrCharOut(
    PUCHAR pc
    );

VOID
TextGrStringOut(
    IN PUCHAR String
    );

VOID
TextGrPositionCursor(
    USHORT Row,
    USHORT Column
    );

VOID
TextGrSetCurrentAttribute(
    IN UCHAR Attribute
    );

UCHAR
TextGrGetGraphicsChar(
    IN GraphicsChar WhichOne
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\detsup.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    detsup.c

Abstract:

    Various detection code is included from the HALs and this module
    includes compatible functions for setup

Revision History:

--*/

#include "haldtect.h"
#define _NTHAL_
#define _HALI_

//
// Include NCR detection code
//

#define SETUP

//
// Include ACPI detection code
//

#include "halacpi\acpisetd.c"

//
// Include MPS 1.1 detection code
//

#include "halmps\i386\mpdetect.c"

//
// Thunk functions.
// Equivalent Hal functions which various detection code may use
//

PVOID
HalpMapPhysicalMemory64(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages
    )

/*++

Routine Description:

    This routine maps physical memory into the area of virtual memory.

Arguments:

    PhysicalAddress - Supplies the physical address of the start of the
                      area of physical memory to be mapped.

    NumberPages - Supplies the number of pages contained in the area of
                  physical memory to be mapped.

Return Value:

    PVOID - Virtual address at which the requested block of physical memory
            was mapped

--*/
{
    extern  PHARDWARE_PTE HalPT;
    ULONG   PageFrame;
    ULONG   i, j;

    PageFrame = (PhysicalAddress.LowPart) >> PAGE_SHIFT;
    if (PageFrame >= 1  &&  PageFrame+NumberPages < 0x1000) {
        //
        // The lower 16M is 'identity' mapped with the physical addresses.
        //

        return (PVOID)PhysicalAddress.LowPart;
    }

    //
    // Map a pointer to the address requested
    //

    for (i=0; i <= 1024-NumberPages; i++) {
        for (j=0; j < NumberPages; j++) {
            if ( ((PULONG)HalPT)[i+j] ) {
                break;
            }
        }

        if (j == NumberPages) {
            for (j=0; j<NumberPages; j++) {
                HalPT[i+j].PageFrameNumber = PageFrame+j;
                HalPT[i+j].Valid = 1;
                HalPT[i+j].Write = 1;
            }

            j = 0xffc00000 | (i<<12) | ((PhysicalAddress.LowPart) & 0xfff);
            return (PVOID) j;
        }
    }

    SlFatalError(PhysicalAddress.LowPart);
    return NULL;
}


PVOID
HalpMapPhysicalMemoryWriteThrough64(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages
    )

/*++

Routine Description:

    This routine maps physical memory into the area of virtual memory.

Arguments:

    PhysicalAddress - Supplies the physical address of the start of the
                      area of physical memory to be mapped.

    NumberPages - Supplies the number of pages contained in the area of
                  physical memory to be mapped.

Return Value:

    PVOID - Virtual address at which the requested block of physical memory
            was mapped

--*/
{
    extern  PHARDWARE_PTE HalPT;
    ULONG   PageFrame;
    ULONG   i, j;

    PageFrame = (PhysicalAddress.LowPart) >> PAGE_SHIFT;

    //
    // Map a pointer to the address requested
    //

    for (i=0; i <= 1024-NumberPages; i++) {
        for (j=0; j < NumberPages; j++) {
            if ( ((PULONG)HalPT)[i+j] ) {
                break;
            }
        }

        if (j == NumberPages) {
            for (j=0; j<NumberPages; j++) {
                HalPT[i+j].PageFrameNumber = PageFrame+j;
                HalPT[i+j].Valid = 1;
                HalPT[i+j].Write = 1;
                HalPT[i+j].WriteThrough = 1;
                HalPT[i+j].CacheDisable = 1;
            }

            j = 0xffc00000 | (i<<12) | ((PhysicalAddress.LowPart) & 0xfff);
            return (PVOID) j;
        }
    }

    SlFatalError(PhysicalAddress.LowPart);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\disp98.h ===
/*++

Copyright (c) 1995  Nec Software Ltd., Tokyo. Japan.

Module Name:

    disp98.h

Abstract:

    Private header file for display routines of PC98.

Author:

    Hideaki Shono 19-Sep-1995

Revision History:

--*/
//
// structures
//
static UCHAR EmulColor[8][8]={
                {0x01,0x21,0x81,0xA1,0x41,0x61,0xC1,0xE1}, //black
                {0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1}, //white character on black background
//                {0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5}, //blue
                {0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85}, //green
                {0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5}, //cyan
                {0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45}, //red
                {0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65}, //magenta
                {0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5}, //yellow
                {0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5}  //white
        };

//
// Code Page 932's code set to PC-98 VRAM code set. (graphics only)
//
static UCHAR Convert932GrphChrSet[0x20] =
        { 0x20, 0x98, 0x99, 0x9A, 0x9B, 0x96, 0x95, 0x0F,   // 0x00 - 0x07
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0x08 - 0x0F
          0x8F, 0x20, 0x20, 0x20, 0x87, 0x90, 0x91, 0x92,   // 0x10 - 0x17
          0x20, 0x93, 0x20, 0x20, 0x1E, 0x20, 0x1C, 0x1D }; // 0x18 - 0x1F

//
// From IBM ASCII char set (0xB0-0xDF) to NEC char set
//
static UCHAR ConvertToNECGrphChrSet[0x40] =
        { 0x8A, 0x8B, 0x8C, 0x96, 0x92, 0x92, 0x92, 0x99,   // 0xB0 - 0xB7
          0x99, 0x92, 0x96, 0x99, 0x9B, 0x9B, 0x9B, 0x99,   // 0xB8 - 0xBF
          0x9A, 0x90, 0x91, 0x93, 0x95, 0x8F, 0x93, 0x93,   // 0xC0 - 0xC7
          0x9A, 0x98, 0x90, 0x91, 0x93, 0x95, 0x8F, 0x90,   // 0xC8 - 0xCF
          0x90, 0x91, 0x91, 0x9A, 0x9A, 0x98, 0x98, 0x8F,   // 0xD0 - 0xD7
          0x8F, 0x9B, 0x98, 0x87, 0x83, 0x8A, 0x97, 0x94 }; // 0xD8 - 0xDF
//
// Code Page 437's code set to PC-98 VRAM code set.
//
/*
static UCHAR Convert437GrphChrSet[0x100] = {
          0x20, 0x20, 0x20, 0xE9, 0xEA, 0xEB, 0xE8, 0x20,   // 0x00 - 0x07
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0x08 - 0x0F
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0x10 - 0x17
          0x1E, 0x1F, 0x1C, 0x1D, 0x20, 0x20, 0x20, 0x20,   // 0x18 - 0x1F
          0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,   // 0x20 - 0x27
          0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,   // 0x28 - 0x2F
          0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,   // 0x30 - 0x37
          0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,   // 0x38 - 0x3F
          0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,   // 0x40 - 0x47
          0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,   // 0x48 - 0x4F
          0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,   // 0x50 - 0x57
          0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,   // 0x58 - 0x5F
          0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,   // 0x60 - 0x67
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,   // 0x68 - 0x6F
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,   // 0x70 - 0x77
          0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,   // 0x78 - 0x7F
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0x80 - 0x87
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0x88 - 0x8F
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0x90 - 0x97
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0x98 - 0x9F
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0xA0 - 0xA7
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0xA8 - 0xAF
          0x20, 0x20, 0x20, 0x96, 0x92, 0x92, 0x92, 0x99,   // 0xB0 - 0xB7
          0x99, 0x92, 0x96, 0x99, 0x9B, 0x9B, 0x9B, 0x99,   // 0xB8 - 0xBF
          0x9A, 0x90, 0x91, 0x93, 0x95, 0x8F, 0x93, 0x93,   // 0xC0 - 0xC7
          0x9A, 0x98, 0x90, 0x91, 0x93, 0x95, 0x8F, 0x90,   // 0xC8 - 0xCF
          0x90, 0x91, 0x91, 0x9A, 0x9A, 0x98, 0x98, 0x8F,   // 0xD0 - 0xD7
          0x8F, 0x9B, 0x98, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0xD8 - 0xDF
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0xE0 - 0xE7
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0xE8 - 0xEF
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 0xF0 - 0xF7
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20 }; // 0xF8 - 0xFF
*/

//
// define
//
#define ATTROFFSET98 0x2000
#define IsANK(c) (!((c >= (UCHAR)0x81 && c <= (UCHAR)0x9f) || (c >= (UCHAR)0xe0 && c <= (UCHAR)0xfe)))


//
// Globals
//
static BOOLEAN IsKanji2nd = FALSE;
static UCHAR   Kanji1st;

// extern BOOLEAN  bInGraphicsMode;
//
// These should be set by an call to a initialization routine.
//
USHORT  RowsPerScreen = 25;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\biosdrv.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    biosdrv.c

Abstract:

    Provides the ARC emulation routines for I/O to a device supported by
    real-mode INT 13h BIOS calls.

Author:

    John Vert (jvert) 7-Aug-1991

Revision History:

--*/

#include "arccodes.h"
#include "bootx86.h"

#include "stdlib.h"
#include "string.h"

#include "flop.h"


#if 0
#define DBGOUT(x)   BlPrint x
#define DBGPAUSE    while(!GET_KEY());
#else
#define DBGOUT(x)
#define DBGPAUSE
#endif

//
// Defines for buffer alignment and boundary checks in BiosDisk*
// functions.
//

#define BIOSDISK_1MB            (1 * 1024 * 1024)
#define BIOSDISK_64KB           (64 * 1024)
#define BIOSDISK_64KB_MASK      (~(BIOSDISK_64KB - 1))

//
// Definitions for caching the last read sector.
//

#define BL_LAST_SECTOR_CACHE_MAX_SIZE 4096

typedef struct _BL_LAST_SECTOR_CACHE
{
    BOOLEAN Initialized;
    BOOLEAN Valid;
    ULONG DeviceId;
    ULONGLONG SectorNumber;
    PUCHAR Data;
} BL_LAST_SECTOR_CACHE, *PBL_LAST_SECTOR_CACHE;

//
// This is the global variable used for caching the last sector read
// from the last disk. Callers who access files sequentially but do
// not make sure their offsets are sector aligned end up reading the
// last sector they read again with their next request. This solves
// the problem. Its Data buffer is allocated from the pool at the
// first disk read. It is setup and used in BiosDiskRead, invalidated
// in BiosDiskWrite.
//

BL_LAST_SECTOR_CACHE FwLastSectorCache = {0};

//
// defines for doing console I/O
//
#define CSI 0x95
#define SGR_INVERSE 7
#define SGR_NORMAL 0

//
// static data for console I/O
//
BOOLEAN ControlSequence=FALSE;
BOOLEAN EscapeSequence=FALSE;
BOOLEAN FontSelection=FALSE;
BOOLEAN HighIntensity=FALSE;
BOOLEAN Blink=FALSE;
ULONG PCount=0;

#define CONTROL_SEQUENCE_MAX_PARAMETER 10
ULONG Parameter[CONTROL_SEQUENCE_MAX_PARAMETER];

#define KEY_INPUT_BUFFER_SIZE 16
UCHAR KeyBuffer[KEY_INPUT_BUFFER_SIZE];
ULONG KeyBufferEnd=0;
ULONG KeyBufferStart=0;

//
// array for translating between ANSI colors and the VGA standard
//
UCHAR TranslateColor[] = {0,4,2,6,1,5,3,7};

ARC_STATUS
BiosDiskClose(
    IN ULONG FileId
    );

VOID
BiosConsoleFillBuffer(
    IN ULONG Key
    );


//
// There are two sorts of things we can open in this module, disk partitions,
// and raw disk devices.  The following device entry tables are
// used for these things.
//

BL_DEVICE_ENTRY_TABLE BiosPartitionEntryTable =
    {
        (PARC_CLOSE_ROUTINE)BiosPartitionClose,
        (PARC_MOUNT_ROUTINE)BlArcNotYetImplemented,
        (PARC_OPEN_ROUTINE)BiosPartitionOpen,
        (PARC_READ_ROUTINE)BiosPartitionRead,
        (PARC_READ_STATUS_ROUTINE)BlArcNotYetImplemented,
        (PARC_SEEK_ROUTINE)BiosPartitionSeek,
        (PARC_WRITE_ROUTINE)BiosPartitionWrite,
        (PARC_GET_FILE_INFO_ROUTINE)BiosPartitionGetFileInfo,
        (PARC_SET_FILE_INFO_ROUTINE)BlArcNotYetImplemented,
        (PRENAME_ROUTINE)BlArcNotYetImplemented,
        (PARC_GET_DIRECTORY_ENTRY_ROUTINE)BlArcNotYetImplemented,
        (PBOOTFS_INFO)NULL
    };

BL_DEVICE_ENTRY_TABLE BiosDiskEntryTable =
    {
        (PARC_CLOSE_ROUTINE)BiosDiskClose,
        (PARC_MOUNT_ROUTINE)BlArcNotYetImplemented,
        (PARC_OPEN_ROUTINE)BiosDiskOpen,
        (PARC_READ_ROUTINE)BiosDiskRead,
        (PARC_READ_STATUS_ROUTINE)BlArcNotYetImplemented,
        (PARC_SEEK_ROUTINE)BiosPartitionSeek,
        (PARC_WRITE_ROUTINE)BiosDiskWrite,
        (PARC_GET_FILE_INFO_ROUTINE)BiosDiskGetFileInfo,
        (PARC_SET_FILE_INFO_ROUTINE)BlArcNotYetImplemented,
        (PRENAME_ROUTINE)BlArcNotYetImplemented,
        (PARC_GET_DIRECTORY_ENTRY_ROUTINE)BlArcNotYetImplemented,
        (PBOOTFS_INFO)NULL
    };

BL_DEVICE_ENTRY_TABLE BiosEDDSEntryTable =
    {
        (PARC_CLOSE_ROUTINE)BiosDiskClose,
        (PARC_MOUNT_ROUTINE)BlArcNotYetImplemented,
        (PARC_OPEN_ROUTINE)BiosDiskOpen,
        (PARC_READ_ROUTINE)BiosElToritoDiskRead,
        (PARC_READ_STATUS_ROUTINE)BlArcNotYetImplemented,
        (PARC_SEEK_ROUTINE)BiosPartitionSeek,
        (PARC_WRITE_ROUTINE)BlArcNotYetImplemented,
        (PARC_GET_FILE_INFO_ROUTINE)BiosDiskGetFileInfo,
        (PARC_SET_FILE_INFO_ROUTINE)BlArcNotYetImplemented,
        (PRENAME_ROUTINE)BlArcNotYetImplemented,
        (PARC_GET_DIRECTORY_ENTRY_ROUTINE)BlArcNotYetImplemented,
        (PBOOTFS_INFO)NULL
    };


ARC_STATUS
BiosDiskClose(
    IN ULONG FileId
    )

/*++

Routine Description:

    Closes the specified device

Arguments:

    FileId - Supplies file id of the device to be closed

Return Value:

    ESUCCESS - Device closed successfully

    !ESUCCESS - Device was not closed.

--*/

{
    if (BlFileTable[FileId].Flags.Open == 0) {
#if DBG
        BlPrint("ERROR - Unopened fileid %lx closed\n",FileId);
#endif
    }
    BlFileTable[FileId].Flags.Open = 0;

    //
    // Invalidate the last read sector cache if it was for this disk.
    //
    if (FwLastSectorCache.DeviceId == FileId) {
        FwLastSectorCache.Valid = FALSE;
    }
    
    return(ESUCCESS);
}

ARC_STATUS
BiosPartitionClose(
    IN ULONG FileId
    )

/*++

Routine Description:

    Closes the specified device

Arguments:

    FileId - Supplies file id of the device to be closed

Return Value:

    ESUCCESS - Device closed successfully

    !ESUCCESS - Device was not closed.

--*/

{
    if (BlFileTable[FileId].Flags.Open == 0) {
#if DBG
        BlPrint("ERROR - Unopened fileid %lx closed\n",FileId);
#endif
    }
    BlFileTable[FileId].Flags.Open = 0;

    return(BiosDiskClose((ULONG)BlFileTable[FileId].u.PartitionContext.DiskId));
}


ARC_STATUS
BiosPartitionOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Opens the disk partition specified by OpenPath.  This routine will open
    floppy drives 0 and 1, and any partition on hard drive 0 or 1.

Arguments:

    OpenPath - Supplies a pointer to the name of the partition.  If OpenPath
               is "A:" or "B:" the corresponding floppy drive will be opened.
               If it is "C:" or above, this routine will find the corresponding
               partition on hard drive 0 or 1 and open it.

    OpenMode - Supplies the mode to open the file.
                0 - Read Only
                1 - Write Only
                2 - Read/Write

    FileId - Returns the file descriptor for use with the Close, Read, Write,
             and Seek routines

Return Value:

    ESUCCESS - File successfully opened.

--*/

{
    ARC_STATUS Status;
    ULONG DiskFileId;
    UCHAR PartitionNumber;
    ULONG Controller;
    ULONG Key;
    BOOLEAN IsEisa = FALSE;

    UNREFERENCED_PARAMETER( OpenMode );

    //
    // BIOS devices are always "multi(0)" (except for EISA flakiness
    // where we treat "eisa(0)..." like "multi(0)..." in floppy cases.
    //
    if(FwGetPathMnemonicKey(OpenPath,"multi",&Key)) {

        if(FwGetPathMnemonicKey(OpenPath,"eisa", &Key)) {
            return(EBADF);
        } else {
            IsEisa = TRUE;
        }
    }

    if (Key!=0) {
        return(EBADF);
    }

    //
    // If we're opening a floppy drive, there are no partitions
    // so we can just return the physical device.
    //

    if((_stricmp(OpenPath,"multi(0)disk(0)fdisk(0)partition(0)") == 0) ||
       (_stricmp(OpenPath,"eisa(0)disk(0)fdisk(0)partition(0)" ) == 0))
    {
        return(BiosDiskOpen( 0, 0, FileId));
    }
    if((_stricmp(OpenPath,"multi(0)disk(0)fdisk(1)partition(0)") == 0) ||
       (_stricmp(OpenPath,"eisa(0)disk(0)fdisk(1)partition(0)" ) == 0))
    {
        return(BiosDiskOpen( 1, 0, FileId));
    }

    if((_stricmp(OpenPath,"multi(0)disk(0)fdisk(0)") == 0) ||
       (_stricmp(OpenPath,"eisa(0)disk(0)fdisk(0)" ) == 0))
    {
        return(BiosDiskOpen( 0, 0, FileId));
    }
    if((_stricmp(OpenPath,"multi(0)disk(0)fdisk(1)") == 0) ||
       (_stricmp(OpenPath,"eisa(0)disk(0)fdisk(1)" ) == 0))
    {
        return(BiosDiskOpen( 1, 0, FileId));
    }

    //
    // We can't handle eisa(0) cases for hard disks.
    //
    if(IsEisa) {
        return(EBADF);
    }

    //
    // We can only deal with disk controller 0
    //

    if (FwGetPathMnemonicKey(OpenPath,"disk",&Controller)) {
        return(EBADF);
    }
    if ( Controller!=0 ) {
        return(EBADF);
    }

    if (!FwGetPathMnemonicKey(OpenPath,"cdrom",&Key)) {
        //
        // Now we have a CD-ROM disk number, so we open that for raw access.
        // Use a special bit to indicate CD-ROM, because otherwise
        // the BiosDiskOpen routine thinks a third or greater disk is
        // a CD-ROM.
        //
        return(BiosDiskOpen( Key | 0x80000000, 0, FileId ) );
    }

    if (FwGetPathMnemonicKey(OpenPath,"rdisk",&Key)) {
        return(EBADF);
    }

    //
    // Now we have a disk number, so we open that for raw access.
    // We need to add 0x80 to translate it to a BIOS number.
    //

    Status = BiosDiskOpen( 0x80 + Key,
                           0,
                           &DiskFileId );

    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // Find the partition number to open
    //

    if (FwGetPathMnemonicKey(OpenPath,"partition",&Key)) {
        BiosPartitionClose(DiskFileId);
        return(EBADF);
    }

    //
    // If the partition number was 0, then we are opening the device
    // for raw access, so we are already done.
    //
    if (Key == 0) {
        *FileId = DiskFileId;
        return(ESUCCESS);
    }

    //
    // Before we open the partition, we need to find an available
    // file descriptor.
    //

    *FileId=2;

    while (BlFileTable[*FileId].Flags.Open != 0) {
        *FileId += 1;
        if (*FileId == BL_FILE_TABLE_SIZE) {
            return(ENOENT);
        }
    }

    //
    // We found an entry we can use, so mark it as open.
    //
    BlFileTable[*FileId].Flags.Open = 1;

    BlFileTable[*FileId].DeviceEntryTable=&BiosPartitionEntryTable;


    //
    // Convert to zero-based partition number
    //
    PartitionNumber = (UCHAR)(Key - 1);
    
    //
    // Try to open the MBR partition
    //
    Status = HardDiskPartitionOpen( *FileId,
                                   DiskFileId,
                                   PartitionNumber);

#ifdef EFI_PARTITION_SUPPORT

    if (Status != ESUCCESS) {
        //
        // Try to open the GPT partition
        //
        Status = BlOpenGPTDiskPartition( *FileId,
                                       DiskFileId,
                                       PartitionNumber);
    }              

#endif    

    return Status;
}


ARC_STATUS
BiosPartitionRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Reads from the specified file

    NOTE John Vert (jvert) 18-Jun-1991
        This only supports block sector reads.  Thus, everything
        is assumed to start on a sector boundary, and every offset
        is considered an offset from the logical beginning of the disk
        partition.

Arguments:

    FileId - Supplies the file to read from

    Buffer - Supplies buffer to hold the data that is read

    Length - Supplies maximum number of bytes to read

    Count -  Returns actual bytes read.

Return Value:

    ESUCCESS - Read completed successfully

    !ESUCCESS - Read failed.

--*/

{
    ARC_STATUS Status;
    LARGE_INTEGER PhysicalOffset;
    ULONG DiskId;
    PhysicalOffset.QuadPart = BlFileTable[FileId].Position.QuadPart +
                            SECTOR_SIZE * (LONGLONG)BlFileTable[FileId].u.PartitionContext.StartingSector;

    DiskId = BlFileTable[FileId].u.PartitionContext.DiskId;

    Status = (BlFileTable[DiskId].DeviceEntryTable->Seek)(DiskId,
                                                          &PhysicalOffset,
                                                          SeekAbsolute );

    if (Status != ESUCCESS) {
        return(Status);
    }

    Status = (BlFileTable[DiskId].DeviceEntryTable->Read)(DiskId,
                                                          Buffer,
                                                          Length,
                                                          Count );

    BlFileTable[FileId].Position.QuadPart += *Count;

    return(Status);
}



ARC_STATUS
BiosPartitionSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    Changes the current offset of the file specified by FileId

Arguments:

    FileId - specifies the file on which the current offset is to
             be changed.

    Offset - New offset into file.

    SeekMode - Either SeekAbsolute or SeekRelative
               SeekEndRelative is not supported

Return Value:

    ESUCCESS - Operation completed succesfully

    EBADF - Operation did not complete successfully.

--*/

{
    switch (SeekMode) {
        case SeekAbsolute:
            BlFileTable[FileId].Position = *Offset;
            break;
        case SeekRelative:
            BlFileTable[FileId].Position.QuadPart += Offset->QuadPart;
            break;
        default:
#if DBG
            BlPrint("SeekMode %lx not supported\n",SeekMode);
#endif
            return(EACCES);

    }
    return(ESUCCESS);

}



ARC_STATUS
BiosPartitionWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Writes to the specified file

    NOTE John Vert (jvert) 18-Jun-1991
        This only supports block sector reads.  Thus, everything
        is assumed to start on a sector boundary, and every offset
        is considered an offset from the logical beginning of the disk
        partition.

Arguments:

    FileId - Supplies the file to write to

    Buffer - Supplies buffer with data to write

    Length - Supplies number of bytes to write

    Count -  Returns actual bytes written.

Return Value:

    ESUCCESS - write completed successfully

    !ESUCCESS - write failed.

--*/

{
    ARC_STATUS Status;
    LARGE_INTEGER PhysicalOffset;
    ULONG DiskId;
    PhysicalOffset.QuadPart = BlFileTable[FileId].Position.QuadPart +
                              SECTOR_SIZE * (LONGLONG)BlFileTable[FileId].u.PartitionContext.StartingSector;

    DiskId = BlFileTable[FileId].u.PartitionContext.DiskId;

    Status = (BlFileTable[DiskId].DeviceEntryTable->Seek)(DiskId,
                                                          &PhysicalOffset,
                                                          SeekAbsolute );

    if (Status != ESUCCESS) {
        return(Status);
    }

    Status = (BlFileTable[DiskId].DeviceEntryTable->Write)(DiskId,
                                                           Buffer,
                                                           Length,
                                                           Count );

    if(Status == ESUCCESS) {
        BlFileTable[FileId].Position.QuadPart += *Count;
    }

    return(Status);
}



ARC_STATUS
BiosConsoleOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Attempts to open either the console input or output

Arguments:

    OpenPath - Supplies a pointer to the name of the device to open.  If
               this is either CONSOLE_INPUT_NAME or CONSOLE_OUTPUT_NAME,
               a file descriptor is allocated and filled in.

    OpenMode - Supplies the mode to open the file.
                0 - Read Only (CONSOLE_INPUT_NAME)
                1 - Write Only (CONSOLE_OUTPUT_NAME)

    FileId - Returns the file descriptor for use with the Close, Read and
             Write routines

Return Value:

    ESUCCESS - Console successfully opened.

--*/

{
    if (_stricmp(OpenPath, CONSOLE_INPUT_NAME)==0) {

        //
        // Open the keyboard for input
        //

        if (OpenMode != ArcOpenReadOnly) {
            return(EACCES);
        }

        *FileId = 0;

        return(ESUCCESS);
    }

    if (_stricmp(OpenPath, CONSOLE_OUTPUT_NAME)==0) {

        //
        // Open the display for output
        //

        if (OpenMode != ArcOpenWriteOnly) {
            return(EACCES);
        }
        *FileId = 1;

        return(ESUCCESS);
    }

    return(ENOENT);

}

ARC_STATUS
BiosConsoleReadStatus(
    IN ULONG FileId
    )

/*++

Routine Description:

    This routine determines if there is a keypress pending

Arguments:

    FileId - Supplies the FileId to be read.  (should always be 0 for this
            function)

Return Value:

    ESUCCESS - There is a key pending

    EAGAIN - There is not a key pending

--*/

{
    ULONG Key;

    // 
    // enforce file id to be 0 by no reading console otherwise
    //
    if (FileId != 0) {
        return EINVAL;
    }

    //
    // If we have buffered input...
    //
    if (KeyBufferEnd != KeyBufferStart) {
        return(ESUCCESS);
    }

    //
    // Check for a key
    //
    Key = GET_KEY();
    if (Key != 0) {
        //
        // We got a key, so we have to stick it back into our buffer
        // and return ESUCCESS.
        //
        BiosConsoleFillBuffer(Key);
        return(ESUCCESS);

    } else {
        //
        // no key pending
        //
        return(EAGAIN);
    }

}

ARC_STATUS
BiosConsoleRead(
    IN ULONG FileId,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Gets input from the keyboard.

Arguments:

    FileId - Supplies the FileId to be read (should always be 0 for this
             function)

    Buffer - Returns the keyboard input.

    Length - Supplies the length of the buffer (in bytes)

    Count  - Returns the actual number of bytes read

Return Value:

    ESUCCESS - Keyboard read completed succesfully.

--*/

{
    ULONG Key;

    // 
    // enforce file id to be 0 by no reading console otherwise
    //
    if (FileId != 0) {
        return EINVAL;
    }

    *Count = 0;

    while (*Count < Length) {
        if (KeyBufferEnd == KeyBufferStart) { // then buffer is presently empty
            do {

                //
                // Poll the keyboard until input is available
                //

                Key = GET_KEY();
            } while ( Key==0 );

            BiosConsoleFillBuffer(Key);
        }

        Buffer[*Count] = KeyBuffer[KeyBufferStart];
        KeyBufferStart = (KeyBufferStart+1) % KEY_INPUT_BUFFER_SIZE;

        *Count = *Count + 1;
    }
    return(ESUCCESS);
}



VOID
BiosConsoleFillBuffer(
    IN ULONG Key
    )

/*++

Routine Description:

    Places input from the keyboard into the keyboard buffer, expanding the
    special keys as appropriate.
    
    All keys translated here use the ARC translation table, as defined in the 
    ARC specification, with one exception -- the BACKTAB_KEY, for which the
    ARC spec is lacking.  I have decided that BACKTAB_KEY is ESC+TAB.

Arguments:

    Key - Raw keypress value as returned by GET_KEY().

Return Value:

    none.

--*/

{
    switch(Key) {
        case UP_ARROW:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'A';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case DOWN_ARROW:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'B';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case RIGHT_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'C';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case LEFT_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'D';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case INS_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = '@';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case DEL_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'P';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F1_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'P';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F2_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'Q';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F3_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'w';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;
            
        case F4_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'x';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;
            
        case F5_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 't';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F6_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'u';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F7_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'q';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F8_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'r';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F10_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'M';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;
        
        case F11_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'A';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F12_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'B';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case HOME_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'H';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case END_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'K';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case ESCAPE_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case BACKTAB_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = (UCHAR)(TAB_KEY & 0xFF);
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        default:
            //
            // The ASCII code is the low byte of Key
            //
            KeyBuffer[KeyBufferEnd] = (UCHAR)(Key & 0xff);
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
    }
}



ARC_STATUS
BiosConsoleWrite(
    IN ULONG FileId,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Outputs to the console.  (In this case, the VGA display)

Arguments:

    FileId - Supplies the FileId to be written (should always be 1 for this
             function)

    Buffer - Supplies characters to be output

    Length - Supplies the length of the buffer (in bytes)

    Count  - Returns the actual number of bytes written

Return Value:

    ESUCCESS - Console write completed succesfully.

--*/
{
    ARC_STATUS Status;
    PUCHAR String;
    ULONG Index;
    UCHAR a;
    PUCHAR p;

    // 
    // enforce file id to be 0 by no reading console otherwise
    //
    if (FileId != 1) {
        return EINVAL;
    }
    
    //
    // Process each character in turn.
    //

    Status = ESUCCESS;
    String = (PUCHAR)Buffer;

    for ( *Count = 0 ;
          *Count < Length ;
          (*Count)++, String++ ) {

        //
        // If we're in the middle of a control sequence, continue scanning,
        // otherwise process character.
        //

        if (ControlSequence) {

            //
            // If the character is a digit, update parameter value.
            //

            if ((*String >= '0') && (*String <= '9')) {
                Parameter[PCount] = Parameter[PCount] * 10 + *String - '0';
                continue;
            }

            //
            // If we are in the middle of a font selection sequence, this
            // character must be a 'D', otherwise reset control sequence.
            //

            if (FontSelection) {

                //if (*String == 'D') {
                //
                //    //
                //    // Other fonts not implemented yet.
                //    //
                //
                //} else {
                //}

                ControlSequence = FALSE;
                FontSelection = FALSE;
                continue;
            }

            switch (*String) {

            //
            // If a semicolon, move to the next parameter.
            //

            case ';':

                PCount++;
                if (PCount > CONTROL_SEQUENCE_MAX_PARAMETER) {
                    PCount = CONTROL_SEQUENCE_MAX_PARAMETER;
                }
                Parameter[PCount] = 0;
                break;

            //
            // If a 'J', erase part or all of the screen.
            //

            case 'J':

                switch (Parameter[0]) {
                    case 0:
                        //
                        // Erase to end of the screen
                        //
                        TextClearToEndOfDisplay();
                        break;

                    case 1:
                        //
                        // Erase from the beginning of the screen
                        //
                        break;

                    default:
                        //
                        // Erase entire screen
                        //
                        TextClearDisplay();
                        break;
                }

                ControlSequence = FALSE;
                break;

            //
            // If a 'K', erase part or all of the line.
            //

            case 'K':

                switch (Parameter[0]) {

                //
                // Erase to end of the line.
                //

                    case 0:
                        TextClearToEndOfLine();
                        break;

                    //
                    // Erase from the beginning of the line.
                    //

                    case 1:
                        TextClearFromStartOfLine();
                        break;

                    //
                    // Erase entire line.
                    //

                    default :
                        TextClearFromStartOfLine();
                        TextClearToEndOfLine();
                        break;
                }

                ControlSequence = FALSE;
                break;

            //
            // If a 'H', move cursor to position.
            //

            case 'H':
                TextSetCursorPosition(Parameter[1]-1, Parameter[0]-1);
                ControlSequence = FALSE;
                break;

            //
            // If a ' ', could be a FNT selection command.
            //

            case ' ':
                FontSelection = TRUE;
                break;

            case 'm':
                //
                // Select action based on each parameter.
                //
                // Blink and HighIntensity are by default disabled
                // each time a new SGR is specified, unless they are
                // explicitly specified again, in which case these
                // will be set to TRUE at that time.
                //

                HighIntensity = FALSE;
                Blink = FALSE;

                for ( Index = 0 ; Index <= PCount ; Index++ ) {
                    switch (Parameter[Index]) {

                    //
                    // Attributes off.
                    //

                    case 0:
                        TextSetCurrentAttribute(7);
                        HighIntensity = FALSE;
                        Blink = FALSE;
                        break;

                    //
                    // High Intensity.
                    //

                    case 1:
                        TextSetCurrentAttribute(0xf);
                        HighIntensity = TRUE;
                        break;

                    //
                    // Underscored.
                    //

                    case 4:
                        break;

                    //
                    // Blink.
                    //

                    case 5:
                        TextSetCurrentAttribute(0x87);
                        Blink = TRUE;
                        break;

                    //
                    // Reverse Video.
                    //

                    case 7:
                        TextSetCurrentAttribute(0x70);
                        HighIntensity = FALSE;
                        Blink = FALSE;
                        break;

                    //
                    // Font selection, not implemented yet.
                    //

                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                        break;

                    //
                    // Foreground Color
                    //

                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                        a = TextGetCurrentAttribute();
                        a &= 0x70;
                        a |= TranslateColor[Parameter[Index]-30];
                        if (HighIntensity) {
                            a |= 0x08;
                        }
                        if (Blink) {
                            a |= 0x80;
                        }
                        TextSetCurrentAttribute(a);
                        break;

                    //
                    // Background Color
                    //

                    case 40:
                    case 41:
                    case 42:
                    case 43:
                    case 44:
                    case 45:
                    case 46:
                    case 47:
                        a = TextGetCurrentAttribute();
                        a &= 0x8f;
                        a |= TranslateColor[Parameter[Index]-40] << 4;
                        TextSetCurrentAttribute(a);
                        break;

                    default:
                        break;
                    }
                }

            default:
                ControlSequence = FALSE;
                break;
            }

        //
        // This is not a control sequence, check for escape sequence.
        //

        } else {

            //
            // If escape sequence, check for control sequence, otherwise
            // process single character.
            //

            if (EscapeSequence) {

                //
                // Check for '[', means control sequence, any other following
                // character is ignored.
                //

                if (*String == '[') {

                    ControlSequence = TRUE;

                    //
                    // Initialize first parameter.
                    //

                    PCount = 0;
                    Parameter[0] = 0;
                }
                EscapeSequence = FALSE;

            //
            // This is not a control or escape sequence, process single character.
            //

            } else {

                switch (*String) {
                    //
                    // Check for escape sequence.
                    //

                    case ASCI_ESC:
                        EscapeSequence = TRUE;
                        break;

                    default:
                        p = TextCharOut(String);
                        //
                        // Each pass through the loop increments String by 1.
                        // If we output a dbcs char we need to increment by
                        // one more.
                        //
                        (*Count) += (p - String) - 1;
                        String += (p - String) - 1;
                        break;
                }

            }
        }
    }
    return Status;
}


ARC_STATUS
BiosDiskOpen(
    IN ULONG DriveId,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Opens a BIOS-accessible disk for raw sector access.

Arguments:

    DriveId - Supplies the BIOS DriveId of the drive to open
              0 - Floppy 0
              1 - Floppy 1
              0x80 - Hard Drive 0
              0x81 - Hard Drive 1
              0x82 - Hard Drive 2
              etc

              High bit set and ID > 0x81 means the device is expected to be
              a CD-ROM drive.

    OpenMode - Supplies the mode of the open

    FileId - Supplies a pointer to a variable that specifies the file
             table entry that is filled in if the open is successful.

Return Value:

    ESUCCESS is returned if the open operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    USHORT NumberHeads;
    UCHAR NumberSectors;
    USHORT NumberCylinders;
    UCHAR NumberDrives;
    ULONG Result;
    PDRIVE_CONTEXT Context;
    BOOLEAN IsCd;
    UCHAR *Buffer = FwDiskCache;
    ULONG BufferSize = 512; // sector size
    BOOLEAN xInt13;

    UNREFERENCED_PARAMETER( OpenMode );

    DBGOUT(("BiosDiskOpen: enter, id = 0x%lx\r\n",DriveId));
      
    //
    // Check special drive number encoding for CD-ROM case
    //
    if(DriveId > 0x80000081) {
        IsCd = TRUE;
        DriveId &= 0x7fffffff;
    } else {
        IsCd = FALSE;
    }

    xInt13 = FALSE;

    //
    // If we are opening Floppy 0 or Floppy 1, we want to read the BPB off
    // the disk so we can deal with all the odd disk formats.
    //
    // If we are opening a hard drive, we can just call the BIOS to find out
    // its characteristics
    //
    if(DriveId < 128) {
        PPACKED_BOOT_SECTOR BootSector;
        BIOS_PARAMETER_BLOCK Bpb;

        //
        // Read the boot sector off the floppy and extract the cylinder,
        // sector, and head information. We fake the CHS values here
        // to allow sector 0 to be read before we actually know the
        // geometry we want to use.
        //
        if(ReadPhysicalSectors((UCHAR)DriveId,0,1,Buffer,1,1,1,FALSE)) {
            DBGOUT(("BiosDiskOpen: error reading from floppy drive\r\n"));
            DBGPAUSE
            return(EIO);
        }
        BootSector = (PPACKED_BOOT_SECTOR)Buffer;

        FatUnpackBios(&Bpb, &(BootSector->PackedBpb));

        NumberHeads = Bpb.Heads;
        NumberSectors = (UCHAR)Bpb.SectorsPerTrack;

        if (Bpb.Sectors != 0) {
            NumberCylinders = Bpb.Sectors / (NumberSectors * NumberHeads);
        }
        else {
            ULONG Cylinders = Bpb.LargeSectors / (NumberSectors * NumberHeads);

            //
            // LargeSectors has size of ULONG.
            // so truncate size at MAX(USHORT) and check for xint13 
            // so it can be used for the higher sectors
            //
            NumberCylinders = ( Cylinders > (USHORT)-1 ) ? (USHORT) -1 :
                                                           (USHORT) Cylinders;

            //
            // Attempt to get extended int13 parameters.
            // Note that we use a buffer that's on the stack, so it's guaranteed
            // to be under the 1 MB line (required when passing buffers to real-mode
            // services).
            //
            // Note that we don't actually care about the parameters, just whether
            // extended int13 services are available.
            //
            RtlZeroMemory(Buffer,BufferSize);
            xInt13 = GET_XINT13_PARAMS(Buffer,(UCHAR)DriveId);
        
        }
    } else if(IsCd) {
        //
        // This is an El Torito drive
        // Just use bogus values since CHS values are meaningless for no-emulation El Torito boot
        //
        NumberCylinders = 1;
        NumberHeads =  1;
        NumberSectors = 1;

    } else {
        
        //
        // Get Drive Parameters via int13 function 8
        // Return of 0 means success; otherwise we get back what the BIOS
        // returned in ax.
        //

        ULONG Retries = 0;

        do {            
            if(BIOS_IO(0x08,(UCHAR)DriveId,0,0,0,0,0)) {
                DBGOUT(("BiosDiskOpen: error getting params for drive\r\n"));
                DBGPAUSE
                return(EIO);
            }

            //
            // At this point, ECX looks like this:
            //
            //    bits 31..22  - Maximum cylinder
            //    bits 21..16  - Maximum sector
            //    bits 15..8   - Maximum head
            //    bits 7..0    - Number of drives
            //
            // Unpack the information from ecx.
            //
            _asm {
                mov Result, ecx
            }

            NumberDrives = (UCHAR)Result;
            NumberHeads = (((USHORT)Result >> 8) & 0xff) + 1;
            NumberSectors = (UCHAR)((Result >> 16) & 0x3f);
            NumberCylinders = (USHORT)(((Result >> 24) + ((Result >> 14) & 0x300)) + 1);
            ++Retries;
        } while ( ((NumberHeads==0) || (NumberSectors==0) || (NumberCylinders==0))
               && (Retries < 5) );

        DBGOUT((
            "BiosDiskOpen: cyl=%u, heads=%u, sect=%u, drives=%u\r\n",
            NumberCylinders,
            NumberHeads,
            NumberSectors,
            NumberDrives
            ));

        if(((UCHAR)DriveId & 0x7f) >= NumberDrives) {
            //
            // The requested drive does not exist
            //
            DBGOUT(("BiosDiskOpen: invalid drive\r\n"));
            DBGPAUSE
            return(EIO);
        }

        if (Retries == 5) {
            DBGOUT(("Couldn't get BIOS configuration info\n"));
            DBGPAUSE
            return(EIO);
        }

        //
        // Attempt to get extended int13 parameters.
        // Note that we use a buffer that's on the stack, so it's guaranteed
        // to be under the 1 MB line (required when passing buffers to real-mode
        // services).
        //
        // Note that we don't actually care about the parameters, just whether
        // extended int13 services are available.
        //
        RtlZeroMemory(Buffer,BufferSize);
        xInt13 = GET_XINT13_PARAMS(Buffer,(UCHAR)DriveId);

        DBGOUT(("BiosDiskOpen: xint13 for drive: %s\r\n",xInt13 ? "yes" : "no"));
    }

    //
    // Find an available FileId descriptor to open the device with
    //
    *FileId=2;

    while (BlFileTable[*FileId].Flags.Open != 0) {
        *FileId += 1;
        if(*FileId == BL_FILE_TABLE_SIZE) {
            DBGOUT(("BiosDiskOpen: no file table entry available\r\n"));
            DBGPAUSE
            return(ENOENT);
        }
    }

    //
    // We found an entry we can use, so mark it as open.
    //
    BlFileTable[*FileId].Flags.Open = 1;

    BlFileTable[*FileId].DeviceEntryTable = IsCd
                                          ? &BiosEDDSEntryTable
                                          : &BiosDiskEntryTable;

    Context = &(BlFileTable[*FileId].u.DriveContext);

    Context->IsCd = IsCd;
    Context->Drive = (UCHAR)DriveId;
    Context->Cylinders = NumberCylinders;
    Context->Heads = NumberHeads;
    Context->Sectors = NumberSectors;
    Context->xInt13 = xInt13;

    DBGOUT(("BiosDiskOpen: exit success\r\n"));

    return(ESUCCESS);
}


ARC_STATUS
BiospWritePartialSector(
    IN UCHAR Int13Unit,
    IN ULONGLONG Sector,
    IN PUCHAR Buffer,
    IN BOOLEAN IsHead,
    IN ULONG Bytes,
    IN UCHAR SectorsPerTrack,
    IN USHORT Heads,
    IN USHORT Cylinders,
    IN BOOLEAN AllowXInt13
    )
{
    ARC_STATUS Status;

    //
    // Read sector into the write buffer
    //
    Status = ReadPhysicalSectors(
                Int13Unit,
                Sector,
                1,
                FwDiskCache,
                SectorsPerTrack,
                Heads,
                Cylinders,
                AllowXInt13
                );

    if(Status != ESUCCESS) {
        return(Status);
    }

    //
    // Transfer the appropriate bytes from the user buffer to the write buffer
    //
    RtlMoveMemory(
        IsHead ? (FwDiskCache + Bytes) : FwDiskCache,
        Buffer,
        IsHead ? (SECTOR_SIZE - Bytes) : Bytes
        );

    //
    // Write the sector out
    //
    Status = WritePhysicalSectors(
                Int13Unit,
                Sector,
                1,
                FwDiskCache,
                SectorsPerTrack,
                Heads,
                Cylinders,
                AllowXInt13
                );

    return(Status);
}


ARC_STATUS
BiosDiskWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Writes sectors directly to an open physical disk.

Arguments:

    FileId - Supplies the file to write to

    Buffer - Supplies buffer with data to write

    Length - Supplies number of bytes to write

    Count - Returns actual bytes written

Return Value:

    ESUCCESS - write completed successfully

    !ESUCCESS - write failed

--*/

{
    ULONGLONG HeadSector,TailSector,CurrentSector;
    UCHAR Int13Unit;
    ULONG HeadOffset,TailByteCount;
    UCHAR SectorsPerTrack;
    USHORT Heads,Cylinders;
    BOOLEAN AllowXInt13;
    ARC_STATUS Status;
    ULONG BytesLeftToTransfer;
    UCHAR SectorsToTransfer;
    BOOLEAN Under1MegLine;
    PVOID TransferBuffer;
    PUCHAR UserBuffer;
    ULONG         PhysicalSectors;

    BytesLeftToTransfer = Length;
    PhysicalSectors = SECTOR_SIZE;

    HeadSector = BlFileTable[FileId].Position.QuadPart / PhysicalSectors;
    HeadOffset = (ULONG)(BlFileTable[FileId].Position.QuadPart % PhysicalSectors);

    TailSector = (BlFileTable[FileId].Position.QuadPart + Length) / PhysicalSectors;
    TailByteCount = (ULONG)((BlFileTable[FileId].Position.QuadPart + Length) % PhysicalSectors);

    Int13Unit = BlFileTable[FileId].u.DriveContext.Drive;
    SectorsPerTrack = BlFileTable[FileId].u.DriveContext.Sectors;
    Heads = BlFileTable[FileId].u.DriveContext.Heads;
    Cylinders = BlFileTable[FileId].u.DriveContext.Cylinders;
    AllowXInt13 = BlFileTable[FileId].u.DriveContext.xInt13;

    UserBuffer = Buffer;

    //
    // If this write will even partially write over the sector cached
    // in the last read sector cache, invalidate the cache.
    //

    if (FwLastSectorCache.Initialized &&
        FwLastSectorCache.Valid &&
        (FwLastSectorCache.SectorNumber >= HeadSector) && 
        (FwLastSectorCache.SectorNumber <= TailSector)) {
        
        FwLastSectorCache.Valid = FALSE;
    }

    //
    // Special case of transfer occuring entirely within one sector
    //
    CurrentSector = HeadSector;
    if(HeadOffset && TailByteCount && (HeadSector == TailSector)) {

        Status = ReadPhysicalSectors(
                    Int13Unit,
                    CurrentSector,
                    1,
                    FwDiskCache,
                    SectorsPerTrack,
                    Heads,
                    Cylinders,
                    AllowXInt13
                    );

        if(Status != ESUCCESS) {
            goto BiosDiskWriteDone;
        }

        RtlMoveMemory(FwDiskCache+HeadOffset,Buffer,Length);

        Status = WritePhysicalSectors(
                    Int13Unit,
                    CurrentSector,
                    1,
                    FwDiskCache,
                    SectorsPerTrack,
                    Heads,
                    Cylinders,
                    AllowXInt13
                    );

        if(Status != ESUCCESS) {
            goto BiosDiskWriteDone;
        }

        BytesLeftToTransfer = 0;
        goto BiosDiskWriteDone;
    }

    if(HeadOffset) {

        Status = BiospWritePartialSector(
                    Int13Unit,
                    HeadSector,
                    Buffer,
                    TRUE,
                    HeadOffset,
                    SectorsPerTrack,
                    Heads,
                    Cylinders,
                    AllowXInt13
                    );

        if(Status != ESUCCESS) {
            return(Status);
        }

        BytesLeftToTransfer -= PhysicalSectors - HeadOffset;
        UserBuffer += PhysicalSectors - HeadOffset;
        CurrentSector += 1;
    }

    if(TailByteCount) {

        Status = BiospWritePartialSector(
                    Int13Unit,
                    TailSector,
                    (PUCHAR)Buffer + Length - TailByteCount,
                    FALSE,
                    TailByteCount,
                    SectorsPerTrack,
                    Heads,
                    Cylinders,
                    AllowXInt13
                    );

        if(Status != ESUCCESS) {
            return(Status);
        }

        BytesLeftToTransfer -= TailByteCount;
    }

    //
    // The following calculation is not inside the transfer loop because
    // it is unlikely that a caller's buffer will *cross* the 1 meg line
    // due to the PC memory map.
    //
    if((ULONG)UserBuffer + BytesLeftToTransfer <= 0x100000) {
        Under1MegLine = TRUE;
    } else {
        Under1MegLine = FALSE;
    }

    //
    // Now handle the middle part.  This is some number of whole sectors.
    //
    while(BytesLeftToTransfer) {

        //
        // The number of sectors to transfer is the minimum of:
        // - the number of sectors left in the current track
        // - BytesLeftToTransfer / SECTOR_SIZE
        //
        // Because sectors per track is 1-63 we know this will fit in a UCHAR
        //
        SectorsToTransfer = (UCHAR)min(
                                    SectorsPerTrack - (CurrentSector % SectorsPerTrack),
                                    BytesLeftToTransfer / PhysicalSectors
                                    );

        //
        // Now we'll figure out where to transfer the data from.  If the
        // caller's buffer is under the 1 meg line, we can transfer the
        // data directly from the caller's buffer.  Otherwise we'll copy the
        // user's buffer to our local buffer and transfer from there.
        // In the latter case we can only transfer in chunks of
        // SCRATCH_BUFFER_SIZE because that's the size of the local buffer.
        //
        // Also make sure the transfer won't cross a 64k boundary.
        //
        if(Under1MegLine) {
            //
            // Check if the transfer would cross a 64k boundary.  If so,
            // use the local buffer.  Otherwise use the user's buffer.
            //
            if(((ULONG)UserBuffer & 0xffff0000) !=
              (((ULONG)UserBuffer + (SectorsToTransfer * PhysicalSectors) - 1) & 0xffff0000))
            {
                TransferBuffer = FwDiskCache;
                SectorsToTransfer = (UCHAR)min(SectorsToTransfer, SCRATCH_BUFFER_SIZE / (USHORT)PhysicalSectors);

            } else {

                TransferBuffer = UserBuffer;
            }
        } else {
            TransferBuffer = FwDiskCache;
            SectorsToTransfer = (UCHAR)min(SectorsToTransfer, SCRATCH_BUFFER_SIZE / (USHORT)PhysicalSectors);
        }

        if(TransferBuffer == FwDiskCache) {
            RtlMoveMemory(FwDiskCache,UserBuffer,SectorsToTransfer*PhysicalSectors);
        }

        Status = WritePhysicalSectors(
                    Int13Unit,
                    CurrentSector,
                    SectorsToTransfer,
                    TransferBuffer,
                    SectorsPerTrack,
                    Heads,
                    Cylinders,
                    AllowXInt13
                    );

        if(Status != ESUCCESS) {
            //
            // Tail part isn't contiguous with middle part
            //
            BytesLeftToTransfer += TailByteCount;
            return(Status);
        }

        CurrentSector += SectorsToTransfer;
        BytesLeftToTransfer -= SectorsToTransfer * PhysicalSectors;
        UserBuffer += SectorsToTransfer * PhysicalSectors;
    }

    Status = ESUCCESS;

    BiosDiskWriteDone:

    *Count = Length - BytesLeftToTransfer;
    BlFileTable[FileId].Position.QuadPart += *Count;
    return(Status);
}


ARC_STATUS
pBiosDiskReadWorker(
    IN  ULONG   FileId,
    OUT PVOID   Buffer,
    IN  ULONG   Length,
    OUT PULONG  Count,
    IN  USHORT  SectorSize,
    IN  BOOLEAN xInt13
    )

/*++

Routine Description:

    Reads sectors directly from an open physical disk.

Arguments:

    FileId - Supplies the file to read from

    Buffer - Supplies buffer to hold the data that is read

    Length - Supplies maximum number of bytes to read

    Count - Returns actual bytes read

Return Value:

    ESUCCESS - Read completed successfully

    !ESUCCESS - Read failed

--*/

{
    ULONGLONG HeadSector,TailSector,CurrentSector;
    ULONG HeadOffset,TailByteCount;
    USHORT Heads,Cylinders;
    UCHAR SectorsPerTrack;
    UCHAR Int13Unit;
    ARC_STATUS Status;
    UCHAR SectorsToTransfer;
    ULONG NumBytesToTransfer;
    BOOLEAN AllowXInt13;
    PUCHAR pDestInUserBuffer;
    PUCHAR pEndOfUserBuffer;
    PUCHAR pTransferDest;
    PUCHAR pSrc;
    ULONG CopyLength;
    ULONG ReadLength;
    PUCHAR pLastReadSector = NULL;
    ULONGLONG LastReadSectorNumber = 0;
    PUCHAR TargetBuffer;

    DBGOUT(("BiosDiskRead: enter; length=0x%lx, sector size=%u, xint13=%u\r\n",Length,SectorSize,xInt13));

    //
    // Reset number of bytes transfered.
    //

    *Count = 0;

    //
    // Complete 0 length requests immediately.
    //

    if (Length == 0) {
        return ESUCCESS;
    }

    //
    // Initialize the last sector cache if it has not been 
    // initialized.
    //

    if (!FwLastSectorCache.Initialized) {
        FwLastSectorCache.Data = 
            FwAllocatePool(BL_LAST_SECTOR_CACHE_MAX_SIZE);

        if (FwLastSectorCache.Data) {
            FwLastSectorCache.Initialized = TRUE;
        }
    }

    //
    // Gather disk stats.
    //

    SectorsPerTrack = BlFileTable[FileId].u.DriveContext.Sectors;
    Heads = BlFileTable[FileId].u.DriveContext.Heads;
    Cylinders = BlFileTable[FileId].u.DriveContext.Cylinders;
    AllowXInt13 = BlFileTable[FileId].u.DriveContext.xInt13;
    Int13Unit = BlFileTable[FileId].u.DriveContext.Drive;

    DBGOUT(("BiosDiskRead: unit 0x%x CHS=%lu %lu %lu\r\n",
            Int13Unit,
            Cylinders,
            Heads,
            SectorsPerTrack));

    //
    // Initialize locals that denote where we are in satisfying the
    // request.
    //

    //
    // If the buffer is in the first 1MB of KSEG0, we want to use the
    // identity-mapped address
    //
    if (((ULONG_PTR)((PUCHAR)Buffer+Length) & ~KSEG0_BASE) < BIOSDISK_1MB) {
        pDestInUserBuffer = (PUCHAR)((ULONG_PTR)Buffer & ~KSEG0_BASE);
    } else {
        pDestInUserBuffer = Buffer;
    }
    
    pEndOfUserBuffer = (PUCHAR) pDestInUserBuffer + Length;
    TargetBuffer = pDestInUserBuffer;
    
    //
    // Calculating these before hand makes it easier to hand the
    // special cases. Note that tail sector is the last sector this
    // read wants bytes from. That is why we subtract one. We handle 
    // the Length == 0 case above.
    //

    HeadSector = BlFileTable[FileId].Position.QuadPart / SectorSize;
    HeadOffset = (ULONG)(BlFileTable[FileId].Position.QuadPart % SectorSize);

    TailSector = (BlFileTable[FileId].Position.QuadPart + Length - 1) / SectorSize;
    TailByteCount = (ULONG)((BlFileTable[FileId].Position.QuadPart + Length - 1) % SectorSize);
    TailByteCount ++;

    //
    // While there is data we should read, read.
    //
    
    CurrentSector = HeadSector;

    while (pDestInUserBuffer != pEndOfUserBuffer) {
        //
        // Look to see if we can find the current sector we have to 
        // read in the last sector cache.
        //
        
        if (FwLastSectorCache.Valid &&
            FwLastSectorCache.DeviceId == FileId &&
            FwLastSectorCache.SectorNumber == CurrentSector) {

            pSrc = FwLastSectorCache.Data;
            CopyLength = SectorSize;

            //
            // Adjust copy parameters depending on whether
            // this sector is the Head and/or Tail sector.
            //

            if (HeadSector == CurrentSector) {
                pSrc += HeadOffset;
                CopyLength -= HeadOffset;
            }

            if (TailSector == CurrentSector) {
                CopyLength -= (SectorSize - TailByteCount);
            }

            //
            // Copy the cached data to users buffer.
            //
           
            RtlCopyMemory(pDestInUserBuffer, pSrc, CopyLength);

            //
            // Update our status.
            //

            CurrentSector += 1;
            pDestInUserBuffer += CopyLength;
            *Count += CopyLength;

            continue;
        }

        //
        // Calculate number of sectors we have to read. Read a maximum
        // of SCRATCH_BUFFER_SIZE so we can use our local buffer if the
        // user's buffer crosses 64KB boundary or is not under 1MB.
        //
        
        SectorsToTransfer = (UCHAR)min ((LONG) (TailSector - CurrentSector + 1),
                                         SCRATCH_BUFFER_SIZE / SectorSize);
        if (!xInt13) {
            //
            // Make sure the number of sectors to transfer does not exceed
            // the number of sectors left in the track.
            //
            SectorsToTransfer = (UCHAR)min(SectorsPerTrack - (CurrentSector % SectorsPerTrack),
                                           SectorsToTransfer);
        }
        NumBytesToTransfer = SectorsToTransfer * SectorSize;

        //
        // Determine where we want to read into. We can use the
        // current chunk of user buffer only if it is under 1MB and
        // does not cross a 64KB boundary, and it can take all we want
        // to read into it.
        //
        
        if (((ULONG_PTR) pDestInUserBuffer + NumBytesToTransfer < BIOSDISK_1MB) && 
            (((ULONG_PTR) pDestInUserBuffer & BIOSDISK_64KB_MASK) ==
             (((ULONG_PTR) pDestInUserBuffer + NumBytesToTransfer) & BIOSDISK_64KB_MASK)) &&
            ((pEndOfUserBuffer - pDestInUserBuffer) >= (LONG) NumBytesToTransfer)) {

            pTransferDest = pDestInUserBuffer;

        } else {

            pTransferDest = FwDiskCache;
        }
        
        //
        // Perform the read.
        //

        if(xInt13) {
            Status = ReadExtendedPhysicalSectors(Int13Unit,
                                                 CurrentSector,
                                                 SectorsToTransfer,
                                                 pTransferDest);
        } else {
            Status = ReadPhysicalSectors(Int13Unit,
                                         CurrentSector,
                                         SectorsToTransfer,
                                         pTransferDest,
                                         SectorsPerTrack,
                                         Heads,
                                         Cylinders,
                                         AllowXInt13);
        }

        if(Status != ESUCCESS) {
            DBGOUT(("BiosDiskRead: read failed with %u\r\n",Status));
            goto BiosDiskReadDone;
        }

        //
        // Note the last sector that was read from the disk.
        //

        pLastReadSector = pTransferDest + (SectorsToTransfer - 1) * SectorSize;
        LastReadSectorNumber = CurrentSector + SectorsToTransfer - 1;

        //
        // Note the amount read.
        //
        
        ReadLength = NumBytesToTransfer;

        //
        // Copy transfered data into user's buffer if we did not
        // directly read into that.
        //

        if (pTransferDest != pDestInUserBuffer) {
            pSrc = pTransferDest;
            CopyLength = NumBytesToTransfer;

            //
            // Adjust copy parameters depending on whether
            // we have read the Head and/or Tail sectors.
            //

            if (HeadSector == CurrentSector) {
                pSrc += HeadOffset;
                CopyLength -= HeadOffset;
            } 

            if (TailSector == CurrentSector + SectorsToTransfer - 1) {
                CopyLength -= (SectorSize - TailByteCount);
            }

            //
            // Copy the read data to users buffer.
            //            
            ASSERT(pDestInUserBuffer >= TargetBuffer);
            ASSERT(pEndOfUserBuffer >= pDestInUserBuffer + CopyLength);
            ASSERT(CopyLength <= SCRATCH_BUFFER_SIZE);
            ASSERT(pSrc >= (PUCHAR) FwDiskCache);
            ASSERT(pSrc < (PUCHAR) FwDiskCache + SCRATCH_BUFFER_SIZE);
            
            RtlCopyMemory(pDestInUserBuffer, pSrc, CopyLength);

            //
            // Adjust the amount read into user's buffer.
            //
            
            ReadLength = CopyLength;
        }
        
        //
        // Update our status.
        //

        CurrentSector += SectorsToTransfer;
        pDestInUserBuffer += ReadLength;
        *Count += ReadLength;
    }

    //
    // Update the last read sector cache.
    //

    if (pLastReadSector && 
        FwLastSectorCache.Initialized &&
        BL_LAST_SECTOR_CACHE_MAX_SIZE >= SectorSize) {

        FwLastSectorCache.DeviceId = FileId;
        FwLastSectorCache.SectorNumber = LastReadSectorNumber;

        RtlCopyMemory(FwLastSectorCache.Data, 
                      pLastReadSector,
                      SectorSize);

        FwLastSectorCache.Valid = TRUE;
    }

    DBGOUT(("BiosDiskRead: exit success\r\n"));
    Status = ESUCCESS;

    BiosDiskReadDone:

    BlFileTable[FileId].Position.QuadPart += *Count;
    return(Status);
}


ARC_STATUS
BiosDiskRead(
    IN  ULONG  FileId,
    OUT PVOID  Buffer,
    IN  ULONG  Length,
    OUT PULONG Count
    )
{
    USHORT    PhysicalSectors;

    PhysicalSectors = SECTOR_SIZE;
    return(pBiosDiskReadWorker(FileId,Buffer,Length,Count,PhysicalSectors,FALSE));
}


ARC_STATUS
BiosElToritoDiskRead(
    IN  ULONG  FileId,
    OUT PVOID  Buffer,
    IN  ULONG  Length,
    OUT PULONG Count
    )
{
    return(pBiosDiskReadWorker(FileId,Buffer,Length,Count,2048,TRUE));
}


ARC_STATUS
BiosPartitionGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION Finfo
    )
{
    //
    // THIS ROUTINE DOES NOT WORK FOR PARTITION 0.
    //

    PPARTITION_CONTEXT Context;

    RtlZeroMemory(Finfo, sizeof(FILE_INFORMATION));

    Context = &BlFileTable[FileId].u.PartitionContext;

    Finfo->StartingAddress.QuadPart = Context->StartingSector;    
    Finfo->StartingAddress.QuadPart = Finfo->StartingAddress.QuadPart << (CCHAR)Context->SectorShift;   
    Finfo->EndingAddress.QuadPart = Finfo->StartingAddress.QuadPart + Context->PartitionLength.QuadPart;
    Finfo->Type = DiskPeripheral;

    return ESUCCESS;
}

ARC_STATUS
BiosDiskGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInfo
    )
/*++

Routine Description:

    Gets the information about the isk.

Arguments:

    FileId - The file id to the disk for which information is needed

    FileInfo - Place holder for returning information about the disk

Return Value:

    ESUCCESS if successful, otherwise appropriate ARC error code.

--*/
{
    ARC_STATUS Result = EINVAL;

    if (FileInfo) {
        PDRIVE_CONTEXT  DriveContext;
        LONGLONG   DriveSize = 0;
        ULONG SectorSize = SECTOR_SIZE;

        DriveContext = &(BlFileTable[FileId].u.DriveContext);
        Result = EIO;

        //
        // NOTE : SectorSize == 512 bytes for everything except
        // Eltorito disks for which sector size is 2048.
        //
        if (DriveContext->IsCd) {
            SectorSize = 2048;
        }
        
        DriveSize = (DriveContext->Heads * DriveContext->Cylinders * 
                        DriveContext->Sectors * SectorSize);

        if (DriveSize) {
            RtlZeroMemory(FileInfo, sizeof(FILE_INFORMATION));        
            
            FileInfo->StartingAddress.QuadPart = 0;
            FileInfo->EndingAddress.QuadPart = DriveSize;
            FileInfo->CurrentPosition = BlFileTable[FileId].Position;

            //
            // Any thing less than 3MB is floppy drive
            //
            if (DriveSize <= 0x300000) {
                FileInfo->Type = FloppyDiskPeripheral;
            } else {
                FileInfo->Type = DiskPeripheral;
            }

            Result = ESUCCESS;
        }            
    }        

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\bootx86.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    bootx86.h

Abstract:

    Header file for the x86-specific portions of the common boot library

Author:

    John Vert (jvert) 14-Oct-1993

Revision History:

--*/

#ifndef _BOOTX86_
#define _BOOTX86_

#include "bldrx86.h"
#include "..\bootlib.h"

//
// common typedefs
//

//
// This must match the structure with the same name in startup\i386\types.h,
// and the FsContextRecord struct in startup\i386\su.inc.
//
typedef struct _FSCONTEXT_RECORD {
    UCHAR BootDrive;
} FSCONTEXT_RECORD, *PFSCONTEXT_RECORD;

//          M E M O R Y   D E S C R I P T O R
//
// Memory Descriptor - each contiguous block of physical memory is
// described by a Memory Descriptor. The descriptors are a table, with
// the last entry having a BlockBase and BlockSize of zero.  A pointer
// to the beginning of this table is passed as part of the BootContext
// Record to the OS Loader.
//

typedef struct _SU_MEMORY_DESCRIPTOR {
    ULONG BlockBase;
    ULONG BlockSize;
} SU_MEMORY_DESCRIPTOR , *PSU_MEMORY_DESCRIPTOR;

VOID
InitializeMemoryDescriptors (
    VOID
    );


//          B O O T   C O N T E X T   R E C O R D
//
//  Passed to the OS loader by the SU module or bootstrap
//  code, whatever the case. Constains all the basic machine
//  and environment information the OS loaders needs to get
//  itself going.
//

typedef struct _BOOT_CONTEXT {
    PFSCONTEXT_RECORD FSContextPointer;
    PEXTERNAL_SERVICES_TABLE ExternalServicesTable;
    PSU_MEMORY_DESCRIPTOR MemoryDescriptorList;
    ULONG MachineType;
    ULONG OsLoaderStart;
    ULONG OsLoaderEnd;
    ULONG ResourceDirectory;
    ULONG ResourceOffset;
    ULONG OsLoaderBase;
    ULONG OsLoaderExports;
    ULONG BootFlags;
    ULONG NtDetectStart;
    ULONG NtDetectEnd;
    ULONG SdiAddress;
} BOOT_CONTEXT, *PBOOT_CONTEXT;

//
// Common function prototypes
//

VOID
InitializeDisplaySubsystem(
    VOID
    );

ARC_STATUS
InitializeMemorySubsystem(
    PBOOT_CONTEXT
    );

ARC_STATUS
XferPhysicalDiskSectors(
    IN  UCHAR     Int13UnitNumber,
    IN  ULONGLONG StartSector,
    IN  UCHAR     SectorCount,
    OUT PUCHAR    Buffer,
    IN  UCHAR     SectorsPerTrack,
    IN  USHORT    Heads,
    IN  USHORT    Cylinders,
    IN  BOOLEAN   AllowExtendedInt13,
    IN  BOOLEAN   Write
    );

#define ReadPhysicalSectors(d,a,n,p,s,h,c,f)                                \
                                                                            \
            XferPhysicalDiskSectors((d),(a),(n),(p),(s),(h),(c),(f),FALSE)

#define WritePhysicalSectors(d,a,n,p,s,h,c,f)                               \
                                                                            \
            XferPhysicalDiskSectors((d),(a),(n),(p),(s),(h),(c),(f),TRUE)


ARC_STATUS
XferExtendedPhysicalDiskSectors(
    IN  UCHAR     Int13UnitNumber,
    IN  ULONGLONG StartSector,
    IN  USHORT    SectorCount,
    OUT PUCHAR    Buffer,
    IN  BOOLEAN   Write
    );

#define ReadExtendedPhysicalSectors(d,a,c,p)                                \
                                                                            \
            XferExtendedPhysicalDiskSectors((d),(a),(c),(p),FALSE)

#define WriteExtendedPhysicalSectors(d,a,c,p)                               \
                                                                            \
            XferExtendedPhysicalDiskSectors((d),(a),(c),(p),TRUE)

VOID
ResetDiskSystem(
    UCHAR Int13UnitNumber
    );

VOID
MdShutoffFloppy(
    VOID
    );


BOOLEAN
FwGetPathMnemonicKey(
    IN PCHAR OpenPath,
    IN PCHAR Mnemonic,
    IN PULONG Key
    );

PVOID
FwAllocateHeapAligned(
    IN ULONG Size
    );

PVOID
FwAllocatePool(
    IN ULONG Size
    );

PVOID
FwAllocateHeapPermanent(
    IN ULONG NumberPages
    );

VOID
FwStallExecution(
    IN ULONG Microseconds
    );

VOID
BlGetActivePartition(
    OUT PCHAR PartitionName
    );

VOID
BlFillInSystemParameters(
    IN PBOOT_CONTEXT BootContextRecord
    );

VOID
BlpRemapReserve (
    VOID
    );

ARC_STATUS
BlpMarkExtendedVideoRegionOffLimits(
    VOID
    );
//
// global data definitions
//

extern ULONG MachineType;
extern PCONFIGURATION_COMPONENT_DATA FwConfigurationTree;
extern ULONG HeapUsed;
extern ULONG BlHighestPage;
extern ULONG BlLowestPage;

#define HYPER_SPACE_ENTRY       768
#define HYPER_SPACE_BEGIN       0xC0000000
#define HYPER_PAGE_DIR          0xC0300000

//
// X86 Detection definitions
// The size is *ALWAYS* assumed to be 64K.
// N.B.  The definition *MUST* be the same as the ones defined in
//       startup\su.inc
//

#define DETECTION_LOADED_ADDRESS 0x10000

//
//  We need to allocate permanent and temporary memory for the page directory,
//  assorted page tables, and the memory descriptors before the blmemory
//  routines ever get control.  So we have two private heaps, one for permanent
//  data and one for temporary data.  There are two descriptors for this.  The
//  permanent heap descriptor starts out as zero-length at P.A. 0x30000.  The
//  temporary heap descriptor immediately follows the permanent heap in memory
//  and starts out as 128k long.  As we allocate permanent pages, we increase
//  the size of the permanent heap descriptor and increase the base (thereby
//  decreasing the size) of the temporary heap descriptor)
//
//  So the permanent heap starts at P.A. 0x30000 and grows upwards.  The
//  temporary heap starts at P.A. 0x5C000 and grows downwards.  This gives us
//  a total of 128k of combined permanent and temporary data.
//

//
// Heap starting locations (in pages)
//

//
// Scratch buffer for disk cache is 36K and begins before the permanent heap
//
#define SCRATCH_BUFFER_SIZE (36*1024)
extern PUCHAR FwDiskCache;

#define BIOS_DISK_CACHE_START 0x30
#define PERMANENT_HEAP_START (0x30+(SCRATCH_BUFFER_SIZE/PAGE_SIZE))
#define TEMPORARY_HEAP_START 0x60

//
// The base "window" for the loader and loaded images == 16MB
// See the comments in memory.c for the implications of changing these.
//
#define BASE_LOADER_IMAGE     (16*1024*1024)

//
// Useful Macro Definitions
//

#define ROUND_UP(Num,Size)  (((Num) + Size - 1) & ~(Size -1))

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) { \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) { \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) { \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }

//
// Global definitions for the BIOS ARC Emulation
//
// Defines for the ARC name of console input and output
//

#define CONSOLE_INPUT_NAME "multi(0)key(0)keyboard(0)"
#define CONSOLE_OUTPUT_NAME "multi(0)video(0)monitor(0)"

//
// Define special character values.
//

#define ASCI_NUL 0x00
#define ASCI_BEL 0x07
#define ASCI_BS  0x08
#define ASCI_HT  0x09
#define ASCI_LF  0x0A
#define ASCI_VT  0x0B
#define ASCI_FF  0x0C
#define ASCI_CR  0x0D
#define ASCI_ESC 0x1B
#define ASCI_SYSRQ 0x80

//
// Device I/O prototypes
//

ARC_STATUS
BiosPartitionClose(
    IN ULONG FileId
    );

ARC_STATUS
BiosPartitionOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BiosPartitionRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosPartitionWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosPartitionSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
BiosPartitionGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInfo
    );
    
ARC_STATUS
BiosDiskGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInfo
    );

ARC_STATUS
BlArcNotYetImplemented(
    IN ULONG FileId
    );

ARC_STATUS
BiosConsoleOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BiosConsoleReadStatus(
    IN ULONG FileId
    );

ARC_STATUS
BiosConsoleRead (
    IN ULONG FileId,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosConsoleWrite (
    IN ULONG FileId,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosDiskOpen(
    IN ULONG DriveId,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BiosDiskRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosElToritoDiskRead(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

BOOLEAN
BlIsElToritoCDBoot(
    UCHAR DriveNum
    );

ARC_STATUS
BiosDiskWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
HardDiskPartitionOpen(
    IN ULONG   FileId,
    IN ULONG   DiskId,
    IN UCHAR   PartitionNumber
    );

//
// Boot debugger prototypes required to initialize the appropriate IDT entries.
//

VOID
BdTrap01 (
    VOID
    );

VOID
BdTrap03 (
    VOID
    );

VOID
BdTrap0d (
    VOID
    );

VOID
BdTrap0e (
    VOID
    );

VOID
BdTrap2d (
    VOID
    );


//
// Helper functions and macros
//

#define PTE_PER_PAGE_X86 (PAGE_SIZE / sizeof(HARDWARE_PTE_X86))
#define PTE_PER_PAGE_X86PAE (PAGE_SIZE / sizeof(HARDWARE_PTE_X86PAE))

//
// todo: this is a bug.  this can be used in the translation 
// from a PTE frame number to the physical address.
// by returning a pointer to the address, we limit ourselves
// and will die if there are more than 32 bits of address.
// jamschw: 2/26/02
//
#define PAGE_FRAME_FROM_PTE( _pte ) \
            ((PVOID)(((ULONG) _pte->PageFrameNumber) << PAGE_SHIFT))

#define PPI_SHIFT_X86PAE 30

#define PT_INDEX_PAE( va ) (((ULONG_PTR)(va) >> PTI_SHIFT) & \
                            ((1 << (PDI_SHIFT_X86PAE - PTI_SHIFT)) - 1))

#define PD_INDEX_PAE( va ) (((ULONG_PTR)(va) >> PDI_SHIFT_X86PAE) & \
                            ((1 << (PPI_SHIFT_X86PAE - PDI_SHIFT_X86PAE)) - 1));

#define PP_INDEX_PAE( va ) ((ULONG_PTR)(va) >> PPI_SHIFT_X86PAE)

#define PAGE_TO_VIRTUAL( page ) ((PVOID)((page << PAGE_SHIFT)))

#endif // _BOOTX86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\disp_tm.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    disp_tm.c

Author:

    Ted Miller 6-July-1995

Abstract:

    This routine contains low-level routines to operate on a
    CGA-style text mode video buffer.

    It collects up various other bits and pieces that were written by
    others and once contained in other source files.

--*/

#include "bootx86.h"
#include "displayp.h"

//
// Standard cga 80x25 text mode's video buffer address,
// resolution, etc.
//
#define VIDEO_BUFFER_VA 0xb8000
#define VIDEO_ROWS      25
#define VIDEO_COLUMNS   80
#define VIDEO_BYTES_PER_ROW (VIDEO_COLUMNS*2)

//
// Various globals to track location on screen, attribute, etc.
//
PUCHAR Vp = (PUCHAR)VIDEO_BUFFER_VA;


VOID
TextTmPositionCursor(
    USHORT Row,
    USHORT Column
    )

/*++

Routine Description:

    Sets the position of the soft cursor. That is, it doesn't move the
    hardware cursor but sets the location of the next write to the
    screen.

Arguments:

    Row - Row coordinate of where character is to be written.

    Column - Column coordinate of where character is to be written.

Returns:

    Nothing.

--*/

{
    if(Row >= VIDEO_ROWS) {
        Row = VIDEO_ROWS-1;
    }

    if(Column >= VIDEO_COLUMNS) {
        Column = VIDEO_COLUMNS-1;
    }

    Vp = (PUCHAR)(VIDEO_BUFFER_VA + (Row * VIDEO_BYTES_PER_ROW) + (2 * Column));
}


VOID
TextTmStringOut(
    IN PUCHAR String
    )
{
    PUCHAR p = String;

    while(*p) {
        p = TextTmCharOut(p);
    }
}


PUCHAR
TextTmCharOut(
    PUCHAR pc
    )

/*++

Routine Description:

    Writes a character on the display at the current position.
    Newlines and tabs are interpreted and acted upon.

Arguments:

    c - pointer to character to write

Returns:

    Pointer to next char in string

--*/



{
    unsigned u;
    UCHAR c;
    UCHAR temp;

    c = *pc;

    switch (c) {
    case '\n':
        if(TextRow == (VIDEO_ROWS-1)) {
            TextTmScrollDisplay();
            TextSetCursorPosition(0,TextRow);
        } else {
            TextSetCursorPosition(0,TextRow+1);
        }
        break;

    case '\r':
        //
        // ignore
        //
        break;

    case '\t':
        temp = ' ';
        u = 8 - (TextColumn % 8);
        while(u--) {
            TextTmCharOut(&temp);
        }
        TextSetCursorPosition(TextColumn+u,TextRow);
        break;

    default :
        *Vp++ = c;
        *Vp++ = TextCurrentAttribute;
        TextSetCursorPosition(TextColumn+1,TextRow);
      }

      return(pc+1);
}


VOID
TextTmFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    )

/*++

Routine Description:

    Changes the screen attribute starting at the current cursor position.
    The cursor is not moved.

Arguments:

    Attribute - Supplies the new attribute

    Length - Supplies the length of the area to change (in bytes)

Return Value:

    None.

--*/

{
    PUCHAR Temp;

    Temp = Vp+1;

    while((Vp+1+Length*2) > Temp) {
        *Temp++ = (UCHAR)Attribute;
        Temp++;
    }
}


VOID
TextTmClearToEndOfLine(
    VOID
    )

/*++

Routine Description:

    Clears from the current cursor position to the end of the line
    by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    PUSHORT p;
    unsigned u;

    //
    // Calculate address of current cursor position
    //
    p = (PUSHORT)((PUCHAR)VIDEO_BUFFER_VA + (TextRow*VIDEO_BYTES_PER_ROW)) + TextColumn;

    //
    // Fill with blanks up to end of line.
    //
    for(u=TextColumn; u<VIDEO_COLUMNS; u++) {
        *p++ = (TextCurrentAttribute << 8) + ' ';
    }
}


VOID
TextTmClearFromStartOfLine(
    VOID
    )

/*++

Routine Description:

    Clears from the start of the line to the current cursor position
    by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    PUSHORT p;
    unsigned u;

    //
    // Calculate address of start of line in video buffer
    //
    p = (PUSHORT)((PUCHAR)VIDEO_BUFFER_VA + (TextRow*VIDEO_BYTES_PER_ROW));

    //
    // Fill with blanks up to char before cursor position.
    //
    for(u=0; u<TextColumn; u++) {
        *p++ = (TextCurrentAttribute << 8) + ' ';
    }
}


VOID
TextTmClearToEndOfDisplay(
    VOID
    )

/*++

Routine Description:

    Clears from the current cursor position to the end of the video
    display by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/
{
    USHORT x,y;
    PUSHORT p;

    //
    // Clear current line
    //
    TextTmClearToEndOfLine();

    //
    // Clear the remaining lines
    //
    p = (PUSHORT)((PUCHAR)VIDEO_BUFFER_VA + ((TextRow+1)*VIDEO_BYTES_PER_ROW));

    for(y=TextRow+1; y<VIDEO_ROWS; y++) {

        for(x=0; x<VIDEO_COLUMNS; x++) {

            *p++ =(TextCurrentAttribute << 8) + ' ';
        }
    }
}


VOID
TextTmClearDisplay(
    VOID
    )

/*++

Routine Description:

    Clears the text-mode video display by writing blanks with
    the current video attribute over the entire display.

Arguments:

    None

Returns:

    Nothing

--*/

{
    unsigned u;

    //
    // Write blanks in the current attribute to the entire screen.
    //
    for(u=0; u<VIDEO_ROWS*VIDEO_COLUMNS; u++) {
        ((PUSHORT)VIDEO_BUFFER_VA)[u] = (TextCurrentAttribute << 8) + ' ';
    }
}


VOID
TextTmScrollDisplay(
    VOID
    )

/*++

Routine Description:

    Scrolls the display up one line. The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    PUSHORT Sp,Dp;
    USHORT i,j,c;

    Dp = (PUSHORT) VIDEO_BUFFER_VA;
    Sp = (PUSHORT) (VIDEO_BUFFER_VA + VIDEO_BYTES_PER_ROW);

    //
    // Move each row up one row
    //
    for(i=0 ; i < (USHORT)(VIDEO_ROWS-1) ; i++) {
        for(j=0; j < (USHORT)VIDEO_COLUMNS; j++) {
            *Dp++ = *Sp++;
        }
    }

    //
    // Write blanks in the bottom line, using the attribute
    // from the leftmost char on the bottom line on the screen.
    //
    c = (*Dp & (USHORT)0xff00) + (USHORT)' ';

    for(i=0; i < (USHORT)VIDEO_COLUMNS; ++i) {
        *Dp++ = c;
    }
}


VOID
TextTmSetCurrentAttribute(
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Noop.

Arguments:

    Attribute - New attribute to set to.

Return Value:

    Nothing.

--*/

{
    UNREFERENCED_PARAMETER(Attribute);
}


CHAR TmGraphicsChars[GraphicsCharMax] = { '','','','','','' };

UCHAR
TextTmGetGraphicsChar(
    IN GraphicsChar WhichOne
    )
{
    return((UCHAR)TmGraphicsChars[WhichOne]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\display.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    display.c

Author:

    Thomas Parslow [TomP] Feb-13-1991
    Reworked substantially in Tokyo 7-July-95 (tedm)

Abstract:

    This file contains an interface to the screen that is independent
    of the screen type actually being written to. It is layered on top
    of modules pecific to vga text mode and vga graphics mode.

--*/


#include "bootx86.h"
#include "displayp.h"


#define ZLEN_SHORT(x) ((x < 0x10) + (x < 0x100) + (x < 0x1000))
#define ZLEN_LONG(x)  ((x < 0x10) + (x < 0x100) + (x < 0x1000) + \
    (x < 0x10000) + (x < 0x100000)+(x < 0x1000000)+(x < 0x10000000))

//
// Current screen position.
//
USHORT TextColumn = 0;
USHORT TextRow  = 0;

//
// Current text attribute
//
UCHAR TextCurrentAttribute = 0x07;      // start with white on black.

//
// Internal routines
//
VOID
puti(
    LONG
    );

VOID
putx(
    ULONG
    );

VOID
putu(
    ULONG
    );

VOID
pTextCharOut(
    IN UCHAR c
    );

VOID
putwS(
    PUNICODE_STRING String
    );


VOID
BlPrint(
    PCHAR cp,
    ...
    )

/*++

Routine Description:

    Standard printf function with a subset of formating features supported.

    Currently handles

     %d, %ld - signed short, signed long
     %u, %lu - unsigned short, unsigned long
     %c, %s  - character, string
     %x, %lx - unsigned print in hex, unsigned long print in hex

    Does not do:

     - field width specification
     - floating point.

Arguments:

    cp - pointer to the format string, text string.

Returns:

    Nothing

--*/

{
    USHORT b,c,w,len;
    PUCHAR ap;
    ULONG l;
    ULONG Count;
    CHAR ch;
    ULONG DeviceId;


    if (BlConsoleOutDeviceId == 0) {
        DeviceId = 1;
    } else {
        DeviceId = BlConsoleOutDeviceId;
    }

    //
    // Cast a pointer to the first word on the stack
    //
    ap = (PUCHAR)&cp + sizeof(PCHAR);

    //
    // Process the arguments using the descriptor string
    //
    while((b = *cp++) != 0) {
        if(b == '%') {

            c = *cp++;

            switch (c) {

            case 'd':
                puti((long)*((int *)ap));
                ap += sizeof(int);
                break;

            case 's':
                ArcWrite(DeviceId, *((PCHAR *)ap), strlen(*((PCHAR *)ap)), &Count);
                ap += sizeof(char *);
                break;

            case 'c':
                //
                // Does not handle dbcs chars
                //
                ArcWrite(DeviceId, ((char *)ap), 1, &Count);
                ap += sizeof(int);
                break;

            case 'x':
                w = *((USHORT *)ap);
                len = (USHORT)ZLEN_SHORT(w);
                ch = '0';
                while (len--) {
                    ArcWrite(DeviceId, &ch, 1, &Count);
                }
                putx((ULONG)*((USHORT *)ap));
                ap += sizeof(int);
                break;

            case 'u':
                putu((ULONG)*((USHORT *)ap));
                ap += sizeof(int);
                break;

            case 'w':
                c = *cp++;
                switch (c) {
                case 'S':
                case 'Z':
                    putwS(*((PUNICODE_STRING *)ap));
                    ap += sizeof(PUNICODE_STRING);
                    break;
                }
                break;

            case 'l':
                c = *cp++;

                switch(c) {

                case '0':
                    break;

                case 'u':
                    putu(*((ULONG *)ap));
                    ap += sizeof(long);
                    break;

                case 'x':
                    l = *((ULONG *)ap);
                    len = (USHORT)ZLEN_LONG(l);
                    ch = '0';
                    while (len--) {
                        ArcWrite(DeviceId, &ch, 1, &Count);
                    }
                    putx(*((ULONG *)ap));
                    ap += sizeof(long);
                    break;

                case 'd':
                    puti(*((ULONG *)ap));
                    ap += sizeof(long);
                    break;
                }
                break;

            default :
                ch = (char)b;
                ArcWrite(DeviceId, &ch, 1, &Count);
                ch = (char)c;
                ArcWrite(DeviceId, &ch, 1, &Count);
            }
        } else {

            if (DbcsLangId && GrIsDBCSLeadByte(*(cp - 1)))  {
                //
                // A double-byte char.
                //
                ArcWrite(DeviceId, cp - 1, 2, &Count);
                cp++;
            } else {
                ArcWrite(DeviceId, cp - 1, 1, &Count);
            }

        }

    }

}


VOID
putwS(
    PUNICODE_STRING String
    )

/*++

Routine Description:

    Writes unicode string to the display at the current cursor position.

Arguments:

    String - pointer to unicode string to display

Returns:

    Nothing

--*/

{
    ULONG i;
    ULONG Count;
    UCHAR ch;

    for(i=0; i < String->Length/sizeof(WCHAR); i++) {
        ch = (UCHAR)String->Buffer[i];
        ArcWrite(BlConsoleOutDeviceId, &ch, 1, &Count);
    }
}


VOID
putx(
    ULONG x
    )

/*++

Routine Description:

    Writes hex long to the display at the current cursor position.

Arguments:

    x - ulong to write

Returns:

    Nothing

--*/

{
    ULONG j;
    ULONG Count;
    UCHAR ch;

    if(x/16) {
        putx(x/16);
    }

    if((j=x%16) > 9) {
        ch = (UCHAR)(j+'A'-10);
        ArcWrite(BlConsoleOutDeviceId, &ch, 1, &Count);
    } else {
        ch = (UCHAR)(j+'0');
        ArcWrite(BlConsoleOutDeviceId, &ch, 1, &Count);
    }
}


VOID
puti(
    LONG i
    )

/*++

Routine Description:

    Writes a long integer on the display at the current cursor position.

Arguments:

    i - the integer to write to the display.

Returns:

    Nothing

--*/

{
    ULONG Count;
    UCHAR ch;

    if(i<0) {
        i = -i;
        ch = '-';
        ArcWrite(BlConsoleOutDeviceId, &ch, 1, &Count);
    }

    if(i/10) {
        puti(i/10);
    }

    ch = (UCHAR)((i%10)+'0');
    ArcWrite(BlConsoleOutDeviceId, &ch, 1, &Count);
}


VOID
putu(
    ULONG u
    )

/*++

Routine Description:

    Write an unsigned long to display

Arguments:

    u - unsigned

Returns:

    Nothing

--*/

{
    ULONG Count;
    UCHAR ch;

    if(u/10) {
        putu(u/10);
    }
    
    ch = (UCHAR)((u%10)+'0');
    ArcWrite(BlConsoleOutDeviceId, &ch, 1, &Count);
}


VOID
pTextCharOut(
    IN UCHAR c
    )
{
    if(DbcsLangId) {
        //
        // Single-byte only
        //
        TextGrCharOut(&c);
    } else {
        TextTmCharOut(&c);
    }
}


PUCHAR
TextCharOut(
    IN PUCHAR pc
    )
{
    if(DbcsLangId) {
        return(TextGrCharOut(pc));
    } else {
        return(TextTmCharOut(pc));
    }
}


VOID
TextStringOut(
    IN PUCHAR String
    )
{
    if(DbcsLangId) {
        TextGrStringOut(String);
    } else {
        TextTmStringOut(String);
    }
}


VOID
TextClearToEndOfLine(
    VOID
    )

/*++

Routine Description:

    Clears from the current cursor position to the end of the line
    by writing blanks with the current video attribute.

Arguments:

    None

Returns:

    Nothing


--*/

{
    if(DbcsLangId) {
        TextGrClearToEndOfLine();
    } else {
        TextTmClearToEndOfLine();
    }
}


VOID
TextClearFromStartOfLine(
    VOID
    )

/*++

Routine Description:

    Clears from the start of the line to the current cursor position
    by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    if(DbcsLangId) {
        TextGrClearFromStartOfLine();
    } else {
        TextTmClearFromStartOfLine();
    }
}


VOID
TextClearToEndOfDisplay(
    VOID
    )

/*++

Routine Description:

    Clears from the current cursor position to the end of the video
    display by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    if(DbcsLangId) {
        TextGrClearToEndOfDisplay();
    } else {
        TextTmClearToEndOfDisplay();
    }
}


VOID
TextClearDisplay(
    VOID
    )

/*++

Routine Description:

    Clears the video display and positions the cursor
    at the upper left corner of the screen (0,0).

Arguments:

    None

Returns:

    Nothing

--*/

{
    if(DbcsLangId) {
        TextGrClearDisplay();
    } else {
        TextTmClearDisplay();
    }
    TextSetCursorPosition(0,0);
}


VOID
TextSetCursorPosition(
    IN ULONG X,
    IN ULONG Y
    )

/*++

Routine Description:

    Moves the location of the software cursor to the specified X,Y position
    on screen.

Arguments:

    X - Supplies the X-position of the cursor

    Y - Supplies the Y-position of the cursor

Return Value:

    None.

--*/

{
    TextColumn = (USHORT)X;
    TextRow = (USHORT)Y;

    if(DbcsLangId) {
        TextGrPositionCursor((USHORT)Y,(USHORT)X);
    } else {
        TextTmPositionCursor((USHORT)Y,(USHORT)X);
    }
}


VOID
TextGetCursorPosition(
    OUT PULONG X,
    OUT PULONG Y
    )

/*++

Routine Description:

    Gets the position of the soft cursor.

Arguments:

    X - Receives column coordinate of where character would be written.

    Y - Receives row coordinate of where next character would be written.

Returns:

    Nothing.

--*/

{
    *X = (ULONG)TextColumn;
    *Y = (ULONG)TextRow;
}


VOID
TextSetCurrentAttribute(
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Sets the character attribute to be used for subsequent text display.

Arguments:

Returns:

    Nothing.

--*/

{
    TextCurrentAttribute = Attribute;

    if(DbcsLangId) {
        TextGrSetCurrentAttribute(Attribute);
    } else {
        TextTmSetCurrentAttribute(Attribute);
    }
}


UCHAR
TextGetCurrentAttribute(
    VOID
    )
{
    return(TextCurrentAttribute);
}

VOID
TextFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    )

/*++

Routine Description:

    Changes the screen attribute starting at the current cursor position.
    The cursor is not moved.

Arguments:

    Attribute - Supplies the new attribute

    Length - Supplies the length of the area to change (in bytes)

Return Value:

    None.

--*/

{
    if(DbcsLangId) {
        TextGrFillAttribute(Attribute,Length);
    } else {
        TextTmFillAttribute(Attribute,Length);
    }
}


UCHAR
TextGetGraphicsCharacter(
    IN GraphicsChar WhichOne
    )
{
    return((WhichOne < GraphicsCharMax)
           ? (DbcsLangId ? TextGrGetGraphicsChar(WhichOne) : TextTmGetGraphicsChar(WhichOne))
           : ' ');
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\entry.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    entry.c

Abstract:

    x86-specific startup for setupldr

Author:

    John Vert (jvert) 14-Oct-1993

Revision History:

--*/
#include "bootx86.h"
#include "stdio.h"
#include "flop.h"
#include <ramdisk.h>

#if 0
#define DBGOUT(x)   BlPrint x
#define DBGPAUSE    while(!GET_KEY());
#else
#define DBGOUT(x)
#define DBGPAUSE
#endif


//
// Prototypes for Internal Routines
//

VOID
DoGlobalInitialization(
    PBOOT_CONTEXT
    );

#if defined(ELTORITO)
BOOLEAN ElToritoCDBoot = FALSE;
#endif

extern CHAR NetBootPath[];

//
// Global context pointers. These are passed to us by the SU module or
// the bootstrap code.
//

PCONFIGURATION_COMPONENT_DATA FwConfigurationTree = NULL;
PEXTERNAL_SERVICES_TABLE ExternalServicesTable;
CHAR BootPartitionName[80];
ULONG MachineType = 0;
ULONG OsLoaderBase;
ULONG OsLoaderExports;
extern PUCHAR BlpResourceDirectory;
extern PUCHAR BlpResourceFileOffset;
ULONG PcrBasePage;
ULONG TssBasePage;

ULONG BootFlags = 0;

ULONG NtDetectStart = 0;
ULONG NtDetectEnd = 0;


#ifdef FORCE_CD_BOOT

BOOLEAN
BlGetCdRomDrive(
  PUCHAR DriveId
  )
{
  BOOLEAN Result = FALSE;
  UCHAR Id = 0;

  do {
    if (BlIsElToritoCDBoot(Id)) {
      *DriveId = Id;
      Result = TRUE;

      break;
    }

    Id++;
  }
  while (Id != 0);

  return Result;
}

#endif

VOID
NtProcessStartup(
    IN PBOOT_CONTEXT BootContextRecord
    )
/*++

Routine Description:

    Main entry point for setup loader. Control is transferred here by the
    start-up (SU) module.

Arguments:

    BootContextRecord - Supplies the boot context, particularly the
        ExternalServicesTable.

Returns:

    Does not return. Control eventually passed to the kernel.


--*/
{
    ARC_STATUS Status;

#ifdef FORCE_CD_BOOT
    BOOLEAN CdFound;
    UCHAR CdId;
#endif

    ULONG_PTR pFirmwareHeapAddress;
    ULONG TssSize,TssPages;

    //
    // Initialize the boot loader's video
    //

    DoGlobalInitialization(BootContextRecord);

    BlFillInSystemParameters(BootContextRecord);

    //
    // Set the global bootflags
    //
    BootFlags = BootContextRecord->BootFlags;

#ifdef FORCE_CD_BOOT
    CdFound = BlGetCdRomDrive(&CdId);

    if (CdFound) {
      BlPrint("CD/DVD-Rom drive found with id:%u\n", CdId);
      BootContextRecord->FSContextPointer->BootDrive = CdId;
    } else {
      BlPrint("CD/DVD-Rom drive not found");
    }
#endif  // for FORCE_CD_BOOT

    if (BootContextRecord->FSContextPointer->BootDrive == 0) {

        //
        // Boot was from A:
        //

        strcpy(BootPartitionName,"multi(0)disk(0)fdisk(0)");

        //
        // To get around an apparent bug on the BIOS of some MCA machines
        // (specifically the NCR 386sx/MC20 w/ BIOS version 1.04.00 (3421),
        // Phoenix BIOS 1.02.07), whereby the first int13 to floppy results
        // in a garbage buffer, reset drive 0 here.
        //

        GET_SECTOR(0,0,0,0,0,0,NULL);

    } else if (BootContextRecord->FSContextPointer->BootDrive == 0x40) {

        //
        // Boot was from the net
        //

        strcpy(BootPartitionName,"net(0)");
        BlBootingFromNet = TRUE;

#if defined(REMOTE_BOOT)
        BlGetActivePartition(NetBootActivePartitionName);
        NetFindCSCPartitionName();
#endif

    } else if (BootContextRecord->FSContextPointer->BootDrive == 0x41) {

        //
        // Boot was from an SDI image
        //

        strcpy(BootPartitionName,"ramdisk(0)");

    } else if (BlIsElToritoCDBoot(BootContextRecord->FSContextPointer->BootDrive)) {

        //
        // Boot was from El Torito CD
        //

        sprintf(BootPartitionName, "multi(0)disk(0)cdrom(%u)", BootContextRecord->FSContextPointer->BootDrive);
        ElToritoCDBoot = TRUE;

    } else {

        //
        // Find the partition we have been booted from.  Note that this
        // is *NOT* necessarily the active partition.  If the system has
        // Boot Mangler installed, it will be the active partition, and
        // we have to go figure out what partition we are actually on.
        //
        BlGetActivePartition(BootPartitionName);

#if defined(REMOTE_BOOT)
        strcpy(NetBootActivePartitionName, BootPartitionName);
        NetFindCSCPartitionName();
#endif

    }


    //
    // We need to make sure that we've got a signature on disk 80.
    // If not, then write one.
    //
    {
    ULONG   DriveId;
    ULONG   NewSignature;
    UCHAR SectorBuffer[4096+256];
    PUCHAR Sector;
    LARGE_INTEGER SeekValue;
    ULONG Count;
    

        Status = ArcOpen("multi(0)disk(0)rdisk(0)partition(0)", ArcOpenReadWrite, &DriveId);

        if (Status == ESUCCESS) {

            //
            // Get a reasonably unique seed to start with.
            //
            NewSignature = ArcGetRelativeTime();
            NewSignature = (NewSignature & 0xFFFF) << 16;
            NewSignature += ArcGetRelativeTime();

            //
            // Now we have a valid new signature to put on the disk.
            // Read the sector off disk, put the new signature in,
            // write the sector back, and recompute the checksum.
            //
            Sector = ALIGN_BUFFER(SectorBuffer);
            SeekValue.QuadPart = 0;
            Status = ArcSeek(DriveId, &SeekValue, SeekAbsolute);
            if (Status == ESUCCESS) {
                Status = ArcRead(DriveId,Sector,512,&Count);

                if( Status == ESUCCESS ) {
                    if( ((PULONG)Sector)[PARTITION_TABLE_OFFSET/2-1] == 0 ) {
                        //
                        // He's 0.  Write a real signature in there.
                        //

                        ((PULONG)Sector)[PARTITION_TABLE_OFFSET/2-1] = NewSignature;

                        Status = ArcSeek(DriveId, &SeekValue, SeekAbsolute);
                        if (Status == ESUCCESS) {
                            Status = ArcWrite(DriveId,Sector,512,&Count);
                            if( Status != ESUCCESS ) {
#if DBG
                                BlPrint( "Falied to write the new signature on the boot partition.\n" );
#endif
                            }
                        } else {
#if DBG
                            BlPrint( "Failed second ArcSeek on the boot partition to check for a signature.\n" );
#endif
                        }
                    }
                } else {
#if DBG
                    BlPrint( "Failed to ArcRead the boot partition to check for a signature.\n" );
#endif
                }
            } else {
#if DBG
                BlPrint( "Failed to ArcSeek the boot partition to check for a signature.\n" );
#endif
            }

            ArcClose(DriveId);
        } else {
#if DBG
            BlPrint( "Couldn't Open the boot partition to check for a signature.\n" );
#endif
        }
    }

    //
    // squirrel away some memory for the PCR and TSS so that we get the 
    // preferred memory location (<16MB) for this data.
    //
    pFirmwareHeapAddress = (ULONG_PTR)FwAllocateHeapPermanent( 2 );
    if (!pFirmwareHeapAddress) {
        BlPrint("Couldn't allocate memory for PCR\n");
        goto BootFailed;
    }
    PcrBasePage = (ULONG)(pFirmwareHeapAddress>>PAGE_SHIFT);

    TssSize = (sizeof(KTSS) + PAGE_SIZE) & ~(PAGE_SIZE - 1);
    TssPages = TssSize / PAGE_SIZE;
    pFirmwareHeapAddress = (ULONG_PTR)FwAllocateHeapPermanent( TssPages );
    if (!pFirmwareHeapAddress) {
        BlPrint("Couldn't allocate memory for TSS\n");
        goto BootFailed;
    }
    TssBasePage = (ULONG)(pFirmwareHeapAddress>>PAGE_SHIFT);

    //
    // Initialize the memory descriptor list, the OS loader heap, and the
    // OS loader parameter block.
    //
    Status = BlMemoryInitialize();
    if (Status != ESUCCESS) {
        BlPrint("Couldn't initialize memory\n");
        goto BootFailed;
    }

    //
    // Initialize the OS loader I/O system.
    //

    AEInitializeStall();

    Status = BlIoInitialize();
    if (Status != ESUCCESS) {
        BlPrint("Couldn't initialize I/O\n");
        goto BootFailed;
    }

    //
    // Call off to regular startup code
    //
    BlStartup(BootPartitionName);

    //
    // we should never get here!
    //
BootFailed:
    if (BootFlags & BOOTFLAG_REBOOT_ON_FAILURE) {
        ULONG StartTime = ArcGetRelativeTime();
        BlPrint(TEXT("\nRebooting in 5 seconds...\n"));
        while ( ArcGetRelativeTime() - StartTime < 5) {}
        ArcRestart();      
    }

    if (!BlIsTerminalConnected()) {
        //
        // typical case.  wait for user to press a key and then 
        // restart
        //
        while(!BlGetKey());
    }
    else {
        // 
        // headless case.  present user with mini sac
        //
        while(!BlTerminalHandleLoaderFailure());
    }
    ArcRestart();

}

BOOLEAN
BlDetectHardware(
    IN ULONG DriveId,
    IN PCHAR LoadOptions
    )

/*++

Routine Description:

    Loads and runs NTDETECT.COM to populate the ARC configuration tree.

Arguments:

    DriveId - Supplies drive id where NTDETECT is located.

    LoadOptions - Supplies Load Options string to ntdetect.

Return Value:

    TRUE - NTDETECT successfully run.

    FALSE - Error

--*/

{

// Current Loader stack size is 8K, so make sure you do not
// blow that space. Make sure this is not smaller than 140.
#define LOAD_OPTIONS_BUFFER_SIZE 512

    ARC_STATUS Status;
    PCONFIGURATION_COMPONENT_DATA TempFwTree;
    ULONG TempFwHeapUsed;
    ULONG FileSize;
    ULONG DetectFileId;
    FILE_INFORMATION FileInformation;
    PUCHAR DetectionBuffer = (PUCHAR)DETECTION_LOADED_ADDRESS;
    PCHAR Options = NULL;
    CHAR Buffer[LOAD_OPTIONS_BUFFER_SIZE];
    LARGE_INTEGER SeekPosition;
    ULONG Read;
    BOOLEAN Success = FALSE;
    ULONG HeapStart;
    ULONG HeapSize;
    ULONG RequiredLength = 0;


    //
    // Check if the ntdetect.com was bundled as a data section
    // in the loader executable.
    //
    if (NtDetectStart == 0) {

        //
        // Now check if we have ntdetect.com in the root directory, if yes,
        // we will load it to predefined location and transfer control to
        // it.
        //

#if defined(ELTORITO)
        if (ElToritoCDBoot) {
            // we assume ntdetect.com is in the i386 directory
            Status = BlOpen( DriveId,
                             "\\i386\\ntdetect.com",
                             ArcOpenReadOnly,
                             &DetectFileId );
        } else {
#endif

        if (BlBootingFromNet
#if defined(REMOTE_BOOT)
            && NetworkBootRom
#endif // defined(REMOTE_BOOT)
            ) {

            strcpy(Buffer, NetBootPath);

#if defined(REMOTE_BOOT)
            //
            // This is the way it was done for remote BOOT, where we were
            // booting out of a client's machine directory.
            //
            strcat(Buffer, "BootDrive\\ntdetect.com");
#else
            //
            // This is how it is done for remote INSTALL, where we are
            // booting out of the templates directory under a setup directory.
            //
            strcat(Buffer, "ntdetect.com");
#endif // defined(REMOTE_BOOT)

            Status = BlOpen( DriveId,
                             Buffer,
                             ArcOpenReadOnly,
                             &DetectFileId );
        } else {
            Status = BlOpen( DriveId,
                             "\\ntdetect.com",
                             ArcOpenReadOnly,
                             &DetectFileId );
        }
#if defined(ELTORITO)
        }
#endif

        if (Status != ESUCCESS) {
#if DBG
            BlPrint("Error opening NTDETECT.COM, status = %x\n", Status);
            BlPrint("Press any key to continue\n");
#endif
            goto Exit;
        }

        //
        // Determine the length of the ntdetect.com file
        //

        Status = BlGetFileInformation(DetectFileId, &FileInformation);
        if (Status != ESUCCESS) {
            BlClose(DetectFileId);
#if DBG
            BlPrint("Error getting NTDETECT.COM file information, status = %x\n", Status);
            BlPrint("Press any key to continue\n");
#endif
            goto Exit;
        }

        FileSize = FileInformation.EndingAddress.LowPart;
        if (FileSize == 0) {
            BlClose(DetectFileId);
#if DBG
            BlPrint("Error: size of NTDETECT.COM is zero.\n");
            BlPrint("Press any key to continue\n");
#endif
            goto Exit;
        }

        SeekPosition.QuadPart = 0;
        Status = BlSeek(DetectFileId,
                        &SeekPosition,
                        SeekAbsolute);
        if (Status != ESUCCESS) {
            BlClose(DetectFileId);
#if DBG
            BlPrint("Error seeking to start of NTDETECT.COM file\n");
            BlPrint("Press any key to continue\n");
#endif
            goto Exit;
        }
        Status = BlRead( DetectFileId,
                         DetectionBuffer,
                         FileSize,
                         &Read );

        BlClose(DetectFileId);
        if (Status != ESUCCESS) {
#if DBG
            BlPrint("Error reading from NTDETECT.COM\n");
            BlPrint("Read %lx bytes\n",Read);
            BlPrint("Press any key to continue\n");
#endif
            goto Exit;
        }
    } else {

        // ntdetect.com was bundled in the loader image
        // as a data section. We will use it contents
        // instead of opening the file.
        RtlCopyMemory( DetectionBuffer, (PVOID)NtDetectStart, NtDetectEnd - NtDetectStart );
    }
    
    //
    // Set the heap start and size used by ntdetect
    //
    HeapStart = (TEMPORARY_HEAP_START - 0x10) * PAGE_SIZE;
    HeapSize = 0x10000; // 64K

    //
    // We need to pass NTDETECT pointers < 1Mb, so
    // use local storage off the stack if possible.  (which is
    // always < 1Mb.) If not possible (boot.ini is too big)
    // and we will add it to the heap used by ntdetect.com, therby
    // reducing the heap space used by ntdetect.com
    //
    if ( LoadOptions ) {
        // count the characters in LoadOptions + null terminator + 
        // room for " NOLEGACY" that might be appended later
        RequiredLength = strlen(LoadOptions) + strlen(" NOLEGACY") + 1;

        // check if the buffer on the stack is big enough
        if ( RequiredLength > LOAD_OPTIONS_BUFFER_SIZE ) {
            //
            // Buffer is too small. let move it to the 
            // end of the ntdetect heap
            //
            Options = (PCHAR)( HeapStart + HeapSize - RequiredLength );
            HeapSize -= RequiredLength;

            strcpy( Options, LoadOptions );
            
        } else {
            //
            // Load options will fit on the stack. copy them there
            //
            strcpy( Buffer, LoadOptions );
            Options = Buffer;
        }
    } else {
        //
        // No load options
        //
        Options = NULL;
    }

    //
    // Check whether we need to add the NOLEGACY option
    //
    if (BlDetectLegacyFreeBios()) {
        if (Options != NULL) {
            strcat(Options, " NOLEGACY");
        } else {
            strcpy(Buffer, " NOLEGACY");
            Options = Buffer;
        }
    }

    DETECT_HARDWARE((ULONG)HeapStart,
                    (ULONG)HeapSize,
                    (PVOID)&TempFwTree,
                    (PULONG)&TempFwHeapUsed,
                    (PCHAR)Options,
                    (Options != NULL) ? strlen(Options) : 0
                    );

    FwConfigurationTree = TempFwTree;

    Status = BlpMarkExtendedVideoRegionOffLimits();
    
    Success = (BOOLEAN)(Status == ESUCCESS);

Exit:

    //
    // Reinitialize the headless port - detect wipes it out.
    //
    BlInitializeHeadlessPort();

    return(Success);
}


VOID
DoGlobalInitialization(
    IN PBOOT_CONTEXT BootContextRecord
    )

/*++

Routine Description

    This routine calls all of the subsytem initialization routines.


Arguments:

    None

Returns:

    Nothing

--*/

{
    ARC_STATUS Status;

    //
    // Set base address of OS Loader image for the debugger.
    //

    OsLoaderBase = BootContextRecord->OsLoaderBase;
    OsLoaderExports = BootContextRecord->OsLoaderExports;

    //
    // Initialize memory.
    //

    Status = InitializeMemorySubsystem(BootContextRecord);
    if (Status != ESUCCESS) {
        BlPrint("InitializeMemory failed %lx\n",Status);
        while (1) {
        }
    }
    ExternalServicesTable=BootContextRecord->ExternalServicesTable;
    MachineType = BootContextRecord->MachineType;

    //
    // Turn the cursor off
    //

    HW_CURSOR(0,127);

    BlpResourceDirectory = (PUCHAR)(BootContextRecord->ResourceDirectory);
    BlpResourceFileOffset = (PUCHAR)(BootContextRecord->ResourceOffset);

    NtDetectStart = BootContextRecord->NtDetectStart;
    NtDetectEnd = BootContextRecord->NtDetectEnd;

    //
    // If this is an SDI boot, copy the address of the SDI image out of the
    // boot context record. SdiAddress is declared in boot\inc\ramdisk.h and
    // initialized to 0 in boot\lib\ramdisk.c.
    //

    if (BootContextRecord->FSContextPointer->BootDrive == 0x41) {
        SdiAddress = BootContextRecord->SdiAddress;
    }

    InitializeMemoryDescriptors ();
}


VOID
BlGetActivePartition(
    OUT PCHAR BootPartitionName
    )

/*++

Routine Description:

    Determine the ARC name for the partition NTLDR was started from

Arguments:

    BootPartitionName - Supplies a buffer where the ARC name of the
        partition will be returned.

Return Value:

    Name of the partition is in BootPartitionName.

    Must always succeed.
--*/

{
    UCHAR SectorBuffer[512];
    ARC_STATUS Status;
    ULONG FileId;
    ULONG Count;
    int i;

    //
    // The boot sector used to boot us is still in memory at 0x7c00.
    // The hidden sectors field in the BPB is pretty much guaranteed
    // to be intact, since all boot codes use that field and thus
    // are unlikely to have overwritten it.
    // We open each partition and compare the in-memory hidden sector count
    // at 0x7c1c to the hidden sector value in the BPB.
    //
    i = 1;
    do {

        sprintf(BootPartitionName,"multi(0)disk(0)rdisk(0)partition(%u)",i);

        Status = ArcOpen(BootPartitionName,ArcOpenReadOnly,&FileId);
        if(Status == ESUCCESS) {

            //
            // Read the first part of the partition.
            //
            Status = ArcRead(FileId,SectorBuffer,512,&Count);
            ArcClose(FileId);
            if((Status == ESUCCESS) && !memcmp(SectorBuffer+0x1c,(PVOID)0x7c1c,4)) {
                //
                // Found it, BootPartitionName is already set for return.
                //
                return;
            }

            Status = ESUCCESS;
        }

        i++;

    } while (Status == ESUCCESS);

    //
    // Run out of partitions without finding match. Fall back on partition 1.
    //
    strcpy(BootPartitionName,"multi(0)disk(0)rdisk(0)partition(1)");
}


BOOLEAN
BlIsElToritoCDBoot(
    UCHAR DriveNum
    )
{

    //
    // Note, even though args are short, they are pushed on the stack with
    // 32bit alignment so the effect on the stack seen by the 16bit real
    // mode code is the same as if we were pushing longs here.
    //
    // GET_ELTORITO_STATUS is 0 if we are in emulation mode

    if (DriveNum > 0x81) {
        if (!GET_ELTORITO_STATUS(FwDiskCache,DriveNum)) {
            return(TRUE);
        } else {
            return(FALSE);
        }
    } else {
        return(FALSE);
    }
}

#if defined(REMOTE_BOOT)
BOOLEAN
NetFindCSCPartitionName(
    )
{
    UCHAR FileName[80];
    UCHAR DiskName[80];
    UCHAR PartitionName[80];
    PUCHAR p;
    ULONG Part;
    ULONG FileId;
    ULONG DeviceId;

    if (NetBootSearchedForCSC) {
        return((BOOLEAN)strlen(NetBootCSCPartitionName));
    }

    if (!strlen(NetBootActivePartitionName)) {
        BlGetActivePartition(NetBootActivePartitionName);
    }

    strcpy(DiskName, NetBootActivePartitionName);
    p = strstr(DiskName, "partition");
    ASSERT( p != NULL );
    *p = '\0';

    Part = 1;
    while (TRUE) {

        sprintf(PartitionName, "%spartition(%u)", DiskName, Part);
        if (ArcOpen(PartitionName, ArcOpenReadOnly, &DeviceId) != ESUCCESS) {
            break;
        }
        ArcClose(DeviceId);

        sprintf(FileName,
                "%s%s",
                PartitionName,
                REMOTE_BOOT_IMIRROR_PATH_A REMOTE_BOOT_CSC_SUBDIR_A);

        if (ArcOpen(FileName, ArcOpenReadOnly, &FileId) == ESUCCESS) {
            ArcClose(FileId);
            NetBootSearchedForCSC = TRUE;
            strcpy(NetBootCSCPartitionName, PartitionName);
            return TRUE;
        }
        ArcClose(FileId);
        Part++;
    }

    strcpy(NetBootCSCPartitionName, NetBootActivePartitionName);
    return FALSE;
}
#endif // defined(REMOTE_BOOT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\flop.h ===
BOOLEAN
FcIsThisFloppyCached(
    IN PUCHAR Buffer
    );

VOID
FcCacheFloppyDisk(
    PBIOS_PARAMETER_BLOCK Bpb    
    );

VOID
FcUncacheFloppyDisk(
    VOID
    );

ARC_STATUS
FcReadFromCache(
    IN  ULONG  Offset,
    IN  ULONG  Length,
    OUT PUCHAR Buffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\flopcach.c ===
#include "arccodes.h"
#include "bootx86.h"
#include "flop.h"

#ifdef FLOPPY_CACHE

//#define FLOPPY_CACHE_DEBUG
#ifdef FLOPPY_CACHE_DEBUG
#define DBGOUT(x) BlPrint x
#else
#define DBGOUT(x)
#endif


#define MAX_FLOPPY_LEN 1474560

UCHAR CachedDiskImage[MAX_FLOPPY_LEN];
UCHAR CachedDiskBadSectorMap[(MAX_FLOPPY_LEN/512)];
UCHAR CachedDiskCylinderMap[80];
USHORT CachedDiskBytesPerSector;
USHORT CachedDiskSectorsPerTrack;
USHORT CachedDiskSectorsPerCylinder;
USHORT CachedDiskBytesPerTrack;
ULONG CachedDiskLastSector;

BOOLEAN DiskInCache = FALSE;


VOID
FcpCacheOneCylinder(
    IN USHORT Cylinder
    )
{
    PUCHAR pCache;
    unsigned track,sector;
    ULONG AbsoluteSector;
    ARC_STATUS Status;
    unsigned retry;

    //
    // Calculate the location in the cache image where this cylinder should go.
    //
    AbsoluteSector = Cylinder * CachedDiskSectorsPerCylinder;
    pCache = CachedDiskImage + (AbsoluteSector * CachedDiskBytesPerSector);

    //
    // Read track 0 and 1 of this cylinder.
    //
    for(track=0; track<2; track++) {

        DBGOUT(("FcCacheFloppyDisk: Cylinder %u head %u: ",Cylinder,track));

        retry = 0;

        do {

            Status = GET_SECTOR(
                        2,                          // int13 request = read
                        0,                          // disk number (a:)
                        (USHORT)track,              // head (0 or 1)
                        Cylinder,                   // track (usually 0-79)
                        1,                          // sector number (1-based)
                        CachedDiskSectorsPerTrack,  // number of sectors to read
                        LocalBuffer                 // buffer
                        );

            if(Status) {
                retry++;
                RESET_DISK(0,0,0,0,0,0,0);
            }

        } while(Status && (retry <= 3));

        if(Status) {

            DBGOUT(("Error!\n"));

            //
            // One or more sectors in the track were bad -- read individually.
            //
            for(sector=1; sector<=CachedDiskSectorsPerTrack; sector++) {
            
                DBGOUT(("                             Sector %u: ",sector));

                retry = 0;

                do {

                    Status = GET_SECTOR(
                                2,                      // int13 request = read
                                0,                      // disk number (a:)
                                (USHORT)track,          // head (0 or 1)
                                Cylinder,               // cylinder (usually 0-79)
                                (USHORT)sector,         // sector number (1-based)
                                1,                      // number of sectors to read
                                LocalBuffer             // buffer
                                );

                    if(Status) {
                        retry++;
                        RESET_DISK(0,0,0,0,0,0,0);
                    }

                } while(Status && (retry <= 2));

                if(Status) {

                    //
                    // Sector is bad.
                    //
                    CachedDiskBadSectorMap[AbsoluteSector] = TRUE;

                    DBGOUT(("bad\n"));

                } else {

                    //
                    // Sector is good.  Transfer the data into the cache buffer.
                    //
                    RtlMoveMemory(pCache,LocalBuffer,CachedDiskBytesPerSector);

                    DBGOUT(("OK\n"));
                }

                //
                // Advance to the next sector in the cache buffer.
                //
                pCache += CachedDiskBytesPerSector;
                AbsoluteSector++;
            }

        } else {
            //
            // Transfer the whole track we just successfully read
            // into the cached disk buffer.
            //
            RtlMoveMemory(pCache,LocalBuffer,CachedDiskBytesPerTrack);
            pCache += CachedDiskBytesPerTrack;
            AbsoluteSector += CachedDiskSectorsPerTrack;

            DBGOUT(("OK\n"));
        }
    }

    CachedDiskCylinderMap[Cylinder] = TRUE;
}


BOOLEAN
FcIsThisFloppyCached(
    IN PUCHAR Buffer
    )
{
    if(!DiskInCache) {
        return(FALSE);
    }

    //
    // Compare the first 512 bytes of the cached disk
    // to the buffer passed in.  If they are equal,
    // then the disk is already cached.
    //
    if(RtlCompareMemory(CachedDiskImage,Buffer,512) == 512) {
        return(TRUE);
    }

    //
    // Disk is not cached.
    //
    return(FALSE);
}
    

VOID
FcUncacheFloppyDisk(
    VOID
    )
{
    DiskInCache = FALSE;
}


VOID
FcCacheFloppyDisk(
    PBIOS_PARAMETER_BLOCK Bpb    
    )
{
    //
    // Indicate that the cache is invalid.
    //
    DiskInCache = FALSE;

    //
    // Sanity check the bpb.
    // Ensure it's a standard 1.2 meg or 1.44 meg disk.
    //
    if((Bpb->Heads != 2) || (Bpb->BytesPerSector != 512)
    || ((Bpb->SectorsPerTrack != 15) && (Bpb->SectorsPerTrack != 18))
    || ((Bpb->Sectors != 2880) && (Bpb->Sectors != 2400)))
    {
        DBGOUT(("FcCacheFloppyDisk: floppy not standard 1.2 or 1.44 meg disk\n"));
        return;
    }

    //
    // Grab a buffer under the 1 meg line.
    // The buffer must be big enough to hold one whole track of 
    // a 1.44 meg floppy.
    //

    if(LocalBuffer == NULL) {
        LocalBuffer = FwAllocateHeap(18 * 512);
        if(LocalBuffer == NULL) {
            DBGOUT(("FcCacheFloppyDisk: Couldn't allocate local buffer\n"));
            return;
        }
    }

    DBGOUT(("FcCacheFloppyDisk: LocalBuffer @ %lx\n",LocalBuffer));

    //
    // The disk is one we can cache.  Indicate that a disk is cached
    // and mark all sectors good and all tracks not present.
    //
    DiskInCache = TRUE;
    RtlZeroMemory(CachedDiskBadSectorMap,sizeof(CachedDiskBadSectorMap));
    RtlZeroMemory(CachedDiskCylinderMap,sizeof(CachedDiskCylinderMap));
    CachedDiskSectorsPerTrack = Bpb->SectorsPerTrack;
    CachedDiskSectorsPerCylinder = Bpb->Heads * Bpb->SectorsPerTrack;
    CachedDiskBytesPerSector = Bpb->BytesPerSector;

    //
    // Calculate the number of bytes in a Track on the floppy.
    //
    CachedDiskBytesPerTrack = CachedDiskSectorsPerTrack * Bpb->BytesPerSector;

    //
    // Calculate the number of tracks.
    //
    CachedDiskLastSector = Bpb->Sectors-1;

    DBGOUT(("FcCacheFloppyDisk: Caching disk, %u sectors per track\n",CachedDiskSectorsPerTrack));

    FcpCacheOneCylinder(0);
}



ARC_STATUS
FcReadFromCache(
    IN  ULONG  Offset,
    IN  ULONG  Length,
    OUT PUCHAR Buffer
    )
{
    ULONG FirstSector,LastSector,Sector;
    ULONG FirstCyl,LastCyl,cyl;

    if(!Length) {
        return(ESUCCESS);
    }

    if(!DiskInCache) {
        return(EINVAL);
    }

    //
    // Determine the first sector in the transfer.
    //
    FirstSector = Offset / 512;

    //
    // Determine and validate the last sector in the transfer.
    //
    LastSector = FirstSector + ((Length-1)/512);

    if(LastSector > CachedDiskLastSector) {
        return(E2BIG);
    }

    //
    // Determine the first and last cylinders involved in the transfer.
    //
    FirstCyl = FirstSector / CachedDiskSectorsPerCylinder;
    LastCyl  = LastSector / CachedDiskSectorsPerCylinder;

    //
    // Make sure all these cylinders are cached.
    //
    for(cyl=FirstCyl; cyl<=LastCyl; cyl++) {
        if(!CachedDiskCylinderMap[cyl]) {
            FcpCacheOneCylinder((USHORT)cyl);
        }
    }

    //
    // Determine if any of the sectors in the transfer range 
    // are marked bad in the sector map.
    // 
    // If so, return an i/o error.
    //
    for(Sector=FirstSector; Sector<=LastSector; Sector++) {
        if(CachedDiskBadSectorMap[Sector]) {
            return(EIO);
        }
    }

    //
    // Transfer the data into the caller's buffer.
    //
    RtlMoveMemory(Buffer,CachedDiskImage+Offset,Length);

    return(ESUCCESS);
}

#endif // def FLOPPY_CACHE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\ixfwhal.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixfwhal.h

Abstract:

    This header file defines the private Hardware Architecture Layer (HAL)
    Intel x86 specific interfaces, defines and structures.

Author:

    Jeff Havens (jhavens) 20-Jun-91


Revision History:

--*/

#ifndef _IXHALP_
#define _IXHALP_


//
// The MAXIMUM_MAP_BUFFER_SIZE defines the maximum map buffers which the system
// will allocate for devices which require phyically contigous buffers.
//

#define MAXIMUM_MAP_BUFFER_SIZE  0x1000000

//
// Define the initial buffer allocation size for a map buffers.
//

#define INITIAL_MAP_BUFFER_SIZE 0x20000

//
// Define the incremental buffer allocation for a map buffers.
//

#define INCREMENT_MAP_BUFFER_SIZE 0x10000

//
// Define the maximum number of map registers that can be requested at one time
// if actual map registers are required for the transfer.
//

#define MAXIMUM_ISA_MAP_REGISTER  16

//
// Define the maximum physical address which can be handled by an Isa card.
//

#define MAXIMUM_PHYSICAL_ADDRESS 0x01000000

//
// Define adapter object structure.
//

typedef struct _ADAPTER_OBJECT {
    CSHORT Type;
    CSHORT Size;
    ULONG MapRegistersPerChannel;
    PVOID AdapterBaseVa;
    PVOID MapRegisterBase;
    ULONG NumberOfMapRegisters;
    UCHAR ChannelNumber;
    UCHAR AdapterNumber;
    UCHAR AdapterMode;
    UCHAR ExtendedModeFlags;
    USHORT DmaPortAddress;
    BOOLEAN NeedsMapRegisters;
    BOOLEAN IsaDevice;
    BOOLEAN MasterDevice;
    BOOLEAN Width16Bits;
    BOOLEAN AdapterInUse;
    PUCHAR PagePort;
} ADAPTER_OBJECT;

//
// Define map register translation entry structure.
//

typedef struct _TRANSLATION_ENTRY {
    PVOID VirtualAddress;
    ULONG PhysicalAddress;
    ULONG Index;
} TRANSLATION_ENTRY, *PTRANSLATION_ENTRY;

//
// Define External data structures.
//

//
// Some devices require a phyicially contiguous data buffers for DMA transfers.
// Map registers are used give the appearance that all data buffers are
// contiguous.  In order to pool all of the map registers a master
// adapter object is used.  This object is allocated and saved internal to this
// file.  It contains a bit map for allocation of the registers and a queue
// for requests which are waiting for more map registers.  This object is
// allocated during the first request to allocate an adapter which requires
// map registers.
//
// In this system, the map registers are translation entries which point to
// map buffers.  Map buffers are physically contiguous and have physical memory
// addresses less than 0x01000000.  All of the map registers are allocated
// initialially; however, the map buffers are allocated base in the number of
// adapters which are allocated.
//
// If the master adapter is NULL in the adapter object then device does not
// require any map registers.
//

extern PADAPTER_OBJECT MasterAdapterObject;

extern POBJECT_TYPE IoAdapterObjectType;

extern BOOLEAN LessThan16Mb;

//
// Define function prototypes.
//

BOOLEAN
HalpGrowMapBuffers(
    PADAPTER_OBJECT AdapterObject,
    ULONG Amount
    );

PADAPTER_OBJECT
IopAllocateAdapter(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID MapRegisterBase
    );

VOID
HalpInitializeDisplay(
    IN PUSHORT VideoBufferAddress
    );

#endif // _IXHALP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\disp_gr.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    disp_gr.c

Abstract:

    This file was created from \private\windows\setup\textmode\splib\ixdispj.c.
    This file contains routines to display MBCS characters to the Graphics
    VRAM.

Author:

    v-junm (Compaq Japan)
    hideyukn
    tedm

Environment:

    Kernel mode only.

Revision History:

--*/

#include "bootx86.h"
#include "displayp.h"
#include "bootfont.h"

#include "vmode.h"

//
// Physical video attributes.
//
#define VIDEO_BUFFER_VA 0xa0000
#define VIDEO_BYTES_PER_SCAN_LINE   80
#define VIDEO_WIDTH_PIXELS          640
#define VIDEO_HEIGHT_SCAN_LINES     480
#define VIDEO_SIZE_BYTES            (VIDEO_BYTES_PER_SCAN_LINE*VIDEO_HEIGHT_SCAN_LINES)


PUCHAR GrVp = (PUCHAR)VIDEO_BUFFER_VA;

//
// Screen width and height in half-character cells
// and macro to determine total number of characters
// displayed on the screen at once.
//
unsigned ScreenWidthCells,ScreenHeightCells;
#define SCREEN_SIZE_CELLS   (ScreenWidthCells*ScreenHeightCells)

//
// Globals:
//
// CharacterCellHeight is the number of scan lines total in a character.
// It includes any top or bottom fill lines.
//
// CharacterImageHeight is the number of scan lines in the image of a character.
// This is dependent on the font. Characters may be padded top and bottom.
//
// NOTE: All of this code assumes the font's single-byte characters are 8 bits wide
// and the font's double-byte characters are 16 bits wide!
//
unsigned CharacterCellHeight;
unsigned CharacterImageHeight;
unsigned CharacterTopPad;
unsigned CharacterBottomPad;

#define VIDEO_BYTES_PER_TEXT_ROW    (VIDEO_BYTES_PER_SCAN_LINE*CharacterCellHeight)

//
// Values describing the number of each type of character in the font,
// and pointers to the base of the glyphs.
//
unsigned SbcsCharCount;
unsigned DbcsCharCount;
PUCHAR SbcsImages;
PUCHAR DbcsImages;

//
// Values to be passed to GrDisplayMBCSChar
//
#define SBCSWIDTH 8
#define DBCSWIDTH 16

//
// Lead byte table. Read from bootfont.bin.
//
UCHAR LeadByteTable[2*(MAX_DBCS_RANGE+1)];

//
// keeps track as to whether to reset the 
// display in TextGrTerminate().
//
BOOLEAN AllowGraphicsReset = TRUE;


VOID
GrDisplayMBCSChar(
    IN PUCHAR   image,
    IN unsigned width,
    IN UCHAR    top,
    IN UCHAR    bottom
    );

PUCHAR
GrGetDBCSFontImage(
    USHORT Code
    );

PUCHAR
GrGetSBCSFontImage(
    UCHAR Code
    );


VOID
GrWriteSBCSChar(
    IN UCHAR c
    )

/*++

Routine Description:

    Displays a character at the current cursor position.  ONLY SBCS
    characters can be displayed using this routine.

Arguments:

    c - character to display.

Return Value:

    None.

--*/

{
    unsigned u;
    PUCHAR pImage;
    UCHAR temp;

    switch(c) {

    case '\n':
        if(TextRow == (ScreenHeightCells-1)) {
            TextGrScrollDisplay();
            TextSetCursorPosition(0,TextRow);
        } else {
            TextSetCursorPosition(0,TextRow+1);
        }
        break;

    case '\r':
        break;          // ignore

    case '\t':
        temp = ' ';
        u = 8 - (TextColumn % 8);
        while(u--) {
            TextGrCharOut(&temp);
        }
        TextSetCursorPosition(TextColumn+u,TextRow);
        break;

    default:
        //
        // Assume it's a valid SBCS character.
        // Get font image for SBCS char.
        //
        pImage = GrGetSBCSFontImage(c);

        //
        // Display the SBCS char. Check for special graphics characters.
        // Add top and bottom extra pixels accordingly (otherwise the grids
        // don't connect properly, because of top and bottom spacing).
        //
        if ( c == 0x2 || c == 0x1 || c == 0x16 )
            GrDisplayMBCSChar( pImage, SBCSWIDTH, 0x00, 0x66 );
        else if ( c == 0x4 || c == 0x3 || c == 0x15 )
            GrDisplayMBCSChar( pImage, SBCSWIDTH, 0x66, 0x00 );
        else if ( c == 0x5 || c == 10 || c == 0x17 || c == 0x19 )
            GrDisplayMBCSChar( pImage, SBCSWIDTH, 0x66, 0x66 );
        else
            GrDisplayMBCSChar( pImage, SBCSWIDTH, 0x00, 0x00 );

    }
}


VOID
GrDisplayMBCSChar(
    IN PUCHAR   image,
    IN unsigned width,
    IN UCHAR    top,
    IN UCHAR    bottom
    )

/*++

Routine Description:

    Displays a DBCS or a SBCS character at the current cursor
    position.

Arguments:

    image - SBCS or DBCS font image.
    width - Width in bits of character image (must be SBCSWIDTH pr DBCSWIDTH).
    top   - Character to fill the top extra character line(s).
    bottom- Character to fill the bottom extra character line(s).

Return Value:

    FALSE if image points to NULL,
    else TRUE.

--*/

{
    unsigned i;

    //
    // Validate parameter
    //
    if(image == NULL) {
        return;
    }


    //
    // There are TOP_EXTRA lines at the top that we need to skip (background color).
    //
    for(i=0; i<CharacterTopPad; i++) {

        //
        // If DBCS char, we need to clear 2 bytes.
        //
        if(width == DBCSWIDTH) {
            *GrVp++ = top;
        }
        *GrVp++ = top;

        //
        // Position pointer at next scan line
        // for the font image.
        //
        GrVp += VIDEO_BYTES_PER_SCAN_LINE - (width/SBCSWIDTH);
    }

    //
    // Display full height of DBCS or SBCS char.
    //
    for(i=0; i<CharacterImageHeight; i++) {

        //
        // If DBCS char, need to display 2 bytes,
        // so display first byte here.
        //
        if(width == DBCSWIDTH) {
            *GrVp++ = *image++;
        }

        //
        // Display 2nd byte of DBCS char or the
        // first and only byte of SBCS char.
        //
        *GrVp++ = *image++;

        //
        // Increment GrVP to display location of
        // next row of font image.
        //
        GrVp += VIDEO_BYTES_PER_SCAN_LINE - (width/SBCSWIDTH);
    }

    //
    // There are BOT_EXTRA lines at the bottom that we need to fill with the
    // background color.
    //
    for(i=0; i<CharacterBottomPad; i++) {

        //
        // If DBCS char, need to clear 2 bytes
        //
        if(width == DBCSWIDTH) {
            *GrVp++ = bottom;
        }
        *GrVp++ = bottom;

        //
        // Position pointer at next scan line
        // for the font image.
        //
        GrVp += VIDEO_BYTES_PER_SCAN_LINE - (width/SBCSWIDTH);
    }

    //
    // Increment cursor and video pointer
    //
    if(width == DBCSWIDTH) {
        TextSetCursorPosition(TextColumn+2,TextRow);
    } else {
        TextSetCursorPosition(TextColumn+1,TextRow);
    }
}


unsigned
GrWriteMBCSString(
    IN PUCHAR   String,
    IN unsigned MaxChars
    )

/*++

Routine Description:

    Displays a mixed byte string at the current cursor
    position.

Arguments:

    String - supplies pointer to asciz string.

    MaxBytes - supplies the maximum number of characters to be written.

Return Value:

    Number of bytes written.

--*/

{
    PUCHAR  pImage;
    USHORT DBCSChar;
    unsigned BytesWritten;

    BytesWritten = 0;

    //
    // While string is not NULL,
    // get font image and display it.
    //
    while(*String && MaxChars--)  {

        //
        // Determine if char is SBCS or DBCS, get the correct font image,
        // and display it.
        //
        if(GrIsDBCSLeadByte(*String))  {
            DBCSChar = *String++ << 8;
            DBCSChar = DBCSChar | *String++;
            pImage = GrGetDBCSFontImage(DBCSChar);
            GrDisplayMBCSChar(pImage,DBCSWIDTH,0x00,0x00);
            BytesWritten++;
        } else {
            GrWriteSBCSChar(*String++);
        }
        BytesWritten++;
    }

    return(BytesWritten);
}


BOOLEAN
GrIsDBCSLeadByte(
    IN UCHAR c
    )

/*++

Routine Description:

    Checks to see if a char is a DBCS leadbyte.

Arguments:

    c - char to check if leadbyte or not.

Return Value:

    TRUE  - Leadbyte.
    FALSE - Non-Leadbyte.

--*/

{
    int i;

    //
    // Check to see if char is in leadbyte range.
    // Note if (CHAR)(0) is a valid leadbyte,
    // this routine will fail.
    //

    for(i=0; LeadByteTable[i]; i+=2)  {
        if((LeadByteTable[i] <= c) && (LeadByteTable[i+1] >= c)) {
            return(TRUE);
        }
    }

    return(FALSE);
}


PUCHAR
GrGetDBCSFontImage(
    USHORT Code
    )

/*++

Routine Description:

    Gets the font image for DBCS char.

Arguments:

    Code - DBCS char code.

Return Value:

    Pointer to font image, or else NULL.

--*/

{
    int Min,Max,Mid;
    int Multiplier;
    int Index;
    USHORT code;

    Min = 0;
    Max = DbcsCharCount;
    // multiplier = 2 (for index) +
    //              2 * height +
    //              2 (for unicode encoding)
    //
    Multiplier = 2 + (2*CharacterImageHeight) + 2;

    //
    // Do a binary search for the image.
    // Format of table:
    //   First 2 bytes contain the DBCS char code.
    //   Next (2 * CharacterImageHeight) bytes are the char image.
    //   Next 2 bytes are for unicode version.
    //
    while(Max >= Min)  {
        Mid = (Max + Min) / 2;
        Index = Mid*Multiplier;
        code = (DbcsImages[Index] << 8) | DbcsImages[Index+1];

        if(Code == code) {
            return(DbcsImages+Index+2);
        }

        if(Code < code) {
            Max = Mid - 1;
        } else {
            Min = Mid + 1;
        }
    }

    //
    // ERROR: No image found.
    //
    return(NULL);
}

//
// This array is used to override a glyph returned by GrGetSBCSFontImage.
// Basically, if the user is asking for one of the first 6 glyphs from
// the SBCS map, we'll intercept the call and return the value from this
// array.
//
// This is because there was a previous assumption that the first 6 glyphs
// in an SBCS image were drawing characters.  The same 6 drawing characters.
// That means we just introduced an external reliance on every bootfont.bin.
// Better to keep the dependence right here.
//
UCHAR SbcsRemapper[6][18] = {
  // SBCS codes (16 bytes worth)                                                                     Unicode value
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x60, 0x60, 0x67, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x25, 0x54},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x06, 0x06, 0xe6, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x25, 0x57},
    {0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x67, 0x60, 0x60, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x5A},
    {0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0xe6, 0x06, 0x06, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x5D},
    {0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x25, 0x51},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x50}
};

    
PUCHAR
GrGetSBCSFontImage(
    UCHAR Code
    )

/*++

Routine Description:

    Gets the font image for SBCS char.

Arguments:

    Code - SBCS char code.

Return Value:

    Pointer to font image, or else NULL.

--*/

{
    int Max,Min,Mid;
    int Multiplier;
    int Index;


    //
    // WARNING: Nauseating hack!!
    // We're going to special case some drawing characters here because
    // these graphics characters may not exist in every locale.  This is
    // where we'll supercede some of the bootfont.bin lookups with the
    // glyphs we really want.
    //
    // We're going to remap some low SBCS values to some specific drawing
    // glyphs.
    //
    // 1: "top left corner" double-line.  Corresponds to ANSI code 0xC9 and unicode 0x2554
    // ----
    // | --
    // | |
    // | |
    //
    //
    // 2. "top right corner" double-line.  Corresponds to ANSI code 0xBB and unicode 0x2557
    // ----
    // -- |
    //  | |
    //  | |
    //
    // 3. "bottom left corner".  Corresponds to ANSI code 0xC8 and unicode 0x255A
    // 4. "bottom right corner".  Corresponds to ANSI code 0xBC and unicode 0x255D
    // 5. "double verticl line".  Corresponds to ANSI code 0xBA and unicode 0x2551
    // 6. "double horizontal line".  Corresponds to ANSI code 0xCD and unicode 0x2550
    //
    if( (Code >= 0x1) && (Code <= 0x6) ) {
        return SbcsRemapper[Code-1];
    }


    Min = 0;
    Max = SbcsCharCount;
    // multiplier = 1 (for index) +
    //              height +
    //              2 (for unicode encoding)
    //
    Multiplier = 1 + (CharacterImageHeight) + 2;


    //
    // Do a binary search for the image.
    // Format of table:
    //   First byte contains the SBCS char code.
    //   Next (CharacterImageHeight) bytes are the char image.
    //   Next 2 bytes are for unicode version.
    //
    while(Max >= Min) {
        Mid = (Max + Min) / 2;
        Index = Mid*Multiplier;

        if(Code == SbcsImages[Index]) {
            return(SbcsImages+Index+1);
        }

        if(Code < SbcsImages[Index]) {
            Max = Mid - 1;
        } else {
            Min = Mid + 1;
        }
    }

    //
    // ERROR: No image found.
    //
    return(NULL);
}


//
// Need to turn off optimization for this
// routine.  Since the write and read to
// GVRAM seem useless to the compiler.
//

#pragma optimize( "", off )

VOID
TextGrSetCurrentAttribute(
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Sets the attribute by setting up various VGA registers.
    The comments only say what registers are set to what, so
    to understand the logic, follow the code while looking at
    Figure 5-5 of PC&PS/2 Video Systems by Richard Wilton.
    The book is published by Microsoft Press.

Arguments:

    Attribute - New attribute to set to.
    Attribute:
        High nibble - background attribute.
        Low  nibble - foreground attribute.

Return Value:

    Nothing.

--*/

{
    UCHAR   temp = 0;

    //
    // Address of GVRAM off the screen.
    //

    PUCHAR  OffTheScreen = (PUCHAR)(0xa9600);

    union WordOrByte {
        struct Word { unsigned short    ax; } x;
        struct Byte { unsigned char     al, ah; } h;
    } regs;

    //
    // Reset Data Rotate/Function Select
    // regisger.
    //

    outpw( 0x3ce, 0x3 );        // Need to reset Data Rotate/Function Select.

    //
    // Set Enable Set/Reset to
    // all (0f).
    //

    outpw( 0x3ce, 0xf01 );

    //
    // Put background color into Set/Reset register.
    // This is done to put the background color into
    // the latches later.
    //

    regs.x.ax = (unsigned short)(Attribute & 0x0f0) << 4;
    outpw( 0x3ce, regs.x.ax );      // Put BLUE color in Set/Reset register.

    //
    // Put Set/Reset register value into GVRAM
    // off the screen.
    //

    *OffTheScreen = temp;

    //
    // Read from screen, so the latches will be
    // updated with the background color.
    //

    temp = *OffTheScreen;

    //
    // Set Data Rotate/Function Select register
    // to be XOR.
    //

    outpw( 0x3ce, 0x1803 );

    //
    // XOR the foreground and background color and
    // put it in Set/Reset register.
    //

    regs.h.ah = (Attribute >> 4) ^ (Attribute & 0x0f);
    regs.h.al = 0;
    outpw( 0x3ce, regs.x.ax );

    //
    // Put Inverse(~) of the XOR of foreground and
    // ground attribute into Enable Set/Reset register.
    //

    regs.x.ax = ~regs.x.ax & 0x0f01;
    outpw( 0x3ce, regs.x.ax );
}

//
// Turn optimization on again.
//

#pragma optimize( "", on )


VOID
TextGrPositionCursor(
    USHORT Row,
    USHORT Column
    )

/*++

Routine Description:

    Sets the position of the soft cursor. That is, it doesn't move the
    hardware cursor but sets the location of the next write to the
    screen.

Arguments:

    Row - Row coordinate of where character is to be written.

    Column - Column coordinate of where character is to be written.

Returns:

    Nothing.

--*/

{
    if(Row >= ScreenHeightCells) {
        Row = (USHORT)ScreenHeightCells-1;
    }

    if(Column >= ScreenWidthCells) {
        Column = (USHORT)ScreenWidthCells-1;
    }

    GrVp = (PUCHAR)VIDEO_BUFFER_VA + (Row * VIDEO_BYTES_PER_TEXT_ROW) + Column;
}


VOID
TextGrStringOut(
    IN PUCHAR String
    )
{
    GrWriteMBCSString(String,(unsigned)(-1));
}


PUCHAR
TextGrCharOut(
    PUCHAR pc
    )

/*++

Routine Description:

    Writes a character on the display at the current position.
    Newlines and tabs are interpreted and acted upon.

Arguments:

    pc - pointer to mbcs character to write.

Returns:

    pointer to next character

--*/

{
    return(pc + GrWriteMBCSString(pc,1));
}


VOID
TextGrFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    )

/*++

Routine Description:

    Changes the screen attribute starting at the current cursor position.
    The cursor is not moved.

Arguments:

    Attribute - Supplies the new attribute

    Length - Supplies the length of the area to change (in bytes)

Return Value:

    None.

--*/

{
    UCHAR OldAttribute;
    unsigned i;
    ULONG x,y;
    PUCHAR pImage;

    //
    // Save the current attribute and set the attribute to the
    // character desired by the caller.
    //
    TextGetCursorPosition(&x,&y);
    OldAttribute = TextCurrentAttribute;
    TextSetCurrentAttribute(Attribute);

    //
    // Dirty hack: just write spaces into the area requested by the caller.
    //
    pImage = GrGetSBCSFontImage(' ');
    for(i=0; i<Length; i++) {
        GrDisplayMBCSChar(pImage,SBCSWIDTH,0x00,0x00);
    }

    //
    // Restore the current attribute.
    //
    TextSetCurrentAttribute(OldAttribute);
    TextSetCursorPosition(x,y);
}


VOID
TextGrClearToEndOfLine(
    VOID
    )

/*++

Routine Description:

    Clears from the current cursor position to the end of the line
    by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    unsigned u;
    ULONG OldX,OldY;
    UCHAR temp;

    //
    // Fill with blanks up to char before cursor position.
    //
    temp = ' ';
    TextGetCursorPosition(&OldX,&OldY);
    for(u=TextColumn; u<ScreenWidthCells; u++) {
        TextGrCharOut(&temp);
    }
    TextSetCursorPosition(OldX,OldY);
}


VOID
TextGrClearFromStartOfLine(
    VOID
    )

/*++

Routine Description:

    Clears from the start of the line to the current cursor position
    by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    unsigned u;
    ULONG OldX,OldY;
    UCHAR temp = ' ';

    //
    // Fill with blanks up to char before cursor position.
    //
    TextGetCursorPosition(&OldX,&OldY);
    TextSetCursorPosition(0,OldY);
    for(u=0; u<TextColumn; u++) {
        TextGrCharOut(&temp);
    }
    TextSetCursorPosition(OldX,OldY);
}

VOID
TextGrClearToEndOfDisplay(
    VOID
    )

/*++

Routine Description:

    Clears from the current cursor position to the end of the video
    display by writing blanks with the current video attribute.
    The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/
{
    unsigned i;
    //
    // Clear current line
    //
    TextGrClearToEndOfLine();

    //
    // Clear the remaining lines
    //
    for(i=(TextRow+1)*VIDEO_BYTES_PER_TEXT_ROW; i<VIDEO_SIZE_BYTES; i++) {
        ((PUCHAR)VIDEO_BUFFER_VA)[i] = 0x00;
    }
}


VOID
TextGrClearDisplay(
    VOID
    )

/*++

Routine Description:

    Clears the text-mode video display by writing blanks with
    the current video attribute over the entire display.

Arguments:

    None

Returns:

    Nothing

--*/

{
    unsigned i;

    //
    // Clear screen.
    //
    for(i=0; i<VIDEO_SIZE_BYTES; i++) {
        ((PUCHAR)VIDEO_BUFFER_VA)[i] = 0x00;
    }
}


VOID
TextGrScrollDisplay(
    VOID
    )

/*++

Routine Description:

    Scrolls the display up one line. The cursor position is not changed.

Arguments:

    None

Returns:

    Nothing

--*/

{
    PUCHAR Source,Dest;
    unsigned n,i;
    ULONG OldX,OldY;
    UCHAR temp = ' ';

    Source = (PUCHAR)(VIDEO_BUFFER_VA) + VIDEO_BYTES_PER_TEXT_ROW;
    Dest = (PUCHAR)VIDEO_BUFFER_VA;

    n = VIDEO_BYTES_PER_TEXT_ROW * (ScreenHeightCells-1);

    for(i=0; i<n; i++) {
        *Dest++ = *Source++;
    }

    //
    // Write blanks in the bottom line, using the current attribute.
    //
    TextGetCursorPosition(&OldX,&OldY);

    TextSetCursorPosition(0,ScreenHeightCells-1);
    for(i=0; i<ScreenWidthCells; i++) {
        TextGrCharOut(&temp);
    }

    TextSetCursorPosition(OldX,OldY);
}


UCHAR GrGraphicsChars[GraphicsCharMax] = { 1, 2, 3, 4, 5, 6 };
// UCHAR GrGraphicsChars[GraphicsCharMax] = { '','','','','','' };

UCHAR
TextGrGetGraphicsChar(
    IN GraphicsChar WhichOne
    )
{
    return(GrGraphicsChars[WhichOne]);
}


VOID
TextGrInitialize(
    IN ULONG DiskId,
    OUT PULONG ImageLength
    )
{
    ULONG FileId;
    ARC_STATUS Status;
    PUCHAR FontImage;
    ULONG BytesRead;
    BOOTFONTBIN_HEADER FileHeader;
    LARGE_INTEGER SeekOffset;
    ULONG SbcsSize,DbcsSize;

    if (ImageLength) {
        *ImageLength = 0;
    }
    
    //
    // Attempt to open bootfont.bin. If this fails, then boot in single-byte charset mode.
    //
    if (BlBootingFromNet
#if defined(REMOTE_BOOT)
        && NetworkBootRom
#endif // defined(REMOTE_BOOT)
        ) {
        CHAR Buffer[129];
        strcpy(Buffer, NetBootPath);
        strcat(Buffer, "BOOTFONT.BIN");
        Status = BlOpen(DiskId,Buffer,ArcOpenReadOnly,&FileId);
    } else {
        Status = BlOpen(DiskId,"\\BOOTFONT.BIN",ArcOpenReadOnly,&FileId);
    }
    if(Status != ESUCCESS) {
        goto clean0;
    }

    //
    // Read in the file header and check some values.
    // We enforce the width of 8/16 here. If this is changed code all over the
    // rest of this module must also be changed.
    //
    Status = BlRead(FileId,&FileHeader,sizeof(BOOTFONTBIN_HEADER),&BytesRead);
    if((Status != ESUCCESS)
    || (BytesRead != sizeof(BOOTFONTBIN_HEADER))
    || (FileHeader.Signature != BOOTFONTBIN_SIGNATURE)
    || (FileHeader.CharacterImageSbcsWidth != 8)
    || (FileHeader.CharacterImageDbcsWidth != 16)
    ) {
        goto clean1;
    }

    //
    // Calculate the amount of memory needed to hold the sbcs and dbcs
    // character entries. Each sbcs entry is 1 byte for the ascii value
    // followed by n bytes for the image itself. We assume a width of 8 pixels.
    // For dbcs chars each entry is 2 bytes for the codepoint and n bytes
    // for the image itself. We assume a width of 16 pixels.
    //
    // Add in an extra 2 bytes per entry for the ending unicode value of the SBCS/DBCS
    // character.
    //
    // Also perform further validation on the file by comparing the sizes
    // given in the header against a size we calculate.
    //
    SbcsSize = FileHeader.NumSbcsChars * (FileHeader.CharacterImageHeight + 1 + 2);
    DbcsSize = FileHeader.NumDbcsChars * ((2 * FileHeader.CharacterImageHeight) + 2 + 2);

    if((SbcsSize != FileHeader.SbcsEntriesTotalSize)
    || (DbcsSize != FileHeader.DbcsEntriesTotalSize)) {
        goto clean1;
    }

    //
    // save off the image length argument if requested
    //
    if (ImageLength) {
        (*ImageLength) = sizeof(BOOTFONTBIN_HEADER) + SbcsSize + DbcsSize;
    }

    //
    // Allocate memory to hold the font. We use FwAllocatePool() because
    // that routine uses a separate heap that was inititialized before the
    // high-level Bl memory system was initialized, and thus is safe.
    //
    FontImage = FwAllocatePool(SbcsSize+DbcsSize);
    if(!FontImage) {
        goto clean1;
    }

    //
    // The entries get read into the base of the region we carved out.
    // The dbcs images get read in immediately after that.
    //
    SbcsImages = FontImage;
    DbcsImages = SbcsImages + FileHeader.SbcsEntriesTotalSize;

    //
    // Read in the sbcs entries.
    //
    SeekOffset.HighPart = 0;
    SeekOffset.LowPart = FileHeader.SbcsOffset;
    if((BlSeek(FileId,&SeekOffset,SeekAbsolute) != ESUCCESS)
    || (BlRead(FileId,SbcsImages,FileHeader.SbcsEntriesTotalSize,&BytesRead) != ESUCCESS)
    || (BytesRead != FileHeader.SbcsEntriesTotalSize)) {
        goto clean2;
    }

    //
    // Read in the dbcs entries.
    //
    SeekOffset.HighPart = 0;
    SeekOffset.LowPart = FileHeader.DbcsOffset;
    if((BlSeek(FileId,&SeekOffset,SeekAbsolute) != ESUCCESS)
    || (BlRead(FileId,DbcsImages,FileHeader.DbcsEntriesTotalSize,&BytesRead) != ESUCCESS)
    || (BytesRead != FileHeader.DbcsEntriesTotalSize)) {
        goto clean2;
    }

    //
    // We're done with the file now.
    //
    BlClose(FileId);

    //
    // Set up various values used for displaying the font.
    //
    DbcsLangId = FileHeader.LanguageId;
    CharacterImageHeight = FileHeader.CharacterImageHeight;
    CharacterTopPad = FileHeader.CharacterTopPad;
    CharacterBottomPad = FileHeader.CharacterBottomPad;
    CharacterCellHeight = CharacterImageHeight + CharacterTopPad + CharacterBottomPad;
    SbcsCharCount = FileHeader.NumSbcsChars;
    DbcsCharCount = FileHeader.NumDbcsChars;
    //
    // throughout the file, row/columns are passed around as ushorts,
    // and compared to ScreenHeight/Width.  
    // ensure ScreenWidth/Height are bounded by the size of a USHORT
    //
    ScreenWidthCells = TRUNCATE_SIZE_AT_USHORT_MAX(VIDEO_WIDTH_PIXELS / FileHeader.CharacterImageSbcsWidth);
    ScreenHeightCells = TRUNCATE_SIZE_AT_USHORT_MAX(VIDEO_HEIGHT_SCAN_LINES / CharacterCellHeight);

    RtlMoveMemory(LeadByteTable,FileHeader.DbcsLeadTable,(MAX_DBCS_RANGE+1)*2);

    //
    // Switch the display into 640x480 graphics mode and clear it.
    // We're done.
    //
    HW_CURSOR(0x80000000,0x12);
    TextClearDisplay();
    return;

clean2:
    //
    // Want to free the memory we allocated but there's no routine to do it
    //
    //FwFreePool();
clean1:
    //
    // Close the font file.
    //
    BlClose(FileId);
clean0:
    return;
}


VOID
TextGrTerminate(
    VOID
    )
{
    if(DbcsLangId) {
        DbcsLangId = 0;
        //
        // This command switches the display into 80x25 text mode
        // if there is no bitmap logo displayed. The logo is common
        // to the loader and bootvid, and in this case we don't want
        // to switch to text mode and then back to graphics.
        //
        if(!GraphicsMode && AllowGraphicsReset)
            HW_CURSOR(0x80000000,0x3);
    }
}


VOID
UTF8Encode(
    USHORT  InputValue,
    PUCHAR UTF8Encoding
    )
/*++

Routine Description:

    Generates the UTF8 translation for a 16-bit value.

Arguments:

    InputValue - 16-bit value to be encoded.
    UTF8Encoding - receives the UTF8-encoding of the 16-bit value

Return Value:

    NONE.
--*/
{

    //
    // convert into UTF8 for actual transmission
    //
    // UTF-8 encodes 2-byte Unicode characters as follows:
    // If the first nine bits are zero (00000000 0xxxxxxx), encode it as one byte 0xxxxxxx
    // If the first five bits are zero (00000yyy yyxxxxxx), encode it as two bytes 110yyyyy 10xxxxxx
    // Otherwise (zzzzyyyy yyxxxxxx), encode it as three bytes 1110zzzz 10yyyyyy 10xxxxxx
    //
    if( (InputValue & 0xFF80) == 0 ) {
        //
        // if the top 9 bits are zero, then just
        // encode as 1 byte.  (ASCII passes through unchanged).
        //
        UTF8Encoding[2] = (UCHAR)(InputValue & 0xFF);
    } else if( (InputValue & 0xF800) == 0 ) {
        //
        // if the top 5 bits are zero, then encode as 2 bytes
        //
        UTF8Encoding[2] = (UCHAR)(InputValue & 0x3F) | 0x80;
        UTF8Encoding[1] = (UCHAR)((InputValue >> 6) & 0x1F) | 0xC0;
    } else {
        //
        // encode as 3 bytes
        //
        UTF8Encoding[2] = (UCHAR)(InputValue & 0x3F) | 0x80;
        UTF8Encoding[1] = (UCHAR)((InputValue >> 6) & 0x3F) | 0x80;
        UTF8Encoding[0] = (UCHAR)((InputValue >> 12) & 0xF) | 0xE0;
    }
}

VOID
GetDBCSUtf8Translation(
    PUCHAR InputChar,
    PUCHAR UTF8Encoding
    )
/*++

Routine Description:

    Gets the UTF8 translation for a DBCS char.

Arguments:

    InputChar - pointer to DBCS character code.
    UTF8Encoding - receives the UTF8-encoding of the DBCS character code

Return Value:

    NONE.

--*/

{
    int Min,Max,Mid;
    int Multiplier;
    int Index;
    USHORT code;
    USHORT Code;

    Code = *InputChar++ << 8;
    Code = Code | *InputChar++;


    // initialize our output.
    for( Index = 0; Index < 3; Index++ ) {
        UTF8Encoding[Index] = 0;
    }


    Min = 0;
    Max = DbcsCharCount;
    
    //
    // multiplier = 2 (for index) +
    //              2* height + 
    //              2 (for unicode encoding) 
    //
    Multiplier = 2 + (2*CharacterImageHeight) + 2;

    //
    // Do a binary search for the image.
    // Format of table:
    //   First 2 bytes contain the DBCS char code.
    //   Next (2 * CharacterImageHeight) bytes are the char image.
    //   Next 2 bytes are for unicode version.
    //
    while(Max >= Min)  {
        Mid = (Max + Min) / 2;
        Index = Mid*Multiplier;
        code = (DbcsImages[Index] << 8) | (DbcsImages[Index+1]);
    
        if(Code == code) {

            WCHAR UnicodeValue = L'\0';
            PUCHAR Image = (PUCHAR)DbcsImages+Index+2;


            //
            // image is pointing to an array of uchars, which are
            // a bitmap of the character we want to display.  Right
            // behind this array is the unicode encoding of the
            // character.  Here's what the structure looks like:
            //
            // index      bitmap                   unicode encoding of 'index'
            // ^          ^                        ^
            // |          |                        |
            // |          |                         - we previously converted 'index' into
            // |          |                           its unicode equivilent.
            // |          |
            // |           - This is where 'image' is pointing.  It's an array of characters
            // |             (2 * width in length), which represents the bitmap to be displayed
            // |             on the screen which will  represent the value in 'index'
            // |
            //  - This is either an 8-bit value (if we're messing with SBCS), or a 16-bit value 
            //    (if we're dealing with DBCS), in which case 'width' will be DBCSWIDTH.
            //
            // We're going to jump over the bitmap and retrieve the unicode encoding.  Then we'll
            // encode it into UTF8, then spew it over the headless port.
            //
            UnicodeValue = (WCHAR)( (Image[DBCSWIDTH*2]) | (Image[(DBCSWIDTH*2) + 1] << 8) );

            UTF8Encode( UnicodeValue,
                        UTF8Encoding );
            
            return;
        }

        if(Code < code) {
            Max = Mid - 1;
        } else {
            Min = Mid + 1;
        }
    }

    //
    // ERROR: No image found.
    //
    return;
}


VOID
GetSBCSUtf8Translation(
    PUCHAR InputChar,
    PUCHAR UTF8Encoding
    )

/*++

Routine Description:

    Gets the font image for SBCS char.

Arguments:

    InputChar - pointer to SBCS character code.
    UTF8Encoding - receives the UTF8-encoding of the SBCS character code

Return Value:

    NONE.

--*/

{
    int Index;
    UCHAR Code = *InputChar;
    PUCHAR SBCSImage = NULL;
    WCHAR   UnicodeValue;

    // initialize our output.
    for( Index = 0; Index < 3; Index++ ) {
        UTF8Encoding[Index] = 0;
    }
    
    SBCSImage = GrGetSBCSFontImage( Code );

    if( SBCSImage ) {
        UnicodeValue = (WCHAR)( (SBCSImage[SBCSWIDTH*2]) | (SBCSImage[(SBCSWIDTH*2) + 1] << 8) );
        
        UTF8Encode( UnicodeValue,
                    UTF8Encoding );
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\haldtect.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    detecthw.c

Abstract:

    Routines for determining which drivers/HAL need to be loaded.

Author:

    John Vert (jvert) 20-Oct-1993

Revision History:

--*/
#include "haldtect.h"
#include <stdlib.h>

#ifndef ARCI386
//
// detection function prototypes
//
ULONG   DetectMPACPI(PBOOLEAN);
ULONG   DetectApicACPI(PBOOLEAN);
ULONG   DetectPicACPI(PBOOLEAN);
ULONG   DetectUPMPS(PBOOLEAN);
ULONG   DetectMPS(PBOOLEAN);
ULONG   DetectTrue(PBOOLEAN);

typedef struct _HAL_DETECT_ENTRY {
    ULONG           (*DetectFunction)(PBOOLEAN);
    PCHAR           Shortname;
} HAL_DETECT_ENTRY, *PHAL_DETECT_ENTRY;

HAL_DETECT_ENTRY DetectHal[] = {

// First check for a HAL to match some specific hardware.
    DetectMPACPI,          "acpiapic_mp",
    DetectApicACPI,        "acpiapic_up",
    DetectPicACPI,         "acpipic_up",
    DetectMPS,             "mps_mp",
    DetectUPMPS,           "mps_up",

// Use default hal for given bus type...
    DetectTrue,            "e_isa_up",

    0,       NULL,                   NULL
};


PCHAR
SlDetectHal(
    VOID
    )

/*++

Routine Description:

    Determines which HAL to load and returns the filename.

Arguments:

    None.

Return Value:

    PCHAR - pointer to the filename of the HAL to be loaded.

--*/

{
    BOOLEAN IsMpMachine;
    ULONG i;
    PCHAR MachineShortname;

    //
    // Figure out machine and hal type.
    //

    for (i=0;;i++) {
        if (DetectHal[i].DetectFunction == NULL) {
            //
            // We reached the end of the list without
            // figuring it out!
            //
            SlFatalError(i);
            return(NULL);
        }

        IsMpMachine = FALSE;
        if ((DetectHal[i].DetectFunction)(&IsMpMachine) != 0) {

            //
            // Found the correct HAL.
            //

            MachineShortname = DetectHal[i].Shortname;
            break;
        }
    }

    return(MachineShortname);
}


ULONG
DetectTrue(
    OUT PBOOLEAN IsMP
)
/*++

Routine Description:

    To Return TRUE

Return Value:

    TRUE

--*/
{
    UNREFERENCED_PARAMETER( IsMP );
    return TRUE;
}
#else   // ARCI386 path...

PVOID InfFile;
PVOID WinntSifHandle;


PCHAR
SlDetectHal(
    VOID
    )

/*++

Routine Description:

    Determines the canonical short machine name for the HAL to be loaded for
    this machine.

    It does this by enumerating the [Map.Computer] section of the INF file and
    comparing the strings there with the computer description in the ARC tree.

    [Map.Computer]
        msjazz_up   = *Jazz
        desksta1_up = "DESKTECH-ARCStation I"
        pica61_up   = "PICA-61"
        duo_mp      = *Duo

    [Map.Computer]
        DECjensen = "DEC-20Jensen"
        DECjensen = "DEC-10Jensen"

Arguments:

    None.

Return Value:

    PCHAR - pointer to canonical shortname for the machine.
    NULL - the type of machine could not be determined.

--*/

{
    PCONFIGURATION_COMPONENT_DATA Node;
    PCHAR MachineName;

    //
    // Find the system description node
    //
    Node = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                    SystemClass,
                                    ArcSystem,
                                    NULL);
    if (Node==NULL) {
        SlError(0);
        return(NULL);
    }

    MachineName = Node->ComponentEntry.Identifier;
    MachineName = (MachineName ? SlSearchSection("Map.Computer", MachineName) : NULL);
    return(MachineName);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\input.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    input.c

Author:

    Ken Reneris Oct-2-1997

Abstract:

--*/


#include "bootx86.h"
#include "displayp.h"
#include "stdio.h"

//
// Takes any pending input and converts it into a KEY value.  Non-blocking, returning 0 if no input available.
//
ULONG
BlGetKey()
{
    ULONG Key = 0;
    UCHAR Ch;
    ULONG Count;

    if (ArcGetReadStatus(BlConsoleInDeviceId) == ESUCCESS) {

        ArcRead(BlConsoleInDeviceId, &Ch, sizeof(Ch), &Count);

        if (Ch == ASCI_CSI_IN) {

            if (ArcGetReadStatus(BlConsoleInDeviceId) == ESUCCESS) {

                ArcRead(BlConsoleInDeviceId, &Ch, sizeof(Ch), &Count);

                //
                // All the function keys start with ESC-O
                //
                switch (Ch) {
                case 'O':

                    ArcRead(BlConsoleInDeviceId, &Ch, sizeof(Ch), &Count);  // will not or block, as the buffer is already filled

                    switch (Ch) {
                    case 'P': 
                        Key = F1_KEY;
                        break;

                    case 'Q': 
                        Key = F2_KEY;
                        break;

                    case 'w': 
                        Key = F3_KEY;
                        break;

                    case 'x':
                        Key = F4_KEY;
                        break;

                    case 't': 
                        Key = F5_KEY;
                        break;

                    case 'u': 
                        Key = F6_KEY;
                        break;

                    case 'r': 
                        Key = F8_KEY;
                        break;

                    case 'M':
                        Key = F10_KEY;
                        break;

                    case 'A':
                        Key = F11_KEY;
                        break;

                    case 'B':
                        Key = F12_KEY;
                        break;
                    }
                    break;

                case 'A':
                    Key = UP_ARROW;
                    break;

                case 'B':
                    Key = DOWN_ARROW;
                    break;

                case 'C':
                    Key = RIGHT_KEY;
                    break;

                case 'D':
                    Key = LEFT_KEY;
                    break;

                case 'H':
                    Key = HOME_KEY;
                    break;

                case 'K':
                    Key = END_KEY;
                    break;

                case '@':
                    Key = INS_KEY;
                    break;

                case 'P':
                    Key = DEL_KEY;
                    break;
                    
                case TAB_KEY:
                    Key = BACKTAB_KEY;
                    break;

                }

            } else { // Single escape key, as no input is waiting.

                Key = ESCAPE_KEY;

            }

        } else if (Ch == 0x8) {

            Key = BKSP_KEY;

        } else {

            Key = (ULONG)Ch;

        }

    }

    return Key;
}

VOID
BlInputString(
    IN ULONG    Prompt,
    IN ULONG    CursorX,
    IN ULONG    PosY,
    IN PUCHAR   String,
    IN ULONG    MaxLength
    )
{
    PTCHAR      PromptString;
    ULONG       TextX, TextY;
    ULONG       Length, Index;
    UCHAR       CursorChar[2];
    ULONG       Key;
    PUCHAR      p;
    ULONG       i;
    ULONG       Count;

    PromptString = BlFindMessage(Prompt);
    Length = strlen((PCHAR)String);
    CursorChar[1] = 0;

    //
    // Print prompt
    //
    
    ARC_DISPLAY_POSITION_CURSOR(CursorX, PosY);
    ArcWrite(BlConsoleOutDeviceId, PromptString, _tcslen(PromptString), &Count);

    //
    // Indent cursor to right of prompt
    //

    CursorX += _tcslen(PromptString);
    TextX = CursorX;
    Key = 0;

    for (; ;) {

        TextY = TextX + Length;
        if (CursorX > TextY) {
            CursorX = TextY;
        }
        if (CursorX < TextX) {
            CursorX = TextX;
        }

        Index = CursorX - TextX;
        String[Length] = 0;

        //
        // Display current string
        //

        ARC_DISPLAY_POSITION_CURSOR(TextX, PosY);
        ArcWrite(BlConsoleOutDeviceId, String, strlen((PCHAR)String), &Count);
        ArcWrite(BlConsoleOutDeviceId, "  ", sizeof("  "), &Count);
        if (Key == 0x0d) {      // enter key?
            break ;
        }

        //
        // Display cursor
        //

        ARC_DISPLAY_POSITION_CURSOR(CursorX, PosY);
        ARC_DISPLAY_INVERSE_VIDEO();
        CursorChar[0] = String[Index] ? String[Index] : ' ';
        ArcWrite(BlConsoleOutDeviceId, CursorChar, sizeof(UCHAR), &Count);
        ARC_DISPLAY_ATTRIBUTES_OFF();
        ARC_DISPLAY_POSITION_CURSOR(CursorX, PosY);

        //
        // Get key and process it
        //
        while ((Key = BlGetKey()) == 0) {
        }

        switch (Key) {
            case HOME_KEY:
                CursorX = TextX;
                break;

            case END_KEY:
                CursorX = TextY;
                break;

            case LEFT_KEY:
                CursorX -= 1;
                break;

            case RIGHT_KEY:
                CursorX += 1;
                break;

            case BKSP_KEY:
                if (!Index) {
                    break;
                }

                CursorX -= 1;
                String[Index-1] = CursorChar[0];
                // fallthough to DEL_KEY
            case DEL_KEY:
                if (Length) {
                    p = String+Index;
                    i = Length-Index+1;
                    while (i) {
                        p[0] = p[1];
                        p += 1;
                        i -= 1;
                    }
                    Length -= 1;
                }
                break;

            case INS_KEY:
                if (Length < MaxLength) {
                    p = String+Length;
                    i = Length-Index+1;
                    while (i) {
                        p[1] = p[0];
                        p -= 1;
                        i -= 1;
                    }
                    String[Index] = ' ';
                    Length += 1;
                }
                break;

            default:
                Key = Key & 0xff;

                if (Key >= ' '  &&  Key <= 'z') {
                    if (CursorX == TextY  &&  Length < MaxLength) {
                        Length += 1;
                    }

                    String[Index] = (UCHAR)Key;
                    String[MaxLength] = 0;
                    CursorX += 1;
                }
                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\lnkconst.asm ===
.386p

_DATA segment dword use32 public 'DATA'

    extrn osloader_EXPORTS:DWORD
    extrn header:DWORD

    public _osloader_EXPORTS
    public _header

_osloader_EXPORTS DD osloader_EXPORTS
_header           DD header

_DATA ends
      end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\ixhwsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixhwsup.c

Abstract:

    This module contains the IoXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would reside in the iosubs.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode

Revision History:


--*/

#include "bootx86.h"
#include "arc.h"
#include "ixfwhal.h"
#include "eisa.h"
#include "ntconfig.h"

extern PHARDWARE_PTE HalPT;
PVOID HalpEisaControlBase;

//
// Define save area for ESIA adapter objects.
//

PADAPTER_OBJECT HalpEisaAdapter[8];

VOID
HalpCopyBufferMap(
    IN PMDL Mdl,
    IN PTRANSLATION_ENTRY TranslationEntry,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    );

ULONG
IoMapTransferMca(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    );


VOID
HalpCopyBufferMap(
    IN PMDL Mdl,
    IN PTRANSLATION_ENTRY TranslationEntry,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine copies the speicific data between the user's buffer and the
    map register buffer.  First a the user buffer is mapped if necessary, then
    the data is copied.  Finally the user buffer will be unmapped if
    neccessary.

Arguments:

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    TranslationEntry - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - The length of the transfer.  This determines the number of map
        registers that need to be written to map the transfer.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    None.

--*/
{
    PCCHAR bufferAddress;
    BOOLEAN mapped;

    //
    // Check to see if the buffer needs to be mapped.
    //


    if ((Mdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) == 0) {

        //
        // Map the buffer into system space.
        //

        bufferAddress = MmGetMdlVirtualAddress(Mdl);
        mapped = TRUE;

    } else {

        bufferAddress = Mdl->MappedSystemVa;
        mapped = FALSE;

    }

    //
    // Calculate the actual start of the buffer based on the system VA and
    // the current VA.
    //

    bufferAddress += (PCCHAR) CurrentVa - (PCCHAR) MmGetMdlVirtualAddress(Mdl);

    //
    // Copy the data between the user buffer and map buffer
    //

    if (WriteToDevice) {

        RtlMoveMemory( TranslationEntry->VirtualAddress, bufferAddress, Length);

    } else {

        RtlMoveMemory(bufferAddress, TranslationEntry->VirtualAddress, Length);

    }

}

PADAPTER_OBJECT
HalGetAdapter(
    IN PDEVICE_DESCRIPTION DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    )

/*++

Routine Description:

    This function returns the appropriate adapter object for the device defined
    in the device description structure.  This code works for Isa and Eisa
    systems.

Arguments:

    DeviceDescriptor - Supplies a description of the deivce.

    NumberOfMapRegisters - Returns the maximum number of map registers which
        may be allocated by the device driver.

Return Value:

    A pointer to the requested adpater object or NULL if an adapter could not
    be created.

--*/

{
    PADAPTER_OBJECT adapterObject;
    PVOID adapterBaseVa;
    ULONG channelNumber;
    ULONG controllerNumber;
    DMA_EXTENDED_MODE extendedMode;
    UCHAR adapterMode;
    ULONG numberOfMapRegisters;
    BOOLEAN useChannel;
    ULONG maximumLength;

    //
    // Determine if the the channel number is important.  Master cards on
    // Eisa and Mca do not use a channel number.
    //

    if (DeviceDescriptor->InterfaceType != Isa &&
        DeviceDescriptor->Master) {

        useChannel = FALSE;
    } else {

        useChannel = TRUE;
    }

    //
    // Support for ISA local bus machines:
    // If the driver is a Master but really does not want a channel since it
    // is using the local bus DMA, just don't use an ISA channel.
    //

    if (DeviceDescriptor->InterfaceType == Isa &&
        DeviceDescriptor->DmaChannel > 7) {

        useChannel = FALSE;
    }

    //
    // Limit the maximum length to 2 GB this is done so that the BYTES_TO_PAGES
    // macro works correctly.
    //

    maximumLength = DeviceDescriptor->MaximumLength & 0x7fffffff;

    //
    // Channel 4 cannot be used since it is used for chaining. Return null if
    // it is requested.
    //

    if (DeviceDescriptor->DmaChannel == 4 && useChannel &&
        DeviceDescriptor->InterfaceType != MicroChannel) {
        return(NULL);
    }

    //
    // Determine the number of map registers for this device.
    //

    if (DeviceDescriptor->ScatterGather && DeviceDescriptor->InterfaceType == Eisa) {

        //
        // Since the device support scatter/Gather then map registers are not
        // required.
        //

        numberOfMapRegisters = 0;

    } else {

        //
        // Determine the number of map registers required based on the maximum
        // transfer length, up to a maximum number.
        //

        numberOfMapRegisters = BYTES_TO_PAGES(maximumLength)
            + 1;
        numberOfMapRegisters = numberOfMapRegisters > MAXIMUM_ISA_MAP_REGISTER ?
            MAXIMUM_ISA_MAP_REGISTER : numberOfMapRegisters;

    }

    //
    // Set the channel number number.
    //

    channelNumber = DeviceDescriptor->DmaChannel & 0x03;

    //
    // Set the adapter base address to the Base address register and controller
    // number.
    //

    if (!(DeviceDescriptor->DmaChannel & 0x04)) {

        controllerNumber = 1;
        adapterBaseVa = (PVOID) &((PEISA_CONTROL) HalpEisaControlBase)->Dma1BasePort;

    } else {

        controllerNumber = 2;
        adapterBaseVa = &((PEISA_CONTROL) HalpEisaControlBase)->Dma2BasePort;

    }

    //
    // Determine if a new adapter object is necessary.  If so then allocate it.
    //

    if (useChannel && HalpEisaAdapter[DeviceDescriptor->DmaChannel] != NULL) {

        adapterObject = HalpEisaAdapter[DeviceDescriptor->DmaChannel];

    } else {

        //
        // Allocate an adapter object.
        //

        adapterObject = (PADAPTER_OBJECT) IopAllocateAdapter(
            numberOfMapRegisters,
            adapterBaseVa,
            NULL
            );

        if (adapterObject == NULL) {

            return(NULL);

        }

        if (useChannel) {

            HalpEisaAdapter[DeviceDescriptor->DmaChannel] = adapterObject;

        }

        //
        // We never need map registers.
        //

        adapterObject->NeedsMapRegisters = FALSE;

        //
        // Set the maximum number of map registers for this channel bus on
        // the number requested and the type of device.
        //

        if (numberOfMapRegisters) {

            //
            // The speicified number of registers are actually allowed to be
            // allocated.
            //

            adapterObject->MapRegistersPerChannel = numberOfMapRegisters;

        } else {

            //
            // No real map registers were allocated.  If this is a master
            // device, then the device can have as may registers as it wants.
            //


            if (DeviceDescriptor->Master) {

                adapterObject->MapRegistersPerChannel = BYTES_TO_PAGES(
                    maximumLength
                    )
                    + 1;

            } else {

                //
                // The device only gets one register.  It must call
                // IoMapTransfer repeatedly to do a large transfer.
                //

                adapterObject->MapRegistersPerChannel = 1;
            }
        }
    }

    *NumberOfMapRegisters = adapterObject->MapRegistersPerChannel;

    //
    // If the channel number is not used then we are finished.  The rest of
    // the work deals with channels.
    //

    if (!useChannel) {
        return(adapterObject);
    }

    //
    // Setup the pointers to all the random registers.
    //

    adapterObject->ChannelNumber = (UCHAR) channelNumber;

    if (controllerNumber == 1) {

        switch ((UCHAR)channelNumber) {

        case 0:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel0;
            break;

        case 1:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel1;
            break;

        case 2:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel2;
            break;

        case 3:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel3;
            break;
        }

        //
        // Set the adapter number.
        //

        adapterObject->AdapterNumber = 1;

        //
        // Save the extended mode register address.
        //

        adapterBaseVa =
            &((PEISA_CONTROL) HalpEisaControlBase)->Dma1ExtendedModePort;

    } else {

        switch (channelNumber) {
        case 1:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel5;
            break;

        case 2:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel6;
            break;

        case 3:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel7;
            break;
        }

        //
        // Set the adapter number.
        //

        adapterObject->AdapterNumber = 2;

        //
        // Save the extended mode register address.
        //
        adapterBaseVa =
            &((PEISA_CONTROL) HalpEisaControlBase)->Dma2ExtendedModePort;

    }

    adapterObject->Width16Bits = FALSE;

    if (MachineType == MACHINE_TYPE_EISA) {

        //
        // Initialzie the extended mode port.
        //

        *((PUCHAR) &extendedMode) = 0;
        extendedMode.ChannelNumber = (UCHAR)channelNumber;

        switch (DeviceDescriptor->DmaSpeed) {
        case Compatible:
            extendedMode.TimingMode = COMPATIBLITY_TIMING;
            break;

        case TypeA:
            extendedMode.TimingMode = TYPE_A_TIMING;
            break;

        case TypeB:
            extendedMode.TimingMode = TYPE_B_TIMING;
            break;

        case TypeC:
            extendedMode.TimingMode = BURST_TIMING;
            break;

        default:
            return(NULL);

        }

        switch (DeviceDescriptor->DmaWidth) {
        case Width8Bits:
            extendedMode.TransferSize = BY_BYTE_8_BITS;
            break;

        case Width16Bits:
            extendedMode.TransferSize = BY_BYTE_16_BITS;

            //
            // Note Width16bits should not be set here because there is no need
            // to shift the address and the transfer count.
            //

            break;

        case Width32Bits:
            extendedMode.TransferSize = BY_BYTE_32_BITS;
            break;

        default:
            return(NULL);

        }

        WRITE_PORT_UCHAR( adapterBaseVa, *((PUCHAR) &extendedMode));

    } else if (!DeviceDescriptor->Master) {


        switch (DeviceDescriptor->DmaWidth) {
        case Width8Bits:

            //
            // The channel must use controller 1.
            //

            if (controllerNumber != 1) {
                return(NULL);
            }

            break;

        case Width16Bits:

            //
            // The channel must use controller 2.
            //

            if (controllerNumber != 2) {
                return(NULL);
            }

            adapterObject->Width16Bits = TRUE;
            break;

        default:
            return(NULL);

        }
    }


    //
    // Determine if this is an Isa adapter.
    //

    if (DeviceDescriptor->InterfaceType == Isa) {

        adapterObject->IsaDevice = TRUE;

    }

    //
    // Initialize the adapter mode register value to the correct parameters,
    // and save them in the adapter object.
    //

    adapterMode = 0;
    ((PDMA_EISA_MODE) &adapterMode)->Channel = adapterObject->ChannelNumber;

    adapterObject->MasterDevice = FALSE;

    if (DeviceDescriptor->Master) {

        adapterObject->MasterDevice = TRUE;

        ((PDMA_EISA_MODE) &adapterMode)->RequestMode = CASCADE_REQUEST_MODE;

        //
        // Set the mode, and enable the request.
        //

        if (adapterObject->AdapterNumber == 1) {

            //
            // This request is for DMA controller 1
            //

            PDMA1_CONTROL dmaControl;

            dmaControl = adapterObject->AdapterBaseVa;

            WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

            //
            // Unmask the DMA channel.
            //

            WRITE_PORT_UCHAR(
                &dmaControl->SingleMask,
                 (UCHAR) (DMA_CLEARMASK | adapterObject->ChannelNumber)
                 );

        } else {

            //
            // This request is for DMA controller 1
            //

            PDMA2_CONTROL dmaControl;

            dmaControl = adapterObject->AdapterBaseVa;

            WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

            //
            // Unmask the DMA channel.
            //

            WRITE_PORT_UCHAR(
                &dmaControl->SingleMask,
                 (UCHAR) (DMA_CLEARMASK | adapterObject->ChannelNumber)
                 );

        }

    } else if (DeviceDescriptor->DemandMode) {

        ((PDMA_EISA_MODE) &adapterMode)->RequestMode = DEMAND_REQUEST_MODE;

    } else {

        ((PDMA_EISA_MODE) &adapterMode)->RequestMode = SINGLE_REQUEST_MODE;

    }

    if (DeviceDescriptor->AutoInitialize) {

        ((PDMA_EISA_MODE) &adapterMode)->AutoInitialize = 1;

    }

    adapterObject->AdapterMode = adapterMode;

    return(adapterObject);
}

NTSTATUS
IoAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter object.
    This is accomplished by placing the device object of the driver that wants
    to allocate the adapter on the adapter's queue.  If the queue is already
    "busy", then the adapter has already been allocated, so the device object
    is simply placed onto the queue and waits until the adapter becomes free.

    Once the adapter becomes free (or if it already is), then the driver's
    execution routine is invoked.

    Also, a number of map registers may be allocated to the driver by specifying
    a non-zero value for NumberOfMapRegisters.  If this is the case, then the
    base address of the allocated map registers in the adapter is also passed
    to the driver's execution routine.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    DeviceObject - Pointer to the driver's device object that represents the
        device allocating the adapter.

    NumberOfMapRegisters - The number of map registers that are to be allocated
        from the channel, if any.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the adapter channel (and possibly map registers) have been
        allocated.

    Context - An untyped longword context parameter passed to the driver's
        execution routine.

Return Value:

    Returns STATUS_SUCESS unless too many map registers are requested.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

--*/

{
    IO_ALLOCATION_ACTION action;

    //
    // Make sure the adapter if free.
    //

    if (AdapterObject->AdapterInUse) {
        DbgPrint("IoAllocateAdapterChannel: Called while adapter in use.\n");
    }

    //
    // Make sure there are enough map registers.
    //

    if (NumberOfMapRegisters > AdapterObject->MapRegistersPerChannel) {

        DbgPrint("IoAllocateAdapterChannel:  Out of map registers.\n");
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    action = ExecutionRoutine( DeviceObject,
                               DeviceObject->CurrentIrp,
                               AdapterObject->MapRegisterBase,
                               Context );

    //
    // If the driver wishes to keep the map registers then
    // increment the current base and decrease the number of existing map
    // registers.
    //

    if (action == DeallocateObjectKeepRegisters &&
        AdapterObject->MapRegisterBase != NULL) {

        AdapterObject->MapRegistersPerChannel -= NumberOfMapRegisters;
        AdapterObject->MapRegisterBase = (PTRANSLATION_ENTRY) AdapterObject->MapRegisterBase + NumberOfMapRegisters;

    } else if (action == KeepObject) {

        AdapterObject->AdapterInUse = TRUE;

    }

    return(STATUS_SUCCESS);
}

VOID
IoFreeAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject
    )

/*++

Routine Description:

    This routine is invoked to deallocate the specified adapter object.
    Any map registers that were allocated are also automatically deallocated.
    No checks are made to ensure that the adapter is really allocated to
    a device object.  However, if it is not, then kernel will bugcheck.

    If another device is waiting in the queue to allocate the adapter object
    it will be pulled from the queue and its execution routine will be
    invoked.

Arguments:

    AdapterObject - Pointer to the adapter object to be deallocated.

Return Value:

    None.

--*/

{

    AdapterObject->AdapterInUse = FALSE;
}

PHYSICAL_ADDRESS
IoMapTransfer(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine is invoked to set up the map registers in the DMA controller
    to allow a transfer to or from a device.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel that has been allocated.

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    MapRegisterBase - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.  This determines the
        number of map registers that need to be written to map the transfer.
        Returns the length of the transfer which was actually mapped.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    Returns the logical address that should be used bus master controllers.

--*/

{
    BOOLEAN useBuffer;
    ULONG transferLength;
    ULONG logicalAddress;
    PULONG pageFrame;
    PUCHAR bytePointer;
    UCHAR adapterMode;
    UCHAR dataByte;
    PTRANSLATION_ENTRY translationEntry;
    BOOLEAN masterDevice;
    PHYSICAL_ADDRESS ReturnAddress;

    masterDevice = AdapterObject == NULL || AdapterObject->MasterDevice ?
        TRUE : FALSE;

    translationEntry = MapRegisterBase;
    transferLength = *Length;

    //
    // Determine if the data transfer needs to use the map buffer.
    //

    if (translationEntry && !masterDevice &&
        ADDRESS_AND_SIZE_TO_SPAN_PAGES(CurrentVa, transferLength) > 1) {

        logicalAddress = translationEntry->PhysicalAddress;
        useBuffer = TRUE;

    } else {

        //
        // The transfer can only be done for one page.
        //



        transferLength = PAGE_SIZE - BYTE_OFFSET(CurrentVa);
        pageFrame = (PULONG)(Mdl+1);
        pageFrame += ((ULONG) CurrentVa - (ULONG) Mdl->StartVa) / PAGE_SIZE;
        logicalAddress = (*pageFrame << PAGE_SHIFT) + BYTE_OFFSET(CurrentVa);

        //
        // If the buffer is contigous and does not cross a 64 K boundary then
        // just extend the buffer.
        //

        while( transferLength < *Length ){

            if (*pageFrame + 1 != *(pageFrame + 1) ||
                (*pageFrame & ~0x0ffff) != (*(pageFrame + 1) & ~0x0ffff)) {
                    break;
            }

            transferLength += PAGE_SIZE;
            pageFrame++;

        }


        transferLength = transferLength > *Length ? *Length : transferLength;

        useBuffer = FALSE;
    }

    //
    // Check to see if this device has any map registers allocated. If it
    // does, then it must require memory to be at less than 16 MB.  If the
    // logical address is greater than 16MB then map registers must be used
    //

    if (translationEntry && logicalAddress >= MAXIMUM_PHYSICAL_ADDRESS) {

        logicalAddress = (translationEntry + translationEntry->Index)->
            PhysicalAddress;
        useBuffer = TRUE;

    }

    //
    // Return the length.
    //

    *Length = transferLength;

    //
    // Copy the data if necessary.
    //

    if (useBuffer && WriteToDevice) {

        HalpCopyBufferMap(
            Mdl,
            translationEntry + translationEntry->Index,
            CurrentVa,
            *Length,
            WriteToDevice
            );

    }

    //
    // If there are map registers, then update the index to indicate
    // how many have been used.
    //

    if (translationEntry) {

        translationEntry->Index += ADDRESS_AND_SIZE_TO_SPAN_PAGES(
            CurrentVa,
            transferLength
            );

    }

    //
    // If no adapter was specificed then there is no more work to do so
    // return.
    //

    if (masterDevice) {

        //
        // We only support 32 bits, but the return is 64.  Just
        // zero extend
        //

        ReturnAddress.QuadPart = logicalAddress;
        return(ReturnAddress);
    }

    //
    // Determine the mode based on the transfer direction.
    //

    adapterMode = AdapterObject->AdapterMode;
    ((PDMA_EISA_MODE) &adapterMode)->TransferType = (UCHAR) (WriteToDevice ?
        WRITE_TRANSFER :  READ_TRANSFER);

    ReturnAddress.QuadPart = logicalAddress;
    bytePointer = (PUCHAR) &logicalAddress;

    if (AdapterObject->Width16Bits) {

        //
        // If this is a 16 bit transfer then adjust the length and the address
        // for the 16 bit DMA mode.
        //

        transferLength >>= 1;

        //
        // In 16 bit DMA mode the low 16 bits are shifted right one and the
        // page register value is unchanged. So save the page register value
        // and shift the logical address then restore the page value.
        //

        dataByte = bytePointer[2];
        logicalAddress >>= 1;
        bytePointer[2] = dataByte;

    }

    //
    // Determine the controller number based on the Adapter number.
    //

    if (AdapterObject->AdapterNumber == 1) {

        //
        // This request is for DMA controller 1
        //

        PDMA1_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );

        WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseAddress,
            bytePointer[0]
            );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseAddress,
            bytePointer[1]
            );

        WRITE_PORT_UCHAR(
            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageLowPort) +
            (ULONG)AdapterObject->PagePort,
            bytePointer[2]
            );

#if 0
        //
        // Write the high page register with zero value. This enable a special mode
        // which allows ties the page register and base count into a single 24 bit
        // address register.
        //

        WRITE_PORT_UCHAR(
            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageHighPort) +
            (ULONG)AdapterObject->PagePort,
            0
            );
#endif

        //
        // Notify DMA chip of the length to transfer.
        //

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseCount,
            (UCHAR) ((transferLength - 1) & 0xff)
            );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseCount,
            (UCHAR) ((transferLength - 1) >> 8)
            );


        //
        // Set the DMA chip to read or write mode; and unmask it.
        //

        WRITE_PORT_UCHAR(
            &dmaControl->SingleMask,
             (UCHAR) (DMA_CLEARMASK | AdapterObject->ChannelNumber)
             );

    } else {

        //
        // This request is for DMA controller 2
        //

        PDMA2_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );

        WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseAddress,
            bytePointer[0]
            );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseAddress,
            bytePointer[1]
            );

        WRITE_PORT_UCHAR(
            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageLowPort) +
            (ULONG)AdapterObject->PagePort,
            bytePointer[2]
            );
#if 0

        //
        // Write the high page register with zero value. This enable a special mode
        // which allows ties the page register and base count into a single 24 bit
        // address register.
        //

        WRITE_PORT_UCHAR(
            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageHighPort) +
            (ULONG)AdapterObject->PagePort,
            0
            );

#endif
        //
        // Notify DMA chip of the length to transfer.
        //

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseCount,
            (UCHAR) ((transferLength - 1) & 0xff)
            );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseCount,
            (UCHAR) ((transferLength - 1) >> 8)
            );


        //
        // Set the DMA chip to read or write mode; and unmask it.
        //

        WRITE_PORT_UCHAR(
            &dmaControl->SingleMask,
             (UCHAR) (DMA_CLEARMASK | AdapterObject->ChannelNumber)
             );

    }

    return(ReturnAddress);
}

BOOLEAN
IoFlushAdapterBuffers(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine flushes the DMA adpater object buffers.  For the Jazz system
    its clears the enable flag which aborts the dma.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel.

    Mdl - A pointer to a Memory Descriptor List (MDL) that maps the locked-down
        buffer to/from which the I/O occured.

    MapRegisterBase - A pointer to the base of the map registers in the adapter
        or DMA controller.

    CurrentVa - The current virtual address in the buffer described the the Mdl
        where the I/O operation occurred.

    Length - Supplies the length of the transfer.

    WriteToDevice - Supplies a BOOLEAN value that indicates the direction of
        the data transfer was to the device.

Return Value:

    TRUE - No errors are detected so the transfer must succeed.

--*/

{
    PTRANSLATION_ENTRY translationEntry;
    PULONG pageFrame;
    ULONG transferLength;
    ULONG partialLength;
    BOOLEAN masterDevice;
    BOOLEAN mapped = FALSE;

    masterDevice = AdapterObject == NULL || AdapterObject->MasterDevice ?
        TRUE : FALSE;

    translationEntry = MapRegisterBase;

    //
    // Clear the index of used buffers.
    //

    if (translationEntry) {

        translationEntry->Index = 0;
    }

    //
    // Determine if the data needs to be copied to the orginal buffer.
    // This only occurs if the data tranfer is from the device, the
    // MapReisterBase is not NULL and the transfer spans a page.
    //

    if (!WriteToDevice && translationEntry) {

        //
        // If this is not a master device, then just transfer the buffer.
        //

        if (ADDRESS_AND_SIZE_TO_SPAN_PAGES(CurrentVa, Length) > 1 &&
            !masterDevice) {

            HalpCopyBufferMap(
                Mdl,
                translationEntry,
                CurrentVa,
                Length,
                WriteToDevice
                );

        } else {

            //
            // Cycle through the pages of the transfer to determine if there
            // are any which need to be copied back.
            //

            transferLength = PAGE_SIZE - BYTE_OFFSET(CurrentVa);
            partialLength = transferLength;
            pageFrame = (PULONG)(Mdl+1);
            pageFrame += ((ULONG) CurrentVa - (ULONG) Mdl->StartVa) / PAGE_SIZE;

            while( transferLength <= Length ){

                if (*pageFrame >= BYTES_TO_PAGES(MAXIMUM_PHYSICAL_ADDRESS)) {

                    //
                    // Check to see that the MDL is mapped in system space.
                    // If is not mapped, then map it.  This ensures that the
                    // buffer will only have to be mapped at most once per I/O.
                    //

                    if ((Mdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) == 0) {

                        Mdl->MappedSystemVa = MmGetMdlVirtualAddress(Mdl);
                        Mdl->MdlFlags |= MDL_MAPPED_TO_SYSTEM_VA;
                        mapped = TRUE;

                    }

                    HalpCopyBufferMap(
                        Mdl,
                        translationEntry,
                        CurrentVa,
                        partialLength,
                        WriteToDevice
                        );

                }

                CurrentVa = (PCCHAR) CurrentVa + partialLength;
                partialLength = PAGE_SIZE;

                //
                // Note that transferLength indicates the amount which will be
                // transfered after the next loop; thus, it is updated with the
                // new partial length.
                //

                transferLength += partialLength;
                pageFrame++;
                translationEntry++;
            }

            //
            // Process the any remaining residue.
            //

            partialLength = Length - transferLength + partialLength;
            if (partialLength && *pageFrame >= BYTES_TO_PAGES(MAXIMUM_PHYSICAL_ADDRESS)) {

                HalpCopyBufferMap(
                    Mdl,
                    translationEntry,
                    CurrentVa,
                    partialLength,
                    WriteToDevice
                    );

            }
        }

    }


    //
    // If this is a master device, then there is nothing more to do so return
    // TRUE.
    //

    if (masterDevice) {

        return(TRUE);

    }

    //
    // Mask the DMA request line so that DMA requests cannot occur.
    //

    if (AdapterObject->AdapterNumber == 1) {

        //
        // This request is for DMA controller 1
        //

        PDMA1_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR(
            &dmaControl->SingleMask,
            (UCHAR) (DMA_SETMASK | AdapterObject->ChannelNumber)
            );

    } else {

        //
        // This request is for DMA controller 2
        //

        PDMA2_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR(
            &dmaControl->SingleMask,
            (UCHAR) (DMA_SETMASK | AdapterObject->ChannelNumber)
            );

    }

    return TRUE;
}

VOID
IoFreeMapRegisters(
   PADAPTER_OBJECT AdapterObject,
   PVOID MapRegisterBase,
   ULONG NumberOfMapRegisters
   )
/*++

Routine Description:

   This routine deallocates the map registers for the adapter.  If there are
   any queued adapter waiting for an attempt is made to allocate the next
   entry.

Arguments:

   AdapterObject - The adapter object to where the map register should be
        returned.

   MapRegisterBase - The map register base of the registers to be deallocated.

   NumberOfMapRegisters - The number of registers to be deallocated.

Return Value:

   None

--+*/
{
    PTRANSLATION_ENTRY translationEntry;

    //
    // Determine if this was the last allocation from the adapter. If is was
    // then free the map registers by restoring the map register base and the
    // channel count; otherwise the registers are lost.  This handles the
    // normal case.
    //

    translationEntry = AdapterObject->MapRegisterBase;
    translationEntry -= NumberOfMapRegisters;

    if (translationEntry == MapRegisterBase) {

        //
        // The last allocated registers are being freed.
        //

        AdapterObject->MapRegisterBase = (PVOID) translationEntry;
        AdapterObject->MapRegistersPerChannel += NumberOfMapRegisters;
    }
}

PHYSICAL_ADDRESS
MmGetPhysicalAddress (
     IN PVOID BaseAddress
     )

/*++

Routine Description:

    This function returns the corresponding physical address for a
    valid virtual address.

Arguments:

    BaseAddress - Supplies the virtual address for which to return the
                  physical address.

Return Value:

    Returns the corresponding physical address.

Environment:

    Kernel mode.  Any IRQL level.

--*/

{
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG Index;

    PhysicalAddress.HighPart = 0;
    PhysicalAddress.LowPart = (ULONG)BaseAddress & ~KSEG0_BASE;

    //
    // If the address is in the hal map range, get the physical
    // addressed mapped by the pte
    //

    if (((ULONG) BaseAddress) >= 0xffc00000) {
        Index = (PhysicalAddress.LowPart >> 12) & 0x3ff;
        PhysicalAddress.LowPart = HalPT[Index].PageFrameNumber << PAGE_SHIFT;
        PhysicalAddress.LowPart |= ((ULONG)BaseAddress) & (PAGE_SIZE-1);
    }

    return(PhysicalAddress);
}

PVOID
MmAllocateNonCachedMemory (
    IN ULONG NumberOfBytes
    )

/*++

Routine Description:

    This function allocates a range of noncached memory in
    the non-paged portion of the system address space.

    This routine is designed to be used by a driver's initialization
    routine to allocate a noncached block of virtual memory for
    various device specific buffers.

Arguments:

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NULL - the specified request could not be satisfied.

    NON-NULL - Returns a pointer (virtual address in the nonpaged portion
               of the system) to the allocated phyiscally contiguous
               memory.

Environment:

    Kernel mode, IRQL of APC_LEVEL or below.

--*/

{
    PVOID BaseAddress;

    //
    // Allocated the memory.
    //

    BaseAddress = FwAllocateHeap(NumberOfBytes);
    return BaseAddress;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\machine.c ===
/*++

Module Name:

    machine.c

Author:

    Thomas Parslow [TomP] Feb-13-1990
    Reworked substantially in Tokyo 7-July-95 (tedm)

Abstract:

    Machine/hardware dependent routines reside within this module/file.
    (Video is in disp_tm.c and disp_gm.c.)

--*/


#include "arccodes.h"
#include "bootx86.h"

#define FLOPPY_CONTROL_REGISTER (PUCHAR)0x3f2

ARC_STATUS
XferExtendedPhysicalDiskSectors(
    IN  UCHAR     Int13UnitNumber,
    IN  ULONGLONG StartSector,
    IN  USHORT    SectorCount,
        PUCHAR    Buffer,
    IN  BOOLEAN   Write
    )

/*++

Routine Description:

    Read or write disk sectors via extended int13.

    It is assumed that the caller has ensured that the transfer buffer is
    under the 1MB line, that the sector run does not cross a 64K boundary,
    etc.

    This routine does not check whether extended int13 is actually available
    for the drive.

Arguments:

    Int13UnitNumber - supplies the int13 drive number for the drive
        to be read from/written to.

    StartSector - supplies the absolute physical sector number. This is 0-based
        relative to all sectors on the drive.

    SectorCount - supplies the number of sectors to read/write.

    Buffer - receives data read from the disk or supplies data to be written.

    Write - supplies a flag indicating whether this is a write operation.
        If FALSE, then it's a read. Otherwise it's a write.

Return Value:

    ARC status code indicating outcome.

--*/

{
    ARC_STATUS s;
    ULONG l,h;
    UCHAR Operation;
        
    //
    // Buffer must be under 1MB to be addressable in real mode.
    // The hardcoded 512 is wrong the CD-ROM case, but close enough.
    //
    if(((ULONG)Buffer + (SectorCount * 512)) > 0x100000) {
        return(EFAULT);
    }

    if(!SectorCount) {
        return(ESUCCESS);
    }

    l = (ULONG)StartSector;
    h = (ULONG)(StartSector >> 32);

    Operation = (UCHAR)(Write ? 0x43 : 0x42);

    //
    // Retry a couple of times if this fails.
    // We don't reset since this routine is only used on hard drives and
    // CD-ROMs, and we don't totally understand the effect of a disk reset
    // on ElTorito.
    //
    s = GET_EDDS_SECTOR(Int13UnitNumber,l,h,SectorCount,Buffer,Operation);
    if(s) {
        s = GET_EDDS_SECTOR(Int13UnitNumber,l,h,SectorCount,Buffer,Operation);
        if(s) {
            s = GET_EDDS_SECTOR(Int13UnitNumber,l,h,SectorCount,Buffer,Operation);
        }
    }

    return(s);
}


ARC_STATUS
XferPhysicalDiskSectors(
    IN  UCHAR     Int13UnitNumber,
    IN  ULONGLONG StartSector,
    IN  UCHAR     SectorCount,
    IN  PUCHAR    Buffer,
    IN  UCHAR     SectorsPerTrack,
    IN  USHORT    Heads,
    IN  USHORT    Cylinders,
    IN  BOOLEAN   AllowExtendedInt13,
    IN  BOOLEAN   Write
    )

/*++

Routine Description:

    Read or write disk sectors.

    Xfers sectors via int13. If the request starts on a cylinder
    larger than the number of cylinders reported by conventional int13, then
    extended int13 will be used if the drive supports it.

    It is assumed that the caller has ensured that the transfer buffer is
    under the 1MB line, that the sector run does not cross a 64K boundary,
    and that the sector run does not cross a track boundary. (The latter
    might not be strictly necessary, but the i/o will fail if the sector run
    starts inside the magic CHS boundary and ends past it since we won't
    switch to xint13 unless the start sector indicates that it is necessary.)

Arguments:

    Int13UnitNumber - supplies the int13 drive number for the drive
        to be read from/written to.

    StartSector - supplies the absolute physical sector number. This is 0-based
        relative to all sectors on the drive.

    SectorCount - supplies the number of sectors to read/write.

    Buffer - receives data read from the disk or supplies data to be written.

    SectorsPerTrack - supplies sectors per track (1-63) from int13 function 8
        for the drive.

    Heads - supplies number of heads (1-255) from int13 function 8 for the drive.

    Cylinders - supplies number of cylinders (1-1023) from int13 function 8
        for the drive.

    AllowExtendedInt13 - if TRUE and the start cylinder for the i/o is
        greater than the cylinder count reported by conventional int13 for
        the drive, then extended int13 will be used to do the i/o operation.

    Write - supplies a flag indicating whether this is a write operation.
        If FALSE, then it's a read. Otherwise it's a write.

Return Value:

    ARC status code indicating outcome.

--*/

{
    ULONGLONG r;
    ULONGLONG cylinder;
    USHORT head;
    UCHAR sector;
    USHORT SectorsPerCylinder;
    int retry;
    ARC_STATUS s;

    //
    // Buffer must be under 1MB to be addressable in real mode
    //
    if(((ULONG)Buffer + (SectorCount * 512)) > 0x100000) {
        return(EFAULT);
    }

    //
    // Figure out CHS values. Note that we use a ULONGLONG for the cylinder,
    // because it could overflow 1023 if the start sector is large.
    //
    SectorsPerCylinder = SectorsPerTrack * Heads;
    cylinder = (ULONG)(StartSector / SectorsPerCylinder);
    r = StartSector % SectorsPerCylinder;
    head = (USHORT)(r / SectorsPerTrack);
    sector = (UCHAR)(r % SectorsPerTrack) + 1;

    //
    // Check to see whether the cylinder is addressable via conventional int13.
    //
    if(cylinder >= Cylinders) {

        //
        // First try standard int13.
        // Some BIOSes (Thinkpad 600) misreport the disk size and ext int13.
        // So let's get this case out of the way now by trying the read anyway.
        //

        if( cylinder == Cylinders ) {
            if( cylinder <= 1023 ) {
            
                //
                // Give conventional int13 a shot.
                //
    
                s = GET_SECTOR(
                        (UCHAR)(Write ? 3 : 2),     // int13 function number
                        Int13UnitNumber,
                        head,
                        (USHORT)cylinder,           // we know it's 0-1023
                        sector,
                        SectorCount,
                        Buffer
                        );
        
                if(s) {
                    
                    //
                    // failed, fall through to ExtendedInt13
                    //
    
                } else {
    
                    // success, let's return
    
                    return(s);
                }
            }
        }

        if(AllowExtendedInt13) {

            s = XferExtendedPhysicalDiskSectors(
                    Int13UnitNumber,
                    StartSector,
                    SectorCount,
                    Buffer,
                    Write
                    );

            return(s);

        //
        // The read is beyond the geometry reported by the BIOS. If it's
        // in the first cylinder beyond that reported by the BIOS, and
        // it's below cylinder 1024, then assume that the BIOS and NT
        // just have a slight disagreement about the geometry and try
        // the read using conventional int13.
        //
        } else if((cylinder > 1023) || (cylinder > Cylinders)) {            
            return(E2BIG);
        }

        //
        // The read is in the "extra" cylinder. Fall through to conventional int13.
        //
    }

    if(!SectorCount) {
        return(ESUCCESS);
    }

    //
    // OK, xfer the sectors via conventional int13.
    //
    retry = (Int13UnitNumber < 128) ? 3 : 1;
    do {
        s = GET_SECTOR(
                (UCHAR)(Write ? 3 : 2),     // int13 function number
                Int13UnitNumber,
                head,
                (USHORT)cylinder,           // we know it's 0-1023
                sector,
                SectorCount,
                Buffer
                );

        if(s) {
            ResetDiskSystem(Int13UnitNumber);
        }
    } while(s && retry--);

    return(s);
}


VOID
ResetDiskSystem(
    UCHAR Int13UnitNumber
    )

/*++

Routine Description:

    Reset the specified drive. Generally used after an error is returned
    by the GetSector routine.

Arguments:

    Int13UnitNumber -

            0x00 - 1st floppy drive
            0x01 - 2nd floppy drive

            0x80 - 1st hard drive
            0x81 - 2nd hard drive

            etc

Returns:

    None.

--*/
{
    RESET_DISK(
        (UCHAR)((Int13UnitNumber < 128) ? 0 : 13),  // int13 function number
        Int13UnitNumber,
        0,
        0,
        0,
        0,
        NULL
        );
}


VOID
MdShutoffFloppy(
    VOID
    )

/*++

Routine Description:

    Shuts off the floppy drive motor.

Arguments:

    None

Return Value:

    None.

--*/

{
    WRITE_PORT_UCHAR(FLOPPY_CONTROL_REGISTER,0xC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\ixcmos.asm ===
title  "Cmos Access Routines"
;++
;
; Copyright (c) 1992 NCR Corporation
;
; Module Name:
;
;    mccmos.asm
;
; Abstract:
;
;    Procedures necessary to access CMOS/ECMOS information.
;
; Author:
;
;    David Risner (o-ncrdr) 20 Apr 1992
;
; Revision History:
;
;--

.386p
        .xlist
;include ks386.inc
;include mac386.inc
include callconv.inc
        .list

;        extrn   _HalpSystemHardwareLock:DWORD

        subttl  "HalpGetCmosData"
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; CMOS space read and write functions.
;
;--

CmosAddressPort         equ     70H
CmosDataPort            equ     71H

ECmosAddressLsbPort     equ     74H
ECmosAddressMsbPort     equ     75H
ECmosDataPort           equ     76H

;++
;
;   ULONG
;   HalpGetCmosData(
;       IN ULONG    SourceLocation
;       IN ULONG    SourceAddress
;       IN ULONG    ReturnBuffer
;       IN PUCHAR   ByteCount
;       )
;
;   This routine reads the requested number of bytes from CMOS/ECMOS and
;   stores the data read into the supplied buffer in system memory.  If
;   the requested data amount exceeds the allowable extent of the source
;   location, the return data is truncated.
;
;   Arguments:
;
;       SourceLocation  : where data is to be read from CMOS or ECMOS
;                           0 - CMOS, 1 - ECMOS
;
;       SourceAddress   : address in CMOS/ECMOS where data is to be read from
;
;       ReturnBuffer    : address in system memory for return data
;
;       ByteCount       : number of bytes to be read
;
;   Returns:
;
;       Number of byte actually read.
;
;--

SourceLocation  equ     2*4[ebp]
SourceAddress   equ     3*4[ebp]
ReturnBuffer    equ     4*4[ebp]
ByteCount       equ     5*4[ebp]

cPublicProc     _HalpGetCmosData,4

        push    ebp
        mov     ebp, esp
        push    ebx
        push    edi

    ;
    ; NOTE: The spinlock is needed even in the UP case, because
    ;    the resource is also used in an interrupt handler (profiler).
    ;    If we own the spinlock in this routine, and we service
    ;    the profiler interrupt (which will wait for the spinlock forever),
    ;    then we have a hosed system.
    ;
Hgcd01:
        cli
;        lea     eax, _HalpSystemHardwareLock
;        ACQUIRE_SPINLOCK    eax, Hgcd90

        xor     edx, edx                ; initialize return data length
        mov     ecx, ByteCount

        or      ecx, ecx                ; validate requested byte count
        jz      HalpGetCmosDataExit     ; if no work to do, exit

        mov     edx, SourceAddress
        mov     edi, ReturnBuffer

        mov     eax, SourceLocation     ; cmos or extended cmos?
        cmp     eax, 1                  
        je      ECmosReadByte
        cmp     eax, 0
        jne     HalpGetCmosDataExit

        align   4
CmosReadByte:

        cmp     edx, 0ffH               ; validate cmos source address
        ja      HalpGetCmosDataExit     ; if out of range, exit
        mov     al, dl
        out     CmosAddressPort, al
        in      al, CmosDataPort
        mov     [edi], al
        inc     edx
        inc     edi
        dec     ecx
        jnz     CmosReadByte
        jmp     SHORT HalpGetCmosDataExit

        align   4
ECmosReadByte:


        cmp     edx,0ffffH              ; validate ecmos source address
        ja      HalpGetCmosDataExit     ; if out of range, exit
        mov     al, dl
        out     ECmosAddressLsbPort, al
        mov     al, dh
        out     ECmosAddressMsbPort, al
        in      al, ECmosDataPort
        mov     [edi], al
        inc     edx
        inc     edi
        dec     ecx
        jnz     ECmosReadByte

HalpGetCmosDataExit:

;        lea     eax, _HalpSystemHardwareLock
;        RELEASE_SPINLOCK    eax
        mov     eax, edx                ; return bytes read

        pop     edi
        pop     ebx
        pop     ebp

        stdRET  _HalpGetCmosData

;Hgcd90:
;        sti
;        SPIN_ON_SPINLOCK    eax, <Hgcd01>

stdENDP _HalpGetCmosData


_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\mdequ.inc ===
;----------------------------------------------------------------------------
;  MDEQU.INC - General equate file
;
;  Microsoft Confidential
;  Copyright (C) Microsoft Corporation 1992-1993
;  All Rights Reserved.
;
;  History:
;   20-Jul-92 chuckst   Initial version.
;
;  VxD History:
;   21-Apr-93 jeffpar   Adapted for MRCI.386
;----------------------------------------------------------------------------


; Define the following variable to generate the standalone
; version of DBLSPACE.BIN, which loads as a device driver under
; MS-DOS 5.0 or greater.
;
;STANDALONE	 equ	 0ffffh


; Note that the final version of DblSpace switched to 6-8-12 encoding
; which assumes the following scheme:
;
;         ccccccc10     raw char ( < 128)
;         ccccccc01     raw char ( >=128)
;          oooooo00     6-bit offset
;       oooooooo011     8-bit offset
;   oooooooooooo111    12-bit offset
;

MAX_6BIT_OFFSET equ     63
MAX_8BIT_OFFSET equ     (MAX_6BIT_OFFSET+256)
MAX_12BIT_OFFSET equ    ((MAX_8BIT_OFFSET+4096)-1)
SPECIAL_EOS     equ     4415            ;End of Sector code
.errnz  MAX_12BIT_OFFSET+1 ne SPECIAL_EOS

MAX_LENGTH_BITS equ     17
MAX_TRUE_LENGTH equ     512
MAX_RAW_LENGTH  equ     (MAX_TRUE_LENGTH-2) ; lengths are stored 2 less than true length


fatal_error_0   equ     0       ; re-entered at strat
fatal_error_1   equ     1       ; irpt without 1 strat
fatal_error_2   equ     2       ; 2 irpts per strat
fatal_error_3   equ     3       ; get_sqztor, number too low
fatal_error_4   equ     4       ; put_sqztor, number too low
fatal_error_5   equ     5       ; get_sqztor, number too high
fatal_error_6   equ     6       ; put_sqztor, number too high
fatal_error_7   equ     7       ; DOS system I/O too high
fatal_error_8   equ     8       ; DOS system I/O too low
fatal_error_9   equ     9       ; HEAP I/O too high
fatal_error_10  equ     10      ; HEAP I/O too low
fatal_error_11  equ     11      ; BITFAT I/O too high
fatal_error_12  equ     12      ; BITFAT I/O too low
fatal_error_13  equ     13      ; MDFAT I/O too high
fatal_error_14  equ     14      ; MDFAT I/O too low
fatal_error_15  equ     15      ; Bad signature check on CVF fragment list
fatal_error_16	equ	16	; Invalid int2f subfn (for forcing popup)
fatal_error_17	equ	17	; free to free sqztor
fatal_error_18	equ	18	; unfree to used sqztor

;;
;; Equates
;;

multMagicdrv    equ     4a11h   ; Int2f multiplex number

DRVMAP_CPR_BIT  equ     80h     ; bit indicating mounted CVF in drv_map array

cr              =       13
lf              =       10
tab             =       9
ctrlz           =       1ah

CVF_SEQ_SWAP    equ     0       ; Sequence number which implies SWAP
CVF_SEQ_MAX     equ     255     ; Maximum allowable sequence number

MAX_ACTIVATES   equ     24      ; 26 drive letters, less two floppies

BIG_CLUSTER     equ     8192            ;Size of BIG cluster (8K)
SMALL_CLUSTER   equ     4096            ;Size of SMALL cluster (4K)

BPTR    equ     BYTE PTR

MAX_FULL                equ     32  ;;64;Minimum of free sectors b4 we declare this disk as full
MAX_WARN                equ     256     ;Minimum free sectors to generate an 'almost full' warning

;; temp_buf_list values
ORIGINAL_DATA           equ     1       ;This sector has an original data
NEW_DATA                equ     2       ;This sector contains new data

MAX_DEMO_HIWORD_SIZE    equ     48      ;Maximum high word for demo file
MAX_SECTOR_SIZE         equ     2048    ;Maximum host sector size (2K)

IO_PART_SPACE           equ     2048    ;Page size for sqztor table
PART_CLUSTER_SIZE_POW2  equ     9       ;How many clusters per one page (DWORD per cluster)

BIT_FAT_SPACE           equ     2048    ;Page size of sec_list table (free space)
SECTORS_PER_BIT_FAT_POW2 equ    14      ;In power 2 if sectors
SECTORS_PER_BIT_FAT     equ     16384   ;Number of bits (sectors) in one page

;BPB equates
DBL_SIGN                equ     512     ;Where the 'DBL' signature can be located
RETRACT_SIGNATURE       equ     1       ; signature is last full sector, ie:
;                                       ;  end of file (rounded down to sector)
;                                       ;  minus 1

RH                      equ     ds:[bx] ;Addressability to Request Header structure

MAX_DISK_UNITS          equ     15      ;Maximumm of extended disk we can handle

cMINFILEFRAGMENTS       equ     50      ;Minimum file fragment heap size
cDEFFILEFRAGMENTS	equ	700	;Default  "      "	 "   "
cMAXFILEFRAGMENTS       equ     10000   ;Maximum  "      "       "   "

; cluster_to_Sqztor equates. See globals definition
NO_FLAGS_MASK           equ     001FH   ;Just the entry, without flags
RESERVED1_MASK          equ     0020H   ;Reserved bit just after 21-bit sector#
PHYSICAL_SIZE_MASK      equ     03C0H   ;Only the physical size bits
PHYSICAL_SIZE_OFFSET    equ     6       ;THe physical size bits offset
PLAINTEXT_MASK          equ     3C00H   ;Only the plaintext size bits
PLAINTEXT_OFFSET        equ     10      ;Plaintext size bits offset
UNCODED_CLUSTER_MASK    equ     4000H   ;Uncompress cluster bit
USED_CLUSTER_MASK       equ     8000H   ;Used cluster bit

PARA_SIZE_POW2          equ     4       ;Number of bytes in one 8088 paragraph
STACK_SIZE              equ     768     ;Size of our stack

; Device driver equates
READ_DISK_CMD           equ     4
WRITE_DISK_CMD          equ     8

STAT_WRITP              equ     8000H           ;Write protect violation
STAT_DFULL              equ     8027h           ;Disk full error
STAT_NRDY               equ     8002H           ;Device not ready
STAT_NOCOM              equ     8003H           ;Unkown command
STAT_CRC                equ     8004H           ;CRC error
STAT_SNF                equ     8008H           ;sector not found error
STAT_SEEK               equ     8006H           ;Seek error
STAT_WRITE              equ     800AH           ;Write FAULT
STAT_READ               equ     800BH           ;Read fault
STAT_GEN                equ     800CH           ;General failore

DOS        EQU  21H             ;DOS request INT
DOS_PCHR   EQU  02H             ;print character function

;Constants for compression/Decompression alg.
MAX_BITS        equ     12              ;Maximum bits (2048 entries)
TABLESIZE       equ     2048            ;Hash table size

shCHUNK         equ     9
cbCHUNK         equ     (1 shl shCHUNK) ; size of a 'chunk'
.errnz cbCHUNK ne 512
cbLONGCOPY      equ     32              ; do extra checking for string copies >= this


;Generic IOCTL return codes
NO_ERROR            equ 0               ;No error
LETTER_BOUNDRY_ERROR equ 1              ;Letter out of bounds
UNIT_USED_ERROR     equ 2               ;Unit already used
NO_FREE_SLOT_ERROR  equ 3               ;No reserved slot available
STAMP_ERROR         equ 4               ;Stamp error on extended disk


;Cluster signature
;Compressed clusters has the signature:
; 44 53 00 00   -  Cluster compressed real time
; 44 53 00 01   -  Cluster SuperCompressed offline
; 44 53 00 02   -  Cluster XCompressed real time
;
; NOTE: If you load these signature as words, they look like:
;
;   low  word = 5344h
;   high word = 0000h or 0100h

; XCMP defines a different REAL_TIME_COMPRESSED signature so a XCMP and
; non XCMP driver can be used on the same CVF and not get confused trying
; to UpdateCompress a XCMP block (XCMP does not support UpdateCompress).

SIG_SIZE                equ     4       ; 4 byte signature
STANDARD_COMPRESSED	equ  0000h	; High word of stamp
SUPER_COMPRESSED        equ  0100h      ; High word of stamp
X_COMPRESSED		equ  0200h	; High word of stamp
REAL_TIME_COMPRESSED    equ  X_COMPRESSED ; Stamp used for real-time compress

;;
;; We always keep at least 64k of extra sqztors around so a
;; file overwrite won't expand to more sqztors that are available.
;; Of course this is a raw heuristic since these should also
;; be contingous.  For more info, see dospatch.asm and
;; low_dlb.asm referenece to FUDGESTOR
FUDGESTOR       equ     128


; eXperimental compression code uses a lookup table to find past
; occurances of individual characters.	The table is currently
; 256 rows (1 for each possible byte value) X N (tracks N occurances
; of each character).

cltROWS EQU	256		; lookup table 256 rows x
cltCOLS EQU     8               ;   N columns

;
; The following basic structures were moved from MDSTRUC.INC to
; eliminate the need to include MDSTRUC.INC except where necessary;
; MDSTRUC.INC is primarily disk-management structures that are of no
; interest to MRCI.
;

;***	offst_segmt -- struc allows easy access to parts of dword pointer
;
offst_segmt	struc
offst	dw	0
segmt	dw	0
offst_segmt	ends

;***	loword_hiword -- struct allows easy access to words of dword
;
loword_hiword	struc
loword	dw	0
hiword	dw	0
loword_hiword	ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\ixbusdat.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixbusdat.c

Abstract:

    This module contains the IoXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would reside in the iosubs.c module.

Author:

Environment:

    Kernel mode

Revision History:


--*/

#include "bootx86.h"
#include "arc.h"
#include "ixfwhal.h"
#include "eisa.h"
#include "ntconfig.h"

ULONG
HalpGetCmosData(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

ULONG
HalpGetEisaData(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpGetPCIData(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpSetPCIData(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
HalpAssignPCISlotResources (
    IN ULONG                    BusNumber,
    IN ULONG                    Slot,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

/*
 *
 * Router functions.  Routes each call to specific handler
 *
 */


ULONG
HalGetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalGetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

ULONG
HalGetBusDataByOffset (
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for GetBusData

--*/
{
    switch (BusDataType) {
        case Cmos:
            if (Offset != 0) {
                return 0;
            }

            return HalpGetCmosData(BusNumber, Slot, Buffer, Length);

        case EisaConfiguration:
            return HalpGetEisaData(BusNumber, Slot, Buffer, Offset, Length);

        case PCIConfiguration:
            return HalpGetPCIData(BusNumber, Slot, Buffer, Offset, Length);
    }
    return 0;
}

ULONG
HalSetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalSetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

ULONG
HalSetBusDataByOffset(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for SetBusData

--*/
{
    switch (BusDataType) {
        case PCIConfiguration:
            return HalpSetPCIData(BusNumber, Slot, Buffer, Offset, Length);
    }
    return 0;
}


NTSTATUS
HalAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
/*++

Routine Description:

    Dispatcher for AssignSlotResources

--*/
{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( DriverObject );
    UNREFERENCED_PARAMETER( DriverClassName );
    UNREFERENCED_PARAMETER( RegistryPath );

    switch (BusType) {
        case PCIBus:
            return HalpAssignPCISlotResources (
                        BusNumber,
                        SlotNumber,
                        AllocatedResources
                        );
        default:
            break;
    }
    return STATUS_NOT_FOUND;
}





/**
 **
 ** Standard PC bus functions
 **
 **/



BOOLEAN
HalTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This function translates a bus-relative address space and address into
    a system physical address.

Arguments:

    BusNumber          - Supplies the bus number.  This is ignored on
                         standard x86 systems

    BusAddress         - Supplies the bus-relative address

    AddressSpace       - Supplies the address space number.
                         Returns the host address space number.

                         AddressSpace == 0 => I/O space
                         AddressSpace == 1 => memory space

    TranslatedAddress - Pointer to a physical_address.

Return Value:

    System physical address corresponding to the supplied bus relative
    address and bus address number.

--*/

{
    UNREFERENCED_PARAMETER( AddressSpace );
    UNREFERENCED_PARAMETER( BusNumber );
    UNREFERENCED_PARAMETER( InterfaceType );

    TranslatedAddress->HighPart = 0;
    TranslatedAddress->LowPart = BusAddress.LowPart;
    return(TRUE);
}


ULONG
HalpGetEisaData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*--

Arguments:

    BusDataType - Supplies the type of bus.

    BusNumber - Indicates which bus.

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/
{

    ULONG DataLength = 0;
    ULONG i;
    ULONG TotalDataSize;
    ULONG SlotDataSize = 0;
    ULONG PartialCount;
    PCONFIGURATION_COMPONENT_DATA ConfigData;
    PCM_EISA_SLOT_INFORMATION SlotInformation = NULL;
    PCM_PARTIAL_RESOURCE_LIST Descriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResource;
    BOOLEAN Found = FALSE;

    UNREFERENCED_PARAMETER( BusNumber );

    if (MachineType != MACHINE_TYPE_EISA) {
        return 0;
    }

    ConfigData = KeFindConfigurationEntry(
        FwConfigurationTree,
        AdapterClass,
        EisaAdapter,
        NULL
        );

    if (ConfigData == NULL) {
        DbgPrint("HalGetBusData: KeFindConfigurationEntry failed\n");
        return(0);
    }

    Descriptor = ConfigData->ConfigurationData;
    PartialResource = Descriptor->PartialDescriptors;
    PartialCount = Descriptor->Count;

    for (i = 0; i < PartialCount; i++) {

        //
        // Do each partial Resource
        //

        switch (PartialResource->Type) {
            case CmResourceTypeNull:
            case CmResourceTypePort:
            case CmResourceTypeInterrupt:
            case CmResourceTypeMemory:
            case CmResourceTypeDma:

                //
                // We dont care about these.
                //

                PartialResource++;

                break;

            case CmResourceTypeDeviceSpecific:

                //
                // Bingo!
                //

                TotalDataSize = PartialResource->u.DeviceSpecificData.DataSize;

                SlotInformation = (PCM_EISA_SLOT_INFORMATION)
                                    ((PUCHAR)PartialResource +
                                     sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

                while (((LONG)TotalDataSize) > 0) {

                    if (SlotInformation->ReturnCode == EISA_EMPTY_SLOT) {

                        SlotDataSize = sizeof(CM_EISA_SLOT_INFORMATION);

                    } else {

                        SlotDataSize = sizeof(CM_EISA_SLOT_INFORMATION) +
                                  SlotInformation->NumberFunctions *
                                  sizeof(CM_EISA_FUNCTION_INFORMATION);
                    }

                    if (SlotDataSize > TotalDataSize) {

                        //
                        // Something is wrong again
                        //

                        DbgPrint("HalGetBusData: SlotDataSize > TotalDataSize\n");

                        return(0);

                    }

                    if (SlotNumber != 0) {

                        SlotNumber--;

                        SlotInformation = (PCM_EISA_SLOT_INFORMATION)
                            ((PUCHAR)SlotInformation + SlotDataSize);

                        TotalDataSize -= SlotDataSize;

                        continue;

                    }

                    //
                    // This is our slot
                    //

                    Found = TRUE;
                    break;

                }

                //
                // End loop
                //

                i = PartialCount;

                break;

            default:

#if DBG
                DbgPrint("Bad Data in registry!\n");
#endif

                return(0);

        }

    }

    if (Found) {

        //
        // As a hack if the length is zero then the buffer points to a
        // PVOID where the pointer to the data should be stored.  This is
        // done in the loader because we quickly run out of heap scaning
        // all of the EISA configuration data.
        //

        if (Length == 0) {

            //
            // Return the pointer to the mini-port driver.
            //

            *((PVOID *)Buffer) = SlotInformation;
            return(SlotDataSize);
        }

        i = Length + Offset;
        if (i > SlotDataSize) {
            i = SlotDataSize;
        }

        DataLength = i - Offset;
        RtlMoveMemory(Buffer, ((PUCHAR) SlotInformation + Offset), DataLength);
    }

    return(DataLength);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\ixphwsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ixphwsup.c

Abstract:

    This module contains the IopXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would normally reside in the internal.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "bootx86.h"
#include "arc.h"
#include "ixfwhal.h"
#include "eisa.h"


PADAPTER_OBJECT
IopAllocateAdapter(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID ChannelNumber
    )

/*++

Routine Description:

    This routine allocates and initializes an adapter object to represent an
    adapter or a DMA controller on the system.  If no map registers are required
    then a standalone adapter object is allocated with no master adapter.

    If map registers are required, then a master adapter object is used to
    allocate the map registers.  For Isa systems these registers are really
    phyically contiguous memory pages.

Arguments:

    MapRegistersPerChannel - Specifies the number of map registers that each
        channel provides for I/O memory mapping.

    AdapterBaseVa - Address of the the DMA controller.

    ChannelNumber - Unused.

Return Value:

    The function value is a pointer to the allocate adapter object.

--*/

{

    PADAPTER_OBJECT AdapterObject;
    CSHORT Size;

    UNREFERENCED_PARAMETER( MapRegistersPerChannel );
    UNREFERENCED_PARAMETER( ChannelNumber );

    //
    // Determine the size of the adapter.
    //

    Size = sizeof( ADAPTER_OBJECT );

    //
    // Now create the adapter object.
    //

    AdapterObject = FwAllocateHeap(Size);

    //
    // If the adapter object was successfully created, then attempt to insert
    // it into the the object table.
    //

    if (AdapterObject) {

        RtlZeroMemory(AdapterObject, Size);

        //
        // Initialize the adapter object itself.
        //

        AdapterObject->Type = IO_TYPE_ADAPTER;
        AdapterObject->Size = Size;
        AdapterObject->MapRegistersPerChannel = 0;
        AdapterObject->AdapterBaseVa = AdapterBaseVa;
        AdapterObject->PagePort = NULL;
        AdapterObject->AdapterInUse = FALSE;

    } else {

        //
        // An error was incurred for some reason.  Set the return value
        // to NULL.
        //

        return(NULL);
    }

    return AdapterObject;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\ixpcibus.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixpcidat.c

Abstract:

    Get/Set bus data routines for the PCI bus

Author:

Environment:

    Kernel mode

Revision History:


--*/

#include "bootx86.h"
#include "arc.h"
#include "ixfwhal.h"
#include "ntconfig.h"

#include "pci.h"

//extern WCHAR rgzMultiFunctionAdapter[];
//extern WCHAR rgzConfigurationData[];
//extern WCHAR rgzIdentifier[];
//extern WCHAR rgzPCIIdentifier[];

//
// Hal specific PCI bus structures
//

typedef struct tagPCIPBUSDATA {
    union {
        struct {
            PULONG      Address;
            ULONG       Data;
        } Type1;
        struct {
            PUCHAR      CSE;
            PUCHAR      Forward;
            ULONG       Base;
        } Type2;
    } Config;

} PCIPBUSDATA, *PPCIPBUSDATA;

#define PciBitIndex(Dev,Fnc)    (Fnc*32 + Dev);
#define PCI_CONFIG_TYPE(PciData)    ((PciData)->HeaderType & ~PCI_MULTIFUNCTION)

#define BUSHANDLER  _BUSHANDLER
#define PBUSHANDLER _PBUSHANDLER

// thunk for NtLdr
typedef struct {
    ULONG           NoBuses;
    ULONG           BusNumber;
    PVOID           BusData;
    PCIPBUSDATA     theBusData;
} BUSHANDLER, *PBUSHANDLER;

#define HalpPCIPin2Line(bus,rbus,slot,pcidata)
#define HalpPCILine2Pin(bus,rbus,slot,pcidata,pcidata2)
#define ExAllocatePool(a,l) FwAllocatePool(l)
// thunk for NtLdr


typedef ULONG (*FncConfigIO) (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

typedef VOID (*FncSync) (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PKIRQL           Irql,
    IN PVOID            State
    );

typedef VOID (*FncReleaseSync) (
    IN PBUSHANDLER      BusHandler,
    IN KIRQL            Irql
    );

typedef struct {
    FncSync         Synchronize;
    FncReleaseSync  ReleaseSynchronzation;
    FncConfigIO     ConfigRead[3];
    FncConfigIO     ConfigWrite[3];
} CONFIG_HANDLER, *PCONFIG_HANDLER;


//
// Prototypes
//

ULONG
HalpGetPCIData (
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpSetPCIData (
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

extern ULONG
HalpGetPCIInterruptVector (
    IN PBUSHANDLER BusHandler,
    IN PBUSHANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

NTSTATUS
HalpAdjustPCIResourceList (
    IN PBUSHANDLER BusHandler,
    IN PBUSHANDLER RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

NTSTATUS
HalpAssignPCISlotResources (
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

VOID
HalpInitializePciBuses (
    VOID
    );

//VOID
//HalpPCIPin2Line (
//    IN PBUSHANDLER         BusHandler,
//    IN PBUSHANDLER         RootHandler,
//    IN PCI_SLOT_NUMBER     Slot,
//    IN PPCI_COMMON_CONFIG  PciData
//    );
//
//VOID
//HalpPCILine2Pin (
//    IN PBUSHANDLER          BusHandler,
//    IN PBUSHANDLER          RootHandler,
//    IN PCI_SLOT_NUMBER      SlotNumber,
//    IN PPCI_COMMON_CONFIG   PciNewData,
//    IN PPCI_COMMON_CONFIG   PciOldData
//    );

BOOLEAN
HalpValidPCISlot (
    IN PBUSHANDLER     BusHandler,
    IN PCI_SLOT_NUMBER Slot
    );

VOID
HalpReadPCIConfig (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


VOID
HalpWritePCIConfig (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

PBUSHANDLER
HalpGetPciBusHandler (
    IN ULONG BusNumber
    );

//-------------------------------------------------

VOID HalpPCISynchronizeType1 (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PKIRQL           Irql,
    IN PVOID            State
    );

VOID HalpPCIReleaseSynchronzationType1 (
    IN PBUSHANDLER      BusHandler,
    IN KIRQL            Irql
    );

ULONG HalpPCIReadUlongType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUcharType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUshortType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUlongType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUcharType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUshortType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

VOID HalpPCISynchronizeType2 (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PKIRQL           Irql,
    IN PVOID            State
    );

VOID HalpPCIReleaseSynchronzationType2 (
    IN PBUSHANDLER      BusHandler,
    IN KIRQL            Irql
    );

ULONG HalpPCIReadUlongType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUcharType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUshortType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUlongType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUcharType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUshortType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );


#define DISABLE_INTERRUPTS() //_asm { cli }
#define ENABLE_INTERRUPTS()  //_asm { sti }


//
// Globals
//

ULONG               PCIMaxDevice;
BUSHANDLER          PCIBusHandler;

CONFIG_HANDLER      PCIConfigHandlers = {
    HalpPCISynchronizeType1,
    HalpPCIReleaseSynchronzationType1,
    {
        HalpPCIReadUlongType1,          // 0
        HalpPCIReadUcharType1,          // 1
        HalpPCIReadUshortType1          // 2
    },
    {
        HalpPCIWriteUlongType1,         // 0
        HalpPCIWriteUcharType1,         // 1
        HalpPCIWriteUshortType1         // 2
    }
};

CONFIG_HANDLER      PCIConfigHandlersType2 = {
    HalpPCISynchronizeType2,
    HalpPCIReleaseSynchronzationType2,
    {
        HalpPCIReadUlongType2,          // 0
        HalpPCIReadUcharType2,          // 1
        HalpPCIReadUshortType2          // 2
    },
    {
        HalpPCIWriteUlongType2,         // 0
        HalpPCIWriteUcharType2,         // 1
        HalpPCIWriteUshortType2         // 2
    }
};

UCHAR PCIDeref[4][4] = { {0,1,2,2},{1,1,1,1},{2,1,2,2},{1,1,1,1} };


VOID
HalpPCIConfig (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PUCHAR           Buffer,
    IN ULONG            Offset,
    IN ULONG            Length,
    IN FncConfigIO      *ConfigIO
    );


VOID
HalpInitializePciBus (
    VOID
    )
{
    PPCI_REGISTRY_INFO  PCIRegInfo;
    PPCIPBUSDATA        BusData;
    PBUSHANDLER         Bus;
    PCONFIGURATION_COMPONENT_DATA   ConfigData;
    PCM_PARTIAL_RESOURCE_LIST       Desc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PDesc;
    ULONG               i;
    ULONG               HwType;

    Bus = &PCIBusHandler;
    PCIBusHandler.BusData = &PCIBusHandler.theBusData;

    PCIRegInfo = NULL;      // not found
    ConfigData = NULL;      // start at begining
    do {
        ConfigData = KeFindConfigurationNextEntry (
            FwConfigurationTree,
            AdapterClass,
            MultiFunctionAdapter,
            NULL,
            &ConfigData
            );

        if (ConfigData == NULL) {
            // PCI info not found
            return ;
        }

        if (ConfigData->ComponentEntry.Identifier == NULL  ||
            _stricmp (ConfigData->ComponentEntry.Identifier, "PCI") != 0) {
            continue;
        }

        PCIRegInfo = NULL;
        Desc  = ConfigData->ConfigurationData;
        PDesc = Desc->PartialDescriptors;
        for (i = 0; i < Desc->Count; i++) {
            if (PDesc->Type == CmResourceTypeDeviceSpecific) {
                PCIRegInfo = (PPCI_REGISTRY_INFO) (PDesc+1);
                break;
            }
            PDesc++;
        }
    } while (!PCIRegInfo) ;

    //
    // PCIRegInfo describes the system's PCI support as indicated
    // by the BIOS.
    //

    HwType = PCIRegInfo->HardwareMechanism & 0xf;

    switch (HwType) {
        case 1:
            // this is the default case
            PCIMaxDevice = PCI_MAX_DEVICES;
            break;

        //
        // Type2 does not work MP, nor does the default type2
        // support more the 0xf device slots
        //

        case 2:
            RtlMoveMemory (&PCIConfigHandlers,
                           &PCIConfigHandlersType2,
                           sizeof (PCIConfigHandlersType2));
            PCIMaxDevice = 0x10;
            break;

        default:
            // unsupport type
            PCIRegInfo->NoBuses = 0;
    }

    PCIBusHandler.NoBuses = PCIRegInfo->NoBuses;
    if (PCIRegInfo->NoBuses) {

        BusData = (PPCIPBUSDATA) Bus->BusData;
        switch (HwType) {
            case 1:
                BusData->Config.Type1.Address = (PULONG)PCI_TYPE1_ADDR_PORT;
                BusData->Config.Type1.Data    = PCI_TYPE1_DATA_PORT;
                break;

            case 2:
                BusData->Config.Type2.CSE     = PCI_TYPE2_CSE_PORT;
                BusData->Config.Type2.Forward = PCI_TYPE2_FORWARD_PORT;
                BusData->Config.Type2.Base    = PCI_TYPE2_ADDRESS_BASE;
                break;
        }
    }
}


PBUSHANDLER
HalpGetPciBusHandler (
    IN ULONG BusNumber
    )
{
    if (PCIBusHandler.BusData == NULL) {
        HalpInitializePciBus ();
    }

    if (BusNumber > PCIBusHandler.NoBuses) {
        return NULL;
    }

    PCIBusHandler.BusNumber = BusNumber;
    return &PCIBusHandler;
}


ULONG
HalpGetPCIData (
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER Slot,
    IN PUCHAR Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the Pci bus data for a device.

Arguments:

    BusNumber - Indicates which bus.

    VendorSpecificDevice - The VendorID (low Word) and DeviceID (High Word)

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

    If this PCI slot has never been set, then the configuration information
    returned is zeroed.


--*/
{
    PBUSHANDLER         BusHandler;
    PPCI_COMMON_CONFIG  PciData;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    PPCIPBUSDATA        BusData;
    ULONG               Len;

    BusHandler = HalpGetPciBusHandler (BusNumber);
    if (!BusHandler) {
        return 0;
    }

    if (Length > sizeof (PCI_COMMON_CONFIG)) {
        Length = sizeof (PCI_COMMON_CONFIG);
    }

    Len = 0;
    PciData = (PPCI_COMMON_CONFIG) iBuffer;

    if (Offset >= PCI_COMMON_HDR_LENGTH) {
        //
        // The user did not request any data from the common
        // header.  Verify the PCI device exists, then continue
        // in the device specific area.
        //

        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, sizeof(ULONG));

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            return 0;
        }

    } else {

        //
        // Caller requested at least some data within the
        // common header.  Read the whole header, effect the
        // fields we need to and then copy the user's requested
        // bytes from the header
        //

        //
        // Read this PCI devices slot data
        //

        Len = PCI_COMMON_HDR_LENGTH;
        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, Len);

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            Len = 2;       // only return invalid id
        }

        //
        // Has this PCI device been configured?
        //

        BusData = (PPCIPBUSDATA) BusHandler->BusData;
        HalpPCIPin2Line (BusHandler, RootHandler, Slot, PciData);

        //
        // Copy whatever data overlaps into the callers buffer
        //

        if (Len < Offset) {
            // no data at caller's buffer
            return 0;
        }

        Len -= Offset;
        if (Len > Length) {
            Len = Length;
        }

        RtlMoveMemory(Buffer, iBuffer + Offset, Len);

        Offset += Len;
        Buffer += Len;
        Length -= Len;
    }

    if (Length) {
        if (Offset >= PCI_COMMON_HDR_LENGTH) {
            //
            // The remaining Buffer comes from the Device Specific
            // area - put on the kitten gloves and read from it.
            //
            // Specific read/writes to the PCI device specific area
            // are guarenteed:
            //
            //    Not to read/write any byte outside the area specified
            //    by the caller.  (this may cause WORD or BYTE references
            //    to the area in order to read the non-dword aligned
            //    ends of the request)
            //
            //    To use a WORD access if the requested length is exactly
            //    a WORD long & WORD aligned.
            //
            //    To use a BYTE access if the requested length is exactly
            //    a BYTE long.
            //

            HalpReadPCIConfig (BusHandler, Slot, Buffer, Offset, Length);
            Len += Length;
        }
    }

    return Len;
}

ULONG
HalpSetPCIData (
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER Slot,
    IN PUCHAR Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the Pci bus data for a device.

Arguments:


    VendorSpecificDevice - The VendorID (low Word) and DeviceID (High Word)

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/
{
    PBUSHANDLER         BusHandler;
    PPCI_COMMON_CONFIG  PciData, PciData2;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    UCHAR               iBuffer2[PCI_COMMON_HDR_LENGTH];
    PPCIPBUSDATA        BusData;
    ULONG               Len;

    BusHandler = HalpGetPciBusHandler (BusNumber);
    if (!BusHandler) {
        return 0;
    }

    if (Length > sizeof (PCI_COMMON_CONFIG)) {
        Length = sizeof (PCI_COMMON_CONFIG);
    }

    Len = 0;
    PciData = (PPCI_COMMON_CONFIG) iBuffer;
    PciData2 = (PPCI_COMMON_CONFIG) iBuffer2;

    if (Offset >= PCI_COMMON_HDR_LENGTH) {
        //
        // The user did not request any data from the common
        // header.  Verify the PCI device exists, then continue in
        // the device specific area.
        //

        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, sizeof(ULONG));

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            return 0;
        }

    } else {

        //
        // Caller requested to set at least some data within the
        // common header.
        //

        Len = PCI_COMMON_HDR_LENGTH;
        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, Len);
        if (PciData->VendorID == PCI_INVALID_VENDORID  ||
            PCI_CONFIG_TYPE (PciData) != 0) {

            // no device, or header type unkown
            return 0;
        }

        //
        // Set this device as configured
        //

        BusData = (PPCIPBUSDATA) BusHandler->BusData;
        //
        // Copy COMMON_HDR values to buffer2, then overlay callers changes.
        //

        RtlMoveMemory (iBuffer2, iBuffer, Len);

        Len -= Offset;
        if (Len > Length) {
            Len = Length;
        }

        RtlMoveMemory (iBuffer2+Offset, Buffer, Len);

        // in case interrupt line or pin was editted
        HalpPCILine2Pin (BusHandler, RootHandler, Slot, PciData2, PciData);

        //
        // Set new PCI configuration
        //

        HalpWritePCIConfig (BusHandler, Slot, iBuffer2+Offset, Offset, Len);

        Offset += Len;
        Buffer += Len;
        Length -= Len;
    }

    if (Length) {
        if (Offset >= PCI_COMMON_HDR_LENGTH) {
            //
            // The remaining Buffer comes from the Device Specific
            // area - put on the kitten gloves and write it
            //
            // Specific read/writes to the PCI device specific area
            // are guarenteed:
            //
            //    Not to read/write any byte outside the area specified
            //    by the caller.  (this may cause WORD or BYTE references
            //    to the area in order to read the non-dword aligned
            //    ends of the request)
            //
            //    To use a WORD access if the requested length is exactly
            //    a WORD long & WORD aligned.
            //
            //    To use a BYTE access if the requested length is exactly
            //    a BYTE long.
            //

            HalpWritePCIConfig (BusHandler, Slot, Buffer, Offset, Length);
            Len += Length;
        }
    }

    return Len;
}

VOID
HalpReadPCIConfig (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    if (!HalpValidPCISlot (BusHandler, Slot)) {
        //
        // Invalid SlotID return no data
        //

        RtlFillMemory (Buffer, Length, (UCHAR) -1);
        return ;
    }

    HalpPCIConfig (BusHandler, Slot, (PUCHAR) Buffer, Offset, Length,
                   PCIConfigHandlers.ConfigRead);
}

VOID
HalpWritePCIConfig (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    if (!HalpValidPCISlot (BusHandler, Slot)) {
        //
        // Invalid SlotID do nothing
        //
        return ;
    }

    HalpPCIConfig (BusHandler, Slot, (PUCHAR) Buffer, Offset, Length,
                   PCIConfigHandlers.ConfigWrite);
}

BOOLEAN
HalpValidPCISlot (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot
    )
{
    PCI_SLOT_NUMBER                 Slot2;
    UCHAR                           HeaderType;
    ULONG                           i;

    if (Slot.u.bits.Reserved != 0) {
        return FALSE;
    }

    if (Slot.u.bits.DeviceNumber >= PCIMaxDevice) {
        return FALSE;
    }

    if (Slot.u.bits.FunctionNumber == 0) {
        return TRUE;
    }

    //
    // Non zero function numbers are only supported if the
    // device has the PCI_MULTIFUNCTION bit set in it's header
    //

    i = Slot.u.bits.DeviceNumber;

    //
    // Read DeviceNumber, Function zero, to determine if the
    // PCI supports multifunction devices
    //

    Slot2 = Slot;
    Slot2.u.bits.FunctionNumber = 0;

    HalpReadPCIConfig (
        BusHandler,
        Slot2,
        &HeaderType,
        FIELD_OFFSET (PCI_COMMON_CONFIG, HeaderType),
        sizeof (UCHAR)
        );

    if (!(HeaderType & PCI_MULTIFUNCTION) || HeaderType == 0xFF) {
        // this device doesn't exists or doesn't support MULTIFUNCTION types
        return FALSE;
    }

    return TRUE;
}


VOID
HalpPCIConfig (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PUCHAR           Buffer,
    IN ULONG            Offset,
    IN ULONG            Length,
    IN FncConfigIO      *ConfigIO
    )
{
    KIRQL               OldIrql;
    ULONG               i;
    UCHAR               State[20];
    PPCIPBUSDATA        BusData;

    BusData = (PPCIPBUSDATA) BusHandler->BusData;
    PCIConfigHandlers.Synchronize (BusHandler, Slot, &OldIrql, State);

    while (Length) {
        i = PCIDeref[Offset % sizeof(ULONG)][Length % sizeof(ULONG)];
        i = ConfigIO[i] (BusData, State, Buffer, Offset);

        Offset += i;
        Buffer += i;
        Length -= i;
    }

    PCIConfigHandlers.ReleaseSynchronzation (BusHandler, OldIrql);
}

VOID HalpPCISynchronizeType1 (
    IN PBUSHANDLER          BusHandler,
    IN PCI_SLOT_NUMBER      Slot,
    IN PKIRQL               Irql,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1
    )
{
    UNREFERENCED_PARAMETER( Irql );

    //
    // Initialize PciCfg1
    //

    PciCfg1->u.AsULONG = 0;
    PciCfg1->u.bits.BusNumber = BusHandler->BusNumber;
    PciCfg1->u.bits.DeviceNumber = Slot.u.bits.DeviceNumber;
    PciCfg1->u.bits.FunctionNumber = Slot.u.bits.FunctionNumber;
    PciCfg1->u.bits.Enable = TRUE;

    //
    // Synchronize with PCI type1 config space
    //

    //KeAcquireSpinLock (&HalpPCIConfigLock, Irql);
}

VOID HalpPCIReleaseSynchronzationType1 (
    IN PBUSHANDLER      BusHandler,
    IN KIRQL            Irql
    )
{
    PCI_TYPE1_CFG_BITS  PciCfg1;
    PPCIPBUSDATA        BusData;

    UNREFERENCED_PARAMETER( Irql );
    
    //
    // Disable PCI configuration space
    //

    PciCfg1.u.AsULONG = 0;
    BusData = (PPCIPBUSDATA) BusHandler->BusData;
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1.u.AsULONG);

    //
    // Release spinlock
    //

    //KeReleaseSpinLock (&HalpPCIConfigLock, Irql);
}


ULONG
HalpPCIReadUcharType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    *Buffer = READ_PORT_UCHAR ((PUCHAR) (BusData->Config.Type1.Data + i));
    return sizeof (UCHAR);
}

ULONG
HalpPCIReadUshortType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    *((PUSHORT) Buffer) = READ_PORT_USHORT ((PUSHORT) (BusData->Config.Type1.Data + i));
    return sizeof (USHORT);
}

ULONG
HalpPCIReadUlongType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    *((PULONG) Buffer) = READ_PORT_ULONG ((PULONG) BusData->Config.Type1.Data);
    return sizeof (ULONG);
}


ULONG
HalpPCIWriteUcharType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    WRITE_PORT_UCHAR ((PUCHAR) (BusData->Config.Type1.Data + i), *Buffer);
    return sizeof (UCHAR);
}

ULONG
HalpPCIWriteUshortType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    WRITE_PORT_USHORT ((PUSHORT) (BusData->Config.Type1.Data + i), *((PUSHORT) Buffer));
    return sizeof (USHORT);
}

ULONG
HalpPCIWriteUlongType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    WRITE_PORT_ULONG ((PULONG) BusData->Config.Type1.Data, *((PULONG) Buffer));
    return sizeof (ULONG);
}


VOID HalpPCISynchronizeType2 (
    IN PBUSHANDLER              BusHandler,
    IN PCI_SLOT_NUMBER          Slot,
    IN PKIRQL                   Irql,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr
    )
{
    PCI_TYPE2_CSE_BITS      PciCfg2Cse;
    PPCIPBUSDATA            BusData;

    UNREFERENCED_PARAMETER( Irql );

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    //
    // Initialize Cfg2Addr
    //

    PciCfg2Addr->u.AsUSHORT = 0;
    PciCfg2Addr->u.bits.Agent = (USHORT) Slot.u.bits.DeviceNumber;
    PciCfg2Addr->u.bits.AddressBase = (USHORT) BusData->Config.Type2.Base;

    //
    // Synchronize with type2 config space - type2 config space
    // remaps 4K of IO space, so we can not allow other I/Os to occur
    // while using type2 config space, hence the disable_interrupts.
    //

    //KeAcquireSpinLock (&HalpPCIConfigLock, Irql);
    //DISABLE_INTERRUPTS ();                      // is not MP safe

    PciCfg2Cse.u.AsUCHAR = 0;
    PciCfg2Cse.u.bits.Enable = TRUE;
    PciCfg2Cse.u.bits.FunctionNumber = (UCHAR) Slot.u.bits.FunctionNumber;
    PciCfg2Cse.u.bits.Key = 0xff;

    //
    // Select bus & enable type 2 configuration space
    //

    WRITE_PORT_UCHAR (BusData->Config.Type2.Forward, (UCHAR) BusHandler->BusNumber);
    WRITE_PORT_UCHAR (BusData->Config.Type2.CSE, PciCfg2Cse.u.AsUCHAR);
}


VOID HalpPCIReleaseSynchronzationType2 (
    IN PBUSHANDLER          BusHandler,
    IN KIRQL                Irql
    )
{
    PCI_TYPE2_CSE_BITS      PciCfg2Cse;
    PPCIPBUSDATA            BusData;

    UNREFERENCED_PARAMETER( Irql );

    //
    // disable PCI configuration space
    //

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    PciCfg2Cse.u.AsUCHAR = 0;
    WRITE_PORT_UCHAR (BusData->Config.Type2.CSE, PciCfg2Cse.u.AsUCHAR);

    //
    // Restore interrupts, release spinlock
    //

    //ENABLE_INTERRUPTS ();
    //KeReleaseSpinLock (&HalpPCIConfigLock, Irql);
}


ULONG
HalpPCIReadUcharType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    UNREFERENCED_PARAMETER( BusData );

    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    *Buffer = READ_PORT_UCHAR ((PUCHAR) ((ULONG)PciCfg2Addr->u.AsUSHORT));
    return sizeof (UCHAR);
}

ULONG
HalpPCIReadUshortType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    USHORT RetVal;

    UNREFERENCED_PARAMETER( BusData );

    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    RetVal = READ_PORT_USHORT ((PUSHORT) ((ULONG)PciCfg2Addr->u.AsUSHORT));
    *Buffer = TRUNCATE_SIZE_AT_UCHAR_MAX(RetVal);

    return sizeof (USHORT);
}

ULONG
HalpPCIReadUlongType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    ULONG RetVal;

    UNREFERENCED_PARAMETER( BusData );

    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    RetVal = READ_PORT_ULONG ((PULONG) ((ULONG) PciCfg2Addr->u.AsUSHORT));
    *Buffer = TRUNCATE_SIZE_AT_UCHAR_MAX(RetVal);

    return sizeof(ULONG);
}


ULONG
HalpPCIWriteUcharType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    UNREFERENCED_PARAMETER( BusData );

    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    WRITE_PORT_UCHAR ((PUCHAR) ((ULONG)PciCfg2Addr->u.AsUSHORT), *Buffer);
    return sizeof (UCHAR);
}

ULONG
HalpPCIWriteUshortType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    UNREFERENCED_PARAMETER( BusData );

    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    WRITE_PORT_USHORT ((PUSHORT) ((ULONG)PciCfg2Addr->u.AsUSHORT), *((PUSHORT) Buffer));
    return sizeof (USHORT);
}

ULONG
HalpPCIWriteUlongType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    UNREFERENCED_PARAMETER( BusData );

    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    WRITE_PORT_ULONG ((PULONG) ((ULONG)PciCfg2Addr->u.AsUSHORT), *((PULONG) Buffer));
    return sizeof(ULONG);
}

NTSTATUS
HalpAssignPCISlotResources (
    IN ULONG                    BusNumber,
    IN ULONG                    Slot,
    IN OUT PCM_RESOURCE_LIST   *pAllocatedResources
    )
/*++

Routine Description:

    Reads the targeted device to determine it's required resources.
    Calls IoAssignResources to allocate them.
    Sets the targeted device with it's assigned resoruces
    and returns the assignments to the caller.

Arguments:

Return Value:

    STATUS_SUCCESS or error

--*/
{
    PBUSHANDLER                     BusHandler;
    UCHAR                           buffer[PCI_COMMON_HDR_LENGTH];
    UCHAR                           buffer2[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG              PciData, PciData2;
    PCI_SLOT_NUMBER                 PciSlot;
    ULONG                           i, j, length, type;
    PHYSICAL_ADDRESS                Address;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor;
    static PCM_RESOURCE_LIST        CmResList;
    USHORT                          NewCommand;

    BusHandler = HalpGetPciBusHandler (BusNumber);
    if (!BusHandler) {
        return 0;
    }

    *pAllocatedResources = NULL;

    PciData  = (PPCI_COMMON_CONFIG) buffer;
    PciData2 = (PPCI_COMMON_CONFIG) buffer2;
    PciSlot  = *((PPCI_SLOT_NUMBER) &Slot);
    BusNumber = BusHandler->BusNumber;

    //
    // Read the PCI device's configuration
    //

    HalpReadPCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    if (PciData->VendorID == PCI_INVALID_VENDORID) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Make a copy of the device's current settings
    //

    RtlMoveMemory (buffer2, buffer, PCI_COMMON_HDR_LENGTH);

    //
    // Set resources to all bits on to see what type of resources
    // are required.
    //

    for (j=0; j < PCI_TYPE0_ADDRESSES; j++) {
        PciData->u.type0.BaseAddresses[j] = 0xFFFFFFFF;
    }
    PciData->u.type0.ROMBaseAddress = 0xFFFFFFFF;

    NewCommand = PciData->Command;
    PciData->Command &= ~(PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE);
    PciData->u.type0.ROMBaseAddress &= ~PCI_ROMADDRESS_ENABLED;
    HalpWritePCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    HalpReadPCIConfig  (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    HalpPCIPin2Line (BusHandler, RootHandler, PciSlot, PciData);

    //
    // Restore the device's settings in case we don't complete
    //

    HalpWritePCIConfig (BusHandler, PciSlot, buffer2, 0, PCI_COMMON_HDR_LENGTH);

    //
    // Build a CmResource descriptor list for the device
    //

    if (!CmResList) {
        // NtLdr pool is only allocated and never freed.  Allocate the
        // buffer once, and from then on just use the buffer over

        CmResList = ExAllocatePool (PagedPool,
            sizeof (CM_RESOURCE_LIST) +
            sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR) * (PCI_TYPE0_ADDRESSES + 2)
            );
    }

    if (!CmResList) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory (CmResList,
        sizeof (CM_RESOURCE_LIST) +
        sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR) * (PCI_TYPE0_ADDRESSES + 2)
        );

    *pAllocatedResources = CmResList;
    CmResList->List[0].InterfaceType = PCIBus;
    CmResList->List[0].BusNumber = BusNumber;

    CmDescriptor = CmResList->List[0].PartialResourceList.PartialDescriptors;
    if (PciData->u.type0.InterruptPin) {

        CmDescriptor->Type = CmResourceTypeInterrupt;
        CmDescriptor->ShareDisposition = CmResourceShareShared;
        CmDescriptor->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;

        // in the loader interrupts aren't actually enabled, so just
        // pass back the untranslated values
        CmDescriptor->u.Interrupt.Level = PciData->u.type0.InterruptLine;
        CmDescriptor->u.Interrupt.Vector =  PciData->u.type0.InterruptLine;
        CmDescriptor->u.Interrupt.Affinity = 1;

        CmResList->List[0].PartialResourceList.Count++;
        CmDescriptor++;
    }

    // clear last address index + 1
    PciData->u.type0.BaseAddresses[PCI_TYPE0_ADDRESSES] = 0;
    if (PciData2->u.type0.ROMBaseAddress & PCI_ROMADDRESS_ENABLED) {

        // put rom address in last index+1
        PciData->u.type0.BaseAddresses[PCI_TYPE0_ADDRESSES] =
            PciData->u.type0.ROMBaseAddress & ~PCI_ADDRESS_IO_SPACE;

        PciData2->u.type0.BaseAddresses[PCI_TYPE0_ADDRESSES] =
            PciData2->u.type0.ROMBaseAddress & ~PCI_ADDRESS_IO_SPACE;
    }

    for (j=0; j < PCI_TYPE0_ADDRESSES + 1; j++) {
        if (PciData->u.type0.BaseAddresses[j]) {
            i = PciData->u.type0.BaseAddresses[j];

            //
            // Make sure the appropriate decode is turned on for this BAR.
            //
            if (i & PCI_ADDRESS_IO_SPACE) {
                NewCommand |= PCI_ENABLE_IO_SPACE;
            } else {
                NewCommand |= PCI_ENABLE_MEMORY_SPACE;
            }

            // scan for first set bit, that's the length & alignment
            length = 1 << (i & PCI_ADDRESS_IO_SPACE ? 2 : 4);
            Address.HighPart = 0;
            Address.LowPart = PciData2->u.type0.BaseAddresses[j] & ~(length-1);
            while (!(i & length)  &&  length) {
                length <<= 1;
            }

            // translate bus specific address
            type = (i & PCI_ADDRESS_IO_SPACE) ? 0 : 1;
            if (!HalTranslateBusAddress (
                    PCIBus,
                    BusNumber,
                    Address,
                    &type,
                    &Address )) {
                // translation failed, skip it
                continue;
            }

            // fill in CmDescriptor to return
            if (type == 0) {
                CmDescriptor->Type = CmResourceTypePort;
                CmDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                CmDescriptor->Flags = CM_RESOURCE_PORT_IO;
                CmDescriptor->u.Port.Length = length;
                CmDescriptor->u.Port.Start = Address;
            } else {
                CmDescriptor->Type = CmResourceTypeMemory;
                CmDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                CmDescriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
                CmDescriptor->u.Memory.Length = length;
                CmDescriptor->u.Memory.Start = Address;

                if (j == PCI_TYPE0_ADDRESSES) {
                    // this is a ROM address
                    CmDescriptor->Flags = CM_RESOURCE_MEMORY_READ_ONLY;
                }
            }

            CmResList->List[0].PartialResourceList.Count++;
            CmDescriptor++;

            if (i & PCI_TYPE_64BIT) {
                // skip upper half of 64 bit address.
                j++;
            }
        }
    }

    //
    // If any decodes need to be turned on, do this now.
    //
    if (NewCommand != PciData2->Command) {
        HalpWritePCIConfig(BusHandler, 
                           PciSlot, 
                           &NewCommand, 
                           FIELD_OFFSET(PCI_COMMON_CONFIG, Command), 
                           sizeof(NewCommand));
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\misc.asm ===
;++
;
;Copyright (c) 2001  Microsoft Corporation
;
;Module Name:
;
;    misc.asm
;
;Abstract:
;
;
;Author:
;
;   Chuck Lenzmeier (chuckl) 27-May-2001
;
;Revision History:
;
;   Two routines moved from wakea.asm
;--


.586p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros

_TEXT   SEGMENT PARA PUBLIC 'CODE'       ; Start 32 bit code
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

cPublicProc  _ENABLE_PSE,0
        mov     eax, cr4
        or      eax, CR4_PSE
        mov     cr4, eax
        stdRET _ENABLE_PSE
stdENDP _ENABLE_PSE


cPublicProc  _FLUSH_TB,0
        mov     eax, cr3
        mov     cr3, eax
        stdRET _FLUSH_TB
stdENDP _FLUSH_TB

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\memory.c ===
/*++


Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    memory.c

Abstract:

    This module sets up paging so that the first 1Mb of virtual memory is
    directly mapped to the first 1Mb of physical memory.  This allows the
    BIOS callbacks to work, and the osloader to continue running below
    1Mb.  It also maps up to the first 16MB of physical memory to KSEG0_BASE
    and ALTERNATE_BASE, so the osloader can load kernel code into kernel
    space, and allocate kernel parameters in kernel space. This allows the
    dynamic configuration of the system for either a 2gb or 3gb user space
    address range.

Note!!
    3/16/00 (mikeg):
        All I/O (BlRead etc.) use a buffer below 1MB to do transfers so we
        don't need to worry about ISA cards DMA buffers. This change allows
        setupldr to run with all files compressed.
        If you need to change this, also change BASE_LOADER_IMAGE in bootx86.h
        or the PDE will not be completely unmapped. This must ALSO match
        ntos\mm\i386\mi386.h (BOOT_IMAGE_SIZE) so we know where
        to start loading images.



Memory Map used by NTLDR:

    000000 - 000fff         RM IDT & Bios Data Area

    007C00 - 007fff         BPB loaded by Bootstrap

    010000 - 01ffff         Loadable miniport drivers, free memory

    020000 - 02ffff         SU + real-mode stack

    030000 - 039000         BIOS disk cache

    039000 - 039000         Permanent heap (GDT, IDT, TSS, Page Dir, Page Tables)
                            (grows up)
                                |
                                v

                                ^
                                |
                            (grows down)
    039000 - 05ffff         Temporary heap

    060000 - 062000         osloader stack (grows down)

    062000 - 09ffff         osloader heap (grows down)

    0b8000 - 0bbfff         Video Buffer

    0d0000 - 0fffff         Bios and Adaptor ROM area

Author:

    John Vert (jvert) 18-Jun-1991

Environment:

    Kernel Mode


Revision History:


--*/

#include "arccodes.h"
#include "bootx86.h"

//
// 4-gigabyte boundary line (in pages)
//

#define _4G (1 << (32 - PAGE_SHIFT))

//
// Bogus memory line.  (We don't ever want to use the memory that is in
// the 0x40 pages just under the 16Mb line.)
//

#define _16MB_BOGUS (((ULONG)0x1000000-0x40*PAGE_SIZE) >> PAGE_SHIFT)

#define ROM_START_PAGE (0x0A0000 >> PAGE_SHIFT)
#define ROM_END_PAGE   (0x100000 >> PAGE_SHIFT)

//
// Buffer for temporary storage of data read from the disk that needs
// to end up in a location above the 1MB boundary.
//
// NOTE: it is very important that this buffer not cross a 64k boundary.
//
PUCHAR FwDiskCache = (PUCHAR)(BIOS_DISK_CACHE_START * PAGE_SIZE);

//
// Current heap start pointers (physical addresses)
// Note that 0x50000 to 0x5ffff is reserved for detection configuration memory
//
ULONG FwPermanentHeap = PERMANENT_HEAP_START * PAGE_SIZE;
ULONG FwTemporaryHeap = (TEMPORARY_HEAP_START - 0x10) * PAGE_SIZE;


//
// Current pool pointers.  This is different than the temporary/permanent
// heaps, because it is not required to be under 1MB.  It is used by the
// SCSI miniports for allocating their extensions and for the dbcs font image.
//

#define FW_POOL_SIZE 96
ULONG FwPoolStart;
ULONG FwPoolEnd;

//
// This gets set to FALSE right before we call into the osloader, so we
// know that the fw memory descriptors can no longer be changed at will.
//
BOOLEAN FwDescriptorsValid = TRUE;


ULONG HighestPde=((_16MB << PAGE_SHIFT) >> PDI_SHIFT);

//
// Private function prototypes
//

ARC_STATUS
MempCopyGdt(
    VOID
    );

ARC_STATUS
MempSetupPaging(
    IN ULONG StartPage,
    IN ULONG NumberOfPages
    );

VOID
MempDisablePages(
    VOID
    );

ARC_STATUS
MempTurnOnPaging(
    VOID
    );

ARC_STATUS
MempSetDescriptorRegion (
    IN ULONG StartPage,
    IN ULONG EndPage,
    IN TYPE_OF_MEMORY MemoryType
    );

ARC_STATUS
MempSetPageMappingOverride(
    IN ULONG StartPage,
    IN ULONG NumberOfPages,
    IN BOOLEAN Enable
    );

extern
void
BlpTrackUsage (
    MEMORY_TYPE MemoryType,
    ULONG ActualBase,
    ULONG  NumberPages
    );
//
// Global - memory management variables.
//

PHARDWARE_PTE PDE;
PHARDWARE_PTE HalPT;

#define MAX_DESCRIPTORS 60

MEMORY_DESCRIPTOR MDArray[MAX_DESCRIPTORS];      // Memory Descriptor List

ULONG NumberDescriptors=0;

ARC_STATUS
InitializeMemorySubsystem(
    PBOOT_CONTEXT BootContext
    )
/*++

Routine Description:

    The initial heap is mapped and allocated. Pointers to the
    Page directory and page tables are initialized.

Arguments:

    BootContext - Supplies basic information provided by SU module.

Returns:

    ESUCCESS - Memory succesfully initialized.

--*/

{
    ARC_STATUS Status = ESUCCESS;
    PSU_MEMORY_DESCRIPTOR SuMemory;
    ULONG PageStart;
    ULONG PageEnd;
    ULONG RomStart = ROM_START_PAGE;
    ULONG LoaderStart;
    ULONG LoaderEnd;
    ULONG BAddr, EAddr, BRound, ERound;

    //
    // Start by creating memory descriptors to describe all of the memory
    // we know about.  Then setup the page tables.  Finally, allocate
    // descriptors that describe our memory layout.
    //

    //
    // We know that one of the SU descriptors is for < 1Mb,
    // and we don't care about that, since we know everything we'll run
    // on will have at least 1Mb of memory.  The rest are for extended
    // memory, and those are the ones we are interested in.
    //

    SuMemory = BootContext->MemoryDescriptorList;
    while (SuMemory->BlockSize != 0) {

        BAddr = SuMemory->BlockBase;
        EAddr = BAddr + SuMemory->BlockSize - 1;

        //
        // Round the starting address to a page boundry.
        //

        BRound = BAddr & (ULONG) (PAGE_SIZE - 1);
        if (BRound) {
            BAddr = BAddr + PAGE_SIZE - BRound;
        }

        //
        // Round the ending address to a page boundry minus 1
        //

        ERound = (EAddr + 1) & (ULONG) (PAGE_SIZE - 1);
        if (ERound) {
            EAddr -= ERound;
        }

        //
        // Covert begining & ending address to page
        //

        PageStart = BAddr >> PAGE_SHIFT;
        PageEnd   = (EAddr + 1) >> PAGE_SHIFT;

        //
        // If this memory descriptor describes conventional ( <640k )
        // memory, then assume the ROM starts immediately after it
        // ends.
        //

        if (PageStart == 0) {
            RomStart = PageEnd;
        }

        //
        // If PageStart was rounded up to a page boundry, then add
        // the fractional page as SpecialMemory
        //

        if (BRound) {
            Status = MempSetDescriptorRegion (
                        PageStart - 1,
                        PageStart,
                        MemorySpecialMemory
                        );
            if (Status != ESUCCESS) {
                break;
            }
        }

        //
        // If PageEnd was rounded down to a page boundry, then add
        // the fractional page as SpecialMemory
        //

        if (ERound) {
            Status = MempSetDescriptorRegion (
                        PageEnd,
                        PageEnd + 1,
                        MemorySpecialMemory
                        );
            if (Status != ESUCCESS) {
                break;
            }

            //
            // RomStart starts after the reserved page
            //

            if (RomStart == PageEnd) {
                RomStart += 1;
            }
        }

        //
        // Add memory range PageStart though PageEnd
        //

        if (PageEnd <= _16MB_BOGUS) {

            //
            // This memory descriptor is all below the 16MB_BOGUS mark
            //

            Status = MempSetDescriptorRegion( PageStart, PageEnd, MemoryFree );

        } else if (PageStart >= _16MB) {

            //
            // Memory above 16MB is only used when absolutely necessary so it
            // is flagged as LoaderReserve
            //
            // --- 3/14/00 Allow it to be used. The diamond code
            // and the bios disk code manage read buffers to
            // keep reads below the 1Mb or 16MB lines
            //

            Status = MempSetDescriptorRegion( PageStart, PageEnd, LoaderReserve);

        } else {

            //
            // This memory descriptor describes memory within the
            // last 40h pages of the 16MB mark - otherwise known as
            // 16MB_BOGUS.
            //
            //

            if (PageStart < _16MB_BOGUS) {

                //
                // Clip starting address to 16MB_BOGUS mark, and add
                // memory below 16MB_BOGUS as useable memory.
                //

                Status = MempSetDescriptorRegion( PageStart, _16MB_BOGUS,
                                               MemoryFree );
                if (Status != ESUCCESS) {
                    break;
                }

                PageStart = _16MB_BOGUS;
            }

            //
            // Add remaining memory as LoaderReserve.
            //
            Status = MempSetDescriptorRegion( PageStart, PageEnd, LoaderReserve);

        }

        if (Status != ESUCCESS) {
            break;
        }

        //
        // Move to the next memory descriptor
        //

        ++SuMemory;
    }

    if (Status != ESUCCESS) {
        BlPrint("MempSetDescriptorRegion failed %lx\n",Status);
        return(Status);
    }

    //
    // Set the range 16MB_BOGUS - 16MB as unusable
    //

    Status = MempSetDescriptorRegion(_16MB_BOGUS, _16MB, MemorySpecialMemory);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // Hack for EISA machines that insist there is usable memory in the
    // ROM area, where we know darn well there isn't.
    //

    // Remove anything in this range..
    MempSetDescriptorRegion(ROM_START_PAGE, ROM_END_PAGE, LoaderMaximum);

    //
    // Describe the BIOS area
    //
    MempSetDescriptorRegion(RomStart, ROM_END_PAGE, MemoryFirmwarePermanent);

    //
    // If this is a remote boot, then everything between the "size of free
    // base memory" mark and the start of the ROM area needs to be marked
    // as firmware temporary.  This is the boot ROM's data/stack area.
    //
    if ( BootContext->FSContextPointer->BootDrive == 0x40 ) {
        ULONG SizeOfFreeBaseMemory = (ULONG)*(USHORT *)0x413 * 1024;
        ULONG FirstRomDataPage = SizeOfFreeBaseMemory >> PAGE_SHIFT;
        if ( FirstRomDataPage < RomStart ) {
            MempSetDescriptorRegion(FirstRomDataPage, RomStart, MemoryFirmwareTemporary);
        }
    }

    //
    // Now we have descriptors that map all of physical memory.  Carve
    // out descriptors from these that describe the parts that we are
    // currently using.
    //

    //
    // Create the descriptors which describe the low 1Mb of memory.
    //

    //
    // 00000 - 00fff  real-mode interrupt vectors
    //
    Status = MempAllocDescriptor(0, 1, MemoryFirmwarePermanent);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // 01000 - 1ffff  loadable miniport drivers, free memory.
    //
    Status = MempAllocDescriptor(1, 0x20, MemoryFree);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // 20000 - 2ffff  SU module, SU stack
    //
    Status = MempAllocDescriptor(0x20, PERMANENT_HEAP_START, MemoryFirmwareTemporary);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // 30000 - 30000  Firmware Permanent
    //  This starts out as zero-length.  It grows into the firmware temporary
    //  heap descriptor as we allocate permanent pages for the Page Directory
    //  and Page Tables
    //

    Status = MempAllocDescriptor(PERMANENT_HEAP_START,
                                  PERMANENT_HEAP_START,
                                  LoaderMemoryData);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // 30000 - 5ffff  Firmware temporary heap
    //

    Status = MempAllocDescriptor(PERMANENT_HEAP_START,
                                  TEMPORARY_HEAP_START,
                                  MemoryFirmwareTemporary);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // Stack we are currently running on.
    //
    Status = MempAllocDescriptor(TEMPORARY_HEAP_START,
                                 TEMPORARY_HEAP_START+2,
                                 MemoryFirmwareTemporary);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // Describe the osloader memory image
    //
    LoaderStart = BootContext->OsLoaderStart >> PAGE_SHIFT;
    LoaderEnd = (BootContext->OsLoaderEnd + PAGE_SIZE - 1) >> PAGE_SHIFT;
    Status = MempAllocDescriptor(LoaderStart,
                                 LoaderEnd,
                                 MemoryLoadedProgram);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // Describe the memory pool used to allocate memory for the SCSI
    // miniports.
    //
    Status = MempAllocDescriptor(LoaderEnd,
                                 LoaderEnd + FW_POOL_SIZE,
                                 MemoryFirmwareTemporary);
    if (Status != ESUCCESS) {
        return(Status);
    }
    FwPoolStart = LoaderEnd << PAGE_SHIFT;
    FwPoolEnd = FwPoolStart + (FW_POOL_SIZE << PAGE_SHIFT);

    //
    // HACKHACK - try to mark a page just below the osloader as firmwaretemp,
    // so it will not get used for heap/stack.  This is to force
    // our heap/stack to be < 1Mb.
    //
    MempAllocDescriptor((BootContext->OsLoaderStart >> PAGE_SHIFT)-1,
                        BootContext->OsLoaderStart >> PAGE_SHIFT,
                        MemoryFirmwareTemporary);


    Status = MempTurnOnPaging();

    if (Status != ESUCCESS) {
        return(Status);
    }

    Status = MempCopyGdt();

    //
    // Find any reserved ranges described by the firmware and
    // record these
    //

    return(Status);
}

VOID
InitializeMemoryDescriptors (
    VOID
    )
/*++

Routine Description:

    Pass 2 of InitializeMemorySubsystem.  This function reads the
    firmware address space map and reserves ranges the firmware declares
    as "address space reserved".

    Note: free memory range descriptors has already been reported by su.

Arguments:

    none

Returns:

    none

--*/
{
    ULONGLONG       BAddr, EAddr, Length;
    ULONG           BPage, EPage;
    E820FRAME       Frame;

#ifdef LOADER_DEBUG
    BlPrint("Begin InitializeMemoryDescriptors\n") ;
#endif

    Frame.Key = 0;
    do {
        Frame.Size = sizeof (Frame.Descriptor);
        GET_MEMORY_DESCRIPTOR (&Frame);
        if (Frame.ErrorFlag  ||  Frame.Size < sizeof (Frame.Descriptor)) {
            break;
        }

#ifdef LOADER_DEBUG
        BlPrint("*E820: %lx  %lx:%lx %lx:%lx %lx %lx\n",
            Frame.Size,
            Frame.Descriptor.BaseAddrHigh,  Frame.Descriptor.BaseAddrLow,
            Frame.Descriptor.SizeHigh,      Frame.Descriptor.SizeLow,
            Frame.Descriptor.MemoryType,
            Frame.Key
            );
#endif

        BAddr = Frame.Descriptor.BaseAddrHigh;
        BAddr = (BAddr << 32) + Frame.Descriptor.BaseAddrLow;

        Length = Frame.Descriptor.SizeHigh;
        Length = (Length << 32) + Frame.Descriptor.SizeLow;

        EAddr = BAddr + Length - 1;

        //
        // The memory range is described as the region from BAddr to EAddr
        // inclusive.
        //

        //
        // Some processors support physical addressing above 32 bits.
        //

        //
        // Based upon the address range descriptor type, find the
        // available memory and add it to the descriptor list
        //

        switch (Frame.Descriptor.MemoryType) {
            case 1:
                //
                // This is a memory descriptor - it's already been handled
                // by su (eisac.c)
                //
                // However, any memory within 16MB_BOGUS - 16MB was
                // considered unuseable.  Reclaim memory within this
                // region which is described via this interface.
                //
                // Also, any memory above 4G was considered unusable.
                // Reclaim memory within this range as well.
                //

                BPage = (ULONG)((BAddr + PAGE_SIZE - 1) >> PAGE_SHIFT);
                EPage = (ULONG)((EAddr >> PAGE_SHIFT) + 1);

                //
                // Clip to bogus range
                //

                if (BPage < _16MB_BOGUS  &&  EPage >= _16MB_BOGUS) {

                    BPage = _16MB_BOGUS;

                }

                //
                // SGP - The code in InitializeMemorySubsystem reserves
                // from 16MB_BOGUS to 16MB as MemorySpecialMemory. This
                // piece set the endpage to 16MB - 1, which isn't consistent
                //
                //
                if (EPage > _16MB && BPage <= _16MB) {

                    EPage = _16MB;

                }

                if (BPage >= _16MB_BOGUS  &&  EPage <= _16MB) {
                    //
                    // Reclaim memory within the bogus range
                    // by setting it to FirmwareTemporary
                    //

                    MempSetDescriptorRegion (
                        BPage,
                        EPage,
                        MemoryFirmwareTemporary
                        );
                }

                //
                // Now reclaim any portion of this range that lies above
                // the 4G line.
                //

                BPage = (ULONG)((BAddr + PAGE_SIZE - 1) >> PAGE_SHIFT);
                EPage = (ULONG)((EAddr >> PAGE_SHIFT) + 1);

                if (EPage >= _4G) {

                    //
                    // At least part of this region is above 4G.  Truncate
                    // any portion that falls below 4G, and reclaim
                    // the memory.
                    //

                    if (BPage < _4G) {
                        BPage = _4G;
                    }

                    MempSetDescriptorRegion (
                        BPage,
                        EPage,
                        MemoryFirmwareTemporary
                        );
                }

                break;

            default:    // unkown types are treated as Reserved
            case 2:

                //
                // This memory descriptor is a reserved address range
                //

                BPage = (ULONG)(BAddr >> PAGE_SHIFT);
                EPage = (ULONG)((EAddr + 1 + PAGE_SIZE - 1) >> PAGE_SHIFT);

                MempSetDescriptorRegion (
                    BPage,
                    EPage,
                    MemorySpecialMemory
                    );

                break;
        }

    } while (Frame.Key) ;


    //
    // Disable pages from KSEG0 which are disabled
    //

    MempDisablePages();

#ifdef LOADER_DEBUG
    BlPrint("Complete InitializeMemoryDescriptors\n") ;
#endif

    return;
}



ARC_STATUS
MempCopyGdt(
    VOID
    )

/*++

Routine Description:

    Copies the GDT & IDT into pages allocated out of our permanent heap.

Arguments:

    None

Return Value:

    ESUCCESS - GDT & IDT copy successful

--*/

{
    #pragma pack(2)
    static struct {
        USHORT Limit;
        ULONG Base;
    } GdtDef, IdtDef;
    #pragma pack(4)

    ULONG BlockSize;
    PKGDTENTRY NewGdt;
    PKIDTENTRY NewIdt;
    ULONG NumPages;

    //
    // Get the current location of the GDT & IDT
    //
    _asm {
        sgdt GdtDef;
        sidt IdtDef;
    }

    if (GdtDef.Base + GdtDef.Limit + 1 != IdtDef.Base) {

        //
        // Just a sanity check to make sure that the IDT immediately
        // follows the GDT.  (As set up in SUDATA.ASM)
        //

        BlPrint("ERROR - GDT and IDT are not contiguous!\n");
        BlPrint("GDT - %lx (%x)  IDT - %lx (%x)\n",
            GdtDef.Base, GdtDef.Limit,
            IdtDef.Base, IdtDef.Limit);
        while (1);
    }

    BlockSize = GdtDef.Limit+1 + IdtDef.Limit+1;

    NumPages = (BlockSize + PAGE_SIZE-1) >> PAGE_SHIFT;

    NewGdt = (PKGDTENTRY)FwAllocateHeapPermanent(NumPages);

    if (NewGdt == NULL) {
        return(ENOMEM);
    }

    RtlMoveMemory((PVOID)NewGdt, (PVOID)GdtDef.Base, NumPages << PAGE_SHIFT);

    GdtDef.Base = (ULONG)NewGdt;
    IdtDef.Base = (ULONG)((PUCHAR)NewGdt + GdtDef.Limit + 1);

    //
    // Initialize the boot debugger IDT entries.
    //

    NewIdt = (PKIDTENTRY)IdtDef.Base;
    NewIdt[1].Offset = (USHORT)((ULONG)BdTrap01 & 0xffff);
    NewIdt[1].Selector = 8;
    NewIdt[1].Access = 0x8e00;
    NewIdt[1].ExtendedOffset = (USHORT)((ULONG)BdTrap01 >> 16);

    NewIdt[3].Offset = (USHORT)((ULONG)BdTrap03 & 0xffff);
    NewIdt[3].Selector = 8;
    NewIdt[3].Access = 0x8e00;
    NewIdt[3].ExtendedOffset = (USHORT)((ULONG)BdTrap03 >> 16);

    NewIdt[0xd].Offset = (USHORT)((ULONG)BdTrap0d & 0xffff);
    NewIdt[0xd].Selector = 8;
    NewIdt[0xd].Access = 0x8e00;
    NewIdt[0xd].ExtendedOffset = (USHORT)((ULONG)BdTrap0d >> 16);

    NewIdt[0xe].Offset = (USHORT)((ULONG)BdTrap0e & 0xffff);
    NewIdt[0xe].Selector = 8;
    NewIdt[0xe].Access = 0x8e00;
    NewIdt[0xe].ExtendedOffset = (USHORT)((ULONG)BdTrap0e >> 16);

    NewIdt[0x2d].Offset = (USHORT)((ULONG)BdTrap2d & 0xffff);
    NewIdt[0x2d].Selector = 8;
    NewIdt[0x2d].Access = 0x8e00;
    NewIdt[0x2d].ExtendedOffset = (USHORT)((ULONG)BdTrap2d >> 16);

    //
    // Load GDT and IDT registers.
    //

    _asm {
        lgdt GdtDef;
        lidt IdtDef;
    }

    //
    // Initialize the boot debugger.
    //

#if defined(ENABLE_LOADER_DEBUG)
    BdInitDebugger((PCHAR)OsLoaderName, (PVOID)OsLoaderBase, ENABLE_LOADER_DEBUG);
#else
    BdInitDebugger((PCHAR)OsLoaderName, (PVOID)OsLoaderBase, NULL);    
#endif

    return ESUCCESS;
}

ARC_STATUS
MempSetDescriptorRegion (
    IN ULONG StartPage,
    IN ULONG EndPage,
    IN TYPE_OF_MEMORY MemoryType
    )
/*++

Routine Description:

    This function sets a range to the corrisponding memory type.
    Descriptors will be removed, modified, inserted as needed to
    set the specified range.

Arguments:

    StartPage  - Supplies the beginning page of the new memory descriptor

    EndPage    - Supplies the ending page of the new memory descriptor

    MemoryType - Supplies the type of memory of the new memory descriptor

Return Value:

    ESUCCESS - Memory descriptor succesfully added to MDL array

    ENOMEM   - MDArray is full.

--*/
{
    ULONG           i;
    ULONG           sp, ep;
    TYPE_OF_MEMORY  mt;
    BOOLEAN         RegionAdded;

    if (EndPage <= StartPage) {
        //
        // This is a completely bogus memory descriptor. Ignore it.
        //

#ifdef LOADER_DEBUG
        BlPrint("Attempt to create invalid memory descriptor %lx - %lx\n",
                StartPage,EndPage);
#endif
        return(ESUCCESS);
    }

    RegionAdded = FALSE;

    //
    // Clip, remove, any descriptors in target area
    //

    for (i=0; i < NumberDescriptors; i++) {
        sp = MDArray[i].BasePage;
        ep = MDArray[i].BasePage + MDArray[i].PageCount;
        mt = MDArray[i].MemoryType;

        if (sp < StartPage) {
            if (ep > StartPage  &&  ep <= EndPage) {
                // truncate this descriptor
                ep = StartPage;
            }

            if (ep > EndPage) {
                //
                // Target area is contained totally within this
                // descriptor.  Split the descriptor into two ranges
                //

                if (NumberDescriptors == MAX_DESCRIPTORS) {
                    return(ENOMEM);
                }

                //
                // Add descriptor for EndPage - ep
                //

                MDArray[NumberDescriptors].MemoryType = mt;
                MDArray[NumberDescriptors].BasePage   = EndPage;
                MDArray[NumberDescriptors].PageCount  = ep - EndPage;
                NumberDescriptors += 1;

                //
                // Adjust current descriptor for sp - StartPage
                //

                ep = StartPage;
            }

        } else {
            // sp >= StartPage

            if (sp < EndPage) {
                if (ep < EndPage) {
                    //
                    // This descriptor is totally within the target area -
                    // remove it
                    //

                    ep = sp;

                }  else {
                    // bump begining page of this descriptor
                    sp = EndPage;
                }
            }
        }

        //
        // Check if the new range can be appended or prepended to
        // this descriptor
        //
        if (mt == MemoryType && !RegionAdded) {
            if (sp == EndPage) {
                // prepend region being set
                sp = StartPage;
                RegionAdded = TRUE;

            } else if (ep == StartPage) {
                // append region being set
                ep = EndPage;
                RegionAdded = TRUE;

            }
        }

        if (MDArray[i].BasePage == sp  &&  MDArray[i].PageCount == ep-sp) {

            //
            // Descriptor was not editted
            //

            continue;
        }

        //
        // Reset this descriptor
        //

        MDArray[i].BasePage  = sp;
        MDArray[i].PageCount = ep - sp;

        if (ep == sp) {

            //
            // Descriptor vanished - remove it
            //

            NumberDescriptors -= 1;
            if (i < NumberDescriptors) {
                MDArray[i] = MDArray[NumberDescriptors];
            }

            i--;        // backup & recheck current position
        }
    }

    //
    // If region wasn't already added to a neighboring region, then
    // create a new descriptor now
    //

    if (!RegionAdded  &&  MemoryType < LoaderMaximum) {
        if (NumberDescriptors == MAX_DESCRIPTORS) {
            return(ENOMEM);
        }

#ifdef LOADER_DEBUG
        BlPrint("Adding '%lx - %lx, type %x' to descriptor list\n",
                StartPage << PAGE_SHIFT,
                EndPage << PAGE_SHIFT,
                (USHORT) MemoryType
                );
#endif

        MDArray[NumberDescriptors].MemoryType = MemoryType;
        MDArray[NumberDescriptors].BasePage   = StartPage;
        MDArray[NumberDescriptors].PageCount  = EndPage - StartPage;
        NumberDescriptors += 1;
    }
    return (ESUCCESS);
}

ARC_STATUS
MempAllocDescriptor(
    IN ULONG StartPage,
    IN ULONG EndPage,
    IN TYPE_OF_MEMORY MemoryType
    )

/*++

Routine Description:

    This routine carves out a specific memory descriptor from the
    memory descriptors that have already been created.  The MD array
    is updated to reflect the new state of memory.

    The new memory descriptor must be completely contained within an
    already existing memory descriptor.  (i.e.  memory that does not
    exist should never be marked as a certain type)

Arguments:

    StartPage  - Supplies the beginning page of the new memory descriptor

    EndPage    - Supplies the ending page of the new memory descriptor

    MemoryType - Supplies the type of memory of the new memory descriptor

Return Value:

    ESUCCESS - Memory descriptor succesfully added to MDL array

    ENOMEM   - MDArray is full.

--*/
{
    ULONG i;

    //
    // Walk through the memory descriptors until we find one that
    // contains the start of the descriptor.
    //
    for (i=0; i<NumberDescriptors; i++) {
        if ((MDArray[i].MemoryType == MemoryFree) &&
            (MDArray[i].BasePage <= StartPage )     &&
            (MDArray[i].BasePage+MDArray[i].PageCount >  StartPage) &&
            (MDArray[i].BasePage+MDArray[i].PageCount >= EndPage)) {

            break;
        }
    }

    if (i==NumberDescriptors) {
        return(ENOMEM);
    }

    if (MDArray[i].BasePage == StartPage) {

        if (MDArray[i].BasePage+MDArray[i].PageCount == EndPage) {

            //
            // The new descriptor is identical to the existing descriptor.
            // Simply change the memory type of the existing descriptor in
            // place.
            //

            MDArray[i].MemoryType = MemoryType;
        } else {

            //
            // The new descriptor starts on the same page, but is smaller
            // than the existing descriptor.  Shrink the existing descriptor
            // by moving its start page up, and create a new descriptor.
            //
            if (NumberDescriptors == MAX_DESCRIPTORS) {
                return(ENOMEM);
            }
            MDArray[i].BasePage = EndPage;
            MDArray[i].PageCount -= (EndPage-StartPage);

            MDArray[NumberDescriptors].BasePage = StartPage;
            MDArray[NumberDescriptors].PageCount = EndPage-StartPage;
            MDArray[NumberDescriptors].MemoryType = MemoryType;
            ++NumberDescriptors;

        }
    } else if (MDArray[i].BasePage+MDArray[i].PageCount == EndPage) {

        //
        // The new descriptor ends on the same page.  Shrink the existing
        // by decreasing its page count, and create a new descriptor.
        //
        if (NumberDescriptors == MAX_DESCRIPTORS) {
            return(ENOMEM);
        }
        MDArray[i].PageCount = StartPage - MDArray[i].BasePage;

        MDArray[NumberDescriptors].BasePage = StartPage;
        MDArray[NumberDescriptors].PageCount = EndPage-StartPage;
        MDArray[NumberDescriptors].MemoryType = MemoryType;
        ++NumberDescriptors;
    } else {

        //
        // The new descriptor is in the middle of the existing descriptor.
        // Shrink the existing descriptor by decreasing its page count, and
        // create two new descriptors.
        //

        if (NumberDescriptors+1 >= MAX_DESCRIPTORS) {
            return(ENOMEM);
        }

        MDArray[NumberDescriptors].BasePage = EndPage;
        MDArray[NumberDescriptors].PageCount = MDArray[i].PageCount -
                (EndPage-MDArray[i].BasePage);
        MDArray[NumberDescriptors].MemoryType = MemoryFree;
        ++NumberDescriptors;

        MDArray[i].PageCount = StartPage - MDArray[i].BasePage;

        MDArray[NumberDescriptors].BasePage = StartPage;
        MDArray[NumberDescriptors].PageCount = EndPage-StartPage;
        MDArray[NumberDescriptors].MemoryType = MemoryType;
        ++NumberDescriptors;
    }

    BlpTrackUsage (MemoryType,StartPage,EndPage-StartPage);

    return(ESUCCESS);
}

ARC_STATUS
MempTurnOnPaging(
    VOID
    )

/*++

Routine Description:

    Sets up the page tables necessary to map the first 16mb of memory and
    enables paging.

Arguments:

    None.

Return Value:

    ESUCCESS - Paging successfully turned on

--*/

{

    ULONG i;
    ARC_STATUS Status;

    //
    // Allocate, initialize, and map the PDE page onto itself (i.e., virtual
    // address PDE_BASE).
    //

    PDE = FwAllocateHeapPermanent(1);
    if (PDE == NULL) {
        return ENOMEM;
    }

    RtlZeroMemory(PDE, PAGE_SIZE);
    PDE[PDE_BASE >> 22].Valid = 1;
    PDE[PDE_BASE >> 22].Write = 1;
    PDE[PDE_BASE >> 22].PageFrameNumber = (ULONG)PDE >> PAGE_SHIFT;

    //
    // Allocate, initialize, and map the HAL page into the last PDE (i.e.,
    // virtual address range 0xffc00000 - 0xffffffff).
    //

    HalPT = FwAllocateHeapPermanent(1);
    if (HalPT == NULL) {
        return ENOMEM;
    }

    RtlZeroMemory(HalPT, PAGE_SIZE);
    PDE[1023].Valid = 1;
    PDE[1023].Write = 1;
    PDE[1023].PageFrameNumber = (ULONG)HalPT >> PAGE_SHIFT;

    //
    // Scan the memory descriptor list and setup paging for each descriptor.
    //

    for (i = 0; i < NumberDescriptors; i++) {

        if (MDArray[i].BasePage < _16MB) {

            Status = MempSetupPaging(MDArray[i].BasePage,
                                     MDArray[i].PageCount);

            if (Status != ESUCCESS) {
                BlPrint("ERROR - MempSetupPaging(%lx, %lx) failed\n",
                        MDArray[i].BasePage,
                        MDArray[i].PageCount);

                return Status;
            }
        }
    }

    //
    // Turn on paging.
    //

    _asm {

        //
        // Load physical address of page directory
        //

        mov eax,PDE
        mov cr3,eax

        //
        // Enable paging mode
        //

        mov eax,cr0
        or  eax,CR0_PG
        mov cr0,eax
    }

    return ESUCCESS;
}

ARC_STATUS
MempSetupPaging(
    IN ULONG StartPage,
    IN ULONG NumberPages
    )

/*++

Routine Description:

    Allocates and initializes the page table pages required to identity map
    the specified region of memory at its physical address, at KSEG0_BASE, OLD_ALTERNATE
    and at ALTERNATE_BASE.

Arguments:

    StartPage - Supplies the first page to start mapping.

    NumberPage - Supplies the number of pages to map.

Return Value:

    ESUCCESS    - Paging successfully set up

--*/

{

    ULONG EndPage;
    ULONG Entry;
    ULONG FrameNumber;
    ULONG Page;
    PHARDWARE_PTE PageTableP;
    PHARDWARE_PTE PageTableV;
    ULONG Offset;

    //
    // The page table pages that are used to map memory at physical equal
    // real addresses are allocated from firmware temporary memory which
    // gets released when memory management initializes.
    //
    // N.B. Physical memory is mapped at its physical address, KSEG0_BASE,
    //      and at ALTERNATE_BASE. This allows the system to be configured
    //      by the OS Loader to be either a 2gb or 3gb user space system
    //      based on an OS Loader option.
    //

    EndPage = StartPage + NumberPages;
    for (Page = StartPage; Page < EndPage; Page += 1) {
        Entry = Page >> 10;

        //
        // If the PDE entry for this page address range is not allocated,
        // then allocate and initialize the PDE entry to map the page table
        // pages for the the memory range. Otherwise, compute the address
        // of the page table pages.
        //
        if (PDE[Entry].Valid == 0) {

            //
            // Allocate and initialize a page table page to map the specified
            // page into physical memory.
            //

            PageTableP = (PHARDWARE_PTE)FwAllocateHeapAligned(PAGE_SIZE);
            if (PageTableP == NULL) {
                return ENOMEM;
            }

            RtlZeroMemory(PageTableP, PAGE_SIZE);
            FrameNumber = (ULONG)PageTableP >> PAGE_SHIFT;
            PDE[Entry].Valid = 1;
            PDE[Entry].Write = 1;
            PDE[Entry].PageFrameNumber = FrameNumber;

            //
            // Allocate and initialize a page table page to map the specified
            // page into KSEG0_BASE and ALTERNATE_BASE.
            //
            // N.B. Only one page table page is allocated since the contents
            //      for both mappings are the same.
            //

            PageTableV = (PHARDWARE_PTE)FwAllocateHeapPermanent(1);
            if (PageTableV == NULL) {
                return ENOMEM;
            }

            RtlZeroMemory(PageTableV, PAGE_SIZE);
            FrameNumber = (ULONG)PageTableV >> PAGE_SHIFT;
            Offset = Entry + (KSEG0_BASE >> 22);
            PDE[Offset].Valid = 1;
            PDE[Offset].Write = 1;
            PDE[Offset].PageFrameNumber = FrameNumber;

            Offset = Entry + (ALTERNATE_BASE >> 22);
            PDE[Offset].Valid = 1;
            PDE[Offset].Write = 1;
            PDE[Offset].PageFrameNumber = FrameNumber;

            if (Entry > HighestPde) {
                HighestPde = Entry;
            }

        } else {
            Offset = Entry + (KSEG0_BASE >> 22);
            PageTableP = (PHARDWARE_PTE)(PDE[Entry].PageFrameNumber << PAGE_SHIFT);
            PageTableV = (PHARDWARE_PTE)(PDE[Offset].PageFrameNumber << PAGE_SHIFT);
        }

        //
        // If this is not the first page in memory, then mark it valid.
        //

        if (Page != 0) {
            Offset = Page & 0x3ff;
            PageTableP[Offset].Valid = 1;
            PageTableP[Offset].Write = 1;
            PageTableP[Offset].PageFrameNumber = Page;

            PageTableV[Offset].Valid = 1;
            PageTableV[Offset].Write = 1;
            PageTableV[Offset].PageFrameNumber = Page;
        }
    }

    return ESUCCESS;
}

VOID
MempDisablePages(
    VOID
    )

/*++

Routine Description:

    Frees as many Page Tables as are required from the KSEG0_BASE, OLD_ALTERNATE
    and ALTERNATE_BASE regions.

Arguments:

    None.

Return Value:

    none

--*/

{

    ULONG EndPage;
    ULONG Entry;
    ULONG i;
    ULONG Offset;
    ULONG Page;
    PHARDWARE_PTE PageTable;

    //
    // Cleanup the KSEG0_BASE and ALTERNATE_BASE regions. The MM PFN database
    // is an array of entries which track each page of main memory.  Large
    // enough memory holes will cause this array to be sparse. MM requires
    // enabled PTEs to have entries in the PFN database. So locate any memory
    // hole and remove their PTEs.
    //

    for (i = 0; i < NumberDescriptors; i += 1) {
        if (MDArray[i].MemoryType == MemorySpecialMemory ||
            MDArray[i].MemoryType == MemoryFirmwarePermanent) {

            //
            // The KSEG0_BASE and ALTERNATE_BASE regions only map up to 16MB,
            // so clip the high end at that address.
            //

            Page = MDArray[i].BasePage;
            EndPage = Page + MDArray[i].PageCount;
            if (EndPage > _16MB) {
                EndPage = _16MB;
            }

            //
            // Some PTEs below 1M may need to stay mapped since they may have
            // been put into ABIOS selectors.  Instead of determining which PTEs
            // they may be, we will leave PTEs below 1M alone.  This doesn't
            // cause the PFN any problems since we know there is some memory
            // below then 680K mark and some more memory at the 1M mark.  Thus
            // there is not a large enough "memory hole" to cause the PFN database
            // to be sparse below 1M.
            //
            // Clip starting address to 1MB
            //

            if (Page < _1MB) {
                Page = _1MB;
            }

            //
            // For each page in this range make sure it is invalid in the
            // KSEG0_BASE and ALTERNATE_BASE regions.
            //
            // N.B. Since there is only one page table page for both the
            //      KSEG0_BASE and ALTERNATE_BASE regions the page only
            //      needs to marked invalid once.
            //

            while (Page < EndPage) {
                Entry = (Page >> 10) + (KSEG0_BASE >> 22);
                if (PDE[Entry].Valid == 1) {
                    PageTable = (PHARDWARE_PTE)(PDE[Entry].PageFrameNumber << PAGE_SHIFT);
                    Offset = Page & 0x3ff;
                    PageTable[Offset].Valid = 0;
                    PageTable[Offset].Write = 0;
                    PageTable[Offset].PageFrameNumber = 0;
                }

                Page += 1;
            }
        }
    }
}

PVOID
FwAllocateHeapPermanent(
    IN ULONG NumberPages
    )

/*++

Routine Description:

    This allocates pages from the private heap.  The memory descriptor for
    the LoaderMemoryData area is grown to include the returned pages, while
    the memory descriptor for the temporary heap is shrunk by the same amount.

    N.B.    DO NOT call this routine after we have passed control to
            BlOsLoader!  Once BlOsLoader calls BlMemoryInitialize, the
            firmware memory descriptors are sucked into the OS Loader heap
            and those are the descriptors passed to the kernel.  So any
            changes in the firmware private heap will be irrelevant.

            If you need to allocate permanent memory after the OS Loader
            has initialized, use BlAllocateDescriptor.

Arguments:

    NumberPages - size of memory to allocate (in pages)

Return Value:

    Pointer to block of memory, if successful.
    NULL, if unsuccessful.

--*/

{

    PVOID MemoryPointer;
    PMEMORY_DESCRIPTOR Descriptor;

    if (FwPermanentHeap + (NumberPages << PAGE_SHIFT) > FwTemporaryHeap) {

        //
        // Our heaps collide, so we are out of memory
        //

        BlPrint("Out of permanent heap!\n");
        while (1) {
        }

        return(NULL);
    }

    //
    // Find the memory descriptor which describes the LoaderMemoryData area,
    // so we can grow it to include the just-allocated pages.
    //
    Descriptor = MDArray;
    while (Descriptor->MemoryType != LoaderMemoryData) {
        ++Descriptor;
        if (Descriptor > MDArray+MAX_DESCRIPTORS) {
            BlPrint("ERROR - FwAllocateHeapPermanent couldn't find the\n");
            BlPrint("        LoaderMemoryData descriptor!\n");
            while (1) {
            }
            return(NULL);
        }
    }
    Descriptor->PageCount += NumberPages;

    //
    // We know that the memory descriptor after this one is the firmware
    // temporary heap descriptor.  Since it is physically contiguous with our
    // LoaderMemoryData block, we remove the pages from its descriptor.
    //

    ++Descriptor;
    Descriptor->PageCount -= NumberPages;
    Descriptor->BasePage  += NumberPages;

    MemoryPointer = (PVOID)FwPermanentHeap;
    FwPermanentHeap += NumberPages << PAGE_SHIFT;

    return(MemoryPointer);
}


PVOID
FwAllocateHeap(
    IN ULONG Size
    )

/*++

Routine Description:

    Allocates memory from the "firmware" temporary heap.

Arguments:

    Size - Supplies size of block to allocate

Return Value:

    PVOID - Pointer to the beginning of the block
    NULL  - Out of memory

--*/

{
    ULONG i;
    ULONG SizeInPages;
    ULONG StartPage;
    ARC_STATUS Status;

    if (((FwTemporaryHeap - FwPermanentHeap) < Size) && (FwDescriptorsValid)) {
        //
        // Large allocations get their own descriptor so miniports that
        // have huge device extensions don't suck up all of the heap.
        //
        // Note that we can only do this while running in "firmware" mode.
        // Once we call into the osloader, it sucks all the memory descriptors
        // out of the "firmware" and changes to this list will not show
        // up there.
        //
        // We are looking for a descriptor that is MemoryFree and <16Mb.
        //
        // [ChuckL 13-Dec-2001]
        // This routine has always been called after the loader's memory list
        // was initialized, which meant that it was stomping on memory that
        // might have been allocated by the loader. This was not a problem
        // because the loader initialized its memory list twice(!), so it
        // looked at the MDArray again to get an updated picture of the
        // memory allocation situation. This didn't really work, and there
        // used to be extra code here to handle the situation by calling
        // BlFindDescriptor/BlGeneratorDescriptor to tell the loader about
        // the low-level allocation. But even that didn't really work. And
        // now, because of the elimination of the second call to
        // BlMemoryInitialize(), the brokenness of the old code has been
        // exposed. What happened is that this routine would use the MDArray
        // to decide where to allocate memory, then it would tell the loader
        // about it. But using MDArray to find free memory was bogus,
        // because the loader had already used its own copy of the list to
        // make its own allocations. So the same memory was allocated twice.
        // The fix implemented here is to use BlAllocateAlignedDescriptor if
        // the loader has been initialized, skipping the MDArray entirely.
        //

        SizeInPages = (Size+PAGE_SIZE-1) >> PAGE_SHIFT;

        if (BlLoaderBlock != NULL) {

            Status = BlAllocateAlignedDescriptor(
                        LoaderFirmwareTemporary,
                        0,
                        SizeInPages,
                        1,
                        &StartPage
                        );
            if (Status == ESUCCESS) {
                return((PVOID)(StartPage << PAGE_SHIFT));
            }

        } else {

            for (i=0; i<NumberDescriptors; i++) {
                if ((MDArray[i].MemoryType == MemoryFree) &&
                    (MDArray[i].BasePage <= _16MB_BOGUS) &&
                    (MDArray[i].PageCount >= SizeInPages)) {
                    break;
                }
            }

            if (i < NumberDescriptors) {
                StartPage = MDArray[i].BasePage+MDArray[i].PageCount-SizeInPages;
                Status = MempAllocDescriptor(StartPage,
                                             StartPage+SizeInPages,
                                             MemoryFirmwareTemporary);
                if (Status==ESUCCESS) {
                    return((PVOID)(StartPage << PAGE_SHIFT));
                }
            }
        }
    }

    FwTemporaryHeap -= Size;

    //
    // Round down to 16-byte boundary
    //

    FwTemporaryHeap &= ~((ULONG)0xf);

    if (FwTemporaryHeap < FwPermanentHeap) {
#if DBG
        BlPrint("Out of temporary heap!\n");
#endif
        return(NULL);
    }

    return((PVOID)FwTemporaryHeap);

}


PVOID
FwAllocatePool(
    IN ULONG Size
    )

/*++

Routine Description:

    This routine allocates memory from the firmware pool.  Note that
    this memory is NOT under the 1MB line, so it cannot be used for
    anything that must be accessed from real mode.  It is currently used
    only by the SCSI miniport drivers and dbcs font loader.

Arguments:

    Size - Supplies size of block to allocate.

Return Value:

    PVOID - pointer to the beginning of the block
    NULL - out of memory

--*/

{
    PVOID Buffer;
    ULONG NewSize;

    //
    // round size up to 16 byte boundary
    //
    NewSize = (Size + 15) & ~0xf;
    if ((FwPoolStart + NewSize) <= FwPoolEnd) {

        Buffer = (PVOID)FwPoolStart;
        FwPoolStart += NewSize;
        return(Buffer);

    } else {
        //
        // we've used up all our pool, try to allocate from the heap.
        //
        return(FwAllocateHeap(Size));
    }


}


PVOID
FwAllocateHeapAligned(
    IN ULONG Size
    )

/*++

Routine Description:

    Allocates memory from the "firmware" temporary heap.  This memory is
    always allocated on a page boundary, so it can readily be used for
    temporary page tables

Arguments:

    Size - Supplies size of block to allocate

Return Value:

    PVOID - Pointer to the beginning of the block
    NULL  - Out of memory

--*/

{

    FwTemporaryHeap -= Size;

    //
    // Round down to a page boundary
    //

    FwTemporaryHeap &= ~(PAGE_SIZE-1);

    if (FwTemporaryHeap < FwPermanentHeap) {
        BlPrint("Out of temporary heap!\n");
        return(NULL);
    }
    RtlZeroMemory((PVOID)FwTemporaryHeap,Size);

    return((PVOID)FwTemporaryHeap);

}


PVOID
MmMapIoSpace (
     IN PHYSICAL_ADDRESS PhysicalAddress,
     IN ULONG NumberOfBytes,
     IN MEMORY_CACHING_TYPE CacheType
     )

/*++

Routine Description:

    This function returns the corresponding virtual address for a
    known physical address.

Arguments:

    PhysicalAddress - Supplies the physical address.

    NumberOfBytes - Unused.

    CacheType - Unused.

Return Value:

    Returns the corresponding virtual address.

Environment:

    Kernel mode.  Any IRQL level.

--*/

{
    ULONG i;
    ULONG j;
    ULONG NumberPages;

    NumberPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(PhysicalAddress.LowPart, NumberOfBytes);

    //
    // We use the HAL's PDE for mapping memory buffers.
    // Find enough free PTEs.
    //

    //
    // Check the value of NumberPages
    //
#define X86_MAX_NUMBER_OF_PAGES     1024
    //
    // since NumberPages is ULONG any arithmetic with NumberPages will
    // result in a ULONG (unless casted)
    // therefore if NumberPages is greated than X86_MAX_NUMBER_OF_PAGES
    // the results of X86_MAX_NUMBER_OF_PAGES-NUmberPages
    // will not be negative (its a ULONG!) therfore the following loop would
    // have returned some bogus pointer...
    //
    // The following 3 line check was added to avoid this problem
    //
    if (NumberPages > X86_MAX_NUMBER_OF_PAGES) {
        return (NULL);
    }

    for (i=0; i <= X86_MAX_NUMBER_OF_PAGES - NumberPages; i++) {
        for (j=0; j < NumberPages; j++) {
            if ((((PULONG)HalPT))[i+j]) {
                break;
            }
        }

        if (j == NumberPages) {
            for (j=0; j<NumberPages; j++) {
                HalPT[i+j].PageFrameNumber =
                                (PhysicalAddress.LowPart >> PAGE_SHIFT)+j;
                HalPT[i+j].Valid = 1;
                HalPT[i+j].Write = 1;
                HalPT[i+j].WriteThrough = 1;
                if (CacheType == MmNonCached) {
                    HalPT[i+j].CacheDisable = 1;
                }
            }

            return((PVOID)(0xffc00000 | (i<<12) | (PhysicalAddress.LowPart & 0xfff)));
        }
        //
        // page 'i + j' is used.  walk past it
        //
        i += j;

    }
    return(NULL);
}


VOID
MmUnmapIoSpace (
     IN PVOID BaseAddress,
     IN ULONG NumberOfBytes
     )

/*++

Routine Description:

    This function unmaps a range of physical address which were previously
    mapped via an MmMapIoSpace function call.

Arguments:

    BaseAddress - Supplies the base virtual address where the physical
                  address was previously mapped.

    NumberOfBytes - Supplies the number of bytes which were mapped.

Return Value:

    None.

Environment:

    Kernel mode, IRQL of DISPATCH_LEVEL or below.

--*/

{
    ULONG StartPage, PageCount;

    PageCount = COMPUTE_PAGES_SPANNED(BaseAddress, NumberOfBytes);
    StartPage = (((ULONG_PTR)BaseAddress & ~0xffc00000) >> PAGE_SHIFT);
    if (BaseAddress > (PVOID)0xffc00000) {
        RtlZeroMemory(&HalPT[StartPage], PageCount * sizeof(HARDWARE_PTE_X86));
    }

    _asm {
        mov     eax, cr3
        mov     cr3, eax
    }
    return;
}


VOID
BlpTruncateMemory (
    IN ULONG MaxMemory
    )

/*++

Routine Description:

    Eliminates all the memory descriptors above a given boundary

Arguments:

    MaxMemory - Supplies the maximum memory boundary in megabytes

Return Value:

    None.

--*/

{
    extern MEMORY_DESCRIPTOR MDArray[];
    extern ULONG NumberDescriptors;
    ULONG Current = 0;
    ULONG MaxPage = MaxMemory * 256;        // Convert Mb to pages

    if (MaxMemory == 0) {
        return;
    }

    while (Current < NumberDescriptors) {
        if (MDArray[Current].BasePage >= MaxPage) {
            //
            // This memory descriptor lies entirely above the boundary,
            // eliminate it.
            //
            RtlMoveMemory(MDArray+Current,
                          MDArray+Current+1,
                          sizeof(MEMORY_DESCRIPTOR)*
                          (NumberDescriptors-Current-1));
            --NumberDescriptors;
        } else if (MDArray[Current].BasePage + MDArray[Current].PageCount > MaxPage) {
            //
            // This memory descriptor crosses the boundary, truncate it.
            //
            MDArray[Current].PageCount = MaxPage - MDArray[Current].BasePage;
            ++Current;
        } else {
            //
            // This one's ok, keep it.
            //
            ++Current;
        }
    }
}



ARC_STATUS
MempCheckMapping(
    ULONG StartPage,
    ULONG NumberPages
    )
/*++

Routine Description:

    This routine makes sure all pages in the range are mapped and
    tracks the highest page used.

    X86 Only.

Arguments:

    Page - Supplies the physical page number we are starting at.


Return Value:

    None.

--*/
{
    PUCHAR p;
    ULONG EndPage;
    ULONG Entry;
    ULONG FrameNumber;
    ULONG Page;
    PHARDWARE_PTE PageTableP;
    PHARDWARE_PTE PageTableV;
    ULONG Offset;

    //
    // memory under 16MB is always mapped.
    //
    if (StartPage < _16MB) {
        return(ESUCCESS);
    }

    //
    // A PDE is 4MB (22 bits, so if we're in the same 4MB region, nothing to do)
    //


    EndPage = StartPage + NumberPages;

    for (Page = StartPage; Page < EndPage; Page += 1) {
        Entry = Page >> 10;

        //
        // If the PDE entry for this page address range is not allocated,
        // then allocate and initialize the PDE entry to map the page table
        // pages for the the memory range. Otherwise, compute the address
        // of the page table pages.
        //
        if (PDE[Entry].Valid == 0) {

            //
            // Allocate and initialize two page table pages to map the specified
            // page into physical memory.
            //
            p = BlAllocateHeapAligned(PAGE_SIZE*3);
            if (p==NULL) {
                return(ENOMEM);
            }

            PageTableP = (PHARDWARE_PTE)PAGE_ALIGN((ULONG)p+PAGE_SIZE-1);
            RtlZeroMemory(PageTableP, PAGE_SIZE);
            FrameNumber = ((ULONG)PageTableP & ~KSEG0_BASE) >> PAGE_SHIFT;
            PDE[Entry].Valid = 1;
            PDE[Entry].Write = 1;
            PDE[Entry].PageFrameNumber = FrameNumber;

            //
            // initialize a page table page to map the specified
            // page into KSEG0_BASE and ALTERNATE_BASE.
            //
            // N.B. Only one page table page is allocated since the contents
            //      for both mappings are the same.
            //
            PageTableV = (PHARDWARE_PTE)((PUCHAR)PageTableP + PAGE_SIZE);

            RtlZeroMemory(PageTableV, PAGE_SIZE);
            FrameNumber = ((ULONG)PageTableV & ~KSEG0_BASE) >> PAGE_SHIFT;
            Offset = Entry + (KSEG0_BASE >> 22);
            PDE[Offset].Valid = 1;
            PDE[Offset].Write = 1;
            PDE[Offset].PageFrameNumber = FrameNumber;

            if (BlVirtualBias) {
                Offset += (BlVirtualBias >> 22);
                PDE[Offset].Valid = 1;
                PDE[Offset].Write = 1;
                PDE[Offset].PageFrameNumber = FrameNumber;
            }

            if (Entry > HighestPde) {
                HighestPde = Entry;
            }

        } else {
            Offset = Entry + (KSEG0_BASE >> 22);
            PageTableP = (PHARDWARE_PTE)(PDE[Entry].PageFrameNumber << PAGE_SHIFT);
            PageTableV = (PHARDWARE_PTE)(PDE[Offset].PageFrameNumber << PAGE_SHIFT);
        }

        //
        // If this is not the first page in memory, then mark it valid.
        //

        if (Page != 0) {
            Offset = Page & 0x3ff;
            PageTableP[Offset].Valid = 1;
            PageTableP[Offset].Write = 1;
            PageTableP[Offset].PageFrameNumber = Page;

            PageTableV[Offset].Valid = 1;
            PageTableV[Offset].Write = 1;
            PageTableV[Offset].PageFrameNumber = Page;
        }
    }

    _asm {

        //
        // Reload cr3 to force a flush
        //

        mov eax,cr3
        mov cr3,eax
    }
    return ESUCCESS;

}

ARC_STATUS
MempFixMapping(
    ULONG StartPage,
    ULONG NumberPages
    )
/*++

Routine Description:

    This routine makes sure that the range for kernel/hal, which
    are currently not relocatable, are mapped by "permanent" PTEs.
    
    Normally they are allocated via OsLoaderHeap, and they could
    become unmapped during system bootup.

    X86 Only.

Arguments:

    StartPage - Supplies the physical page number we are starting at.
    NumberPages - total # of pages

Return Value:

    None.

--*/
{
    ULONG EndPage;
    ULONG PTPage;
    ULONG Entry;
    ULONG FrameNumber;
    ULONG Page;
    PHARDWARE_PTE PhysPageTable;
    PHARDWARE_PTE VirtPageTable;
    PHARDWARE_PTE PageTableOri;
    ULONG Offset;
    ARC_STATUS Status;

    //
    // memory under 16MB is always mapped.
    //
    if (StartPage < _16MB) {
        return(ESUCCESS);
    }

    //
    // A PDE is 4MB (22 bits, so if we're in the same 4MB region, nothing to do)
    //


    EndPage = StartPage + NumberPages;

    for (Page = StartPage; Page < EndPage; Page += 1024) {
        Entry = Page >> 10;

        if (PDE[Entry].Valid == 0) {
            //
            // this must have been previously mapped or MempCheckMapping has a
            // bug in it.
            //
            return(EINVAL);
        }
        
        //
        // allocate space for the new PTEs
        //
        Status = BlAllocateAlignedDescriptor(
                            LoaderMemoryData,
                            0,
                            2,
                            1,
                            &PTPage );
        
        if (Status != ESUCCESS) {
            return(ENOMEM);
        }

        //
        // copy the contents of the original PTE into the new PTE.
        // then point the PDE at the new entry.
        //
        FrameNumber = PTPage;
        PhysPageTable = (PHARDWARE_PTE) (KSEG0_BASE | (FrameNumber << PAGE_SHIFT));
        PageTableOri = (PHARDWARE_PTE) ((PDE[Entry].PageFrameNumber << PAGE_SHIFT) | KSEG0_BASE); 
        RtlCopyMemory(PhysPageTable, PageTableOri, PAGE_SIZE);
        
        PDE[Entry].Valid = 1;
        PDE[Entry].Write = 1;
        PDE[Entry].PageFrameNumber = FrameNumber;

        //
        // now repeat this exercise of copying original PTE into the new PTE
        // for the virtual mappings of the PTE.
        //
        // N.B. Only one page table page is allocated since the contents
        //      for both mappings are the same.
        //
        FrameNumber = PTPage+1;
        VirtPageTable = (PHARDWARE_PTE) (KSEG0_BASE | ((FrameNumber) << PAGE_SHIFT));
        
        Offset = Entry + (KSEG0_BASE >> 22);
        PageTableOri = (PHARDWARE_PTE)((PDE[Offset].PageFrameNumber << PAGE_SHIFT) | KSEG0_BASE); 
        
        RtlCopyMemory(VirtPageTable, PageTableOri, PAGE_SIZE);

        PDE[Offset].Valid = 1;
        PDE[Offset].Write = 1;
        PDE[Offset].PageFrameNumber = FrameNumber;

        if (BlVirtualBias) {
            Offset += (BlVirtualBias >> 22);
            PDE[Offset].Valid = 1;
            PDE[Offset].Write = 1;
            PDE[Offset].PageFrameNumber = FrameNumber;
        }
    } 
    
    _asm {

        //
        // Reload cr3 to force a flush
        //

        mov eax,cr3
        mov cr3,eax
    }
    
    return ESUCCESS;

}

ARC_STATUS
MempSetPageZeroOverride(
    BOOLEAN Enable
    )
/*++

Routine Description:

    This routine maps or unmaps page 0.

    X86 Only.

Arguments:

    Enable - specifies whether to enable or disable the mapping for this page.

Return Value:

    None.

--*/
{
    ULONG Entry;
    PHARDWARE_PTE PageTableP;
    PHARDWARE_PTE PageTableV;
    ULONG Offset;
    const ULONG StartPage = 0;

    Entry = StartPage >> 10;

    //
    // compute the address of the page table pages.
    //
    if (PDE[Entry].Valid == 0) {

        //
        // the pde for the pte should already be setup.
        // if it's not then we're dead.
        //
        return(ENOMEM);


    } else {
        Offset = Entry + (KSEG0_BASE >> 22);
        PageTableP = (PHARDWARE_PTE)(PDE[Entry].PageFrameNumber << PAGE_SHIFT);
        PageTableV = (PHARDWARE_PTE)(PDE[Offset].PageFrameNumber << PAGE_SHIFT);
    }

    Offset = StartPage & 0x3ff;

    if (PageTableP[Offset].PageFrameNumber != StartPage &&
        PageTableV[Offset].PageFrameNumber != StartPage) {
        //
        // the PTE isn't setup correctly.  Bail out.
        //
        return(ENOMEM);
    }

    PageTableP[Offset].Valid = Enable ? 1 : 0;
    PageTableV[Offset].Valid = Enable ? 1 : 0;

    _asm {

        //
        // Reload cr3 to force a flush
        //

        mov eax,cr3
        mov cr3,eax
    }

    return ESUCCESS;

}




//
// Convert remaing LoaderReserve (>16MB mem) to
// MemoryFirmwareTemporary for the mmgr
//
//

void
BlpRemapReserve (void)
{
    PMEMORY_ALLOCATION_DESCRIPTOR NextDescriptor;
    PLIST_ENTRY NextEntry;


    NextEntry = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    while (NextEntry != &BlLoaderBlock->MemoryDescriptorListHead) {
           NextDescriptor = CONTAINING_RECORD(NextEntry,
                                              MEMORY_ALLOCATION_DESCRIPTOR,
                                              ListEntry);
       if ((NextDescriptor->MemoryType == LoaderReserve)) {
           NextDescriptor->MemoryType = MemoryFirmwareTemporary;
       }
       NextEntry = NextEntry->Flink;
    }

}


ARC_STATUS
BlpMarkExtendedVideoRegionOffLimits(
    VOID
    )
/*++

Routine Description:

    This routine marks the extended video memory region as permanant, so that
    the OS doesn't try to map this memory.

    The ntdetect.com module actually finds out the location of this region as
    well as the region size.  We read this from the memory location that
    ntdetect put the data in.

Arguments:

    None.


Return Value:

    ARC_STATUS indicating outcome.

--*/
{
    ULONG BaseOfExtendedVideoRegionInBytes;
    ULONG SizeOfExtendedVideoRegionInBytes;
    ARC_STATUS Status;

    //
    // ntdetect has placed the base page and size of video rom at physical
    // address 0x740
    //
    //
    // Before we go read this address, we have to explicitly map in page zero.
    //
    Status = MempSetPageZeroOverride(TRUE);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // read the memory.
    //
    BaseOfExtendedVideoRegionInBytes = *(PULONG)0x740;
    SizeOfExtendedVideoRegionInBytes = *(PULONG)0x744;

    //
    // Ok, we're done with this page.  unmap it so no one can dereference null.
    //
    Status = MempSetPageZeroOverride(FALSE);
    if (Status != ESUCCESS) {
        return(Status);
    }

    if (BaseOfExtendedVideoRegionInBytes == 0 || SizeOfExtendedVideoRegionInBytes == 0) {
        return(ESUCCESS);
    }

    if (BlLoaderBlock != NULL) {

        PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;
        PKLDR_DATA_TABLE_ENTRY BiosDataTableEntry;
        ULONG BasePage;
        ULONG LastPage;
        ULONG PageCount;

        BasePage = BaseOfExtendedVideoRegionInBytes >> PAGE_SHIFT;
        LastPage = (BaseOfExtendedVideoRegionInBytes + SizeOfExtendedVideoRegionInBytes - 1) >> PAGE_SHIFT;
        PageCount = LastPage - BasePage + 1;

        while ( PageCount != 0 ) {

            ULONG thisCount;

            MemoryDescriptor = BlFindMemoryDescriptor(BasePage);
            if (MemoryDescriptor == NULL) {
                break;
            }

            thisCount = PageCount;
            //
            // if we run off of this descriptor, truncate our region
            // at the end of the descriptor.
            //
            if (BasePage + PageCount > MemoryDescriptor->BasePage + MemoryDescriptor->PageCount) {
                thisCount = (MemoryDescriptor->BasePage + MemoryDescriptor->PageCount) - BasePage;
            }

            BlGenerateDescriptor(MemoryDescriptor,
                                 MemoryFirmwarePermanent,
                                 BasePage,
                                 thisCount);

            BasePage += thisCount;
            PageCount -= thisCount;
        }

        //
        // Allocate the memory in the firmware module list as well
        //
        Status = BlAllocateFirmwareTableEntry(
            "VidBios",
            "\\System\\Firmware\\VidBios",
            (PVOID) BaseOfExtendedVideoRegionInBytes,
            SizeOfExtendedVideoRegionInBytes,
            &BiosDataTableEntry
            );
        if (Status != ESUCCESS) {

            BlPrint("BlpMarkExtendedVideoRegionOffLimits: Failed Adding Firmware\n");

        }
        
    }

    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\ntsetup.c ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    ntsetup.c

Abstract:

    This module is the tail-end of the osloader program.  It performs all
    x86-specific allocations and setups for ntoskrnl.  osloader.c calls
    this module immediately before branching into the loaded kernel image.

Author:

    John Vert (jvert) 20-Jun-1991

Environment:


Revision History:

--*/

#include "bootx86.h"

#if defined(_X86AMD64_)
#include "..\amd64\amd64prv.h"
#endif

#ifdef ARCI386
#include "stdio.h"
#include "string.h"
#include "stdlib.h"
CHAR OutputBuffer[256];
char BreakInKey;
ULONG Count;
#endif

extern PHARDWARE_PTE HalPT;
extern PHARDWARE_PTE PDE;
extern ULONG_PTR BlHeapFree;

extern ULONG PcrBasePage;
extern ULONG TssBasePage;

#define PDI_SHIFT_X86PAE 21

//
// PaeEnabled is set to TRUE when we actually transition to PAE mode.
//

BOOLEAN PaeEnabled = FALSE;

//
// PDPT is a pointer to the Page Directory Pointer Table, used to support
// PAE mode.
//

PHARDWARE_PTE_X86PAE PDPT = NULL;

//
// We need a block of memory to split the free heap that we can allocate before
// we begin cleanup
//
PMEMORY_ALLOCATION_DESCRIPTOR SplitDescriptor;


//
// So we know where to unmap to
//
extern ULONG HighestPde;

//
// Private function prototypes
//

VOID
NSFixProcessorContext(
    IN ULONG PCR,
    IN ULONG TSS
    );

VOID
NSDumpMemoryDescriptors(
    IN PLIST_ENTRY ListHead
    );

VOID
NSUnmapFreeDescriptors(
    IN PLIST_ENTRY ListHead
    );

VOID
NSDumpMemory(
    PVOID Start,
    ULONG Length
    );

VOID
NSFixMappings(
    IN PLIST_ENTRY ListHead
    );

ARC_STATUS
BlpAllocatePAETables(
    VOID
    );

PHARDWARE_PTE_X86PAE
BlpFindPAEPageDirectoryEntry(
    IN ULONG Va
    );

PHARDWARE_PTE_X86PAE
BlpFindPAEPageTableEntry(
    IN ULONG Va
    );

VOID
BlpInitializePAETables(
    VOID
    );

VOID
BlpEnablePAE(
    IN ULONG PaePhysicalAddress
    );


ARC_STATUS
BlSetupForNt(
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    )

/*++

Routine Description:

    Called by osloader to handle any processor-dependent allocations or
    setups.

Arguments:

    BlLoaderBlock - Pointer to the parameters which will be passed to
                    ntoskrnl

    EntryPoint    - Supplies the entry point for ntoskrnl.exe

Return Value:

    ESUCCESS - All setup succesfully completed.

--*/

{

    ARC_STATUS Status = ESUCCESS;
    static ULONG PCR;
    static ULONG TSS;
    ULONG i;
    HARDWARE_PTE_X86 nullpte;

    //
    // First clean up the display, meaning that any messages displayed after
    // this point cannot be DBCS. Unfortunately there are a couple of messages
    // that can be displayed in certain error paths from this point out but
    // fortunately they are extremely rare.
    //
    // Note that TextGrTerminate goes into real mode to do some of its work
    // so we really really have to call it here (see comment at bottom of
    // this routine about real mode).
    //

    TextGrTerminate();

    BlLoaderBlock->u.I386.CommonDataArea = NULL;
    BlLoaderBlock->u.I386.MachineType = MachineType;
    PCR = PcrBasePage;
    if (PCR == 0 || PCR >= _16MB) {
        BlPrint("Couldn't allocate PCR descriptor in NtProcessStartup,BlSetupForNt is failing\n");
        return(ENOMEM);
    }

    //
    // Mapped hardcoded virtual pointer to the boot processors PCR
    // The virtual pointer comes from the HAL reserved area
    //
    // First zero out any PTEs that may have already been mapped for
    // a SCSI card.
    //

    RtlZeroMemory(HalPT, PAGE_SIZE);
    _asm {
        mov     eax, cr3
        mov     cr3, eax
    }

    HalPT[(KI_USER_SHARED_DATA - 0xFFC00000) >> PAGE_SHIFT].PageFrameNumber = PCR + 1;
    HalPT[(KI_USER_SHARED_DATA - 0xFFC00000) >> PAGE_SHIFT].Valid = 1;
    HalPT[(KI_USER_SHARED_DATA - 0xFFC00000) >> PAGE_SHIFT].Write = 1;
    RtlZeroMemory((PVOID)KI_USER_SHARED_DATA, PAGE_SIZE);

    HalPT[(KIP0PCRADDRESS - 0xFFC00000) >> PAGE_SHIFT].PageFrameNumber = PCR;
    HalPT[(KIP0PCRADDRESS - 0xFFC00000) >> PAGE_SHIFT].Valid = 1;
    HalPT[(KIP0PCRADDRESS - 0xFFC00000) >> PAGE_SHIFT].Write = 1;
    PCR = KIP0PCRADDRESS;

    if (BlUsePae != FALSE) {

        //
        // Allocate the new PAE mapping structures
        //

        Status = BlpAllocatePAETables();
        if (Status != ESUCCESS) {
            goto SetupFailed;
        }

    } else {

        //
        // If we are booting into 32-bit non-PAE mode then truncate any memory
        // above 4G.  The parameter to BlTruncateDescriptors() is expressed
        // in pages, and is the highest page that will be included after
        // the truncation.
        //

        if (BlAmd64UseLongMode == FALSE) {
            BlTruncateDescriptors( 1024 * 1024 - 1 );
        }
    }

    //
    // use our pre-allocated space for Tss.
    //
    TSS = TssBasePage;
    if (TSS == 0 || TSS >= _16MB) {
        BlPrint("Couldn't allocate valid TSS descriptor in NtProcessStartup, BlSetupForNt is failing\n");
        return(ENOMEM);
    }
    TSS = (KSEG0_BASE | (TSS << PAGE_SHIFT)) + BlVirtualBias;

#ifdef LOADER_DEBUG

    NSDumpMemoryDescriptors(&(BlLoaderBlock->MemoryDescriptorListHead));

#endif

    //
    // Clean up the page directory and table entries.
    //
    RtlZeroMemory (&nullpte,sizeof (HARDWARE_PTE_X86));
    if (BlVirtualBias) {
        if (!BlOldKernel) {

            //
            // Blow away the 48MB from the old to the new alternate
            //
            i= OLD_ALTERNATE >> PDI_SHIFT;
            while (i < (ALTERNATE_BASE >> PDI_SHIFT)) {
                PDE[i++]= nullpte;
            }

        }

    } else {

        //
        // Remove both sets of 3GB mappings
        //
        i=(OLD_ALTERNATE) >> PDI_SHIFT;
        for (i; i < (ALTERNATE_BASE+BASE_LOADER_IMAGE) >> PDI_SHIFT; i++) {
            PDE[i]= nullpte;
        }

    }

    //
    // Allocate this before we unmap free descriptors, so we can grow the heap
    //
    SplitDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR)BlAllocateHeap(
                                    sizeof(MEMORY_ALLOCATION_DESCRIPTOR));

    //
    // If transitioning to AMD64 long mode, perform some initial mapping
    // and structure transitioning here.
    //

#if defined(_X86AMD64_)

    if (BlAmd64UseLongMode != FALSE) {
        Status = BlAmd64PrepForTransferToKernelPhase1(BlLoaderBlock);
        if (Status != ESUCCESS) {
            goto SetupFailed;
        }
    }

#endif

    //
    // Do this before PAE mode.
    //

    NSUnmapFreeDescriptors(&(BlLoaderBlock->MemoryDescriptorListHead));

    _asm {
        mov     eax, cr3
        mov     cr3, eax
    }

    if (BlUsePae != FALSE) {

        // Copy the four byte page table mapping to the new eight byte
        // mapping and transition to PAE mode.
        //

        BlpInitializePAETables();
        BlpEnablePAE( (ULONG)PDPT );

        //
        // We are now in PAE mode.  The debugger looks at PaeEnabled in order
        // to correctly interpret page table entries, update that now.
        //

        PaeEnabled = TRUE;
    }


    //
    // N. B.  DO NOT GO BACK INTO REAL MODE AFTER REMAPPING THE GDT AND
    //        IDT TO HIGH MEMORY!!  If you do, they will get re-mapped
    //        back into low-memory, then UN-mapped by MmInit, and you
    //        will be completely tubed!
    //

    NSFixProcessorContext(PCR, TSS);

    NSFixMappings(&(BlLoaderBlock->MemoryDescriptorListHead));

    //
    // For every case, except the /3GB case, the number of pages spanned
    // is simply the highest number page allocated, plus 1 (to make the
    // math work out)
    //
    BlLoaderBlock->Extension->LoaderPagesSpanned=BlHighestPage+1;

    //
    // For the /3GB case, we do the additional check that the PagesSpanned
    // must be at least 0x1000. The reasons for that are unclear to me
    //
    if (BlVirtualBias) {

        ULONG PagesSpanned = 0;

        //
        // Calculate the number of pages spanned by the loader image
        //
        PagesSpanned = (BASE_LOADER_IMAGE >> PAGE_SHIFT);

        //
        // Is that a larger number than the highest allocated pages?
        //
        if (PagesSpanned > (BlHighestPage + 1)) {

            //
            // Yes, so use that for the number of pages spanned
            //
            BlLoaderBlock->Extension->LoaderPagesSpanned = PagesSpanned;

        }

        if (!BlOldKernel) {

            BlVirtualBias += ((BlLowestPage) << PAGE_SHIFT);

        }
    }

    BlLoaderBlock->u.I386.VirtualBias = BlVirtualBias;

    //
    // If transitioning to AMD64 long mode, perform the second phase of
    // the transition process now that the mapping tables have been cleaned
    // up.
    //

#if defined(_X86AMD64_)

    if (BlAmd64UseLongMode != FALSE) {
        BlAmd64PrepForTransferToKernelPhase2(BlLoaderBlock);
    }

#endif

SetupFailed:
    return Status;
}

VOID
NSFixProcessorContext(
    IN ULONG PCR,
    IN ULONG TSS
    )

/*++

Routine Description:

    This relocates the GDT, IDT, PCR, and TSS to high virtual memory space.

Arguments:

    PCR - Pointer to the PCR's location (in high virtual memory)
    TSS - Pointer to kernel's TSS (in high virtual memory)

Return Value:

    None.

--*/

{
    #pragma pack(2)
    static struct {
        USHORT Limit;
        ULONG Base;
    } GdtDef,IdtDef;
    #pragma pack(4)

    PKGDTENTRY pGdt;
    ULONG Bias = 0;


    if (BlVirtualBias != 0 ) {
       Bias = BlVirtualBias;
    }
    //
    // Kernel expects the PCR to be zero-filled on startup
    //

    RtlZeroMemory((PVOID)PCR, PAGE_SIZE);
    _asm {
        sgdt GdtDef;
        sidt IdtDef;
    }

    GdtDef.Base = (KSEG0_BASE | GdtDef.Base) + Bias;
    IdtDef.Base = (KSEG0_BASE | IdtDef.Base) + Bias;
    pGdt = (PKGDTENTRY)GdtDef.Base;

    //
    // Initialize selector that points to PCR
    //

    pGdt[6].BaseLow  = (USHORT)(PCR & 0xffff);
    pGdt[6].HighWord.Bytes.BaseMid = (UCHAR)((PCR >> 16) & 0xff);
    pGdt[6].HighWord.Bytes.BaseHi  = (UCHAR)((PCR >> 24) & 0xff);

    //
    // Initialize selector that points to TSS
    //

    pGdt[5].BaseLow = (USHORT)(TSS & 0xffff);
    pGdt[5].HighWord.Bytes.BaseMid = (UCHAR)((TSS >> 16) & 0xff);
    pGdt[5].HighWord.Bytes.BaseHi  = (UCHAR)((TSS >> 24) & 0xff);

    _asm {
        lgdt GdtDef;
        lidt IdtDef;
    }
}

VOID
NSUnmapFreeDescriptors(
    IN PLIST_ENTRY ListHead
    )

/*++

Routine Description:

    Unmaps memory which is marked as free, so it memory management will know
    to reclaim it.

Arguments:

    ListHead - pointer to the start of the MemoryDescriptorList

Return Value:

    None.

--*/

{

    PMEMORY_ALLOCATION_DESCRIPTOR CurrentDescriptor;
    PLIST_ENTRY CurrentLink;
    ULONG EndPage;
    ULONG FrameNumber;
    PHARDWARE_PTE PageTable;
    ULONG StartPage;
    ULONG i,Limit;
    HARDWARE_PTE_X86 nullpte;

    Limit = 0x1000000 >> PAGE_SHIFT;
    if (BlOldKernel) {
        BlpRemapReserve();
    } else {
        if (Limit < BlHighestPage) {
            Limit = BlHighestPage;
        }
    }

    CurrentLink = ListHead->Flink;
    while (CurrentLink != ListHead) {
        CurrentDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR)CurrentLink;

#if 0

#define UNINIT_FILL 0x12345678

        //
        // Fill unused memory with a bogus pattern to catch problems where kernel code
        // expects uninitalized memory to be zero.
        //
        if ((CurrentDescriptor->MemoryType == LoaderFree) ||
            (CurrentDescriptor->MemoryType == LoaderReserve)) {

            if (CurrentDescriptor->BasePage + CurrentDescriptor->PageCount < Limit) {
                //
                // This descriptor should already be mapped, just fill it
                //
                RtlFillMemoryUlong((PVOID)((CurrentDescriptor->BasePage << PAGE_SHIFT) | KSEG0_BASE),
                                   CurrentDescriptor->PageCount << PAGE_SHIFT,
                                   UNINIT_FILL);
            } else {
                //
                // This descriptor is not mapped. Use the first HAL page table to map and fill each page
                //
                for (StartPage = CurrentDescriptor->BasePage;
                     StartPage < CurrentDescriptor->BasePage + CurrentDescriptor->PageCount;
                     StartPage++) {
                    HalPT[0].PageFrameNumber = StartPage;
                    HalPT[0].Valid = 1;
                    HalPT[0].Write = 1;
                    _asm {
                        mov     eax, cr3
                        mov     cr3, eax
                    }
                    RtlFillMemory((PVOID)0xFFC00000,PAGE_SIZE,UNINIT_FILL);
                }
                HalPT[0].PageFrameNumber = 0;
                HalPT[0].Valid = 0;
                HalPT[0].Write = 0;
                _asm {
                    mov     eax, cr3
                    mov     cr3, eax
                }
            }
        }


#endif


        if ( (CurrentDescriptor->MemoryType == LoaderFree) ||
             (((CurrentDescriptor->MemoryType == LoaderFirmwareTemporary) ||
               (CurrentDescriptor->MemoryType == LoaderReserve)) &&
              (CurrentDescriptor->BasePage < Limit)) ||
             (CurrentDescriptor->MemoryType == LoaderLoadedProgram) ||
             (CurrentDescriptor->MemoryType == LoaderOsloaderStack)) {

            StartPage = CurrentDescriptor->BasePage | (KSEG0_BASE >> PAGE_SHIFT);
            EndPage = CurrentDescriptor->BasePage + CurrentDescriptor->PageCount;
            if (EndPage > Limit) {
                EndPage = Limit;
            }
            EndPage |= (KSEG0_BASE >> PAGE_SHIFT);
            while(StartPage < EndPage) {

                if (PDE[StartPage >> 10].Valid != 0) {
                    FrameNumber = PDE[StartPage >> 10].PageFrameNumber;
                    PageTable= (PHARDWARE_PTE)(KSEG0_BASE | (FrameNumber << PAGE_SHIFT));
                    ((PULONG)(PageTable))[StartPage & 0x3ff] = 0;
                }
                StartPage++;
            }
        }

        CurrentLink = CurrentLink->Flink;
    }

    if (BlOldKernel) {
        return;
    }

    //
    // Unmap the PDEs too if running on a new mm
    //

    RtlZeroMemory (&nullpte,sizeof (HARDWARE_PTE_X86));
    for (i=(BlHighestPage >> 10)+1;i <= HighestPde;i++){
        PDE[i]=nullpte;
        PDE[i+(KSEG0_BASE >> PDI_SHIFT)]=nullpte;
        if (BlVirtualBias) {
            PDE[i + ((KSEG0_BASE+BlVirtualBias) >> PDI_SHIFT)] = nullpte;
        }
    }

#if 0
    {
        ULONG stoppde;

        if (BlVirtualBias) {

            //
            //BlHighest page here is the address of the LOWEST page used, so put the
            //subtraction in the loader block and use the value for the base of the bias
            //
            i = ((BlVirtualBias|KSEG0_BASE)>> PDI_SHIFT)+1;


            stoppde = (((BlVirtualBias|KSEG0_BASE) -
                        (BASE_LOADER_IMAGE-(BlLowestPage << PAGE_SHIFT)) ) >> PDI_SHIFT)-1;


            while (i < stoppde){
                PDE[i++]=nullpte;
            }
        }
    }
#endif

}



/*++

Routine Description:

    Fixup the mappings to be consistent.
    We need to have one at address 0 (For the valid PDE entries)
    One at KSEG0 for standard loads
    One at either ALTERNATE_BASE or OLD_ALTERNATE for /3gb systems on a
    post 5.0 or 5.0 and prior respectively


Arguments:

    None

Return Value:

    None.

--*/

VOID
NSFixMappings(
    IN PLIST_ENTRY ListHead
    )
{

    PHARDWARE_PTE_X86PAE PdePae;
    PMEMORY_ALLOCATION_DESCRIPTOR CurrentDescriptor;
    PLIST_ENTRY CurrentLink;
    ULONG StartPage,Bias=0,FreePage,FreeCount;



    //
    //  Finally, go through and mark all large OsloaderHeap blocks
    //  as firmware temporary, so that MM reclaims them in phase 0
    //  (for /3gb) EXCEPT the LoaderBlock.
    //

    CurrentLink = ListHead->Flink;

    if (BlVirtualBias) {
        Bias = BlVirtualBias >> PAGE_SHIFT;
    }

    FreePage = (BlHeapFree & ~KSEG0_BASE) >> PAGE_SHIFT;

    while (CurrentLink != ListHead) {

        CurrentDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR)CurrentLink;

        StartPage = CurrentDescriptor->BasePage | (KSEG0_BASE >> PAGE_SHIFT) ;
        StartPage += Bias;

        //
        // BlHeapFree is not Biased, it relies on the 2GB mapping.
        //
        if ( CurrentDescriptor->MemoryType == LoaderOsloaderHeap) {

            if ((CurrentDescriptor->BasePage <= FreePage) &&
               ((CurrentDescriptor->BasePage + CurrentDescriptor->PageCount) > FreePage + 1)) {

                FreeCount = CurrentDescriptor->PageCount;
                CurrentDescriptor->PageCount = FreePage-CurrentDescriptor->BasePage+1;

                SplitDescriptor->MemoryType= LoaderFirmwareTemporary;
                SplitDescriptor->BasePage = FreePage+1;
                SplitDescriptor->PageCount = FreeCount-CurrentDescriptor->PageCount;

                BlInsertDescriptor(SplitDescriptor);
            }
            if (PaeEnabled)  {
                PdePae = BlpFindPAEPageDirectoryEntry( StartPage << PAGE_SHIFT);
                if (PdePae->Valid == 0) {
                    CurrentDescriptor->MemoryType = LoaderFirmwareTemporary;
                }
            }else {
                if (PDE[StartPage >> 10].Valid == 0 ) {
                    CurrentDescriptor->MemoryType = LoaderFirmwareTemporary;
                }
            }


        }

        if ( (CurrentDescriptor->MemoryType == LoaderReserve)) {
            CurrentDescriptor->MemoryType = LoaderFree;
        }

        CurrentLink = CurrentLink->Flink;
    }


    _asm {
        mov     eax, cr3
        mov     cr3, eax
    }



}

//
// Temp. for debugging
//

VOID
NSDumpMemory(
    PVOID Start,
    ULONG Length
    )
{
    ULONG cnt;

    BlPrint(" %lx:\n",(ULONG)Start);
    for (cnt=0; cnt<Length; cnt++) {
        BlPrint("%x ",*((PUSHORT)(Start)+cnt));
        if (((cnt+1)%16)==0) {
            BlPrint("\n");
        }
    }
}

VOID
NSDumpMemoryDescriptors(
    IN PLIST_ENTRY ListHead
    )

/*++

Routine Description:

    Dumps a memory descriptor list to the screen.  Used for debugging only.

Arguments:

    ListHead - Pointer to the head of the memory descriptor list

Return Value:

    None.

--*/

{

    PLIST_ENTRY CurrentLink;
    PMEMORY_ALLOCATION_DESCRIPTOR CurrentDescriptor;


    CurrentLink = ListHead->Flink;
    while (CurrentLink != ListHead) {
        CurrentDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR)CurrentLink;
        BlPrint("Fl = %lx    Bl = %lx  ",
                (ULONG)CurrentDescriptor->ListEntry.Flink,
                (ULONG)CurrentDescriptor->ListEntry.Blink
               );
        BlPrint("Type %x  Base %lx  Pages %lx\n",
                (USHORT)(CurrentDescriptor->MemoryType),
                CurrentDescriptor->BasePage,
                CurrentDescriptor->PageCount
               );
        CurrentLink = CurrentLink->Flink;
    }
    while (!GET_KEY()) { // DEBUG ONLY!
    }

}

ULONG
BlpCountPAEPagesToMapX86Page(
    PHARDWARE_PTE_X86 PageTable
    )

/*++

Routine Description:

    Called to prepare the conversion of 4-byte PTEs to 8-byte PAE PTEs, this
    routine returns the number of 8-byte page tables that will be required
    to map the contents of this 4-byte page table.

    Because an 8-byte page table has half the number of entries as a 4-byte
    page table, the answer will be 0, 1 or 2.

Arguments:

    PageTable - Pointer to a 4-byte page table.

Return Value:

    The number of 8-byte page tables required to map the contents of this
    4-byte page table.

--*/

{
    PHARDWARE_PTE_X86 pageTableEntry;
    ULONG chunkIndex;
    ULONG pageTableIndex;
    ULONG newPageTableCount;

    //
    // PAE page tables contain fewer PTEs than regular page tables do.
    //
    // Examine the page table in chunks, where each chunk contains the PTEs
    // that represent an entire PAE page table.
    //

    newPageTableCount = 0;
    for (chunkIndex = 0;
         chunkIndex < PTE_PER_PAGE_X86;
         chunkIndex += PTE_PER_PAGE_X86PAE) {

        for (pageTableIndex = 0;
             pageTableIndex < PTE_PER_PAGE_X86PAE;
             pageTableIndex++) {

            pageTableEntry = &PageTable[ chunkIndex + pageTableIndex ];
            if (pageTableEntry->Valid) {

                //
                // One or more PTEs are valid in this chunk, record
                // the fact that a new page table will be needed to map
                // them and skip to the next chunk.
                //

                newPageTableCount++;
                break;
            }
        }
    }
    return newPageTableCount;
}

VOID
BlpCopyX86PteToPAEPte(
    IN  PHARDWARE_PTE_X86 OldPte,
    OUT PHARDWARE_PTE_X86PAE NewPte
    )
/*++

Routine Description:

    Copies the contents of a 4-byte PTE to an 8-byte PTE, with the exception
    of the PageFrameNumber field.

Arguments:

    OldPte - Pointer to the source 4-byte PTE.

    NewPte - Pointer to the destination 8-byte PTE.

Return Value:

    None.

--*/

{
    NewPte->Valid           = OldPte->Valid;
    NewPte->Write           = OldPte->Write;
    NewPte->Owner           = OldPte->Owner;
    NewPte->WriteThrough    = OldPte->WriteThrough;
    NewPte->CacheDisable    = OldPte->CacheDisable;
    NewPte->Accessed        = OldPte->Accessed;
    NewPte->Dirty           = OldPte->Dirty;
    NewPte->LargePage       = OldPte->LargePage;
    NewPte->Global          = OldPte->Global;
}

PHARDWARE_PTE_X86PAE
BlpFindPAEPageDirectoryEntry(
    IN ULONG Va
    )

/*++

Routine Description:

    Given a virtual address, locates and returns a pointer to the appropriate
    8-byte Page Directory Entry.

Arguments:

    Va - Virtual Address for which a PDE pointer is desired.

Return Value:

    Pointer to the page directory entry for the supplied Va.

--*/

{
    PHARDWARE_PTE_X86PAE directoryPointerTableEntry;
    PHARDWARE_PTE_X86PAE pageDirectoryEntry;
    PHARDWARE_PTE_X86PAE pageDirectory;
    ULONG pageDirectoryIndex;
    ULONG directoryPointerTableIndex;

    //
    // Get a pointer to the directory pointer table entry
    //

    directoryPointerTableIndex = PP_INDEX_PAE( Va );
    directoryPointerTableEntry = &PDPT[ directoryPointerTableIndex ];

    //
    // Get a pointer to the page directory entry
    //

    pageDirectory = PAGE_FRAME_FROM_PTE( directoryPointerTableEntry );
    pageDirectoryIndex = PD_INDEX_PAE( Va );
    pageDirectoryEntry = &pageDirectory[ pageDirectoryIndex ];

    return pageDirectoryEntry;
}

PHARDWARE_PTE_X86PAE
BlpFindPAEPageTableEntry(
    IN ULONG Va
    )

/*++

Routine Description:

    Given a virtual address, locates and returns a pointer to the appropriate
    8-byte Page Table Entry.

Arguments:

    Va - Virtual Address for which a PTE pointer is desired.

Return Value:

    Pointer to the page directory entry for the supplied Va.

--*/

{
    PHARDWARE_PTE_X86PAE pageDirectoryEntry;
    PHARDWARE_PTE_X86PAE pageTableEntry;
    PHARDWARE_PTE_X86PAE pageTable;
    ULONG pageTableIndex;

    //
    // Get a pointer to the page directory entry
    //

    pageDirectoryEntry = BlpFindPAEPageDirectoryEntry( Va );
    ASSERT( pageDirectoryEntry->Valid != 0 );

    //
    // Get a pointer to the page table entry
    //

    pageTable = PAGE_FRAME_FROM_PTE( pageDirectoryEntry );
    pageTableIndex = PT_INDEX_PAE( Va );
    pageTableEntry = &pageTable[ pageTableIndex ];

    return pageTableEntry;
}

VOID
BlpMapAddress(
    IN ULONG Va,
    IN PHARDWARE_PTE_X86 OldPageDirectoryEntry,
    IN PHARDWARE_PTE_X86 OldPageTableEntry,
    IN OUT PULONG NextFreePage
    )

/*++

Routine Description:

    Worker function used during the conversion of a two-level, 4-byte mapping
    structure to the three-level, 8-byte mapping structure required for PAE
    mode.

    Maps VA to the physical address referenced by OldPageTableEntry, allocating
    a new page table if necessary.

Arguments:

    Va - Virtual Address for this mapping.

    OldPageDirectoryEntry - Pointer to the existing, 4-byte PDE.

    OldPageTableEntry - Pointer to the existing, 4-byte PTE.

    NextFreePage - Pointer to the physical page number of the next free
        page in our private page pool.

Return Value:

    None.

--*/

{
    PHARDWARE_PTE_X86PAE pageDirectoryEntry;
    PHARDWARE_PTE_X86PAE  pageTableEntry;
    ULONG pageFrameNumber;
    ULONG pageTableVa;

    //
    // Ignore recursive mappings that exist in the old page table
    // structure, we set those up as we go.
    //

    if ((Va >= PTE_BASE) && (Va < (PDE_BASE_X86 + PAGE_SIZE))) {
        return;
    }

    //
    // Get a pointer to the page directory entry
    //

    pageDirectoryEntry = BlpFindPAEPageDirectoryEntry( Va );

    //
    // If the page table for this PTE isn't present yet, allocate one and
    // copy over the old page directory attributes.
    //

    if (pageDirectoryEntry->Valid == 0) {

        pageFrameNumber = *NextFreePage;
        *NextFreePage += 1;

        BlpCopyX86PteToPAEPte( OldPageDirectoryEntry, pageDirectoryEntry );
        pageDirectoryEntry->PageFrameNumber = pageFrameNumber;

        //
        // Check the recursive mapping for this page table
        //

        pageTableVa = PTE_BASE +
                      (Va / PAGE_SIZE) * sizeof(HARDWARE_PTE_X86PAE);

        pageTableEntry = BlpFindPAEPageTableEntry( pageTableVa );

        if (pageTableEntry->Valid == 0) {
            DbgBreakPoint();
        }

        if (pageTableEntry->PageFrameNumber != pageFrameNumber) {
            DbgBreakPoint();
        }
    }

    //
    // Get a pointer to the page table entry
    //

    pageTableEntry = BlpFindPAEPageTableEntry( Va );
    if (pageTableEntry->Valid != 0) {
        DbgBreakPoint();
    }

    //
    // Propogate the PTE page and attributes.
    //

    BlpCopyX86PteToPAEPte( OldPageTableEntry, pageTableEntry );
    pageTableEntry->PageFrameNumber = OldPageTableEntry->PageFrameNumber;
}

VOID
BlpInitializePAETables(
    VOID
    )

/*++

Routine Description:

    Allocates a new, three-level, 8-byte PTE mapping structure and duplicates
    in it the mapping described by the existing 4-byte PTE mapping structure.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG pageDirectoryIndex;
    ULONG va;
    PHARDWARE_PTE_X86 pageDirectoryEntry;
    PHARDWARE_PTE_X86 pageTableEntry;
    PHARDWARE_PTE_X86 pageTable;
    PHARDWARE_PTE_X86PAE paeDirectoryEntry;
    ULONG directoryPointerIndex;
    ULONG nextFreePage;
    ULONG i;
    ULONG pageTableIndex;
    ULONGLONG pageFrameNumber;

    nextFreePage = ((ULONG)PDPT) >> PAGE_SHIFT;

    //
    // Initialize the page directory pointer table to reference the four
    // page directories.
    //

    nextFreePage++;
    for (i = 0; i < 4; i++) {

        PDPT[i].PageFrameNumber = nextFreePage;
        PDPT[i].Valid = 1;
        nextFreePage++;
    }

    //
    // Set up the recursive mapping: first the PDE.
    //

    directoryPointerIndex = PDE_BASE_X86PAE >> PPI_SHIFT_X86PAE;
    pageFrameNumber = PDPT[ directoryPointerIndex ].PageFrameNumber;
    paeDirectoryEntry = (PHARDWARE_PTE_X86PAE)(((ULONG)pageFrameNumber) << PAGE_SHIFT);

    for (i = 0; i < 4; i++) {

        paeDirectoryEntry->PageFrameNumber = PDPT[i].PageFrameNumber;
        paeDirectoryEntry->Valid = 1;
        paeDirectoryEntry->Write = 1;

        paeDirectoryEntry++;
    }


    for (pageDirectoryIndex = 0;
         pageDirectoryIndex < PTE_PER_PAGE_X86;
         pageDirectoryIndex++) {

        pageDirectoryEntry = &PDE[pageDirectoryIndex];
        if (pageDirectoryEntry->Valid == 0) {
            continue;
        }

        pageTable = PAGE_FRAME_FROM_PTE( pageDirectoryEntry );
        for (pageTableIndex = 0;
             pageTableIndex < PTE_PER_PAGE_X86;
             pageTableIndex++) {

            pageTableEntry = &pageTable[pageTableIndex];
            if (pageTableEntry->Valid == 0) {
                continue;
            }

            va = (pageDirectoryIndex << PDI_SHIFT_X86) +
                 (pageTableIndex << PTI_SHIFT);

            //
            // We have a physical address and a va, update the new mapping.
            //

            BlpMapAddress( va,
                           pageDirectoryEntry,
                           pageTableEntry,
                           &nextFreePage );
        }
    }

    //
    // Finally, set up the PDE for the second of two HAL common buffer page
    // tables.
    //

    paeDirectoryEntry =
        BlpFindPAEPageDirectoryEntry( 0xFFC00000 + (1 << PDI_SHIFT_X86PAE) );

    paeDirectoryEntry->Valid = 1;
    paeDirectoryEntry->Write = 1;
    paeDirectoryEntry->PageFrameNumber = nextFreePage;

    nextFreePage += 1;
}

ARC_STATUS
BlpAllocatePAETables(
    VOID
    )

/*++

Routine Description:

    Calculates the number of pages required to contain an 8-byte mapping
    structure to duplicate the existing 4-byte mapping structure.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG pageDirectoryIndex;
    PHARDWARE_PTE_X86 pageDirectoryEntry;
    PHARDWARE_PTE_X86 pageTable;
    PHARDWARE_PTE_X86PAE pageDirectoryPointerTable;
    ULONG status;
    ULONG pageBase;
    ULONG newPageTableCount;
    ULONG allocationSize;

    //
    // Find out how many page tables we are going to need by examining the
    // existing page table entries.
    //

    newPageTableCount = 0;

    for (pageDirectoryIndex = 0;
         pageDirectoryIndex < PTE_PER_PAGE_X86;
         pageDirectoryIndex++) {

        pageDirectoryEntry = &PDE[pageDirectoryIndex];
        if (pageDirectoryEntry->Valid != 0) {

            pageTable = PAGE_FRAME_FROM_PTE( pageDirectoryEntry );

            //
            // For each valid page table, scan the PTEs in chunks, where
            // a chunk represents the PTEs that will reside in a PAE page
            // table.
            //

            newPageTableCount += BlpCountPAEPagesToMapX86Page( pageTable );
        }
    }

    //
    // Include a page for the second HAL page table.  This won't get
    // included automatically in the conversion count because it doesn't
    // currently contain any valid page table entries.
    //

    newPageTableCount += 1;

    //
    // Include a page for each of four page directories and the page
    // directory pointer table, then allocate the pages.
    //

    newPageTableCount += 5;

    status = BlAllocateDescriptor( LoaderMemoryData,
                                   0,
                                   newPageTableCount,
                                   &pageBase );
    if (status != ESUCCESS) {
        DbgPrint("BlAllocateDescriptor failed!\n");
        return status;
    }

    allocationSize = newPageTableCount << PAGE_SHIFT;
    pageDirectoryPointerTable =
        (PHARDWARE_PTE_X86PAE)PAGE_TO_VIRTUAL( pageBase );

    RtlZeroMemory( pageDirectoryPointerTable, allocationSize );

    //
    // Set the global PDPT, we're done.
    //

    PDPT = pageDirectoryPointerTable;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\port.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    port.c

Abstract:

    This modules implements com port code to support reading/writing from com ports.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

--*/

#include "bldr.h"
#include "string.h"
#include "stdlib.h"
#include "stdio.h"
#include "ntverp.h"
#include "acpitabl.h"

#ifdef _IA64_
#include "bldria64.h"
#endif


//
// Headless Port information.
//
ULONG   BlTerminalDeviceId = 0;
BOOLEAN BlTerminalConnected = FALSE;
ULONG   BlTerminalDelay = 0;

HEADLESS_LOADER_BLOCK LoaderRedirectionInformation;




//
// Define COM Port registers.
//
#define COM_DAT     0x00
#define COM_IEN     0x01            // interrupt enable register
#define COM_FCR     0x02            // FIFO Control Register
#define COM_LCR     0x03            // line control registers
#define COM_MCR     0x04            // modem control reg
#define COM_LSR     0x05            // line status register
#define COM_MSR     0x06            // modem status register
#define COM_DLL     0x00            // divisor latch least sig
#define COM_DLM     0x01            // divisor latch most sig

#define COM_BI      0x10
#define COM_FE      0x08
#define COM_PE      0x04
#define COM_OE      0x02

#define LC_DLAB     0x80            // divisor latch access bit

#define CLOCK_RATE  0x1C200         // USART clock rate

#define MC_DTRRTS   0x03            // Control bits to assert DTR and RTS
#define MS_DSRCTSCD 0xB0            // Status bits for DSR, CTS and CD
#define MS_CD       0x80

#define COM_OUTRDY  0x20
#define COM_DATRDY  0x01

//
// This bit controls the loopback testing mode of the device. Basically
// the outputs are connected to the inputs (and vice versa).
//

#define SERIAL_MCR_LOOP     0x10

//
// This bit is used for general purpose output.
//

#define SERIAL_MCR_OUT1     0x04

//
// This bit contains the (complemented) state of the clear to send
// (CTS) line.
//

#define SERIAL_MSR_CTS      0x10

//
// This bit contains the (complemented) state of the data set ready
// (DSR) line.
//

#define SERIAL_MSR_DSR      0x20

//
// This bit contains the (complemented) state of the ring indicator
// (RI) line.
//

#define SERIAL_MSR_RI       0x40

//
// This bit contains the (complemented) state of the data carrier detect
// (DCD) line.
//

#define SERIAL_MSR_DCD      0x80

typedef struct _CPPORT {
    PUCHAR Address;
    ULONG Baud;
    USHORT Flags;
} CPPORT, *PCPPORT;

#define PORT_DEFAULTRATE    0x0001      // baud rate not specified, using default
#define PORT_MODEMCONTROL   0x0002      // using modem controls

//
// Define wait timeout value.
//

#define TIMEOUT_COUNT 1024 * 200


extern
VOID
FwStallExecution(
    IN ULONG Microseconds
    );

//
// Routines for reading/writing bytes out to the UART.
//
UCHAR
(*READ_UCHAR)(
    IN PUCHAR Addr
    );

VOID
(*WRITE_UCHAR)(
    IN PUCHAR Addr,
    IN UCHAR  Value
    );


//
// Define COM Port function prototypes.
//

VOID
CpInitialize (
    PCPPORT Port,
    PUCHAR Address,
    ULONG Rate
    );

VOID 
CpEnableFifo(
    IN PUCHAR   Address,
    IN BOOLEAN  bEnable
    );

LOGICAL
CpDoesPortExist(
    IN PUCHAR Address
    );

UCHAR
CpReadLsr (
    IN PCPPORT Port,
    IN UCHAR Waiting
    );

VOID
CpSetBaud (
    PCPPORT Port,
    ULONG Rate
    );

USHORT
CpGetByte (
    PCPPORT Port,
    PUCHAR Byte,
    BOOLEAN WaitForData,
    BOOLEAN PollOnly
    );

VOID
CpPutByte (
    PCPPORT Port,
    UCHAR Byte
    );

//
// Define debugger port initial state.
//

CPPORT Port[4] = {
                  {NULL, 0, PORT_DEFAULTRATE},
                  {NULL, 0, PORT_DEFAULTRATE},
                  {NULL, 0, PORT_DEFAULTRATE},
                  {NULL, 0, PORT_DEFAULTRATE}
                 };

//
// This is how we find table information from
// the ACPI table index.
//
extern PDESCRIPTION_HEADER
BlFindACPITable(
    IN PCHAR TableName,
    IN ULONG TableLength
    );



//
// We'll use these to fill in some function pointers,
// which in turn will be used to read/write from the
// UART.  We can't simply assign the function pointers
// to point to READ_PORT_UCHAR/READ_REGISTER_UCHAR and
// WRITE_PORT_UCHAR/WRITE_REGISTER_UCHAR, because in
// the case of IA64, some of these functions are macros.
//
// To get around this, build these dummy functions that
// will inturn simply call the correct READ/WRITE functions/macros.
//
UCHAR
MY_READ_PORT_UCHAR( IN PUCHAR Addr )
{
    return( READ_PORT_UCHAR(Addr) );
}

UCHAR
MY_READ_REGISTER_UCHAR( IN PUCHAR Addr )
{
    return( READ_REGISTER_UCHAR(Addr) );
}


VOID
MY_WRITE_PORT_UCHAR( IN PUCHAR Addr, IN UCHAR  Value )
{
    WRITE_PORT_UCHAR(Addr, Value);
}

VOID
MY_WRITE_REGISTER_UCHAR( IN PUCHAR Addr, IN UCHAR  Value )
{
    WRITE_REGISTER_UCHAR(Addr, Value);
}




LOGICAL
BlRetrieveBIOSRedirectionInformation(
    VOID
    )

/*++

Routine Description:

    This functions retrieves the COM port information from the ACPI
    table.

Arguments:

    We'll be filling in the LoaderRedirectionInformation structure.

Returned Value:

    TRUE - If a debug port is found.

--*/

{

    PSERIAL_PORT_REDIRECTION_TABLE pPortTable = NULL;
    PUCHAR      CurrentAddress = NULL;
    UCHAR       Checksum;
    ULONG       i;
    ULONG       CheckLength;

    pPortTable = (PSERIAL_PORT_REDIRECTION_TABLE)BlFindACPITable( "SPCR",
                                                                  sizeof(SERIAL_PORT_REDIRECTION_TABLE) );

    if( pPortTable ) {

        //
        // generate a checksum for later validation.
        //
        CurrentAddress = (PUCHAR)pPortTable;
        CheckLength = pPortTable->Header.Length;
        Checksum = 0;
        for( i = 0; i < CheckLength; i++ ) {
            Checksum = Checksum + CurrentAddress[i];
        }


        if(
                                                // checksum is okay?
            (Checksum == 0) &&

                                                // device address defined?
            ((UCHAR UNALIGNED *)pPortTable->BaseAddress.Address.LowPart != (UCHAR *)NULL) &&

                                                // he better be in system or memory I/O
                                                // note: 0 - systemI/O
                                                //       1 - memory mapped I/O
            ((pPortTable->BaseAddress.AddressSpaceID == 0) ||
             (pPortTable->BaseAddress.AddressSpaceID == 1))

         ) {


            if( pPortTable->BaseAddress.AddressSpaceID == 0 ) {
                LoaderRedirectionInformation.IsMMIODevice = TRUE;
            } else {
                LoaderRedirectionInformation.IsMMIODevice = FALSE;
            }


            //
            // We got the table.  Now dig out the information we want.
            // See definitiion of SERIAL_PORT_REDIRECTION_TABLE (acpitabl.h)
            //
            LoaderRedirectionInformation.UsedBiosSettings = TRUE;
            LoaderRedirectionInformation.PortNumber = 3;
            LoaderRedirectionInformation.PortAddress = (UCHAR UNALIGNED *)(pPortTable->BaseAddress.Address.LowPart);

            if( pPortTable->BaudRate == 7 ) {
                LoaderRedirectionInformation.BaudRate = BD_115200;
            } else if( pPortTable->BaudRate == 6 ) {
                LoaderRedirectionInformation.BaudRate = BD_57600;
            } else if( pPortTable->BaudRate == 4 ) {
                LoaderRedirectionInformation.BaudRate = BD_19200;
            } else {
                LoaderRedirectionInformation.BaudRate = BD_9600;
            }

            LoaderRedirectionInformation.Parity = pPortTable->Parity;
            LoaderRedirectionInformation.StopBits = pPortTable->StopBits;
            LoaderRedirectionInformation.TerminalType = pPortTable->TerminalType;

            //
            // If this is a new SERIAL_PORT_REDIRECTION_TABLE, then it's got the PCI device
            // information.
            //
            if( pPortTable->Header.Length >= sizeof(SERIAL_PORT_REDIRECTION_TABLE) ) {

                LoaderRedirectionInformation.PciDeviceId = (USHORT UNALIGNED)pPortTable->PciDeviceId;
                LoaderRedirectionInformation.PciVendorId = (USHORT UNALIGNED)pPortTable->PciVendorId;
                LoaderRedirectionInformation.PciBusNumber = (UCHAR)pPortTable->PciBusNumber;
                LoaderRedirectionInformation.PciSlotNumber = (UCHAR)pPortTable->PciSlotNumber;
                LoaderRedirectionInformation.PciFunctionNumber = (UCHAR)pPortTable->PciFunctionNumber;
                LoaderRedirectionInformation.PciFlags = (ULONG UNALIGNED)pPortTable->PciFlags;
            } else {

                //
                // There's no PCI device information in this table.
                //
                LoaderRedirectionInformation.PciDeviceId = (USHORT)0xFFFF;
                LoaderRedirectionInformation.PciVendorId = (USHORT)0xFFFF;
                LoaderRedirectionInformation.PciBusNumber = 0;
                LoaderRedirectionInformation.PciSlotNumber = 0;
                LoaderRedirectionInformation.PciFunctionNumber = 0;
                LoaderRedirectionInformation.PciFlags = 0;
            }

            return TRUE;

        }

    }

    return FALSE;

}



LOGICAL
BlPortInitialize(
    IN ULONG BaudRate,
    IN ULONG PortNumber,
    IN PUCHAR PortAddress OPTIONAL,
    IN BOOLEAN ReInitialize,
    OUT PULONG BlFileId
    )

/*++

Routine Description:

    This functions initializes the com port.

Arguments:

    BaudRate - Supplies an optional baud rate.

    PortNumber - supplies an optinal port number.

    ReInitialize - Set to TRUE if we already have this port open, but for some
        reason need to completely reset the port.  Otw it should be FALSE.

    BlFileId - A place to store a fake file Id, if successful.

Returned Value:

    TRUE - If a debug port is found, and BlFileId will point to a location within Port[].

--*/

{


    //
    // Make guesses on any inputs that we didn't get.
    //
    if( BaudRate == 0 ) {
        BaudRate = BD_19200;
    }

    if( PortNumber == 0 ) {

        //
        // Try COM2, then COM1
        //
        if (CpDoesPortExist((PUCHAR)COM2_PORT)) {
            PortNumber = 2;
            PortAddress = (PUCHAR)COM2_PORT;

        } else if (CpDoesPortExist((PUCHAR)COM1_PORT)) {
            PortNumber = 1;
            PortAddress = (PUCHAR)COM1_PORT;
        } else {
            return FALSE;
        }
    }


    //
    // If the user didn't send us a port address, then
    // guess based on the COM port number.
    //
    if( PortAddress == 0 ) {

        switch (PortNumber) {
            case 1:
                PortAddress = (PUCHAR)COM1_PORT;
                break;

            case 2:
                PortAddress = (PUCHAR)COM2_PORT;
                break;

            case 3:
                PortAddress = (PUCHAR)COM3_PORT;
                break;

            default:
                PortNumber = 4;
                PortAddress = (PUCHAR)COM4_PORT;
        }

    }


    //
    // we need to handle the case where we're dealing with
    // MMIO space (as opposed to System I/O space).
    //
    if( LoaderRedirectionInformation.IsMMIODevice ) {
        PHYSICAL_ADDRESS    PhysAddr;
        PVOID               MyPtr;

        PhysAddr.LowPart = PtrToUlong(PortAddress);
        PhysAddr.HighPart = 0;

        MyPtr = MmMapIoSpace(PhysAddr,(1+COM_MSR),TRUE);
        PortAddress = MyPtr;

        READ_UCHAR = MY_READ_REGISTER_UCHAR;
        WRITE_UCHAR = MY_WRITE_REGISTER_UCHAR;

    } else {

        // System IO space.
        READ_UCHAR = MY_READ_PORT_UCHAR;
        WRITE_UCHAR = MY_WRITE_PORT_UCHAR;
    }



    //
    // See if the port even exists...
    //
    if (!CpDoesPortExist(PortAddress)) {

        //
        // It's possible that it's a port that's being emulated
        // in software.  Give them another chance to pass.
        //
        if (!CpDoesPortExist(PortAddress)) {
            return FALSE;
        }
    }



    //
    // Check if the port is already in use, and this is a first init.
    //
    if (!ReInitialize && (Port[PortNumber-1].Address != NULL)) {
        return FALSE;
    }



    //
    // Check if someone tries to reinit a port that is not open.
    //
    if (ReInitialize && (Port[PortNumber-1].Address == NULL)) {
        return FALSE;
    }



    //
    // Initialize the specified port.
    //
    CpInitialize(&(Port[PortNumber-1]),
                 PortAddress,
                 BaudRate);



    *BlFileId = (PortNumber-1);
    return TRUE;
}

VOID
BlLoadGUID(
    GUID *pGuid
    )

/*++

Routine Description:

    Attempt to find the System GUID.  If we find it, load it into
    pGuid.

Arguments:

    pGuid - Variable to receive the detected GUID.

Return Value:

    None.

--*/

{
#include <smbios.h>
#include <wmidata.h>

PUCHAR      CurrentAddress = NULL;
PUCHAR      EndingAddress = NULL;
UCHAR       Checksum;
ULONG       i;
ULONG       CheckLength;
BOOLEAN     FoundIt = FALSE;
PSYSID_UUID_ENTRY   UuidEntry = NULL;


    //
    // Make sure we have a place to store the GUID when we find it.
    //
    if( pGuid == NULL ) {
        return;
    }


    //
    // Now search through the SMBIOS tables for the GUID.
    //
    CurrentAddress = (PUCHAR)SYSID_EPS_SEARCH_START;
    EndingAddress = CurrentAddress + SYSID_EPS_SEARCH_SIZE;

    while( CurrentAddress < EndingAddress ) {

        UuidEntry = (PSYSID_UUID_ENTRY)CurrentAddress;

        if( memcmp(UuidEntry->Type, SYSID_TYPE_UUID, 0x6) == 0 ) {

            //
            // See if the checksum matches too.
            //
            CheckLength = UuidEntry->Length;
            Checksum = 0;
            for( i = 0; i < CheckLength; i++ ) {
                Checksum = Checksum + CurrentAddress[i];
            }

            if( Checksum == 0 ) {
                FoundIt = TRUE;

                RtlCopyMemory( pGuid,
                               UuidEntry->UUID,
                               sizeof(GUID) );

                break;

            }

        }

        CurrentAddress++;

    }


    if( !FoundIt ) {
        RtlZeroMemory( pGuid,
                       sizeof(SYSID_UUID) );
    }

    return;
}

VOID
BlEnableFifo(
    IN ULONG    DeviceId,
    IN BOOLEAN  bEnable
    )
/*++

Routine Description:

    This routine will attempt to enable the FIFO in the 16550 UART.
    Note that the behaviour is undefined for the 16450, but practically,
    this should have no effect.

Arguments:

    DeviceId - Value returned by BlPortInitialize()
    bEnable  - if TRUE, FIFO is enabled
               if FALSE, FIFO  is disabled
                 
Return Value:

    None

--*/
{
    CpEnableFifo(
        Port[DeviceId].Address,
        bEnable
        );
}

VOID
BlInitializeHeadlessPort(
    VOID
    )

/*++

Routine Description:

    Does x86-specific initialization of a dumb terminal connected to a serial port.  Currently,
    it assumes baud rate and com port are pre-initialized, but this can be changed in the future
    by reading the values from boot.ini or someplace.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG   i;
    PCHAR  TmpBuffer;


    if( (LoaderRedirectionInformation.PortNumber == 0) &&
        !(LoaderRedirectionInformation.PortAddress) ) {

        //
        // This means that no one has filled in the LoaderRedirectionInformation
        // structure, which means that we aren't redirecting right now.
        // See if the BIOS was redirecting.  If so, pick up those settings
        // and use them.
        //

        BlRetrieveBIOSRedirectionInformation();


    }

    if( LoaderRedirectionInformation.PortNumber ) {


        //
        // We really need to make sure there's an address associated with
        // this port and not just a port number.
        //
        if( LoaderRedirectionInformation.PortAddress == NULL ) {

            switch( LoaderRedirectionInformation.PortNumber ) {

                case 4:
                    LoaderRedirectionInformation.PortAddress = (PUCHAR)COM4_PORT;
                    break;

                case 3:
                    LoaderRedirectionInformation.PortAddress = (PUCHAR)COM3_PORT;
                    break;

                case 2:
                    LoaderRedirectionInformation.PortAddress = (PUCHAR)COM2_PORT;
                    break;

                case 1:
                default:
                    LoaderRedirectionInformation.PortAddress = (PUCHAR)COM1_PORT;
                    break;
            }

        }


        //
        // Either we just created a LoaderRedirectionInformation, or it was
        // built before we ever got into this function.  Either way, we should
        // go try and initialize the port he wants to talk through.
        //

        BlTerminalConnected = (BOOLEAN)BlPortInitialize(LoaderRedirectionInformation.BaudRate,
                                                        LoaderRedirectionInformation.PortNumber,
                                                        LoaderRedirectionInformation.PortAddress,
                                                        BlTerminalConnected,
                                                        &BlTerminalDeviceId);
        
        if (BlIsTerminalConnected()) {


            //
            // Enable the FIFO on the UART so we reduce the chance of a character
            // getting dropped.
            //
            BlEnableFifo(
                BlTerminalDeviceId,
                TRUE
                );


            //
            // Go get the machine's GUID.
            //
            BlLoadGUID( &LoaderRedirectionInformation.SystemGUID );


            //
            // Figure time to delay based on baudrate.  Note: we do this calculation
            // to be at 60% of the baud rate because it appears that FwStallExecution
            // is extremely inaccurate, and that if we dont go slow enough a lot of
            // screen attributes being sent in a row causes a real vt100 to drop
            // characters that follows as it repaints/clears/whatever the screen.
            //
            if( LoaderRedirectionInformation.BaudRate == 0 ) {
                LoaderRedirectionInformation.BaudRate = BD_9600;
            }
            BlTerminalDelay = LoaderRedirectionInformation.BaudRate;
            BlTerminalDelay = BlTerminalDelay / 10;        // 10 bits per character (8-1-1) is the max.
            BlTerminalDelay = ((1000000 / BlTerminalDelay) * 10) / 6; // 60% speed.


            //
            // Make sure there are no stale attributes on the terminal
            // sitting at the other end of our headless port.
            //
            // <CSI>m  (turn attributes off)
            TmpBuffer = "\033[m";
            for( i = 0; i < strlen(TmpBuffer); i++ ) {
                BlPortPutByte( BlTerminalDeviceId, TmpBuffer[i]);
                FwStallExecution(BlTerminalDelay);
            }



        } else {

            //
            // Make sure we don't have any redirection information
            // hanging around if we didn't pass BlIsTerminalConnected()
            //
            RtlZeroMemory( &LoaderRedirectionInformation, sizeof(HEADLESS_LOADER_BLOCK) );
        }

    } else {

        BlTerminalConnected = FALSE;
    }

}

LOGICAL
BlTerminalAttached(
    IN ULONG DeviceId
    )

/*++

Routine Description:

    This routine will attempt to discover if a terminal is attached.

Arguments:

    DeviceId - Value returned by BlPortInitialize()

Return Value:

    TRUE - Port seems to have something attached.

    FALSE - Port doesn't seem to have anything attached.

--*/

{
    UCHAR ModemStatus;
    BOOLEAN ReturnValue;

    //
    // Check for a carrier.
    //
    ModemStatus = READ_UCHAR(Port[DeviceId].Address + COM_MSR);
    ReturnValue = ((ModemStatus & MS_DSRCTSCD) == MS_DSRCTSCD);
    return ReturnValue;
}

VOID
BlSetHeadlessRestartBlock(
    IN PTFTP_RESTART_BLOCK RestartBlock
    )

/*++

Routine Description:

    This routine will fill in the areas of the restart block that are appropriate
    for the headless server effort.

Arguments:

    RestartBlock - The magic structure for holding restart information from oschoice
        to setupldr.

Return Value:

    None.

--*/

{

    if( LoaderRedirectionInformation.PortNumber ) {


        RestartBlock->HeadlessUsedBiosSettings = (ULONG)LoaderRedirectionInformation.UsedBiosSettings;
        RestartBlock->HeadlessPortNumber = (ULONG)LoaderRedirectionInformation.PortNumber;
        RestartBlock->HeadlessPortAddress = (PUCHAR)LoaderRedirectionInformation.PortAddress;
        RestartBlock->HeadlessBaudRate = (ULONG)LoaderRedirectionInformation.BaudRate;
        RestartBlock->HeadlessParity = (ULONG)LoaderRedirectionInformation.Parity;
        RestartBlock->HeadlessStopBits = (ULONG)LoaderRedirectionInformation.StopBits;
        RestartBlock->HeadlessTerminalType = (ULONG)LoaderRedirectionInformation.TerminalType;

        RestartBlock->HeadlessPciDeviceId = LoaderRedirectionInformation.PciDeviceId;
        RestartBlock->HeadlessPciVendorId = LoaderRedirectionInformation.PciVendorId;
        RestartBlock->HeadlessPciBusNumber = LoaderRedirectionInformation.PciBusNumber;
        RestartBlock->HeadlessPciSlotNumber = LoaderRedirectionInformation.PciSlotNumber;
        RestartBlock->HeadlessPciFunctionNumber = LoaderRedirectionInformation.PciFunctionNumber;
        RestartBlock->HeadlessPciFlags = LoaderRedirectionInformation.PciFlags;
    }
}

VOID
BlGetHeadlessRestartBlock(
    IN PTFTP_RESTART_BLOCK RestartBlock,
    IN BOOLEAN RestartBlockValid
    )

/*++

Routine Description:

    This routine will get all the information from a restart block
    for the headless server effort.

Arguments:

    RestartBlock - The magic structure for holding restart information from oschoice
        to setupldr.

    RestartBlockValid - Is this block valid (full of good info)?

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( RestartBlockValid );

    LoaderRedirectionInformation.UsedBiosSettings = (BOOLEAN)RestartBlock->HeadlessUsedBiosSettings;
    LoaderRedirectionInformation.DataBits = 0;
    LoaderRedirectionInformation.StopBits = (UCHAR)RestartBlock->HeadlessStopBits;
    LoaderRedirectionInformation.Parity = (BOOLEAN)RestartBlock->HeadlessParity;
    LoaderRedirectionInformation.BaudRate = (ULONG)RestartBlock->HeadlessBaudRate;;
    LoaderRedirectionInformation.PortNumber = (ULONG)RestartBlock->HeadlessPortNumber;
    LoaderRedirectionInformation.PortAddress = (PUCHAR)RestartBlock->HeadlessPortAddress;
    LoaderRedirectionInformation.TerminalType = (UCHAR)RestartBlock->HeadlessTerminalType;

    LoaderRedirectionInformation.PciDeviceId = (USHORT)RestartBlock->HeadlessPciDeviceId;
    LoaderRedirectionInformation.PciVendorId = (USHORT)RestartBlock->HeadlessPciVendorId;
    LoaderRedirectionInformation.PciBusNumber = (UCHAR)RestartBlock->HeadlessPciBusNumber;
    LoaderRedirectionInformation.PciSlotNumber = (UCHAR)RestartBlock->HeadlessPciSlotNumber;
    LoaderRedirectionInformation.PciFunctionNumber = (UCHAR)RestartBlock->HeadlessPciFunctionNumber;
    LoaderRedirectionInformation.PciFlags = (ULONG)RestartBlock->HeadlessPciFlags;

}

ULONG
BlPortGetByte (
    IN ULONG BlFileId,
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the port and return it.

Arguments:

    BlFileId - The port to read from.

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
        kernel debugger line.

    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    return CpGetByte(&Port[BlFileId], Input, TRUE, FALSE);
}

VOID
BlPortPutByte (
    IN ULONG BlFileId,
    IN UCHAR Output
    )

/*++

Routine Description:

    Write a byte to the port.

Arguments:

    BlFileId - The port to write to.

    Output - Supplies the output data byte.

Return Value:

    None.

--*/

{
    CpPutByte(&Port[BlFileId], Output);
}

ULONG
BlPortPollByte (
    IN ULONG BlFileId,
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the port and return it if one is available.

Arguments:

    BlFileId - The port to poll.

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    return CpGetByte(&Port[BlFileId], Input, FALSE, FALSE);
}

ULONG
BlPortPollOnly (
    IN ULONG BlFileId
    )

/*++

Routine Description:

    Check if a byte is available

Arguments:

    BlFileId - The port to poll.

Return Value:

    CP_GET_SUCCESS is returned if a byte is ready.
    CP_GET_ERROR is returned if error encountered.
    CP_GET_NODATA is returned if timeout.

--*/

{
    UCHAR Input;

    return CpGetByte(&Port[BlFileId], &Input, FALSE, TRUE);
}

VOID
CpInitialize (
    PCPPORT Port,
    PUCHAR Address,
    ULONG Rate
    )

/*++

    Routine Description:

        Fill in the com port port object, set the initial baud rate,
        turn on the hardware.

    Arguments:

        Port - address of port object

        Address - port address of the com port
                    (CP_COM1_PORT, CP_COM2_PORT)

        Rate - baud rate  (CP_BD_150 ... CP_BD_19200)

--*/

{

    PUCHAR hwport;
    UCHAR   mcr, ier;

    Port->Address = Address;
    Port->Baud = 0;

    CpSetBaud(Port, Rate);

    //
    // Assert DTR, RTS.
    //

    hwport = Port->Address;
    hwport += COM_MCR;

    mcr = MC_DTRRTS;
    WRITE_UCHAR(hwport, mcr);

    hwport = Port->Address;
    hwport += COM_IEN;

    ier = 0;
    WRITE_UCHAR(hwport, ier);
    return;
}

VOID 
CpEnableFifo(
    IN PUCHAR   Address,
    IN BOOLEAN  bEnable
    )
/*++

Routine Description:

    This routine will attempt to enable the FIFO in the
    UART at the address specified.  If this is a 16550,
    this works.  The behaviour on a 16450 is not defined,
    but practically, there is no effect.

Arguments:

    Address - address of hw port.
    bEnable - if TRUE, FIFO is enabled
              if FALSE, FIFO  is disabled

Return Value:

    None

--*/
{
    //
    // Enable the FIFO in the UART. The behaviour is undefined on the
    // 16450, but practically, it should just ignore the command.
    //
    PUCHAR hwport = Address;
    hwport += COM_FCR;
    WRITE_UCHAR(hwport, bEnable);   
}

LOGICAL
CpDoesPortExist(
    IN PUCHAR Address
    )

/*++

Routine Description:

    This routine will attempt to place the port into its
    diagnostic mode.  If it does it will twiddle a bit in
    the modem control register.  If the port exists this
    twiddling should show up in the modem status register.

    NOTE: This routine must be called before the device is
          enabled for interrupts, this includes setting the
          output2 bit in the modem control register.

    This is blatantly stolen from TonyE's code in ntos\dd\serial\serial.c.

Arguments:

    Address - address of hw port.

Return Value:

    TRUE - Port exists.

    FALSE - Port doesn't exist.

--*/

{
    UCHAR OldModemStatus;
    UCHAR ModemStatus;
    BOOLEAN ReturnValue = TRUE;

    //
    // Save the old value of the modem control register.
    //
    OldModemStatus = READ_UCHAR(Address + COM_MCR);

    //
    // Set the port into diagnostic mode.
    //
    WRITE_UCHAR(Address + COM_MCR, SERIAL_MCR_LOOP);

    //
    // Bang on it again to make sure that all the lower bits
    // are clear.
    //
    WRITE_UCHAR(Address + COM_MCR, SERIAL_MCR_LOOP);

    //
    // Read the modem status register.  The high for bits should
    // be clear.
    //

    ModemStatus = READ_UCHAR(Address + COM_MSR);
    if (ModemStatus & (SERIAL_MSR_CTS | SERIAL_MSR_DSR |
                       SERIAL_MSR_RI  | SERIAL_MSR_DCD)) {
        ReturnValue = FALSE;
        goto EndFirstTest;
    }

    //
    // So far so good.  Now turn on OUT1 in the modem control register
    // and this should turn on ring indicator in the modem status register.
    //
    WRITE_UCHAR(Address + COM_MCR, (SERIAL_MCR_OUT1 | SERIAL_MCR_LOOP));

    ModemStatus = READ_UCHAR(Address + COM_MSR);
    if (!(ModemStatus & SERIAL_MSR_RI)) {
        ReturnValue = FALSE;
        goto EndFirstTest;
    }


EndFirstTest:

    if( ReturnValue == FALSE ) {

        UCHAR       OldIEValue = 0, OldLCValue = 0;
        USHORT      Value1 = 0, Value2 = 0;

        UCHAR       PreviousLineControl = 0;

        //
        // We failed the loopback test.  Test another way.
        //

        // Remember the original Interrupt Enable setting and
        // Line Control setting.
        OldIEValue = READ_UCHAR( Address + COM_IEN );
        OldLCValue = READ_UCHAR( Address + COM_LCR );


        // Make sure we aren't accessing the divisor latch.
        WRITE_UCHAR( Address + COM_LCR, OldLCValue | LC_DLAB );

        WRITE_UCHAR( Address + COM_IEN, 0xF );

        Value1 = READ_UCHAR( Address + COM_IEN );
        Value1 = Value1 << 8;
        Value1 |= READ_UCHAR( Address + COM_DAT );

        // Now read the divisor latch.
        PreviousLineControl = READ_UCHAR( Address + COM_LCR );
        WRITE_UCHAR( Address + COM_LCR, (UCHAR)(PreviousLineControl | LC_DLAB) );
        Value2 = READ_UCHAR( Address + COM_DLL );
        Value2 = Value2 + (READ_UCHAR(Address + COM_DLM) << 8 );
        WRITE_UCHAR( Address + COM_LCR, PreviousLineControl );


        // Restore original Line Control register and
        // Interrupt Enable setting.
        WRITE_UCHAR( Address + COM_LCR, OldLCValue );
        WRITE_UCHAR( Address + COM_IEN, OldIEValue );

        if( Value1 == Value2 ) {

            //
            // We passed this test.  Reset ReturnValue
            // appropriately.
            //
            ReturnValue = TRUE;
        }
    }



    //
    // Put the modem control back into a clean state.
    //
    WRITE_UCHAR(Address + COM_MCR, OldModemStatus);
    return ReturnValue;
}

UCHAR
CpReadLsr (
    PCPPORT Port,
    UCHAR waiting
    )

/*++

    Routine Description:

        Read LSR byte from specified port.  If HAL owns port & display
        it will also cause a debug status to be kept up to date.

        Handles entering & exiting modem control mode for debugger.

    Arguments:

        Port - Address of CPPORT

    Returns:

        Byte read from port

--*/

{

    static  UCHAR ringflag = 0;
    UCHAR   lsr, msr;

    lsr = READ_UCHAR(Port->Address + COM_LSR);

    if ((lsr & waiting) == 0) {
        msr = READ_UCHAR (Port->Address + COM_MSR);
        ringflag |= (msr & SERIAL_MSR_RI) ? 1 : 2;
        if (ringflag == 3) {

            //
            // The ring indicate line has toggled, use modem control from
            // now on.
            //

            Port->Flags |= PORT_MODEMCONTROL;
        }
    }

    return lsr;
}

VOID
CpSetBaud (
    PCPPORT Port,
    ULONG Rate
    )

/*++

    Routine Description:

        Set the baud rate for the port and record it in the port object.

    Arguments:

        Port - address of port object

        Rate - baud rate  (CP_BD_150 ... CP_BD_56000)

--*/

{

    ULONG   divisorlatch;
    PUCHAR  hwport;
    UCHAR   lcr;

    //
    // compute the divsor
    //

    divisorlatch = CLOCK_RATE / Rate;

    //
    // set the divisor latch access bit (DLAB) in the line control reg
    //

    hwport = Port->Address;
    hwport += COM_LCR;                  // hwport = LCR register

    lcr = READ_UCHAR(hwport);

    lcr |= LC_DLAB;
    WRITE_UCHAR(hwport, lcr);

    //
    // set the divisor latch value.
    //

    hwport = Port->Address;
    hwport += COM_DLM;                  // divisor latch msb
    WRITE_UCHAR(hwport, (UCHAR)((divisorlatch >> 8) & 0xff));

    hwport--;                           // divisor latch lsb
    WRITE_UCHAR(hwport, (UCHAR)(divisorlatch & 0xff));

    //
    // Set LCR to 3.  (3 is a magic number in the original assembler)
    //

    hwport = Port->Address;
    hwport += COM_LCR;
    WRITE_UCHAR(hwport, 3);

    //
    // Remember the baud rate
    //

    Port->Baud = Rate;
    return;
}

USHORT
CpGetByte (
    PCPPORT Port,
    PUCHAR Byte,
    BOOLEAN WaitForByte,
    BOOLEAN PollOnly
    )

/*++

    Routine Description:

        Fetch a byte and return it.

    Arguments:

        Port - address of port object that describes hw port

        Byte - address of variable to hold the result

        WaitForByte - flag indicates wait for byte or not.

        PollOnly - flag indicates whether to return immediately, not reading the byte, or not.

    Return Value:

        CP_GET_SUCCESS if data returned, or if data is ready and PollOnly is TRUE.

        CP_GET_NODATA if no data available, but no error.

        CP_GET_ERROR if error (overrun, parity, etc.)

--*/

{

    UCHAR   lsr;
    ULONG   limitcount;

    //
    // Check to make sure the CPPORT we were passed has been initialized.
    // (The only time it won't be initialized is when the kernel debugger
    // is disabled, in which case we just return.)
    //

    if (Port->Address == NULL) {
        return CP_GET_NODATA;
    }

    limitcount = WaitForByte ? TIMEOUT_COUNT : 1;
    while (limitcount != 0) {
        limitcount--;

        lsr = CpReadLsr(Port, COM_DATRDY);
        if ((lsr & COM_DATRDY) == COM_DATRDY) {

            //
            // Check for errors
            //

            //
            // If we get an overrun error, and there is data ready, we should
            // return the data we have, so we ignore overrun errors.  Reading
            // the LSR clears this bit, so the first read already cleared the
            // overrun error.
            //
            if (lsr & (COM_FE | COM_PE)) {
                *Byte = 0;
                return CP_GET_ERROR;
            }

            if (PollOnly) {
                return CP_GET_SUCCESS;
            }

            //
            // fetch the byte
            //

            *Byte = READ_UCHAR(Port->Address + COM_DAT);
            if (Port->Flags & PORT_MODEMCONTROL) {

                //
                // Using modem control.  If no CD, then skip this byte.
                //

                if ((READ_UCHAR(Port->Address + COM_MSR) & MS_CD) == 0) {
                    continue;
                }
            }

            return CP_GET_SUCCESS;
        }
    }

    CpReadLsr(Port, 0);
    return CP_GET_NODATA;
}

VOID
CpPutByte (
    PCPPORT  Port,
    UCHAR   Byte
    )

/*++

    Routine Description:

        Write a byte out to the specified com port.

    Arguments:

        Port - Address of CPPORT object

        Byte - data to emit

--*/

{

    UCHAR   msr, lsr;

    //
    // If modem control, make sure DSR, CTS and CD are all set before
    // sending any data.
    //

    while ((Port->Flags & PORT_MODEMCONTROL)  &&
           (msr = READ_UCHAR(Port->Address + COM_MSR) & MS_DSRCTSCD) != MS_DSRCTSCD) {

        //
        // If no CD, and there's a charactor ready, eat it
        //

        lsr = CpReadLsr(Port, 0);
        if ((msr & MS_CD) == 0  && (lsr & COM_DATRDY) == COM_DATRDY) {
            READ_UCHAR(Port->Address + COM_DAT);
        }
    }

    //
    //  Wait for port to not be busy
    //

    while (!(CpReadLsr(Port, COM_OUTRDY) & COM_OUTRDY)) ;

    //
    // Send the byte
    //

    WRITE_UCHAR(Port->Address + COM_DAT, Byte);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\rdcomp.asm ===
IFDEF DBLSPACE_LEGAL
        page    ,130
        title   DeCompressor
;-----------------------------------------------------------------------
; Name: RDCOMP.ASM
;
; Routines defined:
;   Decompress32
;
; Description:
;   This file holds the code that is responsible for decompressing
;   the compressed data.
;
; VxD History:
;   22-Apr-93 jeffpar   Major adaptation and cleanup for MRCI32.386
;-----------------------------------------------------------------------

        .386p

        .xlist
;;        include vmm.inc
;;        include debug.inc
        include mdequ.inc
        .list

    MD_STAMP equ "SD"

;;;-----------------------------------------------------------------------
;;; Data segment
;;;-----------------------------------------------------------------------
;;
;;VxD_LOCKED_DATA_SEG
;;
;;        public  pLowerBound
;;pLowerBound     dd      0       ; if non-zero, then this is the lowest linear
;;                                ; address we treat as *our* error
;;        public  pUpperBound
;;pUpperBound     dd      0       ; if non-zero, then this is the highest linear
;;                                ; address we treat as *our* error (plus one)
;;        public  pPrevPgFltHdlr
;;pPrevPgFltHdlr  dd      0       ; if non-zero, addr of previous page fault hdlr
;;
;;VxD_LOCKED_DATA_ENDS
;;
;;
;;VxD_PAGEABLE_DATA_SEG
_DATA SEGMENT DWORD PUBLIC 'DATA'

        include decode.inc      ; include macros and tables used for decoding

        public  decode_data_end
decode_data_end label byte

;;VxD_PAGEABLE_DATA_ENDS
_DATA ENDS


;-----------------------------------------------------------------------
; Code segment
;-----------------------------------------------------------------------

;;VxD_PAGEABLE_CODE_SEG
_TEXT SEGMENT DWORD USE32 PUBLIC 'CODE'
      ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


        public  aCmdAt
aCmdAt  dd      CmdAt0,CmdAt1,CmdAt2,CmdAt3,CmdAt4,CmdAt5,CmdAt6,CmdAt7


;-----------------------------------------------------------------------
; Decompression Algorithm
; -----------------------
; Decode the next chunk of text in 'coding_buffer', into the buffer as
;  stated in the 'init'.
;
; Entry:
;   CLD
;   EBX == start of cluster (see  MRCI32IncDecompress!)
;   ECX == chunk count
;   ESI -> compressed data
;   EDI -> destination buffer
;   EDX == remaining data(low)/bits(high) from last call, 0 if none
;
; Exit:
;   If successful, CY clear and:
;   ESI == offset to next byte uncompressed data (if any)
;   EDI == offset to next free byte in dest buffer
;   EDX == remaining data(low)/bits(high) for next call, 0 if none
;
; Uses:
;   Everything except EBP
;-----------------------------------------------------------------------

;;BeginProc Decompress32
        public  Decompress32
Decompress32 proc near

        push    ebp
        push    ebp                     ; [esp] is our "chunk_count"

;;        push    ebx
        sub     ebx,MAX_12BIT_OFFSET    ;
;;        mov     [pLowerBound],ebx       ;
;;        pop     [pUpperBound]           ; fault handler enabled *now*

        mov     eax,edx                 ; remaining data to AX
        shr     edx,16                  ; move state to low word of EDX
        jnz     short @F                ; jump if continuing previous state
        lodsw                           ; new decompression, load initial data
@@:     mov     [esp],ecx               ; save chunk count

DecodeLoop:
;
;   AX has the remaining bits, DL has the next state
;
        mov     ebp,cbCHUNK             ; (ebp) is # bytes left this chunk
        DecodeRestart

        LastErrSJump equ <FirstErrSJump>
FirstErrSJump:  jmp     DecodeError     ; put first nice fat jump out of the way

irpc    c,<01234567>
        CmdAt   c
endm
        jmp     CmdAt0

irpc    c,<01234567>
        LengthAt c
endm

        DoGeneralLength                 ; generate code here to handle large lengths

DecodeDone:
;
;   AX has the remaining bits, DL has the next state -- check chunk status
;
        test    ebp,ebp                 ; perfect chunk-size decompression?
        jnz     DecodeCheckLast         ; no, check for last chunk

        dec     dword ptr [esp]         ; chunks remaining?
        jz      DecodeSuccess           ; no, so we're all done
        jmp     DecodeLoop              ; yes, process them

        public  DecodeError
DecodeError label near
        stc                             ; random decomp failure jump target
        jmp     short DecodeExit

DecodeCheckLast:
        dec     dword ptr [esp]         ; chunks remaining?
        jnz     DecodeError             ; yes, then we have an error

DecodeSuccess:
        mov     dh,1                    ; return non-0 EDX indicating state exists
        shl     edx,16                  ; move state to high word of EDX
        movzx   eax,ax                  ; make sure high word of EAX is clear
        or      edx,eax                 ; EDX == state (and carry is CLEAR)

DecodeExit:
;;        mov     [pUpperBound],0         ; fault handler disabled *now*
;;        mov     [pLowerBound],0         ;
        pop     ebp                     ; throw away our "chunk_count" at [esp]
        pop     ebp
        ret

;;EndProc Decompress32
        Decompress32 endp





;;VxD_PAGEABLE_CODE_ENDS
_TEXT ENDS

;;
;;VxD_LOCKED_CODE_SEG
;;
;;;-----------------------------------------------------------------------
;;; Decompress32_Page_Fault
;;; -----------------------
;;; Looks for VMM page faults caused by the decompressor.  The fault
;;; must have taken place in the range from [pLowerBound] to [pUpperBound]-1.
;;; If the fault IS in that range, then we set EIP to DecodeError.
;;;
;;; WARNING: this takes advantage of the fact that the decompressor does not
;;; use the stack;  otherwise, we would obviously need to record and re-set ESP
;;; to a known point as well.
;;;
;;; This is in locked code to insure that a subsequent fault doesn't destroy
;;; the information necessary to process the first (eg, CR2)!
;;;
;;; Entry:
;;;   EBX == VM handle
;;;   EBP -> VMM re-entrant stack frame
;;;
;;; Uses:
;;;   May use everything except SEG REGS
;;;-----------------------------------------------------------------------
;;
;;BeginProc Decompress32_Page_Fault
;;;
;;;   Note: the fall-through case is the common one (ie, not our page fault)
;;;
;;        push    eax
;;        mov     eax,cr2                 ; get faulting address
;;        cmp     eax,[pUpperBound]
;;        jb      short dpf_maybe         ; it might be ours
;;                                        ; otherwise, definitely not
;;dpf_prev:
;;        pop     eax                     ; we've been told to preserve everything
;;        jmp     [pPrevPgFltHdlr]        ; dispatch to real page fault handler
;;                                        ; (if we installed, then there *is* one)
;;dpf_maybe:
;;        cmp     eax,[pLowerBound]
;;        jb      short dpf_prev          ; not going to "fix" it
;;
;;        Trace_Out "Decompress32_Page_Fault: correcting fault on bad cluster"
;;
;;        mov     [ebp].Client_EIP,OFFSET32 DecodeError
;;        pop     eax
;;        ret                             ; we "fixed" it
;;
;;EndProc Decompress32_Page_Fault
;;
;;VxD_LOCKED_CODE_ENDS


;++
;
; ULONG
; DblsMrcfDecompress (
;     PUCHAR UncompressedBuffer,
;     ULONG UncompressedLength,
;     PUCHAR CompressedBuffer,
;     ULONG CompressedLength,
;     PMRCF_DECOMPRESS WorkSpace
;     )
;
; Routine Description:
;
;     This routine decompresses a buffer of StandardCompressed or MaxCompressed
;     data.
;
; Arguments:
;
;     UncompressedBuffer - buffer to receive uncompressed data
;
;     UncompressedLength - length of UncompressedBuffer
;
;           NOTE: UncompressedLength must be the EXACT length of the uncompressed
;                 data, as Decompress uses this information to detect
;                 when decompression is complete.  If this value is
;                 incorrect, Decompress may crash!
; 
;     CompressedBuffer - buffer containing compressed data
;
;     CompressedLength - length of CompressedBuffer
;
;     WorkSpace - pointer to a private work area for use by this operation
; 
; Return Value:
;
;     ULONG - Returns the size of the decompressed data in bytes. Returns 0 if
;         there was an error in the decompress.
;--

_TEXT SEGMENT DWORD USE32 PUBLIC 'CODE'
      ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        public  _DblsMrcfDecompress@20
_DblsMrcfDecompress@20 proc near

        push    esi
        push    edi
        push    ebx

        mov     ecx,dword ptr [esp+20]
        mov     edx,ecx
        shr     ecx,9
        and     edx,512-1    
        jz      @f
        inc     ecx
        sub     edx,edx
@@:     mov     esi,dword ptr [esp+24]
        mov     edi,dword ptr [esp+16]
        mov     ebx,edi

        cld
        lodsd
        cmp     ax,MD_STAMP
        je      @f
        sub     eax,eax
        jz      done

@@:     call    Decompress32
        jnc     @f
        sub     eax,eax
        jz      done    

@@:     sub     edi,dword ptr [esp+16]
        mov     eax,edi

done:
        pop     ebx
        pop     edi
        pop     esi

        ret     20

_DblsMrcfDecompress@20 endp

_TEXT ENDS
        ENDIF   ; DEF DBLSPACE_LEGAL
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\pae.asm ===
;++
;
;Copyright (c) 1998  Microsoft Corporation
;
;Module Name:
;
;    pae.asm
;
;Abstract:
;
;    Contains routines to aid in enabling PAE mode.
;
;Author:
;
;    Forrest Foltz (forrestf) 12-28-98
;
;
;Revision History:
;
;--


.586p
        .xlist
include ks386.inc
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

EFLAGS_ID	equ 	200000h

;++
;
; BOOLEAN
; BlpPaeSupported (
;     VOID
; )
;
; Routine Description:
;
;  	  This routine determines whether the CPU supports PAE mode
;
; Arguments:
;
;     None.
;
; Return value:
;
;     al == 1 if the CPU does support PAE mode.
;     al == 0 if not.
;
;--

public _BlpPaeSupported@0
_BlpPaeSupported@0 proc
	;
	; First determine whether the CPUID instruction is supported.  If
	; the EFLAGS_ID bit "sticks" when stored in the flags register, then
	; the CPUID instruction is supported.
	;

	mov	ecx, EFLAGS_ID
	pushfd
	pop	eax		; eax == flags
	xor	ecx, eax	; ecx == flags ^ EFLAGS_ID
	push	ecx
	popfd			; load new flags
	pushfd
	pop	ecx		; ecx == result of flag load
	xor	eax, ecx	; Q: did the EFLAGS_ID bit stick?
	jz	done            ; N: CPUID is not available

	;
	; We can use the CPUID instruction.
	;

	push	ebx		; CPUID steps on eax, ebx, ecx, edx
	mov	eax, 1
	cpuid
	pop	ebx

	;
	; edx contains the feature bits.  Bit 6 is the PAE extensions flag.
	;

	sub	eax, eax	; assume not set
	test	dl, 40h		; Q: bit 6 set?
	jz	done		; N: return with eax == 0
	inc	eax		; Y: set eax == 1
done:   ret

_BlpPaeSupported@0 endp

;++
;
; VOID
; BlSetPae (
;     IN ULONG IdentityAddress,
;     IN ULONG PaeCr3 
; )
;
; Routine Description:
;
;  Arguments:
;
;  Return
;
;--

public _BlpEnablePAE@4
_BlpEnablePAE@4 proc
public _BlpEnablePAEStart
_BlpEnablePAEStart label dword

	;
	; Load PDPT address
	;

	mov	edx, [esp]+4

	;
	; Do this to set the state machine in motion
	;

	mov	ecx, cr3
	mov	cr3, ecx

	;
	; Disable paging
	;

	mov	eax, cr0
	and	eax, NOT CR0_PG
	mov	cr0, eax
	jmp	$+2

	;
	; Enable physical address extensions
	;

	mov	eax, cr4
	or	eax, CR4_PAE

	;
	; The following instruction was necessary in order to boot some
	; machines.  Probably due to an errata.
	;

	mov	ecx, cr3
	mov	cr4, eax

	;
	; Point cr3 to the page directory pointer table
	; 

	mov	cr3, edx

	;
	; Enable paging
	;

	mov	ecx, cr0
	or	ecx, CR0_PG
	mov	cr0, ecx
	jmp	$+2

	;
	; Clean the stack and return
	;

	ret	4

public _BlpEnablePAEEnd
_BlpEnablePAEEnd label dword
_BlpEnablePAE@4 endp

_TEXT	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\oschoice\dcmpstub.c ===
#include "bldr.h"

VOID
DecompEnableDecompression(
    IN BOOLEAN Enable
    )
{
    UNREFERENCED_PARAMETER(Enable);

    return;
}


BOOLEAN
DecompGenerateCompressedName(
    IN  LPCSTR Filename,
    OUT LPSTR  CompressedName
    )
{
    UNREFERENCED_PARAMETER(Filename);
    UNREFERENCED_PARAMETER(CompressedName);

    //
    // Indicate that the caller shouldn't bother trying to locate
    // the compressed filename.
    //
    return(FALSE);
}


ULONG
DecompPrepareToReadCompressedFile(
    IN LPCSTR Filename,
    IN ULONG  FileId
    )
{
    UNREFERENCED_PARAMETER(Filename);
    UNREFERENCED_PARAMETER(FileId);

    //
    // No processing in osloader, only in setupldr.
    // Special return code of -1 takes care of this.
    //
    return((ULONG)(-1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\stubs.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    stubs.c

Abstract:

    This module implements stub routines for the boot code.

Author:

    David N. Cutler (davec) 7-Nov-1990

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ntos.h"
#include "bootx86.h"
#include "stdio.h"
#include "stdarg.h"

VOID
KeBugCheck (
    IN ULONG BugCheckCode
    )

/*++

Routine Description:

    This function crashes the system in a controlled manner.

Arguments:

    BugCheckCode - Supplies the reason for the bug check.

Return Value:

    None.

--*/

{

    //
    // Print out the bug check code and break.
    //

    BlPrint("\n*** BugCheck (%lx) ***\n\n", BugCheckCode);
    while(TRUE) {
    };
#if _MSC_VER < 1300
    return;
#endif
}

VOID
RtlAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{

    BlPrint( "\n*** Assertion failed %s in %s line %d\n",
            FailedAssertion,
            FileName,
            LineNumber );
    if (Message) {
        BlPrint(Message);
    }

    while (TRUE) {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\wake.c ===
/*++


Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    wake.c

Abstract:


Author:

    Ken Reneris

Environment:

    Kernel Mode


Revision History:

    Steve Deng (sdeng) 20-Aug-2002 

        Add support for PAE and Amd64. It is assumed that all the 
        physical pages are below 4GB. Otherwise hibernation feature 
        should be disabled.


--*/

#include "arccodes.h"
#include "bootx86.h"


extern PHARDWARE_PTE PDE;
extern PHARDWARE_PTE HalPT;
extern ULONG HiberNoMappings;
extern BOOLEAN HiberIoError;
extern ULONG HiberLastRemap;
extern BOOLEAN HiberOutOfRemap;
extern UCHAR BlpEnablePAEStart;
extern UCHAR BlpEnablePAEEnd;
extern UCHAR BlAmd64SwitchToLongModeStart;
extern UCHAR BlAmd64SwitchToLongModeEnd;

PVOID  HiberTransVa;
ULONG64 HiberTransVaAmd64;
ULONG HiberCurrentMapIndex;

#define PDE_SHIFT             22
#define PTE_SHIFT             12
#define PTE_INDEX_MASK        0x3ff

#define PDPT_SHIFT_X86PAE     30
#define PDE_SHIFT_X86PAE      21
#define PTE_SHIFT_X86PAE      12
#define PDE_INDEX_MASK_X86PAE 0x1ff
#define PTE_INDEX_MASK_X86PAE 0x1ff

VOID
HiberSetupForWakeDispatchPAE (
    VOID
    );

VOID
HiberSetupForWakeDispatchX86 (
    VOID
    );

VOID
HiberSetupForWakeDispatchAmd64 (
    VOID
    );


PVOID
HbMapPte (
    IN ULONG    PteToMap,
    IN ULONG    Page
    )
{
    PVOID       Va;

    Va = (PVOID) (HiberVa + (PteToMap << PAGE_SHIFT));
    HbSetPte (Va, HiberPtes, PteToMap, Page);
    return Va;
}


PVOID
HbNextSharedPage (
    IN ULONG    PteToMap,
    IN ULONG    RealPage
    )
/*++

Routine Description:

    Allocates the next available page in the free and
    maps the Hiber pte to the page.   The allocated page
    is put onto the remap list

Arguments:

    PteToMap    - Which Hiber PTE to map

    RealPage    - The page to enter into the remap table for
                  this allocation

Return Value:

    Virtual address of the mapping

--*/

{
    PULONG      MapPage;
    PULONG      RemapPage;
    ULONG       DestPage;
    ULONG       i;

    MapPage = (PULONG) (HiberVa + (PTE_MAP_PAGE << PAGE_SHIFT));
    RemapPage = (PULONG) (HiberVa + (PTE_REMAP_PAGE << PAGE_SHIFT));

    //
    // Loop until we find a free page which is not in
    // use by the loader image, then map it
    //

    while (HiberCurrentMapIndex < HiberNoMappings) {
        DestPage = MapPage[HiberCurrentMapIndex];
        HiberCurrentMapIndex += 1;

        i = HbPageDisposition (DestPage);
        if (i == HbPageInvalid) {
            HiberIoError = TRUE;
            return HiberBuffer;
        }

        if (i == HbPageNotInUse) {

            MapPage[HiberLastRemap] = DestPage;
            RemapPage[HiberLastRemap] = RealPage;
            HiberLastRemap += 1;
            HiberPageFrames[PteToMap] = DestPage;
            return HbMapPte(PteToMap, DestPage);
        }
    }

    HiberOutOfRemap = TRUE;
    return HiberBuffer;
}


VOID
HbAllocatePtes (
     IN ULONG NumberPages,
     OUT PVOID *PteAddress,
     OUT PVOID *MappedAddress
     )
/*++

Routine Description:

    Allocated a consecutive chuck of Ptes.

Arguments:

    NumberPage      - Number of ptes to allocate

    PteAddress      - Pointer to the first PTE

    MappedAddress   - Base VA of the address mapped


--*/
{
    ULONG i;
    ULONG j;

    //
    // We use the HAL's PDE for mapping.  Find enough free PTEs
    //

    for (i=0; i<=1024-NumberPages; i++) {
        for (j=0; j < NumberPages; j++) {
            if ((((PULONG)HalPT))[i+j]) {
                break;
            }
        }

        if (j == NumberPages) {
            *PteAddress = (PVOID) &HalPT[i];
            *MappedAddress = (PVOID) (0xffc00000 | (i<<12));
            return ;
        }
        i += j;
    }
    BlPrint("NoMem");
    while (1);
}


VOID
HbSetPte (
    IN PVOID Va,
    IN PHARDWARE_PTE Pte,
    IN ULONG Index,
    IN ULONG PageNumber
    )
/*++

Routine Description:

    Sets the Pte to the corresponding page address

Arguments:

    Va         - the virtual address of the physical page described by PageNumber

    Pte        - the base address of Page Table 

    Index      - the index into Page Table

    PageNumber - the page frame number of the pysical page to be mapped

Return:

    None

--*/
{
    Pte[Index].PageFrameNumber = PageNumber;
    Pte[Index].Valid = 1;
    Pte[Index].Write = 1;
    Pte[Index].WriteThrough = 0;
    Pte[Index].CacheDisable = 0;
    _asm {
        mov     eax, Va
        invlpg  [eax]
    }
}

VOID
HbMapPagePAE(
    PHARDWARE_PTE_X86PAE HbPdpt,
    PVOID VirtualAddress,
    ULONG PageFrameNumber
    )

/*++

Routine Description:

    This functions maps a virtural address into PAE page mapping structure.

Arguments:

    HbPdpt - Supplies the base address of Page Directory Pointer Table.

    VirtualAddress - Supplies the virtual address to map

    PageFrameNumber - Supplies the physical page number to map the address to

Return:

    None

--*/
{
    ULONG index;
    PHARDWARE_PTE_X86PAE HbPde, HbPte;

    //
    // If the PDPT entry is empty, allocate a new page for it.
    // Otherwise we simply map the page at this entry.
    //

    index = ((ULONG) VirtualAddress) >> PDPT_SHIFT_X86PAE;
    if(HbPdpt[index].Valid) {
        HbPde = HbMapPte (PTE_TRANSFER_PDE, (ULONG)(HbPdpt[index].PageFrameNumber));

    } else {

        HbPde = HbNextSharedPage(PTE_TRANSFER_PDE, 0);
        RtlZeroMemory (HbPde, PAGE_SIZE);
        HbPdpt[index].PageFrameNumber = HiberPageFrames[PTE_TRANSFER_PDE];
        HbPdpt[index].Valid = 1;
    }

    //
    // If the PDE entry is empty, allocate a new page for it.
    // Otherwise we simply map the page at this entry.
    //

    index = (((ULONG) VirtualAddress) >> PDE_SHIFT_X86PAE) & PDE_INDEX_MASK_X86PAE;  
    if(HbPde[index].Valid) {
        HbPte = HbMapPte (PTE_WAKE_PTE, (ULONG)(HbPde[index].PageFrameNumber));

    } else {

        HbPte = HbNextSharedPage(PTE_WAKE_PTE, 0);
        RtlZeroMemory (HbPte, PAGE_SIZE);
        HbPde[index].PageFrameNumber = HiberPageFrames[PTE_WAKE_PTE];
        HbPde[index].Write = 1;
        HbPde[index].Valid = 1;
    }

    //
    // Locate the PTE of VirtualAddress and set it to PageFrameNumber
    //

    index = (((ULONG) VirtualAddress) >> PTE_SHIFT_X86PAE) & PDE_INDEX_MASK_X86PAE;
    HbPte[index].PageFrameNumber = PageFrameNumber;
    HbPte[index].Write = 1;
    HbPte[index].Valid = 1;
}


VOID
HiberSetupForWakeDispatch (
    VOID
    ) 
{
    if(BlAmd64UseLongMode) {

        //
        // if system was hibernated in long mode 
        //

        HiberSetupForWakeDispatchAmd64();

    } else {

        if(BlUsePae) {

            //
            // if system was hibernated in pae mode
            //

            HiberSetupForWakeDispatchPAE();

        } else {

            //
            // if system was hibernated in 32-bit x86 mode
            //

            HiberSetupForWakeDispatchX86();
        } 
    }
}


VOID
HiberSetupForWakeDispatchX86 (
    VOID
    )
{
    PHARDWARE_PTE       HbPde;
    PHARDWARE_PTE       HbPte;
    PHARDWARE_PTE       WakePte;
    PHARDWARE_PTE       TransVa;
    ULONG               TransPde;
    ULONG               WakePde;
    ULONG               PteEntry;

    //
    // Allocate a transistion CR3.  A page directory and table which
    // contains the hibernation PTEs
    //

    HbPde = HbNextSharedPage(PTE_TRANSFER_PDE, 0);
    HbPte = HbNextSharedPage(PTE_WAKE_PTE, 0);          // TRANSFER_PTE, 0);

    RtlZeroMemory (HbPde, PAGE_SIZE);
    RtlZeroMemory (HbPte, PAGE_SIZE);

    //
    // Set PDE to point to PTE
    //

    TransPde = ((ULONG) HiberVa) >> PDE_SHIFT;
    HbPde[TransPde].PageFrameNumber = HiberPageFrames[PTE_WAKE_PTE];
    HbPde[TransPde].Write = 1;
    HbPde[TransPde].Valid = 1;

    //
    // Fill in the hiber PTEs
    //

    PteEntry = (((ULONG) HiberVa) >> PTE_SHIFT) & PTE_INDEX_MASK;
    TransVa = &HbPte[PteEntry];
    RtlCopyMemory (TransVa, HiberPtes, HIBER_PTES * sizeof(HARDWARE_PTE));

    //
    // Make another copy at the Va of the wake image hiber ptes
    //

    WakePte = HbPte;
    WakePde = ((ULONG) HiberIdentityVa) >> PDE_SHIFT;
    if (WakePde != TransPde) {
        WakePte = HbNextSharedPage(PTE_WAKE_PTE, 0);
        HbPde[WakePde].PageFrameNumber = HiberPageFrames[PTE_WAKE_PTE];
        HbPde[WakePde].Write = 1;
        HbPde[WakePde].Valid = 1;
    }

    PteEntry = (((ULONG) HiberIdentityVa) >> PTE_SHIFT) & PTE_INDEX_MASK;
    TransVa = &WakePte[PteEntry];

    RtlCopyMemory (TransVa, HiberPtes, HIBER_PTES * sizeof(HARDWARE_PTE));

    //
    // Set TransVa to be relative to the va of the transfer Cr3
    //

    HiberTransVa = (PVOID)  (((PUCHAR) TransVa) - HiberVa + (PUCHAR) HiberIdentityVa);
}

VOID
HiberSetupForWakeDispatchPAE (
    VOID
    )

/*++

Routine Description:

    Set up memory mappings for wake dispatch routine. This mapping will 
    be used in a "transfer mode" in which the mapping of loader has 
    already been discarded and the mapping of OS is not restored yet. 

    For PAE systems, PAE is enabled before entering this "transfer mode".

Arguments:

    None

Return:

    None

--*/
{

    PHARDWARE_PTE_X86PAE HbPdpt;
    ULONG i, TransferCR3;

    //
    // Borrow the pte at PTE_SOURCE temporarily for Pdpt 
    //

    HbPdpt = HbNextSharedPage(PTE_SOURCE, 0);
    RtlZeroMemory (HbPdpt, PAGE_SIZE);
    TransferCR3 = HiberPageFrames[PTE_SOURCE];

    //
    // Map in the pages where the code of BlpEnablePAE() resides.
    // This has to be a 1-1 mapping, i.e. the value of virtual 
    // address is the same as the value of physical address
    //

    HbMapPagePAE( HbPdpt, 
                  (PVOID)(&BlpEnablePAEStart), 
                  (ULONG)(&BlpEnablePAEStart) >> PAGE_SHIFT);

    HbMapPagePAE( HbPdpt, 
                  (PVOID)(&BlpEnablePAEEnd), 
                  (ULONG)(&BlpEnablePAEEnd) >> PAGE_SHIFT);

    //  
    //  Map in the pages that is reserved for hibernation use
    //  

    for (i = 0; i < HIBER_PTES; i++) {
        HbMapPagePAE( HbPdpt, 
                      (PUCHAR)HiberVa + PAGE_SIZE * i, 
                      (*((PULONG)(HiberPtes) + i) >> PAGE_SHIFT));
    }

    for (i = 0; i < HIBER_PTES; i++) {
        HbMapPagePAE( HbPdpt, 
                      (PUCHAR)HiberIdentityVa + PAGE_SIZE * i, 
                      (*((PULONG)(HiberPtes) + i) >> PAGE_SHIFT));
    }


    //
    // Update the value of HiberPageFrames[PTE_TRANSFER_PDE] to the 
    // TransferCR3. The wake dispatch function will read this entry
    // for the CR3 value in transfer mode
    //

    HiberPageFrames[PTE_TRANSFER_PDE] = TransferCR3;

    //
    // HiberTransVa points to the PTEs reserved for hibernation code. 
    // HiberTransVa is similar to HiberPtes but it is relative to 
    // transfer Cr3
    // 

    HiberTransVa = (PVOID)((PUCHAR) HiberIdentityVa + 
                           (PTE_WAKE_PTE << PAGE_SHIFT) + 
                           sizeof(HARDWARE_PTE_X86PAE) * 
                           (((ULONG_PTR)HiberIdentityVa >> PTE_SHIFT_X86PAE) & PTE_INDEX_MASK_X86PAE));
}


#define AMD64_MAPPING_LEVELS 4

typedef struct _HB_AMD64_MAPPING_INFO {
    ULONG PteToUse;
    ULONG AddressMask;
    ULONG AddressShift;
} CONST HB_AMD64_MAPPING_INFO, *PHB_AMD64_MAPPING_INFO;

HB_AMD64_MAPPING_INFO HbAmd64MappingInfo[AMD64_MAPPING_LEVELS] =
{
   { PTE_WAKE_PTE,     0x1ff, 12 },
   { PTE_TRANSFER_PDE, 0x1ff, 21 },
   { PTE_DEST,         0x1ff, 30 },
   { PTE_SOURCE,       0x1ff, 39 }
};

#define _HARDWARE_PTE_WORKING_SET_BITS  11
typedef struct _HARDWARE_PTE_AMD64 {
    ULONG64 Valid : 1;
    ULONG64 Write : 1;                // UP version
    ULONG64 Owner : 1;
    ULONG64 WriteThrough : 1;
    ULONG64 CacheDisable : 1;
    ULONG64 Accessed : 1;
    ULONG64 Dirty : 1;
    ULONG64 LargePage : 1;
    ULONG64 Global : 1;
    ULONG64 CopyOnWrite : 1;          // software field
    ULONG64 Prototype : 1;            // software field
    ULONG64 reserved0 : 1;            // software field
    ULONG64 PageFrameNumber : 28;
    ULONG64 reserved1 : 24 - (_HARDWARE_PTE_WORKING_SET_BITS+1);
    ULONG64 SoftwareWsIndex : _HARDWARE_PTE_WORKING_SET_BITS;
    ULONG64 NoExecute : 1;
} HARDWARE_PTE_AMD64, *PHARDWARE_PTE_AMD64;

VOID
HbMapPageAmd64(
    PHARDWARE_PTE_AMD64 RootLevelPageTable,
    ULONGLONG VirtualAddress,
    ULONG PageFrameNumber
    )

/*++

Routine Description:

    This functions maps a virtural address into Amd64 page mapping structure.

Arguments:

    RootLevelPageTable - Supplies the base address of Page-Map Level-4 Table.

    VirtualAddress - Supplies the virtual address to map

    PageFrameNumber - Supplies the physical page number to be mapped

Return:

    None

--*/
{

    LONG  i;
    ULONG index, PteToUse;
    PHARDWARE_PTE_AMD64 PageTable, PageTableTmp;

    PageTable = RootLevelPageTable;
    
    //
    // Build a 4-level mapping top-down
    //

    for(i = AMD64_MAPPING_LEVELS - 1; i >= 0; i--) {
        index = (ULONG)((VirtualAddress >> HbAmd64MappingInfo[i].AddressShift) & 
                         HbAmd64MappingInfo[i].AddressMask);

        if (i > 0) {
            PteToUse = HbAmd64MappingInfo[i-1].PteToUse;

            if (PageTable[index].Valid) {

                //
                // If a page table entry is valid we simply map the page 
                // at it and go to the next mapping level.
                //

                PageTable = HbMapPte(PteToUse, 
                                     (ULONG)PageTable[index].PageFrameNumber);
            } else {

                //
                // If a page entry is invalid, we allocate a new page 
                // from the free page list and reference the new page 
                // from this page entry.
                //

                PageTableTmp = HbNextSharedPage(PteToUse, 0);
                PageTable[index].PageFrameNumber = HiberPageFrames[PteToUse];
                PageTable[index].Valid = 1;
                PageTable[index].Write = 1;
                RtlZeroMemory (PageTableTmp, PAGE_SIZE);
                PageTable = PageTableTmp;
            }

        } else {

            //
            // Now we come to the PTE level. Set this PTE entry to the
            // target page frame number.
            //

            PageTable[index].PageFrameNumber = PageFrameNumber;
            PageTable[index].Valid = 1;
            PageTable[index].Write = 1;
        }
    }
}

VOID
HiberSetupForWakeDispatchAmd64(
    VOID
    ) 

/*++

Routine Description:

    This function prepares memory mapping for the transition period
    where neither loader's nor kernel's mapping is available. The 
    processor runs in long mode in transition period. 

    We'll create mapping for the following virtual addresses

      - the code handles long mode switch
      - loader's HiberVa
      - wake image's HiberVa
    
Arguments:

    None

Return:

    None

--*/

{
    PHARDWARE_PTE_AMD64 HbTopLevelPTE;
    ULONG i;
    ULONG TransferCR3;

    //
    // Borrow the pte at PTE_SOURCE for temporary use here
    //

    HbTopLevelPTE = HbNextSharedPage(PTE_SOURCE, 0);
    RtlZeroMemory (HbTopLevelPTE, PAGE_SIZE);
    TransferCR3 = HiberPageFrames[PTE_SOURCE];

    //
    // Map in the pages that is holding thee code of _BlAmd64SwitchToLongMode.
    // This has to be a 1-1 mapping, i.e. the virtual address equals physical 
    // address
    //

    HbMapPageAmd64(
        HbTopLevelPTE,
        (ULONGLONG)(&BlAmd64SwitchToLongModeStart), 
        (ULONG)(&BlAmd64SwitchToLongModeStart) >> PAGE_SHIFT);

    HbMapPageAmd64(
        HbTopLevelPTE,
        (ULONGLONG)(&BlAmd64SwitchToLongModeEnd), 
        (ULONG)(&BlAmd64SwitchToLongModeEnd) >> PAGE_SHIFT);

    //  
    // Map in the loader's HiberVa 
    //  

    for (i = 0; i < HIBER_PTES; i++) {
        HbMapPageAmd64(HbTopLevelPTE, 
                       (ULONGLONG)((ULONG_PTR)HiberVa + PAGE_SIZE * i), 
                       (*((PULONG)(HiberPtes) + i) >> PAGE_SHIFT));
    }

    //  
    // Map in the wake image's HiberVa. Note that the hiber pte at 
    // PTE_WAKE_PTE will be set to the the right value as a result 
    // of this mapping.
    //  

    for (i = 0; i < HIBER_PTES; i++) {
        HbMapPageAmd64(HbTopLevelPTE, 
                      HiberIdentityVaAmd64 + PAGE_SIZE * i, 
                      (*((PULONG)(HiberPtes) + i) >> PAGE_SHIFT));
    }

    //
    // Update the value of HiberPageFrames[PTE_TRANSFER_PDE] to the 
    // TransferCR3. The wake dispatch function will read this entry
    // for the CR3 value in transition mode
    //

    HiberPageFrames[PTE_TRANSFER_PDE] = TransferCR3;

    //
    // HiberTransVaAmd64 points to the wake image's hiber ptes. It is
    // is relative to transfer Cr3
    // 

    HiberTransVaAmd64 = HiberIdentityVaAmd64 + 
                        (PTE_WAKE_PTE << PAGE_SHIFT) + 
                        sizeof(HARDWARE_PTE_AMD64) * ((HiberIdentityVaAmd64 >> HbAmd64MappingInfo[0].AddressShift) & HbAmd64MappingInfo[0].AddressMask);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\xsum.asm ===
.xlist
 include xsum.x86
 .list
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\wake64.asm ===
ifdef _X86AMD64_
include ..\amd64\wake64.asm
endif

    END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\wakea.asm ===
;++
;
;Copyright (c) 1997  Microsoft Corporation
;
;Module Name:
;
;    wakea.asm
;
;Abstract:
;
;
;Author:
;
;   Ken Reneris (kenr) 05-May-1997
;
;Revision History:
;
;   Steve Deng (sdeng) 20-Aug-2002 
;
;       Support hibernation in PAE mode. It is assumed that all the 
;       physical pages are below 4GB. Otherwise hibernation feature 
;       should be disabled.
;--


.586p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list
        extrn   _HiberPtes:DWORD
        extrn   _HiberVa:DWORD
        extrn   _HiberFirstRemap:DWORD
        extrn   _HiberLastRemap:DWORD
        extrn   _HiberPageFrames:DWORD
        extrn   _HiberTransVa:DWORD
        extrn   _HiberIdentityVa:DWORD
        extrn   _HiberImageFeatureFlags:DWORD
        extrn   _HiberBreakOnWake:BYTE
        extrn   _HiberImagePageSelf:DWORD
        extrn   _BlUsePae:DWORD
        extrn   _HiberNoExecute:DWORD
        EXTRNP  _BlpEnablePAE,1


DBGOUT  macro   Value
;        push    edx
;        push    eax
;        mov     edx, 80h
;        mov     al, Value
;        out     dx, al
;        pop     eax
;        pop     edx
endm

; These equates must match the defines in po.h

XPRESS_MAX_PAGES        equ     16


;
; These equates must match the defines in bldr.h
;

PTE_SOURCE              equ     0
PTE_DEST                equ     1
PTE_MAP_PAGE            equ     2
PTE_REMAP_PAGE          equ     3
PTE_HIBER_CONTEXT       equ     4
PTE_TRANSFER_PDE        equ     5
PTE_WAKE_PTE            equ     6
PTE_DISPATCHER_START    equ     7
PTE_XPRESS_DEST_FIRST   equ     9
PTE_XPRESS_DEST_LAST    equ     (PTE_XPRESS_DEST_FIRST + XPRESS_MAX_PAGES)
HIBER_PTES              equ     (16 + XPRESS_MAX_PAGES)


;
; Processor paging defines
;

PAGE_SIZE           equ     4096
PAGE_SHIFT          equ     12
PAGE_MASK           equ     (PAGE_SIZE - 1)
PTE_VALID           equ     23h

PDPT_SHIFT_PAE      equ     30
PDE_SHIFT_PAE       equ     21
PTE_SHIFT_PAE       equ     12
PDE_INDEX_MASK_PAE  equ     1ffh
PTE_INDEX_MASK_PAE  equ     1ffh

PDE_SHIFT           equ     22
PTE_SHIFT           equ     12
PTE_INDEX_MASK      equ     3ffh


;
;   Internal defines and structures
;

STACK_SIZE          equ     1024

HbGdt struc
    Limit           dw      ?
    Base            dd      ?
    Pad             dw      ?
HbGdt ends


HbContextBlock struc
    WakeContext     db      processorstatelength dup (?)
    OldEsp          dd      ?
    PteVa           dd      ?
    TransCr3        dd      ?
    TransPteVa      dd      ?
    WakeHiberVa     dd      ?
    Buffer          dd      ?
    MapIndex        dd      ?
    LastMapIndex    dd      ?
    FeatureFlags    dd      ?
    BlUsePae        dd      ?
    NoExecute       dd      ?
    Gdt             db      size HbGdt dup (?)
    Stack           db      STACK_SIZE dup (?)
    BufferData      db      ?       ; buffer starts here
HbContextBlock ends


;
; Addresses based from ebp
;

SourcePage          equ     [ebp + PAGE_SIZE * PTE_SOURCE]
DestPage            equ     [ebp + PAGE_SIZE * PTE_DEST]
Map                 equ     [ebp + PAGE_SIZE * PTE_MAP_PAGE]
Remap               equ     [ebp + PAGE_SIZE * PTE_REMAP_PAGE]
Context             equ     [ebp + PAGE_SIZE * PTE_HIBER_CONTEXT].HbContextBlock



_TEXT   SEGMENT PARA PUBLIC 'CODE'       ; Start 32 bit code
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; WakeDispatch (
; )
;
; Routine Description:
;
;   Relocatable code which copies any remap page to it's final resting
;   place and then restores the processors wake context.
;
;  Arguments:
;
;  Return
;
;   Only returns if there's an internal failure
;
;--


cPublicProc _WakeDispatcher, 0
        public  _WakeDispatcherStart
_WakeDispatcherStart   label   dword

        push    ebp
        push    ebx
        push    esi
        push    edi

;
; Load EBP with base of hiber va.  Everything will be relative from EBP
;

        mov     ebp, _HiberVa

;
; Initialize HbContextBlock
;

        mov     eax, _HiberFirstRemap
        mov     ecx, _HiberLastRemap
        lea     edx, Context.BufferData
        mov     esi, _HiberPtes
        mov     Context.MapIndex, eax
        mov     Context.LastMapIndex, ecx
        mov     Context.OldEsp, esp
        mov     Context.Buffer, edx
        mov     Context.PteVa, esi

        mov     eax, _HiberPageFrames [PTE_TRANSFER_PDE * 4]
        mov     ecx, _HiberTransVa
        mov     edx, _HiberIdentityVa
        mov     esi, _BlUsePae
        mov     Context.TransCr3, eax
        mov     Context.TransPteVa, ecx
        mov     Context.WakeHiberVa, edx
        mov     Context.BlUsePae, esi

        mov     eax, _HiberImageFeatureFlags
        mov     ecx, _HiberNoExecute
        mov     Context.FeatureFlags, eax
        mov     Context.NoExecute, ecx

        DBGOUT  1

;
; Copy gdt to shared buffer and switch to it
;

        sgdt    fword ptr Context.Gdt
        movzx   ecx, Context.Gdt.Limit
        inc     ecx
        push    ecx
        call    AllocateHeap
        pop     ecx

        mov     edi, eax
        mov     esi, Context.Gdt.Base
        rep movsb

        mov     Context.Gdt.Base, eax
        lgdt    fword ptr Context.Gdt

        sub     eax, ebp
        add     eax, Context.WakeHiberVa
        mov     Context.Gdt.Base, eax

;
; Locate hiber ptes in hibernated image.  First get the PDE, then find
; the PTE for the hiber ptes.
;

        mov     eax, dword ptr Context.WakeContext.PsSpecialRegisters.SrCr3
        shr     eax, PAGE_SHIFT
        call    LocatePage
        push    eax
        push    PTE_SOURCE
        call    SetPte

        cmp     Context.BlUsePae, 0             ; check if it is to restore to PAE mode 
        jnz     short @f                        ; 

        mov     ecx, Context.WakeHiberVa
        shr     ecx, PDE_SHIFT                  ; (ecx) = index into PDE

        mov     eax, [eax+ecx*4]                ; (eax) = PDE for WakeHiberVa PTE
        shr     eax, PAGE_SHIFT

        call    LocatePage
        push    eax
        push    PTE_SOURCE
        call    SetPte

        mov     ecx, Context.WakeHiberVa
        shr     ecx, PTE_SHIFT
        and     ecx, PTE_INDEX_MASK             ; (ecx) = index into PTE

        lea     edi, [eax+ecx*4]                ; (edi) = address of WakeHiber PTEs

        jmp     short hd02

@@:     mov     ecx, dword ptr Context.WakeContext.PsSpecialRegisters.SrCr3
        and     ecx, 0fe0h                      ; (ecx) = offset to page boundary
                                                ; note in PAE mode Cr3 is aligned 
                                                ; to 32-byte, not page, boundary  
        add     eax, ecx                        ; (eax) = base address of PDPT
        mov     ecx, Context.WakeHiberVa
        shr     ecx, PDPT_SHIFT_PAE             ; (ecx) = index into PDPT
        mov     eax, [eax+ecx*8]                ; (eax) = PDPT entry for WakeHiberVa PDE
        shr     eax, PAGE_SHIFT                 ; (eax) = page frame number

        call    LocatePage                      ; locate the page described by (eax)
        push    eax                             ; (eax) = page number located
        push    PTE_SOURCE
        call    SetPte                          ; map this page

        mov     ecx, Context.WakeHiberVa
        shr     ecx, PDE_SHIFT_PAE               
        and     ecx, PDE_INDEX_MASK_PAE         ; (ecx) = index into PDE

        mov     eax, [eax+ecx*8]                ; (eax) = PDE for WakeHiberVa PTE
        shr     eax, PAGE_SHIFT                 ; (eax) = page frame number

        call    LocatePage                      ; locate the page described by (eax)
        push    eax                             ; (eax) = page number located
        push    PTE_SOURCE
        call    SetPte                          ; map this page

        mov     ecx, Context.WakeHiberVa
        shr     ecx, PTE_SHIFT_PAE
        and     ecx, PTE_INDEX_MASK_PAE         ; (ecx) = index into PTE

        lea     edi, [eax+ecx*8]                ; (edi) = address of WakeHiber PTEs

;
; Copy the current HiberPtes to the wake image Ptes
;

hd02:   mov     esi, Context.PteVa
        mov     ecx, HIBER_PTES
        xor     eax, eax
        cmp     Context.BlUsePae, 0           ; check if OS was in PAE mode
        jnz     short @f
        rep movsd
        jmp     short hd04  

@@:     movsd                                 ; translate 32bit pte to PAE pte
        stosd                                 ; assuming memory size is <= 4GB
        loopnz  @b                            ; so that the high dword of PAE 
                                              ; pte is set to 0 
;
; If break on wake, set the image header signature in destionation
;

hd04:   cmp     _HiberBreakOnWake, 0
        jz      short hd05

        mov     eax, _HiberImagePageSelf
        call    LocatePage
        push    eax
        push    PTE_DEST
        call    SetPte
        mov     dword ptr [eax], 706B7262h      ; 'brkp'
;
; Switch to transition CR3
;
hd05:

        DBGOUT  2

        mov     ebx, Context.WakeHiberVa
        mov     eax, Context.TransCr3
        shl     eax, PAGE_SHIFT

        cmp     _BlUsePae, 1                    ; check if OS was in PAE mode
        jnz     short @f 
        lea     esp, Context.Stack + STACK_SIZE ; move stack to safe place
        push    eax                             ; (eax) = the physical address of PDPT
        mov     eax, _BlpEnablePAE@4
        call    dword ptr eax                   ; switch to PAE mode
        cmp     Context.NoExecute, 1            ; check if no-execute was enabled
        jnz     short hd08                      ; if not do nothing
        mov     ecx, 0c0000080h                 ; (ecx) = address of EFER
        rdmsr                                   ; read EFER
        or      eax, 800h                       ; set NXE bit of EFER
        wrmsr                                   ; write EFER
        jmp     hd08

@@:     mov     cr3, eax                        ; switch to transition Cr3 in non PAE case


;
; Move to wake images hiber va
;

hd08:   mov     edi, ebx
        add     ebx, PTE_DISPATCHER_START * PAGE_SIZE
        add     ebx, offset hd10 - offset _WakeDispatcherStart
        jmp     ebx
hd10:   mov     ebp, edi
        mov     eax, Context.TransPteVa
        mov     Context.PteVa, eax
        lea     esp, Context.Stack + STACK_SIZE
        lgdt    fword ptr Context.Gdt

;
; Copy all pages to final locations
;

        DBGOUT  3
        lea     ebx, [ebp + PTE_DISPATCHER_START * PAGE_SIZE]
        cmp     Context.BlUsePae, 0
        jnz     hd20
        add     ebx, offset SetPte - offset _WakeDispatcherStart 
        jmp     hd25
hd20:   add     ebx, offset SetPtePAE - offset _WakeDispatcherStart

hd25:   mov     edx, Context.MapIndex
hd30:   cmp     edx, Context.LastMapIndex
        jnc     short hd40

        push    dword ptr Map.[edx*4]
        push    PTE_SOURCE
        
        call    ebx 
        mov     esi, eax

        push    dword ptr Remap.[edx*4]     
        push    PTE_DEST
        
        call    ebx    
        mov     edi, eax
        mov     ecx, PAGE_SIZE / 4
        rep movsd                           

        inc     edx
        jmp     short hd30

;
; Restore processors wake context
;

hd40:   DBGOUT  5
        lea     esi, Context.WakeContext.PsSpecialRegisters

        mov     eax, cr3                    ; issue a couple of flushes
        mov     cr3, eax                    ; before enabling global ptes
        mov     cr3, eax

        mov     eax, [esi].SrCr4
        test    Context.FeatureFlags, KF_CR4
        jz      short hd50

        mov     cr4, eax
hd50:   mov     eax, [esi].SrCr3

        mov     cr3, eax
        mov     ecx, [esi].SrCr0
        mov     cr0, ecx                    ; on kernel's cr0

        DBGOUT  6

        mov     ecx, [esi].SrGdtr+2         ; base of GDT
        lgdt    fword ptr [esi].SrGdtr      ; load gdtr (w/matching flat cs & ds selectors)
        lidt    fword ptr [esi].SrIdtr      ; load idtr
        lldt    word ptr [esi].SrLdtr       ; load ldtr

        movzx   eax, word ptr [esi].SrTr    ; tss selector

        and     byte ptr [eax+ecx+5], 0fdh  ; clear the busy bit in the TSS
        ltr     ax                          ; load tr

        mov     ds, word ptr Context.WakeContext.PsContextFrame.CsSegDs
        mov     es, word ptr Context.WakeContext.PsContextFrame.CsSegEs
        mov     fs, word ptr Context.WakeContext.PsContextFrame.CsSegFs
        mov     gs, word ptr Context.WakeContext.PsContextFrame.CsSegGs
        mov     ss, word ptr Context.WakeContext.PsContextFrame.CsSegSs

        mov     ebx, dword ptr Context.WakeContext.PsContextFrame.CsEbx
        mov     ecx, dword ptr Context.WakeContext.PsContextFrame.CsEcx
        mov     edx, dword ptr Context.WakeContext.PsContextFrame.CsEdx
        mov     edi, dword ptr Context.WakeContext.PsContextFrame.CsEdi
        mov     esp, dword ptr Context.WakeContext.PsContextFrame.CsEsp

        push    dword ptr Context.WakeContext.PsContextFrame.CsEFlags
        movzx   eax, word ptr Context.WakeContext.PsContextFrame.CsSegCs
        push    eax
        push    dword ptr Context.WakeContext.PsContextFrame.CsEip

        push    dword ptr Context.WakeContext.PsContextFrame.CsEbp
        push    dword ptr Context.WakeContext.PsContextFrame.CsEsi
        push    dword ptr Context.WakeContext.PsContextFrame.CsEax

        lea     esi, Context.WakeContext.PsSpecialRegisters.SrKernelDr0
        lodsd
        mov     dr0, eax                    ; load dr0-dr7
        lodsd
        mov     dr1, eax
        lodsd
        mov     dr2, eax
        lodsd
        mov     dr3, eax
        lodsd
        mov     dr6, eax
        lodsd
        mov     dr7, eax

        DBGOUT  7

        pop     eax
        pop     esi
        pop     ebp
        iretd

; this exit is only used in the shared buffer overflows
Abort:
        mov     esp, Context.OldEsp
        pop     edi
        pop     esi
        pop     ebx
        pop     ebp
        stdRET  _WakeDispatcher


;++
;
; PUCHAR
; AllocateHeap (
;    IN ULONG Length            passed in ECX
;    )
;
; Routine Description:
;
;   Allocates the specified bytes from the wake context page.
;
;   N.B. This function is part of HiberDispacther.
;
;  Arguments:
;   ECX     - Length to allocate
;
;  Returns:
;   EAX     - Virtual address of bytes allocated
;
;  Uses:
;   EAX, ECX, EDX
;
;--

AllocateHeap  label   proc
        mov     eax, Context.Buffer
        mov     edx, eax
        test    eax, 01fh           ; round to 32 byte boundry
        jz      short ah20
        and     eax, not 01fh
        add     eax, 20h
ah20:   add     ecx, eax
        mov     Context.Buffer, ecx
        xor     ecx, edx
        and     ecx, 0ffffffffh - PAGE_MASK
        jnz     short Abort
        ret

;++
;
; PUCHAR
; SetPte (
;    IN ULONG   PteIndex
;    IN ULONG   PageFrameNumber
;    )
;
; Routine Description:
;
;
;   N.B. This function is part of HiberDispacther.
;
;  Arguments:
;
;
;  Returns:
;   EAX va of mapped pte
;
;  Uses:
;   EAX, ECX
;
;--

SetPte label    proc
        push    ecx
        mov     eax, [esp+8]                ; (eax) =  pte index

        shl     eax, 2                      ; * 4
        add     eax, Context.PteVa          ; + pte base

        mov     ecx, [esp+12]               ; (ecx) = page frame number
        shl     ecx, PAGE_SHIFT
        or      ecx, PTE_VALID
        mov     [eax], ecx                  ; set the Pte

        mov     eax, [esp+8]
        shl     eax, PAGE_SHIFT
        add     eax, ebp                    ; (eax) = va mapped by pte
        invlpg  [eax]
        pop     ecx
        ret     8

;++
;
; PUCHAR
; SetPtePAE (
;    IN ULONG   PteIndex
;    IN ULONG   PageFrameNumber
;    )
;
; Routine Description:
;
;   This function maps a physical page into PAE mapping structure. The 
;   mapping is done on a supplied pte entry. 
; 
;   N.B. This function is part of HiberDispacther.
;
; Arguments:
;
;   PteIndex        - Specify a PTE in HiberPtes list  
;
;   PageFrameNumber - the page frame number of the page to be mapped
;
; Returns:
;
;   EAX - va of mapped pte
;
; Uses:
;
;   EAX, ECX
;
;--

SetPtePAE label    proc
        push    ecx
        mov     eax, [esp+8]                ; (eax) =  pte index

        shl     eax, 3                      ; * 8
        add     eax, Context.PteVa          ; + pte base

        mov     ecx, [esp+12]               ; (ecx) = page frame number
        shl     ecx, PAGE_SHIFT
        or      ecx, PTE_VALID
        mov     [eax], ecx                  ; set the low dword of PAE Pte
        mov     dword ptr [eax+4], 0        ; assuming the high dword is always 0

        mov     eax, [esp+8]                ; (eax) =  pte index
        shl     eax, PAGE_SHIFT               
        add     eax, ebp                    ; (eax) = va mapped by pte
        invlpg  [eax]
        pop     ecx
        ret     8

;++
;
; ULONG
; LocatePage (
;    IN ULONG PageNumber        passed in eax
;    )
;
; Routine Description:
;
;   Find the page specified by page number in the wake context.
;   The pagenumber must be a valid page.
;
;   N.B. This function is part of HiberDispacther.
;
;  Arguments:
;
;   EAX  - Page frame number of the page we try to locate.
;
;  Returns:
;
;   EAX  - Page frame number of the page which is holding the content
;          of the page of interest. This number could be different from 
;          the incomming page number if the requested page is in the 
;          remap list.
;
;  Uses:
;
;   EAX, EDX
;
;--

LocatePage label    proc

;
; Scan the remap entries for this page.  If it's found, get the
; source address.  If it's not found, then it's already at it's
; proper address
;
        mov     edx, Context.MapIndex
        dec     edx

lp10:   inc     edx
        cmp     edx, Context.LastMapIndex
        jnc     short lp20

        cmp     eax, Remap.[edx*4]
        jnz     short lp10

        mov     eax, Map.[edx*4]
lp20:   ret

        public  _WakeDispatcherEnd
_WakeDispatcherEnd   label   dword
stdENDP _WakeDispatcher

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\oschoice\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

!IF "$(BUILD_DEBUG_LOADER)" != ""
DBG_LDR=_dbg
!ELSE
DBG_LDR=
!ENDIF

#
# BOOT_LIB_DIR is the relative path to boot.lib.
#
!IFNDEF BOOT_LIB_DIR
BOOT_LIB_DIR=daytona$(DBG_LDR)
!ENDIF

$(O)\msg.mc : ..\msg.$(LANGUAGE)
    copy $** $@

!IF $(386)

OSLOADER_LIBS=\
    $(O)\oscldr.lib \
    $(O)\oschoice.res \
    $(PROJECT_ROOT)\boot\lib\$(BOOT_LIB_DIR)\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\bd\daytona$(DBG_LDR)\$(O)\bd.lib \
    $(PROJECT_ROOT)\boot\tftplib\$(O)\tftplib.lib \
    $(PROJECT_ROOT)\boot\bootssp\boot\$(O)\bootssp.lib \
    $(PROJECT_ROOT)\ntos\ke\up\$(O)\ke.lib \
    $(PROJECT_ROOT)\ntos\rtl\boot$(DBG_LDR)\$(O)\bldrrtl$(DBG_LDR).lib \
    $(PROJECT_ROOT)\ntos\config\boot\$(O)\bconfig.lib \
    $(SDK_LIB_PATH)\libcntpr.lib \
    $(DS_LIB_PATH)\rsa32.lib

$(O)\oschoice.res: $(O)\msg.mc

OSLOADER_LIB_COMPONENTS = \
    $(PROJECT_ROOT)\boot\lib\$(BOOT_LIB_DIR)\$(O)\boot.lib \
    $(O)\oscldr.lib

$(O)\link.rsp : ..\makefile.inc
    type << > $@
-base:0x300000
-debug
-entry:NtProcessStartup@4
-fixed
-incremental:no
-map
-machine:ix86
-opt:ref
-opt:icf
-subsystem:native
$(LINK_LIB_IGNORE_FLAG)
$(OSLOADER_LIBS)
<<NOKEEP

$(O)\oschoice.lib: $(OSLOADER_LIB_COMPONENTS)
    $(LIB_NAME) -machine:i386 -out:$(O)\oschoice.lib $(OSLOADER_LIB_COMPONENTS) -ignore:4001

LDR_NAME=oschoice$(DBG_LDR).exe

$(O)\$(LDR_NAME): $(OSLOADER_LIBS) makefile.inc $(O)\link.rsp
    -$(LINK_NAME) -out:$@ @$(O)\link.rsp 

!ELSE IF $(IA64)

OSLOADER_LIBS=\
    $(O)\oscldr.lib \
    $(O)\oschoice.res \
    $(PROJECT_ROOT)\boot\lib\daytona$(DBG_LDR)\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\bd\daytona$(DBG_LDR)\$(O)\bd.lib \
    $(PROJECT_ROOT)\boot\efi\daytona$(DBG_LDR)\$(O)\efi.lib \
    $(PROJECT_ROOT)\boot\tftplib\$(O)\tftplib.lib \
    $(PROJECT_ROOT)\boot\bootssp\boot\$(O)\bootssp.lib \
    $(PROJECT_ROOT)\ntos\ke\up\$(O)\ke.lib \
    $(PROJECT_ROOT)\ntos\rtl\boot$(DBG_LDR)\$(O)\bldrrtl$(DBG_LDR).lib \
    $(PROJECT_ROOT)\ntos\config\boot\$(O)\bconfig.lib \
    $(SDK_LIB_PATH)\libcntpr.lib \
    $(DS_LIB_PATH)\rsa32.lib

                
$(O)\link.rsp : ..\makefile.inc
    type << > $@
-subsystem:EFI_APPLICATION
-nodefaultlib
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-machine:IA64
-base:0x1040000
!IF "$(BUILD_DEBUG_LOADER)" != ""
-fixed
!ENDIF
-opt:ref
-opt:icf
-entry:main
-map
-ignore:4049,4001,4217
$(LINK_LIB_IGNORE_FLAG)
$(OSLOADER_LIBS)
<<NOKEEP

$(O)\oschoice.res: $(O)\msg.mc

$(O)\oschoice$(DBG_LDR).efi: $(OSLOADER_LIBS) makefile.inc $(O)\link.rsp
    -$(LINK_NAME) -out:$@ @$(O)\link.rsp

$(O)\oschoice.dbg: $(O)\oschoice.efi
    -pe2dbg $? $@


OSLOADER_LIB_COMPONENTS = \
    $(PROJECT_ROOT)\boot\lib\daytona$(DBG_LDR)\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\efi\daytona$(DBG_LDR)\$(O)\efi.lib \
    $(O)\oscldr.lib

$(O)\oschoice.lib: $(OSLOADER_LIB_COMPONENTS)
    $(LIB_NAME) -machine:ia64 -out:$(O)\oschoice.lib $(OSLOADER_LIB_COMPONENTS) -ignore:4001
    

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\oschoice\oscheap.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    oscheap.c

Abstract:

    This module contains "local" heap management code for OS Chooser.

Author:

    Geoff Pease (gpease) May 28 1998

Revision History:

--*/

#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

#include "netfs.h"
#include "oscheap.h"

#define FREE_POOL_TAG 0x0
#define ALLOC_POOL_TAG 0x1

typedef struct _LOCAL_MEMORY_DESCRIPTOR {

    //
    // We create a union to make sure that this struct is always at least the size of a 
    // pointer, and thus will be pointer aligned.
    //
    union {

        struct {
            ULONG Tag;
            ULONG Size;
        };

        struct {
            void *Align;
        };

    };

} LOCAL_MEMORY_DESCRIPTOR, *PLOCAL_MEMORY_DESCRIPTOR;


//
// Variable for holding our memory together.
//
#ifdef EFI
#define OSCHEAPSIZE 0x4000 // 16k
#else
#define OSCHEAPSIZE 0x2000 // 8k
#endif
CHAR OscHeap[ OSCHEAPSIZE ];

//
// Functions
//
void
OscHeapInitialize(
    VOID
    )
/*++

Routine Description:

    This routine initializes the internal memory management system.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PLOCAL_MEMORY_DESCRIPTOR LocalDescriptor;

    LocalDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)OscHeap;

    LocalDescriptor->Tag = FREE_POOL_TAG;
    LocalDescriptor->Size = OSCHEAPSIZE - sizeof(LOCAL_MEMORY_DESCRIPTOR);

    memset((PVOID)(LocalDescriptor + 1), 0, LocalDescriptor->Size);
}

PCHAR
OscHeapAlloc( 
    IN UINT iSize 
    )

/*++

Routine Description:

    This routine allocates memory from our internal structures.

Arguments:

    iSize - Number of bytes the client wants.
    
Return Value:

    A pointer to the allocated block if successful, else NULL

--*/

{
    PLOCAL_MEMORY_DESCRIPTOR LocalDescriptor;
    PLOCAL_MEMORY_DESCRIPTOR NextDescriptor;
    LONG ThisBlockSize;
    ULONG BytesToAllocate;

    //
    // Always allocate in increments of a pointer, minmally.
    //
    if (iSize & (sizeof(void *) - 1)) {
        iSize += sizeof(void *) - (iSize & (sizeof(void *) - 1));
    }

    LocalDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)OscHeap;
    ThisBlockSize = OSCHEAPSIZE - sizeof(LOCAL_MEMORY_DESCRIPTOR);

    while (ThisBlockSize > 0) {

        if ((LocalDescriptor->Tag == FREE_POOL_TAG) && 
            (LocalDescriptor->Size >= iSize)) {
                
            goto FoundBlock;
        }

        ThisBlockSize -= (LocalDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR));
        LocalDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)LocalDescriptor) + 
                                                     LocalDescriptor->Size +
                                                     sizeof(LOCAL_MEMORY_DESCRIPTOR)
                                                     );
    }

    //
    // There is no memory block big enough to hold the request.
    //
    return NULL;
    
FoundBlock:

    //
    // Jump to here when a memory descriptor of the right size has been found.  It is expected that
    // LocalDescriptor points to the correct block.
    //
    if (LocalDescriptor->Size > iSize + sizeof(LOCAL_MEMORY_DESCRIPTOR)) {

        //
        // Make a descriptor of the left over parts of this block.
        //
        NextDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)LocalDescriptor) + 
                                                    sizeof(LOCAL_MEMORY_DESCRIPTOR) +
                                                    iSize
                                                   );

        NextDescriptor->Tag = FREE_POOL_TAG;
        NextDescriptor->Size = (ULONG)(LocalDescriptor->Size - iSize - sizeof(LOCAL_MEMORY_DESCRIPTOR));
        LocalDescriptor->Size = (ULONG)iSize;

    }

    LocalDescriptor->Tag = ALLOC_POOL_TAG;

    memset((LocalDescriptor+1), 0, iSize);

    return (PCHAR)(LocalDescriptor + 1);

}

PCHAR
OscHeapFree(
    IN PCHAR Pointer
    )

/*++


Routine Description:

    This routine frees a block previously allocated from the internal memory management system.

Arguments:

    Pointer - A pointer to free.

Return Value:

    NULL.

--*/

{
    LONG ThisBlockSize;
    PLOCAL_MEMORY_DESCRIPTOR LocalDescriptor;
    PLOCAL_MEMORY_DESCRIPTOR PrevDescriptor;
    PLOCAL_MEMORY_DESCRIPTOR ThisDescriptor;

    LocalDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)Pointer) - sizeof(LOCAL_MEMORY_DESCRIPTOR));

    //
    // Find the memory block in the heap
    //
    PrevDescriptor = NULL;
    ThisDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)OscHeap;
    ThisBlockSize = OSCHEAPSIZE - sizeof(LOCAL_MEMORY_DESCRIPTOR);

    while (ThisBlockSize > 0) {
            
        if (ThisDescriptor == LocalDescriptor) {
            goto FoundBlock;
        }

        ThisBlockSize -= (ThisDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR));
            
        PrevDescriptor = ThisDescriptor;
        ThisDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)ThisDescriptor) + 
                                                    ThisDescriptor->Size +
                                                    sizeof(LOCAL_MEMORY_DESCRIPTOR)
                                                   );
    }

    return NULL;

FoundBlock:

    //
    // Jump to here when the proper memory descriptor has been found.
    //
    
    if (LocalDescriptor->Tag == FREE_POOL_TAG) {
        //
        // Ouch! We tried to free something twice, skip it before bad things happen.
        //
        return NULL;
    }

    LocalDescriptor->Tag = FREE_POOL_TAG;

    //
    // If possible, merge this memory block with the next one.
    //
    if ((ULONG)ThisBlockSize > (LocalDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR))) {
        ThisDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)LocalDescriptor) + 
                                                    LocalDescriptor->Size +
                                                    sizeof(LOCAL_MEMORY_DESCRIPTOR)
                                                   );
        if (ThisDescriptor->Tag == FREE_POOL_TAG) {
            LocalDescriptor->Size += ThisDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR);
            ThisDescriptor->Tag = 0;
            ThisDescriptor->Size = 0;
        }

    }

    //
    // Now see if we can merge this block with a previous block.
    //
    if ((PrevDescriptor != NULL) && (PrevDescriptor->Tag == FREE_POOL_TAG)) {
        PrevDescriptor->Size += LocalDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR);
        LocalDescriptor->Tag = 0;
        LocalDescriptor->Size = 0;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\i386\xxioacc.asm ===
title  "ix ioaccess"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixioacc.asm
;
; Abstract:
;
;    Procedures to correctly touch I/O registers.
;
; Author:
;
;    Bryan Willman (bryanwi) 16 May 1990
;
; Environment:
;
;    User or Kernel, although privledge (IOPL) may be required.
;
; Revision History:
;
;--

.386p
        include callconv.inc
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; I/O port space read and write functions.
;
;  These have to be actual functions on the 386, because we need
;  to use assembler, but cannot return a value if we inline it.
;
;  This set of functions manipulates I/O registers in PORT space.
;  (Uses x86 in and out instructions)
;
;  WARNING: Port addresses must always be in the range 0 to 64K, because
;           that's the range the hardware understands.
;
;--



;++
;
;   UCHAR
;   READ_PORT_UCHAR(
;       PUCHAR  Port
;       )
;
;   Arguments:
;       (esp+4) = Port
;
;   Returns:
;       Value in Port.
;
;--
cPublicProc  _READ_PORT_UCHAR,1

        mov     dx,[esp+4]              ; (dx) = Port
        in      al,dx
        stdRET  _READ_PORT_UCHAR

stdENDP _READ_PORT_UCHAR

;++
;
;   USHORT
;   READ_PORT_USHORT(
;       PUSHORT Port
;       )
;
;   Arguments:
;       (esp+4) = Port
;
;   Returns:
;       Value in Port.
;
;--
cPublicProc  _READ_PORT_USHORT,1

        mov     dx,[esp+4]             ; (dx) = Port
        in      ax,dx
        stdRET  _READ_PORT_USHORT

stdENDP _READ_PORT_USHORT



;++
;
;   ULONG
;   READ_PORT_ULONG(
;       PULONG  Port
;       )
;
;   Arguments:
;       (esp+4) = Port
;
;   Returns:
;       Value in Port.
;
;--
cPublicProc  _READ_PORT_ULONG,1

        mov     dx,[esp+4]             ; (dx) = Port
        in      eax,dx
        stdRET  _READ_PORT_ULONG

stdENDP _READ_PORT_ULONG



;++
;
;   VOID
;   READ_PORT_BUFFER_UCHAR(
;       PUCHAR  Port,
;       PUCHAR  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc  _READ_PORT_BUFFER_UCHAR,3

        mov     dx,[esp+4]              ; (dx) = Port
        mov     ecx,[esp+12]            ; (ecx) = transfer count
        push    edi
        mov     edi,[esp+12]            ; (edi) = (esp+8+push) = buffer
    rep insb
        pop     edi
        stdRET  _READ_PORT_BUFFER_UCHAR

stdENDP _READ_PORT_BUFFER_UCHAR


;++
;
;   VOID
;   READ_PORT_BUFFER_USHORT(
;       PUSHORT Port,
;       PUSHORT Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc  _READ_PORT_BUFFER_USHORT,3

        mov     dx,[esp+4]              ; (dx) = Port
        mov     ecx,[esp+12]            ; (ecx) = transfer count
        push    edi
        mov     edi,[esp+12]            ; (edi) = (esp+8+push) = buffer
    rep insw
        pop     edi
        stdRET  _READ_PORT_BUFFER_USHORT

stdENDP _READ_PORT_BUFFER_USHORT


;++
;
;   VOID
;   READ_PORT_BUFFER_ULONG(
;       PULONG  Port,
;       PULONG  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc  _READ_PORT_BUFFER_ULONG,3

        mov     dx,[esp+4]              ; (dx) = Port
        mov     ecx,[esp+12]            ; (ecx) = transfer count
        push    edi
        mov     edi,[esp+12]            ; (edi) = (esp+8+push) = buffer
    rep insd
        pop     edi
        stdRET  _READ_PORT_BUFFER_ULONG

stdENDP _READ_PORT_BUFFER_ULONG



;++
;
;   VOID
;   WRITE_PORT_UCHAR(
;       PUCHAR  Port,
;       UCHAR   Value
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Value
;
;--
cPublicProc  _WRITE_PORT_UCHAR,2

        mov     dx,[esp+4]              ; (dx) = Port
        mov     al,[esp+8]              ; (al) = Value
        out     dx,al
        stdRET  _WRITE_PORT_UCHAR

stdENDP _WRITE_PORT_UCHAR



;++
;
;   VOID
;   WRITE_PORT_USHORT(
;       PUSHORT Port,
;       USHORT  Value
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Value
;
;--
cPublicProc  _WRITE_PORT_USHORT,2

        mov     dx,[esp+4]              ; (dx) = Port
        mov     ax,[esp+8]              ; (ax) = Value
        out     dx,ax
        stdRET  _WRITE_PORT_USHORT

stdENDP _WRITE_PORT_USHORT



;++
;
;   VOID
;   WRITE_PORT_ULONG(
;       PULONG  Port,
;       ULONG   Value
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Value
;
;--
cPublicProc  _WRITE_PORT_ULONG,2

        mov     dx,[esp+4]              ; (dx) = Port
        mov     eax,[esp+8]             ; (eax) = Value
        out     dx,eax
        stdRET  _WRITE_PORT_ULONG

stdENDP _WRITE_PORT_ULONG



;++
;
;   VOID
;   WRITE_PORT_BUFFER_UCHAR(
;       PUCHAR  Port,
;       PUCHAR  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc  _WRITE_PORT_BUFFER_UCHAR,3

        mov     dx,[esp+4]              ; (dx) = Port
        mov     ecx,[esp+12]            ; (ecx) = transfer count
        push    esi
        mov     esi,[esp+12]            ; (esi) = (esp+8+push) = buffer
    rep outsb
        pop     esi
        stdRET  _WRITE_PORT_BUFFER_UCHAR

stdENDP _WRITE_PORT_BUFFER_UCHAR


;++
;
;   VOID
;   WRITE_PORT_BUFFER_USHORT(
;       PUSHORT Port,
;       PUSHORT Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc  _WRITE_PORT_BUFFER_USHORT,3

        mov     dx,[esp+4]              ; (dx) = Port
        mov     ecx,[esp+12]            ; (ecx) = transfer count
        push    esi
        mov     esi,[esp+12]            ; (esi) = (esp+8+push) = buffer
    rep outsw
        pop     esi
        stdRET _WRITE_PORT_BUFFER_USHORT

stdENDP _WRITE_PORT_BUFFER_USHORT


;++
;
;   VOID
;   WRITE_PORT_BUFFER_ULONG(
;       PULONG  Port,
;       PULONG  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc  _WRITE_PORT_BUFFER_ULONG,3

        mov     dx,[esp+4]              ; (dx) = Port
        mov     ecx,[esp+12]            ; (ecx) = transfer count
        push    esi
        mov     esi,[esp+12]            ; (esi) = (esp+8+push) = buffer
    rep outsd
        pop     esi
        stdRET _WRITE_PORT_BUFFER_ULONG

stdENDP _WRITE_PORT_BUFFER_ULONG


_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\oschoice\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\oschoice\oscheap.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    oscheap.c

Abstract:

    This module contains "local" heap management code for OS Chooser.

Author:

    Geoff Pease (gpease) May 28 1998

Revision History:

--*/

#ifndef __OSCHEAP_H__
#define __OSCHEAP_H__

#ifndef UINT
#define UINT unsigned int
#endif // UINT

void
OscHeapInitialize( );

PCHAR
OscHeapAlloc( 
    IN UINT iSize 
    );

PCHAR
OscHeapFree(
    IN PCHAR pMemory 
    );


#endif // __OSCHEAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\oschoice\daytona_dbg\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\oschoice\parse.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    parse.c

Abstract:

    This module contains UI code for the OS chooser

Author:

    Adam Barr (adamba) 15-May-1997

Revision History:

    Geoff Pease (GPease) 28 May 1998 - Major Overhaul to "OSCML" parser

--*/

#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif


#include "ctype.h"
#include "stdio.h"
#include "string.h"
#include <netfs.h>
#include "oscheap.h"
#include "parse.h"
#include "hdlsterm.h"


#if 0 && DBG==1
#define _TRACE_FUNC_
#endif

#ifdef _TRACE_FUNC_
#define TraceFunc( _func)  { \
    CHAR FileLine[80]; \
    sprintf( FileLine, "%s(%u)", __FILE__, __LINE__ ); \
    DPRINT( OSC, ("%-55s: %s", FileLine, _func) ); \
}
#else
#define TraceFunc( _func )
#endif

#define SCREEN_TOP 2
#ifdef EFI
#define SCREEN_BOTTOM 24
#else
#define SCREEN_BOTTOM 25
#endif

// Special translated character codes
#define CHAR_NBSP       ((CHAR)255)

#define MAX_INPUT_BUFFER_LENGTH 1024

#define PRINT(s,l)  { ULONG privCount; ArcWrite(BlConsoleOutDeviceId, (s), (l), &privCount); }
#define PRINTL(s)  { ULONG privCount; ArcWrite(BlConsoleOutDeviceId, (s), _tcslen(s), &privCount); }

#define BLINK_RATE 5
#define BRACKETS   4    // left and right brackets w/one space each

#define CT_TEXT     0x1
#define CT_PASSWORD 0x2
#define CT_RESET    0x4
#define CT_SELECT   0x8
#define CT_OPTION   0x10
#define CT_LOCAL    0x20
#define CT_VARIABLE 0x40

enum ENCODETYPE {
    ET_NONE = 0,
    ET_OWF
};

typedef struct {
    enum ACTIONS Action;
    PCHAR ScreenName;
} KEY_RESPONSE, *LPKEY_RESPONSE;


typedef struct {
    void * Next;
    enum CONTROLTYPE Type;
} CONTROLSTRUCT, *LPCONTROLSTRUCT;

typedef struct {
    void * Next;
    int  Type;
    enum ENCODETYPE Encoding;
    int   Size;
    int   MaxLength;
    int   X;
    int   Y;
    int   CurrentPosition;
    int   FirstVisibleChar;
    PCHAR Name;
    PCHAR Value;
} INPUTSTRUCT, *LPINPUTSTRUCT;

enum OPTIONFLAGS {
    OF_MULTIPLE = 0x01,
    OF_SELECTED = 0x02,
};

typedef struct {
    void * Next;
    enum CONTROLTYPE Type;
    enum OPTIONFLAGS Flags;
    PCHAR Value;
    PCHAR Displayed;
    PCHAR Tip;
    PCHAR EndTip;
} OPTIONSTRUCT, * LPOPTIONSTRUCT;

typedef struct {
    void * Next;
    enum CONTROLTYPE Type;
    enum OPTIONFLAGS Flags;
    int  Size;
    int  X;
    int  Y;
    int  Width;
    int  Timeout;
    BOOLEAN AutoSelect;
    PCHAR Name;
    LPOPTIONSTRUCT FirstVisibleSelection;
    LPOPTIONSTRUCT CurrentSelection;
} SELECTSTRUCT, * LPSELECTSTRUCT;

typedef struct {
    int X;
    int Y;
    int LeftMargin;
    int RightMargin;
    int Size;
} TIPAREA, *LPTIPAREA;

extern const CHAR rghex[];  // "0123456789ABCDEF"

//
// Current Screen Paramaters
//
PCHAR ScreenAttributes;
static CHAR WhiteOnBlueAttributes[] = ";44;37m"; // normal text, white on blue
static CHAR BlackOnBlackAttributes[] = ";40;40m"; // normal text, black on black
int   ScreenX;
int   ScreenY;
int   ScreenBottom;
int   LeftMargin;
int   RightMargin;
LPKEY_RESPONSE EnterKey;
LPKEY_RESPONSE EscKey;
LPKEY_RESPONSE F1Key;
LPKEY_RESPONSE F3Key;
BOOLEAN PreformattedMode;
BOOLEAN LoginScreen;
BOOLEAN AutoEnter;
BOOLEAN InsertMode;
void * ScreenControls;
enum ACTIONS SpecialAction;
LPTIPAREA TipArea;

#if defined(PLEASE_WAIT)
PCHAR PleaseWaitMsg;
#endif

// 80 spaces, for padding out menu bar highlights.
static TCHAR SpaceString[] =
TEXT("                                                                                ");

//
// used to track the type of authentication we should try.
//
ULONG AuthenticationType;

VOID
RomDumpRawData (
    IN PUCHAR DataStart,
    IN ULONG DataLength,
    IN ULONG Offset
    );

//
// From regboot.c -- Column and Row are 1-based
//

VOID
BlpPositionCursor(
    IN ULONG Column,
    IN ULONG Row
    );

VOID
BlpClearScreen(
    VOID
    );
//
// End from regboot.c
//



//
// Gets an integer, using PrevLoc and CurLoc as in BlProcessScreen.
//
UINT
GetInteger(
    PCHAR * InputString
    )
{
    UINT uint;
    PCHAR psz;

    TraceFunc( "BlpGetInteger()\n" );

    uint = 0;
    psz = *InputString;

    while ((*psz >= '0') && (*psz <= '9')) {
        uint = (uint*10) + *psz - '0';
        ++psz;
    }
    *InputString = psz;

    //DPRINT( OSC, ("Integer: '%u'\n", tmpInteger) );
    return uint;
}



#ifdef EFI
BlpShowCursor(
    IN BOOLEAN ShowCursor,
    IN TCHAR UnderCharacter
    )
{
    //bugbug handle "under character"
    BlEfiEnableCursor(ShowCursor);

}

VOID
BlpSendEscape(
    PCHAR Escape
    )
/*++

Routine Description:

    Sends an escape to the screen.

Arguments:

    None

Return Value:

    None.

--*/

{   
    BlEfiSetAttribute(DEFATT);
    BlEfiSetInverseMode(FALSE);
}


VOID
BlpSendEscapeReverse(
    PCHAR Escape
    )
/*++

Routine Description:

    Sends an escape to the screen that reverses the foreground and
    background colors of the Escape sequence. All special codes are
    retained (codes not in the ranges of 30-37 and 40-47).

Arguments:

    Escape - the escape sequence string.

Return Value:

    None.

--*/

{
    BlEfiSetAttribute(INVATT);
}

VOID
BlpSendEscapeBold(
    PCHAR Escape
    )
/*++

Routine Description:

    Sends an escape to the screen with the additional inverse code.

Arguments:

    None

Return Value:

    None.

--*/

{
    NOTHING;
}

VOID
BlpSendEscapeFlash(
    PCHAR Escape
    )
/*++

Routine Description:

    Sends an escape to the screen with the additional flash code.

Arguments:

    None

Return Value:

    None.

--*/

{
    NOTHING; //there is no flash attribute available under EFI.
}


#else

VOID
BlpSendEscape(
    PCHAR Escape
    )
/*++

Routine Description:

    Sends an escape to the screen.

Arguments:

    None

Return Value:

    None.

--*/

{
    TCHAR Buffer[16];
    ULONG Count;

#ifdef _TRACE_FUNC_
    TraceFunc("BlpSendEscape( ");
    DPRINT( OSC, ("Escape='%s' )\n", Escape) );
#endif

#ifdef UNICODE
    _stprintf(Buffer, TEXT("%s%S"), ASCI_CSI_OUT, Escape);
#else
    _stprintf(Buffer, TEXT("%s%s"), ASCI_CSI_OUT, Escape);
#endif

    PRINTL(Buffer);
}


VOID
BlpSendEscapeReverse(
    PCHAR Escape
    )
/*++

Routine Description:

    Sends an escape to the screen that reverses the foreground and
    background colors of the Escape sequence. All special codes are
    retained (codes not in the ranges of 30-37 and 40-47).

Arguments:

    Escape - the escape sequence string.

Return Value:

    None.

--*/

{
    TCHAR Buffer[20];
    PCHAR CurLoc = Escape;
    int   Color;

#ifdef _TRACE_FUNC_
    TraceFunc( "BlpSendEscapeReverse( " );
    DPRINT( OSC, ("Escape='%s' )\n", Escape) );
#endif

    if ( Escape == NULL ) {
        return; // abort
    }

    _tcscpy( Buffer, ASCI_CSI_OUT );

    //
    // Pre-pend the inverse video string for a vt100 terminal
    //
    if (BlIsTerminalConnected()) {
        _stprintf(Buffer, TEXT("%s7"), Buffer);
    }

    while ( *CurLoc && *CurLoc != 'm' ) {
        if ( !( *CurLoc >= '0' && *CurLoc <= '9' ) ) {
            CurLoc++;
        }

        Color = GetInteger( &CurLoc );

        if ( Color >=30 && Color <= 37) {
            Color += 10;
        } else if ( Color >= 40 && Color <= 47 ) {
            Color -= 10;
        }

        _stprintf( Buffer, TEXT("%s;%u"), Buffer, Color );
    }

    //
    // Add trailing 'm'
    //
    _stprintf( Buffer, TEXT("%sm"), Buffer );

    PRINTL( Buffer );
}

VOID
BlpSendEscapeBold(
    PCHAR Escape
    )
/*++

Routine Description:

    Sends an escape to the screen with the additional inverse code.

Arguments:

    None

Return Value:

    None.

--*/

{
    TCHAR Buffer[20];

#ifdef _TRACE_FUNC_
    TraceFunc( "BlpSendEscapeBold( " );
    DPRINT( OSC, ("Escape='%s' )\n", Escape) );
#endif

    _stprintf(Buffer, TEXT("%s;1%s"), ASCI_CSI_OUT, Escape);
    PRINTL(Buffer);
}

VOID
BlpSendEscapeFlash(
    PCHAR Escape
    )
/*++

Routine Description:

    Sends an escape to the screen with the additional flash code.

Arguments:

    None

Return Value:

    None.

--*/

{
    TCHAR Buffer[20];

#ifdef _TRACE_FUNC_
    TraceFunc( "BlpSendEscapeFlash( " );
    DPRINT( OSC, ("Escape='%s' )\n", Escape) );
#endif

    _stprintf(Buffer, TEXT("%s;5%s"), ASCI_CSI_OUT, Escape);
    PRINTL(Buffer);
}

//
// BlpShowCursor( )
//
VOID
BlpShowCursor(
    IN BOOLEAN ShowCursor,
    IN TCHAR UnderCharacter )
{
    TCHAR Buffer[20];
    
    if (ShowCursor) {   
        if(InsertMode){
            _stprintf(Buffer,TEXT("5%s"),ScreenAttributes);
            BlpSendEscapeReverse(Buffer);
        }
        else{
            _stprintf(Buffer,TEXT("5%s"),ScreenAttributes);
            BlpSendEscape(Buffer);
        }
    } else {
        _stprintf(Buffer,TEXT("0%s"),ScreenAttributes);
        BlpSendEscape(Buffer);
    }

    if (UnderCharacter) {
        PRINT( &UnderCharacter, sizeof(TCHAR));
    } else {
        if((InsertMode == FALSE )&& ShowCursor){
            PRINT(TEXT("_"),sizeof(TCHAR));
            return;
        }
        if(ShowCursor){
            PRINT(TEXT(""),sizeof(TCHAR));
            return;
        }
        PRINT(TEXT(" "),sizeof(TCHAR));
    }
}
#endif

//
// BlpGetKey()
//
// Calls BlGetKey(), but checks if this screen has "auto-enter"
// turned on in which case it will return an enter key once.
//
ULONG
BlpGetKey(
    VOID
)
{
    if (AutoEnter) {
        return ENTER_KEY;
        AutoEnter = FALSE;  // only return it once per screen
    } else {
        return BlGetKey();
    }
}

//
// BlpGetKeyWithBlink( )
//
// Displays a blinking cursor as the X,Y coordinates given and awaits
// a key press.
//
ULONG
BlpGetKeyWithBlink(
    IN ULONG XLocation,
    IN ULONG YLocation,
    IN TCHAR  UnderCharacter
    )
{
    ULONG Key = 0;

    TraceFunc("BlpGetKeyWithBlink()\n");

    BlpPositionCursor(XLocation, YLocation);
    BlpShowCursor( TRUE, UnderCharacter );

    do {

        Key = BlpGetKey();

    } while (Key == 0);

    BlpPositionCursor(XLocation, YLocation);
    BlpShowCursor( FALSE, UnderCharacter );

    return Key;
}

//
// BlpPrintString( )
//
// Prints out a large string to the display. It also wraps the text as
// needed.
//
void
BlpPrintString(
    IN PCHAR Start,
    IN PCHAR End
    )
{
    PTCHAR Scan;
    PTCHAR PrintBuf;
    PTCHAR pStart;
    PTCHAR pEnd;
    ULONG  i;
    TCHAR  TmpChar;
    int    Length = 0;


    DPRINT( OSC, ("BlpPrintString: Start = 0x%08x, End = 0x%08x, Length = %d\n", Start, End, (ULONG)(End - Start)) );
    DPRINT( OSC, ("[BlockPrint, Length=%u] '%s'\n", (ULONG)(End - Start), Start) );

    while ( Start < End && *Start == 32 )
        Start++;

    if ( Start == End )
        return; // NOP

    // Copy the buffer so if something goes wrong, the orginal
    // screen will still be intact.

    Length = (int)(End - Start);
    PrintBuf = (PTCHAR)OscHeapAlloc( Length*sizeof(TCHAR) );
    
    if (!PrintBuf) {
        return;
    }
        
    for (i = 0; i < (ULONG)Length; i++) {
        PrintBuf[i] = (TCHAR)Start[i];
        if (PrintBuf[i] & 0x80) {
            DPRINT( OSC, ("BlpPrintString: covering non-printable character %04lx\r\n", (USHORT)PrintBuf[i]) );
            PrintBuf[i] = (TCHAR)32;
        }
    }
   
    pStart = PrintBuf;
    pEnd = pStart + Length;

    BlpPositionCursor( ScreenX, ScreenY );

    // See if it is short enough to do the quick route
    if ( Length + ScreenX <= RightMargin ) {
#if DBG
        {
            TmpChar = *pEnd;
            *pEnd = 0;
            DPRINT( OSC, ("[BlockPrint, Short] '%s'\n", pStart) );
            *pEnd = TmpChar;
        }
#endif
        PRINT( pStart, Length*sizeof(TCHAR) );
        ScreenX += Length;
    } else {
        
        while( (pStart < pEnd) && (ScreenY <= ScreenBottom) )
        {
            DPRINT( 
                OSC, 
                ("BlpPrintString: About to print a line.\r\n") );
            DPRINT( 
                OSC, 
                ("                pStart: 0x%08lx    pEnd: 0x%08lx    PrintBuf: 0x%08lx\r\n", 
                 PtrToUint(pStart), 
                 PtrToUint(pEnd), 
                 PtrToUint(PrintBuf)) );
            
            //
            // Jump over NULL strings.
            //
            if( *pStart == TEXT('\0') ) {
                pStart++;
                break;
            }
            
            Length = (ULONG)(pEnd - pStart);
            DPRINT( OSC, ("BlpPrint: I think the length of this string is %d\n", Length) );

            // do nice wrapping
            if ( Length > RightMargin - ScreenX ) {

                Length = RightMargin - ScreenX;
                DPRINT( OSC, ("BlpPrint: I'm going to truncate the length because it's too big.  Now it's %d\n", Length) );
                
                // try to find a "break" character
                while ( Length && pStart[Length] != (TCHAR)32 ) {
                    Length--;
                }

                DPRINT( OSC, ("BlpPrint: After jumping over the whitespace, it's %d\n", Length) );


                // If we can't "break" it, just dump one line's worth
                if ( !Length ) {
                    DPRINT( OSC, ("[BlockPrint Length == 0, Dumping a lines worth]\n") );
                    Length = RightMargin - ScreenX;
                }
            }

#if DBG
        {
            TmpChar = pStart[Length];
            pStart[Length] = 0;
#ifdef UNICODE
            DPRINT( OSC, ("[BlockPrint, Length=%u] '%ws'\n", Length, pStart) );
#else
            DPRINT( OSC, ("[BlockPrint, Length=%u] '%s'\n", Length, pStart) );
#endif
            pStart[Length] = TmpChar;
        }
#endif
            BlpPositionCursor( ScreenX, ScreenY );
            PRINT( pStart, Length*sizeof(TCHAR) );

            pStart += Length;

            while ( pStart <= pEnd && *pStart == 32 )
                pStart++;

            ScreenX = LeftMargin;
            ScreenY++;
        }
        ScreenY--;

        ScreenX += Length;

        if ( ScreenY > ScreenBottom ) {
            ScreenY = ScreenBottom;
        }
    }

    // If the copy buffer was allocated, free it.
    if ( PrintBuf != NULL ) {
        OscHeapFree( (PVOID)PrintBuf );
    }
}

// **************************************************************************
//
// Lex section
//
// **************************************************************************

//
// Token list for screen parser
//
enum TOKENS {
    TOKEN_ENDTAG = 0,
    TOKEN_QUOTE,
    TOKEN_HTML,
    TOKEN_ENDHTML,
    TOKEN_META,
    TOKEN_SERVER,
    TOKEN_KEY,
    TOKEN_ENTER,
    TOKEN_ESC,
    TOKEN_F1,
    TOKEN_F3,
    TOKEN_HREF,
    TOKEN_TITLE,
    TOKEN_ENDTITLE,
    TOKEN_FOOTER,
    TOKEN_ENDFOOTER,
    TOKEN_BODY,
    TOKEN_ENDBODY,
    TOKEN_PRE,
    TOKEN_ENDPRE,
    TOKEN_FORM,
    TOKEN_ENDFORM,
    TOKEN_ACTION,
    TOKEN_INPUT,
    TOKEN_NAME,
    TOKEN_INPUTTYPE,
    TOKEN_VALUE,
    TOKEN_SIZE,
    TOKEN_TIP,
    TOKEN_MAXLENGTH,
    TOKEN_ENCODE,
    TOKEN_SELECT,
    TOKEN_MULTIPLE,
    TOKEN_NOAUTO,
    TOKEN_ENDSELECT,
    TOKEN_OPTION,
    TOKEN_SELECTED,
    TOKEN_HELP,
    TOKEN_BREAK,
    TOKEN_BOLD,
    TOKEN_ENDBOLD,
    TOKEN_FLASH,
    TOKEN_ENDFLASH,
    TOKEN_LEFT,
    TOKEN_RIGHT,
    TOKEN_TIPAREA,
    TOKEN_PARAGRAPH,
    TOKEN_ENDPARA,    
#if defined(PLEASE_WAIT)
    TOKEN_WAITMSG,
#endif
    TOKEN_INVALID,  // end of parsable tokens
    TOKEN_TEXT,
    TOKEN_START,
    TOKEN_EOF,      // End of file
};

static struct {
    PCHAR name;
    int   length;
} Tags[] = {
    { ">",            1 },
    { "\"",           1 },
    { "<OSCML",       0 },
    { "</OSCML>",     0 },
    { "<META",        0 },
    { "SERVER",       0 },
    { "KEY=",         0 },
    { "ENTER",        0 },
    { "ESC",          0 },
    { "F1",           0 },
    { "F3",           0 },
    { "HREF=",        0 },
    { "<TITLE",       0 },
    { "</TITLE>",     0 },
    { "<FOOTER",      0 },
    { "</FOOTER>",    0 },
    { "<BODY",        0 },
    { "</BODY>",      0 },
    { "<PRE",         0 },
    { "</PRE>",       0 },
    { "<FORM",        0 },
    { "</FORM>",      0 },
    { "ACTION=",      0 },
    { "<INPUT",       0 },
    { "NAME=",        0 },
    { "TYPE=",        0 },
    { "VALUE=",       0 },
    { "SIZE=",        0 },
    { "TIP=",         0 },
    { "MAXLENGTH=",   0 },
    { "ENCODE=",      0 },
    { "<SELECT",      0 },
    { "MULTIPLE",     0 },
    { "NOAUTO",       0 },
    { "</SELECT>",    0 },
    { "<OPTION",      0 },
    { "SELECTED",     0 },
    { "HELP=",        0 },
    { "<BR",          0 },
    { "<BOLD",        0 },
    { "</BOLD",       0 },
    { "<FLASH",       0 },
    { "</FLASH",      0 },
    { "LEFT=",        0 },
    { "RIGHT=",       0 },
    { "<TIPAREA",     0 },
    { "<P",           0 },
    { "</P",          0 },
#if defined(PLEASE_WAIT)
    { "WAITMSG=",     0 },
#endif
    { NULL,           0 },  // end of parsable tokens
    { "[TEXT]",       0 },
    { "[START]",      0 },
    { "[EOF]",        0 }
};

//
// Lexstrcmpni( )
//
// Impliments strcmpni( ) for the Lexer.
//
int
Lexstrcmpni(
    IN PCHAR pstr1,
    IN PCHAR pstr2,
    IN int iLength
    )
{
    while ( iLength && *pstr1 && *pstr2 )
    {
        CHAR ch1 = *pstr1;
        CHAR ch2 = *pstr2;

        if ( islower( ch1 ) )
        {
            ch1 = (CHAR)toupper(ch1);
        }

        if ( islower( ch2 ) )
        {
            ch2 = (CHAR)toupper(ch2);
        }

        if ( ch1 < ch2 )
            return -1;

        if ( ch1 > ch2 )
            return 1;

        pstr1++;
        pstr2++;
        iLength--;
    }

    return 0;
}

//
//  ReplaceSpecialCharacters( &psz );
//
void
ReplaceSpecialCharacters(
    IN PCHAR psz)
{
    TraceFunc( "ReplaceSpecialCharacters( )\n" );

    if ( Lexstrcmpni( psz, "&NBSP", 5 ) == 0 ) {
        *psz = CHAR_NBSP;                               // replace
        memmove( psz + 1, psz + 5, strlen(psz) - 4 );   // shift
    }
}


#if DBG
// #define LEX_SPEW
#endif

//
// Lex( )
//
// Parses the screen data moving the "InputString" pointer forward and
// returns the token for the text parsed. Spaces are ignored. Illegal
// characters are removed from the screen data. CRs are turned into
// spaces.
//
enum TOKENS
Lex(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_TEXT;
    PCHAR psz = *InputString;
    int   iCounter;

#if defined(LEX_SPEW) && defined(_TRACE_FUNC_)
    TraceFunc( "Lex( " );
    DPRINT( OSC, ("InputString = 0x%08x )\n", *InputString) );
#endif _TRACE_FUNC_

    // skip spaces and control characters
    if ( PreformattedMode == FALSE )
    {
        while ( *psz && *psz <= L' ' )
        {
            if (( *psz != 32 && *psz != '\n' )
               || ( psz != *InputString && (*(psz-1)) == 32 )) {
                // remove any CR or LFs and any bogus characters
                // also remove duplicate spaces in cases like:
                //
                // This is some text \n\r
                // and more text.
                //
                // If we left it alone it would be printed:
                //
                // This is some text  and more text.
                //
                memmove( psz, psz + 1, strlen(psz) );
            } else {
                *psz = 32;
                psz++;
            }
        }
    }

    if ( *psz == '&' ) {
        ReplaceSpecialCharacters( psz );
    }

    if ( *psz ) {
        for ( iCounter = 0; Tags[iCounter].name; iCounter++ )
        {
            if ( !Tags[iCounter].length ) {
                Tags[iCounter].length = strlen( Tags[iCounter].name );
            }

            if ( Lexstrcmpni( psz, Tags[iCounter].name, Tags[iCounter].length ) == 0 ) {
                psz += Tags[iCounter].length;
                Tag = iCounter;
                break;
            }
        }

        if ( Tag == TOKEN_TEXT )
            psz++;
    } else {
        Tag = TOKEN_EOF;
    }

#ifdef LEX_SPEW
    {
        CHAR tmp = *psz;
        *psz = '\0';
        DPRINT( OSC, ("[Lex] Parsed String: '%s' Result: %u - '%s'\n", *InputString, Tag, Tags[Tag].name) );
        *psz = tmp;
    }
#endif

    *InputString = psz;

    return Tag;
}

//
// GetString( )
//
// Finds and copies a string value from the screen data.
//
PCHAR
GetString(
    IN PCHAR * InputString
    )
{
    CHAR  StopChar = 32;
    PCHAR ReturnString = NULL;
    PCHAR pszBegin = *InputString;
    PCHAR pszEnd;
    UINT Length;
    CHAR tmp;

    TraceFunc( "GetString( )\n" );

    if ( !pszBegin )
        goto e0;

    // skip spaces
    while ( *pszBegin == 32 )
        pszBegin++;

    // Check for quoted string
    if ( *pszBegin == '\"' ) {
        // find the end quote
        pszBegin++;
        pszEnd = strchr( pszBegin, '\"' );

    } else {
        // look for a break (space) or end token (">")
        PCHAR pszSpace = strchr( pszBegin, ' ' );
        PCHAR pszEndToken = strchr( pszBegin, '>' );

        if ( !pszSpace ) {
            pszEnd = pszEndToken;
        } else if ( !pszEndToken ) {
            pszEnd = pszSpace;
        } else if ( pszEndToken < pszSpace ) {
            pszEnd = pszEndToken;
        } else {
            pszEnd = pszSpace;
        }
    }

    if ( !pszEnd )
        goto e0;

    tmp = *pszEnd;     // save
    *pszEnd = '\0';    // terminate

    Length = strlen( pszBegin ) + 1;
    ReturnString = OscHeapAlloc( Length );
    if ( ReturnString ) {
        strcpy( ReturnString, pszBegin );
    }
    *pszEnd = tmp;     // restore

    DPRINT( OSC, ("[String] %s<-\n", ReturnString) );

    *InputString = pszEnd;
e0:
    return ReturnString;
}

// **************************************************************************
//
// Parsing States Section
//
// **************************************************************************

//
// TitleTagState( )
//
enum TOKENS
TitleTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;
    PCHAR  PageTitle = *InputString;

    TraceFunc( "TitleTagState( )\n" );

    // ignore tag arguments
    for( ; Tag != TOKEN_EOF && Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) );

    PreformattedMode = TRUE;

    while ( Tag != TOKEN_EOF )
    {
        switch (Tag)
        {
        case TOKEN_EOF:
            // something went wrong, assume all this is text
            *InputString = PageTitle;
            PreformattedMode = FALSE;
            return TOKEN_TEXT;

        case TOKEN_ENDTAG:
            PageTitle = *InputString;
            break; // ignore

        case TOKEN_ENDTITLE:
            {
                PCHAR psz = *InputString;
                CHAR tmp;

                psz -= Tags[Tag].length;

                tmp = *psz;
                *psz = L'\0';

                BlpSendEscapeReverse(ScreenAttributes);
                BlpPositionCursor( 1, 1 );

#ifdef _IN_OSDISP_
                PRINT( SpaceString, sizeof(SpaceString) - sizeof(TCHAR) );
#else
                PRINT( SpaceString, sizeof(SpaceString) );
#endif

                if ( PageTitle ) {
                    BlpPositionCursor( 1, 1 );
                    DPRINT( OSC, ("[Title] '%s'\n", PageTitle) );
#ifdef UNICODE
                    { 
                        ULONG i;
                        WCHAR wc;
                        for (i = 0; i < strlen(PageTitle) ; i++) {
                            wc = (WCHAR)PageTitle[i];
                            PRINT( &wc, sizeof(WCHAR));
                        }
                    }                    
#else
                    PRINTL( PageTitle );
#endif
                }

                BlpSendEscape(ScreenAttributes);
                *psz = tmp;
                PreformattedMode = FALSE;
                return Tag; //exit state
            }
            break;
        }
        Tag = Lex( InputString );
    }

    PreformattedMode = FALSE;
    return Tag;
}

//
// FooterTagState( )
//
enum TOKENS
FooterTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;
    PCHAR  PageFooter = *InputString;

    TraceFunc( "FooterTagState( )\n" );

    // ignore tag arguments
    for( ; Tag != TOKEN_EOF && Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) );

    PreformattedMode = TRUE;

    while ( Tag != TOKEN_EOF )
    {
        switch (Tag)
        {
        case TOKEN_EOF:
            // something went wrong, assume all this is text
            *InputString = PageFooter;
            PreformattedMode = FALSE;
            return TOKEN_TEXT;

        case TOKEN_ENDTAG:
            PageFooter = *InputString;
            break; // ignore

        case TOKEN_ENDFOOTER:
            {
                PCHAR psz = *InputString;
                CHAR tmp;

                psz -= Tags[Tag].length;

                tmp = *psz;
                *psz = L'\0';

                BlpSendEscapeReverse(ScreenAttributes);
                BlpPositionCursor( 1, ScreenBottom );

#ifdef _IN_OSDISP_
                PRINT( SpaceString, sizeof(SpaceString) - sizeof(TCHAR) );
#else
                //
                // if we're writing to a terminal, we don't want to write into the lower
                // right corner as this would make us scroll.
                //
                PRINT( SpaceString, BlTerminalConnected 
                                      ? (sizeof(SpaceString) - sizeof(TCHAR))
                                      : sizeof(SpaceString) );
#endif

                if ( PageFooter ) {
                    ULONG iLen;
                    BlpPositionCursor( 1, ScreenBottom );
                    DPRINT( OSC, ("[Footer] '%s'\n", PageFooter) );
                    
                    iLen = strlen(PageFooter);
                    if (iLen > 79) {
                        iLen = 79;
                    }
#ifdef UNICODE
                    { 
                        ULONG i;
                        WCHAR wc;
                        for (i = 0; i < iLen ; i++) {
                            wc = (WCHAR)PageFooter[i];
                            PRINT( &wc, sizeof(WCHAR));
                        }
                    }
#else
                    PRINT( PageFooter, iLen );
#endif                    
                }

                BlpSendEscape(ScreenAttributes);
                *psz = tmp;
                PreformattedMode = FALSE;
                return Tag; //exit state
            }
            break;
        }
        Tag = Lex( InputString );
    }

    PreformattedMode = FALSE;
    return Tag;
}

//
// InputTagState( )
//
enum TOKENS
InputTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_INVALID;
    LPINPUTSTRUCT Input;

    TraceFunc( "InputTagState( )\n" );
    
    Input = (LPINPUTSTRUCT) OscHeapAlloc( sizeof(INPUTSTRUCT) );
    if ( !Input )
    {
        // get tag arguments
        for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) );
        return TOKEN_INVALID;
    }

    RtlZeroMemory( Input, sizeof(INPUTSTRUCT) );
    Input->Type |= CT_TEXT;
    Input->Encoding = ET_NONE;
    Input->X = ScreenX;
    Input->Y = ScreenY;

    // get tag arguments
    for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) )
    {
        switch( Tag )
        {
        case TOKEN_NAME:
            Input->Name = GetString( InputString );
            if ( Input->Name )
                DPRINT( OSC, ("[Input Name] %s\n", Input->Name) );
            break;

        case TOKEN_VALUE:
            Input->Value = GetString( InputString );
            if ( Input->Value )
                DPRINT( OSC, ("[Input Value] %s\n", Input->Value) );
            break;

        case TOKEN_INPUTTYPE:
            {
                PCHAR pType = GetString( InputString );
                if ( !pType )
                    break;
                if ( Lexstrcmpni( pType, "PASSWORD", 8 ) == 0 ) {
                    Input->Type = CT_PASSWORD;
                    DPRINT( OSC, ("[Input Type] PASSWORD\n") );
                } else if ( Lexstrcmpni( pType, "RESET", 5 ) == 0 ) {
                    Input->Type = CT_RESET;
                    DPRINT( OSC, ("[Input Type] RESET\n") );
                } else if ( Lexstrcmpni( pType, "TEXT", 4 ) == 0 ) {
                    Input->Type = CT_TEXT;
                    DPRINT( OSC, ("[Input Type] TEXT\n") );
                } else if ( Lexstrcmpni( pType, "LOCAL", 5 ) == 0 ) {
                    DPRINT( OSC, ("[Input Type] LOCAL\n") );
                    Input->Type = CT_LOCAL;
                    if ( Lexstrcmpni( pType + 5, "PASSWORD", 8 ) == 0 ) {
                        Input->Type |= CT_PASSWORD;
                        DPRINT( OSC, ("[Input Type] PASSWORD\n") );
                    } else if ( Lexstrcmpni( pType + 5, "RESET", 5 ) == 0 ) {
                        Input->Type |= CT_RESET;
                        DPRINT( OSC, ("[Input Type] RESET\n") );
                    } else if ( Lexstrcmpni( pType + 5, "TEXT", 4 ) == 0 ) {
                        Input->Type |= CT_TEXT;
                        DPRINT( OSC, ("[Input Type] TEXT\n") );
                    }
                } else if ( Lexstrcmpni( pType, "VARIABLE", 8 ) == 0) {
                    Input->Type = CT_VARIABLE;
                    DPRINT( OSC, ("[Input Type] VARIABLE\n") );
                }
                                                         
                OscHeapFree( pType );
            }
            break;

        case TOKEN_SIZE:
            {
                PCHAR psz = GetString( InputString );
                if ( psz ) {
                    PCHAR pszOld = psz;  // save because GetInteger modifies
                    Input->Size = GetInteger( &psz );
                    OscHeapFree( pszOld );
                    DPRINT( OSC, ("[Input Size] %u\n", Input->Size) );
                }
            }
            break;

        case TOKEN_MAXLENGTH:
            {
                PCHAR psz = GetString( InputString );
                
                if ( psz ) {
                    PUCHAR pTmpSz = psz;

                    Input->MaxLength = GetInteger( &pTmpSz );

                    if ( Input->MaxLength > MAX_INPUT_BUFFER_LENGTH - 1 ) {
                        Input->MaxLength = MAX_INPUT_BUFFER_LENGTH - 1;
                    }
                    OscHeapFree( psz );
                    DPRINT( OSC, ("[Input MaxLength] %u\n", Input->MaxLength) );
                }
            }
            break;

        case TOKEN_ENCODE:
            {
                PCHAR pType = GetString( InputString );
                if ( !pType )
                    break;
                if ( Lexstrcmpni( pType, "YES", 3 ) == 0 ) {
                    Input->Encoding = ET_OWF;
                    DPRINT( OSC, ("[Encoding Type] OWF\n") );
                }
                OscHeapFree( pType );
            }
            break;

        case TOKEN_EOF:
            return Tag;
        }
    }

    // add the control to the list of controls
    Input->Next = ScreenControls;
    ScreenControls = Input;

    if ( Input->Size + BRACKETS > RightMargin - ScreenX ) {
        Input->Size = 0;    // too big, so auto figure
    }

    // adjust screen coordinates
    if ( !Input->Size && Input->MaxLength ) {
        // figure out how much is left of the line, choose the smaller
        Input->Size = ( (RightMargin - ScreenX) - BRACKETS < Input->MaxLength ?
                        (RightMargin - ScreenX) - BRACKETS : Input->MaxLength );
    } else if ( !Input->Size ) {
        // assume the input is going to take the whole line
        Input->Size = (RightMargin - ScreenX) - BRACKETS;
    }

    if ( Input->Size > Input->MaxLength ) {
        Input->Size = Input->MaxLength;
    }

    if ((Input->Type & CT_VARIABLE) == 0) {
        ScreenX += Input->Size + BRACKETS + 1;
    }


    if ( ScreenX >= RightMargin ) {
        ScreenX = LeftMargin;
        ScreenY++;
    }

    if ( ScreenY > ScreenBottom )
        ScreenY = ScreenBottom;

    // display any predefined values
    if ( Input->Value ) {
        int Length = strlen(Input->Value);
        if ((Input->Type & CT_VARIABLE) == 0) {
            if ( Length > Input->Size ) {
                Length = Input->Size;
            }
            if (Input->Type &  CT_PASSWORD) {
                    int i;
                    BlpPositionCursor( Input->X + 2, Input->Y );
                    for( i = 0; i < Length; i ++ )
                    {
                        PRINT( TEXT("*"), 1*sizeof(TCHAR) );
                    }
            } else {
                BlpPositionCursor( Input->X + 2, Input->Y );
#ifdef UNICODE
                {
                    int i;
                    WCHAR wc;
                    for (i = 0; i< Length; i++) {
                        wc = (WCHAR)(Input->Value)[i];
                        PRINT( &wc, 1*sizeof(WCHAR));
                    }
                }
#else
                PRINT( Input->Value, Length );
#endif
            }
        }
    }
    return Tag;
}

//
// OptionTagState( )
//
enum TOKENS
OptionTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_INVALID;
    LPOPTIONSTRUCT Option;
    PCHAR pszBegin, pszEnd;
    ULONG Length;

    TraceFunc( "OptionTagState( )\n" );

    Option = (LPOPTIONSTRUCT) OscHeapAlloc( sizeof(OPTIONSTRUCT) );
    if ( !Option )
    {
        // get tag arguments
        for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) );
        return TOKEN_INVALID;
    }

    RtlZeroMemory( Option, sizeof(OPTIONSTRUCT) );
    Option->Type |= CT_OPTION;

    // get tag arguments
    for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) )
    {
        switch( Tag )
        {
        case TOKEN_VALUE:
            Option->Value = GetString( InputString );
            if ( Option->Value )
                DPRINT( OSC, ("[Options Value] %s\n", Option->Value) );
            break;

        case TOKEN_SELECTED:
            DPRINT( OSC, ("[Option] SELECTED\n") );
            Option->Flags = OF_SELECTED;
            break;

        case TOKEN_TIP:
            Option->Tip = GetString( InputString );
            if ( Option->Tip ) {
                PCHAR psz = Option->Tip;
                Option->EndTip = &Option->Tip[strlen(Option->Tip)];
                // strip CRs and LFs from tip
                while ( psz < Option->EndTip )
                {
                    if ( (*psz == '\r') ||
                         ((*psz < 32) && ((psz == Option->Tip) || (*(psz-1) == ' '))) )
                    {   // remove control codes that follows spaces and all CRs
                        memmove( psz, psz+1, strlen(psz) );
                        Option->EndTip--;
                    }
                    else
                    {
                        if ( *psz < 32 )
                        {   // turn control codes into spaces
                            *psz = 32;
                        }
                        psz++;
                    }
                }
                DPRINT( OSC, ("[Option Tip] %s\n", Option->Tip) );
            }
            break;

        case TOKEN_EOF:
            return Tag;
        }
    }

    // get the option title - at this point Tag == TOKEN_ENDTAG
    pszBegin = *InputString;
    for(Tag = Lex( InputString ) ; Tag != TOKEN_EOF; Tag = Lex( InputString ) )
    {
        BOOLEAN ExitLoop = FALSE;
        switch( Tag )
        {
        case TOKEN_HTML:
        case TOKEN_ENDHTML:
        case TOKEN_META:
        case TOKEN_TITLE:
        case TOKEN_ENDTITLE:
        case TOKEN_FOOTER:
        case TOKEN_ENDFOOTER:
        case TOKEN_BODY:
        case TOKEN_ENDBODY:
        case TOKEN_PRE:
        case TOKEN_ENDPRE:
        case TOKEN_FORM:
        case TOKEN_ENDFORM:
        case TOKEN_INPUT:
        case TOKEN_SELECT:
        case TOKEN_ENDSELECT:
        case TOKEN_OPTION:
        case TOKEN_BREAK:
        case TOKEN_TIPAREA:
        case TOKEN_PARAGRAPH:
        case TOKEN_ENDPARA:
        case TOKEN_INVALID:
            ExitLoop = TRUE;
            break;
        }

        if ( ExitLoop == TRUE )
            break;
    }
    pszEnd = (*InputString) - Tags[Tag].length;

    // try to take the crud and extra spaces off the end
    while ( pszEnd > pszBegin && *pszEnd <= 32 )
        pszEnd--;

    if ( pszEnd == pszBegin ) {
        pszEnd = (*InputString) - Tags[Tag].length;
    }

    Length = PtrToUint((PVOID)(pszEnd - pszBegin));
    Option->Displayed = OscHeapAlloc( Length + 1 );
    if ( Option->Displayed ) {
        CHAR tmp = *pszEnd;     // save
        *pszEnd = '\0';         // terminate
        strcpy( Option->Displayed, pszBegin );
        *pszEnd = tmp;          // restore
        DPRINT( OSC, ("[Option Name] %s\n", Option->Displayed) );

        // add the control to the list of controls
        Option->Next = ScreenControls;
        ScreenControls = Option;

    } else {

        // remove it since there is nothing to display
        if ( Option->Tip )
            OscHeapFree( Option->Tip );
        if ( Option->Value )
            OscHeapFree( Option->Value );
        OscHeapFree( (void *)Option );
    }
    return Tag;
}

//
// SelectTagState( )
//
enum TOKENS
SelectTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_INVALID;
    LPSELECTSTRUCT Select;
    
    TraceFunc( "SelectTagState( )\n" );

    Select = (LPSELECTSTRUCT) OscHeapAlloc( sizeof(SELECTSTRUCT) );
    if ( !Select )
    {
        // get tag arguments
        for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) );
        return TOKEN_INVALID;
    }

    RtlZeroMemory( Select, sizeof(SELECTSTRUCT) );
    Select->Type |= CT_SELECT;
    Select->X    = ScreenX;
    Select->Y    = ScreenY;
    Select->Size = 1;
    Select->AutoSelect = TRUE;

    // get tag arguments
    for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) )
    {
        switch( Tag )
        {
        case TOKEN_NAME:
            Select->Name = GetString( InputString );
            if ( Select->Name )
                DPRINT( OSC, ("[Select Name] %s\n", Select->Name) );
            break;

        case TOKEN_MULTIPLE:
            DPRINT( OSC, ("[Select] MULTIPLE\n") );
            Select->Flags = OF_MULTIPLE;
            break;

        case TOKEN_NOAUTO:
            DPRINT( OSC, ("[Select] NOAUTO\n") );
            Select->AutoSelect = FALSE;
            break;

        case TOKEN_SIZE:
            {
                PCHAR psz = GetString( InputString );
                if ( psz ) {
                    PCHAR pszOld = psz;  // save because GetInteger modifies
                    Select->Size = GetInteger( &psz );
                    OscHeapFree( pszOld );
                    DPRINT( OSC, ("[Select Size] %u\n", Select->Size) );
                }
            }
            break;

        case TOKEN_EOF:
            return Tag;
        }
    }

    // add the control to the list of controls
    Select->Next = ScreenControls;
    ScreenControls = Select;
    
    while( Tag != TOKEN_ENDSELECT && Tag != TOKEN_EOF )
    {
        switch( Tag )
        {
        case TOKEN_OPTION:
            {
                LPOPTIONSTRUCT Option;
                
                Tag = OptionTagState( InputString );

                Option = ScreenControls;
                if ( Option->Type & CT_OPTION ) {
                    if ( Option->Displayed ) {
                        int Length = strlen( Option->Displayed ) + 1;
                        if ( Select->Width < Length ) {
                            Select->Width = Length;
                        }
                    }
                    if ( Option->Flags == OF_SELECTED ) {
                        Select->CurrentSelection = Option;
                        if ( Select->Flags != OF_MULTIPLE )
                        {
                            Option->Flags = 0;
                        }
                    }
                }
            }
            break;

        default:
            Tag = Lex( InputString );
        }
    }

    // adjust screen coordinates
    ScreenY += Select->Size;

    if ( ScreenY > ScreenBottom ) {
        Select->Size -= ScreenY - ScreenBottom;
        ScreenY = ScreenBottom;
    }
    return Tag;
}

//
// PreformattedPrint( )
//
void
PreformattedPrint(
    IN PCHAR Start,
    IN PCHAR End
    )
{
#ifdef _TRACE_FUNC_
    TraceFunc( "PreformattedPrint( " );
    DPRINT( OSC, ("Start = 0x%08x, End = 0x%08x )\n", Start, End) );
#endif

    BlpPositionCursor( ScreenX, ScreenY );

    while ( Start < End )
    {
        int Length, OldLength;

        while ( Start < End && (*Start == '\r' || *Start == '\n') )
        {
            if ( *Start == '\r' ) {
                ScreenX = LeftMargin;
            }
            if ( *Start == '\n' ) {
                ScreenY++;
                if ( ScreenY > ScreenBottom ) {
                    ScreenY = ScreenBottom;
                }
            }
            Start++;
        }

        Length = PtrToUint((PVOID)(End - Start));
        if ( !Length )
            continue; // nothing to print

        // trunk if needed
        if ( Length > RightMargin - ScreenX ) {

            Length = RightMargin - ScreenX;
        }

        // try to find a "break" character
        OldLength = Length;
        while ( Length && Start[Length] != '\r' && Start[Length] != '\n' )
            Length--;

        // If we can't "break" it, just dump one line's worth
        if ( !Length ) {
            DPRINT( OSC, ("[FormattedPrint, Length == 0, Dumping a lines worth]\n") );
            Length = OldLength;
        }
#if DBG
    {
        CHAR tmp = Start[Length];
        Start[Length] = 0;
        DPRINT( OSC, ("[FormattedPrint, Length=%u] '%s'\n", Length, Start) );
        Start[Length] = tmp;
    }
#endif
        BlpPositionCursor( ScreenX, ScreenY );
#ifdef UNICODE
        {
            int i;
            WCHAR wc;
            for (i = 0; i < Length; i++) {
                wc = (WCHAR) Start[i];
                PRINT( &wc, 1*sizeof(WCHAR));
            }
        }
#else
        PRINT( Start, Length );
#endif

        ScreenX += Length;

        while ( Start < End && *Start != '\r' && *Start != '\n' )
            Start++;
    }
}
//
// PreTagState( )
//
enum TOKENS
PreTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;
    PCHAR psz = *InputString;

    TraceFunc( "PreTagState( )\n" );

    // get tag arguments
    for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) )
    {
        switch( Tag )
        {
        case TOKEN_LEFT:
            psz = *InputString;
            // skip any spaces
            while( *psz && *psz == 32 )
                psz++;
            *InputString = psz;
            LeftMargin = GetInteger( InputString );
            DPRINT( OSC, ("[LeftMargin = %u]\n", LeftMargin) );
            break;

        case TOKEN_RIGHT:
            psz = *InputString;
            // skip any spaces
            while( *psz && *psz == 32 )
                psz++;
            *InputString = psz;
            RightMargin = GetInteger( InputString );
            DPRINT( OSC, ("[RightMargin = %u]\n", RightMargin) );
            break;

        case TOKEN_EOF:
            return Tag;
        }
    }

    if ( ScreenX >= RightMargin ) {
        ScreenY++;
        if ( ScreenY > ScreenBottom ) {
            ScreenY = ScreenBottom;
        }
    }
    if ( ScreenX >= RightMargin || ScreenX < LeftMargin ) {
        ScreenX = LeftMargin;
    }

    PreformattedMode = TRUE;
    psz = *InputString;
    while ( Tag != TOKEN_EOF )
    {
        switch (Tag)
        {
        case TOKEN_ENDPRE:
        case TOKEN_ENDHTML:
        case TOKEN_ENDBODY:
            PreformattedPrint( psz, (*InputString) - Tags[Tag].length );
            PreformattedMode = FALSE;
            return Tag; // exit state

        // just print everything else
        default:
            PreformattedPrint( psz, *InputString );
            psz = *InputString;
            Tag = Lex( InputString );
            break;
        }
    }
    PreformattedMode = FALSE;
    return Tag;
}

//
// TipAreaTagState( )
//
enum TOKENS
TipAreaTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;
    PCHAR psz = *InputString;

    TraceFunc( "TipAreaTagState( )\n" );

    if ( !TipArea ) {
        TipArea = (LPTIPAREA) OscHeapAlloc( sizeof(TIPAREA) );
        if ( !TipArea )
        {
            // get tag arguments
            for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) );
            return TOKEN_INVALID;
        }
    }

    TipArea->X = ScreenX;
    TipArea->Y = ScreenY;
    TipArea->LeftMargin = LeftMargin;
    TipArea->RightMargin = RightMargin;
    TipArea->Size = ScreenBottom - ScreenY;

    // get tag arguments
    for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) )
    {
        switch( Tag )
        {
        case TOKEN_LEFT:
            psz = *InputString;
            // skip any spaces
            while( *psz && *psz == 32 )
                psz++;
            *InputString = psz;
            TipArea->LeftMargin = GetInteger( InputString );
            DPRINT( OSC, ("[TipArea LeftMargin = %u]\n", TipArea->LeftMargin) );
            break;

        case TOKEN_RIGHT:
            psz = *InputString;
            // skip any spaces
            while( *psz && *psz == 32 )
                psz++;
            *InputString = psz;
            TipArea->RightMargin = GetInteger( InputString );
            DPRINT( OSC, ("[TipArea RightMargin = %u]\n", TipArea->RightMargin) );
            break;

        case TOKEN_SIZE:
            psz = *InputString;
            // skip any spaces
            while( *psz && *psz == 32 )
                psz++;
            *InputString = psz;
            TipArea->Size = GetInteger( InputString ) - 1;
            if ( TipArea->Size < 1 ) {
                TipArea->Size = 1;
            }
            DPRINT( OSC, ("[TipArea Size = %u]\n", TipArea->Size) );
            ScreenY += TipArea->Size;
            break;

        case TOKEN_EOF:
            // imcomplete statement - so don't have a tiparea.
            TipArea = NULL;
            return Tag;
        }
    }

    if ( ScreenY > ScreenBottom ) {
        ScreenY = ScreenBottom;
    }
    return Tag;
}

int ParaOldLeftMargin = 0;
int ParaOldRightMargin = 0;

//
// ParagraphTagState( )
//
enum TOKENS
ParagraphTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;
    PCHAR psz;

    TraceFunc( "ParagraphTagState( )\n" );
    ParaOldLeftMargin = LeftMargin;
    ParaOldRightMargin = RightMargin;

    // get tag arguments
    for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) )
    {
        switch( Tag )
        {
        case TOKEN_LEFT:
            psz = *InputString;
            // skip any spaces
            while( *psz && *psz == 32 )
                psz++;
            *InputString = psz;
            LeftMargin = GetInteger( InputString );
            DPRINT( OSC, ("[LeftMargin = %u]\n", LeftMargin) );
            break;

        case TOKEN_RIGHT:
            psz = *InputString;
            // skip any spaces
            while( *psz && *psz == 32 )
                psz++;
            *InputString = psz;
            RightMargin = GetInteger( InputString );
            DPRINT( OSC, ("[RightMargin = %u]\n", RightMargin) );
            break;

        case TOKEN_EOF:
            return Tag;
        }
    }

    // always simulate a <BR>
    ScreenY++;
    if ( ScreenY > ScreenBottom ) {
        ScreenY = ScreenBottom;
    }
    ScreenX = LeftMargin;
    return Tag;
}

//
// FormTagState( )
//
enum TOKENS
FormTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;
    PCHAR psz;

    TraceFunc( "FormTagState( )\n" );
    // get tag arguments
    for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) )
    {
        switch( Tag )
        {
        case TOKEN_ACTION:
            if ( !EnterKey ) {
                EnterKey = (LPKEY_RESPONSE) OscHeapAlloc( sizeof(KEY_RESPONSE) );
            }
            if ( !EnterKey )
                break;
            EnterKey->Action = ACTION_JUMP;
            EnterKey->ScreenName = GetString( InputString );
            if ( EnterKey->ScreenName )
                DPRINT( OSC, ("[Key Enter Action: JUMP to '%s.OSC']\n", EnterKey->ScreenName) );
            break;

        case TOKEN_EOF:
            return Tag;
        }
    }

    psz = *InputString;

    while ( Tag != TOKEN_EOF && Tag != TOKEN_ENDFORM )
    {
        switch (Tag)
        {
        default:
            if ( !psz ) {
                psz = *InputString;
            }
            Tag = Lex( InputString );
            break;

        case TOKEN_SELECT:
        case TOKEN_INPUT:
        case TOKEN_PRE:
        case TOKEN_BOLD:
        case TOKEN_FLASH:
        case TOKEN_ENDFLASH:
        case TOKEN_ENDBOLD:
        case TOKEN_BREAK:
        case TOKEN_ENDBODY:
        case TOKEN_FORM:
        case TOKEN_TIPAREA:
        case TOKEN_EOF:
        case TOKEN_PARAGRAPH:
        case TOKEN_ENDPARA:
            if ( psz ) {
                BlpPrintString( psz, (*InputString) - Tags[Tag].length );
                psz = NULL; // reset
            }

            switch( Tag )
            {
            case TOKEN_SELECT:
                Tag = SelectTagState( InputString );
                break;

            case TOKEN_INPUT:
                Tag = InputTagState( InputString );
                break;

            case TOKEN_EOF:
                return Tag;

            case TOKEN_PRE:
                Tag = PreTagState( InputString );
                break;

            case TOKEN_BOLD:
                BlpSendEscapeBold(ScreenAttributes);
                DPRINT( OSC, ("[Bold]\n") );
                Tag = Lex( InputString );
                break;

            case TOKEN_FLASH:
                BlpSendEscapeFlash(ScreenAttributes);
                DPRINT( OSC, ("[Flash]\n") );
                Tag = Lex( InputString );
                break;

            case TOKEN_ENDFLASH:
            case TOKEN_ENDBOLD:
                BlpSendEscape(ScreenAttributes);
                DPRINT( OSC, ("[Normal]\n") );
                Tag = Lex( InputString );
                break;

            case TOKEN_FORM:
                // ignore it
                Tag = Lex( InputString );
                break;

            case TOKEN_BREAK:
                ScreenX = LeftMargin;
                ScreenY++;
                if ( ScreenY > ScreenBottom ) {
                    ScreenY = ScreenBottom;
                }
                Tag = Lex( InputString );
                break;

            case TOKEN_TIPAREA:
                Tag = TipAreaTagState( InputString );
                break;

            case TOKEN_PARAGRAPH:
                Tag = ParagraphTagState( InputString );
                break;

            case TOKEN_ENDPARA:
                LeftMargin = ParaOldLeftMargin;
                RightMargin = ParaOldRightMargin;
                // Make sure the boundaries are realistic
                if ( LeftMargin < 1 ) {
                    LeftMargin = 1;
                }
                if ( RightMargin <= LeftMargin ) {
                    RightMargin = LeftMargin + 1;
                }
                if ( RightMargin < 1 ) {
                    RightMargin = 80;
                }
                // always simulate a <BR>
                ScreenY++;
                if ( ScreenY > ScreenBottom ) {
                    ScreenY = ScreenBottom;
                }
                ScreenX = LeftMargin;
                Tag = Lex( InputString );
                break;

            case TOKEN_ENDBODY:
                return Tag; // exit state

            }
            break;
        }
    }
    return Tag;
}

//
// ImpliedBodyTagState( )
//
enum TOKENS
ImpliedBodyTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;
    PCHAR psz = *InputString;

    TraceFunc( "ImpliedBodyTagState( )\n" );

    while ( TRUE )
    {
        // KB: All items in this switch statment must have Tag returned
        //     to them from a function call or must call Lex( ) to get
        //     the next Tag.
        switch (Tag)
        {
        default:
            if ( !psz ) {
                psz = *InputString;
            }
            Tag = Lex( InputString );
            break;

        case TOKEN_PRE:
        case TOKEN_BOLD:
        case TOKEN_FLASH:
        case TOKEN_ENDFLASH:
        case TOKEN_ENDBOLD:
        case TOKEN_BREAK:
        case TOKEN_ENDBODY:
        case TOKEN_FORM:
        case TOKEN_TIPAREA:
        case TOKEN_EOF:
        case TOKEN_PARAGRAPH:
        case TOKEN_ENDPARA:
            if ( psz ) {
                BlpPrintString( psz, (*InputString) - Tags[Tag].length );
                psz = NULL; // reset
            }

            switch( Tag )
            {
            case TOKEN_EOF:
                return Tag;

            case TOKEN_PRE:
                Tag = PreTagState( InputString );
                break;

            case TOKEN_BOLD:
                BlpSendEscapeBold(ScreenAttributes);
                DPRINT( OSC, ("[Bold]\n") );
                Tag = Lex( InputString );
                break;

            case TOKEN_FLASH:
                BlpSendEscapeFlash(ScreenAttributes);
                DPRINT( OSC, ("[Flash]\n") );
                Tag = Lex( InputString );
                break;

            case TOKEN_ENDFLASH:
            case TOKEN_ENDBOLD:
                BlpSendEscape(ScreenAttributes);
                DPRINT( OSC, ("[Normal]\n") );
                Tag = Lex( InputString );
                break;

            case TOKEN_FORM:
                Tag = FormTagState( InputString );
                break;

            case TOKEN_BREAK:
                ScreenX = LeftMargin;
                ScreenY++;
                if ( ScreenY > ScreenBottom ) {
                    ScreenY = ScreenBottom;
                }
                Tag = Lex( InputString );
                break;

            case TOKEN_TIPAREA:
                Tag = TipAreaTagState( InputString );
                break;

            case TOKEN_PARAGRAPH:
                Tag = ParagraphTagState( InputString );
                break;

            case TOKEN_ENDPARA:
                LeftMargin = ParaOldLeftMargin;
                RightMargin = ParaOldRightMargin;
                // Make sure the boundaries are realistic
                if ( LeftMargin < 1 ) {
                    LeftMargin = 1;
                }
                if ( RightMargin <= LeftMargin ) {
                    RightMargin = LeftMargin + 1;
                }
                if ( RightMargin < 1 ) {
                    RightMargin = 80;
                }
                // always simulate a <BR>
                ScreenY++;
                if ( ScreenY > ScreenBottom ) {
                    ScreenY = ScreenBottom;
                }
                ScreenX = LeftMargin;
                Tag = Lex( InputString );
                break;

            case TOKEN_ENDBODY:
                return Tag; // exit state

            }
            break;
        }
    }
    return Tag;
}

//
// BodyTagState( )
//
enum TOKENS
BodyTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;
    PCHAR psz;

    TraceFunc( "BodyTagState( )\n" );
    
    // get tag arguments
    for( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) )
    {
        switch( Tag )
        {
        case TOKEN_LEFT:
            psz = *InputString;
            // skip any spaces
            while( *psz && *psz == 32 )
                psz++;
            *InputString = psz;
            LeftMargin = GetInteger( InputString );
            DPRINT( OSC, ("[LeftMargin = %u]\n", LeftMargin) );
            break;

        case TOKEN_RIGHT:
            psz = *InputString;
            // skip any spaces
            while( *psz && *psz == 32 )
                psz++;
            *InputString = psz;
            RightMargin = GetInteger( InputString );
            DPRINT( OSC, ("[RightMargin = %u]\n", RightMargin) );
            break;

        case TOKEN_EOF:
            return Tag;
        }
    }

    if ( ScreenX >= RightMargin ) {
        ScreenY++;
        if ( ScreenY > ScreenBottom ) {
            ScreenY = ScreenBottom;
        }
    }
    if ( ScreenX >= RightMargin || ScreenX < LeftMargin ) {
        ScreenX = LeftMargin;
    }
    return ImpliedBodyTagState( InputString );
}

//
// KeyTagState( )
//
enum TOKENS
KeyTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;
    LPKEY_RESPONSE Key = NULL;
    PCHAR ScreenName = NULL;

    TraceFunc( "KeyTagState( )\n" );

    // get arguments
    for ( ; Tag != TOKEN_ENDTAG ; Tag = Lex( InputString ) )
    {
        switch (Tag)
        {
        case TOKEN_ENTER:
            DPRINT( OSC, ("[Key Enter]\n") );
            EnterKey = (LPKEY_RESPONSE) OscHeapAlloc( sizeof(KEY_RESPONSE) );
            if ( !EnterKey )
                break;
            Key = EnterKey;
            Key->ScreenName = NULL;
            Key->Action = ACTION_NOP;
            break;

        case TOKEN_F1:
            DPRINT( OSC, ("[Key F1]\n") );
            F1Key = (LPKEY_RESPONSE) OscHeapAlloc( sizeof(KEY_RESPONSE) );
            if ( !F1Key )
                break;
            Key = F1Key;
            Key->ScreenName = NULL;
            Key->Action = ACTION_NOP;
            break;

        case TOKEN_F3:
            DPRINT( OSC, ("[Key F3]\n") );
            F3Key = (LPKEY_RESPONSE) OscHeapAlloc( sizeof(KEY_RESPONSE) );
            if ( !F3Key )
                break;
            Key = F3Key;
            Key->ScreenName = NULL;
            Key->Action = ACTION_NOP;
            break;

        case TOKEN_ESC:
            DPRINT( OSC, ("[Key Escape]\n") );
            EscKey = (LPKEY_RESPONSE) OscHeapAlloc( sizeof(KEY_RESPONSE) );
            if ( !EscKey )
                break;
            Key = EscKey;
            Key->ScreenName = NULL;
            Key->Action = ACTION_NOP;
            break;

        case TOKEN_HREF:
            if ( Key ) {
                Key->Action = ACTION_JUMP;
                Key->ScreenName = GetString( InputString );
                if ( Key->ScreenName )
                    DPRINT( OSC, ("[Key Action: JUMP to '%s.OSC']\n", Key->ScreenName) );
            }
            break;

        case TOKEN_ACTION:
            if ( Key ) {
                PCHAR pAction = GetString( InputString );
                if ( !pAction )
                    break;
                if ( Lexstrcmpni( pAction, "REBOOT", 6 ) == 0 ) {
                    DPRINT( OSC, ("[Key Action: REBOOT]\n") );
                    Key->Action = ACTION_REBOOT;
                } else {
                    DPRINT( OSC, ("[Key Action?] %s\n", pAction) );
                }
                OscHeapFree( pAction );
            }
            break;

        case TOKEN_EOF:
            return Tag;
        }
    }
    return Tag;
}

//
// MetaTagState( )
//
enum TOKENS
MetaTagState(
    IN PCHAR * InputString
    )
{
    enum TOKENS Tag = TOKEN_START;

    TraceFunc( "MetaTagState( )\n" );
    // get tag arguments
    while ( Tag != TOKEN_ENDTAG )
    {
        // KB: All items in this switch statment must have Tag returned
        //     to them from a function call or must call Lex( ) to get
        //     the next Tag.
        switch (Tag)
        {
        case TOKEN_EOF:
            return Tag;

        case TOKEN_KEY:
            Tag = KeyTagState( InputString );
            break;

        case TOKEN_SERVER:
            DPRINT( OSC, ("[Server Meta - ignored]\n") );
            // ignore server side METAs
            while ( Tag != TOKEN_EOF && Tag != TOKEN_ENDTAG )
            {
                Tag = Lex( InputString );
            }
            break;

#if defined(PLEASE_WAIT)
        case TOKEN_WAITMSG:
            {
                if ( PleaseWaitMsg )
                {
                    OscHeapFree( PleaseWaitMsg );
                }

                PleaseWaitMsg = GetString( InputString );
                if ( !PleaseWaitMsg )
                    break;
                Tag = Lex( InputString );

                DPRINT( OSC, ("[WaitMsg: '%s'\n", PleaseWaitMsg ) );
            }
            break;
#endif

        case TOKEN_ACTION:
            {
                PCHAR pAction = GetString( InputString );
                if ( !pAction )
                    break;
                if ( Lexstrcmpni( pAction, "LOGIN", 5 ) == 0 ) {
                    DPRINT( OSC, ("[Screen Action: LOGIN]\n") );
                    LoginScreen = TRUE;
                } else if ( Lexstrcmpni( pAction, "AUTOENTER", 9 ) == 0 ) {
                    DPRINT( OSC, ("[Screen Action: AUTOENTER]\n") );
                    AutoEnter = TRUE;
                } else {
                    DPRINT( OSC, ("[Screen Action?] %s\n", pAction) );
                }
                OscHeapFree( pAction );
            }
            // fall thru

        default:
            Tag = Lex( InputString );
            break;
        }

    }
    return Tag;
}

//
// OSCMLTagState( )
//
enum TOKENS
OSCMLTagState(
    IN PCHAR * InputString
    )
{
#ifdef HEADLESS_SRV
    ULONG y;
#endif
    enum TOKENS Tag = TOKEN_START;

    TraceFunc( "OSCMLTagState( )\n" );

    BlpSendEscape(ScreenAttributes);
    BlpClearScreen();

    ScreenX = LeftMargin;
    ScreenY = SCREEN_TOP;

    while ( Tag != TOKEN_EOF )
    {
        switch (Tag)
        {
        case TOKEN_TITLE:
            Tag = TitleTagState( InputString );
            break;

        case TOKEN_FOOTER:
            Tag = FooterTagState( InputString );
            break;

        case TOKEN_META:
            Tag = MetaTagState( InputString );
            break;

        case TOKEN_BODY:
            Tag = BodyTagState( InputString );
            break;

        case TOKEN_ENDHTML:
            return Tag; // exit state

        default:
            Tag = Lex( InputString );
            break;
        }
    }
    return Tag;
}

// **************************************************************************
//
// "User" Section
//
// **************************************************************************


//
// ProcessEmptyScreen( )
//
// Process a screen that has no input controls
//
CHAR
ProcessEmptyScreen(
    OUT PCHAR OutputString
    )
{
    ULONG Key;
    UCHAR KeyAscii;

    TraceFunc("ProcessEmptyScreen()\n");

    while (TRUE) {

#ifdef EFI
        //
        // disable EFI watchdog when waiting for user response
        //
        DisableEFIWatchDog();
#endif
        do {

            Key = BlpGetKey();

        } while (Key == 0);
#ifdef EFI
        // 
        // reset efi watchdog
        //
        SetEFIWatchDog(EFI_WATCHDOG_TIMEOUT);
#endif

        KeyAscii = (UCHAR)(Key & (ULONG)0xff);

        // If it is enter/esc/F1/F3, check if the screen expects that.

        if ( Key == F1_KEY ) {
            if ( F1Key ) {
                SpecialAction = F1Key->Action;
                if ( F1Key->ScreenName ) {
                    strcpy( OutputString, F1Key->ScreenName );
                    strcat( OutputString, "\n" );
                }
                return KeyAscii;
            }

        } else if ( Key == F3_KEY ) {
            if ( F3Key ) {
                SpecialAction = F3Key->Action;
                if ( F3Key->ScreenName ) {
                    strcpy( OutputString, F3Key->ScreenName );
                    strcat( OutputString, "\n" );
                }
                return KeyAscii;
            }

#if defined(_BUILDING_OSDISP_)
        } else if ( Key  == F5_KEY ) {
            SpecialAction = ACTION_REFRESH;
            return KeyAscii;
#endif

        } else if ( KeyAscii == (UCHAR)(ESCAPE_KEY & 0xFF) ) {
            if ( EscKey ) {
                SpecialAction = EscKey->Action;
                if ( EscKey->ScreenName ) {
                    strcpy( OutputString, EscKey->ScreenName );
                    strcat( OutputString, "\n" );
                }
                return KeyAscii;
            }
        } else {
            // assume any other key is the Enter key
            if ( EnterKey ) {
                SpecialAction = EnterKey->Action;
                if ( EnterKey->ScreenName ) {
                    strcpy( OutputString, EnterKey->ScreenName );
                    strcat( OutputString, "\n" );
                }
                return KeyAscii;
            }
        }
    }
}


//
// ProcessInputControl( )
//
ULONG
ProcessInputControl(
    LPINPUTSTRUCT Input
    )
{
    CHAR InputBuffer[ MAX_INPUT_BUFFER_LENGTH ];
    int MaxLength;
    int CurrentLength;
    ULONG Key;
    UCHAR KeyAscii;

    TraceFunc("ProcessInputControl()\n");

    //
    // variable types are not actually printed or processed.
    // return TAB_KEY to move to the next available input control
    //
    if ((Input->Type & CT_VARIABLE) == CT_VARIABLE) {
        return TAB_KEY;
    }

    if ( Input->Value ) {
        CurrentLength = strlen( Input->Value );
        strcpy( InputBuffer, Input->Value );
        OscHeapFree( Input->Value );
        Input->Value = NULL;
    } else {
        CurrentLength = 0;
        InputBuffer[0] = '\0';
    }

    MaxLength = Input->Size;
    if ( Input->MaxLength ) {
        MaxLength = Input->MaxLength;
    }

    // paranoid
    if ( CurrentLength > MaxLength ) {
        CurrentLength = MaxLength;
        InputBuffer[CurrentLength] = '\0';
    }

    if (Input->CurrentPosition > CurrentLength ) {
        Input->CurrentPosition = CurrentLength;
    }

    // paint the "[ .... ]"
    BlpSendEscapeBold( ScreenAttributes );
    BlpPositionCursor( Input->X, Input->Y );
    PRINT(TEXT("["), 1*sizeof(TCHAR));
    BlpPositionCursor( Input->X + Input->Size + BRACKETS, Input->Y );
    PRINT(TEXT("]") ,1*sizeof(TCHAR));
    BlpSendEscape( ScreenAttributes );

    //
    // Let the user type in a string, showing the text at the current
    // location. Returns the key used to exit (so we can distinguish
    // enter and tab).
    //
#ifdef EFI
    // 
    // disable efi watchdog
    //
    DisableEFIWatchDog();
#endif
    while (TRUE) {
        int DrawSize;

        // Get a keystroke -- this returns (from exp.asm):
        //
        // If no key is available, returns 0 (which BlpGetKeyWithBlink hides)
        //
        // If ASCII character is available, LSB 0 is ASCII code
        //                                  LSB 1 is keyboard scan code
        // If extended character is available, LSB 0 is extended ASCII code
        //                                     LSB 1 is keyboard scan code
        //
        // NOTE: For extended keys LSB 0 seems to be 0, not the ASCII code
        // (which makes sense since they have no ASCII codes).

        if ( (Input->Type & CT_PASSWORD) && InputBuffer[Input->CurrentPosition] )
        {
            Key = BlpGetKeyWithBlink( Input->X + Input->CurrentPosition + 2 - Input->FirstVisibleChar,
                                      Input->Y,
                                      '*' );
        } else {
            Key = BlpGetKeyWithBlink( Input->X + Input->CurrentPosition + 2 - Input->FirstVisibleChar,
                                      Input->Y,
                                      InputBuffer[Input->CurrentPosition] );
        }

#if 0
        // TEMP: Show value of any key pressed near the bottom of the screen

        ARC_DISPLAY_INVERSE_VIDEO();
        ARC_DISPLAY_POSITION_CURSOR(0, 20);
        BlPrint(TEXT("%x\n"), Key);
        ARC_DISPLAY_ATTRIBUTES_OFF();
#endif

        KeyAscii = (UCHAR)(Key & (ULONG)0xff);

        // If it is enter/esc/tab/backtab/F1/F3, then we are done.

        if ((Key == BACKTAB_KEY) || (Key == F1_KEY) || (Key == F3_KEY) ||
            (KeyAscii == ENTER_KEY) || (KeyAscii == TAB_KEY) || 
            (KeyAscii == (UCHAR)(ESCAPE_KEY & 0xFF)) ||
            (Key == DOWN_ARROW) || (Key == UP_ARROW) || (Key == F5_KEY)) {
            break;
        }

        // If it is backspace, then go back one character.

        if ( KeyAscii == (UCHAR)(BKSP_KEY & 0xFF)
          && Input->CurrentPosition != 0
          && CurrentLength != 0 ) {
            Input->CurrentPosition--;
            memcpy( &InputBuffer[Input->CurrentPosition],
                    &InputBuffer[Input->CurrentPosition+1],
                    CurrentLength - Input->CurrentPosition + 1 );
            CurrentLength--;

            if ( Input->CurrentPosition <= Input->FirstVisibleChar ) {
                Input->FirstVisibleChar -= Input->Size / 2;
                if ( Input->FirstVisibleChar < 0 ) {
                    Input->FirstVisibleChar = 0;
                }
            }
        }

        if ( Key == LEFT_KEY ) {
            Input->CurrentPosition--;
            if ( Input->CurrentPosition < 0 ) {
                Input->CurrentPosition = 0;
            }
        }

        if ( Key == RIGHT_KEY && Input->CurrentPosition < CurrentLength ) {
            Input->CurrentPosition++;
        }

        if ( Key == END_KEY ) {
            Input->CurrentPosition = CurrentLength;
        }

        if ( Key == HOME_KEY ) {
            Input->CurrentPosition = 0;
        }

        if ( Key == DEL_KEY
          && CurrentLength != 0
          && Input->CurrentPosition != CurrentLength ) {
            memcpy( &InputBuffer[Input->CurrentPosition],
                    &InputBuffer[Input->CurrentPosition+1],
                    CurrentLength - Input->CurrentPosition + 1 );

            CurrentLength--;
        }

        if ( Key == INS_KEY ) {
            InsertMode = 1 - InsertMode;
        }

        // For now allow any printable character

        if ((KeyAscii >= ' ') && (KeyAscii <= '~')) {

            //
            // If we are at the maximum, then don't allow it.
            //
            if (Input->CurrentPosition > MaxLength || CurrentLength >= MaxLength ) {
                continue;
            }

            if ( !InsertMode ) {
                // add or replace a character
                InputBuffer[Input->CurrentPosition] = KeyAscii;
                Input->CurrentPosition++;
                if ( Input->CurrentPosition > CurrentLength ) {
                    CurrentLength++;
                    InputBuffer[CurrentLength] = '\0';
                }
            } else {
                // insert character
                memmove( &InputBuffer[Input->CurrentPosition+1],
                         &InputBuffer[Input->CurrentPosition],
                         CurrentLength - Input->CurrentPosition );
                CurrentLength++;
                InputBuffer[CurrentLength] = '\0';
                InputBuffer[Input->CurrentPosition] = KeyAscii;
                Input->CurrentPosition++;
            }
        }

        if ( Input->CurrentPosition > Input->FirstVisibleChar + Input->Size ) {
            Input->FirstVisibleChar = Input->CurrentPosition - Input->Size;
        }

        //
        // Scroll Adjuster Section
        //

        DrawSize = Input->Size + 1;

        // Paranoid
        if ( Input->CurrentPosition < Input->FirstVisibleChar ) {
            Input->FirstVisibleChar = Input->CurrentPosition;
        }

        BlpPositionCursor( Input->X + 1, Input->Y );
        if ( Input->FirstVisibleChar <= 0 ) {
            Input->FirstVisibleChar = 0;
            PRINT( SpaceString, 1*sizeof(TCHAR) );
        } else {
            PRINT( TEXT("<"), 1*sizeof(TCHAR) );
        }

        if ( DrawSize > CurrentLength - Input->FirstVisibleChar ) {
            DrawSize = CurrentLength - Input->FirstVisibleChar;
        }

        DPRINT( OSC, ("CurrentPosition: %u\tFirstVisibleChar:%u\tCurrentLength:%u\tDrawSize:%u\n",
            Input->CurrentPosition, Input->FirstVisibleChar, CurrentLength, DrawSize ) );

        if ( Input->Type & CT_PASSWORD ) {
            int i;

            for( i = Input->FirstVisibleChar; i < Input->FirstVisibleChar + DrawSize; i++ )
            {
                PRINT( TEXT("*"), 1*sizeof(TCHAR) );
            }

            PRINT( SpaceString, 1*sizeof(TCHAR) );
        } else {
#ifdef UNICODE
            int i;
            for (i = 0; i < DrawSize; i++) {
                WCHAR wc = (WCHAR)InputBuffer[Input->FirstVisibleChar+i];
                PRINT( &wc, 1*sizeof(WCHAR));
            }
#else
            PRINT( &InputBuffer[Input->FirstVisibleChar], DrawSize );
#endif
            PRINT( SpaceString, 1*sizeof(TCHAR) );
            break;
        }

        BlpPositionCursor( Input->X + Input->Size + BRACKETS - 1, Input->Y );
        if ( Input->FirstVisibleChar + DrawSize < CurrentLength
          && CurrentLength > Input->Size ) {
            PRINT( TEXT(">"), 1*sizeof(TCHAR) );
        } else {
            PRINT( SpaceString, 1*sizeof(TCHAR) );
        }
    }
#ifdef EFI
    // 
    // reset EFI watchdog
    //
    SetEFIWatchDog(EFI_WATCHDOG_TIMEOUT);
#endif

    // copy the buffer
    Input->Value = OscHeapAlloc( CurrentLength + 1 );
    if ( Input->Value ) {
        memcpy( Input->Value, InputBuffer, CurrentLength + 1 );
    }

    // UN-paint the "[ .... ]"
    BlpPositionCursor( Input->X, Input->Y );
    PRINT(SpaceString, 1*sizeof(TCHAR));
    BlpPositionCursor( Input->X + Input->Size + BRACKETS, Input->Y );
    PRINT(TEXT(" ") ,1*sizeof(TCHAR));

    // If we exited on a standard key return the ASCII value, otherwise
    // the full key value.

    if (KeyAscii != 0) {
        return (ULONG)KeyAscii;
    } else {
        return Key;
    }

}

//
// ShowSelectedOptions( )
//
void
ShowSelectedOptions(
    LPSELECTSTRUCT Select,
    LPOPTIONSTRUCT Option,
    int            YPosition,
    BOOLEAN        Hovering
    )
{
    TraceFunc( "ShowSelectedOptions( )\n" );
    if ( Option->Flags == OF_SELECTED ) {
        BlpSendEscapeBold( ScreenAttributes );
    }

    if ( Hovering == TRUE ) {
        BlpSendEscapeReverse( ScreenAttributes );
    }

    // Erase
    BlpPositionCursor( Select->X, YPosition );
    PRINT( SpaceString, Select->Width*sizeof(TCHAR) );

    // Draw
    BlpPositionCursor( Select->X, YPosition );
    if ( Option->Displayed )
#ifdef UNICODE
        {
        ULONG i;
        WCHAR wc;
            for (i = 0; i< strlen(Option->Displayed); i++) {
                wc = (WCHAR)(Option->Displayed)[i];
                PRINT( &wc, sizeof(WCHAR));
            }
        }
#else
        PRINTL( Option->Displayed );
#endif

    if ( Option->Value )
        DPRINT( OSC, ("[Option Y=%u] %s %s\n", YPosition, Option->Value, (Hovering ? "HIGHLITED" : "")) );

    BlpSendEscape( ScreenAttributes );

    if ( TipArea && Hovering == TRUE ) {
        // Draw help area
        int SaveLeftMargin = LeftMargin;
        int SaveRightMargin = RightMargin;
        int SaveScreenY = ScreenY;
        int SaveScreenX = ScreenX;
        int SaveScreenBottom = ScreenBottom;

        // Set the drawing area
        ScreenX = TipArea->X;
        ScreenY = TipArea->Y;
        LeftMargin = TipArea->LeftMargin;
        RightMargin = TipArea->RightMargin;
        ScreenBottom = TipArea->Y + TipArea->Size;

        // Clear the old help text out
        BlpPositionCursor( TipArea->X, TipArea->Y );
        PRINT( SpaceString, (TipArea->RightMargin - TipArea->X)*sizeof(TCHAR) );

        for ( YPosition = TipArea->Y + 1; YPosition < ScreenBottom ; YPosition++ )
        {
            BlpPositionCursor( TipArea->LeftMargin, YPosition );
            PRINT( SpaceString, (TipArea->RightMargin - TipArea->LeftMargin)*sizeof(TCHAR) );
        }

        // Print it!
        DPRINT( OSC, ("[Options Tip X=%u Y=%u Left=%u Right=%u Bottom=%u] %s\n",
            ScreenX, ScreenY, LeftMargin, RightMargin, ScreenBottom, Option->Tip) );
        BlpPrintString( Option->Tip, Option->EndTip );

        // Restore
        ScreenX = SaveScreenX;
        ScreenY = SaveScreenY;
        RightMargin = SaveRightMargin;
        LeftMargin = SaveLeftMargin;
        ScreenBottom = SaveScreenBottom;;
    }
}

//
// DrawSelectControl( )
//
// Select controls get drawn from the bottom up.
//
void
DrawSelectControl(
    LPSELECTSTRUCT Select,
    int OptionCount
    )
{
    LPOPTIONSTRUCT Option = Select->FirstVisibleSelection;

    TraceFunc( "DrawSelectControl( )\n" );

    ScreenY = Select->Y + ( OptionCount < Select->Size ? OptionCount : Select->Size ) - 1;

    while ( Option )
    {
        if ( Option->Type & CT_OPTION ) {
            BOOLEAN b = (Select->CurrentSelection == Option);
            ShowSelectedOptions( Select, Option, ScreenY,  b );
            ScreenY--;
        }

        if ( ScreenY < Select->Y || Option->Next == Select )
            break;

        Option = Option->Next;
    }
    
}

//
// ProcessSelectControl( )
//
ULONG
ProcessSelectControl(
    LPSELECTSTRUCT Select
    )
{
    ULONG Key;
    int   OptionCount = 0;
    LPOPTIONSTRUCT Option;
    int   fMultipleControls = FALSE;

    TraceFunc("ProcessSelectControl()\n");

#ifdef EFI
    //
    // disable EFI watchdog 
    //
    DisableEFIWatchDog();
#endif

    // find out about the control
    Option = ScreenControls;
    while( Option )
    {
        if ( Option->Type & CT_OPTION ) {

            OptionCount++;

        } else if ( (Option->Type & CT_SELECT) == 0 ) {
            // not the only control on the screen
            DPRINT( OSC, ("[Select] Not the only control on the screen.\n") );
            fMultipleControls = TRUE;
        }

        if ( Option->Next == Select )
            break;

        Option = Option->Next;
    }
    // if this is the first thru and nothing else
    if ( !Select->CurrentSelection && Option ) {
        DPRINT( OSC, ("[Select] Setting CurrentSelection to the first item '%s'\n", Option->Value) );
        Select->CurrentSelection = Option;
    }
    // ensure the current selection is visible
EnsureSelectionVisible:
    if ( Select->Size < 2 ) {
        // single line - show the current selection
        Select->FirstVisibleSelection = Select->CurrentSelection;
    } else if ( OptionCount <= Select->Size ) {
        // the number of options is less than or equal to the size
        // of the dialog so simply set the first visible equal to
        // the last OPTION in the list.

        Select->FirstVisibleSelection = ScreenControls;
        while ( Select->FirstVisibleSelection )
        {
            if ( Select->FirstVisibleSelection->Type & CT_OPTION )
                break;

            Select->FirstVisibleSelection = Select->FirstVisibleSelection->Next;
        }

    } else {
        
        //
        // The number of options is greater than the display size so we
        // need to figure out the "best" bottom item.
        //
        ULONG Lines;
        ULONG Count;
        LPOPTIONSTRUCT TmpOption;

        //
        // Find the best FirstVisibleSelection if we already have previously chosen one.
        //
        Count = 0;
        if (Select->FirstVisibleSelection != NULL) {

            //
            // This code checks to see if the current selection is visible with the
            // current first visible selection.
            //
            TmpOption = ScreenControls;

            while (TmpOption->Next != Select) {

                if (TmpOption == Select->FirstVisibleSelection) {
                    Count++;
                } else if (Count != 0) {
                    Count++;
                }

                if (TmpOption == Select->CurrentSelection) {
                    break;
                }

                TmpOption = TmpOption->Next;


            }

            if (TmpOption->Next == Select) {
                Count++;
            }

            //
            // It is, so just display the list.
            //
            if ((Count != 0) && (Count <= (ULONG)(Select->Size))) {                
                goto EndFindVisibleSelection;
            }
            
            //
            // It is not visible, but since we have a FirstVisibleSelection, we can
            // move that around to make it visible.  
            //


            //
            // The current selection comes before the first visible one, so move
            // first visible to the current selection.
            //
            if (Count == 0) {
                Select->FirstVisibleSelection = Select->CurrentSelection;
                goto EndFindVisibleSelection;
            }

            //
            // Count is greater than the screen size, so we move up First visible
            // until count is the screen size.
            //
            TmpOption = ScreenControls;

            while (TmpOption->Next != Select) {

                if (TmpOption == Select->FirstVisibleSelection) {

                    Select->FirstVisibleSelection = TmpOption->Next;
                    Count--;

                    if (Count == (ULONG)(Select->Size)) {
                        break;
                    }

                }

                TmpOption = TmpOption->Next;

            }
            
            goto EndFindVisibleSelection;
        }

        //
        // There is no FirstVisibleSelection, so we choose one that places the current
        // selection near the top of the screen, displaying the first item, if possible.
        //

        TmpOption = Select->CurrentSelection;
        Lines = 0;
        Count = 0;

        //
        // Count the number of items before our current selection.
        //
        while (TmpOption->Next != Select) {

            TmpOption = TmpOption->Next;
            Lines++;

        }

        //
        // Subtract off that many items from what is left for below the selection.
        // 
        Lines = (ULONG)((Lines < (ULONG)(Select->Size)) ? Lines : Select->Size - 1);
        Lines = Select->Size - Lines - 1;

        //
        // If more than a screen before, make this the bottom and move on.
        //
        if (Lines == 0) {
            Select->FirstVisibleSelection = Select->CurrentSelection;
            goto EndFindVisibleSelection;
        }


        TmpOption = ScreenControls;

        //
        // Count the number of items below the current selection
        //
        while (TmpOption != Select->CurrentSelection) {

            TmpOption = TmpOption->Next;
            Count++;

        }

        if (Count < Lines) {
            
            //
            // Not enough items to fill the screen, use the last item.
            //
            Select->FirstVisibleSelection = ScreenControls;

        } else {
        
            //
            // Count back until we reach what will be our bottom item.
            //
            TmpOption = ScreenControls;

            while (Count != Lines) {

                TmpOption = TmpOption->Next;
                Count--;

            }

            Select->FirstVisibleSelection = TmpOption;

        }

    }

EndFindVisibleSelection:

    // paranoid
    if ( !Select->FirstVisibleSelection ) {
        Select->FirstVisibleSelection = ScreenControls;
    }

    while ( TRUE )
    {
        UCHAR KeyAscii = 0;

        DrawSelectControl( Select, OptionCount );
        Option = Select->CurrentSelection;  // remember this

        if ( OptionCount == 0
          || ( Select->AutoSelect == FALSE && OptionCount == 1 ))
        { // empty selection control or no AUTO select
            do {
                Key = BlpGetKey();
            } while ( Key == 0 );

            KeyAscii = (UCHAR)(Key & (ULONG)0xff);
        }
        else if ( OptionCount != 1 )
        { // more than one choice... do the usual
            ULONG CurrentTick, NewTick;
            int   TimeoutCounter = 0;

            // Show any help for this choice
            // BlpShowMenuHelp(psInfo, psInfo->Data[CurChoice].VariableName);

            CurrentTick = GET_COUNTER();
            do {
                Key = BlpGetKey();

                if ( Select->Timeout )
                {
                    NewTick = GET_COUNTER();
                    if ((NewTick < CurrentTick) || ((NewTick - CurrentTick) >= BLINK_RATE))
                    {
                        CHAR Buffer[4];
                        CurrentTick = NewTick;

                        TimeoutCounter++;

                        //
                        // TODO: Update the timer value displayed
                        //

                        if ( TimeoutCounter >= Select->Timeout )
                        {
                            Key = ENTER_KEY; // fake return
                            break;
                        }
                    }
                }

            } while (Key == 0);

            KeyAscii = (UCHAR)(Key & (ULONG)0xff);

            //
            // User pressed a key, so stop doing the timer
            //
            if ( Select->Timeout ) {

                Select->Timeout = 0;

                //
                // TODO: Erase the timer
                //
            }
        }
        else if ( !fMultipleControls ) // && OptionCount == 1
        { // only once choice... auto-accept it
            //
            // Fake return press....
            //
            DPRINT( OSC, ( "[Select] Auto accepting the only option available\n") );
            Key = KeyAscii = ENTER_KEY;
        }

        if ( Select->Flags & OF_MULTIPLE ) {
            if ( KeyAscii == 32 && Select->CurrentSelection) {
                if ( Select->CurrentSelection->Flags & OF_SELECTED ) {
                    Select->CurrentSelection->Flags &= ~OF_SELECTED;    // turn off
                } else {
                    Select->CurrentSelection->Flags |= OF_SELECTED;     // turn on
                }
            }
        } else {
            if ( KeyAscii == ENTER_KEY && Select->CurrentSelection ) {
                Select->CurrentSelection->Flags |= OF_SELECTED;         // turn on
            }
        }

        if ((Key == BACKTAB_KEY) || (Key == F1_KEY) || (Key == F3_KEY) ||
            (KeyAscii == ENTER_KEY) || (KeyAscii == TAB_KEY) || 
            (KeyAscii == (UCHAR)(ESCAPE_KEY & 0xFF)) ||
            (Key == F5_KEY)) {
            // Undraw the selection bar to give user feedback that something has
            // happened
            Select->CurrentSelection = NULL;
            DrawSelectControl( Select, OptionCount );
            break;
        }


        if ( OptionCount ) {

            if (Key == DOWN_ARROW) {
                DPRINT( OSC, ("[KeyPress] DOWN_ARROW\n") );

                Select->CurrentSelection = ScreenControls;

                while ( Select->CurrentSelection && Select->CurrentSelection->Next != Option )
                {
                    Select->CurrentSelection = Select->CurrentSelection ->Next;
                }

                if ( Select->CurrentSelection )
                    DPRINT( OSC, ("[Select] CurrentSelection = '%s'\n", Select->CurrentSelection->Value) );

                // paranoid
                if ( !Select->CurrentSelection )
                    Select->CurrentSelection = Option;

                goto EnsureSelectionVisible;

            } else if ( Key == UP_ARROW ) {
                DPRINT( OSC, ("[KeyPress] UP_ARROW\n") );

                if ( Select->CurrentSelection->Next != Select ) {
                    Select->CurrentSelection = Select->CurrentSelection->Next;
                    DPRINT( OSC, ("[Select] CurrentSelection = '%s'\n", Select->CurrentSelection->Value) );
                }

                // paranoid
                if ( !Select->CurrentSelection )
                    Select->CurrentSelection = Option;

                goto EnsureSelectionVisible;

            } else if ( Key == END_KEY ) {
                DPRINT( OSC, ("[KeyPress] END_KEY\n") );

                Select->CurrentSelection = ScreenControls;

                while( Select->CurrentSelection && (Select->CurrentSelection->Type & CT_OPTION) == 0 )
                {
                    Select->CurrentSelection = Select->CurrentSelection->Next;
                }

                if ( Select->CurrentSelection )
                    DPRINT( OSC, ("[Select] CurrentSelection = '%s'\n", Select->CurrentSelection->Value) );

                // paranoid
                if ( !Select->CurrentSelection )
                    Select->CurrentSelection = Option;

                goto EnsureSelectionVisible;

            } else if ( Key == HOME_KEY ) {
                DPRINT( OSC, ("[KeyPress] HOME_KEY\n") );

                Select->CurrentSelection = ScreenControls;

                while ( Select->CurrentSelection && Select->CurrentSelection->Next != Select )
                {
                    Select->CurrentSelection = Select->CurrentSelection ->Next;
                }

                if ( Select->CurrentSelection )
                    DPRINT( OSC, ("[Select] CurrentSelection = '%s'\n", Select->CurrentSelection->Value) );

                // paranoid
                if ( !Select->CurrentSelection )
                    Select->CurrentSelection = Option;

                goto EnsureSelectionVisible;

            }
        }
    }

#ifdef EFI
    //
    // reset watchdog
    //
    SetEFIWatchDog(EFI_WATCHDOG_TIMEOUT);
#endif
    return Key;
}


//
// BlFixupLoginScreenInputs( )
//
// On an input screen, split a USERNAME that has an @ in it, keeping
// the part before the @ in USERNAME and moving the part after to
// USERDOMAIN.
//
void
BlFixupLoginScreenInputs(
    )
{
    LPCONTROLSTRUCT CurrentControl;
    LPINPUTSTRUCT UserNameControl = NULL;
    LPINPUTSTRUCT UserDomainControl = NULL;
    PCHAR AtSign;

    //
    // First loop through and find the USERNAME and USERDOMAIN input
    // controls.
    //

    CurrentControl = ScreenControls;
    while( CurrentControl ) {

        LPINPUTSTRUCT Input = (LPINPUTSTRUCT) CurrentControl;

        if ( ( Input->Type & CT_TEXT ) && ( Input->Name != NULL ) ) {
            if ( Lexstrcmpni( Input->Name, "USERNAME", 8 ) == 0 ) {
                UserNameControl = Input;
            } else if ( Lexstrcmpni( Input->Name, "USERDOMAIN", 10 ) == 0 ) {
                UserDomainControl = Input;
            }
        }
        CurrentControl = CurrentControl->Next;
    }

    //
    // If we found them, fix them up if necessary.
    //

    if ( ( UserNameControl != NULL ) &&
         ( UserNameControl->Value != NULL ) &&
         ( UserDomainControl != NULL) ) {

        AtSign = strchr(UserNameControl->Value, '@');
        if (AtSign != NULL) {
            *AtSign = '\0';   // terminate UserNameControl->Value before the @
            if ( UserDomainControl->Value != NULL ) {
                OscHeapFree( UserDomainControl->Value );  // throw away old domain
            }
            UserDomainControl->Value = OscHeapAlloc( strlen(AtSign+1) + 1 );
            if ( UserDomainControl->Value != NULL ) {
                strcpy(UserDomainControl->Value, AtSign+1);  // copy part after the @
            }
        }
    }
}


//
// ProcessControlResults( )
//
// Process a screen that has input controls
//
void
ProcessControlResults(
    IN PCHAR OutputString
    )
{
    LPCONTROLSTRUCT CurrentControl;
    LPCONTROLSTRUCT LastControl;

    BOOLEAN CheckAdminPassword_AlreadyChecked = FALSE;
    BOOLEAN CheckAdminPasswordConfirm_AlreadyChecked = FALSE;
    
    // start clean
    OutputString[0] = '\0';

    if ( EnterKey ) {
        SpecialAction = EnterKey->Action;
        if ( EnterKey->ScreenName ) {
            strcpy( OutputString, EnterKey->ScreenName );
            strcat( OutputString, "\n" );
        }
    }

    if ( LoginScreen == TRUE ) {
        SpecialAction = ACTION_LOGIN;
        UserName[0]   = '\0';
        Password[0]   = '\0';
        DomainName[0] = '\0';
        BlFixupLoginScreenInputs();  // split username with @ in it
        AuthenticationType = OSCHOICE_AUTHENETICATE_TYPE_NTLM_V1;
    }

    CurrentControl = ScreenControls;
    while( CurrentControl ) {

        BOOLEAN CheckAdminPasswordConfirm = FALSE;
        BOOLEAN CheckAdminPassword = FALSE;
        
        switch( CurrentControl->Type & (CT_TEXT | CT_PASSWORD | CT_RESET | CT_SELECT | CT_OPTION | CT_VARIABLE))
        {
        case CT_TEXT:
        case CT_PASSWORD:
            {
                LPINPUTSTRUCT Input = (LPINPUTSTRUCT) CurrentControl;
                BOOLEAN LocalOnly;
                 
                DPRINT( OSC, ("About to check a password.\n") );
                
                if ( (Input->Type & (CT_PASSWORD)) &&
                     (Input->Type & (CT_LOCAL)) &&
                     Input->Name ) {

                    LocalOnly = TRUE;
                    
                    if( _strnicmp(Input->Name, "*ADMINISTRATORPASSWORDCONFIRM", 29) == 0 ) {
                        CheckAdminPasswordConfirm = TRUE;
                        CheckAdminPasswordConfirm_AlreadyChecked = TRUE;
                        DPRINT( OSC, ("About to check the ADMINISTRATORPASSWORDCONFIRM\n") );
                    } else if( _strnicmp( Input->Name, "*ADMINISTRATORPASSWORD", 22) == 0 ) {
                        CheckAdminPassword = TRUE;
                        CheckAdminPassword_AlreadyChecked = TRUE;
                        DPRINT( OSC, ("About to check the ADMINISTRATORPASSWORD\n") );
                    } else {
                        DPRINT( OSC, ("It's a local password, but not Admin or AdminConfirm.\n") );
                    }
                
                } else {
                    LocalOnly = FALSE;
                    DPRINT( OSC, ("It's NOT a local password.\n") );
                }

                DPRINT( 
                    OSC, 
                    ("variable %s will%sbe transmitted to the server.\n", 
                    Input->Name,
                    LocalOnly ? " not " : " " ) );
                

                if (Input->Name && !LocalOnly ) {               
                    strcat( OutputString, Input->Name );
                    strcat( OutputString, "=" );
                }

                if ( (Input->Value) && (Input->Encoding == ET_OWF)) {

                    PCHAR TmpLmOwfPassword = NULL;
                    PCHAR TmpNtOwfPassword = NULL;
                    CHAR TmpHashedPW[(LM_OWF_PASSWORD_SIZE+NT_OWF_PASSWORD_SIZE+2)*2];
                    
                    UNICODE_STRING TmpNtPassword;
                    PWCHAR UnicodePassword;
                    ULONG PasswordLen, i;
                    PCHAR OutputLoc;
                    CHAR c;

                    DPRINT( OSC, ("This entry has ET_OWF tagged.\n") );
                    
                    PasswordLen = strlen(Input->Value);

                    UnicodePassword = (PWCHAR)OscHeapAlloc(PasswordLen * sizeof(WCHAR));
                    TmpLmOwfPassword = (PCHAR)OscHeapAlloc(LM_OWF_PASSWORD_SIZE);
                    TmpNtOwfPassword = (PCHAR)OscHeapAlloc(NT_OWF_PASSWORD_SIZE);

                    if( (UnicodePassword != NULL) &&
                        (TmpLmOwfPassword != NULL) &&
                        (TmpNtOwfPassword != NULL) ) {

                        //
                        // Do a quick conversion of the password to Unicode.
                        //
                    
                        TmpNtPassword.Length = (USHORT)(PasswordLen * sizeof(WCHAR));
                        TmpNtPassword.MaximumLength = TmpNtPassword.Length;
                        TmpNtPassword.Buffer = UnicodePassword;
                    
                        for (i = 0; i < PasswordLen; i++) {
                            UnicodePassword[i] = (WCHAR)(Input->Value[i]);
                        }
                    


                        BlOwfPassword(Input->Value, &TmpNtPassword, TmpLmOwfPassword, TmpNtOwfPassword);



                        //
                        // Output the two OWF passwords as hex chars.  If
                        // the value is the administrator password and
                        // should only be stored locally, then
                        // save it in our global variable.  Otherwise put 
                        // it in the output buffer.
                        //
                        OutputLoc = TmpHashedPW;


                        for (i = 0; i < LM_OWF_PASSWORD_SIZE; i++) {
                            c = TmpLmOwfPassword[i];
                            *(OutputLoc++) = rghex [(c >> 4) & 0x0F] ;
                            *(OutputLoc++) = rghex [c & 0x0F] ;
                        }
                        for (i = 0; i < NT_OWF_PASSWORD_SIZE; i++) {
                            c = TmpNtOwfPassword[i];
                            *(OutputLoc++) = rghex [(c >> 4) & 0x0F] ;
                            *(OutputLoc++) = rghex [c & 0x0F] ;
                        }
                        *OutputLoc = '\0';

                        DPRINT( OSC, ("Hashed Password: %s\n", TmpHashedPW) );

                        if (!LocalOnly) {
                            strcat(OutputString,TmpHashedPW);
                        } else {
                            
                            
                            if( CheckAdminPassword ) {
                                strcpy( AdministratorPassword,  TmpHashedPW );
                                DPRINT( OSC, ("AdministratorPassword 1: %s\n", AdministratorPassword) );
                            }
    
                            if( CheckAdminPasswordConfirm ) {
                                strcpy( AdministratorPasswordConfirm,  TmpHashedPW );
                                DPRINT( OSC, ("AdministratorPasswordConfirm 1: %s\n", AdministratorPasswordConfirm) );

                            }
                            
                            
#if 0
                            if (AdministratorPassword[0] != '\0') {
                                if (strcmp(
                                      AdministratorPassword, 
                                      TmpHashedPW)) {
                                    //
                                    // the passwords didn't match.  make the server
                                    // display MATCHPW.OSC and reset the admin password
                                    // for the next time around
                                    //
                                    DPRINT( 
                                        OSC, 
                                        ("Administrator passwords didn't match, force MATCHPW.OSC.\n" ) );

                                    strcpy( OutputString, "MATCHPW\n" );
                                    AdministratorPassword[0] = '\0';
                                } else {
                                    strncpy( 
                                        AdministratorPassword, 
                                        TmpHashedPW, 
                                        sizeof(AdministratorPassword)-1 );
                                }
                            }
#endif
                            OutputLoc = OutputString + strlen(OutputString);
                        }

                        OscHeapFree((PCHAR)UnicodePassword);
                        OscHeapFree(TmpLmOwfPassword);
                        OscHeapFree(TmpNtOwfPassword);
                    }

                } else {
                        
                    
                    DPRINT( OSC, ("This entry does NOT have ET_OWF tagged.\n") );
                    
                    if( LocalOnly ) {
                        //
                        // Load the appropriate password.
                        //
                        if( CheckAdminPassword ) {
                            strcpy( AdministratorPassword, (Input->Value ? Input->Value : "") );
                            DPRINT( OSC, ("I'm setting the Administrator password to %s\n", AdministratorPassword) );
                        }

                        if( CheckAdminPasswordConfirm ) {
                            strcpy( AdministratorPasswordConfirm, (Input->Value ? Input->Value : "") );
                            DPRINT( OSC, ("I'm setting the AdministratorConfirm password to %s\n", AdministratorPasswordConfirm) );
                        }
                    } else  {
                        strcat( OutputString, (Input->Value ? Input->Value : "") );
                    }
                }
                            
                //
                // If both passwords have been processed, check them to see if they match.
                //
                if( CheckAdminPassword_AlreadyChecked &&
                    CheckAdminPasswordConfirm_AlreadyChecked ) {

                    DPRINT( OSC, ("Both Admin and AdminConfirm passwords are set.  About to check if they match.\n") );
                    
                    if( strcmp( AdministratorPassword, AdministratorPasswordConfirm ) ) {

                        //
                        // the passwords didn't match.  make the server
                        // display MATCHPW.OSC and reset the admin password
                        // for the next time around
                        //
                        DPRINT( OSC, ("Administrator passwords didn't match, force MATCHPW.OSC.\n" ) );

                        strcpy( OutputString, "MATCHPW\n" );
                        AdministratorPassword[0] = '\0';
                        AdministratorPasswordConfirm[0] = '\0';
                    
                    } else {
                        DPRINT( OSC, ("Administrator passwords match.\n" ) );

                        //
                        // See if the Admin password is empty.  If so, then put our
                        // super-secret tag on the end to show everyone that it's really
                        // empty, not just uninitialized.
                        //
                        if( AdministratorPassword[0] == '\0' ) {

                            DPRINT( OSC, ("Administrator password is empty, so set our 'it is null' flag.\n" ) );
                            AdministratorPassword[OSC_ADMIN_PASSWORD_LEN-1] = 0xFF;
                        }
                    }
                }

                if ( SpecialAction == ACTION_LOGIN 
                     && (Input->Name != NULL) 
                     && (Input->Value != NULL) ) {
                    if ( Lexstrcmpni( Input->Name, "USERNAME", 8 ) == 0 ) {
                        strncpy( UserName, Input->Value, sizeof(UserName)-1 );
                        UserName[sizeof(UserName)-1] = '\0';
                    } else if ( Lexstrcmpni( Input->Name, "*PASSWORD", 9 ) == 0 ) {
                        strncpy( Password, Input->Value, sizeof(Password)-1 );
                        Password[sizeof(Password)-1] = '\0';
                    } else if ( Lexstrcmpni( Input->Name, "USERDOMAIN", 10 ) == 0 ) {
                        strncpy( DomainName, Input->Value, sizeof(DomainName)-1 );
                        DomainName[sizeof(DomainName)-1] = '\0';
                    }
                }

                if (!LocalOnly) {
                    strcat( OutputString, "\n" );
                }
            }
            break;

        case CT_SELECT:
            {
                CHAR NotFirst = FALSE;
                LPOPTIONSTRUCT Option = ScreenControls;
                LPSELECTSTRUCT Select = (LPSELECTSTRUCT) CurrentControl;
                if ( Select->Name ) {
                    strcat( OutputString, Select->Name );
                    strcat( OutputString, "=" );
                }

                while( Option && Option->Type == CT_OPTION )
                {
                    if ( Option->Flags == OF_SELECTED ) {
                        if ( NotFirst ) {
                            strcat( OutputString, "+" );
                        }

                        if ( Option->Value ) {
                            strcat( OutputString, Option->Value );
                            NotFirst = TRUE;
                        }
                    }

                    Option = Option->Next;
                }
                strcat( OutputString, "\n" );
            }
            break;
        case CT_VARIABLE:
            {
                LPINPUTSTRUCT Input = (LPINPUTSTRUCT) CurrentControl;
                strcat( OutputString, Input->Name );
                strcat( OutputString, "=" );
                strcat( OutputString, Input->Value );
                strcat( OutputString, "\n" );

                if (SpecialAction == ACTION_LOGIN) {
                    //
                    // check if ntlm v2 is enabled on the server.
                    //
                    if ((strcmp(Input->Name,"NTLMV2Enabled") == 0) &&
                        (strcmp(Input->Value,"1") == 0)) {
                        AuthenticationType = OSCHOICE_AUTHENETICATE_TYPE_NTLM_V2;
                    }

                    //
                    // check if the server gave us the current file time
                    // we need this so that we can do ntlm v2 style
                    // authentication.
                    //
                    if (strcmp(Input->Name,"ServerUTCFileTime") == 0) {
                        SetFileTimeFromTimeString(
                                        Input->Value,
                                        &GlobalFileTime,
                                        &ArcTimeForUTCTime);
                    }
                }
            }
            break;
        }

        CurrentControl = CurrentControl->Next;
    }
}

//
// ProcessScreenControls( )
//
// Process a screen that has input controls
//
CHAR
ProcessScreenControls(
    OUT PCHAR OutputString
    )
{
    ULONG Key;
    UCHAR KeyAscii;
    LPCONTROLSTRUCT CurrentControl;
    LPCONTROLSTRUCT LastControl;

    TraceFunc("ProcessScreenControls()\n");

    // find the first control
    LastControl = ScreenControls;
    CurrentControl = ScreenControls; 
    while( LastControl ) {
        CurrentControl = LastControl;
        LastControl    = CurrentControl->Next;
    }

    while (TRUE) {

TopOfLoop:
        // show activation on the control
        switch( CurrentControl->Type & (CT_PASSWORD | CT_TEXT | CT_SELECT) )
        {
        case CT_PASSWORD:
        case CT_TEXT:
            Key = ProcessInputControl( (LPINPUTSTRUCT) CurrentControl );
            break;

        case CT_SELECT:
            Key = ProcessSelectControl( (LPSELECTSTRUCT) CurrentControl );
            break;

        default:
            // non-processing control - skip it
            CurrentControl = CurrentControl->Next;
            if ( !CurrentControl ) {
                CurrentControl = ScreenControls;
            }
            goto TopOfLoop;
        }

        LastControl = CurrentControl;

        KeyAscii = (UCHAR)(Key & (ULONG)0xff);

        // If it is enter/esc/F1/F3, check if the screen expects that.

        if ( Key == F1_KEY ) {

            DPRINT( OSC, ("[KeyPress] F1_KEY\n") );

            if ( F1Key ) {
                SpecialAction = F1Key->Action;
                if ( F1Key->ScreenName ) {
                    strcpy( OutputString, F1Key->ScreenName );
                    strcat( OutputString, "\n" );
                }
                return KeyAscii;
            }

        } else if ( Key == F3_KEY ) {

            DPRINT( OSC, ("[KeyPress] F3_KEY\n") );

            if ( F3Key ) {
                SpecialAction = F3Key->Action;
                if ( F3Key->ScreenName ) {
                    strcpy( OutputString, F3Key->ScreenName );
                    strcat( OutputString, "\n" );
                }
                return KeyAscii;
            }

#if defined(_BUILDING_OSDISP_)
        } else if ( Key == F5_KEY ) {
            SpecialAction = ACTION_REFRESH;
            return KeyAscii;
#endif

        } else if ( KeyAscii == (UCHAR)(ESCAPE_KEY & 0xFF) ) {

            DPRINT( OSC, ("[KeyPress] ESCAPE_KEY\n") );

            if ( EscKey ) {
                SpecialAction = EscKey->Action;
                if ( EscKey->ScreenName ) {
                    strcpy( OutputString, EscKey->ScreenName );
                    strcat( OutputString, "\n" );
                }
                return KeyAscii;
            }

        } else if ( KeyAscii == TAB_KEY || Key == DOWN_ARROW ) {

            DPRINT( OSC, ("[KeyPress] TAB_KEY or DOWN_ARROW\n") );

            CurrentControl = ScreenControls;

            while ( CurrentControl->Next != LastControl &&  // next is current one, so stop
                    CurrentControl->Next != NULL )          // at end of list, so we must have been at
                                                            //  the start, so stop here to loop around
            {
                CurrentControl = CurrentControl->Next;
            }

        } else if ( Key == BACKTAB_KEY || Key == UP_ARROW ) {

            DPRINT( OSC, ("[KeyPress] BACKTAB_KEY or UP_ARROW\n") );

            CurrentControl = CurrentControl->Next;
            if (!CurrentControl) {
                CurrentControl = ScreenControls;   // loop around if needed
            }

        } else if ( KeyAscii == ENTER_KEY ) {

            DPRINT( OSC, ("[KeyPress] ENTER_KEY\n") );

            ProcessControlResults( OutputString );

            return KeyAscii;
        }

        if ( !CurrentControl ) {
            CurrentControl = LastControl;
        }
    }

}

//
// BlProcessScreen( )
//
CHAR
BlProcessScreen(
    IN PCHAR InputString,
    OUT PCHAR OutputString
    )
{
#ifdef HEADLESS_SRV
    ULONG y;
#endif
    CHAR chReturn;
    enum TOKENS Tag;

#ifdef _TRACE_FUNC_
    TraceFunc( "BlProcessScreen( " );
    DPRINT( OSC, ("InputString = 0x%08x, OutputString = 0x%08x )\n", InputString, OutputString) );
#endif

    // reset our "heap"
    OscHeapInitialize( );

    // reset the screen variables
    ScreenAttributes = WhiteOnBlueAttributes;
    SpecialAction    = ACTION_NOP;
    LeftMargin       = 1;
    RightMargin      = 80;
    ScreenX          = LeftMargin;
    ScreenY          = SCREEN_TOP;
    F1Key            = NULL;
    F3Key            = NULL;
    EnterKey         = NULL;
    EscKey           = NULL;
    ScreenControls   = NULL;
    PreformattedMode = FALSE;
    LoginScreen      = FALSE;
    AutoEnter        = FALSE;
    InsertMode       = FALSE;
    TipArea          = NULL;

    if (BlIsTerminalConnected()) {
        ScreenBottom     = HEADLESS_SCREEN_HEIGHT;
    } else {
        ScreenBottom     = SCREEN_BOTTOM;
    }
#if defined(PLEASE_WAIT)
    PleaseWaitMsg    = NULL;
#endif

    BlpSendEscape(ScreenAttributes);
    BlpClearScreen();


    Tag = Lex( &InputString );
    while (Tag != TOKEN_EOF )
    {
        switch (Tag)
        {
        case TOKEN_HTML:
            Tag = OSCMLTagState( &InputString );
            break;

        case TOKEN_ENDHTML:
            Tag = TOKEN_EOF;    // exit state
            break;

        default:
            Tag = ImpliedBodyTagState( &InputString );
            break;
        }
    }

    // Remove any buffered keys to prevent blipping thru the screens.
    // NOTE we call BlGetKey() directly, not BlpGetKey(), so we only
    // remove real keystrokes, not the "auto-enter" keystroke.
    while ( BlGetKey( ) != 0 )
        ; // NOP on purpose

    if ( ScreenControls ) {
        chReturn = ProcessScreenControls( OutputString );
    } else {
        chReturn = ProcessEmptyScreen( OutputString );
    }

    // Erase footer to give user feedback that the screen is being
    // processed.
    BlpSendEscapeReverse(ScreenAttributes);
    BlpPositionCursor( 1, ScreenBottom );

#ifdef _IN_OSDISP_
    PRINT( SpaceString, 79*sizeof(TCHAR) );
#else
    PRINT( SpaceString, BlTerminalConnected 
                            ? 79*sizeof(TCHAR)
                            : 80*sizeof(TCHAR) );
#endif

#if defined(PLEASE_WAIT)
    if ( PleaseWaitMsg ) {
        BlpPositionCursor( 1, ScreenBottom );
#ifdef UNICODE
        {
            ULONG i;
            WCHAR wc;
            for (i = 0; i< strlen(PleaseWaitMsg);i++) {
                wc = (WCHAR)PleaseWaitMsg[i];
                PRINT( &wc, 1*sizeof(WCHAR));
            }
        }
#else
        PRINTL( PleaseWaitMsg );
#endif
    }
#endif

    BlpSendEscape(ScreenAttributes);
    return chReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\oschoice\parse.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    parse.c

Abstract:

    This module contains UI code for the OS chooser

Author:

    Geoff Pease (GPease) May 29 1998

Revision History:

--*/

#ifndef __PARSE_H__
#define __PARSE_H__

enum ACTIONS {
    ACTION_NOP = 0,
    ACTION_REBOOT,
    ACTION_JUMP,
    ACTION_LOGIN    
#if defined(_BUILDING_OSDISP_)
    ,ACTION_REFRESH
#endif
};

extern enum ACTIONS SpecialAction;

extern CHAR DomainName[256];
extern CHAR UserName[256];
extern CHAR Password[128];
extern CHAR AdministratorPassword[OSC_ADMIN_PASSWORD_LEN+1];
extern CHAR AdministratorPasswordConfirm[OSC_ADMIN_PASSWORD_LEN+1];

#ifndef _FILETIME_
#define _FILETIME_
typedef struct _FILETIME {
    ULONG dwLowDateTime;
    ULONG dwHighDateTime;
} FILETIME, *PFILETIME;
#endif // _FILETIME_

extern FILETIME GlobalFileTime;
extern TIME_FIELDS ArcTimeForUTCTime;
extern ULONG AuthenticationType;

#define OSCHOICE_AUTHENETICATE_TYPE_NTLM_V1         0x00000001
#define OSCHOICE_AUTHENETICATE_TYPE_NTLM_V2         0x00000002

NTSTATUS
SetFileTimeFromTimeString(
    IN PSTR TimeString,
    OUT PFILETIME FileTime,
    OUT TIME_FIELDS *ArcTime
    );


CHAR
BlProcessScreen(
    IN PCHAR InputString,
    OUT PCHAR OutputString
    );

#define ASCI_CSI_OUT    TEXT("\033[")     // escape-leftbracket

#define ATT_FG_BLUE     4
#define ATT_FG_WHITE    7
#define ATT_BG_BLUE     (ATT_FG_BLUE    << 4)
#define ATT_BG_WHITE    (ATT_FG_WHITE   << 4)
#define DEFATT          (ATT_FG_WHITE | ATT_BG_BLUE)
#define INVATT          (ATT_FG_BLUE |  ATT_BG_WHITE)

#endif // __PARSE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\oschoice\regboot.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regboot.c

Abstract:

    Provides a minimal registry implementation designed to be used by the
    osloader at boot time.  This includes loading the system hive
    ( <SystemRoot>\config\SYSTEM ) into memory, and computing the driver
    load list from it.

Author:

    John Vert (jvert) 10-Mar-1992

Revision History:

--*/
#include "bldr.h"
#include "msg.h"
#include "cmp.h"
#include "stdio.h"
#include "string.h"

ULONG ScreenWidth=80;
ULONG ScreenHeight=25;


//
// defines for doing console I/O
//
#define ASCII_CR 0x0d
#define ASCII_LF 0x0a
#define ESC 0x1B
#define SGR_INVERSE 7
#define SGR_INTENSE 1
#define SGR_NORMAL 0


//
// prototypes for console I/O routines
//

VOID
BlpClearScreen(
    VOID
    );

VOID
BlpClearToEndOfLine(
    VOID
    );

VOID
BlpPositionCursor(
    IN ULONG Column,
    IN ULONG Row
    );

VOID
BlpSetInverseMode(
    IN BOOLEAN InverseOn
    );



VOID
BlpClearScreen(
    VOID
    )

/*++

Routine Description:

    Clears the screen.

Arguments:

    None

Return Value:

    None.

--*/

{
#if 0
    CHAR Buffer[16];
    ULONG Count;

    sprintf(Buffer, ASCI_CSI_OUT "2J");

    ArcWrite(BlConsoleOutDeviceId,
             Buffer,
             strlen(Buffer),
             &Count);
#else
    BlClearScreen();
#endif
}



VOID
BlpClearToEndOfLine(
    VOID
    )
{
#if 0
    CHAR Buffer[16];
    ULONG Count;

    sprintf(Buffer, ASCI_CSI_OUT "K");
    ArcWrite(BlConsoleOutDeviceId,
             Buffer,
             strlen(Buffer),
             &Count);
#else
    BlClearToEndOfLine();
#endif
}


VOID
BlpPositionCursor(
    IN ULONG Column,
    IN ULONG Row
    )

/*++

Routine Description:

    Sets the position of the cursor on the screen.

Arguments:

    Column - supplies new Column for the cursor position.

    Row - supplies new Row for the cursor position.

Return Value:

    None.

--*/

{
#if 0
    CHAR Buffer[16];
    ULONG Count;

    sprintf(Buffer, ASCI_CSI_OUT "%d;%dH", Row, Column);

    ArcWrite(BlConsoleOutDeviceId,
             Buffer,
             strlen(Buffer),
             &Count);
#else
    BlPositionCursor( Column, Row );
#endif
}


VOID
BlpSetInverseMode(
    IN BOOLEAN InverseOn
    )

/*++

Routine Description:

    Sets inverse console output mode on or off.

Arguments:

    InverseOn - supplies whether inverse mode should be turned on (TRUE)
                or off (FALSE)

Return Value:

    None.

--*/

{
#if 0
    CHAR Buffer[16];
    ULONG Count;

    sprintf(Buffer, ASCI_CSI_OUT "%dm", InverseOn ? SGR_INVERSE : SGR_NORMAL);

    ArcWrite(BlConsoleOutDeviceId,
             Buffer,
             strlen(Buffer),
             &Count);
#else
    BlSetInverseMode( InverseOn );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\oschoice\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl


!ENDIF

MAJORCOMP=ntos
MINORCOMP=bldr

TARGETNAME=oscldr
TARGETPATH=obj
TARGETTYPE=LIBRARY

!IF "$(BUILD_DEBUG_LOADER)" != ""
DBG_LDR=_dbg
!ELSE
DBG_LDR=
!ENDIF

!include $(PROJECT_ROOT)\boot\loader$(DBG_LDR).inc

INCLUDES= \
    $(PROJECT_ROOT)\boot\inc;\
    $(PROJECT_ROOT)\ntos\inc;\
    $(PROJECT_ROOT)\ntos\config;\
    $(PROJECT_ROOT)\boot\lib;\
    $(O);

C_DEFINES=$(C_DEFINES) -DSECURITY_WIN32 -D__RPC_DOS__ -DRPC_NO_WINDOWS_H

!IF $(IA64)
C_DEFINES=$(C_DEFINES) -DEFI -DUNICODE -D_UNICODE
!endif

SOURCES=..\oschoice.c \
        ..\parse.c \
        ..\regboot.c \
        ..\dcmpstub.c \
        ..\oscheap.c \
        $(O)\msg.mc\
        ..\oschoice.rc

	
PASS0_SOURCEDIR=$(O)
PASS0_HEADERDIR=$(O)
NTTARGETFILE0=$(O)\msg.mc

!IF $(386)
MC_FLAGS=-A
!ENDIF

!if "$(NOLINK)" != "1"
!if $(386)
NTTARGETFILES=$(O)\oschoice$(DBG_LDR).exe
!endif

!if $(IA64)
NTTARGETFILES=$(O)\oschoice$(DBG_LDR).efi
!endif

MISCFILES=$(NTTARGETFILES)

!endif


UMRES=$(O)\oschoice.res
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\oschoice\oschoice.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    osloader.c

Abstract:

    This module contains the code that implements the OS chooser.

Author:

    Adam Barr (adamba) 15-May-1997

Revision History:

--*/

#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

#include "netboot.h"  // for network functionality
#include "netfs.h"    // for network functionality
#include "stdio.h"
#include "msg.h"
#include <pxe_cmn.h>
#include <pxe_api.h>
#include <tftp_api.h>
#include "parse.h"
#include "stdlib.h"
#include "parseini.h"
#include "haldtect.h"

#ifdef EFI
#define BINL_PORT   0x0FAB    // 4011 (decimal) in little-endian
#else
#define BINL_PORT   0xAB0F    // 4011 (decimal) in big-endian
#endif

#if defined(_WIN64) && defined(_M_IA64)
#pragma section(".base", long, read, write)
__declspec(allocate(".base"))
extern
PVOID __ImageBase;
#else
extern
PVOID __ImageBase;
#endif

VOID
BlpClearScreen(
    VOID
    );

BOOLEAN
BlDetectHal(
    VOID
    );

VOID
BlMainLoop(
    );

UCHAR OsLoaderVersion[] = "OS Chooser V5.2\r\n";
WCHAR OsLoaderVersionW[] = L"OS Chooser V5.2\r\n";
UCHAR OsLoaderName[] = "oschoice.exe";

const CHAR rghex[] = "0123456789ABCDEF";

typedef BOOLEAN BOOL;


BOOLEAN isOSCHOICE=TRUE;
ULONG RemoteHost;
USHORT RemotePort;
USHORT LocalPort;
CHAR DomainName[256];
CHAR UserName[256];
CHAR Password[128];
CHAR AdministratorPassword[OSC_ADMIN_PASSWORD_LEN+1];
CHAR AdministratorPasswordConfirm[OSC_ADMIN_PASSWORD_LEN+1];
WCHAR UnicodePassword[128];
CHAR LmOwfPassword[LM_OWF_PASSWORD_SIZE];
CHAR NtOwfPassword[NT_OWF_PASSWORD_SIZE];
BOOLEAN LoggedIn = FALSE;   // have we successfully logged in
UCHAR NextBootfile[128];
UCHAR SifFile[128];
BOOLEAN DoSoftReboot = FALSE;
BOOLEAN BlUsePae;

//
// the following globals are for detecting the hal
//
UCHAR HalType[8+1+3+1];
UCHAR HalDescription[128];
PVOID InfFile;
PVOID WinntSifHandle;
PCHAR WinntSifFile;
ULONG WinntSifFileLength;
BOOLEAN DisableACPI = FALSE;

#if 0 && DBG
#define _TRACE_FUNC_
#endif

#ifdef _TRACE_FUNC_
#define TraceFunc( _func)  { \
    CHAR FileLine[80]; \
    sprintf( FileLine, "%s(%u)", __FILE__, __LINE__ ); \
    DPRINT( OSC, ( "%-55s: %s", FileLine, _func )); \
}
#else
#define TraceFunc( _func )
#endif

//
// This removes macro redefinitions which appear because we define __RPC_DOS__,
// but rpc.h defines __RPC_WIN32__
//

#pragma warning(disable:4005)

//
// As of 12/17/98, SECURITY_DOS is *not* defined - adamba
//

#if defined(SECURITY_DOS)
//
// These appear because we defined SECURITY_DOS
//

#define __far
#define __pascal
#define __loadds
#endif

#include <security.h>
#include <rpc.h>
#include <spseal.h>

#if defined(SECURITY_DOS)
//
// PSECURITY_STRING is not supposed to be used when SECURITY_DOS is
// defined -- it should be a WCHAR*. Unfortunately ntlmsp.h breaks
// this rule and even uses the SECURITY_STRING structure, which there
// is really no equivalent for in 16-bit mode.
//

typedef SEC_WCHAR * SECURITY_STRING;   // more-or-less the intention where it is used
typedef SEC_WCHAR * PSECURITY_STRING;
#endif

#include <ntlmsp.h>

//
// Packet structure definitions.
//

#include "oscpkt.h"


VOID
BlpSetInverseMode(
    IN BOOLEAN InverseOn
    );

VOID
BlpSendEscape(
    PCHAR Escape
    );

ULONG
BlDoLogin(
    VOID
    );

VOID
BlDoLogoff(
    VOID
    );


//
// Define external static data.
//

BOOLEAN BlConsoleInitialized = FALSE;
ULONG BlConsoleOutDeviceId = 0;
ULONG BlConsoleInDeviceId = 0;
ULONG BlDcacheFillSize = 32;
extern BOOLEAN BlOutputDots;


ULONGLONG NetRebootParameter = (ULONGLONG)0;
UCHAR NetRebootFile[128];
BOOLEAN BlRebootSystem = FALSE;
ULONG BlVirtualBias = 0;

CHAR KernelFileName[8+1+3+1]="ntoskrnl.exe";
CHAR HalFileName[8+1+3+1]="hal.dll";


//
// Globals used during login. Mostly because it would be too many
// parameters to pass to BlDoLogin().
//

#define OUTGOING_MESSAGE_LENGTH 1024
#define INCOMING_MESSAGE_LENGTH 8192
#define TEMP_INCOMING_MESSAGE_LENGTH 1500

#define RECEIVE_TIMEOUT 5
#define RECEIVE_RETRIES 24

PCHAR OutgoingMessageBuffer = NULL;
SIGNED_PACKET UNALIGNED * OutgoingSignedMessage;

PCHAR IncomingMessageBuffer = NULL;
SIGNED_PACKET UNALIGNED * IncomingSignedMessage;

PCHAR TempIncomingMessage = NULL;

CredHandle CredentialHandle;
BOOLEAN CredentialHandleValid = FALSE;
CtxtHandle ClientContextHandle;
BOOLEAN ClientContextHandleValid = FALSE;
PSecPkgInfoA PackageInfo = NULL;




#if DBG
VOID
DumpBuffer(
    PVOID Buffer,
    ULONG BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    ULONG i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    PUCHAR BufferPtr = Buffer;


    KdPrint(("------------------------------------\n"));

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            KdPrint(("%02x ", (UCHAR)BufferPtr[i]));

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            KdPrint(("  "));
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            KdPrint(("  %s\n", TextBuffer));
        }

    }

    KdPrint(("------------------------------------\n"));
}

VOID
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    KdPrint(( "%s", Comment ));

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( ConvertTime.LowPart == 0x7FFFFFFF ) {
        KdPrint(( "Infinite\n" ));

    //
    // Otherwise print it more clearly
    //

    } else {

        KdPrint(("%lx %lx\n", ConvertTime.HighPart, ConvertTime.LowPart));
    }

}
#endif // DBG

ARC_STATUS
BlInitStdio (
    IN ULONG Argc,
    IN PCHAR Argv[]
    )
{
    PCHAR ConsoleOutDevice;
    PCHAR ConsoleInDevice;
    ULONG Status;

    if (BlConsoleInitialized) {
        return ESUCCESS;
    }

    
    //
    // Allocate some memory for our UDP reads/writes.  These *must*
    // be virtual addresses, so we need to allocate them rather than
    // just using static arrays because if we have lots of memory
    // (greater than >9Gig) on a machine and oschoice gets loaded high, we
    // may end up with a bogus address when we convert these addresses to
    // physical addresses just before we UdpWrite/UdpRead.
    //
    OutgoingMessageBuffer = BlAllocateHeap(OUTGOING_MESSAGE_LENGTH);
    IncomingMessageBuffer = BlAllocateHeap(INCOMING_MESSAGE_LENGTH);
    TempIncomingMessage   = BlAllocateHeap(TEMP_INCOMING_MESSAGE_LENGTH);


    //
    // Get the name of the console output device and open the device for
    // write access.
    //

    ConsoleOutDevice = BlGetArgumentValue(Argc, Argv, "consoleout");
    if (ConsoleOutDevice == NULL) {
        return ENODEV;
    }

    Status = ArcOpen(ConsoleOutDevice, ArcOpenWriteOnly, &BlConsoleOutDeviceId);
    if (Status != ESUCCESS) {
        return Status;
    }

    //
    // Get the name of the console input device and open the device for
    // read access.
    //

    ConsoleInDevice = BlGetArgumentValue(Argc, Argv, "consolein");
    if (ConsoleInDevice == NULL) {
        return ENODEV;
    }

    Status = ArcOpen(ConsoleInDevice, ArcOpenReadOnly, &BlConsoleInDeviceId);
    if (Status != ESUCCESS) {
        return Status;
    }

    BlConsoleInitialized = TRUE;
    return ESUCCESS;
}


extern BOOLEAN NetBoot;

NTSTATUS
UdpSendAndReceive(
    IN PVOID SendBuffer,
    IN ULONG SendBufferLength,
    IN ULONG SendRemoteHost,
    IN USHORT SendRemotePort,
    IN ULONG SendRetryCount,
    IN PVOID ReceiveBuffer,
    IN ULONG ReceiveBufferLength,
    OUT PULONG ReceiveRemoteHost,
    OUT PUSHORT ReceiveRemotePort,
    IN ULONG ReceiveTimeout,
    IN ULONG ReceiveSignatureCount,
    IN PCHAR ReceiveSignatures[],
    IN ULONG ReceiveSequenceNumber
    )
{
    ULONG i, j;
    ULONG length;
    SIGNED_PACKET UNALIGNED * ReceiveHeader =
                (SIGNED_PACKET UNALIGNED *)ReceiveBuffer;

#ifdef _TRACE_FUNC_
    TraceFunc("UdpSendAndReceive( ");
    DPRINT( OSC, ("ReceiveSequenceNumber=%u )\n", ReceiveSequenceNumber) );
#endif

    //
    // Try sending the packet SendRetryCount times, until we receive
    // a response with the right signature, waiting ReceiveTimeout
    // each time.
    //

    for (i = 0; i < SendRetryCount; i++) {

        length = UdpSend(
                    SendBuffer,
                    SendBufferLength,
                    SendRemoteHost,
                    SendRemotePort);

        if ( length != SendBufferLength ) {
            DPRINT( ERROR, ("UdpSend only sent %d bytes, not %d\n", length, SendBufferLength) );
            return STATUS_UNEXPECTED_NETWORK_ERROR;
        }

ReReceive:

        //
        // NULL out the first 12 bytes in case we get shorter data.
        //

        memset(ReceiveBuffer, 0x0, 12);

        length = UdpReceive(
                    ReceiveBuffer,
                    ReceiveBufferLength,
                    ReceiveRemoteHost,
                    ReceiveRemotePort,
                    ReceiveTimeout);

        if ( length == 0 ) {
            DPRINT( ERROR, ("UdpReceive timed out\n") );
            continue;
        }

        //
        // Make sure the signature is one of the ones we expect.
        //

        for (j = 0; j < ReceiveSignatureCount; j++) {
            if (memcmp(ReceiveBuffer, ReceiveSignatures[j], 4) == 0) {

                //
                // Now make sure that the sequence number is correct,
                // if asked to check (0 means don't check).
                //

                if ((ReceiveSequenceNumber == 0) ||
                    (ReceiveSequenceNumber == ReceiveHeader->SequenceNumber)) {

                    return STATUS_SUCCESS;

                } else {

                    DPRINT( ERROR, ("UdpReceive expected seq %d, got %d\n",
                        ReceiveSequenceNumber, ReceiveHeader->SequenceNumber) );

                }
            }
        }

        DPRINT( ERROR, ("UdpReceive got wrong signature\n") );

        //
        // Don't UdpSend again just because we got a bad signature. Still need
        // to respect the original ReceiveTimeout however!
        //

        goto ReReceive;

    }

    //
    // We timed out.
    //

    return STATUS_IO_TIMEOUT;
}


//
// This routine signs and sends a message, waits for a response, and
// then verifies the signature on the response.
//
// It returns a positive number on success, 0 on a timeout, -1 if
// the server did not recognize the client, and -2 on other errors
// (which should be fixable by having the client re-login and
// re-transmit the request).
//
// NOTE: The data is sent as a UDP datagram. This requires a UDP header
// which the SendBuffer is assumed to have room for. In addition, we
// use 32 bytes for the "REQS", the total length, the sequence number,
// the sign length, and the sign itself (which is 16 bytes).
//
// For similar reasons, ReceiveBuffer is assumed to have 32 bytes of
// room at the beginning.
//
// Return values:
//
// 0 - nothing was received
// -1 - a timeout occurred
// -2 - unexpected network error, such as a sign/seal error
// -3 - receive buffer overflow
// positive number - the number of data bytes received
//

#define SIGN_HEADER_SIZE  SIGNED_PACKET_DATA_OFFSET

ULONG CorruptionCounter = 1;

ULONG
SignSendAndReceive(
    IN PVOID SendBuffer,
    IN ULONG SendBufferLength,
    IN ULONG SendRemoteHost,
    IN USHORT SendRemotePort,
    IN ULONG SendRetryCount,
    IN ULONG SendSequenceNumber,
    CtxtHandle ClientContextHandle,
    IN PVOID ReceiveBuffer,
    IN ULONG ReceiveBufferLength,
    OUT PULONG ReceiveRemoteHost,
    OUT PUSHORT ReceiveRemotePort,
    IN ULONG ReceiveTimeout
    )
{
    SECURITY_STATUS SecStatus;
    ULONG Status;
    ULONG length;
    SecBufferDesc SignMessage;
    SecBuffer SigBuffers[2];
    SIGNED_PACKET UNALIGNED * SendHeader =
        (SIGNED_PACKET UNALIGNED *)((PCHAR)SendBuffer - SIGN_HEADER_SIZE);
    SIGNED_PACKET UNALIGNED * ReceiveHeader =
        (SIGNED_PACKET UNALIGNED *)((PCHAR)ReceiveBuffer - SIGN_HEADER_SIZE);
    PCHAR ResultSigs[3];
    USHORT FragmentNumber;
    USHORT FragmentTotal;
    FRAGMENT_PACKET UNALIGNED * TempFragment = (FRAGMENT_PACKET UNALIGNED *)TempIncomingMessage;
    ULONG ResendCount = 0;
    ULONG ReceivedDataBytes;

    TraceFunc("SignSendAndReceive( )\n");

    if ( LoggedIn )
    {
        SigBuffers[1].pvBuffer = SendHeader->Sign;
        SigBuffers[1].cbBuffer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        SigBuffers[1].BufferType = SECBUFFER_TOKEN;

        SigBuffers[0].pvBuffer = SendBuffer;
        SigBuffers[0].cbBuffer = SendBufferLength;
        SigBuffers[0].BufferType = SECBUFFER_DATA;

        SignMessage.pBuffers = SigBuffers;
        SignMessage.cBuffers = 2;
        SignMessage.ulVersion = 0;

        //
        // Sign/seal a message
        //

#ifndef ONLY_SIGN_MESSAGES
        SecStatus = SealMessage(
                            &ClientContextHandle,
                            0,
                            &SignMessage,
                            0 );

        if ( SecStatus != SEC_E_OK ) {
            DPRINT( OSC, ("SealMessage: %lx\n", SecStatus) );
            return (ULONG)-2;
        }
#else
        SecStatus = MakeSignature(
                            &ClientContextHandle,
                            0,
                            &SignMessage,
                            0 );

        if ( SecStatus != SEC_E_OK ) {
            DPRINT( OSC, ("MakeSignature: %lx\n", SecStatus) );
            return (ULONG)-2;
        }
#endif

#if 0
        //
        // Corrupt every fifth message.
        //

        if ((CorruptionCounter % 5) == 0) {
            DPRINT( ERROR, ("INTENTIONALLY CORRUPTING A PACKET\n") );
            ((PCHAR)SendBuffer)[0] = '\0';
        }
        ++CorruptionCounter;
#endif
        memcpy(SendHeader->Signature, RequestSignedSignature, 4);
        SendHeader->SignLength = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        ResultSigs[0] = ResponseSignedSignature;

    }
    else
    {
        memcpy(SendHeader->Signature, RequestUnsignedSignature, 4);
        SendHeader->SignLength = 0;
        ResultSigs[0] = ResponseUnsignedSignature;
    }

    ResultSigs[1] = ErrorSignedSignature;
    ResultSigs[2] = UnrecognizedClientSignature;

    //
    // Fill in our header before the SendBuffer. The sign has already been
    // written in because we set up SigBuffers to point to the right place.
    //

    SendHeader->Length = SendBufferLength + SIGNED_PACKET_EMPTY_LENGTH;
    SendHeader->SequenceNumber = SendSequenceNumber;
    SendHeader->FragmentNumber = 1;
    SendHeader->FragmentTotal = 1;

    //
    // Do an exchange with the server.
    //

ReSend:

    Status = UdpSendAndReceive(
                 SendHeader,
                 SendBufferLength + SIGN_HEADER_SIZE,
                 SendRemoteHost,
                 SendRemotePort,
                 SendRetryCount,
                 ReceiveHeader,
                 INCOMING_MESSAGE_LENGTH,
                 ReceiveRemoteHost,
                 ReceiveRemotePort,
                 ReceiveTimeout,
                 3,             // signature count
                 ResultSigs,    // signatures we look for
                 SendSequenceNumber);   // response should have the same one

    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_IO_TIMEOUT) {
            return (ULONG)-1;
        } else {
            return (ULONG)-2;
        }
    }

    //
    // Was it an error?
    //

    if (memcmp(ReceiveHeader->Signature, ErrorSignedSignature, 4) == 0) {

        DPRINT( ERROR, ("SignSendAndReceive: got ERR response\n") );
        return (ULONG)-2;

    }

    //
    // Was the client not recognized by the server?
    //

    if (memcmp(ReceiveHeader->Signature, UnrecognizedClientSignature, 4) == 0) {

        DPRINT( ERROR, ("SignSendAndReceive: got UNR response\n") );
        return (ULONG)-1;

    }

    if (ReceiveHeader->Length < (ULONG)SIGNED_PACKET_EMPTY_LENGTH) {
        DPRINT( ERROR, ("SignSendAndReceive: response is only %d bytes!\n", ReceiveHeader->Length) );
        ++ResendCount;
        if (ResendCount > SendRetryCount) {
            return (ULONG)-2;
        }
        goto ReSend;
    }

    //
    // If there are fragments, then try to receive the rest of them.
    //

    if (ReceiveHeader->FragmentTotal != 1) {

        //
        // Make sure this is fragment 1 -- otherwise the first one
        // was probably dropped and we should re-request it.
        //

        if (ReceiveHeader->FragmentNumber != 1) {
            DPRINT( ERROR, ("UdpReceive got non-first fragment\n") );
            ++ResendCount;
            if (ResendCount > SendRetryCount) {
                return (ULONG)-1;
            }
            goto ReSend;   // redoes the whole exchange.
        }


        FragmentTotal = ReceiveHeader->FragmentTotal;
        ReceivedDataBytes = ReceiveHeader->Length - SIGNED_PACKET_EMPTY_LENGTH;

        for (FragmentNumber = 1; FragmentNumber < FragmentTotal; FragmentNumber ++) {

ReReceive:

            //
            // NULL out the start of the receive buffer.
            //

            memset(TempFragment, 0x0, sizeof(FRAGMENT_PACKET));

            length = UdpReceive(
                        TempFragment,
                        TEMP_INCOMING_MESSAGE_LENGTH,
                        ReceiveRemoteHost,
                        ReceiveRemotePort,
                        ReceiveTimeout);

            if ( length == 0 ) {
                DPRINT( ERROR, ("UdpReceive timed out\n") );
                ++ResendCount;
                if (ResendCount > SendRetryCount) {
                    return (ULONG)-1;
                }
                goto ReSend;   // redoes the whole exchange.
            }

            //
            // Make sure the signature is one of the ones we expect -- only
            // worry about the ResultSignature because we won't get an
            // error response on any fragment besides the first.
            //
            // Also make sure that the
            // sequence number is correct, if asked to check (0 means don't
            // check). If it's not, then go back and wait for another packet.
            //

            if ((TempFragment->Length < (ULONG)FRAGMENT_PACKET_EMPTY_LENGTH) ||
                (memcmp(TempFragment->Signature, ResultSigs[0], 4) != 0) ||
                ((SendSequenceNumber != 0) &&
                 (SendSequenceNumber != TempFragment->SequenceNumber))) {

                DPRINT( ERROR, ("UdpReceive got wrong signature or sequence number\n") );
                goto ReReceive;

            }

            //
            // Check that the fragment number is also correct.
            //

            if (TempFragment->FragmentNumber != FragmentNumber+1) {

                DPRINT( ERROR, ("UdpReceive got wrong fragment number\n") );
                goto ReReceive;

            }

            //
            // Make sure that this fragment won't overflow the buffer.
            //

            if (ReceivedDataBytes + (TempFragment->Length - FRAGMENT_PACKET_EMPTY_LENGTH) >
                ReceiveBufferLength) {
                return (ULONG)-3;
            }

            //
            // This is the correct fragment, so copy it over and loop
            // to the next fragment.
            //

            memcpy(
                &ReceiveHeader->Data[ReceivedDataBytes],
                TempFragment->Data,
                TempFragment->Length - FRAGMENT_PACKET_EMPTY_LENGTH);

            ReceivedDataBytes += TempFragment->Length - FRAGMENT_PACKET_EMPTY_LENGTH;

        }

        //
        // When we are done getting everything, modify the length in the
        // incoming packet to match the total length (currently it will
        // just have the length of the first fragment.
        //

        ReceiveHeader->Length = ReceivedDataBytes + SIGNED_PACKET_EMPTY_LENGTH;

        DPRINT( OSC, ("Got packet with %d fragments, total length %d\n",
            FragmentTotal, ReceiveHeader->Length) );

    }

    //
    // Make sure the sign is the length we expect!!
    //

    if (LoggedIn == TRUE &&
        ReceiveHeader->SignLength != NTLMSSP_MESSAGE_SIGNATURE_SIZE)
    {
        DPRINT( ERROR, ("SignSendAndReceive: signature length is %d bytes!\n", ReceiveHeader->SignLength) );
        ++ResendCount;
        if (ResendCount > SendRetryCount) {
            return (ULONG)-2;
        }
        goto ReSend;
    }
    else if ( LoggedIn == FALSE &&
              ReceiveHeader->SignLength != 0 )
    {
        DPRINT( ERROR, ("SignSendAndReceive: signature length is not 0 bytes (=%u)!\n", ReceiveHeader->SignLength) );
        ++ResendCount;
        if (ResendCount > SendRetryCount) {
            return (ULONG)-2;
        }
        goto ReSend;
    }

    if ( LoggedIn )
    {
        SigBuffers[1].pvBuffer = ReceiveHeader->Sign;
        SigBuffers[1].cbBuffer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        SigBuffers[1].BufferType = SECBUFFER_TOKEN;

        SigBuffers[0].pvBuffer = ReceiveBuffer;
        SigBuffers[0].cbBuffer = ReceiveHeader->Length - SIGNED_PACKET_EMPTY_LENGTH;
        SigBuffers[0].BufferType = SECBUFFER_DATA;

        SignMessage.pBuffers = SigBuffers;
        SignMessage.cBuffers = 2;
        SignMessage.ulVersion = 0;

#ifndef ONLY_SIGN_MESSAGES
        SecStatus = UnsealMessage(
                            &ClientContextHandle,
                            &SignMessage,
                            0,
                            0 );

        if ( SecStatus != SEC_E_OK ) {
            DPRINT( ERROR, ("UnsealMessage: %lx\n", SecStatus) );
            return (ULONG)-2;
        }
#else
        SecStatus = VerifySignature(
                            &ClientContextHandle,
                            &SignMessage,
                            0,
                            0 );

        if ( SecStatus != SEC_E_OK ) {
            DPRINT( ERROR, ("VerifySignature: %lx\n", SecStatus) );
            return (ULONG)-2;
        }
#endif
    }

    //
    // Sucess, so return.
    //

    return (ReceiveHeader->Length - SIGNED_PACKET_EMPTY_LENGTH);

}

//
// Retrieve next screen
//
BOOL
BlRetrieveScreen(
    ULONG *SequenceNumber,
    PCHAR OutMessage,
    PCHAR InMessage
    )
{
    ARC_STATUS Status;
    ULONG OutMessageLength = strlen( OutMessage );
    ULONG InMessageLength;
    PCREATE_DATA CreateData;

    TraceFunc("BlRetrieveScreen( )\n");

    // make sure we don't over flow the output buffer
    if ( OutMessageLength > 1023 ) {
        OutMessageLength = 1023;
        OutMessage[OutMessageLength] = '\0';
    }

    ++(*SequenceNumber);
    if ( *SequenceNumber > 0x2000 )
    {
        *SequenceNumber = 1;
    }

    if (!LoggedIn)
    {
#ifdef _TRACE_FUNC_
        TraceFunc( "Sending RQU ");
        DPRINT( OSC, ("(%u)...\n", *SequenceNumber) );
#endif

        memcpy( OutgoingSignedMessage->Data, OutMessage, OutMessageLength );

        Status = SignSendAndReceive(
                    OutgoingSignedMessage->Data,
                    OutMessageLength,
                    NetServerIpAddress,
                    BINL_PORT,
                    RECEIVE_RETRIES,
                    *SequenceNumber,
                    ClientContextHandle,
                    IncomingSignedMessage->Data,
                    INCOMING_MESSAGE_LENGTH - SIGN_HEADER_SIZE,
                    &RemoteHost,
                    &RemotePort,
                    RECEIVE_TIMEOUT);

    }
    else
    {

#ifdef _TRACE_FUNC_
        TraceFunc( "Sending Seal/Signed REQS " );
        DPRINT( OSC, ("(%u)...\n", *SequenceNumber) );
#endif

        while (TRUE)
        {

            memcpy( OutgoingSignedMessage->Data, OutMessage, OutMessageLength );

            Status = SignSendAndReceive(
                        OutgoingSignedMessage->Data,
                        OutMessageLength,
                        NetServerIpAddress,
                        BINL_PORT,
                        RECEIVE_RETRIES,
                        *SequenceNumber,
                        ClientContextHandle,
                        IncomingSignedMessage->Data,
                        INCOMING_MESSAGE_LENGTH - SIGN_HEADER_SIZE,
                        &RemoteHost,
                        &RemotePort,
                        RECEIVE_TIMEOUT);

            if ((Status == 0) || (Status == (ULONG)-2))
            {
                DPRINT( OSC, ("Attempting to re-login\n") );

                //
                // We assume that the server has dropped the current login
                // and don't bother calling BlDoLogoff();
                //
                LoggedIn = FALSE;

                Status = BlDoLogin( );

                *SequenceNumber = 1;

                if (Status == STATUS_SUCCESS)
                {
                    DPRINT( ERROR, ("Successfully re-logged in\n") );
                    memcpy(OutgoingSignedMessage->Data, OutMessage, OutMessageLength);
                    LoggedIn = TRUE;
                    continue;
                }
                else
                {
                    DPRINT( ERROR, ("ERROR - could not re-login, %x\n", Status) );
                    //DbgBreakPoint();

                    //
                    // Call ourselves again, but request the LoginErr screen which
                    // is 00004e28.
                    //
                    strcpy( OutMessage, "00004e28\n" );
                    return BlRetrieveScreen( SequenceNumber, OutMessage, InMessage );
                }
            }
            else if (Status == (ULONG)-1)
            {
                DPRINT( ERROR, ("Unrecognized, requested TIMEOUT screen\n") );

                //
                // We assume that the server has dropped the current login
                //
                LoggedIn = FALSE;

                //
                // Increase the sequence number for the new screen request,
                // don't worry about wrapping since the session will die soon.
                //

                ++(*SequenceNumber);

                //
                // Call ourselves again, but request the TIMEOUT screen.
                //
                strcpy( OutMessage, "00004E2A\n" );
                return BlRetrieveScreen( SequenceNumber, OutMessage, InMessage );
            }
            else if (Status == (ULONG)-3)
            {
                DPRINT( ERROR, ("Unrecognized, requested TOO LONG screen\n") );

                //
                // This screen is a fatal error, so don't worry about
                // staying logged in.
                //
                LoggedIn = FALSE;

                //
                // Increase the sequence number for the new screen request,
                // don't worry about wrapping since the session will die soon.
                //

                ++(*SequenceNumber);

                //
                // Call ourselves again, but request the TIMEOUT screen.
                //
                strcpy( OutMessage, "00004E53\n" );
                return BlRetrieveScreen( SequenceNumber, OutMessage, InMessage );
            }
            else
            {
                break;
            }
        }

    }

    //
    // NULL-terminate it.
    //
    IncomingSignedMessage->Data[IncomingSignedMessage->Length - SIGNED_PACKET_EMPTY_LENGTH] = '\0';
    strcpy( InMessage, IncomingSignedMessage->Data );
    InMessageLength = strlen(InMessage);

    // DumpBuffer( InMessage, strlen(InMessage) );

    //
    // If we got an just an ACCT response, with no screen data, that means a
    // restart is happening.
    //
    if (memcmp(InMessage, "ACCT", 4) == 0)
    {
        CreateData = (PCREATE_DATA) IncomingSignedMessage->Data;

        DPRINT( OSC, ("Trying to reboot to <%s>\n", CreateData->NextBootfile) );
        strcpy(NextBootfile, CreateData->NextBootfile);
        strcpy(SifFile, CreateData->SifFile);
        DoSoftReboot = TRUE;
        return FALSE;   // exit message loop
    }

    //
    // If we got a screen with an ACCT response after the screen data,
    // should write the secret and do a soft reboot. In this situation
    // InMessageLength will only include the screen data itself, but
    // IncomingSignedMessage->Length will include the whole thing.
    //
    if ((IncomingSignedMessage->Length - SIGNED_PACKET_EMPTY_LENGTH) ==
        (InMessageLength + 1 + sizeof(CREATE_DATA))) {

        CreateData = (PCREATE_DATA) (InMessage + InMessageLength + 1);
        if (memcmp(CreateData->Id, "ACCT", 4) == 0) {


            DPRINT( OSC, ("INSTALL packet setting up reboot to <%s>\n", CreateData->NextBootfile) );
            strcpy(NextBootfile, CreateData->NextBootfile);
            strcpy(SifFile, CreateData->SifFile);
            DoSoftReboot = TRUE;

            //
            // Don't return FALSE, because we still want to show the INSTALL
            // screen. NextBootFile/SifFile/DoSoftReboot won't be modified by
            // that so we will do a proper soft reboot when the time comes.
            //
        }
    }

    // Special-case server tells us to LAUNCH a file

    if (memcmp(InMessage, "LAUNCH", 6) == 0) {

        CreateData = (PCREATE_DATA) (IncomingSignedMessage->Data + 7);
        DPRINT( OSC, ("Trying to launch <%s>\n", CreateData->NextBootfile) );

        strcpy(NextBootfile, CreateData->NextBootfile);
        strcpy(SifFile, CreateData->SifFile);
        if (CreateData->RebootParameter == OSC_REBOOT_COMMAND_CONSOLE_ONLY) {
            NetRebootParameter = NET_REBOOT_COMMAND_CONSOLE_ONLY;
        } else if (CreateData->RebootParameter == OSC_REBOOT_ASR) {
            NetRebootParameter = NET_REBOOT_ASR;
        }
        DoSoftReboot = TRUE;
        return FALSE;    // exit message loop
    }

    // Special-case REBOOT - server told us to reboot.

    if (memcmp(InMessage, "REBOOT", 6) == 0)
    {
        return FALSE;   // exit message loop
    }

    return TRUE;    // stay in message loop
}


ARC_STATUS
BlOsLoader (
    IN ULONG Argc,
    IN PCHAR Argv[],
    IN PCHAR Envp[]
    )

/*++

Routine Description:

    This is the main routine that controls the loading of the NT operating
    system on an ARC compliant system. It opens the system partition,
    the boot partition, the console input device, and the console output
    device. The NT operating system and all its DLLs are loaded and bound
    together. Control is then transfered to the loaded system.

Arguments:

    Argc - Supplies the number of arguments that were provided on the
        command that invoked this program.

    Argv - Supplies a pointer to a vector of pointers to null terminated
        argument strings.

    Envp - Supplies a pointer to a vector of pointers to null terminated
        environment variables.

Return Value:

    EBADF is returned if the specified OS image cannot be loaded.

--*/

{
    CHAR OutputBuffer[256];
    ULONG Count;
    ARC_STATUS Status;
    SECURITY_STATUS SecStatus;  // NOTE: This is a SHORT, so not an NTSTATUS failure on error
    ULONG PackageCount;
    PVOID LoaderBase;


#ifdef EFI
    // 
    // set the efi watchdog timer to 20 minutes.  the boot manager sets it to 5, but
    // the loader could take longer than this, especially if installing over the 
    // network
    //
    SetEFIWatchDog(EFI_WATCHDOG_TIMEOUT);
#endif

    //
    // Initialize the OS loader console input and output.
    //

    Status = BlInitStdio(Argc, Argv);
    if (Status != ESUCCESS) {
        return Status;
    }

    //
    // Initialize the boot debugger for platforms that directly load the
    // OS Loader.
    //
    // N.B. This must occur after the console input and output have been
    //      initialized so debug messages can be printed on the console
    //      output device.
    //
#if defined(_ALPHA_) || defined(ARCI386) || defined(_IA64_)
    
    //
    // If the program memory descriptor was found, then compute the base
    // address of the OS Loader for use by the debugger.
    //
    LoaderBase = &__ImageBase;

    BlPrint(TEXT("about to init debugger...\r\n"));

    //
    // Initialize traps and the boot debugger.
    //
#if defined(ENABLE_LOADER_DEBUG)

#if defined(_ALPHA_)
    BdInitializeTraps();
#endif

    BdInitDebugger("oschoice.exe", LoaderBase, ENABLE_LOADER_DEBUG);

#else

    BdInitDebugger("oschoice.exe", LoaderBase, NULL);

#endif

#endif

    BlPrint(TEXT("back from initializing debugger...\r\n"));

#if DBG
//    NetDebugFlag |= 0x147;
#endif

    TraceFunc("BlOsLoader( )\n");

    //
    // Announce OS Loader.
    //

    BlpClearScreen();
#if 1
#ifdef UNICODE
    BlPrint(OsLoaderVersionW);
#else
    BlPrint(OsLoaderVersion);
#endif
#else
    strcpy(&OutputBuffer[0], OsLoaderVersion);
    ArcWrite(BlConsoleOutDeviceId,
             &OutputBuffer[0],
             strlen(&OutputBuffer[0]),
             &Count);
#endif

    //
    // Initialize the network.
    //

    NetGetRebootParameters(&NetRebootParameter, NetRebootFile, NULL, NULL, NULL, NULL, NULL, TRUE);

    DPRINT( OSC, ("Initializing the network\n") );

    Status = NetInitialize();

    if (Status != ESUCCESS) {
        return Status;
    }


#ifndef EFI
    //
    // Get ourselves a UDP port.
    //

    LocalPort = UdpAssignUnicastPort();

    DPRINT( OSC, ("Using port %x\n", LocalPort) );
#endif

    //
    // Initialize the security package.
    //

    DPRINT( OSC, ("Initializing security package\n") );

    SecStatus = EnumerateSecurityPackagesA( &PackageCount, &PackageInfo );

    if (SecStatus == SEC_E_OK) {
        DPRINT( OSC, ("NTLMSSP: PackageCount: %ld\n", PackageCount) );
        DPRINT( OSC, ("Name: %s Comment: %s\n", PackageInfo->Name, PackageInfo->Comment) );
        DPRINT( OSC, ("Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                PackageInfo->fCapabilities,
                PackageInfo->wVersion,
                PackageInfo->wRPCID,
                PackageInfo->cbMaxToken) );
    } else {
        DPRINT( ERROR, ("NTLMSSP: Enumerate failed, %d\n", SecStatus) );
    }

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfoA( NTLMSP_NAME_A, &PackageInfo );

    if ( SecStatus != SEC_E_OK ) {
        DPRINT( ERROR, ("QuerySecurityPackageInfo failed %d", SecStatus) );
        return SecStatus;
    }

    //
    // Detect the Hal type
    //
    if (!BlDetectHal()) {
        //
        // just fall through if it fails, it's not the end of the world
        //
        HalType[0] = '\0';
        HalDescription[0] = '\0';
        DPRINT( ERROR, ("BlDetectHal failed.\n") );
    }

    //
    // Process screens, loggons, etc... we come back after a "REBOOT"
    // was indicated.
    //
    BlMainLoop( );


    //
    // Inform boot debugger that the boot phase is complete.
    //
    // N.B. This is x86 only for now.
    //

#if defined(_X86_)

    DbgUnLoadImageSymbols(NULL, (PVOID)-1, 0);

#endif

#ifdef EFI
    BlEfiSetAttribute( DEFATT );
#else
    BlpSendEscape(";0;37;40m");
#endif
    BlpSetInverseMode( FALSE );
    BlpClearScreen();
    BlPrint(TEXT("Waiting for reboot...\r\n"));
#ifndef EFI
    HW_CURSOR(1,0);
#endif


    if (DoSoftReboot) {
        Status = NetSoftReboot(
                     NextBootfile,
                     NetRebootParameter,
                     NULL,     // reboot file
                     SifFile,
                     UserName,
                     DomainName,
                     Password,
                     AdministratorPassword);   // this only returns on an error

    } else {
        DPRINT( OSC, ("calling ArcRestart()\n") );
        ArcRestart();
    }

    BlPrint(TEXT("Reboot failed... Press ALT+CTL+DEL to reboot.\n"));

//LoadFailed:
    return Status;

}


//
//
//
ARC_STATUS
BlProcessLogin(
    PCHAR OutgoingMessage )
{
    //
    // If this is the login screen, remember some of the inputs
    // ourselves.
    //
    ARC_STATUS Status;
    UNICODE_STRING TmpNtPassword;
    PCHAR AtSign;
    int i;

    TraceFunc("BlProcessLogin( )\n");

    //
    // We could be trying to log another person in so log off the
    // current user.
    //
    if ( LoggedIn == TRUE )
    {
        BlDoLogoff();
        LoggedIn = FALSE;
    }

    DPRINT( OSC, ("Login info: Domain <%s>, User <%s>, Password<%s>\n", DomainName, UserName, "*") );

    //
    // Do a quick conversion of the password to Unicode.
    //

    TmpNtPassword.Length = strlen(Password) * sizeof(WCHAR);
    TmpNtPassword.MaximumLength = sizeof(UnicodePassword);
    TmpNtPassword.Buffer = UnicodePassword;

    for (i = 0; i < sizeof(Password); i++) {
        UnicodePassword[i] = (WCHAR)(Password[i]);
    }

    BlOwfPassword(Password, &TmpNtPassword, LmOwfPassword, NtOwfPassword);

    Status = BlDoLogin( );

    DPRINT( OSC, ("Login returned: %x\n", Status) );

    return Status;
}

//
//
//
VOID
BlMainLoop(
    )
{
    ULONG SequenceNumber;
    int len;
    PUCHAR psz;
    PUCHAR pch;
    UCHAR OutgoingMessage[1024];
    PUCHAR IncomingMessage;

    TraceFunc("BlMainLoop( )\n");

    //
    // These all point into our single outgoing and incoming buffers.
    //
    OutgoingSignedMessage = (SIGNED_PACKET UNALIGNED *)OutgoingMessageBuffer;
    IncomingSignedMessage = (SIGNED_PACKET UNALIGNED *)IncomingMessageBuffer;

    DomainName[0] = '\0';
    UserName[0] = '\0';
    Password[0] = '\0';

    SequenceNumber = 0;

    //
    // Ask the server for the initial screen
    //
    strcpy( OutgoingMessage, "\n" );    // first screen name is <blank>.
    IncomingMessage = IncomingSignedMessage->Data;

    SpecialAction = ACTION_NOP;
    while ( SpecialAction != ACTION_REBOOT )
    {
        CHAR LastKey;

        //
        // Retrieve next screen
        //
#if 0
        IF_DEBUG(OSC) {
            DPRINT( OSC, ("Dumping OutgoingingMessage buffer:\r\n" ) );
            DumpBuffer( (PVOID)OutgoingMessage, 256 );
        }
#endif
        if (!BlRetrieveScreen( &SequenceNumber, OutgoingMessage, IncomingMessage ) )
            break;

        //
        // Process the screen and get user input
        //
        LastKey = BlProcessScreen( IncomingMessage, OutgoingMessage );

        DPRINT( OSC, ("LastKey = 0x%02x\nAction = %u\nResults:\n%s<EOM>\n",
                LastKey, SpecialAction, OutgoingMessage) );

        switch ( SpecialAction )
        {
        case ACTION_LOGIN:
            DPRINT( OSC, ("[SpecialAction] Logging in\n") );
            if ( STATUS_SUCCESS == BlProcessLogin( OutgoingMessage ) )
            {
                DPRINT( OSC, ("Validate Results are still the same:\n%s<EOM>\n",
                        OutgoingMessage) );

                LoggedIn = TRUE;
                SequenceNumber = 0;
                //
                // If the welcome screen was processed, then add some extra
                // outgoing predetermined variables.
                //
                // Add NIC address
                //
                //  Convert NIC address 0x00a0c968041c to a string
                //

                //
                // Make sure the outgoing has a \n after the screen name
                //
                if ( OutgoingMessage[ strlen(OutgoingMessage) - 1 ] != '\n' )
                {
                    strcat( OutgoingMessage, "\n" );
                }

                strcat( OutgoingMessage, "MAC=" );

                len = 6;
                psz = &OutgoingMessage[ strlen( OutgoingMessage ) ];
                pch = (PCHAR) NetLocalHardwareAddress;

                while (len--) {
                    UCHAR c = *(pch++);
                    *(psz++) = rghex [(c >> 4) & 0x0F] ;
                    *(psz++) = rghex [c & 0x0F];
                }
                *psz = '\0';    // terminate

                //
                // Add the Guid
                //
                pch = NULL;
                len = 0;
                GetGuid(&pch, &len);

                if ((len != 0) && (pch!=NULL)) {
                    
                    strcat( OutgoingMessage, "\nGUID=" );
                    psz = &OutgoingMessage[ strlen( OutgoingMessage ) ];                

                    while (len--) {
                        UCHAR c = *(pch++);
                        *(psz++) = rghex [(c >> 4) & 0x0F] ;
                        *(psz++) = rghex [c & 0x0F];
                    }

                    *psz = '\0';    // terminate
                }

                //
                // if we detected the HAL, specify it here
                //
                if (HalType[0] != '\0') {
                    strcat( OutgoingMessage, "\nHALTYPE=" );
                    strcat( OutgoingMessage, HalType );

                    if (HalDescription[0] != '\0') {
                        strcat( OutgoingMessage, "\nHALTYPEDESCRIPTION=" );
                        strcat( OutgoingMessage, HalDescription );
                    }
                }

                //
                // Add the machine type
                //
#if defined(_ALPHA_)
                strcat( OutgoingMessage, "\nMACHINETYPE=Alpha\n" );    // add machinetype
#else

#if defined(_IA64_)
                strcat( OutgoingMessage, "\nMACHINETYPE=ia64\n" );    // add machinetype
#else // INTEL
                strcat( OutgoingMessage, "\nMACHINETYPE=i386\n" );    // add machinetype
#endif // _IA64_

#endif
                //
                // Tell BINL to verify the domain, because otherwise
                // the SSPI package on the server will allow the login
                // to succeed with an invalid domain. BINL will delete
                // this variable from the client state on the server
                // once it does the domain check.
                //

                strcat( OutgoingMessage, "CHECKDOMAIN=1\n" );

            }
            else
            {
                //
                // Goto the Login Error Screen which is
                // 00004e28.
                //
                strcpy( OutgoingMessage, "00004e28\n" );
                LoggedIn = FALSE;
            }
            break;
        }
    }

    //
    // If we logged on successfully, then log off.
    //
    if (LoggedIn)
    {
        BlDoLogoff();
    }
}


//
//
//
ULONG
BlDoLogin (    )
{
    ARC_STATUS Status;
    SECURITY_STATUS SecStatus;
    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;
    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;
    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;
    ULONG ContextAttributes;
    SEC_WINNT_AUTH_IDENTITY_A AuthIdentity;
    TimeStamp Lifetime;
    PCHAR ResultSigs[2];
    UCHAR OwfPasswords[LM_OWF_PASSWORD_SIZE + NT_OWF_PASSWORD_SIZE];
    PLOGIN_PACKET OutgoingLoginMessage;
    PLOGIN_PACKET IncomingLoginMessage;

    OutgoingLoginMessage = (LOGIN_PACKET *) OutgoingMessageBuffer;
    IncomingLoginMessage = (LOGIN_PACKET *) IncomingMessageBuffer;

    TraceFunc("BlDoLogin( )\n");

    //
    // Delete both contexts if needed.
    //


    if (ClientContextHandleValid) {

        SecStatus = DeleteSecurityContext( &ClientContextHandle );
        ClientContextHandleValid = FALSE;

    }


    if (CredentialHandleValid) {

        SecStatus = FreeCredentialsHandle( &CredentialHandle );
        CredentialHandleValid = FALSE;

    }


    //
    // Acquire a credential handle for the client side. The password
    // we supply is the LM OWF password and the NT OWF password
    // concatenated together.
    //

    memcpy( OwfPasswords, LmOwfPassword, LM_OWF_PASSWORD_SIZE );
    memcpy( OwfPasswords+LM_OWF_PASSWORD_SIZE, NtOwfPassword, NT_OWF_PASSWORD_SIZE );

    RtlZeroMemory( &AuthIdentity, sizeof(AuthIdentity) );

    AuthIdentity.Domain = DomainName;
    AuthIdentity.User = UserName;
    AuthIdentity.Password = OwfPasswords;

#if 0
    IF_DEBUG(OSC) {
        DPRINT( OSC, ("Dumping OwfPasswords:\r\n") );
        DumpBuffer( AuthIdentity.Password, LM_OWF_PASSWORD_SIZE+NT_OWF_PASSWORD_SIZE );
    }
#endif


    DPRINT( OSC, ("About to AcquireCredentialsHandle\n") );

    SecStatus = AcquireCredentialsHandleA(
                    NULL,           // New principal
                    NTLMSP_NAME_A,    // Package Name
                    SECPKG_CRED_OUTBOUND | SECPKG_CRED_OWF_PASSWORD,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &CredentialHandle,
                    &Lifetime );

    if ( SecStatus != SEC_E_OK ) {
        DPRINT( ERROR, ("AcquireCredentialsHandle failed: %s ", SecStatus) );
        return SecStatus;
    }

    DPRINT( OSC, ("CredentialHandle: 0x%lx 0x%lx   ",
            CredentialHandle.dwLower, CredentialHandle.dwUpper) );

    CredentialHandleValid = TRUE;

    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = OutgoingLoginMessage->Data;

    SecStatus = InitializeSecurityContextA(
                    &CredentialHandle,
                    NULL,               // No Client context yet
                    NULL,               // No target name needed
                    ISC_REQ_SEQUENCE_DETECT,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( (SecStatus != SEC_E_OK) && (SecStatus != SEC_I_CONTINUE_NEEDED) ) {
        DPRINT( ERROR, ("InitializeSecurityContext (negotiate): %d" , SecStatus) );
        return SecStatus;
    }

    ClientContextHandleValid = TRUE;


#if 0
    IF_DEBUG(OSC) {
        KdPrint(( "\n\nNegotiate Message:\n" ));
        KdPrint(( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                    ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                    ContextAttributes ));
        PrintTime( "Lifetime: ", Lifetime );
        DumpBuffer( NegotiateBuffer.pvBuffer, NegotiateBuffer.cbBuffer );
    }
#endif


    //
    // Send the negotiate buffer to the server and wait for a response.
    //

    memcpy(OutgoingLoginMessage->Signature, NegotiateSignature, 4);
    OutgoingLoginMessage->Length = NegotiateBuffer.cbBuffer;

    TraceFunc("");
    DPRINT( OSC, ("Sending NEG...\n") );

    ResultSigs[0] = ChallengeSignature;
    ResultSigs[1] = NegativeAckSignature;

#if 0
    IF_DEBUG(OSC) {
        KdPrint(( "\n\nNegotiate Message Outgoing Packet:\n" ));
        DumpBuffer( OutgoingLoginMessage, NegotiateBuffer.cbBuffer + LOGIN_PACKET_DATA_OFFSET );
    }
#endif

    Status = UdpSendAndReceive(
                OutgoingLoginMessage,
                NegotiateBuffer.cbBuffer + LOGIN_PACKET_DATA_OFFSET,
                NetServerIpAddress,
                BINL_PORT,
                5,     // retry count
                IncomingLoginMessage,
                INCOMING_MESSAGE_LENGTH,
                &RemoteHost,
                &RemotePort,
                2,      // receive timeout
                2,      // number of signatures
                ResultSigs, // signature we are looking for
                0);     // sequence number (0 means don't check)

    if ( !NT_SUCCESS(Status) ) {        
        DPRINT( ERROR, ("UdpSendAndReceive status is %x\n", Status) );
        return Status;
    }

    //
    // If the response was a NAK, then fail immediately.
    //

    if (memcmp(IncomingLoginMessage->Signature, NegativeAckSignature, 4) == 0) {

        DPRINT( ERROR, ("Received NAK from server\n") );
        return STATUS_LOGON_FAILURE;
    }

#if 0
    IF_DEBUG(OSC) {
        KdPrint(( "\n\nNegotiate Message Incoming Packet: %d %d %d %d\n", 
                  IncomingLoginMessage->Data, 
                  IncomingLoginMessage->Length, 
                  IncomingLoginMessage->Signature, 
                  IncomingLoginMessage->Status ));
        DumpBuffer( IncomingLoginMessage->Data, IncomingLoginMessage->Length );
    }
#endif


    //
    // Get the AuthenticateMessage (ClientSide)
    //

    AuthenticateDesc.ulVersion = 0;
    AuthenticateDesc.cBuffers = 1;
    AuthenticateDesc.pBuffers = &AuthenticateBuffer;

    AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
    AuthenticateBuffer.pvBuffer = OutgoingLoginMessage->Data;

    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = IncomingLoginMessage->Length;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN | SECBUFFER_READONLY;
    ChallengeBuffer.pvBuffer = IncomingLoginMessage->Data;

    DPRINT( OSC, ("About to call InitializeSecurityContext\n") );

    SecStatus = InitializeSecurityContextA(
                    NULL,
                    &ClientContextHandle,
                    NULL,               // No target name needed
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    &ChallengeDesc,
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( (SecStatus != SEC_E_OK) ) {        
        DPRINT( OSC, ("InitializeSecurityContext (Authenticate): %d\n", SecStatus) );
        return SecStatus;
    }

    //
    // Send the authenticate buffer to the server and wait for the response.
    //
    memcpy(OutgoingLoginMessage->Signature, AuthenticateSignature, 4);
    
    OutgoingLoginMessage->Length = AuthenticateBuffer.cbBuffer;

    TraceFunc("");
    DPRINT( OSC, ("Sending AUTH...\n") );

#if 0
    IF_DEBUG(OSC) {
        KdPrint(( "\n\nAuth Message Outgoing Packet:\n" ));
        DumpBuffer( OutgoingLoginMessage, AuthenticateBuffer.cbBuffer + LOGIN_PACKET_DATA_OFFSET );
    }
#endif


    ResultSigs[0] = ResultSignature;

    Status = UdpSendAndReceive(
                OutgoingLoginMessage,
                AuthenticateBuffer.cbBuffer + LOGIN_PACKET_DATA_OFFSET,
                NetServerIpAddress,
                BINL_PORT,
                10,        // retry count
                IncomingLoginMessage,
                INCOMING_MESSAGE_LENGTH,
                &RemoteHost,
                &RemotePort,
                5,         // receive timeout
                1,         // number of signatures we are looking for
                ResultSigs,   // signatures we look for
                0);     // sequence number (0 means don't check)

    if ( !NT_SUCCESS(Status) ) {        
        DPRINT( ERROR, ("UdpSendAndReceive status is %x\n", Status) );
        return Status;
    }

#if 0
    IF_DEBUG(OSC) {
        KdPrint(( "\n\nAuthenticateBuffer Message Incoming Packet: %d %d %d %d\n", 
                  IncomingLoginMessage->Data, 
                  IncomingLoginMessage->Length, 
                  IncomingLoginMessage->Signature, 
                  IncomingLoginMessage->Status ));
        DumpBuffer( IncomingLoginMessage->Data, IncomingLoginMessage->Length );
    }
#endif


    if (memcmp(IncomingLoginMessage->Signature, ResultSignature, 4) == 0) {

        //
        // Login has completed/failed, check status.
        //

        if ( IncomingLoginMessage->Status == STATUS_SUCCESS) {

            TraceFunc("Login successful\n");

        } else {

            DPRINT( ERROR, ("ERROR - could not login, %x\n", IncomingLoginMessage->Status) );

        }

        return IncomingLoginMessage->Status;

    } else {

        //
        // Shouldn't get this because we check signatures!!
        //

        DPRINT( ERROR, ("Got wrong message, expecting success or failure\n") );

        return STATUS_UNEXPECTED_NETWORK_ERROR;

    }

}


FILETIME GlobalFileTime = { 0 };
TIME_FIELDS ArcTimeForUTCTime = { 0 };

NTSTATUS
SetFileTimeFromTimeString(
    IN PSTR TimeString,
    OUT PFILETIME FileTime,
    OUT TIME_FIELDS *ArcTime
    )
{
    TIME_FIELDS *pArcTime;
    NTSTATUS Status = STATUS_SUCCESS;
    PSTR p,q;

    if (!TimeString) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    q = p = TimeString;
    //
    // go until we either run out of space or hit a semi-colon.  The
    // semi-colon delimits the two fields of the filetime string.
    //
    while(*q != '\0' && *q != ';') {
        q++;
    }
    
    //
    // make sure we didn't have a bad input
    //
    if (*q == '\0') {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    *q = '\0';
    q += 1;

    //
    // convert from string into binary format.
    //
    FileTime->dwHighDateTime = atoi(p);
    FileTime->dwLowDateTime = atoi(q);
    
    //
    // now save off the arc time that we did the conversion so that
    // we can calculate a delta later on.
    //
    pArcTime = ArcGetTime();
    RtlCopyMemory(ArcTime,pArcTime,sizeof(TIME_FIELDS));

exit:
    return(Status);
}

#if 0

NTSTATUS
GetFileTimeFromTimeFields(
    IN PTIME_FIELDS TimeFields,
    OUT FILETIME *Time
    )
{
    if (!TimeFields) {
        return(STATUS_UNSUCCESSFUL);
    }

    return(RtlTimeFieldsToTime(TimeFields,(LARGE_INTEGER *)Time) == TRUE
            ? STATUS_SUCCESS
            : STATUS_UNSUCCESSFUL );
             
}

#endif

NTSTATUS
BlGetSystemTimeAsFileTime(
    FILETIME *pSystemTimeAsFileTime
    )
/*++

Routine Description:

    Return the current UTC system time in file time format.
    
    This routine requires that a network agent has let us know what the 
    UTC time of the system currently is.  If not, we will try to use the
    less accurate system bios time.  

Arguments:

    pSystemTimeAsFileTime - receives the current time.    

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER OriginalTime,CurrentTime,Delta,LIFileTime;
    
#if 0
    //
    // check if we've gotten the system time from the network.  if not, then
    // we will try to use the time from the bios.
    //
    if (GlobalFileTime.dwLowDateTime == 0 && GlobalFileTime.dwHighDateTime == 0) {
        Status = GetFileTimeFromTimeFields(ArcGetTime(),pSystemTimeAsFileTime);

        return(Status);
    }

    //
    // Get the delta time from when we got the original time.
    //
    if (RtlTimeFieldsToTime(&ArcTimeForUTCTime,&OriginalTime) &&
        RtlTimeFieldsToTime(ArcGetTime(), &CurrentTime)) {
        Delta.QuadPart = CurrentTime.QuadPart - OriginalTime.QuadPart;

        //
        // Add that delta into the current time.
        // do this math in large integer format cause it handles
        // overflow from one DWORD to the next.
        //
        RtlCopyMemory(&LIFileTime,&GlobalFileTime,sizeof(FILETIME));

        LIFileTime.QuadPart += Delta.QuadPart;

        RtlCopyMemory(&GlobalFileTime,&LIFileTime,sizeof(FILETIME));
    }
#endif        
    RtlCopyMemory(pSystemTimeAsFileTime,&GlobalFileTime,sizeof(FILETIME));

    return(STATUS_SUCCESS);

}


VOID
BlDoLogoff (
    VOID
    )
{
    ARC_STATUS Status;

    TraceFunc("BlDoLogoff( )\n");
    //
    // Send a logoff message to the server -- for the moment this is
    // just sent once and not acked, since if it is lost the server
    // will eventually timeout.
    //

    memcpy(OutgoingSignedMessage->Signature, LogoffSignature, 4);
    OutgoingSignedMessage->Length = 0;

    Status = UdpSend(
                OutgoingSignedMessage,
                SIGNED_PACKET_DATA_OFFSET,
                NetServerIpAddress,
                BINL_PORT);

    if ( !NT_SUCCESS(Status) ) {
        DPRINT( ERROR, ("UdpSend status is %x\n", Status) );
    }

}



VOID
BlOutputLoadMessage (
    IN PCHAR DeviceName,
    IN PCHAR FileName,
    IN PTCHAR FileDescription OPTIONAL
    )

/*++

Routine Description:

    This routine outputs a loading message to the console output device.

Arguments:

    DeviceName - Supplies a pointer to a zero terminated device name.

    FileName - Supplies a pointer to a zero terminated file name.

    FileDescription - Friendly name of the file in question.

Return Value:

    None.

--*/

{
    ULONG Count;
    CHAR OutputBuffer[256];
    PTCHAR pOutputBuffer;
#ifdef UNICODE
    WCHAR OutputBufferW[256];
    UNICODE_STRING uString;
    ANSI_STRING aString;
    pOutputBuffer = OutputBufferW;
#else
    pOutputBuffer = OutputBuffer;
#endif
    
    UNREFERENCED_PARAMETER( FileDescription );

    //
    // Construct and output loading file message.
    //

    if (!BlOutputDots) {
        strcpy(&OutputBuffer[0], "  ");
        strcat(&OutputBuffer[0], DeviceName);
        strcat(&OutputBuffer[0], FileName);
        strcat(&OutputBuffer[0], "\r\n");

    } else {
        strcpy(&OutputBuffer[0],".");
    }

#if 0
    BlLog((LOG_LOGFILE,OutputBuffer));
#endif

#ifdef UNICODE
    RtlInitAnsiString( &aString, OutputBuffer);
    uString.MaximumLength = sizeof(OutputBufferW);
    uString.Buffer = OutputBufferW;
    RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );
#endif

    ArcWrite(BlConsoleOutDeviceId,
              pOutputBuffer,
              _tcslen(pOutputBuffer),
              &Count);

    return;
}

#ifndef EFI

BOOLEAN
BlDetectHal(
    VOID
    )
/*++

Routine Description:

    This function tries to determine the Hal type for this system.

    It fills in the global "HalType" with the type.

Arguments:

    None.

Return Value:

    TRUE if the function successfully detects the hal type.

--*/
{
    BOOLEAN Status = FALSE;
    PSTR MachineName,HalName;
    CHAR FileName[128];
    ARC_STATUS AStatus;
    ULONG DontCare;


    //
    // detecting the hal requires that you open up a copy of winnt.sif
    //
    strncpy(FileName, NetBootPath, sizeof(FileName));
    FileName[sizeof(FileName)-1] = '\0';
    
    strncat(FileName, "winnt.sif", sizeof(FileName) - strlen(FileName) );
    FileName[sizeof(FileName)-1] = '\0';

    AStatus = SlInitIniFile( NULL,
                                    NET_DEVICE_ID,
                                    FileName,
                                    &InfFile,
                                    &WinntSifFile,
                                    &WinntSifFileLength,
                                    &DontCare );

    //
    // if it opens successfully, then search for the HAL.
    //
    if (AStatus == ESUCCESS) {

        //
        // do the search for the HAL.
        //
        MachineName = SlDetectHal();
        if (MachineName) {
            //
            // OK, got the hal type, now look in the SIF file for the actual
            // hal name.
            //
            HalName = SlGetIniValue(
                                InfFile,
                                "Hal",
                                MachineName,
                                NULL);

            if (HalName) {
                strcpy(HalType, HalName );
                
    
                //
                // also get the hal description, which is a "pretty print" version
                // of the hal name
                //
                HalName = SlGetIniValue(
                                    InfFile,
                                    "Computer",
                                    MachineName,
                                    NULL );

                if (HalName) {
                    strcpy(HalDescription, HalName);
                    Status = TRUE;
                }
            }
        }

        SpFreeINFBuffer( InfFile );

    }

    return(Status);
}
#else 

BOOLEAN
BlDetectHal(
    VOID
    )
/*++

Routine Description:

    This function tries to determine the Hal type for this system.

    It fills in the global "HalType" with the type.
    
    NOTE WELL:  EFI machines are always "ACPI" machines so there is
    only one hal type.

Arguments:

    None.

Return Value:

    TRUE if the function successfully detects the hal type.

--*/
{
    strcpy(HalType, "hal.dll" );
    strcpy(HalDescription,"ACPI PC");
    return(TRUE);
}
#endif

//
// note well:  We stub out these setup functions in oschoice.exe, which are
// needed so that the hal detection routines can run properly.  None of these
// routines should actually be called.
//

VOID
SlErrorBox(
    IN ULONG MessageId,
    IN ULONG Line,
    IN PCHAR File
    )
{
    NOTHING;
}

VOID
SlFatalError(
    IN ULONG MessageId,
    ...
    )
{
    //while(1) {
        NOTHING;
    //};

}

VOID
SlFriendlyError(
    IN ULONG uStatus,
    IN PCHAR pchBadFile,
    IN ULONG uLine,
    IN PCHAR pchCodeFile
    )
{
    NOTHING;
}

VOID
SlNoMemError(
    IN ULONG Line,
    IN PCHAR File
    )
{
    SlFatalError(0,Line,File);
}

VOID
SlBadInfLineError(
    IN ULONG Line,
    IN PCHAR INFFile
    )
{
    SlFatalError(0,Line,INFFile);
}


#define SL_KEY_F3       0x03000000

ULONG
SlGetChar(
    VOID
    )
{
    return(SL_KEY_F3);
}

VOID
SlPrint(
    IN PTCHAR FormatString,
    ...
    )
{
    NOTHING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\arcdisp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    arcdisp.c

Abstract:

    This module provides code for managing screen output on an ARC-compliant
    system.

Author:

    John Vert (jvert) 6-Oct-1993

Revision History:

    John Vert (jvert) 6-Oct-1993
        Taken from old 1.0 splib sources

--*/
#include "setupldr.h"
#include "parseini.h"
#include "stdio.h"
#include "hdlsterm.h"

#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

#if defined(EFI)
#include "bootefi.h"
#endif


//
// The screen is divided into 3 areas: the header area, the status area,
// and the client area.  The header area basically always says "Windows NT
// Setup".  The status area is always 1 line high and displayed using a
// different attribute (black on gray).
//


#define     HEADER_HEIGHT       3
#define     MAX_STATUS          200   // allow up to 1600 horizontal res.

#define     SCREEN_SIZE         (ScreenWidth*ScreenHeight)

BOOLEAN StatusBarEnabled = TRUE;
ULONG ScreenWidth=80;
ULONG ScreenHeight=25;
ULONG ScreenX=0,ScreenY=0;
UCHAR CurAttribute = (ATT_FG_WHITE | ATT_BG_BLACK);
TCHAR MessageBuffer[1024];

extern BOOLEAN ShowProgressBar;

//
// private function prototypes
//
VOID
SlpDrawMenu(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG TopItem,
    IN ULONG Height,
    IN PSL_MENU Menu
    );

VOID
SlpDrawMenuItem(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG TopItem,
    IN ULONG Item,
    IN PSL_MENU Menu
    );

VOID
SlpSizeMessage(
    IN PTCHAR Message,
    OUT PULONG Lines,
    OUT PULONG MaxLength,
    OUT ULONG LineLength[],
    OUT PTCHAR LineText[]
    );



PSL_MENU
SlCreateMenu(
    VOID
    )

/*++

Routine Description:

    Allocates and initializes a new menu structure.

Arguments:

    None

Return Value:

    Pointer to the new menu structure if successful.

    NULL on failure

--*/
{
    PSL_MENU p;

    p=BlAllocateHeap(sizeof(SL_MENU));
    if (p==NULL) {
        return(NULL);
    }
    p->ItemCount = 0;
    p->Width = 0;
    InitializeListHead(&p->ItemListHead);
    return(p);
}


BOOLEAN
SlGetMenuItemIndex(
    IN PSL_MENU Menu,
    IN PTCHAR Text,
    OUT PULONG Index
    )

/*++

Routine Description:

    Given the text of a menu item, returns the index of that item.

Arguments:

    Menu - Supplies the menu

    Text - Supplies the text to search for.

    Index - Returns the index of the text in the menu

Return Value:

    TRUE - Item was found.

    FALSE - Item was not found

--*/

{
    ULONG i;
    PSL_MENUITEM Item;

    //
    // Find first item to display
    //
    Item = CONTAINING_RECORD(Menu->ItemListHead.Flink,
                             SL_MENUITEM,
                             ListEntry);

    i=0;
    while ( Item != CONTAINING_RECORD(&Menu->ItemListHead,
                                      SL_MENUITEM,
                                      ListEntry)) {
        if (_tcsicmp(Item->Text,Text)==0) {
            *Index = i;
            return(TRUE);
        }

        Item = CONTAINING_RECORD(Item->ListEntry.Flink,
                                 SL_MENUITEM,
                                 ListEntry);
        ++i;

    }
    return(FALSE);
}


PVOID
SlGetMenuItem(
    IN PSL_MENU Menu,
    IN ULONG Item
    )

/*++

Routine Description:

    Given an item index, returns the data associated with that item.

Arguments:

    Menu - Supplies the menu structure.

    Item - Supplies the item index.

Return Value:

    The data associated with the given item.

--*/

{
    ULONG i;
    PSL_MENUITEM MenuItem;

    //
    // Find item to return
    //
    MenuItem = CONTAINING_RECORD(Menu->ItemListHead.Flink,
                                 SL_MENUITEM,
                                 ListEntry);

    for (i=0;i<Item;i++) {
        MenuItem = CONTAINING_RECORD(MenuItem->ListEntry.Flink,
                                     SL_MENUITEM,
                                     ListEntry);

#if DBG
        if (&MenuItem->ListEntry == &Menu->ItemListHead) {
            SlError(Item);
            return(NULL);
        }
#endif
    }
    return(MenuItem->Data);

}


ULONG
SlAddMenuItem(
    PSL_MENU Menu,
    PTCHAR Text,
    PVOID Data,
    ULONG Attributes
    )

/*++

Routine Description:

    Adds an item to the menu

Arguments:

    Menu - Supplies a pointer to the menu the item will be added to

    Text - Supplies the text to be displayed in the menu

    Data - Supplies a pointer to the data to be returned when the item
           is selected.

    Attributes - Supplies any attributes for the item.

Return Value:

    The Selection index if successful

    -1 on failure

--*/
{
    PSL_MENUITEM NewItem;
    ULONG Length;

    NewItem = BlAllocateHeap(sizeof(SL_MENUITEM));
    if (NewItem==NULL) {
        SlError(0);
        return((ULONG)-1);
    }
    InsertTailList(&Menu->ItemListHead, &NewItem->ListEntry);
    Menu->ItemCount += 1;

    NewItem->Text = Text;
    NewItem->Data = Data;
    NewItem->Attributes = Attributes;
    Length = (ULONG)_tcslen(Text);
    if (Length > Menu->Width) {
        Menu->Width = Length;
    }
    return(Menu->ItemCount - 1);
}


ULONG
SlDisplayMenu(
    IN ULONG HeaderId,
    IN PSL_MENU Menu,
    IN OUT PULONG Selection
    )

/*++

Routine Description:

    Displays a menu and allows the user to pick a selection

Arguments:

    HeaderId - Supplies the message ID of the prompt header
                to be displayed above the menu.

    Menu - Supplies a pointer to the menu to be displayed

    Selection - Supplies the index of the default item.
                Returns the index of the selected item.

Return Value:

    Key that terminated the menu display.

--*/
{
    LONG X, Y;
    ULONG Height;
    ULONG Width;
    ULONG TopItem;
    ULONG c;
    ULONG PreviousSelection;
    ULONG Sel;
    PTCHAR Header;
    ULONG HeaderLines;
    ULONG MaxHeaderLength;
    PTCHAR HeaderText[20];
    ULONG HeaderLength[20];
    ULONG MaxMenuHeight;
    ULONG i;
    ULONG Count;

    Header = BlFindMessage(HeaderId);

    SlpSizeMessage(Header,
                   &HeaderLines,
                   &MaxHeaderLength,
                   HeaderLength,
                   HeaderText);

    if (MaxHeaderLength > ScreenWidth) {
        MaxHeaderLength = ScreenWidth;
    }

    X = (ScreenWidth-MaxHeaderLength)/2;
    for (i=0;i<HeaderLines;i++) {
        SlPositionCursor(X,i+4);
        ArcWrite(ARC_CONSOLE_OUTPUT,HeaderText[i],HeaderLength[i]*sizeof(TCHAR),&Count);
    }

    Width = Menu->Width+4;
    if (Width > ScreenWidth) {
        Width=ScreenWidth;
    }

    //
    // HEADER_HEIGHT + 1 line separator + text height + 1 line separator + max menu heigth + 
    // + 1 line separator + 1 line status bar = screen height
    //
    MaxMenuHeight = ScreenHeight-(HeaderLines+HEADER_HEIGHT+4);

    Height = Menu->ItemCount+2;
    if (Height > MaxMenuHeight) {
        Height = MaxMenuHeight;
    }

    X = (ScreenWidth-Width)/2;
    Y = (MaxMenuHeight - Height)/2 + HeaderLines + HEADER_HEIGHT + 2;

    TopItem = 0;
    Sel = *Selection;
    //
    // Make sure default item is in view;
    //
    if (Sel >= Height - 2) {
        TopItem = Sel - Height + 3;
    }

    SlpDrawMenu(X,Y,
                TopItem,
                Height,
                Menu);

    //
    // highlight default selection
    //
    SlSetCurrentAttribute(INVATT);
    SlpDrawMenuItem(X,Y,
                TopItem,
                Sel,
                Menu);
    SlSetCurrentAttribute(DEFATT);
    SlFlushConsoleBuffer();

#ifdef EFI
    // 
    // disable efi watchdog timer 
    //
    DisableEFIWatchDog();
#endif
    do {
        c = SlGetChar();
        PreviousSelection = Sel;
        SlpDrawMenuItem(X, Y,
                    TopItem,
                    Sel,
                    Menu);

        switch (c) {
            case SL_KEY_UP:
                if(Sel > 0) {
                    Sel--;
                }
                break;

            case SL_KEY_DOWN:
                if(Sel < Menu->ItemCount - 1) {
                    Sel++;
                }
                break;

            case SL_KEY_HOME:
                Sel = 0;
                break;

            case SL_KEY_END:
                Sel = Menu->ItemCount - 1;
                break;

            case SL_KEY_PAGEUP:
                if (Menu->ItemCount > Height) {
                    if (Sel > Height) {
                        Sel -= Height;
                    } else {
                        Sel = 0;
                    }
                }
                break;

            case SL_KEY_PAGEDOWN:
                if (Menu->ItemCount > Height) {
                    Sel += Height;
                    if (Sel >= Menu->ItemCount) {
                        Sel = Menu->ItemCount - 1;
                    }
                }
                break;

            case SL_KEY_F1:
            case SL_KEY_F3:
            case ASCI_CR:
            case ASCI_ESC:
                *Selection = Sel;
#ifdef EFI
                // 
                // reset efi watchdog
                //
                SetEFIWatchDog(EFI_WATCHDOG_TIMEOUT);
#endif
                return(c);

        }

        if (Sel < TopItem) {
            TopItem = Sel;
            SlpDrawMenu(X, Y,
                        TopItem,
                        Height,
                        Menu);
        } else if (Sel > TopItem+Height-3) {
            TopItem = Sel - Height + 3;
            SlpDrawMenu(X, Y,
                        TopItem,
                        Height,
                        Menu);
        }
        //
        // highlight default selection
        //
        SlSetCurrentAttribute(INVATT);
        SlpDrawMenuItem(X,Y,
                    TopItem,
                    Sel,
                    Menu);
        SlSetCurrentAttribute(DEFATT);


    } while ( TRUE );

}



VOID
SlpDrawMenu(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG TopItem,
    IN ULONG Height,
    IN PSL_MENU Menu
    )

/*++

Routine Description:

    Displays the menu on the screen

Arguments:

    X - Supplies X coordinate of upper-left corner of menu

    Y - Supplies Y coordinate of upper-left corner of menu

    TopItem - Supplies index of item at the top of the menu

    Height - Supplies the height of the menu

    Menu - Supplies the menu to be displayed

Return Value:

    None.

--*/

{
    ULONG i;
    PSL_MENUITEM Item;
    ULONG Count;
    TCHAR Output[80];
    ULONG Length;
    ULONG MenuWidth;

    MenuWidth = Menu->Width+4;
    Output[0]=GetGraphicsChar(GraphicsCharDoubleRightDoubleDown);
    for (i=1;i<MenuWidth-1;i++) {
        Output[i]=GetGraphicsChar(GraphicsCharDoubleHorizontal);
    }
    Output[MenuWidth-1]=GetGraphicsChar(GraphicsCharDoubleLeftDoubleDown);
    SlPositionCursor(X,Y);
    ArcWrite(ARC_CONSOLE_OUTPUT,Output,MenuWidth*sizeof(TCHAR),&Count);
    //
    // Find first item to display
    //
    Item = CONTAINING_RECORD(Menu->ItemListHead.Flink,
                             SL_MENUITEM,
                             ListEntry);

    for (i=0;i<TopItem;i++) {
        Item = CONTAINING_RECORD(Item->ListEntry.Flink,
                                 SL_MENUITEM,
                                 ListEntry);
    }

    //
    // Display items
    //
    Output[0]=
    Output[MenuWidth-1]=GetGraphicsChar(GraphicsCharDoubleVertical);
    for (i=Y+1;i<Y+Height-1;i++) {
#ifdef UNICODE
        for (Count = 0 ; Count < MenuWidth-2;Count++) {
            Output[1+Count] = TEXT(' ');
        }
#else
        RtlFillMemory(Output+1,(MenuWidth-2)*sizeof(TCHAR),' ');
#endif
        SlPositionCursor(X, i);

        if (&Item->ListEntry != &Menu->ItemListHead) {
            Length = (ULONG)_tcslen(Item->Text);
            if (Menu->Width < Length) {
                Length = Menu->Width;
            }
            RtlCopyMemory(Output+2,Item->Text,Length*sizeof(TCHAR));
            Item = CONTAINING_RECORD(Item->ListEntry.Flink,
                                     SL_MENUITEM,
                                     ListEntry);
        }
        ArcWrite(ARC_CONSOLE_OUTPUT,Output,MenuWidth*sizeof(TCHAR),&Count);
    }
    Output[0]=GetGraphicsChar(GraphicsCharDoubleRightDoubleUp);
    for (i=1;i<MenuWidth-1;i++) {
        Output[i]=GetGraphicsChar(GraphicsCharDoubleHorizontal);
    }
    Output[MenuWidth-1]=GetGraphicsChar(GraphicsCharDoubleLeftDoubleUp);
    SlPositionCursor(X,Y+Height-1);
    ArcWrite(ARC_CONSOLE_OUTPUT,Output,MenuWidth*sizeof(TCHAR),&Count);
}


VOID
SlpDrawMenuItem(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG TopItem,
    IN ULONG Item,
    IN PSL_MENU Menu
    )

/*++

Routine Description:

    Redraws the given item

Arguments:

    X - Supplies X coordinate of upper-left corner of menu

    Y - Supplies Y coordinate of upper-left corner of menu

    TopItem - Supplies index of item at the top of the menu

    Height - Supplies the height of the menu
           - We had been passing in the Menu Height.  But we have no use for
           - it, since we are already assuming that the menu item id exists,
           - so therefore we are writing exactly one line.

    Item - Supplies the index of the item to be redrawn

    Menu - Supplies the menu to be displayed

Return Value:

    None.

--*/

{
    ULONG i;
    PSL_MENUITEM MenuItem;
    ULONG Count;
    TCHAR Width[80];

    //
    // Find item to display
    //
    MenuItem = CONTAINING_RECORD(Menu->ItemListHead.Flink,
                                 SL_MENUITEM,
                                 ListEntry);

    for (i=0;i<Item;i++) {
        MenuItem = CONTAINING_RECORD(MenuItem->ListEntry.Flink,
                                     SL_MENUITEM,
                                     ListEntry);

#if DBG
        if (&MenuItem->ListEntry == &Menu->ItemListHead) {
            SlError(Item);
        }
#endif
    }

#ifdef UNICODE
        for (Count = 0 ; Count < Menu->Width;Count++) {
            Width[Count] = TEXT(' ');
        }
#else
        RtlFillMemory(Width,(Menu->Width)*sizeof(TCHAR),' ');
#endif


    
    RtlCopyMemory(
            Width,
            MenuItem->Text,
            _tcslen(MenuItem->Text)*sizeof(TCHAR) );
    SlPositionCursor(X+2, Y+(Item-TopItem)+1);
    ArcWrite(ARC_CONSOLE_OUTPUT,Width,Menu->Width*sizeof(TCHAR),&Count);
}



VOID
SlInitDisplay(
    VOID
    )

/*++

Routine Description:

    Clears the screen and does some initialization of global variables based
    on the ARC display information.

Arguments:

    None

Return Value:

    None.

--*/

{
#ifndef EFI
    PARC_DISPLAY_STATUS DisplayStatus;
    
    //
    // Check to see if this version of the ARC firmware is revision 2 or above.
    //
    // If not, we default to 80x25
    //
    if ((SYSTEM_BLOCK->Version > 1) ||
        ((SYSTEM_BLOCK->Version == 1) && (SYSTEM_BLOCK->Revision >= 2))) {

        //
        // Additional checks are required on 1.2 firmware, since some
        // 1.2 firmware does not implement ArcGetDisplayStatus
        //
        if ((SYSTEM_BLOCK->FirmwareVectorLength > (ULONG)GetDisplayStatusRoutine*sizeof(PVOID)) &&
            (SYSTEM_BLOCK->FirmwareVector[GetDisplayStatusRoutine] != NULL)) {
            DisplayStatus = ArcGetDisplayStatus(ARC_CONSOLE_OUTPUT);

            ScreenWidth = DisplayStatus->CursorMaxXPosition;
            ScreenHeight = DisplayStatus->CursorMaxYPosition;
        }
    }

#ifdef ARCI386
    SlPrint(ASCI_CSI_OUT "2J"); // Clears Screen
    
    SlSetCurrentAttribute(DEFATT);
//
//  This is a patch to setup VGA colors in the text port.
//  Otherwise screen colors and attributes are not the same as a PC
//
    // Write all the attributes to the textport
    {
    int row;
    TCHAR    text[MAX_STATUS+1];
    ULONG   Count,Length;
    _stprintf(text,TEXT("                                                                                "));
    //           012345678901234567890123456789012345678901234567890123456789012345678901234567890
    //                     1         2         3         4         5         6         7         8      
    for (row=0;  row< 48; row++)    // compensate for the long textport 48 versus 24 (VGA)
        ArcWrite(ARC_CONSOLE_OUTPUT,text,strlen(&text[0]),&Count);
    }
    // Position cursor at Top Left of screen
    SlPositionCursor(0,0);
#endif

#endif
    
#ifdef EFI
    //
    // On EFI, we won't be redirecting because setupldr.efi is an
    // EFI application.  If that's the case, then we can't use
    // BlIsTerminalConnected().  Instead, we're going to look
    // at the values in the LoaderRedirectionInformation structure
    // to see if we're really redirecting.
    //
    if( LoaderRedirectionInformation.PortAddress != 0 ) {
#else
    if (BlIsTerminalConnected()) {
#endif        
        ScreenHeight = HEADLESS_SCREEN_HEIGHT;
    }


    SlSetCurrentAttribute(DEFATT);
    SlClearDisplay();
}


VOID
SlPrint(
    IN PTCHAR FormatString,
    ...
    )
{
    va_list arglist;
    TCHAR    text[MAX_STATUS+1];
    ULONG   Count,Length;
    ULONG   MaxWidth = ScreenWidth - 2;

    if (MaxWidth > MAX_STATUS) {
        MaxWidth = MAX_STATUS;
    }

    va_start(arglist,FormatString);
    Length = _vsntprintf(text,MaxWidth*sizeof(TCHAR),FormatString,arglist);
    text[MaxWidth] = TEXT('\0');

    ArcWrite(ARC_CONSOLE_OUTPUT,text,Length,&Count);
    va_end(arglist);
}


VOID
SlClearDisplay(
    VOID
    )

/*++

Routine Description:

    Clears the entire display, including header, client area, and status line.

Arguments:

    None

Return Value:

    None.

--*/

{
#if 1    
    BlClearScreen();
#else

    SlPositionCursor(0,0);

#ifdef EFI
    BlEfiClearToEndOfDisplay();
#else
    ARC_DISPLAY_CLEAR_TO_EOD();
#endif    

    if (!ShowProgressBar) {
        SlWriteStatusText(TEXT(""));
    }

#endif
}

ARC_STATUS
SlClearClientArea(
    VOID
    )

/*++

Routine Description:

    Clears the client area of the screen.  Does not disturb the header or
    status areas.

Arguments:

    None.

Return Value:

    always ESUCCESS

--*/

{
    USHORT i;

    for(i=HEADER_HEIGHT; i<ScreenHeight-1; i++) {
        SlPositionCursor(0,i);
        SlClearToEol();
    }

    //
    // home cursor
    //

    SlPositionCursor(0,0);
    return(ESUCCESS);
}


ARC_STATUS
SlClearToEol(
    VOID
    )
{
#ifdef EFI
    
    BlEfiClearToEndOfLine();
#else
    ARC_DISPLAY_CLEAR_TO_EOL();
#endif
    return(ESUCCESS);
}


VOID
SlGetCursorPosition(
    OUT unsigned *x,
    OUT unsigned *y
    )
{
    *x = ScreenX;
    *y = ScreenY;
}


ARC_STATUS
SlPositionCursor(
    IN unsigned x,
    IN unsigned y
    )
{
    //
    // clip to screen
    //

    if(x>=ScreenWidth) {
        x = ScreenWidth-1;
    }

    if(y>=ScreenHeight) {
        y = ScreenHeight-1;
    }

    ScreenX = x;
    ScreenY = y;

#ifdef EFI
    BlEfiPositionCursor(x, y );
#else
    ARC_DISPLAY_POSITION_CURSOR(x, y);
#endif

    
    return(ESUCCESS);
}


ARC_STATUS
SlWriteString(
    IN PTCHAR s
    )
{
    PTCHAR p = s,q;
    BOOLEAN done = FALSE;
    ULONG len,count;

    do {
        q = p;
        while((*q != TEXT('\0')) && (*q != TEXT('\n'))) {
            q++;
        }
        if(*q == TEXT('\0')) {
            done = TRUE;
        } else {
            *q = TEXT('\0');
        }
        len = (ULONG)(q - p);

        ArcWrite(ARC_CONSOLE_OUTPUT,p,len*sizeof(TCHAR),&count);

        ScreenX += len;

        if(!done) {
            ArcWrite(ARC_CONSOLE_OUTPUT,TEXT("\r\n"),2*sizeof(TCHAR),&count);
            ScreenX = 0;
            ScreenY++;
            if(ScreenY == ScreenHeight) {
                ScreenY = ScreenHeight-1;
            }
            *q = TEXT('\n');
        }
        p = q + 1;
    } while(!done);

    return(ESUCCESS);
}


VOID
SlSetCurrentAttribute(
    IN UCHAR Attribute
    )
{
    CurAttribute = Attribute;
#ifdef EFI
    BlEfiSetAttribute( CurAttribute );
#else

    SlPrint(ASCI_CSI_OUT);

    if (BlIsTerminalConnected() && 
        ((Attribute == DEFSTATTR) ||
         (Attribute == INVATT))) {
        SlPrint(TEXT("7"));
    } else {
        SlPrint(TEXT("0"));
    }

    SlPrint(TEXT(";%u;%um"), (Attribute &  0x7) + 30, ((Attribute >> 4) & 7) + 40);

    if(Attribute & ATT_FG_INTENSE) {
        SlPrint(ASCI_CSI_OUT TEXT("1m"));
    }
#endif
}


VOID
SlWriteHeaderText(
    IN ULONG MsgId
    )

/*++

Routine Description:

    Updates the header on the screen with a given string

Arguments:

    MsgId - Supplies the message ID of the new string to be displayed.  This should
            be just one line long.  If it is 0, the header is cleared.

Return Value:

    None.

--*/
{
    int i;

    for(i=HEADER_HEIGHT-1; i>=0; i--) {
        SlPositionCursor(0,i);
        SlClearToEol();
    }

    if (MsgId != 0) {
        SlWriteString(BlFindMessage(MsgId));
    }
}

//
// Stores the current status text.  The size is the screen width, plus the
// terminating nul char.
//
TCHAR StatusText[MAX_STATUS];

UCHAR StatusAttribute = DEFSTATTR;

VOID
SlSetStatusAttribute(
    IN UCHAR Attribute
    )
{
    StatusAttribute = Attribute;
}


BOOLEAN
SlGetStatusBarStatus(
    VOID
    )
/*++

Routine Description:

    Determines if status bar is enabled or not
    
Arguments:

    None.

Return Value:

    TRUE or FALSE
--*/    
{
    return StatusBarEnabled;
}

VOID
SlEnableStatusBar(
    IN  BOOLEAN Enable
    )
/*++

Routine Description:

    Enables or disables the status bar
    
Arguments:

    Enabled - Enable/Disable = TRUE/FALSE

Return Value:

    None.

--*/    
{
    StatusBarEnabled = Enable;
}

VOID
SlWriteStatusText(
    IN PTCHAR Text
    )

/*++

Routine Description:

    Updates the status area on the screen with a given string

Arguments:

    Text - Supplies the new text for the status area.

Return Value:

    None.

--*/
{
    UCHAR AttributeSave = CurAttribute;
    PTCHAR p;
    ULONG Count;
#ifdef EFI
    ULONG MaxWidth = ScreenWidth - 3;
#else
    ULONG MaxWidth = ScreenWidth - 2;
#endif

    //
    // Nop, if status bar is disabled
    //
    if (!StatusBarEnabled) {
        return;
    }

    //
    // if we're writing to a terminal, we don't want to write into the lower
    // right corner as this would make us scroll.
    //
    if (BlTerminalConnected) {
        MaxWidth -= 1;
    }

    if (MaxWidth > MAX_STATUS) {
        MaxWidth = MAX_STATUS;
    }

#ifdef UNICODE
    for (Count = 0 ; Count < sizeof(StatusText)/sizeof(TCHAR);Count++) {
        StatusText[Count] = TEXT(' ');
    }
#else
    RtlFillMemory(StatusText,sizeof(StatusText),' ');
#endif

    //
    // Strip cr/lf as we copy the status text into the status text buffer.
    //
    p = StatusText;
    Count = 0;
    while((Count < MaxWidth) && *Text) {
        if((*Text != TEXT('\r')) && (*Text != TEXT('\n'))) {
            *p++ = *Text;
            Count++;
        }
        Text++;
    }

    SlSetCurrentAttribute(StatusAttribute);
    SlPositionCursor(0,ScreenHeight-1);
    ArcWrite(ARC_CONSOLE_OUTPUT,TEXT("  "),2*sizeof(TCHAR),&Count);
    SlPositionCursor(2,ScreenHeight-1);
    ArcWrite(ARC_CONSOLE_OUTPUT,StatusText,MaxWidth*sizeof(TCHAR),&Count);
    SlSetCurrentAttribute(AttributeSave);
    SlPositionCursor(0,5);
}


VOID
SlGetStatusText(
    OUT PTCHAR Text
    )
{
    _tcscpy(Text,StatusText);
}



#if DBG
VOID
SlWriteDbgText(
    IN PTCHAR text
    )
{
    UCHAR SavedAttribute = CurAttribute;

    SlPositionCursor(0,0);
    CurAttribute = ATT_FG_YELLOW | ATT_BG_RED | ATT_FG_INTENSE;

    SlClearToEol();
    SlWriteString(text);

    CurAttribute = SavedAttribute;
}
#endif


VOID
SlFlushConsoleBuffer(
    VOID
    )

/*++

Routine Description:

    This routine flushes the console buffer, so that we don't have any
    pre-existing keypresses in the buffer when we prompt the user to
    'press any key to continue.'

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    UCHAR c;
    ULONG count;

    while(ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {
        ArcRead(ARC_CONSOLE_INPUT, &c, 1, &count);
    }
}


ULONG
SlGetChar(
    VOID
    )
{
    UCHAR c;
    ULONG count;

    ArcRead(ARC_CONSOLE_INPUT,&c,1,&count);

    if(c == ASCI_CSI_IN) {
        if (ArcGetReadStatus(ARC_CONSOLE_INPUT) != ESUCCESS) {
            //
            // Just a single escape - return it
            //
            return (ASCI_ESC);
        }

        ArcRead(ARC_CONSOLE_INPUT,&c,1,&count);

        switch(c) {

        //
        // see ntos\fw\mips\fwsignal.c!TranslateScanCode() for these codes.
        // Additional codes that might be useful someday:
        // left=C, right=D, insert=@, delete=P
        //

        case 'A':                   // up arrow
            return(SL_KEY_UP);

        case 'B':                   // down arrow
            return(SL_KEY_DOWN);

        case 'H':                   // home
            return(SL_KEY_HOME);

        case 'K':                   // end
            return(SL_KEY_END);

        case '?':                   // page up
            return(SL_KEY_PAGEUP);

        case '/':                   // page down
            return(SL_KEY_PAGEDOWN);

        case 'O':                   // function keys

            ArcRead(ARC_CONSOLE_INPUT,&c,1,&count);

            //
            // F1=P, F2=Q, F3=w, F4 =x, F5 =t, F6 =u
            // F7=q, F8=r, F9=p, F10=m, F11=A, F12=B
            //
            // Note: as of 12/15/92, f11 and f12 were commented out in the
            // firmware sources so are probably never returned.
            //

            switch(c) {

            case 'P':
                return(SL_KEY_F1);

            case 'Q':
                return(SL_KEY_F2);

            case 'w':
                return(SL_KEY_F3);
                
            case 'x':
                return(SL_KEY_F4);


            case 't':
                return(SL_KEY_F5);

            
            case 'u':
                return(SL_KEY_F6);

            case 'q':
                return(SL_KEY_F7);

            case 'r':
                return SL_KEY_F8;

            case 'm':
            case 'M':
                return  SL_KEY_F10;

            case 'A':
                return(SL_KEY_F11);

            case 'B':
                return(SL_KEY_F12);

            default:
                return(0);
            }

        default:
            return(0);
        }

    } else {
        if(c == ASCI_LF) {
            c = ASCI_CR;
        }
        return((ULONG)c);
    }
}


BOOLEAN
SlPromptForDisk(
    IN PTCHAR  DiskName,
    IN BOOLEAN IsCancellable
    )

/*++

Routine Description:

    This routine prompts a user to insert a given diskette #, or to abort the
    Setup process.

    The status line will be erased.

Arguments:

    DiskName - Supplies the name of the disk to be inserted.

    IsCancellable - Supplies flag indicating whether prompt may be cancelled.

Return Value:

    TRUE - The user has pressed OK

    FALSE - The user has pressed CANCEL

--*/

{
    ULONG msg;
    ULONG y;
    ULONG Key;
    PTCHAR Text;
    PTCHAR PleaseWait;
    ULONG i;
    TCHAR  DiskNameDisplayed[81];
    BOOLEAN Repaint=TRUE;

    SlWriteStatusText(TEXT(""));

    if(IsCancellable) {
        msg = SL_NEXT_DISK_PROMPT_CANCELLABLE;
    } else {
        msg = SL_NEXT_DISK_PROMPT;
    }
    Text = BlFindMessage(msg);
    if(Text == NULL) {
        SlError(msg);
        return(FALSE);
    }

    PleaseWait = BlFindMessage(SL_PLEASE_WAIT);
    if(PleaseWait == NULL) {
        SlError(SL_PLEASE_WAIT);
        return(FALSE);
    }

    //
    // Get first line of DiskName and save it in DiskNameDisplayed (limit to 80 chars)
    //
    for(i = 0;
        ((i < 80) && DiskName[i] && (DiskName[i] != TEXT('\r')) && (DiskName[i] != TEXT('\n')));
        i++)
    {
        DiskNameDisplayed[i] = DiskName[i];
    }
    DiskNameDisplayed[i] = TEXT('\0');

    do {
        if (Repaint) {
            SlClearClientArea();
            y = SlDisplayMessageBox(SL_MSG_INSERT_DISK);
            SlPositionCursor((ScreenWidth-i)/2,y+2);
            SlWriteString(DiskNameDisplayed);
            SlWriteStatusText(Text);
        }
        Repaint = FALSE;
        SlFlushConsoleBuffer();
#ifdef EFI
        //
        // diable EFI watchdog when prompting for user input
        //
        DisableEFIWatchDog();
#endif
        Key = SlGetChar();
#ifdef EFI
        // 
        // reset EFI watchdog
        //
        SetEFIWatchDog(EFI_WATCHDOG_TIMEOUT);
#endif

        if (Key == ASCI_CR) {
            SlClearClientArea();
            SlWriteStatusText(PleaseWait);
            return(TRUE);
        } else if (Key == SL_KEY_F3) {
            SlConfirmExit();
            Repaint=TRUE;
        } else if((Key == ASCI_ESC) && IsCancellable) {
            SlWriteStatusText(TEXT(""));
            SlClearClientArea();
            return FALSE;
        }
    } while ( TRUE );
}


VOID
SlConfirmExit(
    VOID
    )

/*++

Routine Description:

    Routine to be called when user presses F3.  Confirms that he really wants
    to exit by popping up a dialog.  DOES NOT RETURN if user chooses to exit.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG c;

    //
    // if we use too much stack space the heap and stack can overlap and we can run into corruption problems
    // without any "stack overflow" exceptions; making large strings static helps prevent this
    //
    static TCHAR OldStatus[MAX_STATUS];
    PTCHAR Text;

    SlGetStatusText(OldStatus);

    SlClearClientArea();

    SlSetCurrentAttribute(DEFDLGATT);

    SlDisplayMessageBox(SL_MSG_EXIT_DIALOG);

    SlSetCurrentAttribute(DEFATT);

    SlFlushConsoleBuffer();

#ifdef EFI
    // 
    // Disable EFI watchdog
    //
    DisableEFIWatchDog();
#endif
    while(1) {
        c = SlGetChar();
        if(c == ASCI_CR) {
            SlWriteStatusText(OldStatus);
#ifdef EFI
            // 
            // reset EFI watchdog
            //
            SetEFIWatchDog(EFI_WATCHDOG_TIMEOUT);
#endif
            return;
        }
        if(c == SL_KEY_F3) {
            Text = BlFindMessage(SL_REBOOT_PROMPT);
            SlClearClientArea();
#ifdef i386
            SlDisplayMessageBox(SL_SCRN_TEXTSETUP_EXITED);
#else
            SlDisplayMessageBox(SL_SCRN_TEXTSETUP_EXITED_ARC);
#endif
            SlWriteStatusText(Text);

            SlFlushConsoleBuffer();
            while(SlGetChar() != ASCI_CR);
            ArcRestart();
        }
    }
}



VOID
SlFriendlyError(
    IN ULONG uStatus,
    IN PCHAR pchBadFile,
    IN ULONG uLine,
    IN PCHAR pchCodeFile
    )

/*++

Routine Description:

    This is called when an error occurs.  It puts up a
    message box, displays an informative message, and allows
    the user to continue.  It is intended to give friendlier
    messages than the SlError macro, in the cases where SlError
    gets passed ARC error codes.

    The status text line will be erased.

Arguments:

    uStatus     - ARC error code

    pchBadFile  - Name of file causing error (Must be given for handled
                  ARC codes.  Optional for unhandled codes.)

    uLine       - Line # in source code file where error occurred (only
                  used for unhandled codes.)

    pchCodeFile - Name of souce code file where error occurred (only
                  used for unhandled codes.)

Return Value:

    None.

--*/

{
    ULONG uMsg;
    PTSTR pBadFile;
    PTSTR pCodeFile;
#ifdef UNICODE
    WCHAR BadFileW[64];
    WCHAR CodeFileW[200];
    ANSI_STRING aString;
    UNICODE_STRING uString;

    RtlInitString( &aString, pchBadFile );
    uString.Buffer = BadFileW;
    uString.MaximumLength = sizeof(BadFileW);
    RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );

    RtlInitString( &aString, pchCodeFile );
    uString.Buffer = CodeFileW;
    uString.MaximumLength = sizeof(CodeFileW);
    RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );

    if (pchBadFile) {
        pBadFile = BadFileW;
    } else {
        pBadFile = NULL;
    }

    pCodeFile = CodeFileW;

#else
    pBadFile = pchBadFile;
    pCodeFile = pchCodeFile;
#endif

    SlClearClientArea();    
    switch(uStatus) {
       case EBADF:
       case EINVAL:  // image corrupt
          uMsg = SL_WARNING_IMG_CORRUPT;
          break;

       case EIO:     // i/o error
          uMsg = SL_WARNING_IOERR;
          break;

       case ENOENT:  // file not found
          uMsg = SL_WARNING_NOFILE;
          break;

       case ENOMEM:  // insufficient memory
          uMsg = SL_WARNING_NOMEM;
          break;

       case EACCES: // unrecognized file system
           uMsg = SL_WARNING_BAD_FILESYS;
           break;

       default:      // then get SlError() behavior (with optional bad file name)
          if(pBadFile) {  // include error-causing file's name
              SlMessageBox(
                  SL_WARNING_ERROR_WFILE,
                  pBadFile,
                  uStatus,
                  uLine,
                  pCodeFile
                  );
          } else {
              SlMessageBox(
                  SL_WARNING_ERROR,
                  uStatus,
                  uLine,
                  pCodeFile
                  );
          }
          return;
    }
    SlMessageBox(
        uMsg,
        pBadFile
        );
}

VOID
SlMessageBox(
    IN ULONG MessageId,
    ...
    )

/*++

Routine Description:

    This is called when an error occurs.  It puts up a
    message box, displays an informative message, and allows
    the user to continue.

    The status text line will be erased.

Arguments:

    MessageId - Supplies ID of message box to be presented.

    any sprintf-compatible arguments to be inserted in the
    message box.

Return Value:

    None.

--*/

{
    va_list args;

    SlClearClientArea();
    va_start(args, MessageId);
    SlGenericMessageBox(MessageId, &args, NULL, NULL, NULL, NULL, TRUE);
    va_end(args);
    
    SlFlushConsoleBuffer();
    SlGetChar();
}


ULONG
SlDisplayMessageBox(
    IN ULONG MessageId,
    ...
    )

/*++

Routine Description:

    Just puts a message box up on the screen and returns.

    The status text line will be erased.

Arguments:

    MessageId - Supplies ID of message box to be presented.

    any sprintf-compatible arguments to be inserted in the
    message box.

Return Value:

    Y position of top line of message box

--*/

{
    ULONG y;
    va_list args;

    va_start(args, MessageId);
    SlGenericMessageBox(MessageId, &args, NULL, NULL, &y, NULL, TRUE);
    va_end(args);

    return(y);
}


VOID
SlFatalError(
    IN ULONG MessageId,
    ...
    )

/*++

Routine Description:

    This is called when a fatal error occurs.  It clears the client
    area, puts up a message box, displays the fatal error message, and
    allows the user to press a key to reboot.

    The status text line will be erased.

Arguments:

    MessageId - Supplies ID of message box to be presented.

    any sprintf-compatible arguments to be inserted in the
    message box.

Return Value:

    Does not return.

--*/

{
    va_list args;
    ULONG x,y;
    PTCHAR Text;

    SlClearClientArea();

    Text = BlFindMessage(MessageId);
    if(Text) {

        va_start(args, MessageId);

        _vsntprintf(MessageBuffer, sizeof(MessageBuffer), Text, args);
        MessageBuffer[sizeof(MessageBuffer)-1] = '\0';

        //
        // Add a blank line, then concatenate the 'Can't continue' text.
        //
        _tcscat(MessageBuffer, TEXT("\r\n"));

        Text = BlFindMessage(SL_CANT_CONTINUE);
        if(Text) {
            _tcscat(MessageBuffer, Text);
        }

        Text = BlAllocateHeap(((ULONG)_tcslen(MessageBuffer)+1) * sizeof(TCHAR));
        _tcscpy(Text, MessageBuffer);

        //
        // Note that MessageId and args won't be used, since we're
        // passing in our Text pointer.
        //
        SlGenericMessageBox(MessageId, &args, Text, &x, NULL, &y, TRUE);

        va_end(args);

    } else {
        SlError(MessageId);
    }

    SlFlushConsoleBuffer();

    SlGetChar();

    ArcRestart();
    
}


VOID
SlGenericMessageBox(
    IN     ULONG   MessageId, OPTIONAL
    IN     va_list *args,     OPTIONAL
    IN     PTCHAR   Message,  OPTIONAL
    IN OUT PULONG  xLeft,     OPTIONAL
    IN OUT PULONG  yTop,      OPTIONAL
    OUT    PULONG  yBottom,   OPTIONAL
    IN     BOOLEAN bCenterMsg
    )

/*++

Routine Description:

    Formats and displays a message box.  The longest line in the string
    of characters will be centered on the screen if bCenterMsg is TRUE.

    The status text line will be erased.

Arguments:

    NOTE:  Either the MessageId/args pair or the Message string must be
           specified. Message string will be used if non-NULL.

    MessageId - Supplies the MessageId that will be looked up to provide
                a NULL-terminated string of characters.
                Each \r\n delimited string will be displayed on its own line.

    args - Supplies the argument list that will be passed to vsprintf.

    Message - Supplies the actual text of the message to be displayed

    xLeft - If bCenterMsg is FALSE, then xLeft is used for the starting x
            coordinate of the message (if specified, otherwise, x = 1).
            Also, if specified, it receives the x coordinate of the left edge
            of all lines that were displayed.

    yTop -  If bCenterMsg is FALSE, then yTop is used for the starting y
            coordinate of the message (if specified, otherwise, y = 3).
            Also, if specified, receives the y coordinate of the top line where
            the message box was displayed.

    yBottom - if specified, receives the y coordinate of the bottom line of
              the message box.

    bCenterMsg - if TRUE, center message on the screen.

Return Value:

    None.

--*/

{
    PTCHAR p;
    ULONG NumLines;
    ULONG MaxLength;
    ULONG x;
    ULONG y;
    ULONG i;
    PTCHAR Line[20];
    ULONG LineLength[20];
    ULONG Count;

    //
    // set some default position values
    //
    x = 3;
    y = ScreenHeight/2;
    NumLines = 0;

    if(!Message) {    // then look up the message
        p=BlFindMessage(MessageId);
        if (p==NULL) {
            SlError(MessageId);
        } else {
            _vsntprintf(MessageBuffer,sizeof(MessageBuffer),p,*args);
            Message = MessageBuffer;
        }
    } else {
        //
        // Just make p non-NULL, so we'll know it's OK to continue.
        //
        p = Message;
    }

    if(p) {

        SlWriteStatusText(TEXT(""));  // Clear status bar

        SlpSizeMessage(Message,
                       &NumLines,
                       &MaxLength,
                       LineLength,
                       Line);

        if (MaxLength > ScreenWidth) {
            MaxLength = ScreenWidth;
        }

        if(bCenterMsg) {
            x = (ScreenWidth-MaxLength)/2;
            y = (ScreenHeight-NumLines)/2;
        } else {
            if(xLeft) {
                x = *xLeft;
            } else {
                x = 1;
            }

            if(yTop) {
                y = *yTop;
            } else {
                y = 3;
            }
        }
    }

    for (i=0; i<NumLines; i++) {
        SlPositionCursor(x, y+i);
        ArcWrite(ARC_CONSOLE_OUTPUT,Line[i],LineLength[i]*sizeof(TCHAR),&Count);
    }

    if(xLeft) {
        *xLeft = x;
    }

    if(yTop) {
        *yTop = y;
    }

    if(yBottom) {
        *yBottom = NumLines ? y+NumLines-1 : 0;
    }
}


VOID
SlpSizeMessage(
    IN  PTCHAR Message,
    OUT PULONG Lines,
    OUT PULONG MaxLength,
    OUT ULONG LineLength[],
    OUT PTCHAR LineText[]
    )

/*++

Routine Description:

    This routine walks down a message and determines the number of
    lines and the maximum line length.

Arguments:

    Message - Supplies a pointer to a null-terminated message

    Lines - Returns the number of lines

    MaxLength - Returns the length of the longest line.

    LineLength - Supplies a pointer to an array of ULONGs
                 Returns a filled in array containing the
                 length of each line.

    LineText - Supplies a pointer to an array of PCHARs
               Returns a filled in array containing a
               pointer to the start of each line.

Return Value:

    None.

--*/

{
    PTCHAR p;
    ULONG NumLines;
    ULONG Length;

    p = Message;
    NumLines = 0;
    *MaxLength = 0;
    Length = 0;

    //
    // walk through the string, determining the number of lines
    // and the length of the longest line.
    //
    LineText[0]=p;
    while (*p != TEXT('\0')) {
        if ((*p == TEXT('\r')) && (*(p+1) == TEXT('\n'))) {
            //
            // End of a line.
            //

            if (Length > *MaxLength) {
                *MaxLength = Length;
            }
            LineLength[NumLines] = Length;
            ++NumLines;
            Length = 0;
            p += 2;
            LineText[NumLines] = p;

        } else {
            ++Length;
            ++p;

            if (*p == TEXT('\0')) {

                //
                // End of the message.
                //

                if (Length > *MaxLength) {
                    *MaxLength = Length;
                }
                LineLength[NumLines] = Length;
                ++NumLines;
            }
        }
    }

    *Lines = NumLines;

}

VOID
SlNoMemError(
    IN ULONG Line,
    IN PCHAR File
    )

/*++

Routine Description:

    Stub error routine for linking with boot\lib\parseini.c.  Just passes arguments thru.

Arguments:

    Line - Line number within the file the error occurred on.

    File - File name where the error occurred.

Return Value:

    None.

--*/
{
     SlFatalError(SL_NO_MEMORY, Line, SlCopyStringAT(File));
}

VOID
SlBadInfLineError(
    IN ULONG Line,
    IN PCHAR INFFile
    )

/*++

Routine Description:

    Stub error routine for linking with boot\lib\parseini.c.  Just passes arguments thru.

Arguments:

    Line - Line number within the inf file the error occurred on.
    
    INFFile - Supplies a pointer to the INF filename.

Return Value:

    None.

--*/
{
    SlFatalError(SL_BAD_INF_LINE, Line, SlCopyStringAT(INFFile));
}

VOID
SlErrorBox(
    IN ULONG MessageId,
    IN ULONG Line,
    IN PCHAR File
    )

/*++

Routine Description:

    Stub error routine for linking with boot\lib\parseini.c.  Just passes arguments thru.

Arguments:

    MessageId - Id of the message to display.

    Line - Line number within the file the error occurred on.

    File - File name where the error occurred.

Return Value:

    None.

--*/
{
    PTSTR pFile;
#ifdef UNICODE    
    WCHAR FileW[200];
    ANSI_STRING aString;
    UNICODE_STRING uString;

    RtlInitString( &aString, File );
    uString.Buffer = FileW;
    uString.MaximumLength = sizeof(FileW);
    RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );
    
    pFile = FileW;

#else
    pFile = File;    
#endif


     SlMessageBox(SL_WARNING_ERROR, MessageId, Line, pFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\oschoice\i386\initx86.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    initx86.c

Abstract:

    Does any x86-specific initialization, then starts the common ARC osloader

Author:

    John Vert (jvert) 4-Nov-1993

Revision History:

--*/
#include "bldrx86.h"
#include "msg.h"
#include "stdio.h"

VOID
BlInitializeTerminal(
    VOID
    );


UCHAR BootPartitionName[80];
UCHAR KernelBootDevice[80];
UCHAR OsLoadFilename[100];
UCHAR OsLoaderFilename[100];
UCHAR SystemPartition[100];
UCHAR OsLoadPartition[100];
UCHAR OsLoadOptions[100];
UCHAR ConsoleInputName[50];
UCHAR MyBuffer[SECTOR_SIZE+32];
UCHAR ConsoleOutputName[50];
UCHAR X86SystemPartition[sizeof("x86systempartition=") + sizeof(BootPartitionName)];


VOID
BlStartup(
    IN PCHAR PartitionName
    )

/*++

Routine Description:

    Does x86-specific initialization, particularly presenting the boot.ini
    menu and running NTDETECT, then calls to the common osloader.

Arguments:

    PartitionName - Supplies the ARC name of the partition (or floppy) that
        setupldr was loaded from.

Return Value:

    Does not return

--*/

{
    ULONG Argc = 0;
    PUCHAR Argv[10];
    ARC_STATUS Status;
    ULONG BootFileId;
    PCHAR BootFile;
    ULONG Read;
    PCHAR p;
    ULONG i;
    ULONG DriveId;
    ULONG FileSize;
    ULONG Count;
    LARGE_INTEGER SeekPosition;
    PCHAR LoadOptions = NULL;
    BOOLEAN UseTimeOut=TRUE;
    BOOLEAN AlreadyInitialized = FALSE;
    extern BOOLEAN FwDescriptorsValid;

    //
    // Initialize ARC StdIo functionality
    //

    strcpy(ConsoleInputName,"consolein=multi(0)key(0)keyboard(0)");
    strcpy(ConsoleOutputName,"consoleout=multi(0)video(0)monitor(0)");
    Argv[0]=ConsoleInputName;
    Argv[1]=ConsoleOutputName;
    BlInitStdio (2, Argv);

    //
    // Initialize any dumb terminal that may be connected.
    //
    BlInitializeTerminal();

    //
    // Announce the loader
    //
    BlPrint(OsLoaderVersion);
    

    //
    // The main functionality of the OS chooser.
    //
    BlOsLoader( Argc, Argv, NULL );

    //
    // If we ever come back here, just wait to reboot.
    //
    if (!BlIsTerminalConnected()) {
        //
        // typical case.  wait for user to press a key and then 
        // restart
        //
        while(!BlGetKey());
    }
    else {
        // 
        // headless case.  present user with mini sac
        //
        while(!BlTerminalHandleLoaderFailure());
    }
    ArcRestart();
}

VOID
BlInitializeTerminal(
    VOID
    )

/*++

Routine Description:

    Does x86-specific initialization of a dumb terminal connected to a serial port.
    
Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // Clear any stale settings.
    //
    RtlZeroMemory( &LoaderRedirectionInformation, sizeof(HEADLESS_LOADER_BLOCK) );

    //
    // See if StartROM was redirecting.
    //
    if( (BOOLEAN)(BIOS_REDIRECT_SERVICE(1) != -1) ) {

        //
        // He is.  Pick up his settings.
        //

        LoaderRedirectionInformation.PortNumber = (ULONG)BIOS_REDIRECT_SERVICE(1);
        LoaderRedirectionInformation.BaudRate = (ULONG)BIOS_REDIRECT_SERVICE(2);
        LoaderRedirectionInformation.Parity = (BOOLEAN)BIOS_REDIRECT_SERVICE(3);
        LoaderRedirectionInformation.StopBits = (UCHAR)BIOS_REDIRECT_SERVICE(4);
    }
    
    
    //
    // Try to initialize the headless port.  Note that if we didn't get anything
    // from startrom, then this call will go out and query the BIOS for an
    // ACPI table to get settings from.
    //
    BlInitializeHeadlessPort();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\oschoice\ia64\initia64.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    initx86.c

Abstract:

    Does any x86-specific initialization, then starts the common ARC osloader

Author:

    John Vert (jvert) 4-Nov-1993

Revision History:

--*/
#include "bldria64.h"
#include "msg.h"
#include "efi.h"
#include "stdio.h"

extern EFI_SYSTEM_TABLE        *EfiST;

VOID
BlInitializeTerminal(
    VOID
    );


UCHAR BootPartitionName[80];
UCHAR KernelBootDevice[80];
UCHAR OsLoadFilename[100];
UCHAR OsLoaderFilename[100];
UCHAR SystemPartition[100];
UCHAR OsLoadPartition[100];
UCHAR OsLoadOptions[100];
UCHAR ConsoleInputName[50];
UCHAR MyBuffer[SECTOR_SIZE+32];
UCHAR ConsoleOutputName[50];
UCHAR X86SystemPartition[sizeof("x86systempartition=") + sizeof(BootPartitionName)];


VOID
BlStartup(
    IN PCHAR PartitionName
    )

/*++

Routine Description:

    Does x86-specific initialization, particularly presenting the boot.ini
    menu and running NTDETECT, then calls to the common osloader.

Arguments:

    PartitionName - Supplies the ARC name of the partition (or floppy) that
        setupldr was loaded from.

Return Value:

    Does not return

--*/

{
    ULONG Argc = 0;
    PUCHAR Argv[10];
    ARC_STATUS Status;
    ULONG BootFileId;
    PCHAR BootFile;
    ULONG Read;
    PCHAR p;
    ULONG i;
    ULONG DriveId;
    ULONG FileSize;
    ULONG Count;
    LARGE_INTEGER SeekPosition;
    PCHAR LoadOptions = NULL;
    BOOLEAN UseTimeOut=TRUE;
    BOOLEAN AlreadyInitialized = FALSE;
    extern BOOLEAN FwDescriptorsValid;

    //
    // Initialize ARC StdIo functionality
    //

    strcpy(ConsoleInputName,"consolein=multi(0)key(0)keyboard(0)");
    strcpy(ConsoleOutputName,"consoleout=multi(0)video(0)monitor(0)");
    Argv[0]=ConsoleInputName;
    Argv[1]=ConsoleOutputName;
    BlInitStdio (2, Argv);

    //
    // Initialize any dumb terminal that may be connected.
    //
    BlInitializeTerminal();

    //
    // The main functionality of the OS chooser.
    //
    BlOsLoader( Argc, Argv, NULL );


    //
    // If we ever come back here, just wait to reboot.
    //
    if (!BlIsTerminalConnected()) {
        //
        // typical case.  wait for user to press a key and then 
        // restart
        //
        while(!BlGetKey());
    }
    else {
        // 
        // headless case.  present user with mini sac
        //
        while(!BlTerminalHandleLoaderFailure());
    }
    ArcRestart();
}

VOID
BlInitializeTerminal(
    VOID
    )

/*++

Routine Description:

    Does initialization of a dumb terminal connected to a serial port.
    
Arguments:

    None.

Return Value:

    None.

--*/

{


    //
    // Try to initialize the headless port.
    //
    BlInitializeHeadlessPort();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\config.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    config.c

Abstract:

    This module contains code for interpreting and manipulating the ARC
    firmware configuration tree in various ways.

Author:

    John Vert (jvert) 7-Oct-1993

Environment:

    Runs in the ARC environment.

Revision History:

--*/
#include "setupldr.h"
#include "stdio.h"

#define MAX_FLOPPIES 4

PCONFIGURATION_COMPONENT_DATA FloppyData[MAX_FLOPPIES];
ULONG NumFloppies=0;

//
// definition for function callbacks
//

//
// Local prototypes
//

BOOLEAN
EnumerateFloppies(
    IN PCONFIGURATION_COMPONENT_DATA ConfigData
    );



BOOLEAN
SlFindFloppy(
    IN ULONG FloppyNumber,
    OUT PCHAR ArcName
    )

/*++

Routine Description:

    Given a floppy number (0, 1, etc.) this routine computes the appropriate
    ARC name.

Arguments:

    FloppyNumber - Supplies the floppy number.

    ArcName - Returns the ARC name of the specified floppy device

Return Value:

    TRUE - Floppy exists in the ARC firmware tree.

    FALSE - Floppy was not found.

--*/

{
    if (NumFloppies==0) {
        BlSearchConfigTree(BlLoaderBlock->ConfigurationRoot,
                            PeripheralClass,
                            FloppyDiskPeripheral,
                            (ULONG)-1,
                            EnumerateFloppies);
    }

    if (FloppyNumber >= NumFloppies) {
        SlFatalError(SL_FLOPPY_NOT_FOUND,NumFloppies,FloppyNumber);
    }

    BlGetPathnameFromComponent(FloppyData[FloppyNumber],
                               ArcName);
    return(TRUE);
}


BOOLEAN
EnumerateFloppies(
    IN PCONFIGURATION_COMPONENT_DATA ConfigData
    )

/*++

Routine Description:

    Callback routine for enumerating all the floppies in the ARC config tree.

Arguments:

    ConfigData - Supplies a pointer to the floppies ARC component data.

Return Value:

    TRUE - continue searching

    FALSE - stop searching tree.

--*/

{
    if (NumFloppies == MAX_FLOPPIES) {
        return(FALSE);
    }

    FloppyData[NumFloppies++] = ConfigData;

    return(TRUE);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\decomp.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    decomp.c

Abstract:

    Routines to handle reading of files compressed into single-file
    cabinet format.

Author:

    Ted Miller (tedm) 16 May 1997

Revision History:

--*/


#include "..\lib\bootlib.h"
#include "diamondd.h"
#include <stdio.h>
#include <fcntl.h>
#include <basetsd.h>
#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

#if 0
#define TmErrOut(x) DbgPrint x
#define TmDbgOut(x) DbgPrint x
#define TmDbgPause() DbgBreakPoint()
#else
#define TmErrOut(x)
#define TmDbgOut(x)
#define TmDbgPause()
#endif

BOOLEAN Decompress;

//
// Global variable that points to a buffer used for decompressing the file
// being opened. After that, reads are satisfied from this buffer. The buffer
// holds exactly one file at a time. We rely on the ordering of stuff in the loader
// to ensure that only one file that needs to be decompressed is open at a time!
//
ULONG_PTR DecompressBufferBasePage;
PVOID DecompressBuffer;
ULONG DecompressBufferSize;
BOOLEAN DecompressBufferInUse;
ULONG SizeOfFileInDecompressBuffer;
ULONG DecompExpectedSize;
HFDI FdiContext;
ERF DecompErf;

//
// The diamond stuff allocates and frees blocks of memory
// for each file. There's no memory allocator in the boot loader that allows
// for memory frees. So we have to fake it.
//
PVOID DecompressHeap;
ULONG_PTR DecompressHeapPage;
#define DECOMP_HEAP_SIZE  ((128+2048)*1024)     // 128K work + 2MB window

typedef struct _DECOMP_HEAP_BLOCK {
    struct _DECOMP_HEAP_BLOCK *Next;
    ULONG BlockSize;
    BOOL Free;
} DECOMP_HEAP_BLOCK, *PDECOMP_HEAP_BLOCK;

VOID
ReinitializeDiamondMiniHeap(
    VOID
    );

//
// Bogus global variable used to track the device id for the device that
// the file we are currently decompressing lives on.
//
ULONG DecompDeviceId;
ARC_STATUS DecompLastIoError;

//
// This is the value we return to diamond when it asks us to create
// the target file.
//
#define DECOMP_MAGIC_HANDLE 0x87654

//
// Misc forward references.
//
ARC_STATUS
DecompAllocateDecompressBuffer (
    IN ULONG BufferSize
    );

VOID
DecompFreeDecompressBuffer (
    VOID
    );

ARC_STATUS
DecompClose(
    IN ULONG FileId
    );

ARC_STATUS
DecompRead(
    IN  ULONG  FileId,
    OUT VOID  * FIRMWARE_PTR Buffer,
    IN  ULONG  Length,
    OUT ULONG * FIRMWARE_PTR Transfer
    );

ARC_STATUS
DecompSeek(
    IN ULONG          FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE      SeekMode
    );

ARC_STATUS
DecompGetFileInfo(
    IN  ULONG             FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR FileInfo
    );

PVOID
DIAMONDAPI
DiamondAlloc(
    IN ULONG Size
    );

VOID
DIAMONDAPI
DiamondFree(
    IN PVOID Block
    );

INT_PTR
DIAMONDAPI
DiamondOpen(
    IN LPSTR FileName,
    IN int   oflag,
    IN int   pmode
    );

UINT
DIAMONDAPI
DiamondRead(
    IN  INT_PTR Handle,
    OUT PVOID pv,
    IN  UINT  ByteCount
    );

UINT
DIAMONDAPI
DiamondWrite(
    IN INT_PTR Handle,
    IN PVOID pv,
    IN UINT  ByteCount
    );

int
DIAMONDAPI
DiamondClose(
    IN INT_PTR Handle
    );

long
DIAMONDAPI
DiamondSeek(
    IN INT_PTR Handle,
    IN long Distance,
    IN int  SeekType
    );

INT_PTR
DIAMONDAPI
DiamondNotifyFunction(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    );

//
// Device dispatch table for our pseudo-filesystem.
//
BL_DEVICE_ENTRY_TABLE DecompDeviceEntryTable = {    DecompClose,            // close
                                                    NULL,                   // mount
                                                    NULL,                   // open
                                                    DecompRead,             // read
                                                    NULL,                   // read status
                                                    DecompSeek,             // seek
                                                    NULL,                   // write
                                                    DecompGetFileInfo,      // get file info
                                                    NULL,                   // set file info
                                                    NULL,                   // rename
                                                    NULL,                   // get dirent
                                                    NULL                    // PBOOTFS_INFO, unused
                                               };


VOID
DecompEnableDecompression(
    IN BOOLEAN Enable
    )
{
#if defined(_X86_) || defined(_IA64_)
    //
    // Disable on alpha, since it doesn't seem to work.
    //
    Decompress = Enable;
#endif
}


BOOLEAN
DecompGenerateCompressedName(
    IN  LPCSTR Filename,
    OUT LPSTR  CompressedName
    )

/*++

Routine Description:

    This routine generates the "compressed-form" name of a file.
    The compressed form substitutes the last character of the extension
    with a _. If there is no extension then ._ is appended to the name.
    Only the final component is relevent; others are preserved in the
    compressed form name.

Arguments:

    Filename - supplies full pathname of file whose compressed form name
        is desired.

    CompressedName - receives compressed form of the full path. The caller must
        ensure that the buffer is large enough.

Return Value:

    TRUE - the caller should try to locate the compressed filename first.
    FALSE - the caller should not attempt to locate the compressed filename
        at all.

    This value depends on the state of the Decompress global.

--*/

{
    PCHAR p,q;

    if(!Decompress) {
        return(FALSE);
    }

    strcpy(CompressedName,Filename);
    p = strrchr(CompressedName,'.');
    q = strrchr(CompressedName,'\\');
    if(q < p) {
        //
        // If there are 0, 1, or 2 characters after the dot, just append
        // the underscore. p points to the dot so include that in the length.
        //
        if(strlen(p) < 4) {
            strcat(CompressedName,"_");
        } else {
            //
            // Assume there are 3 characters in the extension and replace
            // the final one with an underscore.
            //
            p[3] = '_';
        }
    } else {
        //
        // No dot, just add ._.
        //
        strcat(CompressedName,"._");
   }

    return(TRUE);
}

DECOMP_STRUCTURE_CONTEXT DecompStructureContext = {0};

ULONG
DecompPrepareToReadCompressedFile(
    IN LPCSTR Filename,
    IN ULONG  FileId
    )
{
    ULONG Status;
    BOOL b;
    int err;
    ULONGLONG x;
    FDICABINETINFO CabinetInfo;
    ULONG OldUsableBase, OldUsableLimit;

    //
    // On both x86 and alpha the allocation of our large decompress buffer
    // has an unfortunate tendency to place the block right where the
    // (non-relocatable) kernel wants to go. By allocating from the top
    // of memory we make this problem go away.
    //

    if(!Decompress) {
        return((ULONG)(-1));
    }

    //
    // If we're in the middle of FDICopy or FDIIsCabinet then
    // we don't want to do our special processing. Special return code
    // of -1 tells the caller that we didn't process it.
    //
    if(FdiContext) {
        return((ULONG)(-1));
    }

    //
    // If there's no decompression heap yet, allocate one.
    //
    if(!DecompressHeap) {

        //
        // Set allocatable range to the decompression-specific range
        //
        OldUsableBase = BlUsableBase;
        OldUsableLimit = BlUsableLimit;
        BlUsableBase  = BL_DECOMPRESS_RANGE_LOW;
        BlUsableLimit = BL_DECOMPRESS_RANGE_HIGH;

        Status = BlAllocateDescriptor(
                    LoaderOsloaderHeap,
                    0,
                    ROUND_TO_PAGES(DECOMP_HEAP_SIZE) >> PAGE_SHIFT,
                    (PULONG)&DecompressHeapPage
                    );

        //
        // Restore the previous alloc range.
        //
        BlUsableBase = OldUsableBase;
        BlUsableLimit = OldUsableLimit;

        if(Status != ESUCCESS) {
            TmErrOut(("Setup: couldn't allocate decompression heap (%u)\r\n",Status));
            DecompressHeap = NULL;
            return(Status);
        }

        DecompressHeap = (PVOID)(KSEG0_BASE | (DecompressHeapPage << PAGE_SHIFT));
    }

    //
    // We reinitialize diamond each time because of the way we deal with
    // the heap for alloc and free requests from diamond -- doing this
    // allows us to wipe our heap clean for each file.
    //
    ReinitializeDiamondMiniHeap();

    FdiContext = FDICreate(
                    DiamondAlloc,
                    DiamondFree,
                    DiamondOpen,
                    DiamondRead,
                    DiamondWrite,
                    DiamondClose,
                    DiamondSeek,
                    0,                  // cpu type flag is ignored
                    &DecompErf
                    );

    if(!FdiContext) {
        TmErrOut(("Setup: FDICreate failed\r\n"));
        return(ENOMEM);
    }

    //
    // Check if file is a cabinet and reset file pointer.
    //
    b = FDIIsCabinet(FdiContext,FileId,&CabinetInfo);

    x = 0;
    BlSeek(FileId,(PLARGE_INTEGER)&x,SeekAbsolute);

    if(!b) {
        //
        // Not a cabinet, we're done. Bail with return code of -1
        // which tells the caller that everything's OK.
        //
        TmDbgOut(("Setup: file %s is not a cabinet\r\n",Filename));
        FDIDestroy(FdiContext);
        FdiContext = NULL;
        return((ULONG)(-1));
    }

    TmDbgOut(("Setup: file %s is compressed, prearing it for read\r\n",Filename));

    DecompDeviceId = BlFileTable[FileId].DeviceId;
    DecompLastIoError = ESUCCESS;

    b = FDICopy(
            FdiContext,
            "",                         // filename part only
            (LPSTR)Filename,            // full path
            0,                          // no flags relevent
            DiamondNotifyFunction,      // routine to process control messages
            NULL,                       // no decryption
            NULL                        // no user-specified data
            );

    err = DecompErf.erfOper;

    FDIDestroy(FdiContext);
    FdiContext = NULL;

    if(b) {
        //
        // Everything worked.
        //
        // Get file information from the original file system so we can
        // return it later if someone wants it.
        //
        // Close the original file and switch context
        // structures so that read, seek, close, etc. requests come to us
        // instead of the original filesystem.
        //
        if(SizeOfFileInDecompressBuffer != DecompExpectedSize) {
            TmErrOut(("Setup: warning: expected size %lx, actual size = %lx\r\n",DecompExpectedSize,SizeOfFileInDecompressBuffer));
        }

        Status = BlGetFileInformation(FileId,&DecompStructureContext.FileInfo);
        if(Status != ESUCCESS) {
            TmErrOut(("DecompPrepareToReadCompressedFile: BlGetFileInfo returned %u\r\n",Status));
            DecompFreeDecompressBuffer();
            return(Status);
        }
        DecompStructureContext.FileInfo.EndingAddress.LowPart = SizeOfFileInDecompressBuffer;
        DecompStructureContext.FileInfo.EndingAddress.HighPart = 0;

        //
        // We don't handle files whose size doesn't fit in a DWORD.
        //
        if(DecompStructureContext.FileInfo.EndingAddress.HighPart) {
            TmErrOut(("DecompPrepareToReadCompressedFile: file too big\r\n"));
            DecompFreeDecompressBuffer();
            return(E2BIG);
        }

        BlClose(FileId);

        BlFileTable[FileId].Flags.Open = 1;
        BlFileTable[FileId].Position.QuadPart = 0;
        BlFileTable[FileId].DeviceEntryTable = &DecompDeviceEntryTable;

#ifdef CACHE_DEVINFO
        BlFileTable[FileId].StructureContext = &DecompStructureContext;
#else
        RtlCopyMemory(
            BlFileTable[FileId].StructureContext,
            &DecompStructureContext,
            sizeof(DECOMP_STRUCTURE_CONTEXT)
            );
#endif

        return(ESUCCESS);

    } else {
        //
        // Failure.
        //
        TmErrOut(("Setupldr: FDICopy failed (FDIERROR = %u, last io err = %u)\r\n",err,DecompLastIoError));
        TmDbgPause();
        return(EINVAL);
    }
}


ARC_STATUS
DecompAllocateDecompressBuffer (
    IN ULONG BufferSize
    )
{
    ARC_STATUS Status;
    ULONG OldUsableBase, OldUsableLimit;

    //
    // On both x86 and alpha the allocation of our large decompress buffer
    // has an unfortunate tendency to place the block right where the
    // (non-relocatable) kernel wants to go. By allocating from the top
    // of memory we make this problem go away.
    //

    DecompressBufferSize = BufferSize;

    //
    // Set allocatable range to the decompression-specific range
    //
    OldUsableBase = BlUsableBase;
    OldUsableLimit = BlUsableLimit;
    BlUsableBase  = BL_DECOMPRESS_RANGE_LOW;
    BlUsableLimit = BL_DECOMPRESS_RANGE_HIGH;

    Status = BlAllocateDescriptor(
                LoaderOsloaderHeap,
                0,
                (ULONG)(ROUND_TO_PAGES(DecompressBufferSize) >> PAGE_SHIFT),
                (PULONG)&DecompressBufferBasePage
                );

    //
    // Restore the previous alloc range.
    //
    BlUsableBase = OldUsableBase;
    BlUsableLimit = OldUsableLimit;

    if ( Status != ESUCCESS ) {
        TmErrOut(("Setup: couldn't allocate decompression buffer (%u)\r\n",Status));
        DecompressBuffer = NULL;
        return(Status);
    }

    DecompressBuffer = (PVOID)(KSEG0_BASE | (DecompressBufferBasePage << PAGE_SHIFT));

    DecompressBufferInUse = TRUE;

    return ESUCCESS;
}

VOID
DecompFreeDecompressBuffer (
    VOID
    )
{
    if ( DecompressBufferInUse ) {
        DecompressBufferInUse = FALSE;
        BlFreeDescriptor( (ULONG)DecompressBufferBasePage );
    }

    if(DecompressHeap) {
        BlFreeDescriptor( (ULONG)DecompressHeapPage );
        DecompressHeap = NULL;
    }

    return;
}

ARC_STATUS
DecompClose(
    IN ULONG FileId
    )

/*++

Routine Description:

    Close routine for decompression pseudo-filesystem.

    We mark the decompression buffer free and return success.

Arguments:

    FileId - supplies open file id to be closed.

Return Value:


--*/

{
    TmDbgOut(("DecompClose\r\n"));

    if(DecompressBufferInUse) {
        DecompFreeDecompressBuffer();
    } else {
        TmErrOut(("DecompClose: warning: no file buffered!\r\n"));
        TmDbgPause();
    }

    BlFileTable[FileId].Flags.Open = 0;

    return(ESUCCESS);
}


ARC_STATUS
DecompRead(
    IN  ULONG  FileId,
    OUT VOID  * FIRMWARE_PTR Buffer,
    IN  ULONG  Length,
    OUT ULONG * FIRMWARE_PTR Transfer
    )

/*++

Routine Description:

    Read routine for the decompression pseudo-filesystem.

    Reads are satisfied out of the decompression buffer.

Arguments:

    FileId - supplies id for open file as returned by BlOpen().

    Buffer - receives data read from file.

    Length - supplies amount of data to be read, in bytes.

    Transfer - recieves number of bytes actually transferred
        into caller's buffer.

Return Value:

    ARC status indicating outcome.

--*/

{
    ARC_STATUS Status;

    if(DecompressBufferInUse) {
        //
        // Make sure we don't try to read past EOF.
        //
        if((Length + BlFileTable[FileId].Position.LowPart) > SizeOfFileInDecompressBuffer) {
            TmErrOut(("DecompRead: warning: attempt to read past eof; read trucated\r\n"));
            TmDbgPause();
            Length = SizeOfFileInDecompressBuffer - BlFileTable[FileId].Position.LowPart;
        }

        //
        // Transfer data into caller's buffer.
        //
        TmDbgOut(("DecompRead: %lx bytes at filepos %lx\r\n",Length,BlFileTable[FileId].Position.LowPart));

        RtlCopyMemory(
            Buffer,
            (PCHAR)DecompressBuffer + BlFileTable[FileId].Position.LowPart,
            Length
            );

        *Transfer = Length;

        BlFileTable[FileId].Position.QuadPart += Length;

        Status = ESUCCESS;

    } else {
        //
        // Should never get here.
        //
        TmErrOut(("DecompRead: no file buffered!\r\n"));
        TmDbgPause();
        Status = EACCES;
    }

    return(Status);
}


ARC_STATUS
DecompSeek(
    IN ULONG          FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE      SeekMode
    )

/*++

Routine Description:

    Seek routine for the decompression pseudo-filesystem.
    Sets pseudo-file pointer to given offset.

Arguments:

    FileId - supplies id for open file as returned by BlOpen().

    Offset - supplies new offset, whose interpretation depends on
        the SeekMode parameter.

    SeekMode - supplies type of seek. One of SeekAbsolute or SeekRelative.

Return Value:

    ARC status indicating outcome.

--*/

{
    LONGLONG NewPosition;

    TmDbgOut(("DecompSeek: mode %u, pos = %lx\r\n",SeekMode,Offset->LowPart));

    if(DecompressBufferInUse) {

        switch(SeekMode) {

        case SeekAbsolute:

            NewPosition = Offset->QuadPart;
            break;

        case SeekRelative:

            NewPosition = BlFileTable[FileId].Position.QuadPart + Offset->QuadPart;
            break;

        default:
            TmErrOut(("DecompSeek: invalid seek mode\r\n"));
            TmDbgPause();
            return(EINVAL);
        }

        //
        // Make sure we don't try to seek to a negative offset or past EOF.
        //
        if(NewPosition < 0) {
            TmErrOut(("DecompSeek: warning: attempt to seek to negative offset\r\n"));
            TmDbgPause();
            NewPosition = 0;
        } else {
            if((ULONGLONG)NewPosition > (ULONGLONG)SizeOfFileInDecompressBuffer) {
                TmErrOut(("DecompSeek: attempt to seek past eof\r\n"));
                TmDbgPause();
                return(EINVAL);
            }
        }

        //
        // Remember new position.
        //
        TmDbgOut(("DecompSeek: new position is %lx\r\n",NewPosition));
        BlFileTable[FileId].Position.QuadPart = NewPosition;

    } else {
        //
        // Should never get here.
        //
        TmErrOut(("DecompSeek: no file buffered!\r\n"));
        TmDbgPause();
        return(EACCES);
    }

    return(ESUCCESS);
}


ARC_STATUS
DecompGetFileInfo(
    IN  ULONG             FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR FileInfo
    )
{
    RtlCopyMemory(
        FileInfo,
        &((PDECOMP_STRUCTURE_CONTEXT)BlFileTable[FileId].StructureContext)->FileInfo,
        sizeof(FILE_INFORMATION)
        );

    TmDbgOut(("DecompGetFileInfo: size = %lx\r\n",FileInfo->EndingAddress.LowPart));

    return(ESUCCESS);
}


VOID
ReinitializeDiamondMiniHeap(
    VOID
    )
{
    PDECOMP_HEAP_BLOCK p;

    p = DecompressHeap;

    p->BlockSize = DECOMP_HEAP_SIZE - sizeof(DECOMP_HEAP_BLOCK);
    p->Next = NULL;
    p->Free = TRUE;
}


PVOID
DIAMONDAPI
DiamondAlloc(
    IN ULONG Size
    )
{
    PDECOMP_HEAP_BLOCK p,q;
    ULONG LeftOver;

    TmDbgOut(("DiamondAlloc: request %lx bytes\r\n",Size));

    //
    // Round size up to dword boundary.
    //
    if(Size % sizeof(ULONG_PTR)) {
        Size += sizeof(ULONG_PTR) - (Size % sizeof(ULONG_PTR));
    }

    //
    // Nothing fancy. First-fit algorithm, traversing all blocks
    // in the heap every time.
    //
    for(p=DecompressHeap; p; p=p->Next) {
        if(p->Free && (p->BlockSize >= Size)) {

            p->Free = FALSE;

            LeftOver = p->BlockSize - Size;

            if(LeftOver > sizeof(DECOMP_HEAP_BLOCK)) {
                //
                // Split the block.
                //
                p->BlockSize = Size;

                q = (PDECOMP_HEAP_BLOCK)((PUCHAR)(p+1) + Size);
                q->Next = p->Next;

                p->Next = q;

                q->Free = TRUE;
                q->BlockSize = LeftOver - sizeof(DECOMP_HEAP_BLOCK);
            }

            //
            // Return pointer to data area of the block.
            //
            TmDbgOut(("DiamondAlloc(%lx): %lx\r\n",Size,p+1));
            return(p+1);
        }
    }

    TmErrOut(("DiamondAlloc: out of heap space!\r\n"));
    TmDbgPause();
    return(NULL);
}


VOID
DIAMONDAPI
DiamondFree(
    IN PVOID Block
    )
{
    PDECOMP_HEAP_BLOCK p;

    TmDbgOut(("DiamondFree(%lx)\r\n",Block));

    //
    // Get pointer to header for block.
    //
    Block = (PUCHAR)Block - sizeof(DECOMP_HEAP_BLOCK);

    //
    // Nothing fancy, no coalescing free blocks.
    //
    for(p=DecompressHeap; p; p=p->Next) {

        if(p == Block) {

            if(p->Free) {
                TmErrOut(("DiamondFree: warning: freeing free block\r\n"));
                TmDbgPause();
                return;
            }

            p->Free = TRUE;
            return;
        }
    }

    TmErrOut(("DiamondFree: warning: freeing invalid block\r\n"));
    TmDbgPause();
}


INT_PTR
DIAMONDAPI
DiamondOpen(
    IN LPSTR FileName,
    IN int   oflag,
    IN int   pmode
    )
{
    ARC_STATUS Status;
    ULONG FileId;

    UNREFERENCED_PARAMETER(pmode);

    TmDbgOut(("DiamondOpen: %s\r\n",FileName));

    if(oflag & (_O_WRONLY | _O_RDWR | _O_APPEND | _O_CREAT | _O_TRUNC | _O_EXCL)) {

        TmErrOut(("DiamondOpen: invalid oflag %lx for %s\r\n",oflag,FileName));
        TmDbgPause();
        DecompLastIoError = EINVAL;
        return(-1);
    }

    Status = BlOpen(DecompDeviceId,FileName,ArcOpenReadOnly,&FileId);
    if(Status != ESUCCESS) {

        TmErrOut(("DiamondOpen: BlOpen %s returned %u\r\n",FileName,Status));
        TmDbgPause();
        DecompLastIoError = Status;
        return(-1);
    } else {
        TmDbgOut(("DiamondOpen: handle to %s is %lx\r\n",FileName,FileId));
    }

    return((INT_PTR)FileId);
}


UINT
DIAMONDAPI
DiamondRead(
    IN  INT_PTR Handle,
    OUT PVOID pv,
    IN  UINT  ByteCount
    )
{
    ARC_STATUS Status;
    ULONG n;

    TmDbgOut(("DiamondRead: %lx bytes, handle %lx\r\n",ByteCount,Handle));

    //
    // We should never be asked to read from the target file.
    //
    if(Handle == DECOMP_MAGIC_HANDLE) {
        TmErrOut(("DiamondRead: called for unexpected file!\r\n"));
        TmDbgPause();
        DecompLastIoError = EACCES;
        return((UINT)(-1));
    }

    Status = BlRead((ULONG)Handle,pv,ByteCount,&n);
    if(Status != ESUCCESS) {
        TmErrOut(("DiamondRead: BlRead failed %u\r\n",Status));
        TmDbgPause();
        DecompLastIoError = Status;
        n = (UINT)(-1);
    }

    return(n);
}


UINT
DIAMONDAPI
DiamondWrite(
    IN INT_PTR Handle,
    IN PVOID pv,
    IN UINT  ByteCount
    )
{
    TmDbgOut(("DiamondWrite: %lx bytes\r\n",ByteCount));

    //
    // This guy should be called ONLY to write decompressed data
    // into the decompress buffer.
    //
    if(Handle != DECOMP_MAGIC_HANDLE) {
        TmErrOut(("DiamondWrite: called for unexpected file!\r\n"));
        TmDbgPause();
        DecompLastIoError = EACCES;
        return((UINT)(-1));
    }

    //
    // Check for overflow.
    //
    if(SizeOfFileInDecompressBuffer+ByteCount > DecompressBufferSize) {
        TmErrOut(("DiamondWrite: decompressed file too big!\r\n"));
        TmDbgPause();
        DecompLastIoError = E2BIG;
        return((UINT)(-1));
    }

    RtlCopyMemory(
        (PCHAR)DecompressBuffer + SizeOfFileInDecompressBuffer,
        pv,
        ByteCount
        );

    SizeOfFileInDecompressBuffer += ByteCount;
    return(ByteCount);
}


int
DIAMONDAPI
DiamondClose(
    IN INT_PTR Handle
    )
{
    TmDbgOut(("DiamondClose, handle=%lx\r\n",Handle));

    if(Handle != DECOMP_MAGIC_HANDLE) {
        BlClose((ULONG)Handle);
    }

    return(0);
}


long
DIAMONDAPI
DiamondSeek(
    IN INT_PTR Handle,
    IN long Distance,
    IN int  SeekType
    )
{
    ARC_STATUS Status;
    LARGE_INTEGER Offset;

    TmDbgOut(("DiamondSeek: type=%u, dist=%lx, handle=%lx\r\n",SeekType,Distance,Handle));

    //
    // We should never be asked to seek in the output file.
    //
    if(Handle == DECOMP_MAGIC_HANDLE) {
        TmErrOut(("DiamondSeek: asked to seek target file!\r\n"));
        TmDbgPause();
        DecompLastIoError = EACCES;
        return(-1);
    }

    //
    // We can't handle seek from end of file.
    //
    if(SeekType == SEEK_END) {
        TmErrOut(("DiamondSeek: asked to seek relative to end of file!\r\n"));
        TmDbgPause();
        DecompLastIoError = EACCES;
        return(-1);
    }

    Offset.QuadPart = Distance;

    Status = BlSeek((ULONG)Handle,&Offset,SeekType);
    if(Status != ESUCCESS) {
        TmErrOut(("DiamondSeek: BlSeek(%lx,%x) returned %u\r\n",Distance,SeekType,Status));
        TmDbgPause();
        DecompLastIoError = Status;
        return(-1);
    }

    TmDbgOut(("DiamondSeek: BlSeek(%lx,%x) new file position is %lx\r\n",Distance,SeekType,BlFileTable[Handle].Position.LowPart));
    return((long)BlFileTable[Handle].Position.LowPart);
}


INT_PTR
DIAMONDAPI
DiamondNotifyFunction(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    )
{
    ARC_STATUS Status;

    switch(Operation) {

    case fdintCABINET_INFO:
        //
        // Nothing interesting here. Return 0 to continue.
        //
        return(0);

    case fdintCOPY_FILE:

        //
        // The file was obviously a cabinet so we're going to extract
        // the file out of it. Rememember that the decompression buffer
        // is in use. If it's already in use, then a fundamental
        // principle of our implementation has been violated and we
        // must bail now.
        //
        if(DecompressBufferInUse) {
            TmErrOut(("DiamondNotifyFunction: opens overlap (%s)!\r\n",Parameters->psz1));
            DecompLastIoError = EACCES;
            return(-1);
        }

        DecompExpectedSize = Parameters->cb;

        Status = DecompAllocateDecompressBuffer( DecompExpectedSize );
        if (Status != ESUCCESS) {
            TmErrOut(("DiamondNotifyFunction: unable to allocate decompress buffer!\r\n"));
            return(-1);
        }

        SizeOfFileInDecompressBuffer = 0;
        return(DECOMP_MAGIC_HANDLE);

    case fdintCLOSE_FILE_INFO:
        //
        // Diamond is asking to close the target handle. There's nothing we really
        // care about here, just return success as long as we recognize the handle.
        //
        if(Parameters->hf == DECOMP_MAGIC_HANDLE) {
            return(TRUE);
        } else {
            TmErrOut(("DiamondNotifyFunction: asked to close unexpected file!\r\n"));
            TmDbgPause();
            DecompLastIoError = EINVAL;
            return(FALSE);
        }

    default:
        //
        // Disregard any other messages
        //
        return(0);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\msgs.cs ===
;/*++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    msgs.h
;
;Abstract:
;
;    This file contains the message definitions for setupldr
;
;Author:
;
;    John Vert (jvert) 12-Nov-1993
;
;Revision History:
;
;Notes:
;
;    This file is generated from msgs.mc
;
;--*/
;
;#ifndef _SETUPLDR_MSG_
;#define _SETUPLDR_MSG_
;
;

MessageID=9000 SymbolicName=SL_MSG_FIRST
Language=English
.


MessageID=9001 SymbolicName=SL_SCRN_WELCOME
Language=English
Vt vs instalan program systmu Windows

           Pokraujte klvesou ENTER

         Instalaci ukonte klvesou F3
.

MessageID=9002 SymbolicName=SL_WELCOME_HEADER
Language=English

 Instalace systmu Windows

.

MessageID=9003 SymbolicName=SL_TOTAL_SETUP_DEATH
Language=English
Instalace se nepodaila. Libovolnou klvesou restartujte pota.
.

MessageID=9004 SymbolicName=SL_FILE_LOAD_MESSAGE
Language=English
Instalan program nat soubory (%s)...
.

MessageID=9005 SymbolicName=SL_OTHER_SELECTION
Language=English
Jin (vyaduje disketu s ovladaem OEM)
.

MessageID=9006 SymbolicName=SL_SELECT_DRIVER_PROMPT
Language=English
ENTER=Vybrat  F3=Konec
.

MessageID=9007 SymbolicName=SL_NEXT_DISK_PROMPT_CANCELLABLE
Language=English
ENTER=Pokraovat  ESC=Storno  F3=Konec
.

MessageID=9008 SymbolicName=SL_OEM_DISK_PROMPT
Language=English
Podprn disketa dodan vrobcem hardwaru
.

MessageID=9009 SymbolicName=SL_MSG_INSERT_DISK
Language=English
  Vlote disketu, oznaenou jako



           do jednotky A:

*  Potvrte vloen klvesou ENTER.
.

MessageID=9010 SymbolicName=SL_MSG_EXIT_DIALOG
Language=English

  Systm Windows nen na potai zcela               
  nainstalovn. Ukonte-li nyn instalan program,  
  budete jej muset spustit znovu, aby se systm       
  Windows nainstaloval.                               
                                                      
     * Stisknete-li ENTER, instalace bude pokraovat. 
     * Stisknutm klvesy F3 instalaci ukonte.      

     F3=Konec  ENTER=Pokraovat                       

.

MessageID=9011 SymbolicName=SL_NEXT_DISK_PROMPT
Language=English
ENTER=Pokraovat  F3=Konec
.

MessageID=9012 SymbolicName=SL_NTDETECT_PROMPT
Language=English

Instalan program zjiuje hardwarovou konfiguraci potae...

.

MessageID=9013 SymbolicName=SL_KERNEL_NAME
Language=English
Vkonn jdro systmu Windows
.

MessageID=9014 SymbolicName=SL_HAL_NAME
Language=English
Vrstva HAL
.

MessageID=9015 SymbolicName=SL_PAL_NAME
Language=English
Doplky procesoru systmu Windows
.

MessageID=9016 SymbolicName=SL_HIVE_NAME
Language=English
Konfiguran data systmu Windows
.

MessageID=9017 SymbolicName=SL_NLS_NAME
Language=English
Jazykov zvisl data
.

MessageID=9018 SymbolicName=SL_OEM_FONT_NAME
Language=English
Psmo instalanho programu
.

MessageID=9019 SymbolicName=SL_SETUP_NAME
Language=English
Instalace systmu Windows
.

MessageID=9020 SymbolicName=SL_FLOPPY_NAME
Language=English
Ovlada disketov jednotky
.

MessageID=9021 SymbolicName=SL_KBD_NAME
Language=English
Ovlada klvesnice
.

MessageID=9121 SymbolicName=SL_FAT_NAME
Language=English
Systm soubor FAT
.

MessageID=9022 SymbolicName=SL_SCSIPORT_NAME
Language=English
Ovlada rozhran SCSI
.

MessageID=9023 SymbolicName=SL_VIDEO_NAME
Language=English
Grafick ovlada
.

MessageID=9024 SymbolicName=SL_STATUS_REBOOT
Language=English
Restartujte pota stisknutm libovoln klvesy.
.

MessageID=9025 SymbolicName=SL_WARNING_ERROR
Language=English
Nastala neoekvan chyba (%d)
na dku %d v souboru %s.

Pokraujte stisknutm libovoln klvesy.
.

MessageID=9026 SymbolicName=SL_FLOPPY_NOT_FOUND
Language=English
Bylo nalezeno pouze %d disketovch jednotek,
systm se snail nalzt jednotku %d.
.

MessageID=9027 SymbolicName=SL_NO_MEMORY
Language=English
Systmu dola veker voln pam
na dku %d v souboru %s.
.

MessageID=9028 SymbolicName=SL_IO_ERROR
Language=English
V systmu dolo k V/V chyb
pi pstupu k souboru %s.
.

MessageID=9029 SymbolicName=SL_BAD_INF_SECTION
Language=English
Sekce %s souboru INF je neplatn.
.

MessageID=9030 SymbolicName=SL_BAD_INF_LINE
Language=English
dek %d souboru INF %s je neplatn
.

MessageID=9031 SymbolicName=SL_BAD_INF_FILE
Language=English
Soubor %s (INF) je pokozen nebo chyb, stav %d.
.

MessageID=9032 SymbolicName=SL_FILE_LOAD_FAILED
Language=English
Soubor %s se nepodailo nast.

Kd chyby je %d
.

MessageID=9033 SymbolicName=SL_INF_ENTRY_MISSING
Language=English
Poloka "%s" v sekci [%s]
souboru INF je pokozena nebo chyb.
.

MessageID=9034 SymbolicName=SL_PLEASE_WAIT
Language=English
Pokejte prosm...
.

MessageID=9035 SymbolicName=SL_CANT_CONTINUE
Language=English
Instalace neme pokraovat. Ukonete instalaci libovolnou klvesou.
.

MessageID=9036 SymbolicName=SL_PROMPT_SCSI
Language=English
Vyberte poadovan adaptr SCSI ze seznamu, nebo zvolte "Jin",
mte-li disketu s podporou danho zazen od vrobce adaptru.

.

MessageID=9037 SymbolicName=SL_PROMPT_OEM_SCSI
Language=English
Zvolili jste monost konfigurovat adaptr SCSI pro pouit v systmu 
Windows pomoc diskety s podporou zazen od vrobce adaptru.

Vyberte poadovan adaptr SCSI z nsledujcho seznamu, nebo se
stisknutm klvesy ESC vrate na pedchoz obrazovku.

.
MessageID=9038 SymbolicName=SL_PROMPT_HAL
Language=English
Instalanmu programu se nepodailo urit typ potae, nebo byla 
zvolena monost typ potae zadat run.

Vyberte typ potae z nsledujcho seznamu, nebo zvolte "Jin",
mte-li disketu s podporou zazen od vrobce potae.

K posouvn mezi polokami nabdky pouijte klvesy ipka nahoru a dol.

.

MessageID=9039 SymbolicName=SL_PROMPT_OEM_HAL
Language=English
Zvolili jste monost konfigurovat pota pro systm Windows
pomoc diskety s podporou zazen od vrobce potae.

Zadejte typ potae z nsledujcho seznamu, nebo se stisknutm
tlatka ESC vrate na pedchoz obrazovku.

K posouvn mezi polokami nabdky pouijte klvesy ipka nahoru a dol.

.

MessageID=9040 SymbolicName=SL_PROMPT_VIDEO
Language=English
Instalanmu programu se nepodailo urit typ nainstalovanho 
grafickho adaptru.

Vyberte grafick adaptr ze seznamu, nebo zvolte "Jin",
mte-li disketu s podporou zazen od vrobce adaptru.

.

MessageID=9041 SymbolicName=SL_PROMPT_OEM_VIDEO
Language=English
Zvolili jste monost konfigurovat grafick adaptr pro systm Windows
pomoc diskety s podporou zazen od vrobce adaptru.

Vyberte grafick adaptr z nsledujcho seznamu, nebo se stisknutm
tlatka ESC vrate na pedchoz obrazovku.

.

MessageID=9042 SymbolicName=SL_WARNING_ERROR_WFILE
Language=English
Soubor %s zpsobil neoekvanou chybu (%d)
na dku %d v %s.

Pokraujte stisknutm libovoln klvesy.
.

MessageID=9043 SymbolicName=SL_WARNING_IMG_CORRUPT
Language=English
Soubor %s je pokozen.

Pokraujte stisknutm libovoln klvesy.
.

MessageID=9044 SymbolicName=SL_WARNING_IOERR
Language=English
Pi pstupu k souboru %s dolo k V/V chyb.

Pokraujte stisknutm libovoln klvesy.
.

MessageID=9045 SymbolicName=SL_WARNING_NOFILE
Language=English
Soubor %s nebyl nalezen.

Pokraujte stisknutm libovoln klvesy.
.

MessageID=9046 SymbolicName=SL_WARNING_NOMEM
Language=English
Nedostatek pamti pro %s.

Pokraujte stisknutm libovoln klvesy.
.

MessageID=9047 SymbolicName=SL_DRIVE_ERROR
Language=English
SETUPLDR: Jednotku %s nelze otevt
.

MessageID=9048 SymbolicName=SL_NTDETECT_MSG
Language=English

Instalan program zjiuje hardwarovou konfiguraci potae...

.

MessageID=9049 SymbolicName=SL_NTDETECT_FAILURE
Language=English
NTDETECT selhal
.

MessageId=9050 SymbolicName=SL_SCRN_TEXTSETUP_EXITED
Language=English
Systm Windows nebyl nainstalovn.

Pokud je v jednotce A: vloena disketa, vyjmte ji.

Restartujte pota stisknutm klvesy ENTER.
.

MessageId=9051 SymbolicName=SL_SCRN_TEXTSETUP_EXITED_ARC
Language=English
Systm Windows nebyl nainstalovn.

Restartujte pota stisknutm klvesy ENTER.
.

MessageID=9052 SymbolicName=SL_REBOOT_PROMPT
Language=English
ENTER=Restartovat pota
.

MessageID=9053 SymbolicName=SL_WARNING_SIF_NO_DRIVERS
Language=English
Instalan program nenalezl dn ovladae spojen se zadanou volbou.

Pokraujte stisknutm libovoln klvesy.
.

MessageID=9054 SymbolicName=SL_WARNING_SIF_NO_COMPONENT
Language=English
Vloen disketa neobsahuje dn odpovdajc soubory podpory.

Pokraujte stisknutm libovoln klvesy.
.

MessageID=9055 SymbolicName=SL_WARNING_BAD_FILESYS
Language=English
Tuto disketu nelze pest, protoe obsahuje nerozpoznan systm soubor.

Pokraujte stisknutm libovoln klvesy.
.

MessageID=9056 SymbolicName=SL_BAD_UNATTENDED_SCRIPT_FILE
Language=English
Poloka

"%s"

souboru skriptu bezobslun instalace
v sekci [%s] souboru INF %s neexistuje.
.

MessageID=9057 SymbolicName=SL_MSG_PRESS_F5_OR_F6
Language=English
Chcete-li nainstalovat jin ovladae zazen SCSI nebo RAID, stisknte F6...
.

;//
;// The following three messages are used to provide the same mnemonic
;// keypress as is used in the Additional SCSI screen in setupdd.sys
;// (see setup\textmode\user\msg.mc--SP_MNEMONICS and SP_MNEMONICS_INFO)
;// The single character specified in SL_SCSI_SELECT_MNEMONIC must be
;// the same as that listed in the status text of SL_SCSI_SELECT_PROMPT
;// (and also referenced in the SL_SCSI_SELECT_MESSAGE_2).
;//
MessageID=9060 SymbolicName=SL_SCSI_SELECT_MNEMONIC
Language=English
S
.

MessageID=9061 SymbolicName=SL_SCSI_SELECT_PROMPT
Language=English
S=Specifikovat dal zazen   ENTER=Pokraovat   F3=Konec
.

MessageID=9062 SymbolicName=SL_SCSI_SELECT_MESSAGE_2
Language=English
  * Chcete-li specifikovat dal adaptry SCSI, jednotky CD-ROM, nebo 
    speciln adie disk pro pouit v systmu Windows, 
    vetn tch, pro n mte disketu s podporou zazen od vrobce 
    velkokapacitnch ukldacch zazen, stisknte klvesu S.

  * Pokud nemte disketu s podporou zazen od vrobce velkokapacitnch
    zazen, nebo nechcete specifikovat dn dal zazen pro 
    pouit v systmu Windows, stisknte klvesu ENTER.
.

MessageID=9063 SymbolicName=SL_SCSI_SELECT_MESSAGE_1
Language=English
Instalan program nemohl urit typ jednoho nebo vce velkokapacitnch
zazen, nainstalovanch v systmu, nebo byla zvolena monost urit 
adaptr run. Instalan program nyn nate podporu nsledujcch 
velkokapacitnch ukldacch zazen:
.

MessageID=9064 SymbolicName=SL_SCSI_SELECT_MESSAGE_3
Language=English
Instalan program nate podporu nsledujcch velkokapacitnch 
ukldacch zazen:
.

MessageID=9065 SymbolicName=SL_SCSI_SELECT_ERROR
Language=English
Instalan program nemohl nast podporu pro uren velkokapacitn
ukldac zazen. Instalan program nyn nate podporu nsledujcch 
velkokapacitnch ukldacch zazen:
.

MessageID=9066 SymbolicName=SL_TEXT_ANGLED_NONE
Language=English
<dn>
.

MessageID=9067 SymbolicName=SL_TEXT_SCSI_UNNAMED
Language=English
<nepojmenovan adaptr>
.

MessageID=9068 SymbolicName=SL_TEXT_OTHER_DRIVER
Language=English
Jin
.

MessageID=9069 SymbolicName=SL_TEXT_REQUIRES_486
Language=English
Systm Windows vyaduje procesor 80486 nebo vy.
.

MessageID=9070 SymbolicName=SL_NTPNP_NAME
Language=English
Exportn ovlada Plug & Play
.

MessageID=9071 SymbolicName=SL_PCI_IDE_EXTENSIONS_NAME
Language=English
Ovlada rozen PCI IDE
.

MessageID=9072 SymbolicName=SL_HW_FW_CFG_CLASS
Language=English
Systm Windows se nepodailo spustit z dvodu nsledujcho
problmu spoutc konfigurace firmwaru ARC:
.

MessageID=9073 SymbolicName=DIAG_SL_FW_GET_BOOT_DEVICE
Language=English
Nastaven parametru 'osloadpartition' je neplatn.
.

MessageID=9074 SymbolicName=LOAD_HW_FW_CFG_ACT
Language=English
Monosti konfigurace ARC naleznete v dokumentaci k systmu Windows
Dal informace naleznete v prukch k hardwaru.
.
MessageID=9075 SymbolicName=SL_NETADAPTER_NAME
Language=English
Ovlada sovho adaptru
.
MessageID=9076 SymbolicName=SL_TCPIP_NAME
Language=English
Sluba TCP/IP
.
MessageID=9077 SymbolicName=SL_NETBT_NAME
Language=English
Sluba WINS Client(TCP/IP)
.
MessageID=9078 SymbolicName=SL_MRXSMB_NAME
Language=English
Mini-pesmrova MRXSMB
.
MessageID=9079 SymbolicName=SL_MUP_NAME
Language=English
Systm soubor UNC
.
MessageID=9080 SymbolicName=SL_NDIS_NAME
Language=English
Ovlada NDIS
.
MessageID=9081 SymbolicName=SL_RDBSS_NAME
Language=English
Systm soubor SMB Redirector
.
MessageID=9082 SymbolicName=SL_NETBOOT_CARD_ERROR
Language=English
Sov karta ve vaem potai obsahuje star verzi pamti ROM
a nelze ji pout pro vzdlenou instalaci systmu Windows.
Obrate se na sprvce systmu nebo vrobce potae s dost
o inovaci pamti ROM.
.
MessageID=9083 SymbolicName=SL_NETBOOT_SERVER_ERROR
Language=English
Vybran obraz operanho systmu neobsahuje nezbytn ovladae
sovho adaptru. Pokuste se vybrat jin obraz operanho
systmu. Pokud problm trv, obrate se na sprvce systmu.
.
MessageID=9084 SymbolicName=SL_IPSEC_NAME
Language=English
Zabezpeen protokolu IP 
.
MessageID=9085 SymbolicName=SL_CMDCONS_MSG
Language=English
Konzola pro zotaven systmu Windows
.
MessageID=9086 SymbolicName=SL_KERNEL_TRANSITION
Language=English
Instalan program spout systm Windows
.
;#ifdef _WANT_MACHINE_IDENTIFICATION
MessageID=9087 SymbolicName=SL_BIOSINFO_NAME
Language=English
Data pro identifikaci potae
.
;#endif
MessageID=9088 SymbolicName=SL_KSECDD_NAME
Language=English
Sluba Zabezpeen jdra
.
MessageID=9089 SymbolicName=SL_WRONG_PROM_VERSION
Language=English
Systmov pam PROM (obsahujc firmware) je na ni rovni revize
ne je poadovno. Obrate se na technickou podporu spolenosti SGI nebo
navtivte webov server spolenosti SGI a podejte o aktualizaci pamti PROM
a instrukce k proveden aktualizace.

Poznmka: Vbrem pslun poloky spoutc obrazovky msto vchoz
poloky Instalace systmu Windows mete spustit pedchoz instalace
systmu Microsoft(R) Windows(R) NT nebo Windows(R) XP.
.
MessageID=9090 SymbolicName=SIGNATURE_CHANGED
Language=English
Instalan program zjistil v potai vce disk, kter nelze rozliit.
Instalan program problm opravil, ale je nutno restartovat pota.
.
MessageID=9091 SymbolicName=SL_KDDLL_NAME
Language=English
Kernel Debugger DLL
.

MessageID=9092 SymbolicName=SL_OEM_DRIVERINFO
Language=English
%s

Systm Windows ji m ovlada pro "%s".

Pokud vrobce nedoporuuje jinak, mli byste pout ovlada systmu Windows.
.

MessageID=9093 SymbolicName=SL_CONFIRM_OEMDRIVER
Language=English
S=Pout ovlada na disket  ENTER=Pout vchoz ovlada systmu Windows
.

MessageID=9094 SymbolicName=SL_OEMDRIVER_NEW
Language=English
Poskytnut ovlada je zejm novj ne vchoz ovlada systmu Windows.
.

MessageID=9095 SymbolicName=SL_INBOXDRIVER_NEW
Language=English
Poskytnut ovlada je pravdpodobn star ne vchoz ovlada systmu Windows
.

MessageID=9096 SymbolicName=SL_CMDCONS_STARTING
Language=English
Spoutn konzoly pro obnoven...
.

MessageID=9097 SymbolicName=SL_NTDETECT_CMDCONS
Language=English
Modul NTDETECT kontroluje hardware...
.

MessageID=9098 SymbolicName=SL_MSG_PRESS_ASR
Language=English
Stisknutm kvesy F2 spustte Automatick obnoven systmu (ASR)...
.

MessageID=9099 SymbolicName=SL_MSG_WARNING_ASR
Language=English
        Vlote disketu oznaenou:


Disketa pro automatick obnoven systmu Windows


            do disketov jednotky.



          Pak stisknte libovolnou klvesu.
.


MessageID=9100 SymbolicName=SL_TEXT_REQUIRED_FEATURES_MISSING
Language=English

Systm Windows poaduje urit funkce procesoru,
kter nejsou v procesoru tohoto potae k dispozici.
Systm Windows zejmna poaduje instrukce:

    CPUID
    CMPXCHG8B
.

MessageID=9101 SymbolicName=SL_MSG_PREPARING_ASR
Language=English
Pprava Automatickho obnoven systmu (ASR) (zruit mete klvesou ESC)...
.

MessageID=9102 SymbolicName=SL_MSG_ENTERING_ASR
Language=English
Spoutn Automatickho obnoven systmu...
.

MessageID=9103 SymbolicName=SL_MOUSE_NAME
Language=English
Ovlada myi
.

MessageID=9104 SymbolicName=SL_SETUP_STARTING
Language=English
Spoutn instalace systmu Windows...
.

MessageID=9105 SymbolicName=SL_MSG_INVALID_ASRPNP_FILE
Language=English
Soubor ASRPNP.SIF na disket Automatickho obnoven systmu je neplatn.
.

MessageID=9106 SymbolicName=SL_SETUP_STARTING_WINPE
Language=English
Spoutn pedinstalanho prosted systmu Windows...
.

MessageID=9107 SymbolicName=SL_NTDETECT_ROLLBACK
Language=English

Odinstalace kontroluje hardware...


.

MessageID=9108 SymbolicName=SL_ROLLBACK_STARTING
Language=English
Spoutn odinstalace systmu Windows...
.


MessageID=9109 SymbolicName=SL_NO_FLOPPY_DRIVE
Language=English
Instalan program nenalezl v potai disketovou jednotku k naten
ovlada z diskety od vrobce OEM.

    * Natn ovlada vrobce OEM zrute stisknutm klvesy ESC 
    
    * Instalaci ukonte stisknutm klvesy F3.
.

MessageID=9110 SymbolicName=SL_UPGRADE_IN_PROGRESS
Language=English
Tento pota je aktualizovn systmem Microsoft Windows.
Jak chcete pokraovat?

    * Stisknutm klvesy ENTER.bude pokraovat aktualizace

    * Chcete-li aktualizaci zruit a nainstalovat novou verzi
      systmu Microsoft Windows, stisknte klvesu F10.

    * Chcete-li instalan program ukonit bez instalace 
      systmu Microsoft Windows, stisknte klvesu F3.
.

MessageID=9111 SymbolicName=SL_DRVMAINSDB_NAME
Language=English
Data k identifikaci ovladae
.

MessageID=9112 SymbolicName=SL_OEM_FILE_LOAD_FAILED
Language=English
Naten ovlada vrobce OEM se nezdailo.

Pokraujte stisknutm libovoln klvesy.
.

MessageID=9113 SymbolicName=SL_SACDRV_NAME
Language=English
Podpora sluby EMS
.



; //
; // NOTE : donot change the Message ID values for SL_CMDCONS_PROGBAR_FRONT
; // and SL_CMDCONS_PROGBAR_BACK from 11513 & 11514
; //

;
; // The character used to draw the foregound in percent-complete bar
;
;
MessageID=11513 SymbolicName=SL_CMDCONS_PROGBAR_FRONT
Language=English

.

;
; // The character used to draw the background in percent-complete bar
;
;
MessageID=11514 SymbolicName=SL_CMDCONS_PROGBAR_BACK
Language=English

.

;
; //
; // Ramdisk related messages. DO NOT CHANGE the message numbers
; // as they are kept in sync with \base\boot\inc\ramdisk.h.
; //
;

MessageID=15000 SymbolicName=BL_RAMDISK_GENERAL_FAILURE
Language=English
Systm Windows nemohl bt sputn z dvodu chyby pi sputn z disku RAMDISK.
.

MessageID=15001 SymbolicName=BL_RAMDISK_INVALID_OPTIONS
Language=English
Parametry disku RAMDISK v souboru boot.ini jsou neplatn.
.

MessageID=15002 SymbolicName=BL_RAMDISK_BUILD_FAILURE
Language=English
Systmu Windows se nepodailo sestavit spustitelnou bitovou kopii disku RAMDISK.
.

MessageID=15003 SymbolicName=BL_RAMDISK_BOOT_FAILURE
Language=English
Systmu Windows se nepodailo otevt bitovou kopii disku RAMDISK.
.

MessageID=15004 SymbolicName=BL_RAMDISK_BUILD_DISCOVER
Language=English
Hledn serveru sestaven...
.

MessageID=15005 SymbolicName=BL_RAMDISK_BUILD_REQUEST
Language=English
Vydn spustiteln bitov kopie ze serveru sestaven...
.

MessageID=15006 SymbolicName=BL_RAMDISK_BUILD_PROGRESS_TIMEOUT
Language=English
Adresa IP serveru sestaven = %d.%d.%d.%d. Vyprel asov limit poslednho poadavku.     
.

MessageID=15007 SymbolicName=BL_RAMDISK_BUILD_PROGRESS_PENDING
Language=English
Adresa IP serveru sestaven = %d.%d.%d.%d. Posledn poadavek ek na zpracovn.     
.

MessageID=15008 SymbolicName=BL_RAMDISK_BUILD_PROGRESS_ERROR
Language=English
Adresa IP serveru sestaven = %d.%d.%d.%d. Posledn poadavek se nezdail.     
.

MessageID=15009 SymbolicName=BL_RAMDISK_BUILD_PROGRESS
Language=English
Adresa IP serveru sestaven = %d.%d.%d.%d.
.

MessageID=15010 SymbolicName=BL_RAMDISK_DOWNLOAD
Language=English
Natn bitov kopie disku RAMDISK...
.

MessageID=15011 SymbolicName=BL_RAMDISK_DOWNLOAD_NETWORK
Language=English
Stahovn protokolem TFTP z %d.%d.%d.%d
.

MessageID=15012 SymbolicName=BL_RAMDISK_DOWNLOAD_NETWORK_MCAST
Language=English
Vcesmrov stahovn protokolem TFTP z %d.%d.%d.%d:%d.
.

;#endif // _SETUPLDR_MSG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\arcdtect.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    arcdtect.c

Abstract:

    Provides HAL and SCSI detection for ARC-compliant machines.

Author:

    John Vert (jvert) 21-Oct-1993

Revision History:

--*/
#include "setupldr.h"
#include <stdlib.h>

#if defined(_IA64_)

//
// Stuff used for detecting video
//
#define MAX_VIDEO_ADAPTERS 5
ULONG VideoAdapterCount;
PCONFIGURATION_COMPONENT_DATA VideoAdapter[MAX_VIDEO_ADAPTERS];

VOID
DecideVideoAdapter(
    VOID
    );

BOOLEAN FoundUnknownScsi;

//
// private function prototypes
//
BOOLEAN
EnumerateSCSIAdapters(
    IN PCONFIGURATION_COMPONENT_DATA ConfigData
    );

BOOLEAN
EnumerateVideoAdapters(
    IN PCONFIGURATION_COMPONENT_DATA ConfigData
    );



VOID
SlDetectScsi(
    IN PSETUP_LOADER_BLOCK SetupBlock
    )
/*++

Routine Description:

    Detects SCSI adapters on an ARC machine by walking the ARC firmware tree.

    Fills in the appropriate entries in the setuploaderblock


Arguments:

    SetupBlock - Supplies a pointer to the setup loader block.

Return Value:

    None.

--*/

{
    FoundUnknownScsi = FALSE;

    BlSearchConfigTree(BlLoaderBlock->ConfigurationRoot,
                       AdapterClass,
                       ScsiAdapter,
                       (ULONG)-1,
                       EnumerateSCSIAdapters);
    if (FoundUnknownScsi) {
        //
        // We found at least one scsi device we didn't recognize,
        // so force the OEM selection menu.
        //
        PromptOemScsi=TRUE;
    }

    SetupBlock->ScalarValues.LoadedScsi = 1;
}


BOOLEAN
EnumerateSCSIAdapters(
    IN PCONFIGURATION_COMPONENT_DATA ConfigData
    )

/*++

Routine Description:

    Callback function for enumerating SCSI adapters in the ARC tree.

    Adds the SCSI adapter that was found to the list of detected SCSI devices.

Arguments:

    ConfigData - Supplies a pointer to the ARC node of the SCSI adapter.

Return Value:

    TRUE - continue searching

    FALSE - some error, abort the search

--*/

{
    PDETECTED_DEVICE ScsiDevice;
    PCHAR AdapterName;
    ULONG Ordinal;
    PCHAR ScsiFileName;
    PTCHAR ScsiDescription;
    SCSI_INSERT_STATUS sis;

    AdapterName = SlSearchSection("Map.SCSI",ConfigData->ComponentEntry.Identifier);
    if (AdapterName==NULL) {
        //
        // We found an adapter in the ARC tree, but it is not one of the ones
        // specified in our INF file, so trigger the prompt for an OEM driver
        // disk.
        //

        FoundUnknownScsi = TRUE;
        return(TRUE);
    }

    //
    // Find this adapter's ordinal within the Scsi.Load section of txtsetup.sif
    //
    Ordinal = SlGetSectionKeyOrdinal(InfFile, "Scsi.Load", AdapterName);
    if(Ordinal == (ULONG)-1) {
        FoundUnknownScsi = TRUE;
        return(TRUE);
    }

    //
    // Find the driver filename
    //
    ScsiFileName = SlGetSectionKeyIndex(InfFile,
                                        "Scsi.Load",
                                        AdapterName,
                                        SIF_FILENAME_INDEX);
    if(!ScsiFileName) {
        FoundUnknownScsi = TRUE;
        return(TRUE);
    }

    //
    // Create a new detected device entry.
    //
    if((sis = SlInsertScsiDevice(Ordinal, &ScsiDevice)) == ScsiInsertError) {
        SlFriendlyError(ENOMEM, "SCSI detection", 0, NULL);
        return(FALSE);
    }

    if(sis == ScsiInsertExisting) {
#if DBG
        //
        // Sanity check to make sure we're talking about the same driver
        //
        if(_stricmp(ScsiDevice->BaseDllName, ScsiFileName)) {
            SlError(400);
            return FALSE;
        }
#endif
    } else {
        //
        // Find the driver description
        //
#ifdef UNICODE
        ScsiDescription = SlGetIniValueW(
#else
        ScsiDescription = SlGetIniValue(
#endif
                                    InfFile,
                                    "SCSI",
                                    AdapterName,
                                    AdapterName);

        ScsiDevice->IdString = AdapterName;
        ScsiDevice->Description = ScsiDescription;
        ScsiDevice->ThirdPartyOptionSelected = FALSE;
        ScsiDevice->FileTypeBits = 0;
        ScsiDevice->Files = NULL;
        ScsiDevice->BaseDllName = ScsiFileName;
    }

    return(TRUE);
}

VOID
SlDetectVideo(
    IN PSETUP_LOADER_BLOCK SetupBlock
    )
/*++

Routine Description:

    Detects video adapters on an ARC machine by walking the ARC firmware tree.

    Fills in the appropriate entries in the setuploaderblock


Arguments:

    SetupBlock - Supplies a pointer to the setup loader block.

Return Value:

    None.

--*/

{
    //
    // On arc machines, there is no default video type.
    //
    SetupBlock->VideoDevice.Next = NULL;
    SetupBlock->VideoDevice.IdString = NULL;
    SetupBlock->VideoDevice.ThirdPartyOptionSelected = FALSE;
    SetupBlock->VideoDevice.FileTypeBits = 0;
    SetupBlock->VideoDevice.Files = NULL;
    SetupBlock->VideoDevice.BaseDllName = NULL;
    SetupBlock->Monitor = NULL;
    SetupBlock->MonitorId = NULL;

    BlSearchConfigTree(BlLoaderBlock->ConfigurationRoot,
                       ControllerClass,
                       DisplayController,
                       (ULONG)-1,
                       EnumerateVideoAdapters);

    DecideVideoAdapter();
}


BOOLEAN
EnumerateVideoAdapters(
    IN PCONFIGURATION_COMPONENT_DATA ConfigData
    )

/*++

Routine Description:

    Callback function for enumerating video adapters in the ARC tree.

    Adds the video adapter that was found to the setup block.

Arguments:

    ConfigData - Supplies a pointer to the ARC node of the display adapter.

Return Value:

    TRUE - continue searching

    FALSE - some error, abort the search

--*/

{
    //
    // Just remember this guy for later.
    //
    if(VideoAdapterCount < MAX_VIDEO_ADAPTERS) {
        VideoAdapter[VideoAdapterCount++] = ConfigData;
    }
    return(TRUE);
}

VOID
DecideVideoAdapter(
    VOID
    )
{
    IN PCONFIGURATION_COMPONENT_DATA ConfigData;
    PCHAR AdapterName,MonitorId;
    PCONFIGURATION_COMPONENT_DATA MonitorData;
    PMONITOR_CONFIGURATION_DATA Monitor;
    CHAR ArcPath[256];
    CHAR ConsoleOut[256];
    PCHAR p,q;
    ULONG u;

    if(VideoAdapterCount) {
        //
        // The first thing we want to do is to see whether any of the
        // adapters we found match the value of the CONSOLEOUT nvram var.
        // If so then use that node for detection. Before comparing we have to
        // change all instances of () to (0) in the value of CONSOLEOUT.
        //
        ConfigData = NULL;
        if(p = ArcGetEnvironmentVariable("CONSOLEOUT")) {
            strncpy(ArcPath,p,sizeof(ArcPath)-1);
            ArcPath[sizeof(ArcPath)-1] = 0;
            ConsoleOut[0] = 0;
            for(p=ArcPath; q=strstr(p,"()"); p=q+2) {
                *q = 0;
                strcat(ConsoleOut,p);
                strcat(ConsoleOut,"(0)");
            }
            strcat(ConsoleOut,p);

            //
            // Finally, we need to truncate the consoleout variable after
            // the video adapter, if any.
            //
            _strlwr(ConsoleOut);
            if(p = strstr(ConsoleOut,")video(")) {
                *(p+sizeof(")video(")+1) = 0;
            }

            for(u=0; u<VideoAdapterCount; u++) {

                ArcPath[0] = 0;
                BlGetPathnameFromComponent(VideoAdapter[u],ArcPath);

                if(!_stricmp(ConsoleOut,ArcPath)) {
                    ConfigData = VideoAdapter[u];
                    break;
                }
            }
        }

        //
        // If we didn't find a match for CONSOLEOUT then use the last node
        // we found in the tree scan.
        //
        if(!ConfigData) {
            ConfigData = VideoAdapter[VideoAdapterCount-1];
        }

        AdapterName = SlSearchSection("Map.Display",ConfigData->ComponentEntry.Identifier);
        if (AdapterName==NULL) {
            //
            // We found a display adapter in the ARC tree, but it is not one of the ones
            // specified in our INF file, so trigger the prompt for an OEM driver
            // disk.
            //

            PromptOemVideo = TRUE;
            return;
        }

        BlLoaderBlock->SetupLoaderBlock->VideoDevice.IdString = AdapterName;
        BlLoaderBlock->SetupLoaderBlock->VideoDevice.Description = NULL;
        BlLoaderBlock->SetupLoaderBlock->VideoDevice.ThirdPartyOptionSelected = FALSE;
        BlLoaderBlock->SetupLoaderBlock->VideoDevice.FileTypeBits = 0;
        BlLoaderBlock->SetupLoaderBlock->VideoDevice.Files = NULL;
        BlLoaderBlock->SetupLoaderBlock->VideoDevice.BaseDllName = NULL;

        //
        // If there is a monitor peripheral associated with this device,
        // capture its configuration data.  Otherwise, let Setup assume an
        // appropriate default.
        //

        MonitorData = ConfigData->Child;
        if (MonitorData==NULL) {
            BlLoaderBlock->SetupLoaderBlock->Monitor = NULL;
            BlLoaderBlock->SetupLoaderBlock->MonitorId = NULL;
        } else {
            Monitor = BlAllocateHeap(MonitorData->ComponentEntry.ConfigurationDataLength);
            if (Monitor==NULL) {
                SlFriendlyError(ENOMEM, "video detection", 0, NULL);
                return;
            }
            MonitorId = BlAllocateHeap(MonitorData->ComponentEntry.IdentifierLength+1);
            if (MonitorId==NULL) {
                SlFriendlyError(ENOMEM, "video detection", 0, NULL);
                return;
            }

            strncpy(MonitorId,
                    MonitorData->ComponentEntry.Identifier,
                    MonitorData->ComponentEntry.IdentifierLength);

            MonitorId[MonitorData->ComponentEntry.IdentifierLength] = 0;

            RtlCopyMemory((PVOID)Monitor,
                          MonitorData->ConfigurationData,
                          MonitorData->ComponentEntry.ConfigurationDataLength);

            BlLoaderBlock->SetupLoaderBlock->Monitor = Monitor;
            BlLoaderBlock->SetupLoaderBlock->MonitorId = MonitorId;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\br\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\chs\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\cht\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\cs\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\da\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\daytona_dbg\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\el\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

#
# BOOT_LIB_DIR is the relative path to boot.lib.
#
$(O)\msgs.mc : ..\msgs.$(LANGUAGE)
    copy $** $@

!IF $(386)

!IFNDEF BOOT_LIB_DIR
ENTRYPOINT=-entry:NtProcessStartup@4
LDR_NAME=setupldr$(DBG_LDR).exe
BOOT_LIB_DIR=daytona$(DBG_LDR)
!ENDIF


SETUPLDR_LIBS= \
    $(O)\setupldr.lib \
    $(O)\setupldr.res \
    $(PROJECT_ROOT)\boot\lib\$(BOOT_LIB_DIR)\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\bd\daytona$(DBG_LDR)\$(O)\bd.lib \
    $(PROJECT_ROOT)\boot\tftplib\$(O)\tftplib.lib \
    $(PROJECT_ROOT)\boot\bootssp\boot\$(O)\bootssp.lib \
    $(PROJECT_ROOT)\ntos\ke\up\$(O)\ke.lib \
    $(PROJECT_ROOT)\ntos\rtl\boot$(DBG_LDR)\$(O)\bldrrtl$(DBG_LDR).lib \
    $(PROJECT_ROOT)\ntos\config\boot\$(O)\bconfig.lib \
    $(DS_LIB_PATH)\rsa32.lib \
    $(SDK_LIB_PATH)\fdi.lib \
    $(SDK_LIB_PATH)\libcntpr.lib \


$(O)\link.rsp : ..\makefile.inc
    type << > $@
-base:0x300000
-debug
$(ENTRYPOINT)
-fixed
-ignore:4001
-incremental:no
-machine:ix86
-map
-nodefaultlib
-opt:ref
-opt:icf
-subsystem:native
$(LINK_TIME_CODE_GENERATION_LINKER_FLAGS)
$(LINK_LIB_IGNORE_FLAG)
$(SETUPLDR_LIBS)
<<NOKEEP

$(O)\setupldr.res: $(O)\msgs.mc

$(O)\$(LDR_NAME): $(SETUPLDR_LIBS) makefile.inc $(O)\link.rsp
    $(LINK_NAME) -out:$@ @$(O)\link.rsp

!IFNDEF NTVERSION
STARTUP=i386\startup\a20.asm     \
        i386\startup\abios.inc   \
        i386\startup\abiosa.asm  \
        i386\startup\backend.asm \
        i386\startup\constant.h  \
        i386\startup\display.c   \
        i386\startup\eisac.c     \
        i386\startup\eisaa.asm   \
        i386\startup\eisa.h      \
        i386\startup\eisa.inc    \
        i386\startup\exp.asm     \
        i386\startup\global.h    \
        i386\startup\macro.inc   \
        i386\startup\main.c      \
        i386\startup\memmap.h    \
        i386\startup\memmap.inc  \
        i386\startup\su.asm      \
        i386\startup\su.h        \
        i386\startup\su.inc      \
        i386\startup\sudata.asm  \
        i386\startup\trap.asm    \
        i386\startup\trapdump.c  \
        i386\startup\types.h

!ENDIF

#
# STARTUP_DIR is the relative path to startup.com.
# All languages use their own startup.com,
# except FE langauges which use the US version when
# creating setupldr.bin.
#
!IFNDEF STARTUP_DIR
STARTUP_DIR=$(ALT_PROJECT)
!ENDIF

$(O)\setupldr$(DBG_LDR).bin: $(O)\setupldr$(DBG_LDR).exe ..\..\startup\$(STARTUP_DIR)\$(_OBJ_DIR)\i386\startup.com makefile.inc
    -copy $(O)\setupldr$(DBG_LDR).exe $(O)\setupldr.spl
    splitsym -a $(O)\setupldr.spl
    -copy /b ..\..\startup\$(STARTUP_DIR)\$(_OBJ_DIR)\i386\startup.com+$(O)\setupldr.spl $@
    -del /q $(O)\setupldr.dbg

!ELSE IF $(IA64)
EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

!if $(IA64)
LIBSRC=sal64
MACH=IA64
!else
LIBSRC=nt32
MACH=x86
!endif

#Add in -fixed if debugging with an ITP to get a known base

SETUPLDR_LIBS=\
    $(O)\setupldr.lib \
    $(O)\setupldr.res \
    $(PROJECT_ROOT)\boot\lib\daytona$(DBG_LDR)\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\bd\daytona$(DBG_LDR)\$(O)\bd.lib \
    $(PROJECT_ROOT)\boot\efi\daytona$(DBG_LDR)\$(O)\efi.lib \
    $(PROJECT_ROOT)\boot\tftplib\$(O)\tftplib.lib \
    $(PROJECT_ROOT)\boot\bootssp\boot\$(O)\bootssp.lib \
    $(PROJECT_ROOT)\ntos\ke\up\$(O)\ke.lib \
    $(PROJECT_ROOT)\ntos\ex\up\$(O)\ex.lib \
    $(PROJECT_ROOT)\ntos\rtl\boot$(DBG_LDR)\$(O)\bldrrtl$(DBG_LDR).lib \
    $(PROJECT_ROOT)\ntos\config\boot\$(O)\bconfig.lib \
    $(DS_LIB_PATH)\rsa32.lib \
    $(SDK_LIB_PATH)\fdi.lib \
    $(SDK_LIB_PATH)\libcntpr.lib \
    $(DDK_LIB_PATH)\hal.lib
                
$(O)\link.rsp : ..\makefile.inc
    type << > $@
-subsystem:EFI_APPLICATION
-nodefaultlib
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-machine:IA64
-base:0x1040000
!IF "$(BUILD_DEBUG_LOADER)" != ""
-fixed
!ENDIF
-opt:ref
-opt:icf
-entry:main
-map
-ignore:4049,4001,4217
$(LINK_TIME_CODE_GENERATION_LINKER_FLAGS)
$(LINK_LIB_IGNORE_FLAG)
$(SETUPLDR_LIBS)
<<NOKEEP

$(O)\setupldr.res: $(O)\msgs.mc

$(O)\setupldr$(DBG_LDR).efi: $(SETUPLDR_LIBS) makefile.inc $(O)\link.rsp
    -$(LINK_NAME) -out:$@ @$(O)\link.rsp

$(O)\setupldr.dbg: $(O)\setupldr$(DBG_LDR).efi
    -pe2dbg $? $@

SETUP_LIB_COMPONENTS = \
    $(PROJECT_ROOT)\boot\lib\daytona$(DBG_LDR)\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\efi\daytona$(DBG_LDR)\$(O)\efi.lib

!ELSE

SETUPLDR_LIBS=\
    $(O)\setupldr.lib \
    $(O)\setupldr.res \
    $(PROJECT_ROOT)\boot\lib\daytona$(DBG_LDR)\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\bd\daytona$(DBG_LDR)\$(O)\bd.lib \
    $(PROJECT_ROOT)\boot\tftplib\$(O)\tftplib.lib \
    $(PROJECT_ROOT)\boot\bootssp\boot\$(O)\bootssp.lib \
    $(PROJECT_ROOT)\ntos\ke\up\$(O)\ke.lib \
    $(PROJECT_ROOT)\ntos\rtl\boot$(DBG_LDR)\$(O)\bldrrtl$(DBG_LDR).lib \
    $(DS_LIB_PATH)\rsa32.lib \
    $(SDK_LIB_PATH)\fdi.lib \
    $(SDK_LIB_PATH)\libcntpr.lib

$(O)\link.rsp : ..\makefile.inc
    type << >$@
-rom
-nodefaultlib
-debugtype:cv
-debug:full
-align:0x200
-fixed
!if $(ALPHA)
-base:0x80600000
!elseif $(AXP64)
-base:0xFFFFFFFF80600000
!endif
-entry:SlInit
-map
-opt:noicf
$(LINK_TIME_CODE_GENERATION_LINKER_FLAGS)
$(LINK_LIB_IGNORE_FLAG)
$(SETUPLDR_LIBS)
<<NOKEEP

$(O)\setupldr.res: $(O)\msgs.mc

$(O)\setupldr$(DBG_LDR): $(SETUPLDR_LIBS) makefile.inc $(O)\link.rsp
    -$(LINK_NAME) -out:$@ @$(O)\link.rsp
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\es\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\fi\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\ger\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\fr\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\hu\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\setup\setup.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    setup.c

Abstract:

    This module contains the code that implements the NT setup loader

Author:

    John Vert (jvert) 6-Oct-1993

Environment:

    ARC Environment

Revision History:

--*/

#include <setupbat.h>
#include "setupldr.h"
#include "stdio.h"
#include "string.h"
#include "stdlib.h"
#include <dockinfo.h>
#include <netboot.h>
#include <ramdisk.h>
#include "acpitabl.h"

#ifdef i386
#include <bldrx86.h>
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

#if defined(EFI)
#include "bootefi.h"
#endif

#if defined(_IA64_)
UCHAR OsLoaderName[] = "setupldr.efi";
#else
UCHAR OsLoaderName[] = "setupldr.exe";
#endif

#if defined(_WIN64) && defined(_M_IA64)
#pragma section(".base", long, read, write)
__declspec(allocate(".base"))
extern
PVOID __ImageBase;
#else
extern
PVOID __ImageBase;
#endif


#define BlDiagLoadMessage(x,y,z)

#define DRIVER_DATABASE_FILENAME L"drvmain.sdb"
#define KERNEL_UP_IMAGE_FILENAME LEGACY_KERNEL_NAME
#define KERNEL_MP_IMAGE_FILENAME MP_KERNEL_NAME
CHAR KernelImage[13];
BOOLEAN UseCommandConsole = FALSE;
BOOLEAN g_RollbackEnabled = FALSE;
BOOLEAN TryASRViaNetwork = FALSE;

CHAR KdFileName[8+1+3+1]="KDCOM.DLL";
BOOLEAN UseAlternateKdDll = FALSE;
#define KD_ALT_DLL_PREFIX_CHARS 2
#define KD_ALT_DLL_REPLACE_CHARS 6

#if defined(_X86_) && !defined(ALLOW_386)
    //
    // Disallow installation on a 386 or any processor which
    // does not support CPUID and CMPXCHG8B instructions.
    //
    extern BOOLEAN BlIs386(VOID);
    extern ULONG   BlGetFeatureBits(VOID);
#endif

#define DBG_OUT(x)

/*
//
//  For debugging purposes
//  Example:
//
//        DBG_OUT("Testing")
//
#define DBG_OUT(x) {                                                            \
    if (x) {                                                                    \
        BlPositionCursor(5, 10);                                                \
        BlPrint("                                                        ");    \
        BlPositionCursor(5, 10);                                                \
        BlPrint(x);                                                             \
        while (!SlGetChar());                                                   \
    }                                                                           \
}

//
//  For debugging purposes
//  Example:
//
//      DebugOutput("Calling SlDetectScsi(). Line = %d. %s\n",__LINE__,"")
//
//
#define DebugOutput(X,Y,Z) {                                      \
    if (ARC_CONSOLE_OUTPUT) {                                      \
        CHAR _b[128];                                                \
        ULONG _c;                                                    \
        sprintf(&_b[0], X, Y, Z);                                    \
        ArcWrite(ARC_CONSOLE_OUTPUT, &_b[0], strlen(&_b[0]), &_c); \
        SlGetChar();                                                \
    }                                                                \
}
*/

//
// Define external static data.
//

ULONG BlConsoleOutDeviceId = ARC_CONSOLE_OUTPUT;
ULONG BlConsoleInDeviceId = ARC_CONSOLE_INPUT;

//
// Global string constants.
//
PCHAR FilesSectionName = "SourceDisksFiles";
PCHAR MediaSectionName = "SourceDisksNames";

#if defined(_AXP64_)
PCHAR PlatformExtension = ".axp64";
#elif defined(_ALPHA_)
PCHAR PlatformExtension = ".alpha";
#elif defined(_IA64_)
PCHAR PlatformExtension = ".ia64";
#elif defined(_X86_)
#define PlatformExtension (BlAmd64Setup(NULL) ? ".amd64" : ".x86")
#endif

//
// Global data
//

ULONG BlDcacheFillSize = 32;
ULONG BlVirtualBias = 0;

//
// Global setupldr control values
//
MEDIA_TYPE BootMedia;
MEDIA_TYPE InstallMedia;
PCHAR BootDevice;
ULONG BootDeviceId;
BOOLEAN BootDeviceIdValid = FALSE;
PCHAR BootPath;
ULONG BootDriveNumber;
ULONG InstallDriveNumber;
PCHAR HalName;
PCHAR HalDescription;
PCHAR AnsiCpName;
PCHAR OemHalFontName;
UNICODE_STRING AnsiCodepage;
UNICODE_STRING OemCodepage;
UNICODE_STRING UnicodeCaseTable;
UNICODE_STRING OemHalFont;

#ifdef _WANT_MACHINE_IDENTIFICATION
UNICODE_STRING BiosInfo;
#endif

BOOLEAN LoadScsiMiniports;
BOOLEAN LoadDiskClass;
BOOLEAN LoadCdfs;
BOOLEAN FixedBootMedia = FALSE;
BOOLEAN FloppyBoot = FALSE;

PVOID InfFile;
PVOID WinntSifHandle;
PVOID MigrateInfHandle;
ULONG BootFontImageLength = 0;
PVOID UnsupDriversInfHandle;
BOOLEAN IgnoreMissingFiles;
BOOLEAN BlUsePae;
BOOLEAN UseRegularBackground = TRUE;
BOOLEAN IsUpgrade = FALSE;

//
// OEM related variables
//
POEM_SOURCE_DEVICE OemSourceDevices = NULL;
POEM_SOURCE_DEVICE DefaultOemSourceDevice = NULL;
POEM_SOURCE_DEVICE AutoLoadOemHalDevice = NULL;
BOOLEAN AutoLoadOemScsi = FALSE;

//
//  Pre-install stuff
//

PCHAR   OemTag = "OEM";
PTCHAR   _TOemTag = TEXT("OEM");
BOOLEAN PreInstall = FALSE;
PTCHAR  ComputerType = NULL;
BOOLEAN OemHal = FALSE;
PPREINSTALL_DRIVER_INFO PreinstallDriverList = NULL;
POEM_SOURCE_DEVICE PreInstallOemSourceDevice = NULL;
PCHAR PreInstallSourcePath = NULL;

//
// Dynamic update variables
//
static BOOLEAN DynamicUpdate = FALSE;
static PCSTR   DynamicUpdateRootDir = NULL;
static POEM_SOURCE_DEVICE DynamicUpdateSourceDevice = NULL;

//
// WinPE (aka MiniNT) global variables
//
BOOLEAN WinPEBoot = FALSE;
BOOLEAN WinPEAutoBoot = FALSE;

PCTSTR  StartupMsg = NULL;

//
// Is used by HALACPI.DLL
//
BOOLEAN DisableACPI = FALSE;

BOOLEAN isOSCHOICE = FALSE;

//
// Primarily used by floppy boot support to key track 
// of the last disk read
// 
PCHAR LastDiskTag = NULL;

//
// TRUE if user pressed F8
//
BOOLEAN EnableDebugger = FALSE;

//
// TRUE if user presses F4.
//
BOOLEAN DisableVirtualOemDevices = FALSE;

#if defined(ELTORITO)
extern BOOLEAN ElToritoCDBoot;
#endif

//
// Define transfer entry of loaded image.
//

typedef
VOID
(*PTRANSFER_ROUTINE) (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

#if defined(_IA64_)

VOID
BuildArcTree();

#endif

//
// Local function prototypes
//
VOID
SlGetSetupValuesBeforePrompt(
    IN PSETUP_LOADER_BLOCK SetupBlock
    );

VOID
SlGetSetupValuesAfterPrompt(
    IN PSETUP_LOADER_BLOCK SetupBlock
    );

ARC_STATUS
SlLoadDriver(
    IN PTCHAR  DriverDescription,
    IN PCHAR   DriverName,
    IN ULONG   DriverFlags,
    IN BOOLEAN InsertIntoDriverList,
    IN BOOLEAN MigratedDriver,
    IN PCHAR   ServiceName OPTIONAL
    );

ARC_STATUS
SlLoadOemDriver(
    IN PCHAR  ExportDriver OPTIONAL,
    IN PCHAR  DriverName,
    IN PVOID  BaseAddress,
    IN PTCHAR LoadMessage
    );

PBOOT_DRIVER_LIST_ENTRY
SlpCreateDriverEntry(
    IN PCHAR DriverName,
    IN PCHAR ServiceName OPTIONAL
    );

    
ARC_STATUS
SlDetectMigratedScsiDrivers(
    IN PVOID Inf
    );

ARC_STATUS
SlGetMigratedHardwareIds(
    IN PSETUP_LOADER_BLOCK SetupBlock,
    IN PVOID               Inf
    );

BOOLEAN
SlpIsDiskVacant(
    IN PARC_DISK_SIGNATURE DiskSignature
    );

ARC_STATUS
SlpStampFTSignature(
    IN PARC_DISK_SIGNATURE DiskSignature,
    IN BOOLEAN  GenerateNewSignature
    );

VOID
SlpMarkDisks(
    IN BOOLEAN Reboot
    );


VOID
SlCheckOemKeypress(
    IN ULONG WaitTime
    );

VOID
SlCheckASRKeypress(
    VOID
    );

ARC_STATUS
SlLoadPnpDriversSection(
    IN PVOID Inf,
    IN PCHAR SectionName,
    IN OUT PDETECTED_DEVICE* DetectedDeviceList OPTIONAL
    );

BOOLEAN
SlIsUpgrade(
    IN PVOID SifHandle
    );

BOOLEAN
SlIsCdBootUpgrade(
    IN  PCHAR   InstallDirectory,
    IN  PCHAR   SetupFileName,
    IN  ULONG   MaxDisksToScan,
    IN  ULONG   MaxPartitionsPerDisk,
    OUT PCHAR   SetupDevice
    );

ARC_STATUS
SlLoadBootFontFile(
    IN PSETUP_LOADER_BLOCK SetupLoaderBlock,
    IN ULONG DiskId,
    IN ULONG BootFontImageLength
    );

//
// Dynamic update function prototypes
//
BOOLEAN
SlpIsDynamicUpdate(
    IN  PVOID   InfHandle,
    OUT PCSTR   *DynamicUpdateRootDir
    );

BOOLEAN
SlModifyOsLoadOptions(
    IN OUT PSTR* LoadOptions,
    IN PCSTR OptionsToAdd OPTIONAL,
    IN PCSTR OptionsToRemove OPTIONAL
    );

BOOLEAN
SlIsVirtualOemDeviceDisabled(
    IN      PVOID SifHandle, 
    IN      PPREINSTALL_DRIVER_INFO PreinstallDriverList
    );

VOID
SlDisableVirtualOemDevices(
    IN      POEM_SOURCE_DEVICE OemDeviceList
    );

ARC_STATUS
SlInit(
    IN ULONG Argc,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Argv,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Envp
    )

/*++

Routine Description:

    The main startup routine for the NT Setup Loader.  This is the entrypoint
    called by the ARC firmware.

    If successful, this routine will never return, it will start NT directly.

Arguments:

    Argc - Supplies the number of arguments that were provided on the
        command that invoked this program.

    Argv - Supplies a pointer to a vector of pointers to null terminated
        argument strings.

    Envp - Supplies a pointer to a vector of pointers to null terminated
        environment variables.

Return Value:

    ARC_STATUS if unsuccessful.


--*/

{
    //
    // if we use too much stack space the heap and stack can overlap and we can run into corruption problems
    // without any "stack overflow" exceptions; making large strings static helps prevent this
    //

    PCONFIGURATION_COMPONENT_DATA DataCache;
    ARC_STATUS Status;
    ULONG LinesPerBlock;
    ULONG CacheLineSize;
    static CHAR SetupDevice[128];
    static CHAR SetupDirectory[128];
    static CHAR BadFileName[128];
    static CHAR CanonicalName[128];
    static CHAR HalDirectoryPath[256];
    static CHAR KernelDirectoryPath[256];
    PCHAR NetSetupServerShare = NULL;
    PCHAR NetSetupPath = NULL;
    PCHAR p;
    ULONG ErrorLine=0;
    ULONG DontCare;
    PVOID SystemBase;
    PVOID HalBase;
    PVOID VideoBase;
    PCHAR FileName;
    PVOID KdDllBase;
    static CHAR KdDllName[256];
    ULONG i;
    PKLDR_DATA_TABLE_ENTRY SystemDataTableEntry;
    PKLDR_DATA_TABLE_ENTRY HalDataTableEntry;
    PKLDR_DATA_TABLE_ENTRY KdDataTableEntry;
    PTRANSFER_ROUTINE SystemEntry;
    PIMAGE_NT_HEADERS NtHeaders;
    PBOOT_DRIVER_LIST_ENTRY DriverEntry;
    PSETUP_LOADER_BLOCK SetupBlock;
    PDETECTED_DEVICE ScsiDevice;
    PCHAR VideoFileName;
    PTCHAR VideoDescription;
    POEMSCSIINFO OemScsiInfo = NULL;
    PCHAR OemVideoName;
    PVOID   OemInfHandle = NULL;
    BOOLEAN LoadedAVideoDriver = FALSE;
    static CHAR NetbootCardDriverName[24];
    static CHAR NetbootUser[64];
    static CHAR NetbootDomain[64];
    static CHAR NetbootPassword[64];
    static CHAR NetbootAdministratorPassword[OSC_ADMIN_PASSWORD_LEN];
    static CHAR NetbootSifFile[128];
    DOCKING_STATION_INFO dockInfo = { 0, 0, 0, FW_DOCKINFO_DOCK_STATE_UNKNOWN };
    PCONFIGURATION_COMPONENT_DATA dockInfoData;
    extern ULONG BlProgressBarShowTimeOut;
    extern ULONG BlDisableProgressBar;
#if defined (_X86_)
    extern BOOLEAN AllowGraphicsReset;
#endif
    ULONG OemKeypressTimeout = 5;   //secs

#if defined(REMOTE_BOOT)
    BOOLEAN RemoteBootEnableIpsec = FALSE;
#endif // defined(REMOTE_BOOT)
#if defined(_X86_) || defined(_IA64_)
    BOOLEAN Win9xUnsupHdc = FALSE;
#endif
    static FULL_PATH_SET PathSet;
    UNICODE_STRING DrvMainSdb;

#if DBG
    ULONG   StartTime = 0;
#endif

#if defined(_ALPHA_) || defined(ARCI386) || defined(_IA64_)
    PVOID LoaderBase;
#endif

    UNREFERENCED_PARAMETER( Envp );

    //
    // Disable progress bar, by default.
    //
    BlDisableProgressBar = TRUE;


#ifdef EFI
    // 
    // set the efi watchdog timer to 20 minutes.  the boot manager sets it to 5, but
    // setupldr could take longer than this, especially if installing over the 
    // network
    //
    SetEFIWatchDog(EFI_WATCHDOG_TIMEOUT);
#endif

#if defined (_X86_)
    //
    // Do not allow display to be reset at the end of setupldr.
    // this would leave the screen blank for ~30 seconds, until
    // textmode setup reinitializes the display
    //
    AllowGraphicsReset = FALSE;
#endif

    //
    // Initialize the boot debugger for platforms that directly load the
    // OS Loader.
    //
    // N.B. This must occur after the console input and output have been
    //      initialized so debug messages can be printed on the console
    //      output device.
    //
    
#if defined(_ALPHA_) || defined(ARCI386) || defined(_IA64_)

    LoaderBase = &__ImageBase;

    //
    // Initialize traps and the boot debugger.
    //

#if defined(ENABLE_LOADER_DEBUG)

#if defined(_ALPHA_)

    BdInitializeTraps();

#endif
    
    BdInitDebugger((PCHAR)OsLoaderName, LoaderBase, ENABLE_LOADER_DEBUG);

#else

    BdInitDebugger((PCHAR)OsLoaderName, 0, NULL);

#endif

#endif
    
#if 0 && !defined(_IA64_)
//
// AJR bugbug -- do we really need to do this twice? we already call in SuMain()
//
// ChuckL -- Turned this code off because it screws up remote boot, which
//           does some allocations before we get here.
//
    //
    // Initialize the memory descriptor list, the OS loader heap, and the
    // OS loader parameter block.
    //    

    Status = BlMemoryInitialize();
    if (Status != ESUCCESS) {
        BlDiagLoadMessage(LOAD_HW_MEM_CLASS,
                          DIAG_BL_MEMORY_INIT,
                          LOAD_HW_MEM_ACT);
        goto LoadFailed;
    }

#endif

#if defined(_IA64_)
    //
    // Build required portion of ARC tree since we are not doing NTDETECT
    // anymore.
    //
    BuildArcTree();
#endif

#ifdef EFI
    //
    // Establish SMBIOS information in the loader block
    //
    SetupSMBiosInLoaderBlock();
#endif



    SetupBlock = BlAllocateHeap(sizeof(SETUP_LOADER_BLOCK));
    if (SetupBlock==NULL) {
        SlNoMemoryError();
        Status = ENOMEM;
        goto LoadFailed;
    }
    BlLoaderBlock->SetupLoaderBlock = SetupBlock;
    SetupBlock->ScsiDevices = NULL;
    SetupBlock->BootBusExtenders = NULL;
    SetupBlock->BusExtenders = NULL;
    SetupBlock->InputDevicesSupport = NULL;
    SetupBlock->Flags |= SETUPBLK_FLAGS_IS_TEXTMODE;

    SetupBlock->ScalarValues.SetupFromCdRom = FALSE;
    SetupBlock->ScalarValues.SetupOperation = SetupOperationSetup;
    SetupBlock->ScalarValues.LoadedScsi = 0;
    SetupBlock->ScalarValues.LoadedCdRomDrivers = 0;
    SetupBlock->ScalarValues.LoadedDiskDrivers = 0;
    SetupBlock->ScalarValues.LoadedFloppyDrivers = 0;
    SetupBlock->ScalarValues.LoadedFileSystems = 0;

    //
    // Initialize the NT configuration tree.
    //

    BlLoaderBlock->ConfigurationRoot = NULL;


    Status = BlConfigurationInitialize(NULL, NULL);
    if (Status != ESUCCESS) {
        BlDiagLoadMessage(LOAD_HW_FW_CFG_CLASS,
                          DIAG_BL_CONFIG_INIT,
                          LOAD_HW_FW_CFG_ACT);
        goto LoadFailed;
    }

    //
    // Compute the data cache fill size. This value is used to align
    // I/O buffers in case the host system does not support coherent
    // caches.
    //
    // If a combined secondary cache is present, then use the fill size
    // for that cache. Otherwise, if a secondary data cache is present,
    // then use the fill size for that cache. Otherwise, if a primary
    // data cache is present, then use the fill size for that cache.
    // Otherwise, use the default fill size.
    //

    DataCache = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                         CacheClass,
                                         SecondaryCache,
                                         NULL);

    if (DataCache == NULL) {
        DataCache = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                             CacheClass,
                                             SecondaryDcache,
                                             NULL);

        if (DataCache == NULL) {
            DataCache = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                                 CacheClass,
                                                 PrimaryDcache,
                                                 NULL);
        }
    }

    if (DataCache != NULL) {
        LinesPerBlock = DataCache->ComponentEntry.Key >> 24;
        CacheLineSize = 1 << ((DataCache->ComponentEntry.Key >> 16) & 0xff);
        BlDcacheFillSize = LinesPerBlock * CacheLineSize;
    }

    //
    // Initialize the OS loader I/O system.
    //

    Status = BlIoInitialize();
    if (Status != ESUCCESS) {
        BlDiagLoadMessage(LOAD_HW_DISK_CLASS,
                          DIAG_BL_IO_INIT,
                          LOAD_HW_DISK_ACT);
        goto LoadFailed;
    }

#if DBG
      StartTime = ArcGetRelativeTime();
#endif

    SlPositionCursor(5,3);

#if !defined(_IA64_)
    //
    // Initialize the message resources
    //
    Status = BlInitResources(Argv[0]);
    if (Status != ESUCCESS) {
       // if this fails, then we can't print out any messages,
       // so we just exit.
        return(Status);
    }
#endif

    //
    // If there is an ImageType parameter, this is a command console or rollback.
    //
    p = BlGetArgumentValue(Argc, Argv, "ImageType");
    if (p) {
        if (!strcmp (p, "cmdcons")) {
            UseCommandConsole = TRUE;
        } else if (!strcmp (p, "rollback")) {
            g_RollbackEnabled = TRUE;
        }
    }

#ifdef FORCE_CD_BOOT
    g_RollbackEnabled = FALSE;
#endif


    //
    // See if we're redirecting.
    //
    if( LoaderRedirectionInformation.PortAddress ) {

        //
        // Yes, we are redirecting right now.  Use these settings.
        //
        BlLoaderBlock->Extension->HeadlessLoaderBlock = BlAllocateHeap(sizeof(HEADLESS_LOADER_BLOCK));

        RtlCopyMemory( BlLoaderBlock->Extension->HeadlessLoaderBlock,
                       &LoaderRedirectionInformation,
                       sizeof(HEADLESS_LOADER_BLOCK) );

    } else {

        BlLoaderBlock->Extension->HeadlessLoaderBlock = NULL;

    }



    //
    // Initialize the display and announce ourselves
    //
    SlInitDisplay();

#if defined(_X86_) && !defined(ALLOW_386)
    //
    // Disallow installation on a 386 or any processor which
    // does not support CPUID and CMPXCHG8B instructions.
    //
    {
        if(BlIs386()) {
            SlFatalError(SL_TEXT_REQUIRES_486);
        }

        //
        // CMPXCHG8B is required on Whistler and above.  This
        // implies a requirement for CPUID which is used to
        // determine the presence of CMPXCHG8B.
        //

        if ((BlGetFeatureBits() & 0x100) == 0) {
            SlFatalError(SL_TEXT_REQUIRED_FEATURES_MISSING);
        }
    }
#endif


#ifdef _IA64_
    //
    // Is this automated WinPE boot?
    //
    p = BlGetArgumentValue(Argc, Argv, "systempartition");

    if (p && SlIsWinPEAutoBoot(p)) {
        WinPEAutoBoot = TRUE;

        //
        // get the WinPE device & directory
        //
        if (ESUCCESS != SlGetWinPEStartupParams(SetupDevice, SetupDirectory)) {
            SlFriendlyError(
                Status,
                "SETUPLDR:Cannot find WinPE installation",
                __LINE__,
                __FILE__
                );

            goto LoadFailed;
        }     
    } 
#endif    

    if (!WinPEAutoBoot) {
        //
        // If this is a winnt setup, then we want to behave as if
        // we were started from the location specified by the
        // OSLOADPARTITION and OSLOADFILENAME nv-ram variables.
        //
        p = BlGetArgumentValue(Argc,Argv,"osloadoptions");

        if(p && !_stricmp(p,"winnt32")) {

            p = BlGetArgumentValue(Argc,Argv,"osloadpartition");
            if(!p) {
                SlError(100);
                goto LoadFailed;
            }

            Status = BlGenerateDeviceNames(p,SetupDevice,NULL);
            if (Status != ESUCCESS) {
                SlError(110);
                goto LoadFailed;
            }

            p = BlGetArgumentValue(Argc,Argv,"osloadfilename");
            if(!p || !(*p)) {
                SlError(120);
                goto LoadFailed;
            }

            strcpy(SetupDirectory,p);

            //
            // Make sure directory is terminated with a \.
            //
            if(SetupDirectory[strlen(SetupDirectory)-1] != '\\') {
                strcat(SetupDirectory,"\\");
            }
        } else {
            //
            // extract device name from our startup path
            //
            p=strrchr(Argv[0],')');
            if (p==NULL) {
                SlError(0);
                goto LoadFailed;
            }

            strncpy(SetupDevice, Argv[0], (int)(p-Argv[0]+1));
            SetupDevice[p-Argv[0]+1] = '\0';

            Status = BlGenerateDeviceNames(SetupDevice,CanonicalName,NULL);
            if (Status != ESUCCESS) {
                SlFriendlyError(
                    Status,
                    SetupDevice,
                    __LINE__,
                    __FILE__
                    );
                goto LoadFailed;
            }
            strcpy(SetupDevice,CanonicalName);

            //
            // If this is a remote boot, load winnt.sif. If we were passed
            // a path through the soft reboot use that, if not then look
            // in the same place that the loader was loaded from. Once we
            // have read winnt.sif we get the SetupSourceDevice path.
            //
            if (BlBootingFromNet) {

                NetGetRebootParameters(
                    NULL,
                    NULL,
                    (PUCHAR) NetbootSifFile,
                    (PUCHAR) NetbootUser,
                    (PUCHAR) NetbootDomain,
                    (PUCHAR) NetbootPassword,
                    (PUCHAR) NetbootAdministratorPassword,
                    TRUE);

                if (NetbootSifFile[0] != '\0') {
                    strcpy(BadFileName, NetbootSifFile);
                } else {
                    strcpy(BadFileName,NetBootPath);
                    strcat(BadFileName,WINNT_SIF_FILE_A);
                }


                if (NetbootAdministratorPassword[0] != '\0') {
                    //
                    // It's possible that the string contained in NetbootAdministratorPassword
                    // may not be terminated.  Just block copy the entire 64-bytes into the loader
                    // block, then we'll treat the data carefully in setupdd.sys when we read it
                    // back out.
                    //
                    RtlMoveMemory(BlLoaderBlock->SetupLoaderBlock->NetBootAdministratorPassword,
                                  NetbootAdministratorPassword,
                                  OSC_ADMIN_PASSWORD_LEN );
                }


                BlLoaderBlock->SetupLoaderBlock->WinntSifFile = NULL;
                BlLoaderBlock->SetupLoaderBlock->WinntSifFileLength = 0;
                Status = SlInitIniFile(SetupDevice,
                                       0,
                                       BadFileName,
                                       &WinntSifHandle,
                                       &BlLoaderBlock->SetupLoaderBlock->WinntSifFile,
                                       &BlLoaderBlock->SetupLoaderBlock->WinntSifFileLength,
                                       &DontCare);
                if(Status != ESUCCESS) {
                    if (NetbootSifFile[0] != '\0') {
                        SlFatalError(
                            SL_BAD_INF_FILE,
                            SlCopyStringAT(NetbootSifFile),
                            Status);
                    } else {
                        SlFatalError(
                            SL_BAD_INF_FILE,
                            WINNT_SIF_FILE,
                            Status);
                    }
                    goto LoadFailed;
                }

                //
                // Get the SetupSourceDevice parameter from winnt.sif.
                //
                // SetupSourceDevice is of the form "\Device\LanmanRedirector\server\share\setup\nt5".
                //

                NetSetupServerShare = SlGetSectionKeyIndex(WinntSifHandle,
                                                           "SetupData",
                                                           "SetupSourceDevice",
                                                           0);

#if DBG
                if (((ULONG)strlen(NetSetupServerShare) + 1) > sizeof(SetupBlock->NetBootIMirrorFilePath)) {
                    DbgPrint("The UNC name is too long!\n");
                    goto LoadFailed;
                }
#endif

                strcpy((PCHAR)SetupBlock->NetBootIMirrorFilePath, NetSetupServerShare);

                if(NetSetupServerShare != NULL) {
                    // must start with '\'
                    if (*NetSetupServerShare != '\\') {
                        NetSetupServerShare = NULL;
                    } else {
                        // skip to '\' after Device
                        NetSetupServerShare = strchr(NetSetupServerShare+1,'\\');
                        if (NetSetupServerShare != NULL) {
                            // skip to '\' after LanmanRedirector (before server)
                            NetSetupServerShare = strchr(NetSetupServerShare+1,'\\');
                            if (NetSetupServerShare != NULL) {
                                // skip to '\' after server
                                NetSetupPath = strchr(NetSetupServerShare+1,'\\');
                                if (NetSetupPath != NULL) {
                                    // skip to '\' after share (path part)
                                    NetSetupPath = strchr(NetSetupPath+1,'\\');
                                }
                            }
                        }
                    }
                }
                if ((NetSetupServerShare == NULL) || (NetSetupPath == NULL)) {
                    SlFatalError(SL_INF_ENTRY_MISSING,TEXT("SetupSourceDevice"),TEXT("SetupData"));

                    goto LoadFailed;
                }
                *NetSetupPath = 0;                  // terminate server\share part
                NetSetupPath++;                     // remainder is path part

                //
                // If the TargetNtPartition parameter exists in winnt.sif, then
                // the target is remote, and this is a remote boot setup. Otherwise,
                // this is a remote installation setup.
                //

                if (SlGetSectionKeyIndex(WinntSifHandle,
                                         "SetupData",
                                         "TargetNtPartition",
                                         0) == NULL) {
                    PCHAR pTmp, pTmp2;

                    pTmp = SlGetSectionKeyIndex(WinntSifHandle,
                                                "OSChooser",
                                                "ImageType",
                                                0);

                    if (pTmp != NULL) {

                        pTmp2 = pTmp;
                        while (*pTmp != '\0') {
                            *pTmp = (UCHAR)toupper(*pTmp);
                            pTmp++;
                        }

                        if (!strcmp(pTmp2, "SYSPREP")) {

                            pTmp = SlGetSectionKeyIndex(WinntSifHandle,
                                                        "SetupData",
                                                        "SysPrepDevice",
                                                        0);

                            if (pTmp != NULL) {
                                strcpy((PCHAR)SetupBlock->NetBootIMirrorFilePath, pTmp);
                            } else {
                                memset(SetupBlock->NetBootIMirrorFilePath,
                                       0x0,
                                       sizeof(SetupBlock->NetBootIMirrorFilePath)
                                      );
                            }
                            SetupBlock->Flags |= SETUPBLK_FLAGS_SYSPREP_INSTALL;
                        } else {
                            SetupBlock->Flags |= SETUPBLK_FLAGS_REMOTE_INSTALL;
                        }
                    } else {
                        SetupBlock->Flags |= SETUPBLK_FLAGS_REMOTE_INSTALL;
                    }
                }
            }

            //
            // extract directory from our startup path.
            //
            if (BlBootingFromNet) {
                strcpy(SetupDirectory, "\\");
                strcat(SetupDirectory, NetSetupPath);
            } else if (UseCommandConsole) {
                strcpy(SetupDirectory,"\\cmdcons");
            } else if(*(p+1) != '\\') {
                //
                // directory must begin at root
                //
                strcpy(SetupDirectory, "\\");
            } else {
                *SetupDirectory = '\0';
            }
            strcat(SetupDirectory, p+1);
            p=strrchr(SetupDirectory, '\\');
            *(p+1) = '\0';
        }
    }        

#ifndef _IA64_
    BlAmd64Setup(SetupDevice);
#endif

#if defined(ELTORITO)
    if (ElToritoCDBoot && !WinPEAutoBoot) {
        //
        // Use the i386 directory for setup files when we boot from an El Torito CD
        //                
        PCHAR   SetupDirectoryOnDisk = "\\$WIN_NT$.~BT";        
        CHAR    SetupBootDevice[128] = {0};
        ULONG   MaxDisksToScan = 1;         // on x86 only the first disk
        ULONG   MaxPartitionsToScan = 4;    // on x86 check only primary partitions
        BOOLEAN CheckUpgrades = TRUE;
        
#if defined(_IA64_)
        strcat(SetupDirectory, "ia64\\");

        /*
        //
        // Values for IA64 installation, currently not used
        //
        SetupDirectoryOnDisk = "\\$WIN_NT$.~LS\\ia64";
        MaxDisksToScan = 4;         // NOTE : arbitrary limit
        MaxPartitionsToScan = 4;    // NOTE : arbitrary limit
        */
        
        CheckUpgrades = FALSE;      // NOTE : Currently disabled on IA64
#else
        strcat(SetupDirectory, BlAmd64Setup(NULL) ? "AMD64\\" : "I386\\" );
#endif    


        //
        // If WinPE boot then disable check for CD boot upgrade
        // NOTE: We check for the presence of system32\\drivers directory
        // rather than relying on /minint flag in txtsetup.sif since we
        // have not yet loaded txtsetup.sif file
        //
        if (CheckUpgrades) {
            CHAR        DriversDir[128];
            ARC_STATUS  DirStatus;
            ULONG       DeviceId, DirId;            

            strcat(DriversDir, SetupDirectory);
            strcat(DriversDir, "system32\\drivers");

            DirStatus = ArcOpen(SetupDevice, ArcOpenReadOnly, &DeviceId);

            if (ESUCCESS == DirStatus) {
                DirStatus = BlOpen(DeviceId, DriversDir, ArcOpenDirectory, &DirId);

                if (ESUCCESS == DirStatus) {
                    CheckUpgrades = FALSE;      // looks like a WinPE boot
                    BlClose(DirId);
                }

                ArcClose(DeviceId);
            }                
        }            

        
        //
        // Figure out if user was already trying to upgrade
        // using winnt32.exe. If user confirms he is
        // wants to continue upgrading then switch to
        // harddisk
        //
        if (CheckUpgrades && 
            SlIsCdBootUpgrade(SetupDirectoryOnDisk,
                            WINNT_SIF_FILE_A,
                            MaxDisksToScan,
                            MaxPartitionsToScan,
                            SetupBootDevice)) {
            strcpy(SetupDevice, SetupBootDevice);
            strcpy(SetupDirectory, SetupDirectoryOnDisk);
            strcat(SetupDirectory, "\\");
            ElToritoCDBoot = FALSE;
        }                    
    }
#endif

    //
    // Turn on ability to load compressed files.
    //

    DecompEnableDecompression(TRUE);

#if defined(EFI)
    //
    // Now that all variables are set and we can load compressed files, load the fpswa.efi driver from the setup dir
    //
    BlLoadEFIImage(SetupDevice, SetupDirectory, "fpswa.efi", TRUE, NULL);
#endif

    ///////////////////////////////////////////////////////////////////
    //
    //  On x86, the files loaded from now on are on boot floppy #1
    //  HALs may be on floppy #1 or floppy #2
    //
    ///////////////////////////////////////////////////////////////////

    strcpy(KernelDirectoryPath, SetupDirectory);
    strcat(KernelDirectoryPath, "txtsetup.sif");

    BlLoaderBlock->SetupLoaderBlock->IniFile = NULL;

    Status = SlInitIniFile(SetupDevice,
                           0,
                           KernelDirectoryPath,
                           &InfFile,
                           &BlLoaderBlock->SetupLoaderBlock->IniFile,
                           &BlLoaderBlock->SetupLoaderBlock->IniFileLength,
                           &ErrorLine);
    if (Status != ESUCCESS) {

        //
        // See if we can get the txtsetup.sif out of the WinPE boot
        // directory.
        //
        if( (strcmp( SetupDirectory, "\\") == 0) &&
            (!ElToritoCDBoot) &&
            (!BlBootingFromNet) ) {
            //
            // We're not booting off CD and we're not booting off the
            // net and we're about to fail because we didn't find \txtsetup.sif
            // Try in the MiniNT directory...
            //
            Status = SlInitIniFile(SetupDevice,
                       0,
                       "\\minint\\txtsetup.sif",
                       &InfFile,
                       &BlLoaderBlock->SetupLoaderBlock->IniFile,
                       &BlLoaderBlock->SetupLoaderBlock->IniFileLength,
                       &ErrorLine);
        }

        if( Status != ESUCCESS ) {
            SlFatalError(SL_BAD_INF_FILE,
                TEXT("txtsetup.sif"),
                Status);
            
            goto LoadFailed;
        }
    }

    SlGetSetupValuesBeforePrompt(SetupBlock);

    //
    // Find out if we are starting the MiniNT boot or rollback
    // (mutually exclusive options)
    //
    if (BlLoaderBlock->LoadOptions) {
        CHAR    Option[256];
        PCHAR   NextOption = strchr(BlLoaderBlock->LoadOptions, '/');
        PCHAR   OptionEnd = NULL;


        while (NextOption) {
            OptionEnd = strchr(NextOption, ' ');

            if (OptionEnd) {
                strncpy(Option, NextOption, OptionEnd - NextOption);
                Option[OptionEnd - NextOption] = 0;
            } else {
                strcpy(Option, NextOption);
            }

            if (!_stricmp(Option, "/minint")) {
                WinPEBoot = TRUE;
            }

            //
            // Pick up any headless settings in the boot options.
            //
            if (!_strnicmp(Option,"/redirect=",10)) {
                PCHAR pOption = strchr(Option,'=');
                if( pOption != NULL ) {
                    pOption++;

                    if (_strnicmp(pOption,"com",3) == 0) {
                        pOption +=3;
                        LoaderRedirectionInformation.PortNumber = atoi(pOption);

                    } else if (_strnicmp(pOption, "usebiossettings", 15) == 0) {

                        BlRetrieveBIOSRedirectionInformation();

                    } else {

                        //
                        // See if they gave us a hardcoded address.
                        //
                        LoaderRedirectionInformation.PortAddress = (PUCHAR)ULongToPtr(strtoul(pOption,NULL,16));

                        if( LoaderRedirectionInformation.PortAddress != (PUCHAR)NULL ) {
                            LoaderRedirectionInformation.PortNumber = 3;
                        }

                    }
                }
            }

            if (!_strnicmp(Option,"/redirectbaudrate=",18)) {
                PCHAR pOption = strchr(Option,'=');
                if( pOption != NULL ) {
                    pOption++;
                    
                    if( _strnicmp(pOption,"115200",6) == 0 ) {
                        LoaderRedirectionInformation.BaudRate = BD_115200;
                    } else if( _strnicmp(pOption,"57600",5) == 0 ) {
                        LoaderRedirectionInformation.BaudRate = BD_57600;
                    } else if( _strnicmp(pOption,"19200",5) == 0 ) {
                        LoaderRedirectionInformation.BaudRate = BD_19200;
                    } else {
                        LoaderRedirectionInformation.BaudRate = BD_9600;
                    }
                }
            }

            NextOption++;
            NextOption = strchr(NextOption, '/');
        }
    }


    //
    // Fix up the setup directory path to include system32 also
    // if this is a MiniNT boot
    //
    if (WinPEBoot) {
        strcat(SetupDirectory, "system32\\");

        // 
        // find out if a different load message has been specified
        //
#ifdef UNICODE        
        StartupMsg = SlGetIniValueW(InfFile,
#else        
        StartupMsg = (PCTSTR)SlGetIniValue(InfFile,
#endif        
                        "setupdata",
                        "loaderprompt",
                        NULL);

        //
        // Reduce the OEM key press time out
        //
        OemKeypressTimeout = 2; // secs
    }

    //
    // Now we know everything we should load, compute the ARC name to load
    // from and start loading things.
    //
    if (BootDevice==NULL) {
        //
        // No device was explicitly specified, so use whatever device
        // setupldr was started from.
        //

        BootDevice = SlCopyStringA(SetupDevice);
    }

    Status = ArcOpen(BootDevice, ArcOpenReadOnly, &BootDeviceId);

    if (Status != ESUCCESS) {
        SlFatalError(SL_IO_ERROR,SlCopyStringAT(BootDevice));
        goto LoadFailed;
    } else {
        BootDeviceIdValid = TRUE;
    }

#ifdef _X86_
    //
    // Load the bootfont.bin into memory
    //
    SlLoadBootFontFile(BlLoaderBlock->SetupLoaderBlock,
        BootDeviceId,
        BootFontImageLength);
#endif // _X86_

    _strlwr(BootDevice);
    FixedBootMedia = (BOOLEAN)(strstr(BootDevice,")rdisk(") != NULL);
    FloppyBoot = (BOOLEAN)(strstr(BootDevice, ")fdisk(") != NULL);

    //
    // If we are booting from fixed media, we better load disk class drivers.
    //
    if(FixedBootMedia) {
        LoadDiskClass = TRUE;
    }

    if(!BlGetPathMnemonicKey(BootDevice,"disk",&DontCare)
    && !BlGetPathMnemonicKey(BootDevice,"fdisk",&BootDriveNumber))
    {
        //
        // boot was from floppy, canonicalize the ARC name.
        //
        BlLoaderBlock->ArcBootDeviceName = BlAllocateHeap(80);
        sprintf(BlLoaderBlock->ArcBootDeviceName, "multi(0)disk(0)fdisk(%d)",BootDriveNumber);
    } else {
        BlLoaderBlock->ArcBootDeviceName = BootDevice;
    }
    if (BootPath==NULL) {
        //
        // No explicit boot path given, default to the directory setupldr was started
        // from.
        //
#if defined(_X86_)
        //
        // Increadibly nauseating hack:
        //
        // If we are booting from hard drive on x86, we will assume this is
        // the 'floppyless' winnt/winnt32 scenario, in which case the actual
        // boot path is \$win_nt$.~bt.
        //
        // This lets us avoid having winnt and winnt32 attempt to modify
        // the BootPath value in the [SetupData] section of txtsetup.sif.
        //
        // Enable booting WINPE from an LS-120 media.
        //
        if((FixedBootMedia)||(WinPEBoot && FloppyBoot)) {

            CHAR SetupPath[256];
            
            if( WinPEBoot ) {
                strcpy(SetupPath, "\\minint\\system32\\");
            } else if( UseCommandConsole ) {
               strcpy(SetupPath, "\\CMDCONS\\");
            } else {
               strcpy(SetupPath, "\\$WIN_NT$.~BT\\");
            }
            BootPath = SlCopyStringA(SetupPath);
        } else
#endif
        BootPath = SlCopyStringA(SetupDirectory);
    }

    //
    // Load the WinPE inf, if present.
    //
    if (WinPEBoot) {
        CHAR    FullPath[128];

        strcpy(FullPath, BootPath);
        strcat(FullPath, WINPE_OEM_FILENAME_A);
        
        Status = SlInitIniFile(NULL,
                       BootDeviceId,
                       FullPath,
                       &OemInfHandle,
                       NULL,
                       0,
                       &ErrorLine);

        if (Status != ESUCCESS) {
            OemInfHandle = NULL;
            Status = ESUCCESS;
        }
    }        

#ifdef _WANT_MACHINE_IDENTIFICATION

    BlLoaderBlock->Extension->InfFileImage = NULL;
    BlLoaderBlock->Extension->InfFileSize = 0;
    if (BiosInfo.Buffer) {

        if (Status == ESUCCESS) {

            Status = BlLoadBiosinfoInf( BootDeviceId,
                                        BlFindMessage(SL_BIOSINFO_NAME),
                                        BootPath,
                                        &BiosInfo,
                                        &BlLoaderBlock->Extension->InfFileImage,
                                        &BlLoaderBlock->Extension->InfFileSize,
                                        BadFileName);
        }


        if (Status != ESUCCESS) {
            SlFatalError(SL_FILE_LOAD_FAILED, SlCopyStringAT(BadFileName), Status);
            goto LoadFailed;
        }
    }

#endif

    //
    // Let the kernel deal with failure to load this driver database.
    //

    BlLoaderBlock->Extension->DrvDBImage = NULL;
    BlLoaderBlock->Extension->DrvDBSize = 0;
    DrvMainSdb.Buffer = DRIVER_DATABASE_FILENAME;
    DrvMainSdb.MaximumLength = sizeof(DRIVER_DATABASE_FILENAME);           // MaxLength is size of buffer
    DrvMainSdb.Length =  sizeof(DRIVER_DATABASE_FILENAME) - sizeof(WCHAR); // Length does not include \0
    BlLoadDrvDB(    BootDeviceId,
                    NULL, // BlFindMessage(SL_DRVMAINSDB_NAME),
                    BootPath,
                    &DrvMainSdb,
                    &BlLoaderBlock->Extension->DrvDBImage,
                    &BlLoaderBlock->Extension->DrvDBSize,
                    BadFileName);

    //
    // Attempt to load winnt.sif from the path where we are
    // loading setup files. Borrow the BadFileName buffer
    // for temporary use.
    //
    if (!BlBootingFromNet) {
        CHAR FloppyName[80];
        ULONG FloppyId;
        BOOLEAN FloppyUsed = FALSE;

        if (SlpFindFloppy(0,FloppyName)) {
            Status = ArcOpen(FloppyName,ArcOpenReadOnly,&FloppyId);

            if (Status == ESUCCESS) {
                strcpy(BadFileName,"\\");
                strcat(BadFileName,WINNT_SIF_FILE_A);
                BlLoaderBlock->SetupLoaderBlock->WinntSifFile = NULL;
                BlLoaderBlock->SetupLoaderBlock->WinntSifFileLength = 0;
                Status = SlInitIniFile(
                    NULL,
                    FloppyId,
                    BadFileName,
                    &WinntSifHandle,
                    &BlLoaderBlock->SetupLoaderBlock->WinntSifFile,
                    &BlLoaderBlock->SetupLoaderBlock->WinntSifFileLength,
                    &DontCare
                    );
                if (Status == ESUCCESS) {
                    FloppyUsed = TRUE;
                }

                ArcClose(FloppyId);
            }
        }

        if (!FloppyUsed) {
            strcpy(BadFileName,BootPath);
            strcat(BadFileName,WINNT_SIF_FILE_A);
            BlLoaderBlock->SetupLoaderBlock->WinntSifFile = NULL;
            BlLoaderBlock->SetupLoaderBlock->WinntSifFileLength = 0;
            Status = SlInitIniFile(
                NULL,
                BootDeviceId,
                BadFileName,
                &WinntSifHandle,
                &BlLoaderBlock->SetupLoaderBlock->WinntSifFile,
                &BlLoaderBlock->SetupLoaderBlock->WinntSifFileLength,
                &DontCare
                );
        }

    }

    IsUpgrade = SlIsUpgrade(WinntSifHandle);
    UseRegularBackground = (UseCommandConsole || IsUpgrade || WinPEBoot);

    //
    // If the BIOS told us to redirect, we'd be doing it right now.  However,
    // the user may have told us some specific settings.  If that's the case,
    // override anything we're doing now with the settings from the user.
    //

    if( WinntSifHandle ) {

        p = SlGetSectionKeyIndex(WinntSifHandle, WINNT_DATA_A, WINNT_U_HEADLESS_REDIRECT_A, 0);

        if (p != NULL) {

            if (!_strnicmp(p, "com", 3)) {

                LoaderRedirectionInformation.PortNumber = (UCHAR)atoi( (PCHAR)(p+3) );

                //
                // See if they want to give us a baudrate.
                //
                p = SlGetSectionKeyIndex( WinntSifHandle, WINNT_DATA_A, WINNT_U_HEADLESS_REDIRECTBAUDRATE_A, 0 );
                if( p ) {

                    if( _strnicmp(p,"115200",6) == 0 ) {
                        LoaderRedirectionInformation.BaudRate = BD_115200;
                    } else if( _strnicmp(p,"57600",5) == 0 ) {
                        LoaderRedirectionInformation.BaudRate = BD_57600;
                    } else if( _strnicmp(p,"19200",5) == 0 ) {
                        LoaderRedirectionInformation.BaudRate = BD_19200;
                    } else {
                        LoaderRedirectionInformation.BaudRate = BD_9600;
                    }
                }



            } else if( !_stricmp(p, "usebiossettings" ) ) {


                //
                // Now we get to dig up all the information from the
                // ACPI table.
                //
                BlRetrieveBIOSRedirectionInformation();

            } else if( !_stricmp(p, "noncomport" ) ) {

                //
                // It's something other than serial.  Go load a file off the floppy
                // and get the driver from there.
                //

                //
                // Currently not implemented.
                //
                RtlZeroMemory( &LoaderRedirectionInformation, sizeof(HEADLESS_LOADER_BLOCK) );

            } else {

                //
                // See if they gave us a hardcoded address.
                //
                LoaderRedirectionInformation.PortAddress = (PUCHAR)ULongToPtr(strtoul(p,NULL,16));

                if( LoaderRedirectionInformation.PortAddress != (PUCHAR)NULL ) {
                    LoaderRedirectionInformation.PortNumber = 3;
                }
            
            }

        }

    }

    //
    // If we found any headless redirection settings, go initialize
    // the port now.
    //
    if( (LoaderRedirectionInformation.PortNumber) || (LoaderRedirectionInformation.PortAddress) ) {

        //
        // Yes, we are redirecting right now.  Use these settings.
        //
        BlInitializeHeadlessPort();
        SlClearDisplay();


        if( BlLoaderBlock->Extension->HeadlessLoaderBlock == NULL ) {
            BlLoaderBlock->Extension->HeadlessLoaderBlock = BlAllocateHeap(sizeof(HEADLESS_LOADER_BLOCK));
            if (BlLoaderBlock->Extension->HeadlessLoaderBlock == NULL) {
                SlNoMemoryError();
                goto LoadFailed;
            }
        }

        RtlCopyMemory( BlLoaderBlock->Extension->HeadlessLoaderBlock,
                       &LoaderRedirectionInformation,
                       sizeof(HEADLESS_LOADER_BLOCK) );
        
    } else {

        BlLoaderBlock->Extension->HeadlessLoaderBlock = NULL;

    }

    if (UseRegularBackground) {
        extern BOOLEAN BlOutputDots;
        extern int BlMaxFilesToLoad;

        SlSetCurrentAttribute(DEFATT);
        SlSetStatusAttribute(DEFATT);
        SlClearDisplay();
        SlPositionCursor(0,0);

        if (UseCommandConsole) {
            SlPrint(BlFindMessage(SL_CMDCONS_MSG));
        }

        BlOutputDots = TRUE;

        //
        // To reset BlShowProgress bar correctly
        //
        BlDisableProgressBar = FALSE;
        BlProgressBarShowTimeOut = 0;   

        //
        // Note : We can compute the real number of drivers to be loaded
        // from various INF sections and manually counting all the
        // different SlLoadDriver(...) calls. But the code/effort required
        // to do this is not worth the feature, since we just want to
        // replace the old "..." with progress bar to make the recovery
        // console starting look similar to windows starting. So we make
        // an assumption here about the maximum files to be loaded.
        //
        BlMaxFilesToLoad = 80;

        BlSetProgBarCharacteristics(SL_CMDCONS_PROGBAR_FRONT,
                        SL_CMDCONS_PROGBAR_BACK);

        if (WinPEBoot) {
            StartupMsg ? BlOutputStartupMsgStr(StartupMsg) :
                         BlOutputStartupMsg(SL_SETUP_STARTING_WINPE);
        } else if (UseCommandConsole) {
            BlOutputStartupMsg(SL_CMDCONS_STARTING);
        } else if (g_RollbackEnabled) {
            BlOutputStartupMsg(SL_ROLLBACK_STARTING);
        } else if (IsUpgrade) {
            BlOutputStartupMsg(SL_SETUP_STARTING);
        }
    } else {
        SlSetCurrentAttribute(DEFATT);
        SlSetStatusAttribute(DEFSTATTR);
        SlClearDisplay();
        SlWriteHeaderText(SL_WELCOME_HEADER);
        SlClearClientArea();
    }

    //
    // Figure out all the OEM drivers source devices
    //
    RamdiskInitialize(BlLoaderBlock->LoadOptions, FALSE);
    SlInitOemSourceDevices(&OemSourceDevices, &DefaultOemSourceDevice);

    //
    // If we found at least one valid OEM source device with proper
    // txtsetup.oem and no default driver then bump up the timeout to
    // 20 secs
    //

    if (OemSourceDevices) {
        POEM_SOURCE_DEVICE  CurrDevice = OemSourceDevices;

        while(CurrDevice) {
            if (SL_OEM_SOURCE_MEDIA_TYPE(CurrDevice, 
                    SL_OEM_SOURCE_MEDIA_HAS_DRIVERS) &&
                !SL_OEM_SOURCE_MEDIA_TYPE(CurrDevice,
                    SL_OEM_SOURCE_MEDIA_HAS_DEFAULT)) {
                OemKeypressTimeout = 20;

                break;
            }         

            CurrDevice = CurrDevice->Next;
        }
    }

    //
    // We need to check to see if the user pressed any keys to force OEM HAL,
    // OEM SCSI, or both. Do this before getting the settings in the sif file,
    // so that we won't try to detect the machine if OEM HAL is needed.    
    //

    SlCheckOemKeypress(OemKeypressTimeout);

    {
        PCSTR szOptionsToAdd = NULL;
        CHAR szOptionsToRemove[sizeof("/noguiboot/nodebug")];
        szOptionsToRemove[0] = 0;

        //
        // If F8 was pressed, add the debug options
        //
        if(EnableDebugger) {
            if(InfFile != NULL) {
                szOptionsToAdd = SlGetSectionKeyIndex(InfFile, "SetupData", "SetupDebugOptions", 0);
            }

            if(NULL == szOptionsToAdd) {
                szOptionsToAdd = "/debug";
            }

            strcat(szOptionsToRemove, "/nodebug");
        }

        //
        // remove the /noguiboot option so what we show the logo
        // and switch the video adapter into graphics mode
        // early on during initialization
        //
        if (IsUpgrade) {
            strcat(szOptionsToRemove, "/noguiboot");
        }

        if(szOptionsToAdd != NULL || szOptionsToRemove[0] != 0) {
            SlModifyOsLoadOptions(&BlLoaderBlock->LoadOptions, szOptionsToAdd, szOptionsToRemove);
        }
    }


#if defined(_X86_) || defined(_IA64_)
    //
    // We need to check to see if the user pressed any keys to force loading,
    // an ASR pnp repair disk.  Only do this if the user didn't select
    // anything in the SlCheckOemKeypress function.
    //
    if(!UseCommandConsole && !WinPEBoot && !IsUpgrade && !BlBootingFromNet) {

        PCHAR pTmp;

        pTmp = SlGetSectionKeyIndex(InfFile,
                                    "SetupData",
                                    "DisableAsr",
                                     0);

        if ((pTmp == NULL) || (atoi(pTmp) == 0)) {

            SlCheckASRKeypress();
        }
    }    

    if (BlBootingFromNet && TryASRViaNetwork) {
        PVOID ASRPNPSifHandle = NULL;
        ULONG c;
        PCHAR FileNameFromSif;

        FileNameFromSif = SlGetIniValue( 
                                WinntSifHandle,
                                "OSChooser",
                                "ASRFile",
                                "generic.sif" );

        Status = SlInitIniFile( SetupDevice,
                                0,
                                FileNameFromSif,
                                &ASRPNPSifHandle,
                                &BlLoaderBlock->SetupLoaderBlock->ASRPnPSifFile,
                                &BlLoaderBlock->SetupLoaderBlock->ASRPnPSifFileLength,
                                &c );

        if(Status != ESUCCESS) {
            SlFatalError(SL_BAD_INF_FILE,SlCopyStringAT(FileNameFromSif),Status);
            goto LoadFailed;
        }        
    }

#endif

    SlGetSetupValuesAfterPrompt(SetupBlock);

    //
    // Are there any dyamic update boot drivers which we need
    // to process
    //
    DynamicUpdate = SlpIsDynamicUpdate(WinntSifHandle, &DynamicUpdateRootDir);

    //
    // Add the dynamic update source device as OEM source device since it could
    // have F6 
    //
    if (DynamicUpdate) {
        DynamicUpdateSourceDevice = BlAllocateHeap(sizeof(OEM_SOURCE_DEVICE));

        if (DynamicUpdateSourceDevice) {
            memset(DynamicUpdateSourceDevice, 0, sizeof(OEM_SOURCE_DEVICE));
            
            strcpy(DynamicUpdateSourceDevice->ArcDeviceName,
                    BootDevice);
                    
            DynamicUpdateSourceDevice->DriverDir = DynamicUpdateRootDir;

            SL_OEM_SET_SOURCE_DEVICE_TYPE(DynamicUpdateSourceDevice,
                (SL_OEM_SOURCE_DEVICE_TYPE_LOCAL |
                 SL_OEM_SOURCE_DEVICE_TYPE_FIXED |
                 SL_OEM_SOURCE_DEVICE_TYPE_DYN_UPDATE));

            SL_OEM_SET_SOURCE_MEDIA_TYPE(DynamicUpdateSourceDevice,
                (SL_OEM_SOURCE_MEDIA_PRESENT |
                 SL_OEM_SOURCE_MEDIA_HAS_DRIVERS |
                 SL_OEM_SOURCE_MEDIA_HAS_MSD |
                 SL_OEM_SOURCE_MEDIA_HAS_DEFAULT));

            SL_OEM_SET_SOURCE_DEVICE_STATE(DynamicUpdateSourceDevice,
                SL_OEM_SOURCE_DEVICE_NOT_PROCESSED);

            DynamicUpdateSourceDevice->DeviceId = BootDeviceId;

            //
            // Insert it at the head of the linked list
            //
            DynamicUpdateSourceDevice->Next = OemSourceDevices;
            OemSourceDevices = DynamicUpdateSourceDevice;
        }
    }

    if (BlBootingFromNet || (Status == ESUCCESS)) {


        //
        //  Find out if this is a pre-install, by looking at OemPreinstall key
        //  in [unattended] section of winnt.sif
        //
        p = SlGetSectionKeyIndex(WinntSifHandle,WINNT_UNATTENDED_A,WINNT_U_OEMPREINSTALL_A,0);
        if(p && !_stricmp(p,"yes")) {
            PreInstall = TRUE;
        }

        //
        //  If this is a pre-install, find out which hal to load, by looking
        //  at ComputerType key in [unattended] section of winnt.sif.
        //
        if( PreInstall && !DynamicUpdate) {
#ifdef UNICODE
            ComputerType = (PTCHAR)SlGetSectionKeyIndexW(
#else
            ComputerType = (PTCHAR)SlGetSectionKeyIndex(      
#endif
                                            WinntSifHandle,
                                            WINNT_UNATTENDED_A,
                                            WINNT_U_COMPUTERTYPE_A,
                                            0);
            if(ComputerType) {
                //
                // If the hal to load is an OEM one, then set OemHal to TRUE
                //
                p = SlGetSectionKeyIndex(WinntSifHandle,WINNT_UNATTENDED_A,WINNT_U_COMPUTERTYPE_A,1);
                if(p && !_stricmp(p, OemTag)) {
                    OemHal = TRUE;
                } else {
                    OemHal = FALSE;
                }
                //
                //  In the pre-install mode, don't let the user specify
                //  an OEM hal, if one was specified in unattend.txt
                //
                PromptOemHal = FALSE;
            }

            //
            //  Find out which SCSI drivers to load, by looking at
            //  [MassStorageDrivers] in winnt.sif
            //
            if( SpSearchINFSection( WinntSifHandle, WINNT_OEMSCSIDRIVERS_A ) ) {
                PPREINSTALL_DRIVER_INFO TempDriverInfo;
                PTSTR  pOem;
#ifdef UNICODE
                CHAR  DriverDescriptionA[100];
                PCHAR pDriverDescriptionA;
                UNICODE_STRING uString;
                ANSI_STRING aString;                
#endif

                PreinstallDriverList = NULL;
                for( i = 0;
#ifdef UNICODE
                     ((pOem = SlGetKeyNameW( 
#else
                     ((pOem = SlGetKeyName(
#endif
                                WinntSifHandle, 
                                WINNT_OEMSCSIDRIVERS_A, 
                                i )) != NULL);
                     i++ ) {
                    TempDriverInfo = BlAllocateHeap(sizeof(PREINSTALL_DRIVER_INFO));
                    if (TempDriverInfo==NULL) {
                        SlNoMemoryError();
                        goto LoadFailed;
                    }
                    TempDriverInfo->DriverDescription = pOem;
#ifdef UNICODE
                    RtlInitUnicodeString( &uString, TempDriverInfo->DriverDescription);
                    
                    
                    //
                    // use the static buffer if possible
                    //
                    pDriverDescriptionA = DriverDescriptionA;
                    aString.MaximumLength = sizeof(DriverDescriptionA);
                    
                    //
                    // if more memory is needed for the driver description
                    // allocate it
                    //
                    if (aString.MaximumLength < uString.Length/2 + 1 ) {
                        pDriverDescriptionA = BlAllocateHeap(uString.Length/2 + 1);
                        if (pDriverDescriptionA == NULL) {
                            SlNoMemoryError();
                            goto LoadFailed;
                        }
                        aString.MaximumLength = uString.Length/2 + 1;
                    }

                    aString.Buffer = pDriverDescriptionA;

                    Status = RtlUnicodeStringToAnsiString( &aString, &uString, FALSE );
                    pOem = (Status != ESUCCESS) ? NULL : SlGetIniValueW( WinntSifHandle,
                                                                         WINNT_OEMSCSIDRIVERS_A,
                                                                         pDriverDescriptionA,
                                                                         NULL );
#else
                    pOem = SlGetIniValue( 
                                WinntSifHandle,
                                WINNT_OEMSCSIDRIVERS_A,
                                TempDriverInfo->DriverDescription,
                                NULL );                                        
#endif
                    TempDriverInfo->OemDriver = (pOem && !_tcsicmp(pOem, _TOemTag))? TRUE : FALSE;
                    TempDriverInfo->Next = PreinstallDriverList;
                    PreinstallDriverList = TempDriverInfo;
                }
                if( PreinstallDriverList != NULL ) {
                    //
                    //  In the pre-install mode, don't let the user specify
                    //  an OEM scsi, if at least one was specified in unattend.txt
                    //
                    PromptOemScsi = FALSE;
                }
            }
        }

        p = SlGetSectionKeyIndex(WinntSifHandle,WINNT_SETUPPARAMS_A,WINNT_S_SKIPMISSING_A,0);
        if(p && (*p != '0')) {
            IgnoreMissingFiles = TRUE;
        }

#if defined(_X86_) || defined(_IA64_)
        //
        //  Find out if this is a Win9x upgrade
        //
        Win9xUnsupHdc = FALSE;
        p = SlGetSectionKeyIndex(WinntSifHandle,WINNT_DATA_A,WINNT_D_WIN95UPGRADE_A,0);
        if(p && !_stricmp(p, WINNT_A_YES_A)) {
            //
            //  If it is an Win9x upgrade, find out if winnt32 found an unsupported
            //  hard disk controller.
            //
            p = SlGetSectionKeyIndex(WinntSifHandle,WINNT_DATA_A,WINNT_D_WIN95UNSUPHDC_A,0);
            if(p && (*p != '0')) {
                Win9xUnsupHdc = TRUE;
            }
        }
#endif

        //
        //  At this point, we know that we wre able to read winnt.sif.
        //  So attempt to read migrate.inf. Borrow the BadFileName buffer
        //  for temporary use.
        //

        strcpy(BadFileName,BootPath);
        strcat(BadFileName,WINNT_MIGRATE_INF_FILE_A);
        if( SlInitIniFile(NULL,
                          BootDeviceId,
                          BadFileName,
                          &MigrateInfHandle,
                          &BlLoaderBlock->SetupLoaderBlock->MigrateInfFile,
                          &BlLoaderBlock->SetupLoaderBlock->MigrateInfFileLength,
                          &DontCare) != ESUCCESS ) {
            MigrateInfHandle = NULL;
            BlLoaderBlock->SetupLoaderBlock->MigrateInfFile = NULL;
            BlLoaderBlock->SetupLoaderBlock->MigrateInfFileLength = 0;
        }
        //
        //  Attempt also to read unsupdrv.inf. Borrow the BadFileName buffer
        //  for temporary use.
        //

        strcpy(BadFileName,BootPath);
        strcat(BadFileName,WINNT_UNSUPDRV_INF_FILE_A);
        if( SlInitIniFile(NULL,
                          BootDeviceId,
                          BadFileName,
                          &UnsupDriversInfHandle,
                          &BlLoaderBlock->SetupLoaderBlock->UnsupDriversInfFile,
                          &BlLoaderBlock->SetupLoaderBlock->UnsupDriversInfFileLength,
                          &DontCare) != ESUCCESS ) {
            UnsupDriversInfHandle = NULL;
            BlLoaderBlock->SetupLoaderBlock->UnsupDriversInfFile = NULL;
            BlLoaderBlock->SetupLoaderBlock->UnsupDriversInfFileLength = 0;
        }
        SlGetMigratedHardwareIds(SetupBlock, UnsupDriversInfHandle);

    } else {
        WinntSifHandle = NULL;
        //
        //  If winnt.sif doesn't exist, then we don't bother to read migrate.inf and unsupdrv.inf,
        //  since we are booting from the retail boot floppies or the CD, and in this
        //  case there is no migrate.inf or unsupdrv.inf.
        //
        MigrateInfHandle = NULL;
        BlLoaderBlock->SetupLoaderBlock->MigrateInfFile = NULL;
        BlLoaderBlock->SetupLoaderBlock->MigrateInfFileLength = 0;

        UnsupDriversInfHandle = NULL;
        BlLoaderBlock->SetupLoaderBlock->UnsupDriversInfFile = NULL;
        BlLoaderBlock->SetupLoaderBlock->UnsupDriversInfFileLength = 0;
    }

    //
    // Store the boot path in the loader block.
    //

    if (UseCommandConsole) {
        SetupBlock->Flags |= SETUPBLK_FLAGS_CONSOLE;
    }

    if (g_RollbackEnabled) {
        SetupBlock->Flags |= SETUPBLK_FLAGS_ROLLBACK;
    }

    if ( !BlBootingFromNet ) {

        BlLoaderBlock->NtBootPathName = BootPath;

    } else {

        ANSI_STRING aString;
        UNICODE_STRING uString;
        ULONG length;
#if defined(REMOTE_BOOT)
        PCHAR TempEnableIpsec;
#endif // defined(REMOTE_BOOT)

        SetupBlock->Flags |= SETUPBLK_FLAGS_IS_REMOTE_BOOT;

        BlLoaderBlock->NtBootPathName =
                            BlAllocateHeap( (ULONG)strlen(NetSetupServerShare) + (ULONG)strlen(BootPath) + 1 );
        if ( BlLoaderBlock->NtBootPathName == NULL ) {
            SlNoMemoryError();
            goto LoadFailed;
        }
        strcpy( BlLoaderBlock->NtBootPathName, NetSetupServerShare );
        strcat( BlLoaderBlock->NtBootPathName, BootPath );

        //
        // NetSetupServerShare is of the form \server\IMirror. NetBootPath
        // is of the form Clients\machine\ (note trailing \). We need to
        // insert a \ between the two and add BootDrive to yield
        // \server\IMirror\Clients\machine\BootDrive.
        //

        length = (ULONG)strlen(NetSetupServerShare) + 
                  sizeof(CHAR) +           // '\'
                 (ULONG)strlen(NetBootPath) + 
                  sizeof("BootDrive");     // sizeof includes the \0
        SetupBlock->MachineDirectoryPath = BlAllocateHeap( length );
        if ( SetupBlock->MachineDirectoryPath == NULL ) {
            SlNoMemoryError();
            goto LoadFailed;
        }
        strcpy( SetupBlock->MachineDirectoryPath, NetSetupServerShare );
        SetupBlock->MachineDirectoryPath[strlen(NetSetupServerShare)] = '\\';
        SetupBlock->MachineDirectoryPath[strlen(NetSetupServerShare) + 1] = 0;
        strcat(SetupBlock->MachineDirectoryPath, NetBootPath);
        strcat(SetupBlock->MachineDirectoryPath, "BootDrive");

        //
        // Save the path to the SIF file so it can be deleted later.
        //
        if (((SetupBlock->Flags & (SETUPBLK_FLAGS_REMOTE_INSTALL|SETUPBLK_FLAGS_SYSPREP_INSTALL)) != 0) &&
            (NetbootSifFile[0] != '\0')) {
            length = (ULONG)strlen(NetSetupServerShare) + 
                     sizeof(CHAR) +           // '\'
                     (ULONG)strlen(NetbootSifFile) + 
                     sizeof(CHAR);            // '\0'

            SetupBlock->NetBootSifPath = BlAllocateHeap( length );
            if ( SetupBlock->NetBootSifPath == NULL ) {
                SlNoMemoryError();
                goto LoadFailed;
            }
            strcpy( SetupBlock->NetBootSifPath, NetSetupServerShare );
            SetupBlock->NetBootSifPath[strlen(NetSetupServerShare)] = '\\';
            SetupBlock->NetBootSifPath[strlen(NetSetupServerShare) + 1] = 0;
            strcat(SetupBlock->NetBootSifPath, NetbootSifFile);
        }

        //
        // NetSetupServerShare was read from winnt.sif and we replaced
        // the '\' at the end with a NULL -- put this back for when
        // winnt.sif is re-parsed by the kernel (the only modification
        // that the kernel parser can really accept is replacing a
        // final " with a NULL, which SlInitIniFile does).
        //

        NetSetupServerShare[strlen(NetSetupServerShare)] = '\\';

        //
        // Get the computer name from winnt.sif.
        //
        p = SlGetSectionKeyIndex(WinntSifHandle,WINNT_USERDATA_A,WINNT_US_COMPNAME_A,0);
        if(!p || (*p == 0)) {
            SlFatalError(SL_INF_ENTRY_MISSING,WINNT_US_COMPNAME,WINNT_USERDATA);
            goto LoadFailed;
        }

        RtlInitString( &aString, p );
        uString.Buffer = SetupBlock->ComputerName;
        uString.MaximumLength = 64 * sizeof(WCHAR);
        RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );

        //
        // Save these from the global variables.
        //

#ifdef EFI
        //
        // Convert these back to Network Order.
        //
        SetupBlock->IpAddress = RtlUlongByteSwap(NetLocalIpAddress);
        SetupBlock->SubnetMask = RtlUlongByteSwap(NetLocalSubnetMask);
        SetupBlock->DefaultRouter = RtlUlongByteSwap(NetGatewayIpAddress);
        SetupBlock->ServerIpAddress = RtlUlongByteSwap(NetServerIpAddress);
#else
        SetupBlock->IpAddress = NetLocalIpAddress;
        SetupBlock->SubnetMask = NetLocalSubnetMask;
        SetupBlock->DefaultRouter = NetGatewayIpAddress;
        SetupBlock->ServerIpAddress = NetServerIpAddress;
#endif

        //
        // Get information about the net card and do an exchange with the
        // server to get information we need to load it properly.
        //

        SetupBlock->NetbootCardInfo = BlAllocateHeap(sizeof(NET_CARD_INFO));
        if ( SetupBlock->NetbootCardInfo == NULL ) {
            SlNoMemoryError();
            goto LoadFailed;
        }
        SetupBlock->NetbootCardInfoLength = sizeof(NET_CARD_INFO);

        Status = NetQueryCardInfo(
                     (PNET_CARD_INFO)SetupBlock->NetbootCardInfo
                     );

        if (Status != STATUS_SUCCESS) {
            SlFatalError(SL_NETBOOT_CARD_ERROR);
            goto LoadFailed;
        }

        //
        // This call may allocate SetupBlock->NetbootCardRegistry
        //

        Status = NetQueryDriverInfo(
                     (PNET_CARD_INFO)SetupBlock->NetbootCardInfo,
                     NetSetupServerShare,
                     NULL,
                     SetupBlock->NetbootCardHardwareId,
                     sizeof(SetupBlock->NetbootCardHardwareId),
                     SetupBlock->NetbootCardDriverName,
                     NetbootCardDriverName,
                     sizeof(SetupBlock->NetbootCardDriverName),
                     SetupBlock->NetbootCardServiceName,
                     sizeof(SetupBlock->NetbootCardServiceName),
                     &SetupBlock->NetbootCardRegistry,
                     &SetupBlock->NetbootCardRegistryLength);

        if (Status == STATUS_INSUFFICIENT_RESOURCES) {
            SlNoMemoryError();
            goto LoadFailed;
        } else if (Status != STATUS_SUCCESS) {
            SlFatalError(SL_NETBOOT_SERVER_ERROR);
            goto LoadFailed;
        }

#if 0
        DbgPrint("HardwareID is <%ws>, DriverName is <%ws>, Service <%ws>\n",
            SetupBlock->NetbootCardHardwareId,
            SetupBlock->NetbootCardDriverName,
            SetupBlock->NetbootCardServiceName);
        DbgPrint("NetbootCardRegistry at %lx, length %d\n",
            SetupBlock->NetbootCardRegistry,
            SetupBlock->NetbootCardRegistryLength);
        DbgBreakPoint();
#endif

#if defined(REMOTE_BOOT)
        //
        // See if we should enable remote boot security (IPSEC).
        //

        TempEnableIpsec = SlGetSectionKeyIndex(WinntSifHandle,
                                               "RemoteBoot",
                                               "EnableIpSecurity",
                                               0);
        if ((TempEnableIpsec != NULL) &&
            ((TempEnableIpsec[0] == 'Y') ||
             (TempEnableIpsec[0] == 'y'))) {

            RemoteBootEnableIpsec = TRUE;
        }

        if ((SetupBlock->Flags & (SETUPBLK_FLAGS_REMOTE_INSTALL |
                                  SETUPBLK_FLAGS_SYSPREP_INSTALL)) == 0) {

            ARC_STATUS ArcStatus;
            ULONG      FileId;

            //
            // Read the secret off the disk, if there is one, and store it
            // in the loader block.
            //

            ArcStatus = BlOpenRawDisk(&FileId);

            if (ArcStatus == ESUCCESS) {

                SetupBlock->NetBootSecret = BlAllocateHeap(sizeof(RI_SECRET));
                if (SetupBlock->NetBootSecret == NULL) {
                    SlNoMemoryError();
                    BlCloseRawDisk(FileId);
                    goto LoadFailed;
                }

                ArcStatus = BlReadSecret(FileId, (PRI_SECRET)(SetupBlock->NetBootSecret));
                if (ArcStatus != ESUCCESS) {
                    SlNoMemoryError();
                    BlCloseRawDisk(FileId);
                    goto LoadFailed;
                }

                ArcStatus = BlCloseRawDisk(FileId);

                //
                // By now we have TFTPed some files so this will be TRUE if it
                // is ever going to be.
                //

                SetupBlock->NetBootUsePassword2 = NetBootTftpUsedPassword2;
            }

        } else
#endif // defined(REMOTE_BOOT)
        {

            //
            // Construct a secret to pass to the redirector, based on what
            // was passed to use across the reboot. For the moment only
            // user/domain/password matters.
            //

            WCHAR UnicodePassword[64];
            UNICODE_STRING TmpNtPassword;
            CHAR LmOwfPassword[LM_OWF_PASSWORD_SIZE];
            CHAR NtOwfPassword[NT_OWF_PASSWORD_SIZE];
            CHAR GarbageSid[RI_SECRET_SID_SIZE];

            SetupBlock->NetBootSecret = BlAllocateHeap(sizeof(RI_SECRET));
            if (SetupBlock->NetBootSecret == NULL) {
                SlNoMemoryError();
                goto LoadFailed;
            }

            //
            // Do a quick conversion of the password to Unicode.
            //

            TmpNtPassword.Length = (USHORT)strlen(NetbootPassword) * sizeof(WCHAR);
            TmpNtPassword.MaximumLength = sizeof(UnicodePassword);
            TmpNtPassword.Buffer = UnicodePassword;

            for (i = 0; i < sizeof(NetbootPassword); i++) {
                UnicodePassword[i] = (WCHAR)(NetbootPassword[i]);
            }

            BlOwfPassword((PUCHAR) NetbootPassword, 
                          &TmpNtPassword,
                          (PUCHAR) LmOwfPassword, 
                          (PUCHAR) NtOwfPassword);

            BlInitializeSecret(
                (PUCHAR) NetbootDomain,
                (PUCHAR) NetbootUser,
                (PUCHAR) LmOwfPassword,
                (PUCHAR) NtOwfPassword,
#if defined(REMOTE_BOOT)
                NULL,             // no password2
                NULL,             // no password2
#endif // defined(REMOTE_BOOT)
                (PUCHAR) GarbageSid,
                SetupBlock->NetBootSecret);

        }

    }

    //
    // Initialize the debugging system.
    //

    BlLogInitialize(BootDeviceId);

    //
    // Do PPC-specific initialization.
    //

#if defined(_PPC_)

    Status = BlPpcInitialize();
    if (Status != ESUCCESS) {
        goto LoadFailed;
    }

#endif // defined(_PPC_)

    //
    // Check for an alternate Kernel Debugger DLL, i.e.,
    // /debugport=1394 (kd1394.dll), /debugport=usb (kdusb.dll), etc...
    //

    FileName = NULL;

    if (BlLoaderBlock->LoadOptions != NULL) {
        FileName = strstr(BlLoaderBlock->LoadOptions, "DEBUGPORT=");
        if (FileName == NULL) {
            FileName = strstr(BlLoaderBlock->LoadOptions, "debugport=");
        }
    }

    if (FileName != NULL) {
        _strupr(FileName);
        if (strstr(FileName, "COM") == NULL) {
            UseAlternateKdDll = TRUE;
            FileName += strlen("DEBUGPORT=");
            for (i = 0; i < KD_ALT_DLL_REPLACE_CHARS; i++) {
                if (FileName[i] == ' ') {
                    break;
                }

                KdFileName[KD_ALT_DLL_PREFIX_CHARS + i] = FileName[i];
            }
            KdFileName[KD_ALT_DLL_PREFIX_CHARS + i] = '\0';
            strcat(KdFileName, ".DLL");
        }
    }

    //
    // If this is a preinstall case then add another
    // OEM source device
    //

    if (PreInstall || WinPEBoot) {
        PreInstallOemSourceDevice = BlAllocateHeap(sizeof(OEM_SOURCE_DEVICE));
        PreInstallSourcePath = BlAllocateHeap(256);

        if (PreInstallOemSourceDevice && PreInstallSourcePath) {
            strcpy(PreInstallOemSourceDevice->ArcDeviceName,
                    BootDevice);

            strcpy(PreInstallSourcePath, BootPath);
            strcat(PreInstallSourcePath, WINNT_OEM_DIR_A);
            
            PreInstallOemSourceDevice->DriverDir = PreInstallSourcePath;

            SL_OEM_SET_SOURCE_DEVICE_TYPE(PreInstallOemSourceDevice,
                (SL_OEM_SOURCE_DEVICE_TYPE_LOCAL |
                 SL_OEM_SOURCE_DEVICE_TYPE_FIXED |
                 SL_OEM_SOURCE_DEVICE_TYPE_PREINSTALL));

            //
            // Mark the device as containing preinstall drivers only if they
            // specified any F6 mass storage drivers
            //
            if (!WinPEBoot && PreinstallDriverList) {
                SL_OEM_SET_SOURCE_MEDIA_TYPE(PreInstallOemSourceDevice,
                    (SL_OEM_SOURCE_MEDIA_PRESENT |
                     SL_OEM_SOURCE_MEDIA_HAS_DRIVERS |
                     SL_OEM_SOURCE_MEDIA_HAS_MSD |
                     SL_OEM_SOURCE_MEDIA_HAS_DEFAULT));
            }                

            SL_OEM_SET_SOURCE_DEVICE_STATE(PreInstallOemSourceDevice,
                SL_OEM_SOURCE_DEVICE_NOT_PROCESSED);

            PreInstallOemSourceDevice->DeviceId = BootDeviceId;

            //
            // Insert it at the head of the linked list
            //
            PreInstallOemSourceDevice->Next = OemSourceDevices;
            OemSourceDevices = PreInstallOemSourceDevice;                
        } else {
            SlNoMemoryError();
            goto LoadFailed;
        }            
    }                

    if (!BlBootingFromNet) {
        //
        // Figure out if there are any OEM hal/drivers which need to 
        // be autoloaded.
        // NOTE: We skip the dynamic update OEM source device since it's
        // drivers will be autoloaded later.
        //
        POEM_SOURCE_DEVICE  CurrDevice = OemSourceDevices;

        while (CurrDevice && !(AutoLoadOemHalDevice && AutoLoadOemScsi)) {
            if ((SL_OEM_SOURCE_MEDIA_TYPE(CurrDevice,
                        SL_OEM_SOURCE_MEDIA_HAS_DRIVERS) &&
                  SL_OEM_SOURCE_MEDIA_TYPE(CurrDevice,
                        SL_OEM_SOURCE_MEDIA_HAS_DEFAULT)) &&
                !SL_OEM_SOURCE_DEVICE_TYPE(CurrDevice,
                        SL_OEM_SOURCE_DEVICE_TYPE_DYN_UPDATE)) {

                if (!AutoLoadOemHalDevice && 
                    SL_OEM_SOURCE_MEDIA_TYPE(CurrDevice, SL_OEM_SOURCE_MEDIA_HAS_HAL)) {
                    AutoLoadOemHalDevice = CurrDevice;
                }

                if (!AutoLoadOemScsi && 
                    SL_OEM_SOURCE_MEDIA_TYPE(CurrDevice, SL_OEM_SOURCE_MEDIA_HAS_MSD)) {
                    AutoLoadOemScsi = TRUE;
                }
            }
            
            CurrDevice = CurrDevice->Next;
        }

        //
        // Set allocatable range to the kernel-specific range
        //
        BlUsableBase  = BL_KERNEL_RANGE_LOW;
        BlUsableLimit = BL_KERNEL_RANGE_HIGH;

        //
        // Load the kernel.
        //

        SlGetDisk(KERNEL_MP_IMAGE_FILENAME);
        strcpy(KernelDirectoryPath, BootPath);
        strcat(KernelDirectoryPath, KERNEL_MP_IMAGE_FILENAME);

        //
        // If AMD64 long mode is detected, the following call will set the
        // global BlAmd64UseLongMode to TRUE.
        //
        
#if defined(_X86_)

        BlAmd64CheckForLongMode(BootDeviceId, KernelDirectoryPath, "");

#endif

        strcpy(KernelImage, KERNEL_MP_IMAGE_FILENAME);

#ifdef i386
retrykernel:
#endif

        BlOutputLoadMessage(BootDevice, KernelDirectoryPath, BlFindMessage(SL_KERNEL_NAME));
        Status = BlLoadImage(BootDeviceId,
                             LoaderSystemCode,
                             KernelDirectoryPath,
                             TARGET_IMAGE,
                             &SystemBase);

        //
        // If the kernel didn't fit in the preferred range, reset the range to
        // all of memory and try again.
        //

#ifdef i386

        if ((Status == ENOMEM) &&
            ((BlUsableBase != 0) ||
             (BlUsableLimit != _16MB))) {
            BlUsableBase = 0;
            BlUsableLimit = _16MB;

            goto retrykernel;
        }

#endif

        if (Status != ESUCCESS) {
            SlFatalError(SL_FILE_LOAD_FAILED,
                         SlCopyStringAT(KernelDirectoryPath),
                         Status);

            goto LoadFailed;
        }

        BlUpdateBootStatus();

        //
        // Load the HAL.
        //

        strcpy(HalDirectoryPath, BootPath);
        if (PromptOemHal || (PreInstall && (ComputerType != NULL))) {
            if(PreInstall && OemHal) {
                //
                //  This is a pre-install and an OEM hal was specified
                //
                strcat( HalDirectoryPath,
#if defined(_X86_) || defined(_IA64_)
                        WINNT_OEM_DIR_A
#else
                        WINNT_OEM_TEXTMODE_DIR_A
#endif
                      );
                strcat( HalDirectoryPath, "\\" );
            }
            
            SlPromptOemHal((PreInstall ? PreInstallOemSourceDevice : DefaultOemSourceDevice),
                (BOOLEAN) (!PreInstall || (ComputerType == NULL)),
                &HalBase, 
                &HalName);
                
            strcat(HalDirectoryPath,HalName);

            //
            // Reset the last disk tag for floopy boot             
            //
            if (FloppyBoot) {
                LastDiskTag = NULL;
            }
        } else {
            if (AutoLoadOemHalDevice) {
                SlPromptOemHal(AutoLoadOemHalDevice,
                    FALSE,
                    &HalBase,
                    &HalName);
            } else {
                //
                //  Note that on x86, the HAL may be on floppy #1 or floppy #2
                //
                strcat(HalDirectoryPath,HalName);
                SlGetDisk(HalName);
                BlOutputLoadMessage(BootDevice, HalDirectoryPath, BlFindMessage(SL_HAL_NAME));

#ifdef i386
            retryhal:
#endif
                Status = BlLoadImage(BootDeviceId,
                                     LoaderHalCode,
                                     HalDirectoryPath,
                                     TARGET_IMAGE,
                                     &HalBase);
#ifdef i386
                //
                // If the HAL didn't fit in the preferred range, reset the range to
                // all of memory and try again.
                //
                if ((Status == ENOMEM) &&
                    ((BlUsableBase != 0) ||
                     (BlUsableLimit != _16MB))) {
                    BlUsableBase = 0;
                    BlUsableLimit = _16MB;

                    goto retryhal;
                }
#endif
                if (Status != ESUCCESS) {
                    SlFatalError(SL_FILE_LOAD_FAILED,
                                 SlCopyStringAT(HalDirectoryPath),
                                 Status);

                    goto LoadFailed;
                }
            }

            BlUpdateBootStatus();
        }

        //
        // Set allocatable range to the driver-specific range
        //
        BlUsableBase  = BL_DRIVER_RANGE_LOW;
        BlUsableLimit = BL_DRIVER_RANGE_HIGH;

    } else {

#if !defined(_IA64_)
        // 
        // don't need these variables for ia64
        //
        PCHAR id;
        ULONG idLength;
#endif

        //
        // This is a remote boot setup. Load the HAL first, so that we
        // can determine whether to load the UP or MP kernel.
        //
        // Note that we cannot load the HAL first on local boots
        // because that would break floppy boot, where the kernel
        // is on floppy #1 and the HALs are on floppy #2.
        //


        //
        // Set allocatable range to the kernel-specific range
        //
        BlUsableBase  = BL_KERNEL_RANGE_LOW;
        BlUsableLimit = BL_KERNEL_RANGE_HIGH;


#if defined(_IA64_)
        
        //
        // ===============
        // Load the kernel for IA64 systems.
        //
        // On IA64, load the kernel first, then hal.  This helps ensure
        // the kernel will go at 48Mb.
        // ===============
        //

        strcpy( KernelImage, KERNEL_MP_IMAGE_FILENAME );
        SlGetDisk(KernelImage);
        strcpy(KernelDirectoryPath, BootPath);
        strcat(KernelDirectoryPath,KernelImage);
        BlOutputLoadMessage(BootDevice, KernelDirectoryPath, BlFindMessage(SL_KERNEL_NAME));
        Status = BlLoadImage(BootDeviceId,
                             LoaderSystemCode,
                             KernelDirectoryPath,
                             TARGET_IMAGE,
                             &SystemBase);
        if (Status != ESUCCESS) {
            SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT(KernelDirectoryPath),Status);
            goto LoadFailed;
        }

        BlUpdateBootStatus();


#endif


        //
        // ===============
        // Load the hal.
        // ===============
        //


        strcpy(HalDirectoryPath, BootPath);

        if (PromptOemHal || (PreInstall && (ComputerType != NULL))) {
            if(PreInstall && OemHal) {
                //
                //  This is a pre-install and an OEM hal was specified
                //
                strcat( HalDirectoryPath,
#if defined(_X86_) || defined(_IA64_)
                        WINNT_OEM_DIR_A
#else
                        WINNT_OEM_TEXTMODE_DIR_A
#endif
                      );
                strcat( HalDirectoryPath, "\\" );
            }
            
            SlPromptOemHal((PreInstall ? PreInstallOemSourceDevice : DefaultOemSourceDevice), 
                (BOOLEAN) (!PreInstall || (ComputerType == NULL)),
                &HalBase, 
                &HalName);
                
            strcat(HalDirectoryPath,HalName);

            //
            // Reset the last disk tag for floopy boot             
            //
            if (FloppyBoot) {
                LastDiskTag = NULL;
            }
        } else {
            strcat(HalDirectoryPath,HalName);
            BlOutputLoadMessage(BootDevice, HalDirectoryPath, BlFindMessage(SL_HAL_NAME));
#ifdef i386
netbootretryhal:
#endif
            Status = BlLoadImage(BootDeviceId,
                                 LoaderHalCode,
                                 HalDirectoryPath,
                                 TARGET_IMAGE,
                                 &HalBase);
#ifdef i386
            //
            // If the HAL didn't fit in the preferred range, reset the range to
            // all of memory and try again.
            //
            if ((Status == ENOMEM) &&
                ((BlUsableBase != 0) ||
                 (BlUsableLimit != _16MB))) {
                BlUsableBase = 0;
                BlUsableLimit = _16MB;

                goto netbootretryhal;
            }
#endif
            if (Status != ESUCCESS) {
                SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT(HalDirectoryPath),Status);
                goto LoadFailed;
            }

            BlUpdateBootStatus();
        }


#if !defined(_IA64_)

        //
        // ===============
        // Load the kernel for non-IA64 systems.
        //
        // Load the kernel, loading ntoskrnl.exe or ntkrnlmp.exe based on
        // whether the HAL is UP or MP. This is important for remote boot
        // because the networking code's spin lock usage pattern requires
        // the kernel and HAL to be matched.
        //
        // If the computer ID string ends in "_mp", load the MP kernel.
        // Otherwise, load the UP kernel. The code is modeled after similar
        // code in setup\textmode\kernel\sphw.c\SpInstallingMp().
        //
        // ===============
        //

        id = SetupBlock->ComputerDevice.IdString;
        idLength = strlen(id);

        //
        // load ntkrnlmp always in MiniNT network boot
        //
        if (WinPEBoot || ((idLength >= 3) && (_stricmp(id+idLength-3,"_mp") == 0))) {
            strcpy(KernelImage,KERNEL_MP_IMAGE_FILENAME);
        } else {
            strcpy(KernelImage,KERNEL_UP_IMAGE_FILENAME);
        }


#if defined(REMOTE_BOOT)
#if DBG
        if ((strlen(id) + 1) > sizeof(SetupBlock->NetBootHalName)) {
            DbgPrint("The KERNEL name is too long!\n");
            goto LoadFailed;
        }
#endif

        strcpy(SetupBlock->NetBootHalName, id);
#endif // defined(REMOTE_BOOT)

        SlGetDisk(KernelImage);

        strcpy(KernelDirectoryPath, BootPath);
        strcat(KernelDirectoryPath,KernelImage);
        BlOutputLoadMessage(BootDevice, KernelDirectoryPath, BlFindMessage(SL_KERNEL_NAME));
#ifdef i386
netbootretrykernel:        
#endif
        Status = BlLoadImage(BootDeviceId,
                             LoaderSystemCode,
                             KernelDirectoryPath,
                             TARGET_IMAGE,
                             &SystemBase);
        if (Status != ESUCCESS) {
#ifdef i386
            //
            // If the kernel didn't fit in the preferred range, reset the range to
            // all of memory and try again.
            //
            if (Status == ENOMEM) {
                if (BlUsableBase == BL_KERNEL_RANGE_LOW &&
                    BlUsableLimit == BL_KERNEL_RANGE_HIGH) {
                    //
                    // first we try all of memory below 16MB
                    //
                    BlUsableBase = 0;
                    BlUsableLimit = _16MB;
                    goto netbootretrykernel;
                } else if (BlUsableBase == 0 &&
                           BlUsableLimit == _16MB) {
                    //
                    // then we try all of memory above 16MB
                    //
                    BlUsableBase = _16MB;
                    BlUsableLimit = BL_DRIVER_RANGE_HIGH;
                    goto netbootretrykernel;
                }
            }
#endif
            SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT(KernelDirectoryPath),Status);
            goto LoadFailed;
        }

        BlUpdateBootStatus();
    

#endif // if !defined(_IA64_)
    
        //
        // Set allocatable range to the driver-specific range
        //
        BlUsableBase  = BL_DRIVER_RANGE_LOW;
        BlUsableLimit = BL_DRIVER_RANGE_HIGH;    
    
    }


    //
    // Load Kernel Debugger DLL
    //
    
    strcpy(KdDllName, BootPath);
    strcat(KdDllName, KdFileName);
    SlGetDisk(KdFileName);
    BlOutputLoadMessage(BootDevice, KdDllName, BlFindMessage(SL_KDDLL_NAME));
    Status = BlLoadImage(BootDeviceId,
                         LoaderHalCode,
                         KdDllName,
                         TARGET_IMAGE,
                         &KdDllBase);

    if ((Status != ESUCCESS) && (UseAlternateKdDll == TRUE)) {
        UseAlternateKdDll = FALSE;

        strcpy(KdDllName, BootPath);
        strcpy(KdFileName, "KDCOM.DLL");
        strcat(KdDllName, KdFileName);

        Status = BlLoadImage(BootDeviceId,
                             LoaderHalCode,
                             KdDllName,
                             TARGET_IMAGE,
                             &KdDllBase);
    }

    if (Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED, SlCopyStringAT(KdDllName), Status);
        goto LoadFailed;
    }

    //
    // Generate a loader data entry for the system image.
    //

    Status = BlAllocateDataTableEntry("ntoskrnl.exe",
                                      KernelDirectoryPath,
                                      SystemBase,
                                      &SystemDataTableEntry);

    if (Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT(KernelDirectoryPath),Status);
        goto LoadFailed;
    }

    //
    // Generate a loader data entry for the HAL DLL.
    //

    Status = BlAllocateDataTableEntry("hal.dll",
                                      HalDirectoryPath,
                                      HalBase,
                                      &HalDataTableEntry);

    if (Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT(HalDirectoryPath),Status);
        goto LoadFailed;
    }

    //
    // Generate a loader data entry for the Kernel Debugger DLL.
    //

    Status = BlAllocateDataTableEntry("kdcom.dll",
                                      KdDllName,
                                      KdDllBase,
                                      &KdDataTableEntry);

    if (Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED, SlCopyStringAT(KdDllName), Status);
        goto LoadFailed;
    }

    PathSet.PathCount = 1;
    PathSet.AliasName = "\\SystemRoot";
    PathSet.PathOffset[0] = '\0';
    PathSet.Source[0].DeviceId = BootDeviceId;
    PathSet.Source[0].DeviceName = BootDevice;
    PathSet.Source[0].DirectoryPath = BootPath;

    Status = BlScanImportDescriptorTable(&PathSet,
                                         SystemDataTableEntry,
                                         LoaderSystemCode
                                         );

    if (Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT(KernelImage),Status);
    }

    //
    // Scan the import table for the HAL DLL and load all referenced DLLs.
    //

    Status = BlScanImportDescriptorTable(&PathSet,
                                         HalDataTableEntry,
                                         LoaderHalCode);

    if (Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT("hal.dll"),Status);
        goto LoadFailed;
    }

    //
    // Scan the import table for the Kernel Debugger DLL and load all
    // referenced DLLs.
    //

    Status = BlScanImportDescriptorTable(&PathSet,
                                         KdDataTableEntry,
                                         LoaderSystemCode);


    if (Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED, SlCopyStringAT(KdFileName), Status);
        goto LoadFailed;
    }

    //
    // Relocate the system entry point and set system specific information.
    //

    NtHeaders = RtlImageNtHeader(SystemBase);
    SystemEntry = (PTRANSFER_ROUTINE)((ULONG_PTR)SystemBase +
                                NtHeaders->OptionalHeader.AddressOfEntryPoint);

#if defined(_IA64_)

    BlLoaderBlock->u.Ia64.KernelVirtualBase = (ULONG_PTR)SystemBase;
    BlLoaderBlock->u.Ia64.KernelPhysicalBase = (ULONG_PTR)SystemBase & 0x7fffffff;

#endif

    ///////////////////////////////////////////////////////////////////
    //
    //  On x86, the files loaded from now on are on boot floppy #2
    //
    ///////////////////////////////////////////////////////////////////

    //
    // Load registry's SYSTEM hive
    //

    SlGetDisk("SETUPREG.HIV");
    Status = BlLoadSystemHive(BootDeviceId,
                              NULL, // BlFindMessage(SL_HIVE_NAME), UNREFERENCED_PARAMETER
                              BootPath,
                              "SETUPREG.HIV");

    if (Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT("SETUPREG.HIV"),Status);
        goto LoadFailed;
    }

    //
    // Pull the Docking information from the hardware tree.
    //

    dockInfoData = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                            PeripheralClass,
                                            DockingInformation,
                                            NULL);

    if (NULL == dockInfoData) {
        BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
        BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_UNKNOWN;
        BlLoaderBlock->Extension->Profile.Capabilities = 0;
        BlLoaderBlock->Extension->Profile.DockID = 0;
        BlLoaderBlock->Extension->Profile.SerialNumber = 0;

    } else if (sizeof (dockInfo) <=
               dockInfoData->ComponentEntry.ConfigurationDataLength) {

        RtlCopyMemory (
            &dockInfo,
            (PUCHAR) (dockInfoData->ConfigurationData) + sizeof(CM_PARTIAL_RESOURCE_LIST),
            sizeof (dockInfo));

        BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_FAILURE;

        switch (dockInfo.ReturnCode) {
        case FW_DOCKINFO_SUCCESS:
            BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
            BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_DOCKED;
            BlLoaderBlock->Extension->Profile.Capabilities = dockInfo.Capabilities;
            BlLoaderBlock->Extension->Profile.DockID = dockInfo.DockID;
            BlLoaderBlock->Extension->Profile.SerialNumber = dockInfo.SerialNumber;
            break;

        case FW_DOCKINFO_SYSTEM_NOT_DOCKED:
            BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
            BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_UNDOCKED;
            BlLoaderBlock->Extension->Profile.Capabilities = dockInfo.Capabilities;
            BlLoaderBlock->Extension->Profile.DockID = dockInfo.DockID;
            BlLoaderBlock->Extension->Profile.SerialNumber = dockInfo.SerialNumber;
            break;

        case FW_DOCKINFO_DOCK_STATE_UNKNOWN:
            BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
            BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_UNKNOWN;
            BlLoaderBlock->Extension->Profile.Capabilities = dockInfo.Capabilities;
            BlLoaderBlock->Extension->Profile.DockID = dockInfo.DockID;
            BlLoaderBlock->Extension->Profile.SerialNumber = dockInfo.SerialNumber;
            break;

        case FW_DOCKINFO_FUNCTION_NOT_SUPPORTED:
        case FW_DOCKINFO_BIOS_NOT_CALLED:
            BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
        default:
            BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_UNSUPPORTED;
            BlLoaderBlock->Extension->Profile.Capabilities = dockInfo.Capabilities;
            BlLoaderBlock->Extension->Profile.DockID = dockInfo.DockID;
            BlLoaderBlock->Extension->Profile.SerialNumber = dockInfo.SerialNumber;
            break;
        }

    } else {
        BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
        BlLoaderBlock->Extension->Profile.Capabilities = 0;
        BlLoaderBlock->Extension->Profile.DockID = 0;
        BlLoaderBlock->Extension->Profile.SerialNumber = 0;
    }

    if (BlLoaderBlock->Extension->Profile.Status == HW_PROFILE_STATUS_SUCCESS) {
        //
        // We don't match profiles in textmode setup so just pretend that we did.
        //
        BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_TRUE_MATCH;
    }

    //
    // Allocate structure for NLS data.
    //

    BlLoaderBlock->NlsData = BlAllocateHeap(sizeof(NLS_DATA_BLOCK));
    if (BlLoaderBlock->NlsData == NULL) {
        Status = ENOMEM;
        SlNoMemoryError();
        goto LoadFailed;
    }

    //
    // Load the OEM font
    //

    SlGetDisk(OemHalFontName);
    Status = BlLoadOemHalFont(BootDeviceId,
                              NULL, // BlFindMessage(SL_OEM_FONT_NAME), UNREFERENCED_PARAMETER
                              BootPath,
                              &OemHalFont,
                              BadFileName);

    if(Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED, SlCopyStringAT(BadFileName), Status);
        goto LoadFailed;
    }

    //
    // Load the NLS data.
    //
    // For now, we ensure that the disk containing the ansi
    // codepage file is in the drive and hope that the rest of the
    // nls files (oem codepage, unicode table) are on the same disk.
    //

    SlGetDisk(AnsiCpName);
    Status = BlLoadNLSData(BootDeviceId,
                           NULL, // BlFindMessage(SL_NLS_NAME), UNREFERENCED_PARAMETER
                           BootPath,
                           &AnsiCodepage,
                           &OemCodepage,
                           &UnicodeCaseTable,
                           BadFileName);

    if(Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED, SlCopyStringAT(BadFileName), Status);
        goto LoadFailed;
    }

    //
    // Load the system drivers we will need here
    //

    InitializeListHead(&BlLoaderBlock->BootDriverListHead);

    //
    // Load setupdd.sys next. Setupdd.sys needs to be loaded before any other
    // driver, because it will need to prep the rest of the system.
    //
    Status = SlLoadDriver(BlFindMessage(SL_SETUP_NAME),
                          "setupdd.sys",
                          0,
                          TRUE,
                          FALSE,
                          NULL
                          );

    if (Status != ESUCCESS) {
        SlFatalError(SL_FILE_LOAD_FAILED,SlCopyStringAT("setupdd.sys"),Status);
        goto LoadFailed;
    }

    //
    // Fill in its registry key -- setupdd fills these in for all the other
    // drivers (unless we do it here), but we have to do it here for setupdd
    // itself.
    //

    DriverEntry = (PBOOT_DRIVER_LIST_ENTRY)(BlLoaderBlock->BootDriverListHead.Flink);
    DriverEntry->RegistryPath.Buffer = BlAllocateHeap(256);
    if (DriverEntry->RegistryPath.Buffer == NULL) {
        SlNoMemoryError();
        goto LoadFailed;
    }

    DriverEntry->RegistryPath.Length = 0;
    DriverEntry->RegistryPath.MaximumLength = 256;
    RtlAppendUnicodeToString(&DriverEntry->RegistryPath,
                             L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\setupdd");

#if 0
#ifdef i386
    //
    // Note that if pciide.sys, intelide.sys and pciidex.sys are on the same
    // boot floppy (x86 only), then we don't need to load pciidex.sys.
    // The driver will be automatically loaded when pciide.sys or intelide.sys
    // (both listed on [BusExtenders.Load] is loaded.
    //
    Status = SlLoadDriver(BlFindMessage(SL_PCI_IDE_EXTENSIONS_NAME),
                          "PCIIDEX.SYS",
                          0,
                          FALSE,
                          FALSE,
                          NULL
                          );
#endif
#endif

    //
    //  Load boot bus extenders.
    //  It has to be done before scsiport.sys
    //

    Status = SlLoadPnpDriversSection( InfFile,
                                      "BootBusExtenders",
                                      &(SetupBlock->BootBusExtenders) );
    if (Status!=ESUCCESS) {
        goto LoadFailed;
    }

    //
    //  Load bus extenders.
    //  It has to be done before scsiport.sys
    //

    Status = SlLoadPnpDriversSection( InfFile,
                                      "BusExtenders",
                                      &(SetupBlock->BusExtenders) );
    if (Status!=ESUCCESS) {
        goto LoadFailed;
    }

    //
    //  Load input device related drivers.
    //

    Status = SlLoadPnpDriversSection( InfFile,
                                      "InputDevicesSupport",
                                      &(SetupBlock->InputDevicesSupport) );
    if (Status!=ESUCCESS) {
        goto LoadFailed;
    }

    //
    //  Detect video
    //

    SlDetectVideo(SetupBlock);
    
    //
    // On x86, the video type is always set to VGA in i386\x86dtect.c.
    // On non-x86, the video type is either recognized, in which case
    // we don't unconditionally need vga.sys (the Display.Load section
    // tells us what to load), or it's not recognized,
    // in which case we will prompt the user for an oem disk.
    // If there is no display controller node at all, then PromptOemDisk
    // will be false and there will be no video device. In this case
    // we load vga.sys.
    //

    if (SetupBlock->VideoDevice.IdString != NULL) {
        VideoFileName = SlGetSectionKeyIndex(InfFile,
                                             "Display.Load",
                                             SetupBlock->VideoDevice.IdString,
                                             SIF_FILENAME_INDEX);
        if (VideoFileName != NULL) {
#ifdef ARCI386
            VideoDescription = SlGetIniValue(InfFile,
                                             "Display",
                                             SetupBlock->VideoDevice.IdString,
                                             BlFindMessage(SL_VIDEO_NAME));
#else
            //
            // With the new video detection mechanism, the description
            // for the video driver is likely to be something like
            // "Windows NT Compatible" which looks funny when displayed
            // in the status bar.
            //
            VideoDescription = BlFindMessage(SL_VIDEO_NAME);
#endif
            if (!WinPEBoot) {
                Status = SlLoadDriver(VideoDescription,
                                      VideoFileName,
                                      0,
                                      TRUE,
                                      FALSE,
                                      NULL
                                      );
            }

            if (Status == ESUCCESS) {
                SetupBlock->VideoDevice.BaseDllName = SlCopyStringA(VideoFileName);

            } else {
                SlFriendlyError(
                    Status,
                    VideoFileName,
                    __LINE__,
                    __FILE__
                    );
                goto LoadFailed;
            }

            LoadedAVideoDriver = TRUE;
        }
    } else if (PromptOemVideo) {

        SlPromptOemVideo(DefaultOemSourceDevice, 
            TRUE,
            &VideoBase, 
            &OemVideoName);

        Status = SlLoadOemDriver(
                    "VIDEOPRT.SYS",
                    OemVideoName,
                    VideoBase,
                    BlFindMessage(SL_VIDEO_NAME)
                    );

        if(Status==ESUCCESS) {

            LoadedAVideoDriver = TRUE;
            SetupBlock->VideoDevice.BaseDllName = SlCopyStringA(OemVideoName);
        }

        //
        // Reset the last disk tag for floopy boot             
        //
        if (FloppyBoot) {
            LastDiskTag = NULL;
        }        
    }

    if(!LoadedAVideoDriver) {
        Status = SlLoadDriver(BlFindMessage(SL_VIDEO_NAME),
                              VGA_DRIVER_FILENAME,
                              0,
                              TRUE,
                              FALSE,
                              NULL
                              );
        if(Status == ESUCCESS) {
            SetupBlock->VideoDevice.BaseDllName = SlCopyStringA(VGA_DRIVER_FILENAME);
        } else {
            SlFriendlyError(
                Status,
                VGA_DRIVER_FILENAME,
                __LINE__,
                __FILE__
                );
            goto LoadFailed;
        }
    }

    if(SetupBlock->VideoDevice.IdString == NULL) {
        SetupBlock->VideoDevice.IdString = SlCopyStringA(VIDEO_DEVICE_NAME);
    }

    //
    //  Load keyboard drivers.
    //

    Status = SlLoadPnpDriversSection( InfFile,
                                      "Keyboard",
                                      &(SetupBlock->KeyboardDevices) );
    if (Status!=ESUCCESS) {
        goto LoadFailed;
    }


    Status = SlLoadDriver(BlFindMessage(SL_KBD_NAME),
                          "kbdclass.sys",
                          0,
                          TRUE,
                          FALSE,
                          NULL
                          );
    if(Status != ESUCCESS) {
        SlFriendlyError(
             Status,
             "kbdclass.sys",
             __LINE__,
             __FILE__
             );
        goto LoadFailed;
    }

    //
    // We would need mouse support also in minint environment
    //

    if (WinPEBoot) {
        Status = SlLoadSection(InfFile,
                              "MouseDrivers",
                              FALSE,
                              TRUE,
                              NULL);

        if(Status != ESUCCESS) {
            SlFriendlyError(
                 Status,
                 "MouseDrivers",
                 __LINE__,
                 __FILE__
                 );
                 
            goto LoadFailed;
        }
    }


    ///////////////////////////////////////////////////////////////////
    //
    //  On x86, the files loaded from now on are on boot floppy #3
    //
    ///////////////////////////////////////////////////////////////////

    //
    // Load scsiport.sys next, so it'll always be around for any scsi miniports we may load
    //

    Status = SlLoadDriver(BlFindMessage(SL_SCSIPORT_NAME),
                          "SCSIPORT.SYS",
                          0,
                          FALSE,
                          FALSE,
                          NULL
                          );


    //
    // Detect scsi
    //
    // (If the user wants to select their own SCSI devices, we won't
    // do any detection)
    //

    if(!PromptOemScsi  && (PreinstallDriverList == NULL) ) {
        SlDetectScsi(SetupBlock);
#if defined(_X86_) || defined(_IA64_)
        if( Win9xUnsupHdc ) {
            //
            // If this is a Win9x upgrade and winnt32 detected an unsupported
            // SCSI controller, then the user needs to be prompted for an OEM SCSI driver
            //
            PromptOemScsi = TRUE;
        }
#endif
    }

#if defined(ELTORITO) && !defined(ARCI386)
    //
    // If this is an El Torito CD-ROM install, then we want to load all SCSI miniports
    // and disk class drivers.
    // BUT we do not want to load all the disk class drivers for an ARC
    // machine which knows what drivers it wants to install from its tree
    //
    if(ElToritoCDBoot) {
        LoadScsiMiniports = TRUE;
    }
#endif

    //
    // If the LoadScsi flag is set, enumerate all the known SCSI miniports and load each
    // one.
    //
   if(LoadScsiMiniports && (PreinstallDriverList == NULL)) {
        if (WinPEBoot && OemInfHandle) {
            Status = SlLoadWinPESection(PreInstallOemSourceDevice,
                        OemInfHandle,
                        WINNT_OEMSCSIDRIVERS_A,
                        InfFile,
                        "Scsi",
                        TRUE,
                        &OemScsiInfo,
                        &BlLoaderBlock->SetupLoaderBlock->HardwareIdDatabase);
        } else {
            Status = SlLoadSection(InfFile,"Scsi",TRUE, TRUE, NULL);
        }
        
        if (Status!=ESUCCESS) {
            goto LoadFailed;
        }
        
        SetupBlock->ScalarValues.LoadedScsi = 1;
    }

    //
    // Pick the the dynamic update boot drivers, if any
    //

    if (DynamicUpdate) {
        SlLoadOemScsiDriversUnattended(DynamicUpdateSourceDevice,
            WinntSifHandle,
            WINNT_SETUPPARAMS_A,
            WINNT_SP_DYNUPDTBOOTDRIVERROOT_A,           
            WINNT_SP_DYNUPDTBOOTDRIVERS_A,
            &OemScsiInfo,
            &BlLoaderBlock->SetupLoaderBlock->HardwareIdDatabase);
    }

    //
    // Allow the user to pick an OEM SCSI driver here
    //

    if (PromptOemScsi || (PreinstallDriverList != NULL)) {
        POEMSCSIINFO    DynUpdtScsiInfo = OemScsiInfo;

        SlPromptOemScsi(((PreinstallDriverList == NULL) ? 
                                DefaultOemSourceDevice : PreInstallOemSourceDevice),
            (BOOLEAN) (!PreInstall || (PreinstallDriverList == NULL)),
            &OemScsiInfo);

        //
        // Mark the default OEM source device as processed, 
        // if the user manually pressed F6
        //
        if (PromptOemScsi && DefaultOemSourceDevice) {
            SL_OEM_SET_SOURCE_DEVICE_STATE(DefaultOemSourceDevice,
                SL_OEM_SOURCE_DEVICE_PROCESSED);
        }

        //
        // Reset the last disk tag for floopy boot             
        //
        if (FloppyBoot) {
            LastDiskTag = NULL;
        }

        //
        // Merge the dynamic update SCSI driver list with oem SCSI
        // driver list
        //
        if (DynUpdtScsiInfo) {
            if (OemScsiInfo) {
                POEMSCSIINFO    CurrNode = DynUpdtScsiInfo;

                while (CurrNode && CurrNode->Next) {
                    CurrNode = CurrNode->Next;
                }

                if (CurrNode) {
                    CurrNode->Next = OemScsiInfo;
                    OemScsiInfo = DynUpdtScsiInfo;
                }
            } else {
                OemScsiInfo = DynUpdtScsiInfo;
            }
        }

        // Cleanup here needed for all installation - ARCI386
        if (UseRegularBackground) {
          SlClearDisplay();

          if (WinPEBoot) {
            StartupMsg ? BlOutputStartupMsgStr(StartupMsg) :
                         BlOutputStartupMsg(SL_SETUP_STARTING_WINPE);
          } else {
            if (UseCommandConsole) {
                BlOutputStartupMsg(SL_CMDCONS_STARTING);
            } else if (g_RollbackEnabled) {
                BlOutputStartupMsg(SL_ROLLBACK_STARTING);
            } else {
                BlOutputStartupMsg(SL_SETUP_STARTING);
            }
          }

          BlRedrawProgressBar();
        } else {
          SlClearClientArea();
          SlWriteStatusText(TEXT(""));
        }
    } 

    //
    // If we found any valid txtsetup.oem with valid default MSD
    // in any OEM source device which is not yet processed, then
    // go and autoload the drivers from these devices.
    //

    if (OemSourceDevices && AutoLoadOemScsi) {
        POEMSCSIINFO DeviceOemScsiInfo = NULL;
        POEMSCSIINFO LastOemScsiNode = NULL;

        //
        // Determine if we need to disable the Virtual OEM devices.
        // Disable OEM virtual Devices if we have been instructed by F4 in 
        // attended install, using the DisableOemVirtualDevices key in the unattend
        // file or if Preinstall.
        //
        if (SlIsVirtualOemDeviceDisabled(WinntSifHandle, 
                                         PreinstallDriverList)) {
            SlDisableVirtualOemDevices(OemSourceDevices);
        }
        SlLoadOemScsiDriversFromOemSources(OemSourceDevices,
            &BlLoaderBlock->SetupLoaderBlock->HardwareIdDatabase,
            &DeviceOemScsiInfo);            
        
        //
        // Merge the full OEM source device list with the 
        // global OEM scsi information
        //        
        if (DeviceOemScsiInfo) {
            if (OemScsiInfo) {
                LastOemScsiNode = OemScsiInfo;

                while (LastOemScsiNode->Next) {
                    LastOemScsiNode = LastOemScsiNode->Next;
                }

                LastOemScsiNode->Next = DeviceOemScsiInfo;
            } else {
                OemScsiInfo = DeviceOemScsiInfo;
            }                
        }        
    }

    //
    // Load all the disk images for the virtual devices
    // into memory
    //

    if (OemSourceDevices) {
        Status = SlInitVirtualOemSourceDevices(BlLoaderBlock->SetupLoaderBlock,
                        OemSourceDevices);           

        if (Status != ESUCCESS) {                        
            SlFatalError(SL_OEM_FILE_LOAD_FAILED);
        
            goto LoadFailed;
        }            
    }                
   
    //
    //  Add unsupported SCSI drivers, if any, to the list
    //

    if( UnsupDriversInfHandle != NULL ) {
        Status = SlDetectMigratedScsiDrivers( UnsupDriversInfHandle );
        if (Status!=ESUCCESS) {
            goto LoadFailed;
        }
    }

    //
    // Walk the list of detected SCSI miniports and load each one.
    //

    ScsiDevice = SetupBlock->ScsiDevices;
    while (ScsiDevice != NULL) {

        if(ScsiDevice->ThirdPartyOptionSelected) {

            if(!OemScsiInfo) {
                SlError(500);
                goto LoadFailed;
            }

            Status = SlLoadOemDriver(
                        NULL,
                        OemScsiInfo->ScsiName,
                        OemScsiInfo->ScsiBase,
                        BlFindMessage(SL_SCSIPORT_NAME)
                        );
            OemScsiInfo = OemScsiInfo->Next;
        } else if(ScsiDevice->MigratedDriver) {
            Status = SlLoadDriver(ScsiDevice->Description,
                                  ScsiDevice->BaseDllName,
                                  0,
                                  TRUE,
                                  TRUE,
                                  ScsiDevice->IdString
                                  );
            if( Status != ESUCCESS ) {
//                DebugOutput("Status = %d %s \n",Status,"");
            }
        } else {
            Status = SlLoadDriver(ScsiDevice->Description,
                                  ScsiDevice->BaseDllName,
                                  0,
                                  TRUE,
                                  FALSE,
                                  NULL
                                  );
        }

        if((Status == ESUCCESS)
        || ((Status == ENOENT) && IgnoreMissingFiles && !ScsiDevice->ThirdPartyOptionSelected)) {

            SetupBlock->ScalarValues.LoadedScsi = 1;

        } else {
            SlFriendlyError(
                Status,
                ScsiDevice->BaseDllName,
                __LINE__,
                __FILE__
                );
            goto LoadFailed;
        }

        ScsiDevice = ScsiDevice->Next;
    }

    //
    // If the LoadDiskClass flag is set, enumerate all the monolithic disk class drivers
    // and load each one.  Note that we also do this if we've "detected" any scsi drivers,
    // so that we preserve the drive order.
    //

    if((LoadDiskClass) || (SetupBlock->ScalarValues.LoadedScsi == 1)) {
        Status = SlLoadSection(InfFile, "DiskDrivers", FALSE, TRUE, NULL);
        if (Status == ESUCCESS) {
            SetupBlock->ScalarValues.LoadedDiskDrivers = 1;
        } else {
            goto LoadFailed;
        }
    }


#if !defined(_IA64_)
    //
    // There is currently no floppy support on IA64 systems.
    //

    //
    // Load the floppy driver (flpydisk.sys)
    //
#if !defined (ARCI386) && defined(_X86_)
    Status=ESUCCESS;

    //
    // If there are only SFLOPPY devices (such as the LS-120 ATAPI super floppy)
    // DON'T load flpydisk.sys on them. It will collide with SFLOPPY.SYS
    //
    if (!SlpIsOnlySuperFloppy()) {
#endif
        Status = SlLoadDriver(BlFindMessage(SL_FLOPPY_NAME),
                              "flpydisk.sys",
                              0,
                              TRUE,
                              FALSE,
                              NULL
                              );
#if !defined (ARCI386) && defined(_X86_)
    }
#endif
    if (Status == ESUCCESS) {
        SetupBlock->ScalarValues.LoadedFloppyDrivers = 1;
    }
#endif
#ifdef i386
    else {
        SlFriendlyError(
             Status,
             "flpydisk.sys",
             __LINE__,
             __FILE__
             );
        goto LoadFailed;
    }
#endif

    if(SetupBlock->ScalarValues.LoadedScsi == 1) {
        //
        // Enumerate the entries in the scsi class section and load each one.
        //
        Status = SlLoadSection(InfFile, "ScsiClass",FALSE, TRUE, NULL);
        if (Status != ESUCCESS) {
            goto LoadFailed;
        }
    }

    if((LoadDiskClass) || (SetupBlock->ScalarValues.LoadedScsi == 1)) {
        Status = SlLoadSection(InfFile, "FileSystems", FALSE, TRUE, NULL);
        if (Status == ESUCCESS) {
            SetupBlock->ScalarValues.LoadedFileSystems = 1;
        } else {
            goto LoadFailed;
        }
    } else {

        //
        // Load FAT
        //
        Status = SlLoadDriver(BlFindMessage(SL_FAT_NAME),
                              "fastfat.sys",
                              0,
                              TRUE,
                              FALSE,
                              NULL
                              );
#ifdef i386
        if(Status != ESUCCESS) {
            SlFriendlyError(
                 Status,
                 "fastfat.sys",
                 __LINE__,
                 __FILE__
                 );
            goto LoadFailed;
        }
#endif
    }

    //
    // Load CDFS if setupldr was started from a cdrom, or if ForceLoadCdfs is set.
    //

    if (LoadCdfs || (!BlGetPathMnemonicKey(SetupDevice,
                                          "cdrom",
                                          &BootDriveNumber))) {
        Status = SlLoadSection(InfFile, "CdRomDrivers",FALSE, TRUE, NULL);
        if (Status == ESUCCESS) {
            SetupBlock->ScalarValues.LoadedCdRomDrivers = 1;
        } else {
            goto LoadFailed;
        }
    }

    if (BlBootingFromNet || WinPEBoot) {

        //
        // Load the network stack.
        //

        Status = SlLoadDriver(BlFindMessage(SL_KSECDD_NAME),
                              "ksecdd.sys",
                              0,
                              TRUE,
                              FALSE,
                              NULL
                              );
        if(Status != ESUCCESS) {
            SlFriendlyError(
                 Status,
                 "ksecdd.sys",
                 __LINE__,
                 __FILE__
                 );
            goto LoadFailed;

        }

        Status = SlLoadDriver(BlFindMessage(SL_NDIS_NAME),
                              "ndis.sys",
                              0,
                              TRUE,
                              FALSE,
                              NULL
                              );
        if(Status != ESUCCESS) {
            SlFriendlyError(
                 Status,
                 "ndis.sys",
                 __LINE__,
                 __FILE__
                 );
            goto LoadFailed;

        }

        if (BlBootingFromNet) {

            Status = SlLoadDriver(BlFindMessage(SL_IPSEC_NAME),
                                  "ipsec.sys",
                                  0,
                                  TRUE,
                                  FALSE,
                                  NULL
                                  );
            if(Status != ESUCCESS) {
                SlFriendlyError(
                     Status,
                     "ipsec.sys",
                     __LINE__,
                     __FILE__
                     );
                goto LoadFailed;
            }

            Status = SlLoadDriver(BlFindMessage(SL_TCPIP_NAME),
                                  "tcpip.sys",
                                  0,
                                  TRUE,
                                  FALSE,
                                  NULL
                                  );
            if(Status != ESUCCESS) {
                SlFriendlyError(
                     Status,
                     "tcpip.sys",
                     __LINE__,
                     __FILE__
                     );
                goto LoadFailed;
            }

            Status = SlLoadDriver(BlFindMessage(SL_NETBT_NAME),
                                  "netbt.sys",
                                  0,
                                  TRUE,
                                  FALSE,
                                  NULL
                                  );
            if(Status != ESUCCESS) {
                SlFriendlyError(
                     Status,
                     "netbt.sys",
                     __LINE__,
                     __FILE__
                     );
                goto LoadFailed;
            }

            Status = SlLoadDriver(BlFindMessage(SL_NETADAPTER_NAME),
                                  NetbootCardDriverName,
                                  0,
                                  TRUE,
                                  FALSE,
                                  NULL
                                  );
            if(Status != ESUCCESS) {
                SlFriendlyError(
                     Status,
                     NetbootCardDriverName,
                     __LINE__,
                     __FILE__
                     );
                goto LoadFailed;
            }

            //
            // Fill in the registry key for the netboot card because its service name
            // may be different from the driver name.
            //
            DriverEntry = (PBOOT_DRIVER_LIST_ENTRY)(BlLoaderBlock->BootDriverListHead.Blink);   // SlLoadDriver inserts at the tail
            DriverEntry->RegistryPath.Buffer = BlAllocateHeap(256);
            if (DriverEntry->RegistryPath.Buffer == NULL) {
                SlNoMemoryError();
                goto LoadFailed;
            }
            DriverEntry->RegistryPath.Length = 0;
            DriverEntry->RegistryPath.MaximumLength = 256;
            RtlAppendUnicodeToString(&DriverEntry->RegistryPath,
                                     L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\");
            RtlAppendUnicodeToString(&DriverEntry->RegistryPath,
                                     SetupBlock->NetbootCardServiceName);

            Status = SlLoadDriver(BlFindMessage(SL_RDBSS_NAME),
                                  "rdbss.sys",
                                  0,
                                  TRUE,
                                  FALSE,
                                  NULL
                                  );
            if(Status != ESUCCESS) {
                SlFriendlyError(
                     Status,
                     "rdbss.sys",
                     __LINE__,
                     __FILE__
                     );
                goto LoadFailed;
            }
        }

        Status = SlLoadDriver(BlFindMessage(SL_MUP_NAME),
                              "mup.sys",
                              0,
                              TRUE,
                              FALSE,
                              NULL
                              );

        if(Status != ESUCCESS) {
            SlFriendlyError(
                 Status,
                 "mup.sys",
                 __LINE__,
                 __FILE__
                 );
            goto LoadFailed;
        }

        if (BlBootingFromNet) {
            Status = SlLoadDriver(BlFindMessage(SL_MRXSMB_NAME),
                                  "mrxsmb.sys",
                                  0,
                                  TRUE,
                                  FALSE,
                                  NULL
                                  );
            if(Status != ESUCCESS) {
                SlFriendlyError(
                     Status,
                     "mrxsmb.sys",
                     __LINE__,
                     __FILE__
                     );
                goto LoadFailed;
            }
        }
    }

    if( WinPEBoot && BlLoaderBlock->Extension->HeadlessLoaderBlock != NULL ) {
        //
        // Try and load the sacdriver.
        //
        Status = SlLoadDriver(BlFindMessage(SL_SACDRV_NAME),
                      "sacdrv.sys",
                      0,
                      TRUE,
                      FALSE,
                      NULL
                      );

    }

    if (!UseRegularBackground) {
        SlWriteStatusText (BlFindMessage (SL_KERNEL_TRANSITION));
    }

    //
    // Finally, make sure the appropriate disk containing NTDLL.DLL is in
    // the drive.
    //

    SlGetDisk("ntdll.dll");

    //
    // Fill in the SETUPLDR block with relevant information
    //
    SetupBlock->ArcSetupDeviceName = BlLoaderBlock->ArcBootDeviceName;

    SetupBlock->ScalarValues.SetupFromCdRom = FALSE;
    SetupBlock->ScalarValues.SetupOperation = SetupOperationSetup;

    //
    // Get the NTFT drive signatures to allow the kernel to create the
    // correct ARC name <=> NT name mappings.
    //
    //
    // X86Only : Go enumerate all the disks and record their ability to
    // support xint13.
    //

    BlGetArcDiskInformation(TRUE);
    
    //
    // ntdetect has already run.  Although it's awful to have
    // 2 disks that look just alike, stamping a signature on one
    // after ntdetect has run will also break us.  Rather err on
    // the side of caution and not write to the disks.
    //
    // This is much safer on x86 because we've ensured that the
    // boot disk has a signature before we get here.  On Alpha,
    // we can't do that.  So it's ugly, but call this guy for
    // BIOS-based x86 machines.

    //
    // don't reboot after stamping signatures
    // the first time
    //

    SlpMarkDisks(FALSE);
 
    //
    // If setup was started from a CD-ROM, generate an entry in the ARC disk
    // information list describing the cd-rom.
    //

    if (!BlGetPathMnemonicKey(SetupDevice,
                              "cdrom",
                              &BootDriveNumber)) {
        BlReadSignature(SetupDevice,TRUE);
    }

    //
    // Close the ARC device.
    //

    ArcClose(BootDeviceId);


#if 0
  {
        ULONG   EndTime = ArcGetRelativeTime();
        char    szTemp[256];
        extern ULONG BlFilesOpened;

        BlPositionCursor(1, 10);
        sprintf(szTemp, "BootTime : %d secs, FilesOpened : %d\r\n",
                  EndTime - StartTime, BlFilesOpened );

        BlPrint(szTemp);
  }
#endif

    if (UseRegularBackground) {
      BlOutputStartupMsg(SL_PLEASE_WAIT);
      BlUpdateProgressBar(100);
    }
       
    //
    // Remove system32 from the boot path if we added it
    //

    if (WinPEBoot) {
        PCHAR Sys32 = BlLoaderBlock->NtBootPathName +
                        strlen(BlLoaderBlock->NtBootPathName) -
                        strlen("system32\\");

        if (Sys32 && !_stricmp(Sys32, "system32\\")) {
            *Sys32 = 0;
        }
    }


    //
    // Close down the remote boot network file system.
    //
    // NOTE: If BlBootingFromNet, don't do anything after this point
    // that would cause access to the boot ROM.
    //

    if ( BlBootingFromNet ) {
        NetTerminate();
    }

    //
    //
    // Execute the architecture specific setup code.
    //
    // NOTE: If BlBootingFromNet, don't do anything after this point
    // that would cause access to the boot ROM.
    //

    Status = BlSetupForNt(BlLoaderBlock);
    if (Status != ESUCCESS) {
        SlFriendlyError(
            Status,
            "\"Windows NT Executive\"",
             __LINE__,
             __FILE__
            );
        goto LoadFailed;
    }

    //
    // Transfer to the kernel
    //

//    DbgBreakPoint();

    BlTransferToKernel(SystemEntry, BlLoaderBlock);

    //
    // Any return from the system is an error.
    //

    Status = EBADF;
    SlFriendlyError(
        Status,
        "\"Windows NT Executive\"",
        __LINE__,
        __FILE__
        );

LoadFailed:
    SlWriteStatusText(BlFindMessage(SL_TOTAL_SETUP_DEATH));
    SlFlushConsoleBuffer();
    SlGetChar();
    ArcRestart();
    return(Status);
}


VOID
SlpTruncateMemory(
    IN ULONG MaxMemory
    )

/*++

Routine Description:

    Eliminates all the memory descriptors above a given boundary

Arguments:

    MaxMemory - Supplies the maximum memory boundary in megabytes

Return Value:

    None.

--*/

{
    PLIST_ENTRY NextEntry;
    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;
    ULONG MaxPage = MaxMemory * 256;        // Convert Mb to pages

    if (MaxMemory == 0) {
        return;
    }

    NextEntry = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    while ( NextEntry != &BlLoaderBlock->MemoryDescriptorListHead ) {
        MemoryDescriptor = CONTAINING_RECORD(NextEntry,
                                             MEMORY_ALLOCATION_DESCRIPTOR,
                                             ListEntry);
        NextEntry = NextEntry->Flink;
        if ( (MemoryDescriptor->MemoryType != LoaderFree) &&
             (MemoryDescriptor->MemoryType != LoaderFirmwareTemporary) ) {
            continue;
        }
        if (MemoryDescriptor->BasePage >= MaxPage) {
            //
            // This memory descriptor lies entirely above the boundary,
            // eliminate it.
            //
            BlRemoveDescriptor(MemoryDescriptor);
        } else if (MemoryDescriptor->BasePage + MemoryDescriptor->PageCount > MaxPage) {
            //
            // This memory descriptor crosses the boundary, truncate it.
            //
            MemoryDescriptor->PageCount = MaxPage - MemoryDescriptor->BasePage;
        }
    }
}

VOID
SlGetSetupValuesBeforePrompt(
    IN PSETUP_LOADER_BLOCK SetupBlock
    )

/*++

Routine Description:

    Reads the setup control values out of the given .INI file.
    Also supplies reasonable defaults for values that don't exist.

Arguments:

    SetupBlock - Supplies a pointer to the Setup loader block

Return Value:

    None.  Global variables are initialized to reflect the
    contents of the INI file

--*/

{
    PCHAR NlsName;
    ANSI_STRING NlsString;
    PCHAR Options="1";
    ULONG MaxMemory;

    if (BlBootingFromNet) {
        BlLoaderBlock->LoadOptions = SlGetIniValue(WinntSifHandle,
                                                   "setupdata",
                                                   "osloadoptions",
                                                   NULL);
    } else {
        BlLoaderBlock->LoadOptions = NULL;
    }

    if (BlLoaderBlock->LoadOptions == NULL) {
        BlLoaderBlock->LoadOptions = SlGetIniValue(InfFile,
                                                   "setupdata",
                                                   "osloadoptions",
                                                   NULL);
    }

    AnsiCpName = SlGetIniValue(InfFile,
                               "nls",
                               "AnsiCodepage",
                               "c_1252.nls");

    // 
    // when assigning the length, do some checking to make sure we don't 
    // overflow.  if we do overflow, assign the length value to 0
    // make sure we don't overflow (USHORT)-1 / sizeof(WCHAR) - sizeof(CHAR))
    // we check this value, since the maximum length of the unicode
    // will include the null character, and be twice it's length
    // or (USHORT) -1.
    //
    NlsString.Buffer = AnsiCpName;
    NlsString.Length = (USHORT) RESET_SIZE_AT_VALUE(strlen(AnsiCpName),
                                                    (USHORT)-1 / sizeof(WCHAR) - sizeof(CHAR));
    NlsString.MaximumLength = (NlsString.Length) ? NlsString.Length + sizeof(CHAR) : 0; 
    AnsiCodepage.MaximumLength = NlsString.MaximumLength * sizeof(WCHAR);     
    AnsiCodepage.Buffer = BlAllocateHeap(AnsiCodepage.MaximumLength);
    if (AnsiCodepage.Buffer == NULL) {
        SlNoMemoryError();
    }
    RtlAnsiStringToUnicodeString(&AnsiCodepage, &NlsString, FALSE);

    NlsName = SlGetIniValue(InfFile,
                            "nls",
                            "OemCodepage",
                            "c_437.nls");

    // 
    // when assigning the length, do some checking to make sure we don't 
    // overflow.  if we do overflow, assign the length value to 0
    // make sure we don't overflow (USHORT)-1 / sizeof(WCHAR) - sizeof(CHAR))
    // we check this value, since the maximum length of the unicode
    // will include the null character, and be twice it's length
    // or (USHORT) -1.
    //
    NlsString.Buffer = NlsName;
    NlsString.Length = (USHORT) RESET_SIZE_AT_VALUE(strlen(NlsName),
                                                    (USHORT)-1 / sizeof(WCHAR) - sizeof(CHAR));
    NlsString.MaximumLength = (NlsString.Length) ? NlsString.Length + sizeof(CHAR) : 0;
    OemCodepage.MaximumLength = NlsString.MaximumLength * sizeof(WCHAR);     
    OemCodepage.Buffer = BlAllocateHeap(OemCodepage.MaximumLength);
    if (OemCodepage.Buffer == NULL) {
        SlNoMemoryError();
    }
    RtlAnsiStringToUnicodeString(&OemCodepage, &NlsString, FALSE);

    NlsName = SlGetIniValue(InfFile,
                            "nls",
                            "UnicodeCasetable",
                            "l_intl.nls");

    // 
    // when assigning the length, do some checking to make sure we don't 
    // overflow.  if we do overflow, assign the length value to 0
    // make sure we don't overflow (USHORT)-1 / sizeof(WCHAR) - sizeof(CHAR))
    // we check this value, since the maximum length of the unicode
    // will include the null character, and be twice it's length
    // or (USHORT) -1.
    //
    NlsString.Buffer = NlsName;
    NlsString.Length = (USHORT) RESET_SIZE_AT_VALUE(strlen(NlsName),
                                                    (USHORT)-1 / sizeof(WCHAR) - sizeof(CHAR));
    NlsString.MaximumLength = (NlsString.Length) ? NlsString.Length + sizeof(CHAR) : 0;
    UnicodeCaseTable.MaximumLength = NlsString.MaximumLength*sizeof(WCHAR);
    UnicodeCaseTable.Buffer = BlAllocateHeap(UnicodeCaseTable.MaximumLength);
    if (UnicodeCaseTable.Buffer == NULL) {
        SlNoMemoryError();
    }
    RtlAnsiStringToUnicodeString(&UnicodeCaseTable, &NlsString, FALSE);

    OemHalFontName = SlGetIniValue(InfFile,
                                   "nls",
                                   "OemHalFont",
                                   "vgaoem.fon");

    // 
    // when assigning the length, do some checking to make sure we don't 
    // overflow.  if we do overflow, assign the length value to 0
    // make sure we don't overflow (USHORT)-1 / sizeof(WCHAR) - sizeof(CHAR))
    // we check this value, since the maximum length of the unicode
    // will include the null character, and be twice it's length
    // or (USHORT) -1.
    //
    NlsString.Buffer = OemHalFontName;
    NlsString.Length = (USHORT) RESET_SIZE_AT_VALUE(strlen(OemHalFontName),
                                                    (USHORT)-1 / sizeof(WCHAR) - sizeof(CHAR));
    NlsString.MaximumLength = (NlsString.Length) ? NlsString.Length + sizeof(CHAR) : 0;
    OemHalFont.MaximumLength = NlsString.MaximumLength*sizeof(WCHAR);
    OemHalFont.Buffer = BlAllocateHeap(OemHalFont.MaximumLength);
    if (OemHalFont.Buffer == NULL) {
        SlNoMemoryError();
    }
    RtlAnsiStringToUnicodeString(&OemHalFont, &NlsString, FALSE);

#ifdef _WANT_MACHINE_IDENTIFICATION

    BiosInfo.Buffer = NULL;
    NlsString.Buffer = SlGetIniValue(InfFile,
                                     "BiosInfo",
                                     "InfName",
                                     NULL);

    if (NlsString.Buffer) {

        // 
        // when assigning the length, do some checking to make sure we don't 
        // overflow.  if we do overflow, assign the length value to 0
        // make sure we don't overflow (USHORT)-1 / sizeof(WCHAR) - sizeof(CHAR))
        // we check this value, since the maximum length of the unicode
        // will include the null character, and be twice it's length
        // or (USHORT) -1.
        //
        NlsString.Length = (USHORT) RESET_SIZE_AT_VALUE(strlen(NlsString.Buffer),
                                                        (USHORT)-1 / sizeof(WCHAR) - sizeof(CHAR));
        NlsString.MaximumLength = (NlsString.Length) ? NlsString.Length + sizeof(CHAR) : 0;
        BiosInfo.MaximumLength = NlsString.MaximumLength*sizeof(WCHAR);
        BiosInfo.Buffer = BlAllocateHeap(BiosInfo.MaximumLength);
        if (BiosInfo.Buffer == NULL) {
            SlNoMemoryError();
        }        
        RtlAnsiStringToUnicodeString(&BiosInfo, &NlsString, FALSE);
    }

 #endif

    //
    // Loading all the miniport will exhaust all free mem <16Mb - ArcSetup dies.
    //
#ifndef ARCI386
    LoadScsiMiniports = (BOOLEAN) (atoi(SlGetIniValue(InfFile,
                                                      "SetupData",
                                                      "ForceScsi",
                                                      "0")) == 1);
#endif

    LoadDiskClass = (BOOLEAN) (atoi(SlGetIniValue(InfFile,
                                                  "setupdata",
                                                  "ForceDiskClass",
                                                  "0")) == 1);

    LoadCdfs = (BOOLEAN) (atoi(SlGetIniValue(InfFile,
                                             "setupdata",
                                             "ForceCdRom",
                                             "0")) == 1);


    BootPath = SlGetIniValue(InfFile,
                             "setupdata",
                             "BootPath",
                             NULL);
    BootDevice = SlGetIniValue(InfFile,
                               "setupdata",
                               "BootDevice",
                               NULL);

    //
    //  Build a linked list with all the P&P hardware ids.
    //  listed on [HardwareIdsDatabase]. This list will be used
    //  during the initialization phase of setupdd.sys
    //
    SetupBlock->HardwareIdDatabase = NULL;

    if( SpSearchINFSection( InfFile, "HardwareIdsDatabase" ) ) {
        ULONG   i;
        PPNP_HARDWARE_ID TempHardwareId;
        PCHAR   p;

        for( i = 0;
             ((p = SlGetKeyName( InfFile, "HardwareIdsDatabase", i )) != NULL);
             i++ ) {
            TempHardwareId = BlAllocateHeap(sizeof(PNP_HARDWARE_ID));

            if (TempHardwareId==NULL) {
                SlNoMemoryError();
            }

            TempHardwareId->Id = p;
            p = SlGetSectionKeyIndex( InfFile,
                                      "HardwareIdsDatabase",
                                      TempHardwareId->Id,
                                      0 );
            TempHardwareId->DriverName = p;
            p = SlGetSectionKeyIndex( InfFile,
                                      "HardwareIdsDatabase",
                                      TempHardwareId->Id,
                                      1 );
            TempHardwareId->ClassGuid = p;

            TempHardwareId->Next = SetupBlock->HardwareIdDatabase;
            SetupBlock->HardwareIdDatabase = TempHardwareId;
        }
    }

    if (BlLoaderBlock->LoadOptions) {
        _strupr(BlLoaderBlock->LoadOptions);

        if ( ( Options = strstr(BlLoaderBlock->LoadOptions,"/MAXMEM") ) != 0 ) {
            MaxMemory = atoi(Options+8);
            SlpTruncateMemory( MaxMemory );
        }
    }
}


VOID
SlGetSetupValuesAfterPrompt(
    IN PSETUP_LOADER_BLOCK SetupBlock
    )
/*++

Routine Description:

    Reads the setup control values out of the given .INI file.  Also supplies
    reasonable defaults for values that don't exist.

    Note : This is called after the user is prompted for F5,
           F6 & F7 behavior.

Arguments:

    SetupBlock - Supplies a pointer to the Setup loader block

Return Value:

    None.  Global variables are initialized to reflect the contents
    of the INI file

--*/
{
    PCHAR MachineName = NULL;

    //
    // Determine which HAL to load.  If the appropriate HAL cannot be
    // determined, or if we are to prompt for an OEM HAL, then set the
    // 'PromptOemHal' flag (may have already been set by the user's
    // keypress).
    //
    if(!PromptOemHal) {
        PromptOemHal = (BOOLEAN) (atoi(SlGetIniValue(InfFile,
                                                     "setupdata",
                                                     "ForceOemHal",
                                                     "0")) == 1);
    }

    if(!PromptOemHal) {
        MachineName = SlDetectHal();
    }

    SetupBlock->ComputerDevice.Files = 0;
    SetupBlock->ComputerDevice.Next = NULL;
    SetupBlock->ComputerDevice.Description = NULL;
    SetupBlock->ComputerDevice.ThirdPartyOptionSelected = FALSE;
    SetupBlock->ComputerDevice.FileTypeBits = 0;
    SetupBlock->ComputerDevice.Files = 0;
    SetupBlock->ComputerDevice.BaseDllName = SlCopyStringA("");

    if(MachineName!=NULL) {
        SetupBlock->ComputerDevice.IdString = SlCopyStringA(MachineName);
        //
        // Map the machine name to a HAL name. If we're doing a remote boot,
        // look in the [Hal] section. Otherwise, look in the [Hal.Load]
        // section. (Local setup has a separate section to minimize the
        // number of HAL binaries that need to be on the boot floppies.)
        //
        HalName = SlGetIniValue(InfFile,
                                BlBootingFromNet ? "Hal" : "Hal.Load",
                                MachineName,
                                NULL);
        HalDescription = SlGetIniValue(InfFile,
                                       "Computer",
                                       MachineName,
                                       NULL);
    }

    if(!(MachineName && HalName && HalDescription)) {
        PromptOemHal = TRUE;
    }

    //
    // If we haven't already been instructed to prompt for an OEM SCSI disk (by
    // the user's keypress), then get this value from the inf file.
    //
    if(!PromptOemScsi) {
        PromptOemScsi = (BOOLEAN) (atoi(SlGetIniValue(InfFile,
                                                      "setupdata",
                                                      "ForceOemScsi",
                                                      "0")) == 1);
    }
}



VOID
BlOutputLoadMessage (
    IN PCHAR DeviceName,
    IN PCHAR FileName,
    IN PTCHAR FileDescription OPTIONAL
    )

/*++

Routine Description:

    This routine outputs a loading message on the status line

Arguments:

    DeviceName - Supplies a pointer to a zero terminated device name.

    FileName - Supplies a pointer to a zero terminated file name.

    FileDescription - Friendly name of the file in question.

Return Value:

    None.

--*/

{
    static int dots = 0;
    TCHAR OutputBuffer[256];
    PTCHAR FormatString;

    UNREFERENCED_PARAMETER( FileName );
    UNREFERENCED_PARAMETER( DeviceName );

    //
    // Construct and output loading file message.
    //

    if (!UseRegularBackground) {
        FormatString = BlFindMessage(SL_FILE_LOAD_MESSAGE);

        if (FileDescription) {
            _stprintf(OutputBuffer,FormatString,FileDescription);
            SlWriteStatusText(OutputBuffer);
        }            
    }

    return;
}



ARC_STATUS
SlLoadDriver(
    IN PTCHAR DriverDescription,
    IN PCHAR DriverName,
    IN ULONG DriverFlags,
    IN BOOLEAN InsertIntoDriverList,
    IN BOOLEAN MigratedDriver,
    IN PCHAR ServiceName OPTIONAL
    )

/*++

Routine Description:

    Attempts to load a driver from the device identified by the global
    variable BootDeviceId.

Arguments:

    DriverDescription - Supplies a friendly description of the driver being
                        loaded.

    DriverName - Supplies the name of the driver.

    DriverFlags - Flags to set in the LDR_DATA_TABLE_ENTRY.

    InsertIntoDriverList - Flag specifying whether this 'driver' should be
                           placed into the BootDriveListHead list (eg, scsiport.sys
                           is not a true driver, and should not be placed in this list)

    MigratedDriver - Flag specifying whther this driver was migrated from an NT system.

    ServiceName - The service name for this driver as it may be different from the driver name.

Return Value:

    ESUCCESS - Driver successfully loaded

--*/

{
    PBOOT_DRIVER_LIST_ENTRY DriverEntry;
    NTSTATUS Status;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry;
    FULL_PATH_SET PathSet;

    if(BlCheckForLoadedDll(DriverName,&DataTableEntry)) {
        return(ESUCCESS);
    }

    DriverEntry = SlpCreateDriverEntry(DriverName, ServiceName);
    if(DriverEntry == NULL) {
        SlNoMemoryError();
        return(ENOMEM);
    }

    if( !WinPEBoot && !MigratedDriver ) {
        SlGetDisk(DriverName);
    }

    PathSet.PathCount = 1;
    PathSet.AliasName = "\\SystemRoot";
    PathSet.PathOffset[0] = '\0';
    PathSet.Source[0].DeviceId = BootDeviceId;
    PathSet.Source[0].DeviceName = BootDevice;

    if (WinPEBoot) {
        static PCHAR Path = NULL;

        if (!Path) {
            CHAR Buffer[256];

            strcpy(Buffer, BootPath);
            strcat(Buffer, "drivers\\");
            Path = SlCopyStringA(Buffer);
        }

        PathSet.Source[0].DirectoryPath = Path;
    } else {
        PathSet.Source[0].DirectoryPath = BootPath;
    }

    Status = BlLoadDeviceDriver(
                &PathSet,
                DriverName,
                DriverDescription,
                DriverFlags,
                &DriverEntry->LdrEntry
                );

    if((Status == ESUCCESS) && InsertIntoDriverList) {
        InsertTailList(&BlLoaderBlock->BootDriverListHead,&DriverEntry->Link);
    }

    return(Status);
}



ARC_STATUS
SlLoadOemDriver(
    IN PCHAR ExportDriver OPTIONAL,
    IN PCHAR DriverName,
    IN PVOID BaseAddress,
    IN PTCHAR LoadMessage
    )
{
    PBOOT_DRIVER_LIST_ENTRY DriverEntry;
    ARC_STATUS Status;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry;
    FULL_PATH_SET PathSet;

    UNREFERENCED_PARAMETER(LoadMessage);

    if(BlCheckForLoadedDll(DriverName,&DataTableEntry)) {
        return(ESUCCESS);
    }

    if(ExportDriver) {
        SlGetDisk(ExportDriver);
    }

    DriverEntry = SlpCreateDriverEntry(DriverName, NULL);
    if (DriverEntry==NULL) {
        return(ENOMEM);
    }

    Status = BlAllocateDataTableEntry(
                DriverName,
                DriverName,
                BaseAddress,
                &DriverEntry->LdrEntry
                );

    if (Status == ESUCCESS) {

        PathSet.PathCount = 1;
        PathSet.AliasName = "\\SystemRoot";
        PathSet.PathOffset[0] = '\0';
        PathSet.Source[0].DeviceId = BootDeviceId;
        PathSet.Source[0].DeviceName = BootDevice;
        PathSet.Source[0].DirectoryPath = BootPath;

        Status = BlScanImportDescriptorTable(
                    &PathSet,
                    DriverEntry->LdrEntry,
                    LoaderBootDriver
                    );

        if(Status == ESUCCESS) {

            InsertTailList(&BlLoaderBlock->BootDriverListHead,&DriverEntry->Link);
        }
    }

    return(Status);
}




PBOOT_DRIVER_LIST_ENTRY
SlpCreateDriverEntry(
    IN PCHAR DriverName,
    IN PCHAR ServiceName OPTIONAL
    )

/*++

Routine Description:

    Allocates and initializes a boot driver list entry structure.

Arguments:

    DriverName - Supplies the name of the driver.
    ServiceName - The service name for this driver as it may be different from the driver name.

Return Value:

    Pointer to the initialized structure.

--*/

{
    PBOOT_DRIVER_LIST_ENTRY DriverEntry;
    ANSI_STRING String;

    DriverEntry = BlAllocateHeap(sizeof(BOOT_DRIVER_LIST_ENTRY));
    if (DriverEntry==NULL) {
        SlNoMemoryError();
        return(NULL);
    }
    // 
    // when assigning the length, do some checking to make sure we don't 
    // overflow.  if we do overflow, assign the length value to 0
    // make sure we don't overflow (USHORT)-1 / sizeof(WCHAR) - sizeof(CHAR))
    // we check this value, since the maximum length of the unicode
    // will include the null character, and be twice it's length
    // or (USHORT) -1.
    //
    String.Buffer = DriverName;
    String.Length = (USHORT) RESET_SIZE_AT_VALUE(strlen(DriverName),
                                                 (USHORT)-1 / sizeof(WCHAR) - sizeof(CHAR));
    String.MaximumLength = (String.Length) ? String.Length + sizeof(CHAR) : 0;
    DriverEntry->FilePath.MaximumLength = String.MaximumLength * sizeof(WCHAR);    
    DriverEntry->FilePath.Buffer = BlAllocateHeap(DriverEntry->FilePath.MaximumLength);
    if (DriverEntry->FilePath.Buffer==NULL) {
        SlNoMemoryError();
        return(NULL);
    }
    RtlAnsiStringToUnicodeString(&DriverEntry->FilePath, &String, FALSE);

    if(ServiceName != NULL && ServiceName[0] != 0) {
        ANSI_STRING ansi;
        UNICODE_STRING unicode;

        RtlInitString(&ansi, ServiceName);
        DriverEntry->RegistryPath.Length = (SL_REGKEY_SERVICES_LEN + ansi.Length) * sizeof(WCHAR);
        DriverEntry->RegistryPath.MaximumLength = DriverEntry->RegistryPath.Length + sizeof(WCHAR);
        DriverEntry->RegistryPath.Buffer = BlAllocateHeap(DriverEntry->RegistryPath.MaximumLength);

        if(NULL == DriverEntry->RegistryPath.Buffer) {
            SlNoMemoryError();
            return(NULL);
        }

        RtlCopyMemory(DriverEntry->RegistryPath.Buffer, SL_REGKEY_SERVICES_W, SL_REGKEY_SERVICES_LEN * sizeof(WCHAR));
        unicode.MaximumLength = ansi.MaximumLength * sizeof(WCHAR);
        unicode.Buffer = DriverEntry->RegistryPath.Buffer + SL_REGKEY_SERVICES_LEN;
        RtlAnsiStringToUnicodeString(&unicode, &ansi, FALSE);
        DriverEntry->RegistryPath.Buffer[DriverEntry->RegistryPath.Length / sizeof(WCHAR)] = 0;
    }

    return(DriverEntry);
}


BOOLEAN
SlGetDisk(
    IN PCHAR Filename
    )

/*++

Routine Description:

    Given a filename, this routine ensures that the correct disk is
    in the drive identified by the global variables BootDevice and
    BootDeviceId. The user may be prompted to change disks.

Arguments:

    Filename - Supplies the name of the file to be loaded.

Return Value:

    TRUE - Disk was successfully loaded.

    FALSE - User has cancelled out of Setup.

--*/

{
    PCHAR DiskNumber;
    PTCHAR DiskName;
    PCHAR DiskTag;
    ULONG FileId;
    CHAR PlatformSpecificSection[128];
    PCHAR  DiskTagSection = NULL;

    //
    // If the media is fixed, the user can't change disks.
    // Just return TRUE indicating that the disk is in the drive.
    //
    if(FixedBootMedia || BlBootingFromNet) {
       return(TRUE);
    }

    //
    // Look up filename to get the disk number. Look in the platform-specific
    // directory first.
    //
    strcpy(PlatformSpecificSection,FilesSectionName);
    strcat(PlatformSpecificSection,PlatformExtension);

#if defined(ELTORITO)
    if (ElToritoCDBoot) {
        // for Cd boot we use the setup media path instead of a boot-media-specific path
        DiskNumber = SlGetSectionKeyIndex(InfFile,PlatformSpecificSection,Filename,0);
    } else {
#endif

    DiskNumber = SlGetSectionKeyIndex(InfFile,PlatformSpecificSection,Filename,6);

#if defined(ELTORITO)
    }
#endif

    if(DiskNumber == NULL) {

#if defined(ELTORITO)
        if (ElToritoCDBoot) {
            // for Cd boot we use the setup media path instead of a boot-media-specific path
            DiskNumber = SlGetSectionKeyIndex(InfFile,FilesSectionName,Filename,0);
        } else {
#endif

        DiskNumber = SlGetSectionKeyIndex(InfFile,FilesSectionName,Filename,6);

#if defined(ELTORITO)
        }
#endif

    }

    if((DiskNumber==NULL) || !(*DiskNumber)) {
        SlFatalError(SL_INF_ENTRY_MISSING,SlCopyStringAT(Filename),FilesSectionName);
        return(FALSE);
    }

    //
    // Look up disk number to get the diskname and tag.
    // Look in platform-specific directory first.
    //
    strcpy(PlatformSpecificSection,MediaSectionName);
    strcat(PlatformSpecificSection,PlatformExtension);

#ifdef UNICODE
    if((DiskName = (PTCHAR)SlGetSectionKeyIndexW(
#else
    if((DiskName = (PTCHAR)SlGetSectionKeyIndex(
#endif
                                        InfFile,
                                        PlatformSpecificSection,
                                        DiskNumber,
                                        0)) != 0 ) {
        DiskTag = SlGetSectionKeyIndex(InfFile,PlatformSpecificSection,DiskNumber,1);
        DiskTagSection = PlatformSpecificSection;
    } else {
#ifdef UNICODE
        if((DiskName = (PTCHAR)SlGetSectionKeyIndexW(
#else
        if((DiskName = (PTCHAR)SlGetSectionKeyIndex(
#endif
                                        InfFile,
                                        MediaSectionName,
                                        DiskNumber,
                                        0)) != 0 ) {
            DiskTag = SlGetSectionKeyIndex(InfFile,MediaSectionName,DiskNumber,1);
            DiskTagSection = MediaSectionName;
        } else {
            SlFatalError(SL_INF_ENTRY_MISSING,SlCopyStringAT(DiskNumber),SlCopyStringAT(MediaSectionName));
            return(FALSE);
        }
    }

    if (!DiskTag) {
        SlFatalError(SL_INF_ENTRY_MISSING,SlCopyStringAT(DiskNumber), SlCopyStringAT(DiskTagSection));
        return FALSE;
    }

    //
    // If this disk is known to be in the drive, don't look again
    //
    if ((LastDiskTag != NULL) && (!strcmp(DiskTag, LastDiskTag))) {
        return(TRUE);
    }

    LastDiskTag = NULL;


    while(1) {

        //
        // Open a new device id onto the disk.
        //
        if(BootDeviceIdValid) {
            ArcClose(BootDeviceId);
            BootDeviceIdValid = FALSE;
        }

        if(ArcOpen(BootDevice,ArcOpenReadOnly,&BootDeviceId) == ESUCCESS) {

            BootDeviceIdValid = TRUE;
            //
            // Check for existence of the disk tag.
            //
            if(BlOpen(BootDeviceId,DiskTag,ArcOpenReadOnly,&FileId) == ESUCCESS) {

                //
                // Disk is in the drive.  Return success.
                // Leave BootDeviceId open onto the device.
                //
                BlClose(FileId);
                LastDiskTag = DiskTag;
                return(TRUE);

            } else {

                //
                // Prompt for the user to change disks.
                //
                ArcClose(BootDeviceId);
                BootDeviceIdValid = FALSE;

                SlPromptForDisk(DiskName, FALSE);

            }
        } else {
            //
            // Can't open device. Prompt for the disk.
            //
            SlPromptForDisk(DiskName, FALSE);
        }
    }
}


PTCHAR
SlCopyString(
    IN PTCHAR String
    )

/*++

Routine Description:

    Copies a tchar string into the loader heap so it can be passed to the
    kernel.

Arguments:

    String - Supplies the string to be copied.

Return Value:

    PTCHAR - pointer into the loader heap where the string was copied to.

--*/

{
    PTCHAR Buffer;

    if (String==NULL) {
        SlNoMemoryError();
        return NULL;
    }
    Buffer = BlAllocateHeap(((ULONG)_tcslen(String)+1)*sizeof(TCHAR));
    if (Buffer==NULL) {
        SlNoMemoryError();
    } else {
        _tcscpy(Buffer, String);
    }

    return(Buffer);
}


PCHAR
SlCopyStringA(
    IN PCSTR String
    )

/*++

Routine Description:

    Copies an ANSI string into the loader heap so it can be passed to the
    kernel.

Arguments:

    String - Supplies the string to be copied.

Return Value:

    PCHAR - pointer into the loader heap where the string was copied to.

--*/

{
    PCHAR Buffer;

    if (String==NULL) {
        SlNoMemoryError();
        return NULL;
    }
    Buffer = BlAllocateHeap((ULONG)strlen(String)+1);
    if (Buffer==NULL) {
        SlNoMemoryError();
    } else {
        strcpy(Buffer, String);
    }

    return(Buffer);
}



ARC_STATUS
SlLoadSection(
    IN PVOID Inf,
    IN PCSTR SectionName,
    IN BOOLEAN IsScsiSection,
    IN BOOLEAN AppendLoadSuffix,
    IN OUT PULONG  StartingInsertIndex OPTIONAL
    )

/*++

Routine Description:

    Enumerates all the drivers in a section and loads them.

Arguments:

    Inf - Supplies a handle to the INF file.

    SectionName - Supplies the name of the section.

    IsScsiSection - Flag specifying whether this is the Scsi.Load section.
                    If so, we create the DETECTED_DEVICE linked list, but
                    don't actually load the drivers.

    AppendLoadSuffix - Indicates whether to append the ".load" suffix to the
                       section name or not.

    StartingInsertIndex - The position index in the linked list at which
                          the device needs to be inserted. The output value
                          contains the next available index.

Return Value:

    ESUCCESS if all drivers were loaded successfully/no errors encountered

--*/

{
    ULONG i;
    CHAR LoadSectionName[100];
    PCHAR DriverFilename;
    PCHAR DriverId;
    PTCHAR DriverDescription;
    PCHAR NoLoadSpec;
    PCHAR p;
    ARC_STATUS Status;
    PDETECTED_DEVICE ScsiDevice;
    SCSI_INSERT_STATUS sis;
    ULONG  InsertIndex;

    ULONG LoadSectionNameLength = (AppendLoadSuffix) ? (ULONG)strlen(SectionName) + 1 : 
                                                       (ULONG)strlen(SectionName) + sizeof(".Load"); // sizeof include \0

    if (sizeof(LoadSectionName) < LoadSectionNameLength ) {
        return ENOMEM;
    }
    strcpy(LoadSectionName, SectionName);
    
    if (AppendLoadSuffix) {
        strcat(LoadSectionName, ".Load");
    }                

    //
    // Use the specified insert index, if its valid
    //
    if (StartingInsertIndex && ((*StartingInsertIndex) != SL_OEM_DEVICE_ORDINAL)) {
        InsertIndex = *StartingInsertIndex;
    } else {
        InsertIndex = 0;
    }        

    i=0;
    do {
        DriverFilename = SlGetSectionLineIndex(Inf,LoadSectionName,i,SIF_FILENAME_INDEX);
        NoLoadSpec = SlGetSectionLineIndex(Inf,LoadSectionName,i,2);

        if(DriverFilename && ((NoLoadSpec == NULL) || _stricmp(NoLoadSpec,"noload"))) {

            if(!IsScsiSection) {
                //
                // We only want to load the drivers if they aren't scsi miniports
                //
                DriverId = SlGetKeyName(Inf,LoadSectionName,i);
#ifdef UNICODE
                DriverDescription = SlGetIniValueW( 
                                            Inf, 
                                            (PSTR)SectionName,
                                            DriverId, 
                                            SlCopyStringAW(DriverId));
#else
                DriverDescription = SlGetIniValue( 
                                            Inf, 
                                            (PSTR)SectionName,
                                            DriverId, 
                                            DriverId);
#endif

                Status = SlLoadDriver(DriverDescription,
                                      DriverFilename,
                                      0,
                                      TRUE,
                                      FALSE,
                                      NULL
                                      );

                if((Status == ENOENT) && IgnoreMissingFiles) {
                    Status = ESUCCESS;
                }
            } else {
                Status = ESUCCESS;
            }

            if (Status == ESUCCESS) {

                if(IsScsiSection) {

                    //
                    // Create a new detected device entry.
                    //
                    if((sis = SlInsertScsiDevice(InsertIndex, &ScsiDevice)) == ScsiInsertError) {
                        return(ENOMEM);
                    }

                    if(sis == ScsiInsertExisting) {
#if DBG
                        //
                        // Sanity check to make sure we're talking about the same driver
                        //
                        if(_stricmp(ScsiDevice->BaseDllName, DriverFilename)) {
                            SlError(400);
                            return EINVAL;
                        }
#endif
                    } else {
                        InsertIndex++;
                        p = SlGetKeyName(Inf,LoadSectionName,i);

                        //
                        // Find the driver description
                        //
                        if(p) {
#ifdef UNICODE
                            DriverDescription = SlGetIniValueW( 
                                                        Inf,
                                                        (PSTR)SectionName,
                                                        p,
                                                        SlCopyStringAW(p));
#else
                            DriverDescription = SlGetIniValue(
                                                        Inf,
                                                        (PSTR)SectionName,
                                                        p,
                                                        p);
#endif                                                        
                        } else {
                            DriverDescription = SlCopyString(BlFindMessage(SL_TEXT_SCSI_UNNAMED));
                        }

                        ScsiDevice->IdString = p ? p : SlCopyStringA("");
                        ScsiDevice->Description = DriverDescription;
                        ScsiDevice->ThirdPartyOptionSelected = FALSE;
                        ScsiDevice->MigratedDriver = FALSE;
                        ScsiDevice->FileTypeBits = 0;
                        ScsiDevice->Files = NULL;
                        ScsiDevice->BaseDllName = DriverFilename;
                    }
                }
            } else {
                SlFriendlyError(
                    Status,
                    DriverFilename,
                    __LINE__,
                    __FILE__
                    );
                return(Status);
            }
        }

        i++;

    } while ( DriverFilename != NULL );

    if (StartingInsertIndex) {
        *StartingInsertIndex = InsertIndex;
    }                

    return(ESUCCESS);

}



VOID
SlpMarkDisks(
    IN BOOLEAN Reboot
    )

/*++

Routine Description:

    This routine ensures that there is not more than one disk with the
    same checksum, a signature of zero, and a valid partition table.

    If it finds a disk with a signature of zero, it searches the rest
    of the list for any other disks with a zero signature and the same
    checksum.  If it finds one, it stamps a unique signature on the
    first disk.

    We also use a heuristic to determine if the disk is 'vacant', and if
    so, we stamp a unique signature on it (unless it's the first one we
    found).

Arguments:

    Reboot - Indicates whether to reboot after stamping signatures

Return Value:

    None.

--*/

{
    PARC_DISK_INFORMATION DiskInfo;
    PLIST_ENTRY     Entry;
    PLIST_ENTRY     CheckEntry;
    PARC_DISK_SIGNATURE DiskSignature;
    PARC_DISK_SIGNATURE CheckDiskSignature;
    ARC_STATUS      Status = ESUCCESS;
    BOOLEAN         SignatureStamped = FALSE;
    ULONG           DiskCount = 0;
    ULONG           DisksStamped = 0;

    DiskInfo = BlLoaderBlock->ArcDiskInformation;
    Entry = DiskInfo->DiskSignatures.Flink;

    while (Entry != &DiskInfo->DiskSignatures) {

        DiskSignature = CONTAINING_RECORD(Entry,ARC_DISK_SIGNATURE,ListEntry);

        //
        // Make sure there are no other disks with this same
        // signature.
        //
        CheckEntry = Entry->Flink;
        while( CheckEntry != &DiskInfo->DiskSignatures ) {

            CheckDiskSignature = CONTAINING_RECORD(CheckEntry,ARC_DISK_SIGNATURE,ListEntry);

            if( (CheckDiskSignature->Signature == DiskSignature->Signature) ) {

                //
                // We found another disk with the same disk signature.
                // Stamp a new signature on the disk.
                //
                Status = SlpStampFTSignature(CheckDiskSignature, TRUE);
                SignatureStamped = TRUE;
                DisksStamped++;

                if (Status != ESUCCESS) {
                    SlError(Status);
                }
            }

            CheckEntry = CheckEntry->Flink;
        }

        //
        // Now look for disk with no signature.
        //
        if (DiskSignature->ValidPartitionTable) {
            if (DiskSignature->Signature == 0) {
                Status = SlpStampFTSignature(DiskSignature, TRUE);
                SignatureStamped = TRUE;
                DisksStamped++;

                if (Status != ESUCCESS) {
                    SlError(Status);
                }
            }                
        } else {
            //
            // See if the disk is vacant.
            //
            if (SlpIsDiskVacant(DiskSignature)) {
                //
                // If disk has the signature then use it otherwise
                // stamp a new signature
                //
                Status = SlpStampFTSignature(DiskSignature,
                                             (BOOLEAN) (DiskSignature->Signature == 0));
                              
                SignatureStamped = TRUE;
                DisksStamped++;

                if (Status != ESUCCESS) {
                    SlError(Status);
                }
            }
        }

        DiskCount++;
        Entry = Entry->Flink;
    }

    //
    // We've just changed the signatures on a disk.  It might be
    // okay to continue with the boot, but may not. Lets not reboot
    // as textmode setup will bugcheck if the signatures
    // are not stamped correctly.
    //
    if( SignatureStamped) {

        if (Reboot) {
            SlFatalError(SIGNATURE_CHANGED);
        } else {
            //
            // Don't bother rescanning the disks if there is only
            // one disk or we just stamped only one disk
            //
            if ((DiskCount > 1) && (DisksStamped > 1)) {
                
                Status = BlGetArcDiskInformation(TRUE);

                if (Status != ESUCCESS) {                    
                    SlFatalError(SIGNATURE_CHANGED);
                }else {
                    //
                    // Reboot if first time signature
                    // stamping failed to update the disks
                    // correctly
                    //
                    SlpMarkDisks(TRUE);
                }
            }
        }
    }
}


BOOLEAN
SlpIsDiskVacant(
    IN PARC_DISK_SIGNATURE DiskSignature
    )

/*++

Routine Description:

    This routine attempts to determine if a disk is 'vacant' by
    checking to see if the first half of its MBR has all bytes set
    to the same value.

Arguments:

    DiskSignature - Supplies a pointer to the existing disk
                    signature structure.

Return Value:

    TRUE  - The disk is vacant.
    FALSE - The disk is not vacant (ie, we can't determine if it
            is vacant using our heuristic)

--*/
{
    UCHAR Partition[100];
    ULONG DiskId;
    ARC_STATUS Status;
    UCHAR SectorBuffer[512+256];
    PUCHAR Sector;
    LARGE_INTEGER SeekValue;
    ULONG Count, i;
    BOOLEAN IsVacant;

    //
    // Open partition0.
    //
    strcpy((PCHAR)Partition, DiskSignature->ArcName);
    strcat((PCHAR)Partition, "partition(0)");
    Status = ArcOpen((PCHAR)Partition, ArcOpenReadOnly, &DiskId);
    if (Status != ESUCCESS) {
        return(FALSE);
    }

    //
    // Read in the first sector
    //
    Sector = ALIGN_BUFFER(SectorBuffer);
    SeekValue.QuadPart = 0;
    Status = ArcSeek(DiskId, &SeekValue, SeekAbsolute);
    if (Status == ESUCCESS) {
        Status = ArcRead(DiskId, Sector, 512, &Count);
    }
    if (Status != ESUCCESS) {
        ArcClose(DiskId);
        return(FALSE);
    }

    //
    // See if 1st 256 bytes are identical
    //
    for(i = 1, IsVacant = TRUE; i<256; i++) {
        if(Sector[i] - *Sector) {
            IsVacant = FALSE;
            break;
        }
    }

    ArcClose(DiskId);

    return(IsVacant);
}



ARC_STATUS
SlpStampFTSignature(
    IN PARC_DISK_SIGNATURE DiskSignature,
    IN BOOLEAN GenerateNewSignature
    )

/*++

Routine Description:

    This routine stamps a given drive with a unique signature.
    It traverses the list of disk signatures to ensure that it
    stamps a signature that is not already present in the
    disk list.  Then it writes the new disk signature to the
    disk and recomputes the checksum.

Arguments:

    DiskSignature - Supplies a pointer to the existing disk
        signature structure. 

    GenerateNewSignature - Indicates whether to generate a new
        signature or use the one in DiskSignature. When TRUE
        this will also disable the check of duplicate signatures. 
        This argument is ignored when the DiskSignature->Signature
        field is 0, since 0 is not a valid signature
                           

Return Value:

    None.

--*/
{
    ULONG NewSignature;
    PLIST_ENTRY ListEntry;
    UCHAR SectorBuffer[SECTOR_SIZE * 2];
    PUCHAR Sector;
    LARGE_INTEGER SeekValue;
    UCHAR Partition[100];
    PARC_DISK_SIGNATURE Signature;
    ULONG DiskId;
    ARC_STATUS Status;
    ULONG i;
    ULONG Sum;
    ULONG Count;
    

    if (GenerateNewSignature || (DiskSignature->Signature == 0)) {
        //
        // Get a reasonably unique seed to start with.
        //
        NewSignature = ArcGetRelativeTime();
        NewSignature = (NewSignature & 0xFFFF) << 16;
        NewSignature += ArcGetRelativeTime();

        //
        // Scan through the list to make sure it's unique.
        //
    ReScan:
        ListEntry = BlLoaderBlock->ArcDiskInformation->DiskSignatures.Flink;
        while (ListEntry != &BlLoaderBlock->ArcDiskInformation->DiskSignatures) {
            Signature = CONTAINING_RECORD(ListEntry,ARC_DISK_SIGNATURE,ListEntry);
            if (Signature->Signature == NewSignature) {
                //
                // Found a duplicate, pick a new number and
                // try again.
                //
                if (++NewSignature == 0) {
                    //
                    // zero signatures are what we're trying to avoid
                    // (like this will ever happen)
                    //
                    NewSignature = 1;
                }
                goto ReScan;
            }
            ListEntry = ListEntry->Flink;
        }
    } else {
        NewSignature = DiskSignature->Signature;
    }        
   

    //
    // Now we have a valid new signature to put on the disk.
    // Read the sector off disk, put the new signature in,
    // write the sector back, and recompute the checksum.
    //
    strcpy((PCHAR)Partition,DiskSignature->ArcName);
    strcat((PCHAR)Partition,"partition(0)");

    Status = ArcOpen((PCHAR)Partition, ArcOpenReadWrite, &DiskId);

    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // Read in the first sector
    //
    Sector = ALIGN_BUFFER_WITH_SIZE(SectorBuffer, SECTOR_SIZE);
    SeekValue.QuadPart = 0;

    Status = ArcSeek(DiskId, &SeekValue, SeekAbsolute);

    if (Status == ESUCCESS) {
        Status = ArcRead(DiskId,Sector,512,&Count);
    }

    if (Status != ESUCCESS) {
        ArcClose(DiskId);
        return(Status);
    }

    //
    // If partition table is not valid then initialize it with BOOT_RECORD_SIGNATURE and
    // fill partition entries with zeros
    //  
    if (((USHORT UNALIGNED *)Sector)[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {
        memset(Sector + (PARTITION_TABLE_OFFSET * 2),
            0,
            SECTOR_SIZE - (PARTITION_TABLE_OFFSET * 2));

        ((USHORT UNALIGNED *)Sector)[BOOT_SIGNATURE_OFFSET] = BOOT_RECORD_SIGNATURE;
    }

    ((ULONG UNALIGNED *)Sector)[PARTITION_TABLE_OFFSET/2-1] = NewSignature;

    Status = ArcSeek(DiskId, &SeekValue, SeekAbsolute);

    if (Status == ESUCCESS) {
        Status = ArcWrite(DiskId,Sector,512,&Count);
    }

    ArcClose(DiskId);

    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // We have successfully written back out the new signature,
    // recompute the checksum.
    //
    DiskSignature->Signature = NewSignature;
    DiskSignature->ValidPartitionTable = TRUE;

    Sum = 0;
    for (i=0;i<128;i++) {
        Sum += ((PULONG)Sector)[i];
    }
    DiskSignature->CheckSum = 0-Sum;

    return(ESUCCESS);
}


VOID
SlCheckOemKeypress(
    IN ULONG WaitTime
    )
{

    ULONG StartTime;
    ULONG EndTime;
    ULONG c;
    PTCHAR StatusText;

    //
    // For no particular reason some machines occasionally leave F7s
    // in their keyboard buffer. Drain them out here.
    //
#ifdef EFI
    //
    // disable EFI watchdog when draining keyboard buffer
    //
    DisableEFIWatchDog();
#endif
    while (ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {
        c = SlGetChar();
        switch (c) {
            case SL_KEY_F5:          // Force OEM HAL prompt
                PromptOemHal = TRUE;
                break;

            case SL_KEY_F6:          // Force OEM SCSI prompt
                PromptOemScsi = TRUE;
                break;

        }

    }
#ifdef EFI
    //
    // reset EFI watchdog
    //
    SetEFIWatchDog(EFI_WATCHDOG_TIMEOUT);
#endif

    //
    // HACK alert:  The oem hal and SCSI stuff doesn't make sense in an RIS
    // environment.  Instead, the administrator should put the oem drivers
    // on the RIS server.  So we don't display the OEM drivers prompt, instead
    // we hide it with some bogus "please wait" text.  We do this instead of
    // just skipping the check altogether so that the user will still have a
    // chance to press F7 to disable ACPI.
    //
    StatusText = BlFindMessage(
                    BlBootingFromNet 
                     ? SL_PLEASE_WAIT 
                     : SL_MSG_PRESS_F5_OR_F6);
    if( StatusText != NULL ) {
        SlWriteStatusText(StatusText);
    }

    StartTime = ArcGetRelativeTime();

    if (WinPEBoot) {
        EndTime = StartTime + WaitTime;
    } else {
        EndTime = StartTime + WaitTime;
    }

    do {
        if(ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {
            //
            // There is a key pending, so see what it is.
            //
            c = SlGetChar();

            switch(c) {    
                case SL_KEY_F4:          // Disable OEM virtual devices.
                    DisableVirtualOemDevices = TRUE;
                    break;
                    
                case SL_KEY_F5:          // Force OEM HAL prompt
                    PromptOemHal = TRUE;
                    break;

                case SL_KEY_F6:          // Force OEM SCSI prompt
                    PromptOemScsi = TRUE;
                    break;

                case SL_KEY_F7:
                    DisableACPI = TRUE;  // Force ACPI disabled
                    break;                        

                case SL_KEY_F8:          // Enable debugger
                    EnableDebugger = TRUE;
                    break;

                case SL_KEY_F10:
                    UseCommandConsole = TRUE;  // User wants to use cmdcons
                    break;
            }

        }

    } while (EndTime > ArcGetRelativeTime());

    //
    // see comment above -- we reset these values back to FALSE in the RIS
    // scenario because they don't make sense
    //
    if (BlBootingFromNet) {
        PromptOemHal = FALSE;
        PromptOemScsi = FALSE;
    } else {
        SlWriteStatusText(TEXT(""));
    }
}

VOID
SlCheckASRKeypress(
    VOID
    )
/*++

Routine Description:

    See if the user is doing an ASR.  If so, see if he's got a floppy
    with asrpnp.sif on it.  We'll ask him to press F5 for this.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ARC_STATUS Status;
    #define     ASR_FILE "asrpnp.sif"
    ULONG       StartTime;
    ULONG       EndTime;
    ULONG       c;
    PTCHAR      StatusText;
    CHAR        FloppyName[80];
    ULONG       FloppyId;
    CHAR        FileName[128];
    PVOID       ASRPNPSifHandle = NULL;
    BOOLEAN     PromptASR = FALSE;
    BOOLEAN     Done = FALSE;
    BOOLEAN     FirstTry = TRUE;

#if defined(EFI)
    //
    // Turn off the EFI Watchdog
    //
    DisableEFIWatchDog();
#endif

    do {
        SlClearClientArea();

        //
        // Drain the keyboard buffer.
        //
        while (ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {
            c = SlGetChar();
        }

        if (FirstTry) {
            StatusText = BlFindMessage(SL_MSG_PRESS_ASR);
            FirstTry = FALSE;
        }
        else {
            StatusText = BlFindMessage(SL_MSG_PREPARING_ASR);
        }


        if( StatusText != NULL ) {
            SlWriteStatusText(StatusText);
        }

        StartTime = ArcGetRelativeTime();
        EndTime = StartTime + 5;

        do {
            if(ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {
                //
                // There is a key pending, so see what it is.
                //
                c = SlGetChar();

                switch(c) {

                    case SL_KEY_F2:          // Force ASR prompt
                        PromptASR = TRUE;
                        Done = TRUE;
                        break;

                    case ASCI_ESC:
                        PromptASR = FALSE;
                        Done = TRUE;
                        break;
                }
            }

        } while( !Done && (EndTime > ArcGetRelativeTime()) );

        SlWriteStatusText(TEXT(""));

        if( PromptASR ) {
            Done = FALSE;

            StatusText = BlFindMessage(SL_MSG_ENTERING_ASR);
            if( StatusText != NULL ) {
              SlWriteStatusText(StatusText);
            }

            //
            // Build the filename we're looking for.
            //
            strcpy( FileName, "\\" );
            strcat( FileName, ASR_FILE );

            //
            // Initialize pointers in loader block.
            //
            BlLoaderBlock->SetupLoaderBlock->ASRPnPSifFile = NULL;
            BlLoaderBlock->SetupLoaderBlock->ASRPnPSifFileLength = 0;
            Status = ESUCCESS;

            //
            // Try checking the installation media for asrpnp.sif
            //
            Status = SlInitIniFile( NULL,
                                    BootDeviceId,
                                    FileName,
                                    &ASRPNPSifHandle,
                                    &BlLoaderBlock->SetupLoaderBlock->ASRPnPSifFile,
                                    &BlLoaderBlock->SetupLoaderBlock->ASRPnPSifFileLength,
                                    &c );

            if (ESUCCESS != Status) {
                //
                // Installation media doesn't contain the ASR files, we're 
                // going to have to prompt for the ASR floppy.
                //
                // Build the path to the floppy.
                //
                if (SlpFindFloppy(0,FloppyName)) {
                    Status = ArcOpen(FloppyName,ArcOpenReadOnly,&FloppyId);

                    //
                    // We found the floppy and opened him.  See if he's
                    // got our file.
                    //
                    if( Status == ESUCCESS ) {
                        ASRPNPSifHandle = NULL;

                        Status = SlInitIniFile( NULL,
                                                FloppyId,
                                                FileName,
                                                &ASRPNPSifHandle,
                                                &BlLoaderBlock->SetupLoaderBlock->ASRPnPSifFile,
                                                &BlLoaderBlock->SetupLoaderBlock->ASRPnPSifFileLength,
                                                &c );

                        ArcClose(FloppyId);
                    }
                }
            }


            //
            // See if we successfully loaded the file off the
            // floppy.
            //

            SlWriteStatusText(TEXT(""));

            if( (Status != ESUCCESS) ||
                (BlLoaderBlock->SetupLoaderBlock->ASRPnPSifFile == NULL) ) {

                //
                // Missed.  Inform the user and we'll try again.
                //
                SlMessageBox(SL_MSG_WARNING_ASR);

            } else if (BlLoaderBlock->SetupLoaderBlock->ASRPnPSifFileLength == 0) {
                //
                // Invalid ASR file: inform user and we'll try again
                //

                StatusText = BlFindMessage(SL_MSG_INVALID_ASRPNP_FILE);

                //
                // First display the ASR insert floppy message
                //
                SlDisplayMessageBox(SL_MSG_WARNING_ASR);
                //
                // Populate status area with the error
                //
                if( StatusText != NULL ) {
                  SlWriteStatusText(StatusText);
                }
                //
                // Now wait for user to hit a key
                //
                SlFlushConsoleBuffer();
                SlGetChar();
                //
                // Clear status just in case ...
                //
                if( StatusText != NULL ) {
                  SlWriteStatusText(TEXT(""));
                }

            } else {
                Done = TRUE;
            }
        }
    } while( PromptASR && !Done );

#if defined(EFI)
    //
    // Turn EFI Watchdog back on
    //
    SetEFIWatchDog(EFI_WATCHDOG_TIMEOUT);
#endif
}


SCSI_INSERT_STATUS
SlInsertScsiDevice(
    IN  ULONG Ordinal,
    OUT PDETECTED_DEVICE *pScsiDevice
    )
/*++

Routine Description:

    This routine

Arguments:

    Ordinal - Supplies the 0-based ordinal of the Scsi device
              to insert (based on order listed in [Scsi.Load]
              section of txtsetup.sif).  If the Scsi device is a third party
              driver, then Ordinal is -1 (SL_OEM_DEVICE_ORDINAL).

    pScsiDevice - Receives a pointer to the inserted DETECTED_DEVICE structure,
                  the existing structure, or NULL.
Return Value:

    ScsiInsertError    - Not enough memory to allocate a new DETECTED_DEVICE.
    ScsiInsertNewEntry - A new entry was inserted into the DETECTED_DEVICE list.
    ScsiInsertExisting - An existing entry was found that matched the specified
                         ordinal, so we returned this entry.

--*/
{
    PDETECTED_DEVICE prev, cur;

    if(Ordinal == SL_OEM_DEVICE_ORDINAL) {
        //
        // This is a third-party driver, so find the end of the linked list
        // (we want to preserve the order in which the user specifies the drivers).
        //
        for(prev=BlLoaderBlock->SetupLoaderBlock->ScsiDevices, cur = NULL;
            prev && prev->Next;
            prev=prev->Next);
    } else {
        //
        // Find the insertion point in the linked list for this driver,
        // based on its ordinal.  (Note that we will insert all supported drivers
        // before any third-party ones, since (ULONG)-1 = maximum unsigned long value)
        //
        for(prev = NULL, cur = BlLoaderBlock->SetupLoaderBlock->ScsiDevices;
            cur && (Ordinal > cur->Ordinal);
            prev = cur, cur = cur->Next);
    }

    if(cur && (cur->Ordinal == Ordinal)) {
        //
        // We found an existing entry for this driver
        //
        *pScsiDevice = cur;
        return ScsiInsertExisting;
    }

    if((*pScsiDevice = BlAllocateHeap(sizeof(DETECTED_DEVICE))) == 0) {
        return ScsiInsertError;
    }

    (*pScsiDevice)->Next = cur;
    if(prev) {
        prev->Next = *pScsiDevice;
    } else {
        BlLoaderBlock->SetupLoaderBlock->ScsiDevices = *pScsiDevice;
    }

    (*pScsiDevice)->Ordinal = Ordinal;

    return ScsiInsertNewEntry;
}


ARC_STATUS
SlLoadPnpDriversSection(
    IN PVOID Inf,
    IN PCHAR SectionName,
    IN OUT PDETECTED_DEVICE* DetectedDeviceList OPTIONAL
    )

/*++

Routine Description:

    Enumerates all pnp drivers listed in [<section name>.Load], loads them, and puts
    a list with all the the drivers loaded, in the setup loader block.

Arguments:

    Inf - Supplies a handle to the INF file.

    SectionName - Name of the section in the inf file that contains the list of
                  drivers to be loaded.

    DetectedDeviceList - Address of the variable in Setup loader block that will contain
                         the list of drivers loaded. If this argument is NULL, then the list of
                         loaded devices will not be created.

Return Value:

    ESUCCESS if all drivers were loaded successfully/no errors encountered

--*/

{
    ULONG i;
    CHAR LoadSectionName[100];
    PCHAR DriverFilename;
    PCHAR DriverId;
    PTCHAR DriverDescription;
    PCHAR NoLoadSpec;
    ARC_STATUS Status;
    PDETECTED_DEVICE TempDevice;

    sprintf(LoadSectionName, "%s.Load",SectionName);

    i=0;
    do {
        DriverFilename = SlGetSectionLineIndex(Inf,LoadSectionName,i,SIF_FILENAME_INDEX);
        NoLoadSpec = SlGetSectionLineIndex(Inf,LoadSectionName,i,2);

        if(DriverFilename && ((NoLoadSpec == NULL) || _stricmp(NoL