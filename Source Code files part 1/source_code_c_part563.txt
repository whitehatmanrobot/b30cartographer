  CRImportSitePtr s,
                 IBindHost * bh,
                 CRGeometry   *pGeoStandIn,
                 CRGeometry  **ppGeometry,
                 CREvent  **ppEvent,
                 CRNumber **ppProgress,
                 CRNumber **size)
{
    Assert (relUrl);

    // Needs to be outside the try block - must not throw exception

    URLCombineAndCanonicalizeOLESTR canonURL(baseUrl,
                                             relUrl);

    DWORD ret = 0;

    APIPRECODE;

    Bvr constbvr = ImportSwitcherBvr(pGeoStandIn?pGeoStandIn:ConstBvr(emptyGeometry),
                                     pGeoStandIn?true:false);

    if (ppGeometry)
        *ppGeometry = (CRGeometryPtr) constbvr;

    IImportSite* pIIS=NULL;
    pIIS = NEW ImportXSite(canonURL.GetURL(),
                           s,
                           bh,
                           pGeoStandIn?true:false,
                           constbvr,
                           NULL,
                           NULL);


    __try {

        //import URL
        SubmitImport(pIIS,
                     ppEvent,
                     ppProgress,
                     size);

        ret = pIIS->GetImportId();

    } __finally {

        RELEASE(pIIS);
    }

    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(DWORD)                     
CRImportGeometryWrapped(LPCWSTR baseUrl,
     LPCWSTR relUrl,
     CRImportSitePtr s,
     IBindHost * bh,
     CRGeometry   *pGeoStandIn,
     CRGeometry  **ppGeometry,
     CREvent  **ppEvent,
     CRNumber **ppProgress,
     CRNumber **size,
     LONG wrapType,
     double originX,
     double originY,
     double originZ,
     double zAxisX,
     double zAxisY,
     double zAxisZ,
     double yAxisX,
     double yAxisY,
     double yAxisZ,
     double texOriginX,
     double texOriginY,
     double texScaleX,
     double texScaleY,
     DWORD flags)
{
    Assert (relUrl);

    TextureWrapInfo wrapInfo;
    wrapInfo.type = wrapType;
    wrapInfo.origin.x = originX;
    wrapInfo.origin.y = originY;
    wrapInfo.origin.z = originZ;
    wrapInfo.z.x = zAxisX;
    wrapInfo.z.y = zAxisY;
    wrapInfo.z.z = zAxisZ;
    wrapInfo.y.x = yAxisX;
    wrapInfo.y.y = yAxisY;
    wrapInfo.y.z = yAxisZ;
    wrapInfo.texOrigin.x = texOriginX;
    wrapInfo.texOrigin.y = texOriginY;
    wrapInfo.texScale.x = texScaleX;
    wrapInfo.texScale.y = texScaleY;
    wrapInfo.relative = (flags & 0x1) ? true : false;
    wrapInfo.wrapU = (flags & 0x2) ? true : false;
    wrapInfo.wrapV = (flags & 0x4) ? true : false;

    // This is a total hack for TxD for backwards compatibility.  If
    // this flag is set then we will ignore the wrap
    bool bUseWrap = (flags & 0x80000000) ? false : true;

    // Needs to be outside the try block - must not throw exception

    URLCombineAndCanonicalizeOLESTR canonURL(baseUrl,
                                             relUrl);

    DWORD ret = 0;

    APIPRECODE;

    Bvr constbvr = ImportSwitcherBvr(pGeoStandIn?pGeoStandIn:ConstBvr(emptyGeometry),
                                     pGeoStandIn?true:false);

    if (ppGeometry)
        *ppGeometry = (CRGeometryPtr) constbvr;

    IImportSite* pIIS=NULL;
    pIIS = NEW ImportXSite(canonURL.GetURL(),
                           s,
                           bh,
                           pGeoStandIn?true:false,
                           constbvr,
                           NULL,
                           NULL,
                           bUseWrap,
                           bUseWrap ? &wrapInfo : NULL,
                           false);


    __try {

        //import URL
        SubmitImport(pIIS,
                     ppEvent,
                     ppProgress,
                     size);

        ret = pIIS->GetImportId();

    } __finally {

        RELEASE(pIIS);
    }

    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRImagePtr)
CRImportDirectDrawSurface(IUnknown *dds,
                          CREvent *updateEvent)
{
    // TODO: ddalal, gregsc.  use updateEvent

    // ISSUE: is this called every frame ?
    // if so, how do we make sure the resources are
    // correctly released ?

    Assert (dds);

    CRImagePtr ret = NULL;

    IDirectDrawSurface *idds = NULL;

    APIPRECODE;

    HRESULT hr;

    hr = dds->QueryInterface(IID_IDirectDrawSurface, (void **)&idds);

    if(SUCCEEDED(hr)) {
        ret = (CRImagePtr) ConstBvr(ConstructDirectDrawSurfaceImage(idds));
        // QUESTION: when is ConstructDirectDrawSurfaceImage called ?
        // if it's not called till later, this release might
        // be premature, because we're expecting that
        // function to addref it's reference to idds
    } else {
        DASetLastError(hr,NULL);
    }

    APIPOSTCODE;

    // guaranteed to fall thru
    RELEASE(idds);

    return ret;
}



/*****************************************************************************
This procedure imports a D3DRM Visual.  The only type of visual supported is
an IDirect3DRMMeshBuilder3.
*****************************************************************************/

CRSTDAPI_(CRGeometryPtr)
CRImportDirect3DRMVisual(IUnknown *visual)
{
    Assert (visual);

    CRGeometryPtr ret = NULL;

    APIPRECODE;

    IDirect3DRMMeshBuilder3 *mbuilder = NULL;
    HRESULT hr;

    // We only recognize IDirect3DRMMeshBuilder3's.

    hr = visual->QueryInterface
        (IID_IDirect3DRMMeshBuilder3, (void **)&mbuilder);

    if (FAILED(hr))
        RaiseException_UserError(E_INVALIDARG, 0);

    ret = (CRGeometryPtr) ConstBvr(NEW RM3MBuilderGeo (mbuilder, true));

    mbuilder->Release();

    APIPOSTCODE;

    return ret;
}


/*****************************************************************************
This procedure imports a D3DRM Visual.  The only type of visual supported is
an IDirect3DRMMeshBuilder3.
*****************************************************************************/

CRSTDAPI_(CRGeometryPtr)
CRImportDirect3DRMVisualWrapped(
    IUnknown *visual,
    LONG wrapType,
    double originX,
    double originY,
    double originZ,
    double zAxisX,
    double zAxisY,
    double zAxisZ,
    double yAxisX,
    double yAxisY,
    double yAxisZ,
    double texOriginX,
    double texOriginY,
    double texScaleX,
    double texScaleY,
    DWORD flags)
{
    Assert (visual);

    TextureWrapInfo wrapInfo;
    wrapInfo.type = wrapType;
    wrapInfo.origin.x = originX;
    wrapInfo.origin.y = originY;
    wrapInfo.origin.z = originZ;
    wrapInfo.z.x = zAxisX;
    wrapInfo.z.y = zAxisY;
    wrapInfo.z.z = zAxisZ;
    wrapInfo.y.x = yAxisX;
    wrapInfo.y.y = yAxisY;
    wrapInfo.y.z = yAxisZ;
    wrapInfo.texOrigin.x = texOriginX;
    wrapInfo.texOrigin.y = texOriginY;
    wrapInfo.texScale.x = texScaleX;
    wrapInfo.texScale.y = texScaleY;
    wrapInfo.relative = (flags & 0x1) ? true : false;
    wrapInfo.wrapU = (flags & 0x2) ? true : false;
    wrapInfo.wrapV = (flags & 0x4) ? true : false;
    
    CRGeometryPtr ret = NULL;

    APIPRECODE;

    IDirect3DRMMeshBuilder3 *mbuilder = NULL;
    HRESULT hr;

    // We only recognize IDirect3DRMMeshBuilder3's.

    hr = visual->QueryInterface
        (IID_IDirect3DRMMeshBuilder3, (void **)&mbuilder);

    if (FAILED(hr))
        RaiseException_UserError(E_INVALIDARG, 0);

    RM3MBuilderGeo *builder = NEW RM3MBuilderGeo (mbuilder, true);
    if (builder) {
        builder->TextureWrap(&wrapInfo);
    }

    ret = (CRGeometryPtr) ConstBvr(builder);

    mbuilder->Release();

    APIPOSTCODE;

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\crspline.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "apiprims.h"
#include "backend/values.h"
#include "backend/gc.h"
#include "conv.h"
#include "appelles\bspline.h"

CRSTDAPI_(CRBvrPtr)
CRBSpline(int degree,
          long numKnots,
          CRNumberPtr knots[],
          long numPts,
          CRBvrPtr ctrlPts[],
          long numWts,
          CRNumberPtr weights[],
          CRNumberPtr evaluator,
          CR_BVR_TYPEID tid)
{
    Assert(knots);
    Assert(ctrlPts);
    Assert(evaluator);
    Assert(numKnots == numPts + degree - 1);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    DXMTypeInfo tinfo = GetTypeInfoFromTypeId(tid);

    if (tinfo) {
        // Need to allocate the arrays on the system heap
        Bvr * bvrknots = (Bvr *) StoreAllocate(GetSystemHeap(), numKnots * sizeof(Bvr));
        Bvr * bvrctrlPts = (Bvr *) StoreAllocate(GetSystemHeap(), numPts * sizeof(Bvr));
        Bvr * bvrwts = weights
            ?((Bvr *) StoreAllocate(GetSystemHeap(), numWts * sizeof(Bvr)))
            : NULL;

        memcpy(bvrknots, knots, numKnots * sizeof(Bvr));
        memcpy(bvrctrlPts, ctrlPts, numPts * sizeof(Bvr));
        if (weights) {
            memcpy(bvrwts, weights, numWts * sizeof(Bvr));
        }

        ret = (CRBvrPtr) ConstructBSplineBvr(degree,
                                             numPts,
                                             (Bvr *) bvrknots,
                                             (Bvr *) bvrctrlPts,
                                             (Bvr *) bvrwts,
                                             evaluator,
                                             tinfo);
    } else {
        DASetLastError(E_INVALIDARG,NULL);
    }
    
    APIPOSTCODE;

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\crview.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _CRVIEW_H
#define _CRVIEW_H

#include "server/view.h"

#endif /* _CRVIEW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\crconv.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "conv.h"

double
ExtractNum(Bvr num)
{
    ConstParam cp(true);
    AxAValue v = num->GetConst(cp);

    if (!v)
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_NUM_EXTRACT) ;

    return ValNumber(v);
}

WideString
ExtractString(Bvr str)
{
    ConstParam cp(true);
    AxAValue v = str->GetConst(cp);

    if (!v)
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_STR_EXTRACT);

    return ValString(v) ;
}

bool
ExtractBool(Bvr b)
{
    ConstParam cp(true);
    AxAValue v = b->GetConst(cp);

    if (!v)
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_BOOL_EXTRACT);

    return BooleanTrue(v)?TRUE:FALSE;
}

AxAValue
GetConstVal(Bvr b)
{
    ConstParam cp;
    AxAValue v = b->GetConst(cp);
    if (v == NULL)
        RaiseException_UserError (E_FAIL, IDS_ERR_SRV_CONST_REQUIRED);

    return v;
}

#if DEVELOPER_DEBUG
void CheckBvrParam(void * bvr)
{ Assert(bvr); }
void CheckPtrParam(void * ptr)
{ Assert(ptr); }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\ctx.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _CRCONTEXT_H
#define _CRCONTEXT_H

#include "server/context.h"

#endif /* _CRCONTEXT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

// Disable warning for exception unwind
#pragma warning(disable:4530)

#include "include/headers.h"
#include "backend/bvr.h"
#include "dartapi.h"
#include "dartapipriv.h"
#include "privinc/server.h"
#include "privinc/mutex.h"
#include "privinc/comutil.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\crview_api.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "apiprims.h"
#include "ctx.h"
#include "crview.h"
#include "privinc/resource.h"
#include "privinc/util.h"
#include "privinc/htimer.h"
#include "privinc/viewport.h"
#include "crimport.h"
#include "privinc/dddevice.h"
#include "privinc/d3dutil.h"    // For GetD3DRM1()

DeclareTag(tagCRView, "CRView", "CRView functions");

CRSTDAPI_(CRViewPtr)
CRCreateView()
{
    CRViewPtr vp = NULL;

    APIVIEWPRECODE;

    vp = NEW CRView;

    APIVIEWPOSTCODE;

    return vp;
}

CRSTDAPI_(void)
CRDestroyView(CRViewPtr v)
{
    APIVIEWPRECODE;

    v->Release();

    APIVIEWPOSTCODE;
}

CRSTDAPI_(double)
CRGetSimulationTime(CRViewPtr v)
{
    double ret = 0;

    APIVIEWPRECODE_RENDERLOCK(v);
    ret = v->GetCurrentSimulationTime();
    APIVIEWPOSTCODE_RENDERLOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRTick(CRViewPtr v, double simTime, bool * needToRender)
{
    TraceTag((tagCRView,
              "CRTick(%lx,%lg)",v,simTime));

    bool ret = false;
    if (needToRender)
        *needToRender = false;

    APIVIEWPRECODE_RENDERLOCK(v);
    // if (!v->Paused()) 
    {
        bool b = v->Tick(simTime);
        if (needToRender)
            *needToRender = b;
        ret = true;
    }
    APIVIEWPOSTCODE_RENDERLOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRRender(CRViewPtr v)
{
    TraceTag((tagCRView,
              "CRRender(%lx)",v));

    bool ret = false;

    APIVIEWPRECODE_RENDERLOCK(v);
#if 0
#if _DEBUGMEM
    _CrtMemState diff, oldState, newState;
    _CrtMemCheckpoint(&oldState);
#endif
#endif

    v->RenderImage();

#if 0
#if _DEBUGMEM
    _CrtMemCheckpoint(&newState);
    _CrtMemDifference(&diff, &oldState, &newState);
    _CrtMemDumpStatistics(&diff);
    _CrtMemDumpAllObjectsSince(&oldState);
#endif
#endif
    ret = true;
    APIVIEWPOSTCODE_RENDERLOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRAddBvrToRun(CRViewPtr v, CRBvrPtr bvr, bool continueTimeline, long * pId)
{
    TraceTag((tagCRView,
              "CRAddBvrToRun(%lx,%lx)", v, bvr));

    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    long l = v->AddBvrToRun(bvr, continueTimeline);
    if (pId) *pId = l;
    ret = true;
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRRemoveRunningBvr(CRViewPtr v, long id)
{
    TraceTag((tagCRView,
              "CRRemoveRunningBvr(%lx,%d)", v, id));

    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    v->RemoveRunningBvr(id);
    ret = true;
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRStartModel(CRViewPtr v,
             CRImagePtr img,
             CRSoundPtr snd,
             double startTime,
             DWORD dwFlags,
             bool * pbPending)
{
    TraceTag((tagCRView,
              "CRStartModel(%lx,%lx,%lx,%lg,%d)",
              v, img, snd, startTime,dwFlags));

    bool ret = false;
    bool bPending = false;

    APIVIEWPRECODE_RENDERLOCK(v);
    v->StartModel(img, snd, startTime, dwFlags, bPending);
    ret = true;
    APIVIEWPOSTCODE_RENDERLOCK(v);

    // Do this outside of the renderlock
    if (ret && bPending && !(dwFlags & CRAsyncFlag)) {
        v->WaitForImports();
        bPending = false;
    }

    if (pbPending) *pbPending = bPending;

    return ret;
}

CRSTDAPI_(bool)
CRStopModel(CRViewPtr v)
{
    TraceTag((tagCRView,
              "CRStopModel(%lx)", v));

    bool ret = false;

    APIVIEWPRECODE_RENDERLOCK(v);
    v->StopModel();
    ret = true;
    APIVIEWPOSTCODE_RENDERLOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRPauseModel(CRViewPtr v)
{
    TraceTag((tagCRView, "CRPauseModel(%lx)", v));

    bool ret = false;

    APIVIEWPRECODE_RENDERLOCK(v);
    v->PauseModel();
    ret = true;
    APIVIEWPOSTCODE_RENDERLOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRResumeModel(CRViewPtr v)
{
    TraceTag((tagCRView, "CRResumeModel(%lx)", v));

    bool ret = false;

    APIVIEWPRECODE_RENDERLOCK(v);
    if (v->Paused()) {
        v->ResumeModel();
    }

    ret = true;
    APIVIEWPOSTCODE_RENDERLOCK(v);

    return ret;
}

CRSTDAPI_(HWND)
CRGetWindow(CRViewPtr v)
{
    TraceTag((tagCRView,
              "CRGetWindow(%lx)", v));

    HWND ret = NULL;

    APIVIEWPRECODE_LOCK(v);
    ret = v->GetWindow();
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRSetWindow(CRViewPtr v, HWND hwnd)
{
    TraceTag((tagCRView,
              "CRSetWindow(%lx,%lx)",
              v,hwnd));

    if (!IsWindow(hwnd) && hwnd != NULL) {
        DASetLastError(E_INVALIDARG,IDS_ERR_INVALIDARG) ;
        return false;
    }

    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    v->SetWindow(hwnd);
    ret = true;
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(IUnknown *)
CRGetDirectDrawSurface(CRViewPtr v)
{
    IUnknown * ret = NULL;

    APIVIEWPRECODE_LOCK(v);
    ret = v->GetDDSurf();
    if (ret)
        ret->AddRef();
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRSetDirectDrawSurface(CRViewPtr v, IUnknown *ddsurf)
{
    bool ret = false;

    DAComPtr<IDirectDrawSurface> surf;

    APIVIEWPRECODE_LOCK(v);

    if (ddsurf != NULL) {
        ddsurf->QueryInterface(IID_IDirectDrawSurface, (void **) &surf);
    }

    if (!v->SetDDSurf(surf))
        RaiseException_UserError(E_INVALIDARG, 0);

    ret = true;

    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(HDC)
CRGetDC(CRViewPtr v)
{
    HDC ret = NULL;

    APIVIEWPRECODE_LOCK(v);
    ret = v->GetHDC();
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRSetDC(CRViewPtr v, HDC dc)
{
    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    ret = v->SetHDC(dc);
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRGetCompositeDirectlyToTarget(CRViewPtr v)
{
    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    ret = v->GetCompositeDirectlyToTarget();
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRSetCompositeDirectlyToTarget(CRViewPtr v, bool b)
{
    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    v->SetCompositeDirectlyToTarget(b);
    ret = true;
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRSetViewport
//
//  Synopsis:   Called to set the window size relative
//              to the rendering target.  This rectangle
//              defines our coordinate space.
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CRSetViewport(CRViewPtr v,
              long x,
              long y,
              long w,
              long h)
{
    TraceTag((tagCRView,
              "CRSetViewport(%lx,%ld,%ld,%ld,%ld)",
              v, x,y,w,h));

    bool ret = false;

    APIVIEWPRECODE_LOCK(v);

    // Add the event to the queue so the viewupperright gets updated
    v->GetEventQ().SizeChanged(true);

    // Indicate view needs to be repainted
    v->Repaint() ;

    v->SetViewport(x, y, x+w, y+h);

    ret = true;

    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRSetClipRect
//
//  Synopsis:   Relative to the viewport, clip rendering
//              to this rectangle.
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CRSetClipRect(CRViewPtr v,
              long x,
              long y,
              long w,
              long h)
{
    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    v->SetClipRect(x, y, x+w, y+h);
    ret = true;
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRRepaint
//
//  Synopsis:   Called when a window needs to be repainted
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CRRepaint(CRViewPtr v,
          long x,
          long y,
          long w,
          long h)
{
    TraceTag((tagCRView,
              "CRRepaint(%lx,%ld,%ld,%ld,%ld)",
              v, x,y,w,h));

    bool ret = false;

    APIVIEWPRECODE_LOCK(v);

    v->SetInvalid(x, y, x+w, y+h);

    // Indicate view needs to be repainted
    v->Repaint() ;

    ret = true;

    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRGetSite
//
//  Synopsis:   Gets an view site.
//
//--------------------------------------------------------------------------

CRSTDAPI_(CRViewSitePtr)
CRGetSite(CRViewPtr v)
{
    TraceTag((tagCRView,
              "CRGetViewSite(%lx)",
              v));

    CRViewSitePtr ret = NULL;

    APIVIEWPRECODE_LOCK(v);
    ret = v->GetSite();
    if (ret)
        ret->AddRef();
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRSetSite
//
//  Synopsis:   Sets an view site.
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CRSetSite(CRViewPtr v, CRViewSitePtr s)
{
    TraceTag((tagCRView,
              "CRSetSite(%lx,%lx)",
              v, s));

    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    v->SetSite(s);
    ret = true;
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRGetServiceProvider
//
//  Synopsis:   Gets a view's ServiceProvider.
//
//--------------------------------------------------------------------------

CRSTDAPI_(IServiceProvider *)
CRGetServiceProvider(CRViewPtr v)
{
    TraceTag((tagCRView,
              "CRGetServiceProvider(%lx)",
              v));

    IServiceProvider * ret = NULL;

    APIVIEWPRECODE_LOCK(v);
    ret = v->GetServiceProvider();
    if (ret)
        ret->AddRef();
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRSetServiceProvider
//
//  Synopsis:   Sets a view's ServiceProvider.
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CRSetServiceProvider(CRViewPtr v, IServiceProvider * s)
{
    TraceTag((tagCRView,
              "CRSetServiceProvider(%lx,%lx)",
              v, s));

    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    v->SetServiceProvider(s);
    ret = true;
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(DWORD)
CRQueryHitPoint(CRViewPtr v,
                DWORD dwAspect,
                LPCRECT prcBounds,
                POINT   ptLoc,
                long lCloseHint)
{
    TraceTag((tagCRView,
              "CRQueryHitPoint(%#lx,%d, %d)",
              v, ptLoc.x, ptLoc.y));

    DWORD ret = HITRESULT_OUTSIDE;

    APIVIEWPRECODE_LOCK(v);

    bool bHit = v->QueryHitPoint(dwAspect,
                                 prcBounds,
                                 ptLoc,
                                 lCloseHint);

    ret = bHit ? HITRESULT_HIT : HITRESULT_OUTSIDE;

    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(long)
CRQueryHitPointEx(CRViewPtr v,
                  long s,
                  DWORD_PTR *cookies,
                  double *points,
                  LPCRECT prcBounds,
                  POINT   ptLoc)
{
    TraceTag((tagCRView,
              "CRQueryHitPointEx(%#lx,%d, %d)",
              v, ptLoc.x, ptLoc.y));

    if (s<1 || !cookies || !points) {
        DASetLastError(E_INVALIDARG,IDS_ERR_INVALIDARG) ;
        return false;
    }

    long ret = 0;

    APIVIEWPRECODE_LOCK(v);
    ret = v->QueryHitPointEx(s, cookies, points, prcBounds, ptLoc);
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}


CRSTDAPI_(long)
CRGetInvalidatedRects(CRViewPtr v,
                      DWORD flags,
                      long  size,
                      RECT *pRects)
{
    long ret = 0;

    APIVIEWPRECODE_LOCK(v);
    ret = v->GetInvalidatedRects(flags, size, pRects);
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

//----------------------------------------------------------------------------
// This method fetches the DirectDraw and Direct3DRM interfaces that
// correspond to the view.
//----------------------------------------------------------------------------

CRSTDAPI_(bool)
CRGetDDD3DRM(CRViewPtr v,
             IUnknown **directDraw,
             IUnknown **d3drm)
{
    bool ret = false;

    APIVIEWPRECODE_LOCK(v);

    if (directDraw)
    {
        *directDraw = NULL;
        DirectDrawViewport *imgdev = v->GetImageDev();
        if (imgdev) {
            IDirectDraw2 *lpDD2 = imgdev->DirectDraw2();
            if( lpDD2 ) {
                // no need to check hr.  directDraw NULL on failure
                lpDD2->QueryInterface(IID_IUnknown, (void **)directDraw);
            }
        }

        TraceTag((tagDirectDrawObject, "CRGetDDD3DRM: ddraw iunk %x", *directDraw));
    }

    if (d3drm)
    {
        *d3drm = GetD3DRM1();
        if (*d3drm)
            (*d3drm)->AddRef();
    }

    ret = true;

    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

//----------------------------------------------------------------------------
// This method fetches the D3D RM device associated with the view, and a
// sequence number.  This number is incremented
//----------------------------------------------------------------------------

CRSTDAPI_(bool)
CRGetRMDevice(CRViewPtr v,
              IUnknown **d3drmDevice,
              DWORD *seqNum)
{
    bool result = false;
    bool error  = false;

    *d3drmDevice = NULL;

    APIVIEWPRECODE_LOCK(v);
    
    DirectDrawViewport *viewport = v->GetImageDev();

    if(!v->IsTargetPackageValid()) 
    {
        DASetLastError(DAERR_VIEW_TARGET_NOT_SET,IDS_ERR_SRV_VIEW_TARGET_NOT_SET);
        error  = true;
    }
   

    if (!error && viewport)
    {
        GeomRenderer *geomRenderer = viewport->MainGeomRenderer();

        if (geomRenderer)
        {
            geomRenderer->GetRMDevice (d3drmDevice, seqNum);
            result = true;
        }
    }

    APIVIEWPOSTCODE_LOCK(v);

    return result;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRPutPreference
//
//  Synopsis:   Set a preference property
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CRPutPreference(CRViewPtr v,
                LPWSTR preferenceName,
                VARIANT value)
{
    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    ret = v->PutPreference(preferenceName, value);
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRGetPreference(CRViewPtr v,
                LPWSTR preferenceName,
                VARIANT * value)
{
    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    ret = v->GetPreference(preferenceName, value);
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRPropagate(CRViewPtr v)
{
    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    v->Propagate();
    ret = true;
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\switchers.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "apiprims.h"
#include "backend/values.h"
#include "backend/gc.h"
#include "conv.h"
#include "privinc/bbox3i.h"
#include "privinc/colori.h"
#include "privinc/vec2i.h"
#include "privinc/vec3i.h"
#include "privinc/xform2i.h"
#include "privinc/xformi.h"

CRSTDAPI_(CRBvrPtr)
CRModifiableBvr(CRBvrPtr orig, DWORD dwFlags)
{
    Assert(orig);

    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) ::SwitcherBvr(orig, dwFlags);
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRBvrPtr)
CRGetModifiableBvr(CRBvrPtr bvr)
{
    Assert(bvr);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) GetCurSwitcherBvr(bvr);
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRIsModifiableBvr(CRBvrPtr bvr)
{
    Assert (bvr);
    
    bool ret = false;
    
    APIPRECODE;
    ret = IsSwitcher(bvr) && !IsImport(bvr);
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(bool)
CRSwitchTo(CRBvrPtr bvr,
           CRBvrPtr switchTo,
           bool bOverrideFlags,
           DWORD dwFlags,
           double gTime)
{
    Assert (bvr);
    
    bool ret = false;
    
    APIPRECODE;
    if (!IsSwitcher(bvr) || IsImport(bvr)) {
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_BAD_SWITCH);
    }

    SwitchTo(bvr, switchTo, bOverrideFlags, dwFlags, gTime);

    ret = true;
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRNumberPtr)
CRModifiableNumber(double initVal)
{
    CRNumberPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRNumberPtr) SwitcherBvr(UnsharedConstBvr(NEW AxANumber(initVal)));
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRSwitchToNumber(CRNumberPtr bvr, double numToSwitchTo)
{
    Assert (bvr);
    
    bool ret = false;
    
    APIPRECODE;
    SwitchToNumbers(bvr, &numToSwitchTo);
    ret = true;
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRStringPtr)
CRModifiableString(LPWSTR initVal)
{
    CRStringPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRStringPtr) SwitcherBvr(UnsharedConstBvr(NEW AxAString(initVal)));
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRSwitchToString(CRStringPtr bvr, LPWSTR strToSwitchTo)
{
    Assert (bvr);
    
    bool ret = false;
    
    APIPRECODE;
    SwitchTo(bvr, LPWSTRToStrBvr(strToSwitchTo), false, SW_DEFAULT);
    ret = true;
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(bool)
CRSwitchToBool(CRBooleanPtr bvr, bool b)
{
    Assert (bvr);
    
    bool ret = false;
    
    APIPRECODE;
    SwitchTo(bvr, BoolToBvr(b), false, SW_DEFAULT);
    ret = true;
    APIPOSTCODE;

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\misc.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "apiprims.h"
#include "crcb.h"
#include "conv.h"
#include "backend/values.h"
#include "backend/gc.h"
#include "backend/jaxaimpl.h"
#include "backend/timeln.h"
#include "version.h"

CRSTDAPI_(double)
CRGetConstDuration(CREventPtr event)
{
    double retval = -1;
    
    APIPRECODE;

    Bvr d = event->GetTimer();
    AxAValue v;
    ConstParam cp;
    if (d && (v = d->GetConst(cp))) {
        retval = ValNumber(v);
    } else {
        DASetLastError(E_FAIL,IDS_ERR_BE_NON_CONST_DURATION);
    }

    APIPOSTCODE;

    return retval;
}

LPCWSTR _varCRVersionString = NULL;

CRSTDAPI_(LPCWSTR) CRVersionString()
{
    return _varCRVersionString;
}

CRSTDAPI_(bool)
CRTriggerEvent(CREventPtr event, CRBvrPtr data)
{
    Assert (event);

    bool ret = false;
    
    APIPRECODE;
    TriggerEvent(event, data);
    ret = true;
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRBvrPtr)
CRCond(CRBooleanPtr c,
       CRBvrPtr i,
       CRBvrPtr e)
{
    Assert (c);
    Assert (i);
    Assert (e);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) CondBvr(c, i, e);
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRArrayPtr)
CRCreateArray(long s, CRBvrPtr pBvrs[], DWORD dwFlags)
{
    Assert (pBvrs);
    Assert (s >= 0);
    
    CRArrayPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRArrayPtr) ArrayBvr(s, (Bvr *) pBvrs,
                                (dwFlags & CR_ARRAY_CHANGEABLE_FLAG)?true:false);
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRArrayPtr)
CRCreateArray(long s,
              double dArr[],
              CR_BVR_TYPEID tid)
{
    Assert (s >= 0);
    Assert (s == 0 || dArr != NULL); // Array can only be NULL if s is 0
    
    CRArrayPtr ret = NULL;
    
    APIPRECODE;
    
    int elmsPerObject;
    DXMTypeInfo ti;

    switch (tid) {
      case CRNUMBER_TYPEID:
        elmsPerObject = 1;
        ti = AxANumberType;
        break;
      case CRPOINT2_TYPEID:
        elmsPerObject = 2;
        ti = Point2ValueType;
        break;
      case CRVECTOR2_TYPEID:
        elmsPerObject = 2;
        ti = Vector2ValueType;
        break;
      case CRPOINT3_TYPEID:
        elmsPerObject = 3;
        ti = Point3ValueType;
        break;
      case CRVECTOR3_TYPEID:
        elmsPerObject = 3;
        ti = Vector3ValueType;
        break;
      default:
        RaiseException_UserError(E_INVALIDARG, 0);
    }

    Assert ((s % elmsPerObject) == 0);

    int nObjs = s / elmsPerObject;
    
    AxAValue *array = NULL;

    array = (AxAValue *) _alloca(nObjs * sizeof(AxAValue));

    for (int i = 0; i < nObjs; i++) {
        AxAValue v;
        
        switch (tid) {
          case CRNUMBER_TYPEID:
            v = NEW AxANumber(dArr[i]);
            break;
          case CRPOINT2_TYPEID:
            v = NEW Point2Value(dArr[i*2],dArr[i*2+1]);
            break;
          case CRVECTOR2_TYPEID:
            v = NEW Vector2Value(dArr[i*2],dArr[i*2+1]);
            break;
          case CRPOINT3_TYPEID:
            v = NEW Point3Value(dArr[i*3],dArr[i*3+1],dArr[i*3+2]);
            break;
          case CRVECTOR3_TYPEID:
            v = NEW Vector3Value(dArr[i*3],dArr[i*3+1],dArr[i*3+2]);
            break;
          default:
            Assert (!"Invalid type pass to CRCreateArray");
        }

        array[i] = v;
    }
        
    AxAArray * valarr = MakeValueArray(array,nObjs,ti);

    ret = (CRArrayPtr) ConstBvr(valarr);
    
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRTuplePtr)
CRCreateTuple(long s, CRBvrPtr pBvrs[])
{
    Assert (pBvrs);
    Assert (s >= 0);
    
    CRTuplePtr ret = NULL;
    
    APIPRECODE;
    ret = (CRTuplePtr) TupleBvr(s, (Bvr *) pBvrs);
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRArrayPtr)
CRUninitializedArray(CRArrayPtr typeTmp)
{
    Assert (typeTmp);
    
    CRArrayPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRArrayPtr) InitBvr(typeTmp->GetTypeInfo());
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRTuplePtr)
CRUninitializedTuple(CRTuplePtr typeTmp)
{
    Assert (typeTmp);
    
    CRTuplePtr ret = NULL;
    
    APIPRECODE;
    ret = (CRTuplePtr) InitBvr(typeTmp->GetTypeInfo());
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRBvrPtr)
CRUninitializedBvr(CR_BVR_TYPEID t)
{
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) InitBvr(GetTypeInfoFromTypeId(t));
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRBvrPtr)
CRSampleAtLocalTime(CRBvrPtr b, double localTime)
{
    Assert (b);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) SampleAtLocalTime(b, localTime);

    // TODO: Improve this error message.
    if (ret == NULL)
        DASetLastError(E_INVALIDARG, NULL);
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRIsConstantBvr(CRBvrPtr b)
{
    Assert (b);
    
    bool ret = false;
    
    APIPRECODE;
    ConstParam cp(true);
    ret = (b->GetConst(cp) != NULL);
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRBvrPtr)
CRSequenceArray(long s, CRBvrPtr pBvrs[])
{
    Assert (pBvrs);
    Assert (s >= 0);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) Sequence(s, (Bvr *) pBvrs);
    APIPOSTCODE;

    return ret;
}

Bvr MakeUserData(LPUNKNOWN unk)
{
    return UserDataBvr (WrapUserData(unk)) ;
}

LPUNKNOWN GetUserData(Bvr bvr)
{
    return ExtractUserData(GetUserDataBvr(bvr)) ;
}

void
InitializeModule_APIMisc()
{
    USES_CONVERSION;
    _varCRVersionString = CopyString(A2W(VERSION));
}

void
DeinitializeModule_APIMisc(bool bShutdown)
{
    delete (void *) _varCRVersionString;
    _varCRVersionString = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\appdll\main.cpp ===
/*******************************************************************************
  Copyright (c) 1995-96 Microsoft Corporation

  Abstract:

    Initialization

 *******************************************************************************/

#include "headers.h"
#include "privinc/util.h"
#include "dartapi.h"

HINSTANCE  hInst;
int bInitState = 0;

int InitializeAllAppelModules(void);
void InitializeAllAppelThreads(void);
void DeinitializeAllAppelThreads(void);
void DeinitializeAllAppelModules(bool bShutdown);

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C" BOOL WINAPI _DllMainCRTStartup (HINSTANCE hInstance,
                                           DWORD dwReason,
                                           LPVOID lpReserved);

extern "C" BOOL WINAPI
_DADllMainStartup(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_DETACH) {
        // Call the routines in reverse order of initialization
        BOOL r = _DllMainCRTStartup(hInstance,dwReason,lpReserved);
        r = DALibStartup(hInstance,dwReason,lpReserved) && r;

        return r;
    } else {
        // In everything except DLL_PROCESS_DETACH call DALibStartup first
        return (DALibStartup(hInstance,dwReason,lpReserved) &&
                _DllMainCRTStartup(hInstance,dwReason,lpReserved));
    }
}

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch(dwReason) {
      case DLL_PROCESS_ATTACH:
        {
            hInst = hInstance;
//        DisableThreadLibraryCalls(hInstance);
            
            RESTOREDEFAULTDEBUGSTATE;

            __try {
                bInitState = 1;
                InitializeAllAppelModules();
            } __except ( HANDLE_ANY_DA_EXCEPTION ) {
                bInitState = 0;
                TraceTag((tagError, "InitializeAllAppelModules - exception caught"));
#if DEVELOPER_DEBUG
                OutputDebugString("\nDANIM: Error during DLL initialization.\n");
#endif
#ifdef _DEBUG
                // Do not try to use the exception since it may not be
                // initialized
                MessageBox(NULL,
                           "Error",
                           "Error during DLL initialization",MB_OK|MB_SETFOREGROUND) ;
#endif
                
                return FALSE;
            }
            break;
        }
      case DLL_PROCESS_DETACH:
        {
            // lpReserved is non-null if called during process shutdown
            bool bShutdown = lpReserved != NULL;
            
            bInitState = -1;
            __try {
                DeinitializeAllAppelModules(bShutdown);
            } __except ( HANDLE_ANY_DA_EXCEPTION ) {
                bInitState = 0;
                TraceTag((tagError, "DeinitializeAllAppelModules - exception caught"));
#if DEVELOPER_DEBUG
                OutputDebugString("\nDANIM: Error during DLL deinitialization.\n");
#endif
                return FALSE;
            }

#if _DEBUG
            char buf[MAX_PATH + 1];
        
            GetModuleFileName(hInst, buf, MAX_PATH);
        
#if _DEBUGMEM
            TraceTag((tagLeaks, "\n[%s] unfreed memory:", buf));
            DUMPMEMORYLEAKS;
#endif
            
            // de-initialize the debug trace info.
            DeinitDebug();
#endif
            
            break;
        }
      case DLL_THREAD_ATTACH:
        {
            __try {
                InitializeAllAppelThreads();
            } __except ( HANDLE_ANY_DA_EXCEPTION ) {
                bInitState = 0;
                TraceTag((tagError, "InitializeAllAppelThreads - exception caught"));
#if DEVELOPER_DEBUG
                OutputDebugString("\nDANIM: Error during thread initialization.\n");
#endif
                return FALSE;
            }

            break;
        }
      case DLL_THREAD_DETACH:
        {
            __try {
                DeinitializeAllAppelThreads();
            } __except ( HANDLE_ANY_DA_EXCEPTION ) {
                bInitState = 0;
                TraceTag((tagError, "DeinitializeAllAppelThreads - exception caught"));
#if DEVELOPER_DEBUG
                OutputDebugString("\nDANIM: Error during thread deinitialization.\n");
#endif
                return FALSE;
            }

            break;
        }
    }
    
    bInitState = 0;

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

#ifdef _DEBUG
static bool breakDialog = false ;
DeclareTag(tagDebugBreak, "!Debug", "Breakpoint on entry to DLL");
#endif

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _DEBUG
    if (!breakDialog && IsTagEnabled(tagDebugBreak)) {
        char buf[MAX_PATH + 1];
        
        GetModuleFileName(hInst, buf, MAX_PATH);
        
        MessageBox(NULL,buf,"Creating first COM Object",MB_OK|MB_SETFOREGROUND) ;
        breakDialog = true;
    }
#endif

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}


#if _DEBUG
STDAPI_(void)
DoTraceTagDialog(HWND hwndStub,
                 HINSTANCE hAppInstance,
                 LPWSTR lpwszCmdLine,
                 int nCmdShow)
{
    DoTracePointsDialog(true);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\andornot.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation for And/Or/Not events

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "appelles/events.h"

/////////////////////////// And Event ///////////////////////////////

extern const char AND[] = "and";
extern const char OR[] = "or";
extern const char THEN[] = "then";
extern const char NOTEVENT[] = "notEvent";
static const double EPSILON = 0.0001;

extern AxAPrimOp *RealAddOp;

// And event semantics says we need to find the first occurrence of
// BOTH events e1 & e2 happen.  We loop through each of the e1's
// occurrences t0 and see if e2 happens around that event time (to the
// accuracy of EPSILON).

class AndPerfImpl : public GCBase2<Perf, PerfImpl, AND> {
  public:
    AndPerfImpl(BOOL int1, BOOL int2, Perf e1, Perf e2)
    : GCBase2<Perf, PerfImpl, AND>(e1, e2),
      _int1(int1), _int2(int2), _swap(int2 && !int1) {
    }
    
    virtual AxAValue _Sample(Param& p) {
        Perf e1 = _b1, e2 = _b2;

        if (_swap) {
            e1 = _b2;
            e2 = _b1;
        }
        
        AxAEData *edata1 = ValEData(e1->Sample(p));
        
        while (edata1->Happened()) {

            Time t1 = edata1->HappenedTime();
            
            AxAEData *edata2 = ValEData(EventAt(e2, p, t1));

            if (edata2->Happened()) {

                if (fabs(edata2->HappenedTime() - t1) <= EPSILON) {

                    /*
                    printf("Got *** %20.15f and %20.15f %20.15f\n",
                           p._time, t1, edata2->HappenedTime());
                    fflush(stdout);
                    */
                    
                    return CreateEData(t1,
                                       _swap ?
                                       PairBvr(edata2->EventData(),
                                               edata1->EventData()) :
                                       PairBvr(edata1->EventData(),
                                               edata2->EventData()));
                }

                /*
                else {
                    printf("too far %20.15f and %20.15f %20.15f\n",
                           p._time, t1, edata2->HappenedTime());
                    fflush(stdout);
                }
                */
            }

            // If both events are not interrupt driven, we are
            // searching through a continuous based, the iteration
            // can't terminate without more advanced algorithm.
            // Let's just quit.  E.g. predicate(time>1) &&
            // predicate(time<0).  
            
            if (_int1 || _int2)
                edata1 = ValEData(EventAfter(e1, p, t1));
            else
                break;
        }
        
        return noEvent;
    }

  private:
    BOOL _swap;
    BOOL _int1;
    BOOL _int2;
};

////////// Bvr ////////////////

class AndBvrImpl : public GCBase2<Bvr, BvrImpl, AND> {
  public:
    AndBvrImpl(Bvr e1, Bvr e2) : GCBase2<Bvr, BvrImpl, AND>(e1, e2) {}

    virtual BOOL InterruptBasedEvent() {
        return _b1->InterruptBasedEvent() || _b2->InterruptBasedEvent();
    }

    virtual Perf _Perform(PerfParam& p) {
        BOOL interrupt1 = _b1->InterruptBasedEvent();
        BOOL interrupt2 = _b2->InterruptBasedEvent();
        
        return
            NEW AndPerfImpl(interrupt1,
                            interrupt2,
                            ::Perform(_b1, p),
                            ::Perform(_b2, p));
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
};

/////////////////////////// Or Event ///////////////////////////////

class OrPerfImpl : public GCBase2<Perf, PerfImpl, OR> {
  public:
    OrPerfImpl(Perf e1, Perf e2) : GCBase2<Perf, PerfImpl, OR>(e1, e2) {}
    
    virtual AxAValue _Sample(Param& p) {
        AxAEData *edata = ValEData(_b1->Sample(p));

        if (edata->Happened())
            return edata;
        else
            return _b2->Sample(p);
    }
};

////////// Bvr ////////////////

class OrBvrImpl : public GCBase2<Bvr, BvrImpl, OR> {
  public:
    OrBvrImpl(Bvr e1, Bvr e2) : GCBase2<Bvr, BvrImpl, OR>(e1, e2) {}

    virtual BOOL InterruptBasedEvent() {
        return _b1->InterruptBasedEvent() && _b2->InterruptBasedEvent();
    }

    virtual Perf _Perform(PerfParam& p) {
        return NEW OrPerfImpl(::Perform(_b1, p), ::Perform(_b2, p));
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
};

/////////////////////////// Not Event ///////////////////////////////

class NotEventPerfImpl : public GCBase1<Perf, PerfImpl, NOTEVENT> {
  public:
    NotEventPerfImpl(Perf e) : GCBase1<Perf, PerfImpl, NOTEVENT>(e) {}
    
    virtual AxAValue _Sample(Param& p) {
        AxAEData *edata = ValEData(_base->Sample(p));

        if (edata->Happened())
            return noEvent;
        else
            return CreateEData(p._time, TrivialBvr());
    }
};

////////// Bvr ////////////////

class NotEventBvrImpl : public GCBase1<Bvr, BvrImpl, NOTEVENT> {
  public:
    NotEventBvrImpl(Bvr e) : GCBase1<Bvr, BvrImpl, NOTEVENT>(e) {}

    virtual BOOL InterruptBasedEvent() { return _base->InterruptBasedEvent(); }

    virtual Perf _Perform(PerfParam& p) {
        return NEW NotEventPerfImpl(::Perform(_base, p));
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
};

/////////////////////////// Then Event ///////////////////////////////

class ThenPerfImpl : public PerfImpl {
  public:
    ThenPerfImpl(Perf e1, Bvr e2, TimeXform tt)
    : _p1(e1), _b2(e2), _data1(NULL), _p2(NULL), _tt(tt) {}
    
    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_b2);
        (*proc)(_p1);
        (*proc)(_tt);
        if (_data1) (*proc)(_data1);
        if (_p2) (*proc)(_p2);
    }
    
    virtual AxAValue _Sample(Param& p) {
        if (_data1 && _p2) {    // event1 already occurred.
            if (p._time > _eTime1) {
                AxAEData *edata = ValEData(_p2->Sample(p));

                if (edata->Happened()) {
                    return CreateEData(edata->HappenedTime(),
                                       PairBvr(_data1, edata->EventData()));
                }
            }
        } else {
            AxAEData *edata = ValEData(_p1->Sample(p));

            if (edata->Happened()) {
                _data1 = edata->EventData();
                _eTime1 = edata->HappenedTime();
                _p2 = ::Perform(_b2, PerfParam(_eTime1, Restart(_tt, _eTime1, p)));
                return _p2->Sample(p);
            } 
        }

        return noEvent;
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        os << "then(" << _p1 << ",";
        if (_data1 && _p2)
            os << _p2;
        else
            os << _b2;
        return os << ")";
    }
#endif

  private:
    Time _eTime1;
    Bvr _data1, _b2;
    Perf _p1, _p2;
    TimeXform _tt;
};

////////// Bvr ////////////////

class ThenBvrImpl : public GCBase2<Bvr, BvrImpl, THEN> {
  public:
    ThenBvrImpl(Bvr e1, Bvr e2) : GCBase2<Bvr, BvrImpl, THEN>(e1, e2) {}

    // Actually after _b1 happens, it depends on _b2.
    virtual BOOL InterruptBasedEvent() {
        return _b1->InterruptBasedEvent();
    }

    virtual Perf _Perform(PerfParam& p) {
        return NEW ThenPerfImpl(::Perform(_b1, p), _b2, p._tt);
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
};


////////////////////// Max Event ////////////////////

class MaxEventPerfImpl : public PerfImpl {
  public:
    MaxEventPerfImpl() : _te(0) {}
        
    void Init(Perf *events, int n) {
        _events = events;
        _n = n;
        _times = (Time *) StoreAllocate(GetGCHeap(), sizeof(Time) * _n);
        _markers = (bool *) StoreAllocate(GetGCHeap(), sizeof(bool) * _n);
        for (int i=0; i<_n; i++) {
            _markers[i] = false;
        }
    }

    virtual ~MaxEventPerfImpl() {
        StoreDeallocate(GetGCHeap(), _events);
        StoreDeallocate(GetGCHeap(), _markers);
        StoreDeallocate(GetGCHeap(), _times);
    }

    virtual AxAValue _Sample(Param& p) {
        bool allHappened = true;
        
        for (int i=0; i<_n; i++) {
            if (!_markers[i]) {
                AxAEData *e = ValEData(_events[i]->Sample(p));

                if (e->Happened()) {
                    _markers[i] = true;
                    _times[i] = e->HappenedTime();
                    _te = MAX(_te, _times[i]);
                } else {
                    allHappened = false;
                }
            }
        }

        if (allHappened && (p._time > _te))
            return CreateEData(_te, TrivialBvr());
        else
            return noEvent;
    }
    
    virtual void _DoKids(GCFuncObj proc) {
        for (int i=0; i<_n; i++) {
            (*proc)(_events[i]);
        }
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "max"; }
#endif

  private:
    Perf *_events;
    int _n;
    bool *_markers;
    Time *_times;
    Time _te;
};

class MaxEventBvrImpl : public BvrImpl {
  public:
    MaxEventBvrImpl(Bvr *events, int n) : _events(events), _n(n) {}

    virtual ~MaxEventBvrImpl()
    { StoreDeallocate(GetGCHeap(), _events); }

    virtual Perf _Perform(PerfParam& p) {
        Perf *perfs = (Perf *) StoreAllocate(GetGCHeap(), _n * sizeof(Perf));
        for (int i=0; i<_n; i++) {
            perfs[i] = ::Perform(_events[i], p);
        }

        // Avoid allocation in constructor
        MaxEventPerfImpl* x = NEW MaxEventPerfImpl();
        x->Init(perfs, _n);
        return x;
    }
    
    // Actually after _b1 happens, it depends on _b2.
    virtual BOOL InterruptBasedEvent() {
        for (int i=0; i<_n; i++) {
            if (!_events[i]->InterruptBasedEvent())
                return FALSE;
        }

        return TRUE;
    }

    virtual void _DoKids(GCFuncObj proc) {
        for (int i=0; i<_n; i++) {
            (*proc)(_events[i]);
        }
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "max"; }
#endif

  private:
    Bvr *_events;
    int _n;
};

/////////////////// Event Bvr for the front end ////////////////

inline Bvr NumConst(double d)
{ return ConstBvr(NEW AxANumber(d)); }

inline Bvr Timer(double duration)
{ return TimerEvent(NumConst(duration)); }

Bvr AndEvent(Bvr e1, Bvr e2)
{
    if ((e1 == neverBvr) || (e2 == neverBvr))
        return neverBvr;
    
    return NEW AndBvrImpl(e1, e2);
}

Bvr OrEvent(Bvr e1, Bvr e2)
{
    if (e1 == neverBvr) return e2;
    if (e2 == neverBvr) return e1;
    
    AxAValue v1, v2;
    Bvr t1 = e1->GetTimer();
    Bvr t2 = e2->GetTimer();
    
    ConstParam cp;
    
    if (t1 && t2 && (v1 = t1->GetConst(cp)) && (v2 = t2->GetConst(cp)))
        return Timer(MIN(ValNumber(v1), ValNumber(v2)));
    
    return NEW OrBvrImpl(e1, e2);
}

Bvr NotEvent(Bvr e)
{
    if (e == neverBvr)
        return alwaysBvr;
    if (e == alwaysBvr)
        return neverBvr;
    
    return NEW NotEventBvrImpl(e);
}

Bvr ThenEvent(Bvr e1, Bvr e2)
{
    if ((e1 == neverBvr) || (e2 == neverBvr))
        return neverBvr;

    Bvr d1 = e1->GetTimer();
    Bvr d2 = e2->GetTimer();
    
    if (d1 && d2) {
        // would get constant folded if constant
        return TimerEvent(PrimApplyBvr(RealAddOp, 2, d1, d2));
    }
    
    return NEW ThenBvrImpl(e1, e2);
}

Bvr MaxEvent(Bvr *events, int n)
{
    Time last = 0;
    AxAValue v;
    ConstParam cp;
    
    for (int i=0; i<n; i++) {
        Bvr timer = events[i]->GetTimer();

        if (timer && (v = timer->GetConst(cp))) {
            last = MAX(ValNumber(v), last);
        } else {
            return NEW MaxEventBvrImpl(events, n);
        }
    }

    return Timer(last);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\pickable.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    IDABehavior implementation

Revision:

--*/

#include "headers.h"
#include "apiprims.h"
#include "backend/values.h"
#include "backend/gc.h"

DeclareTag(tagPickable, "API", "Pickable");

class CRPickableResult : public GCObj
{
  public:
    CRPickableResult(CRImagePtr img,
                     CRGeometryPtr geo,
                     CREventPtr ev)
    : _img(img), _geo(geo), _ev(ev) {}

    virtual void DoKids(GCFuncObj proc) {
        if (_img) (*proc)(_img);
        if (_geo) (*proc)(_geo);
        if (_ev) (*proc)(_ev);
    }

    CRImagePtr GetImage() { return _img; }
    CRGeometryPtr GetGeometry() { return _geo; }
    CREventPtr GetEvent() { return _ev; }
  protected:
    CRImagePtr _img;
    CRGeometryPtr _geo;
    CREventPtr _ev;
};

CRPickableResultPtr
PickableImageHelper(CRImagePtr imageBvr, bool ignoreOcclusion)
{
    Bvr img, event;
    
    ::PickableImage(imageBvr, ignoreOcclusion, img, event);

    return NEW CRPickableResult((CRImagePtr)img,
                                NULL,
                                (CREventPtr) event);
}

CRSTDAPI_(CRPickableResultPtr)
CRPickable(CRImagePtr img)
{
    CRPickableResultPtr ret = NULL;
    APIPRECODE;
    ret =  PickableImageHelper(img, false);
    APIPOSTCODE;
    return ret;
}

CRSTDAPI_(CRPickableResultPtr)
CRPickableOccluded(CRImagePtr img)
{
    CRPickableResultPtr ret = NULL;
    APIPRECODE;
    ret =  PickableImageHelper(img, true);
    APIPOSTCODE;
    return ret;
}

CRPickableResultPtr
PickableGeometryHelper(CRGeometryPtr geoBvr, bool ignoreOcclusion)
{
    Bvr geo, event;
    
    ::PickableGeometry(geoBvr, ignoreOcclusion, geo, event);

    return NEW CRPickableResult(NULL,
                                (CRGeometryPtr) geo,
                                (CREventPtr) event);
}

CRSTDAPI_(CRPickableResultPtr)
CRPickable(CRGeometryPtr geo)
{
    CRPickableResultPtr ret = NULL;
    APIPRECODE;
    ret =  PickableGeometryHelper(geo, false);
    APIPOSTCODE;
    return ret;
}

CRSTDAPI_(CRPickableResultPtr)
CRPickableOccluded(CRGeometryPtr geo)
{
    CRPickableResultPtr ret = NULL;
    APIPRECODE;
    ret =  PickableGeometryHelper(geo, true);
    APIPOSTCODE;
    return ret;
}

CRSTDAPI_(CRImagePtr)
CRGetImage(CRPickableResultPtr pr)
{
    return pr->GetImage();
}

CRSTDAPI_(CRGeometryPtr)
CRGetGeometry(CRPickableResultPtr pr)
{
    return pr->GetGeometry();
}

CRSTDAPI_(CREventPtr)
CRGetEvent(CRPickableResultPtr pr)
{
    return pr->GetEvent();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\axapath.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Path Bvr

*******************************************************************************/

#include <headers.h>
#include "appelles/sound.h"
#include "appelles/axaprims.h"
#include "bvr.h"
#include "perf.h"
#include "values.h"

extern AxAPrimOp *RealAddOp;
extern AxAPrimOp *RealMultiplyOp;

Bvr MakeRenderedSound(Bvr geo, Bvr mic)
{
    return
        PrimApplyBvr(ValPrimOp(RenderSound, 2,
                               "RenderSound", SoundType),
                     2, geo, mic);
}

Bvr MakeSoundSource(Bvr s)
{
    return
        PrimApplyBvr(ValPrimOp(SoundSource, 1, "SoundSource",
                               GeometryType),
                     1,
                     s);
}

Bvr ApplyPhase(Bvr phase, Bvr snd)
{
    return
        TimeXformBvr(snd, PrimApplyBvr(RealAddOp, 2, TimeBvr(), phase));
}

Bvr ApplyPitchShift(Bvr rate, Bvr snd)
{
    return TimeXformBvr(snd, IntegralBvr(rate));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\array.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Array/Tuple Behavior.  

*******************************************************************************/

#include <headers.h>
#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "events.h"
#include "privinc/resource.h"
#include "privinc/debug.h"
#include "privinc/stlsubst.h"
#include "dartapi.h"

inline AxAValue GetConst(Bvr b, ConstParam& p)
{ return b->GetConst(p); }

inline AxAValue GetRBConst(Perf b, RBConstParam& p)
{ return b->GetRBConst(p); }

FixedArray::FixedArray(long sz, GCBase** a) : _sz(sz)
{
    if (a)
        _arr = a;
    else
        _arr = (GCBase**) AllocateFromStore(sizeof(GCBase*) * _sz);
}

FixedArray::~FixedArray()
{ DeallocateFromStore(_arr); }

void
FixedArray::DoKids(GCFuncObj proc)
{ 
    for (long i=0; i<_sz; i++) {
        (*proc)(_arr[i]);
    }
}

#if _USE_PRINT
ostream&
FixedArray::Print(ostream& os)
{ 
    os << "[";
    for (long i=0; i<_sz; i++) {
        os << _arr[i];
        if (i<_sz-1)
            os << ",";
    }
    return os << "]";
}
#endif
        
static int
IndexCheck(char *prefix, long i, long sz)
{
    if ((i<0) || (i>=sz)) {
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_BAD_INDEX,prefix,sz,i);
    }

    return i;
}

GCBase *&
FixedArray::operator[](long i)
{
    Assert((i>=0) && (i<_sz));
    return _arr[i];
}

AxAArray::AxAArray(AxAValue *vals, long n, DXMTypeInfo typeinfo, 
                   bool copy, bool changeable) 
: _sz(n), _typeinfo(typeinfo), _changeable(changeable)
{
    if (copy) {
        _vals = (AxAValue*) AllocateFromStore(sizeof(AxAValue) * _sz);
        for (long i=0; i<n; i++) {
            _vals[i] = vals[i];
        }
    } else
        _vals = vals;
}

AxAArray::~AxAArray()
{ DeallocateFromStore(_vals); }

void
AxAArray::DoKids(GCFuncObj proc)
{ 
    (*proc)(_typeinfo);
    for (long i=0; i<_sz; i++) {
        (*proc)(_vals[i]);
    }
}

#if _USE_PRINT
ostream&
AxAArray::Print(ostream& os)
{ 
    os << "[";
    for (long i=0; i<_sz; i++) {
        os << _vals[i];
        if (i<_sz-1)
            os << ",";
    }
    return os << "]";
}
#endif

template<class Impl, class Base>
class ArrayBase : public Impl {
  public:
    ArrayBase(long size, DXMTypeInfo type) : _type(type) {
        _arr = NEW vector<Base*>(size);
    }

    virtual ~ArrayBase() { delete _arr; }
    
#if _USE_PRINT
    ostream& Print(ostream& os) { 
        os << "[";
        for (long i=0; i<_arr->size(); i++) {
            os << (*_arr)[i];
            if (i<_arr->size()-1)
                os << ",";
        }
        return os << "]";
    }
#endif
        
    virtual void _DoKids(GCFuncObj proc) {
        for (long i=0; i<_arr->size(); i++) {
            (*proc)((*_arr)[i]);
        }
        Assert(_type);
        (*proc)(_type);
    }

    Base *& operator[](long i) {
        Assert((i>=0) && (i<_arr->size()));
        return (*_arr)[i];
    }

    long Length() { return _arr->size(); }

    virtual DXMTypeInfo GetTypeInfo() { return _type; }

    virtual BVRTYPEID GetBvrTypeId() { return ARRAY_BTYPEID; }

  protected:
    vector<Base *> *_arr;
    DXMTypeInfo _type;
};

class ArrayBvrImpl;

class ArrayPerfImpl : public ArrayBase<PerfImpl, PerfBase> {
  public:
    ArrayPerfImpl(long size, DXMTypeInfo type,
                  Time t0,
                  ArrayBvrImpl* b = NULL,  // NULL means non-changeable
                  TimeXform tt = NULL)
    : ArrayBase<PerfImpl, PerfBase>(size, type), 
      _base(b), _tt(tt), _t0(t0), _ids(NULL) {
        if (b) {
            _ids = NEW vector<unsigned long>(size, 0);
        }
    }

    ~ArrayPerfImpl() { delete _ids; }

    virtual bool CheckChangeables(CheckChangeablesParam &ccp);

    virtual AxAValue _Sample(Param& p);

    virtual AxAValue _GetRBConst(RBConstParam& p);

    virtual void _DoKids(GCFuncObj proc);

  protected:
    ArrayBvrImpl *_base;
    vector<unsigned long> *_ids;
    TimeXform _tt;
    Time _t0;
};

class ArrayTypeInfo : public DXMTypeInfoImpl {
  public:
    ArrayTypeInfo(DXMTypeInfo type)
    : _type(type), DXMTypeInfoImpl(AXAARRAY_TYPEID,"Array",CRARRAY_TYPEID) {}

    DXMTypeInfo ArrayType() { return _type; }

    virtual BOOL Equal(DXMTypeInfo x) {
        if (x->GetTypeInfo() == AXAARRAY_TYPEID) {
            Assert(DYNAMIC_CAST(ArrayTypeInfo*, x));
            ArrayTypeInfo *a = (ArrayTypeInfo *) x;

            return _type->Equal(a->ArrayType());
        }

        return FALSE;
    }
    
  private:
    DXMTypeInfo _type;
};

DXMTypeInfo GetArrayTypeInfo(DXMTypeInfo b)
{ return SAFE_CAST(ArrayTypeInfo *, b)->ArrayType(); }

class ArrayBvrImpl : public ArrayBase<BvrImpl, BvrBase> {
    friend class ArrayPerfImpl;
    
  public:
    ArrayBvrImpl(long size, Bvr *bvrs, bool sizeChangeable, bool doTypes = TRUE)
    : ArrayBase<BvrImpl, BvrBase>(size, NULL), _flags(NULL), _ids(NULL),
      _sizeChangeable(sizeChangeable), _end(NULL) {
        Assert(size > 0);

        for (long i=0; i<_arr->size(); i++) {
            Assert(bvrs[i]);
            (*_arr)[i] = bvrs[i];
        }
  
        if (sizeChangeable) {
            _flags = NEW vector<DWORD>(size, 0);
            _ids = NEW vector<unsigned long>(size, 0);
        }
        
        if (doTypes)
            SetupType();

        _info = GetInfo(true);
    }

    virtual ~ArrayBvrImpl() { 
        delete _flags;
        delete _ids;
    }
    
    virtual DWORD GetInfo(bool recalc) {
        if (recalc)
        {
            _info = 0xffffffff;
            
            for (long i=0; i<_arr->size(); i++)
            {
                Bvr b = (*_arr)[i];
                
                if (b)
                {
                    _info &= b->GetInfo(recalc);
                }
            }
        }

        return _info;
    }
    
    void SetupType() {
        DXMTypeInfo elmType = (*_arr)[0]->GetTypeInfo();
        _type = NEW ArrayTypeInfo(elmType);

        for (long i=1; i<_arr->size(); i++) 
            CheckMatchTypes("array", elmType, (*_arr)[i]->GetTypeInfo());
    }

    virtual Perf _Perform(PerfParam& p) {
        ArrayPerfImpl *perfs = PerfConstruction(p);
    
        for (long i=0; i<_arr->size(); i++) {
            Bvr b = (*_arr)[i];
            (*perfs)[i] = b ? ::Perform(b, p) : NULL;
        }

        return perfs;
    }

    virtual ArrayPerfImpl *PerfConstruction(PerfParam& p) {
        return NEW ArrayPerfImpl(_arr->size(), _type,
                                 p._t0,
                                 _sizeChangeable ? this : NULL,
                                 _sizeChangeable ? p._tt : NULL);
    }

    virtual DXMTypeInfo GetTypeInfo() { Assert(_type); return _type; }

    virtual Bvr EndEvent(Bvr overrideEvent) {
        Bvr ret = _end;

        if (overrideEvent || ret==NULL) {
            int s = _arr->size();
        
            Bvr *events =
                (Bvr *) StoreAllocate(GetGCHeap(), s * sizeof(Bvr));

            for (long i=0; i<s; i++) {
                Bvr b = (*_arr)[i];
                
                events[i] = b ? b->EndEvent(overrideEvent) : zeroTimer;
            }

            // events deleted by MaxEvent
            ret = MaxEvent(events, s);

            // If not overriding then cache the event
            if (!overrideEvent)
                _end = ret;
        }

        return ret;
    }

    virtual void _DoKids(GCFuncObj proc) {
        ArrayBase<BvrImpl, BvrBase>::_DoKids(proc);
        (*proc)(_end);
    }
    
    virtual AxAValue GetConst(ConstParam & cp);

    int AddElement(Bvr b, DWORD flag) {
        // if (!_end) EndEvent(NULL);  // init 
            
        int i = _arr->size();

        SetElement(i, b, flag);

        // Kevin we shouldn't handle dynamic duration for dynamic arrays.
        /*
        int j = _end->_AddElement(b->EndEvent(NULL), flag);

        Assert(i==j);
        */

        return i;
    }

    void SetElement(long i, Bvr b, DWORD flag) {
        if ((flag!=SW_CONTINUE) && (flag!=0)) {
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_ARRAY_FLAG);
        }

        if (!_sizeChangeable || i<0) {
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_ARRAY_ADD);
        }

        ArrayTypeInfo *t = SAFE_CAST(ArrayTypeInfo*, _type);
        CheckMatchTypes("SetElement", t->ArrayType(), b->GetTypeInfo());
            
        if (i>=_arr->size()) {
            long n = i + 1;
            if (n > _arr->capacity()) {
                long nn = n * 1.5;
                _arr->reserve(nn);
                _flags->reserve(nn);
                _ids->reserve(nn);
            }
            _arr->resize(n, NULL);
            _flags->resize(n, 0);
            _ids->resize(n, 0);
        }

        Assert(i < _arr->capacity());

        (*_arr)[i] = b;
        (*_flags)[i] = flag;
        (*_ids)[i]++;


        GetInfo(true);
    }
    
    void _RemoveElement(int i) {
        if (_sizeChangeable) {
            (*_arr)[i] = NULL;
            (*_ids)[i]++;
            GetInfo(true);
        } else {
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_ARRAY_ADD);
        }
    }

    void RemoveElement(int i) {
        //if (!_end) EndEvent(NULL);
            
        _RemoveElement(i);
        
        //_end->_RemoveElement(i);
    }

    virtual Bvr Nth(int i) {
        if (i>=0 && i<_arr->size())
            return (*_arr)[i];
        else
            return NULL;
    }

  protected:
    DWORD _info;
    bool _sizeChangeable;
    vector<DWORD> *_flags;
    vector<unsigned long> *_ids;
    Bvr _end;
};

AxAValue 
ArrayBvrImpl::GetConst(ConstParam & cp) 
{
    if (_sizeChangeable)
        return NULL;
        
    long n = _arr->size();
        
    AxAValue *vals = 
        (AxAValue*) AllocateFromStore(sizeof(AxAValue) * n);

    for (long i=0; i<n; i++) {
        Bvr b = (*_arr)[i];
        bool nullElm = (b == NULL);
        vals[i] = nullElm ? NULL : b->GetConst(cp);
        if (!nullElm && (vals[i] == NULL)) {
            DeallocateFromStore(vals);
            return NULL;
        }
    }

    return NEW AxAArray(vals, n, _type, false);
}

AxAValue
ArrayPerfImpl::_GetRBConst(RBConstParam& p)
{
    if (_base && _base->_sizeChangeable) {
        p.AddChangeable(this);
    }
        
    long n = _arr->size();
        
    AxAValue *vals = 
        (AxAValue*) AllocateFromStore(sizeof(AxAValue) * n);

    bool isConst = true;
        
#if _DEBUG
    bool doDCF = true;

    if (IsTagEnabled(tagDCFold))
        doDCF = false;
#endif _DEBUG

    for (long i=0; i<n; i++) {
        Perf b = (*_arr)[i];
        bool nullElm = (b == NULL);
        vals[i] = nullElm ? NULL : b->GetRBConst(p);
        if (!nullElm && (vals[i] == NULL)) {
            if (isConst)
                isConst = false;
#if _DEBUG
            if (!doDCF)
                break;
#endif _DEBUG
        }
    }

    if (isConst) {
        return NEW AxAArray(vals, n, _type, false);
    } else {
        DeallocateFromStore(vals);
        return NULL;
    }
}

bool
ArrayPerfImpl::CheckChangeables(CheckChangeablesParam &ccp)
{
    if (_base) {

        long bsz = _base->_arr->size();

        if (bsz > _arr->size()) {
            // Detected an AddElement
            return true;
        }

        for (long i=0; i<bsz; i++) {
            
            if ((*_base->_arr)[i] == NULL && ((*_arr)[i] != NULL)) { 
                // Detected a RemoveElement
                return true;
            }
            
        }
        
    } 
        
    return false;
}

AxAValue
ArrayPerfImpl::_Sample(Param& p)
{
    if (_base) {
        long bsz = _base->_arr->size();
        long sz = _arr->size(); 

        if (bsz > sz) {
            if (bsz > _arr->capacity()) {
                int n = bsz * 1.5;
                _arr->reserve(n);
                _ids->reserve(n);
            }
            _arr->resize(bsz, NULL);
            _ids->resize(bsz, 0);
        }

        Assert(_base->_arr->size() == _arr->size());

        for (long i=0; i<bsz; i++) {

            // Id is different, indicates a change since last sample.
            if ((*_ids)[i] != (*_base->_ids)[i]) {
                
                if ((*_base->_arr)[i]) {
            
                    TimeXform tt;
                    Time t0 = _t0;

                    if ((*_base->_flags)[i]==SW_CONTINUE)
                        tt = Restart(_tt, _t0, p);
                    else {
                        tt = Restart(_tt, p._time, p);
                        t0 = p._time;
                    }

                    (*_arr)[i] = ::Perform((*_base->_arr)[i],
                                           PerfParam(t0, tt));
                } else {
                    (*_arr)[i] = NULL;
                }  

                (*_ids)[i] = (*_base->_ids)[i];
            }
        }
    }
    
    long n = _arr->size();
        
    AxAValue *vals = 
        (AxAValue*) AllocateFromStore(sizeof(AxAValue) * n);

    // Sample all elements for events...
    for (long i=0; i<n; i++) {
        Perf perf = (*_arr)[i];
        vals[i] = perf ? perf->Sample(p) : NULL;
    }

    return NEW AxAArray(vals, n, _type, false, _base != NULL);
}

void
ArrayPerfImpl::_DoKids(GCFuncObj proc)
{
    ArrayBase<PerfImpl, PerfBase>::_DoKids(proc);
    (*proc)(_base);
    (*proc)(_tt);
}

static AxAValue GetVal(AxAValue a, long i)
{
    if (a) {
        Assert(DYNAMIC_CAST(AxAArray*, a));
        AxAArray *arr = SAFE_CAST(AxAArray*, a);

        return (*arr)[i];
    }

    return NULL;
}

static AxAValue GetVal(AxAValue a, AxAValue index)
{
    if (index)
        return GetVal(a, (int) ValNumber(index));

    return NULL;
}

class NthPerfImpl : public PerfImpl {
  public:
    NthPerfImpl(Perf arr, Perf index) : _index(index), _arr(arr) { }

    virtual AxAValue _Sample(Param& p) {
        int i = (int) ValNumber(_index->Sample(p));
        AxAValue a = _arr->Sample(p);
        Assert(DYNAMIC_CAST(AxAArray*, a));
        AxAArray *x = SAFE_CAST(AxAArray*, a);

        AxAValue v = (*x)[IndexCheck("array", i, x->Length())];

        if (v==NULL)
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_ARRAY_REM);

        return v;
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_arr);
        (*proc)(_index);
    }
    
    virtual AxAValue _GetRBConst(RBConstParam& p)
    { return GetVal(_arr->GetRBConst(p), _index->GetRBConst(p)); }

#if _USE_PRINT
    ostream& Print(ostream& os)
    { return os << "nth(" << _arr << "," << _index << ")"; }
#endif
        
  private:
    Perf _arr;
    Perf _index;
};

class NthBvrImpl : public BvrImpl {
  public:
    NthBvrImpl(Bvr arr, Bvr i) : _index(i), _arr(arr) {
        _info = GetInfo(true);
    }

    virtual DWORD GetInfo(bool recalc) {
        if (recalc) {
            _info = _arr->GetInfo(recalc) & _index->GetInfo(recalc);
        }

        return _info;
    }
    
    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_arr);
        (*proc)(_index);
    }
    
    virtual Bvr EndEvent(Bvr overrideEvent) {
        Bvr end = _arr->EndEvent(overrideEvent);
        DXMTypeInfo type = end->GetTypeInfo();

        if (type->GetCRTypeId() == CRARRAY_TYPEID)
            return ::Nth(end, _index);
        else
            return end;
    }
    
    virtual AxAValue GetConst(ConstParam & cp) {
        return GetVal(_arr->GetConst(cp), _index->GetConst(cp));
    }

    virtual Perf _Perform(PerfParam& p) {
        return NEW NthPerfImpl(::Perform(_arr, p),
                               ::Perform(_index, p));
    }

    virtual DXMTypeInfo GetTypeInfo() {
        DXMTypeInfo type = _arr->GetTypeInfo();
        Assert(DYNAMIC_CAST(ArrayTypeInfo*, type));
        return ((ArrayTypeInfo*)type)->ArrayType();
    }

    Bvr GetNth() {
        ConstParam cp;
        AxAValue v = _index->GetConst(cp);

        if (v) 
            return _arr->Nth((int) ValNumber(v));

        return NULL;
    }

    virtual void Trigger(Bvr data, bool bAllViews) {
        Bvr x = GetNth();

        if (x)
            x->Trigger(data, bAllViews);
        else
            BvrImpl::Trigger(data, bAllViews);
    }

    virtual void SwitchTo(Bvr b, bool override, SwitchToParam flag,
                          Time gTime) {
        Bvr x = GetNth();

        if (x)
            x->SwitchTo(b, override, flag, gTime);
        else
            BvrImpl::SwitchTo(b, override, flag, gTime);
    }
    
    virtual void SwitchToNumbers(Real *numbers,
                                 Transform2::Xform2Type *xfType)
    {
        Bvr x = GetNth();

        if (x)
            x->SwitchToNumbers(numbers, xfType);
        else
            BvrImpl::SwitchToNumbers(numbers, xfType);
    }
    
    virtual Bvr GetCurBvr() {
        Bvr x = GetNth();

        return x ? x->GetCurBvr() : BvrImpl::GetCurBvr();
    }
    
#if _USE_PRINT
    ostream& Print(ostream& os)
    { return os << "nth(" << _arr << "," << _index << ")"; }
#endif
        
  private:
    Bvr _arr;
    Bvr _index;
    DWORD _info;
};

Bvr ArrayBvr(long size, Bvr *bvrs, bool sizeChangeable)
{ return NEW ArrayBvrImpl(size, bvrs, sizeChangeable); }

long ArrayAddElement(Bvr arr, Bvr b, DWORD flag)
{
    if (arr->GetBvrTypeId() != ARRAY_BTYPEID)
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_ARRAY_ADD_TYPE);

    Assert(DYNAMIC_CAST(ArrayBvrImpl*, arr));
    ArrayBvrImpl *a = SAFE_CAST(ArrayBvrImpl*, arr);

    return a->AddElement(b, flag);
}

void ArraySetElement(Bvr arr, long i, Bvr b, DWORD flag)
{
    if (arr->GetBvrTypeId() != ARRAY_BTYPEID)
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_ARRAY_ADD_TYPE);

    Assert(DYNAMIC_CAST(ArrayBvrImpl*, arr));
    ArrayBvrImpl *a = SAFE_CAST(ArrayBvrImpl*, arr);

    a->SetElement(IndexCheck("array", i, a->Length()), b, flag);
}

Bvr ArrayGetElement (Bvr arr, long i)
{
    if (arr->GetBvrTypeId() != ARRAY_BTYPEID)
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_ARRAY_ADD_TYPE);

    Assert(DYNAMIC_CAST(ArrayBvrImpl*, arr));
    ArrayBvrImpl *a = SAFE_CAST(ArrayBvrImpl*, arr);

    return a->Nth(IndexCheck("array", i, a->Length()));
}

void ArrayRemoveElement(Bvr arr, long i)
{
    if (arr->GetBvrTypeId() != ARRAY_BTYPEID)
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_ARRAY_ADD_TYPE);

    Assert(DYNAMIC_CAST(ArrayBvrImpl*, arr));

    ArrayBvrImpl *a = SAFE_CAST(ArrayBvrImpl*, arr);

    a->RemoveElement(IndexCheck("array", i, a->Length()));
}

long ArrayExtractElements(Bvr arr, Bvr *&ret)
{
    long n = 0; 

    if (arr->GetBvrTypeId() != ARRAY_BTYPEID)
        return 0;

    Assert(DYNAMIC_CAST(ArrayBvrImpl*, arr));

    ArrayBvrImpl *a = SAFE_CAST(ArrayBvrImpl*, arr);

    n = a->Length();

    ret = THROWING_ARRAY_ALLOCATOR(Bvr, n);

    for (long i=0; i<n; i++)
        ret[i] = a->Nth(i);

    return n;
}

Bvr Nth(Bvr array, Bvr index)
{ return NEW NthBvrImpl(array, index); }

AxANumber *ArrayLength(AxAArray *a)
{ return NEW AxANumber(a->Length()); }

//
// ================================ tuple ==========================
//

class TupleTypeInfo : public DXMTypeInfoImpl {
  public:
    TupleTypeInfo(long n, DXMTypeInfo *types)
    : _n(n), _types(types), DXMTypeInfoImpl(TUPLE_TYPEID,"Tuple",CRTUPLE_TYPEID) {}

    virtual ~TupleTypeInfo() 
    { StoreDeallocate(GetSystemHeap(), _types); }

    virtual void DoKids(GCFuncObj proc) {
        for (long i=0; i<_n; i++)
            (*proc)(_types[i]);
    }
        
    DXMTypeInfo *TupleTypes() { return _types; }

    long Len() { return _n; }

    virtual BOOL Equal(DXMTypeInfo x) {
        if (x->GetTypeInfo() == TUPLE_TYPEID) {
            Assert(DYNAMIC_CAST(TupleTypeInfo*, x));
            TupleTypeInfo *t = (TupleTypeInfo *) x;

            if (_n != t->Len())
                return FALSE;

            DXMTypeInfo *xtypes = t->TupleTypes();

            for (long i=0; i<_n; i++) {
                if (!(_types[i]->Equal(xtypes[i])))
                    return FALSE;
            }
           
            return TRUE;
        }

        return FALSE;
    }

  private:
    DXMTypeInfo* _types;
    long _n;
};

DXMTypeInfo *
GetTupleTypeInfo(DXMTypeInfo b, long *n)
{
    TupleTypeInfo * ti = SAFE_CAST(TupleTypeInfo *, b);

    if (n) *n = ti->Len();
    return ti->TupleTypes();
}

class TuplePerfImpl : public ArrayPerfImpl {
  public:
    TuplePerfImpl(long size, DXMTypeInfo type)
    : ArrayPerfImpl(size, type, 0.0) {}

    virtual BVRTYPEID GetBvrTypeId() { return TUPLE_BTYPEID; }
};

class TupleBvrImpl : public ArrayBvrImpl {
  public:
    TupleBvrImpl(long size, Bvr *bvrs)
    : ArrayBvrImpl(size, bvrs, false, false) {
        SetupTupleType();
    }

    void SetupTupleType() {
        DXMTypeInfo *types = (DXMTypeInfo *)
            StoreAllocate(GetSystemHeap(), (_arr->size() * sizeof(DXMTypeInfo)));

        for (long j=0; j<_arr->size(); j++)
            types[j] = (*_arr)[j]->GetTypeInfo();

        _type = NEW TupleTypeInfo(_arr->size(), types);
    }

    virtual ArrayPerfImpl* PerfConstruction()
    { return NEW TuplePerfImpl(_arr->size(), _type); }

    virtual DXMTypeInfo GetTypeInfo()
    { return _type ? _type : TupleType; }

    virtual BVRTYPEID GetBvrTypeId() { return TUPLE_BTYPEID; }
};

class TupleNthPerfImpl : public PerfImpl {
  public:
    TupleNthPerfImpl(Perf arr, long index) : _index(index), _arr(arr) { }

    virtual AxAValue _Sample(Param& p) {
        return GetVal(_arr->Sample(p), _index);
    }

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_arr); }
    
    virtual AxAValue _GetRBConst(RBConstParam& p)
    { return GetVal(_arr->GetRBConst(p), _index); }

#if _USE_PRINT
    ostream& Print(ostream& os)
    { return os << "nth(" << _arr << "," << _index << ")"; }
#endif
        
  private:
    Perf _arr;
    long _index;
};

class TupleNthBvrImpl : public BvrImpl {
  public:
    TupleNthBvrImpl(Bvr arr, long i) : _index(i), _arr(arr) {
        DXMTypeInfo type = _arr->GetTypeInfo();
        Assert(DYNAMIC_CAST(TupleTypeInfo*, type));
        IndexCheck("tuple", i,
                   ((TupleTypeInfo*)type)->Len());
    }

    virtual DWORD GetInfo(bool recalc)
    { return _arr->GetInfo(recalc); }
    
    virtual void _DoKids(GCFuncObj proc) { (*proc)(_arr); }
    
    virtual Bvr EndEvent(Bvr overrideEvent) {
        Bvr end = _arr->EndEvent(overrideEvent);
        DXMTypeInfo type = end->GetTypeInfo();

        if (type->GetCRTypeId() == CRTUPLE_TYPEID)
            return ::Nth(end, _index);
        else
            return end;
    }
    
    virtual AxAValue GetConst(ConstParam & cp) {
        return GetVal(_arr->GetConst(cp), _index);
    }

    virtual Perf _Perform(PerfParam& p) {
        return NEW TupleNthPerfImpl(::Perform(_arr, p), _index);
    }

    virtual DXMTypeInfo GetTypeInfo() {
        DXMTypeInfo type = _arr->GetTypeInfo();
        Assert(DYNAMIC_CAST(TupleTypeInfo*, type));
        return ((TupleTypeInfo*)type)->TupleTypes()[_index];
    }

    virtual void Trigger(Bvr data, bool bAllViews) {
        Bvr x = _arr->Nth(_index);

        if (x)
            x->Trigger(data, bAllViews);
        else
            BvrImpl::Trigger(data, bAllViews);
    }

    virtual void SwitchTo(Bvr b, bool override, SwitchToParam flag,
                          Time gTime) {
        Bvr x = _arr->Nth(_index);

        if (x)
            x->SwitchTo(b, override, flag, gTime);
        else
            BvrImpl::SwitchTo(b, override, flag, gTime);
    }
    
    virtual void SwitchToNumbers(Real *numbers,
                                 Transform2::Xform2Type *xfType)
    {
        Bvr x = _arr->Nth(_index);

        if (x)
            x->SwitchToNumbers(numbers, xfType);
        else
            BvrImpl::SwitchToNumbers(numbers, xfType);
    }

    virtual Bvr GetCurBvr() {
        Bvr x = _arr->Nth(_index);

        return x ? x->GetCurBvr() : BvrImpl::GetCurBvr();
    }
    
#if _USE_PRINT
    ostream& Print(ostream& os)
    { return os << "nth(" << _arr << "," << _index << ")"; }
#endif
        
  private:
    Bvr _arr;
    long _index;
};

Bvr TupleBvr(long size, Bvr *bvrs)
{ return NEW TupleBvrImpl(size, bvrs); }

Bvr Nth(Bvr tuple, long index)
{ return NEW TupleNthBvrImpl(tuple, index); }

long TupleLength(Bvr tuple)
{
    if (tuple->GetBvrTypeId() != TUPLE_BTYPEID)
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_TUPLE_LENGTH);

    return SAFE_CAST(TupleBvrImpl*,tuple)->Length();
}

Bvr Tuple2(Bvr b1, Bvr b2)
{
    Bvr *bvrs = (Bvr *) StoreAllocate(GetSystemHeap(), (2 * sizeof(Bvr)));

    bvrs[0] = b1;
    bvrs[1] = b2;

    return TupleBvr(2, bvrs);
}

AxAArray * MakeValueArray(AxAValue * vals, long num, DXMTypeInfo typeinfo)
{ return NEW AxAArray(vals, num, typeinfo, true, false); }


AxAArray *PackArray(AxAArray *inputArray)
{
    if (!inputArray->Changeable())
        return inputArray;

    int elts = inputArray->Length();
    int i;
    int emptySlots = 0;

    for (i = 0; i < elts; i++) {
        if ((*inputArray)[i] == NULL) {
            emptySlots++;
        }
    }

    if (emptySlots == 0) {
        return inputArray;
    }

    int fullSlots = elts - emptySlots;
        
    AxAValue *packedArray = 
        (AxAValue*) AllocateFromStore(sizeof(AxAValue) * fullSlots);

    int destSlot = 0;
    for (i = 0; i < elts; i++) {
        AxAValue val = (*inputArray)[i];
        if (val != NULL) {
            packedArray[destSlot++] = val;
        }
    }

    Assert(destSlot == fullSlots);
    AxAArray *result = NEW AxAArray(packedArray, fullSlots,
                                    inputArray->GetTypeInfo(), false, true);

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\apply.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Handling apply

*******************************************************************************/

#include <headers.h>
#include "privinc/except.h"
#include "perf.h"
#include "bvr.h"
#include "events.h"
#include "values.h"
#include "appelles/events.h"
#include "privinc/debug.h"
#include "server/context.h"


#define MAX_ARGS 5

AxAValue PrimDispatch (AxAPrimOp * primop, int nargs, AxAValue cargs[])
{
    Assert (nargs <= MAX_ARGS);
    Assert (nargs == primop->GetNumArgs());

    void * fun = primop->GetPrimFun();

    switch (nargs) {
            case 1:
                return ((AxAValue (_cdecl *) (AxAValue )) fun) (cargs[0]) ;
            case 2:
                return ((AxAValue (_cdecl *) (AxAValue ,AxAValue )) fun) (cargs[0],cargs[1]) ;
            case 3:
                return ((AxAValue (_cdecl *) (AxAValue ,AxAValue ,AxAValue )) fun) (cargs[0],cargs[1],cargs[2]) ;
            case 4:
                return ((AxAValue (_cdecl *) (AxAValue ,AxAValue ,AxAValue ,AxAValue )) fun) (cargs[0],cargs[1],cargs[2],cargs[3]) ;
            case 5:
                return ((AxAValue (_cdecl *) (AxAValue ,AxAValue ,AxAValue ,AxAValue ,AxAValue )) fun) (cargs[0],cargs[1],cargs[2],cargs[3],cargs[4]) ;

      default:
        RaiseException_InternalError ("Invalid # of arguments") ;
        return NULL;
    }
}

#if _USE_PRINT
static char *FuncMapOp(char *fname)
{
    if (!strcmp(fname, "RealModulus")) {
        return "%";
    } else if (!strcmp(fname, "RealMultiply")) {
        return "*";
    } else if (!strcmp(fname, "RealDivide")) {
        return "/";
    } else if (!strcmp(fname, "RealAdd")) {
        return "+";
    } else if (!strcmp(fname, "RealSubtract")) {
        return "-";
    } else if (!strcmp(fname, "RealLT")) {
        return "<";
    } else if (!strcmp(fname, "RealLTE")) {
        return "<=";
    } else if (!strcmp(fname, "RealGT")) {
        return ">";
    } else if (!strcmp(fname, "RealGTE")) {
        return ">=";
    } else if (!strcmp(fname, "RealEQ")) {
        return "==";
    } else if (!strcmp(fname, "RealNE")) {
        return "!=";
    } else if (!strcmp(fname, "RealSin")) {
        return "sin";
    } else if (!strcmp(fname, "RealCos")) {
        return "cos";
    } else {
        return fname;
    }
}

#endif 

////////////////////////// PrimApplyBvr ////////////////////////////////

class PrimApplyPerfImpl : public PerfImpl
{
  public:
    PrimApplyPerfImpl(AxAPrimOp * primFunc, int nargs, Perf * b) 
      : _func(primFunc),
        _nargs(nargs),
        _args(NEW Perf[nargs])
    {
        Assert (_nargs && (_nargs <= MAX_ARGS));
        memcpy (_args,b,_nargs * sizeof (*b));
    }

    ~PrimApplyPerfImpl() { CleanUp() ; }
    virtual void CleanUp() { delete [] _args; }
    
    virtual AxAValue _GetRBConst(RBConstParam& p) {
        AxAValue v[MAX_ARGS];
        bool isConst = true;
        
#ifdef _DEBUG
        bool doDCF = true;

        if (IsTagEnabled(tagDCFold))
            doDCF = false;
#endif _DEBUG

        for (int i = 0;i < _nargs;i++) {
            v[i] = _args[i]->GetRBConst(p);
            if (v[i] == NULL) {
                if (isConst)
                    isConst = false;
#ifdef _DEBUG
                if (!doDCF)
                    break;
#endif _DEBUG
            }
        }

        return isConst ? _func->Apply(_nargs, v) : NULL ;
    }

    virtual AxAValue _Sample(Param& p) {
        AxAValue v[MAX_ARGS];
        
        for (int i = 0;i < _nargs;i++) {
            v[i] = _args[i]->Sample(p);
        }

        return _func->Apply(_nargs, v) ;
    }

    AxAPrimOp * GetFunction() 
    { return _func; }

    Perf * GetArgs() 
    { return _args; }

    int GetNumArgs() 
    { return _nargs; }

    Perf & operator[](int index) {
        Assert (index < _nargs) ;
        return _args[index];
    }
    
    virtual void _DoKids(GCFuncObj proc) {
        for (int i = 0;i < _nargs;i++)
            (*proc)(_args[i]);
        (*proc)(_func);
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
//        os << "'" << "<" << (long)this << ">" << FuncMapOp(_func->GetName()) << "(";
        os << "'" << FuncMapOp(_func->GetName()) << "(";
        for (int i = 0;i < _nargs;i++) {
            _args[i]->Print(os);
            os << ((i==_nargs-1) ? ")" : ",");
        }
        //os << "</" << this << ">";
        return os;
    }
#endif

    virtual BVRTYPEID GetBvrTypeId() { return PRIMAPPLY_BTYPEID; }
  private:
    AxAPrimOp * _func;
    Perf * _args;
    int _nargs;
};

// TODO: We need a way to determine if we are constant folding view
// specific constants.  Right now it will constant fold and all views
// will share the constant

class PrimApplyBvrImpl : public BvrImpl {
  public:
    PrimApplyBvrImpl(AxAPrimOp * primFunc, int nargs, Bvr * b)
    : _func(primFunc),
      _const(NULL),
      _nargs(nargs),
      _knownNonConst(false),
      _infoCached(false),
      _endEvent(NULL),
      _args((Bvr *) StoreAllocate(GetGCHeap(), sizeof(Bvr) * nargs))
    {
        Assert (_nargs && (_nargs <= MAX_ARGS));
        memcpy (_args,b,_nargs * sizeof (Bvr));

        GetInfo(true);
    }

    ~PrimApplyBvrImpl() { StoreDeallocate(GetGCHeap(), _args); }

    virtual DWORD GetInfo(bool recalc) {
        
        if (recalc & !_infoCached) {
            _info = BVR_IS_CONSTANT;

            Perf c = GetConstVal();

            if (c==NULL) {
                for (int i=0; i<_nargs; i++) {
                    _info &= _args[i]->GetInfo(recalc);
                }
            }

            _infoCached = true;
        } 

        return _info;
    }
    
    virtual Bvr EndEvent(Bvr overrideEvent) {
        // This assumes that apply never returns array or tuple or any
        // other complex (structured) type
        
        if (overrideEvent)
            return overrideEvent;
        
        CritSectGrabber csg(_cs);

        if (_endEvent)
            return _endEvent;
        
        if (GetConstVal())
            return neverBvr;

        Bvr *events =
            (Bvr *) StoreAllocate(GetGCHeap(), sizeof(Bvr) * _nargs);

        for (int i=0; i<_nargs; i++) {
            events[i] = _args[i]->EndEvent(NULL);
            if (events[i] == neverBvr) {
                StoreDeallocate(GetGCHeap(), events);
                return (_endEvent = neverBvr);
            }
        }
        
        return (_endEvent = MaxEvent(events, _nargs));
    }
    
    virtual Perf _Perform(PerfParam& p) {
        Perf c = GetConstVal();

        if (c) return c;

        if (!IsKnownNonConst()) {

            AxAValue v = NULL;

            /* push the context transient heap on to the top of the
               transient heap stack.    That way any constant values
               created by GetConst are stored there.

               The transient heap stack is implicitly popped when
               pusher goes out of scope below. */

            {
                DynamicHeapPusher pusher(GetGCHeap());

                AxAValue vals[MAX_ARGS];
                ConstParam cp;

                for (int i = 0;i< _nargs;i++) {
                    if ((vals[i] = _args[i]->GetConst(cp)) == NULL) {
                        SetKnownNonConst();
                        break;
                    }
                }

                if (i == _nargs) 
                    v = _func->Apply(_nargs, vals);
            }

            if (v) {
                Perf c = ConstPerf(v);
                SetConstVal(c);
                return c;
            }
        
        } 

        Perf argperf[MAX_ARGS];
        
        for (int i = 0;i < _nargs;i++) 
            argperf[i] = ::Perform(_args[i],p);

        return NEW PrimApplyPerfImpl(_func, _nargs, argperf);
    }

    virtual AxAValue GetConst(ConstParam & cp) {
        {
            Perf cv = GetConstVal();
            
            if (cv)
                return GetPerfConst(cv);
        }
        
        AxAValue v[MAX_ARGS];

        for (int i = 0;i < _nargs;i++) {
            if ((v[i] = _args[i]->GetConst(cp)) == NULL)
                return NULL;
        }

        DynamicHeapPusher heap(GetGCHeap());
            
        AxAValue c = _func->Apply(_nargs, v);

        SetConstVal(ConstPerf(c));

        return c;
    }
    
    virtual void _DoKids(GCFuncObj proc) {
        // TODO: We should not need to GC the args once the
        // performance has been created
        
        Perf v = GetConstVal();
        
        if (v) {
            (*proc)(v);
        } else {
            // NOTE: GC assumption: no GC during perform or sample!
            for (int i = 0;i < _nargs;i++)
                (*proc)(_args[i]);
        }

        (*proc)(_func);
        (*proc)(_endEvent);
    }

    // Only synchronize here so we do not have the critical section
    // across function calls
    
    Perf GetConstVal() {
        CritSectGrabber csg(_cs);
        return _const;
    }

    void SetConstVal(Perf v) {
        CritSectGrabber csg(_cs);
        _const = v;

        // Known to be constant, let args be GC'ed
        for (int i = 0;i < _nargs;i++)
            _args[i]=NULL;
    }

    bool IsKnownNonConst() {
        CritSectGrabber csg(_cs);
        return _knownNonConst;
    }

    void SetKnownNonConst() {
        CritSectGrabber csg(_cs);
        _knownNonConst = false;
    }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        ConstParam cp;
        Perf cv = GetConstVal();

//        os << "'" << "<" << (long)(this) << ">" << FuncMapOp(_func->GetName()) << "(";

        os << "'" << FuncMapOp(_func->GetName()) << "(";

        if (cv) {
            return os << "folded" << _nargs << "(" << cv << ")";
        }
        
        for (int i = 0;i < _nargs;i++) {
            _args[i]->Print(os);
            os << ((i==_nargs-1) ? ")" : ",");
        }
        //os << "</" << reinterpret_cast<long>(this) << ">";
        return os;
    }
#endif

    virtual DXMTypeInfo GetTypeInfo () {

        DXMTypeInfo ti = _func->GetTypeInfo();

        // If the info is NULL, that means that we should get our
        // output type from the type of a specific argument.
        if (!ti) {
            int polymorphicArg = _func->GetPolymorphicArg();
            Assert(polymorphicArg > 0 && polymorphicArg < _nargs);
            ti = _args[polymorphicArg-1]->GetTypeInfo();
            Assert(ti);
        }

        return ti;
    }

    virtual BVRTYPEID GetBvrTypeId() { return PRIMAPPLY_BTYPEID; }
    
  private:
    AxAPrimOp * _func;
    Perf _const;
    Bvr * _args;
    int _nargs;
    CritSect _cs;
    Bvr _endEvent;              // Cache end event
    DWORD _info;
    bool _knownNonConst, _infoCached;
};

Bvr PrimApplyBvr(AxAPrimOp * func,
                 int nArgs,
                 ...)
{
    Assert (nArgs <= MAX_ARGS);

    va_list args;

    va_start(args, nArgs) ;
    
    Bvr b[MAX_ARGS];

    DynamicHeapPusher h(GetGCHeap());
    
    for (int i = 0;i < nArgs;i++) {
        b[i] = va_arg(args,Bvr);
    }

#if _DEBUG
    if(IsTagEnabled(tagNoApplyFolding))
        return NEW PrimApplyBvrImpl(func, nArgs, b);
#endif    

    AxAValue v[MAX_ARGS];
    ConstParam cp;
    
    for (i = 0;i < nArgs;i++) {
        v[i] = b[i]->GetConst(cp);
        if (v[i] == NULL) {
            return NEW PrimApplyBvrImpl(func, nArgs, b);
        }
    }

    return ConstBvr(func->Apply(nArgs, v));
}

BOOL IsApp(Perf p)
{ return (p->GetBvrTypeId() == PRIMAPPLY_BTYPEID); }

Perf GetOperand(Perf p, int index)
{
    Assert (DYNAMIC_CAST(PrimApplyPerfImpl *, p));
    return (*((PrimApplyPerfImpl *) p))[index]; 
}

void SetOperand(Perf p, int index, Perf newperf)
{
    Assert (DYNAMIC_CAST(PrimApplyPerfImpl *, p));
    (*((PrimApplyPerfImpl *) p))[index] = newperf; 
}

int GetNumOperands(Perf p)
{
    Assert (DYNAMIC_CAST(PrimApplyPerfImpl *, p));
    return ((PrimApplyPerfImpl *) p)->GetNumArgs(); 
}

AxAValue GetOperator(Perf p)
{ Assert (DYNAMIC_CAST(PrimApplyPerfImpl *, p));
  return ((PrimApplyPerfImpl *) p)->GetFunction(); 
}

Perf PrimApplyPerf(AxAPrimOp * f, int nargs, Perf * a)
{ return (NEW PrimApplyPerfImpl(f,nargs,a)); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\bvr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Behavior evaluation

*******************************************************************************/

#include <headers.h>
#include "privinc/except.h"
#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "privinc/server.h"
#include "privinc/resource.h"
#include "appelles/events.h"
#include "privinc/debug.h"

#if _USE_PRINT
ostream& operator<<(ostream& os, Bvr bvr)
{ return bvr->Print(os); }
#endif

Perf Perform(Bvr b, PerfParam& p)
{
    Assert(b && p._tt && (p._t0 == p._tt->GetStartedTime()));

    return b->Perform(p);
}

RMImpl *BvrBase::Spritify(PerfParam& p,
                          SpriteCtx* ctx,
                          SpriteNode** sNodeOut)
{
    // TODO: Should throw an exception
    *sNodeOut = NULL;
    
    return NULL;
}

void BvrImpl::SetCache(Perf p, PerfParam& pp)
{
    _pcache = p;
    _tt = pp._tt;
}

void BvrImpl::ClearCache()
{
    _pcache = NULL;
    _tt = NULL;
}

Perf BvrImpl::Perform(PerfParam& p)
{
    bool matchTx = (p._tt == _tt) && (p._t0 == _tt->GetStartedTime());

    // If same t0 & timexform, but cache is NULL, cycle detected.
    if (!_pcache && matchTx) {
#ifdef _DEBUG
        if (IsTagEnabled(tagCycleCheck))
            //TraceTag((tagError, "circular behavior detected"));
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_CYCLIC_BVR);
#endif _DEBUG    
    }
    
    // If no cache, or if timexform not matched, create new
    // performance.  Set cache to NULL and timexform to tt to indicate
    // performing this bvr in progress.  
    if (!_pcache || !matchTx) {
        _pcache = NULL;
        _tt = p._tt;
        _pcache = _Perform(p);
    }

    return _pcache;
}

void BvrImpl::DoKids(GCFuncObj proc)
{
    if (_pcache)
        (*proc)(_pcache);

    if (_tt)
        (*proc)(_tt);
    
    _DoKids(proc);
}

Bvr BvrBase::Left()
{ return FirstBvr(this); }

Bvr BvrBase::Right()
{ return SecondBvr(this); }

void BvrBase::Init(Bvr)
{ RaiseException_InternalError("Bvr can't be initialized"); }

Bvr BvrBase::EndEvent(Bvr overrideEvent)
{ return overrideEvent?overrideEvent:neverBvr; }

void BvrBase::Trigger(Bvr data, bool bAllViews)
{
    RaiseException_UserError(E_FAIL, IDS_ERR_BE_WRONG_TRIGGER);
}

void BvrBase::SwitchTo(Bvr b,
                       bool override,
                       SwitchToParam p,
                       Time)
{
    RaiseException_UserError(E_FAIL, IDS_ERR_BE_BAD_SWITCH);
}                             

void BvrBase::SwitchToNumbers(Real *numbers,
                              Transform2::Xform2Type *xfType)
{
    RaiseException_UserError(E_FAIL, IDS_ERR_BE_BAD_SWITCH);
}                             

Bvr BvrBase::GetCurBvr()
{
    RaiseException_UserError(E_FAIL, IDS_ERR_BE_BAD_SWITCH);
    return NULL;
}                             

void
CheckMatchTypes(char *str, DXMTypeInfo t1, DXMTypeInfo t2)
{
    if (!(t1->Equal(t2))) {
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_TYPE_MISMATCH,
                           str,
                           t1->GetName(),
                           t2->GetName());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\basic.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Basic Primitives 

*******************************************************************************/

#include <headers.h>
#include "privinc/except.h"
#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "timetran.h"
#include "events.h"
#include "appelles/axaprims.h"
#include "appelles/events.h"
#include "appelles/hacks.h"
#include "appelles/arith.h"
#include "privinc/server.h"
#include "privinc/probe.h"
#include "privinc/vec2i.h"
#include "privinc/soundi.h"
#include "axadefs.h"
#include "jaxaimpl.h"

////////////////////////// Time ////////////////////////////////

class TimePerfImpl : public PerfImpl {
  public:
    TimePerfImpl(TimeXform tt) : _tt(tt) { Assert(tt); }
    
    virtual AxAValue _Sample(Param& p) {
        return NEW AxANumber(EvalLocalTime(p, _tt));
    }
    
    virtual void _DoKids(GCFuncObj proc) { (*proc)(_tt); }

    virtual AxAValue GetRBConst(RBConstParam& id)
    { return _tt->GetRBConst(id); }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        os << "time(";
        _tt->Print(os);
        return os << ")";
    }
#endif
    
  private:
    TimeXform _tt;
};

class TimeBvrImpl : public BvrImpl {
  public:
    virtual DWORD GetInfo(bool) { return BVR_TIMEVARYING_ONLY; }
    
    virtual Perf _Perform(PerfParam& p)
    { return NEW TimePerfImpl(p._tt); }

    virtual void _DoKids(GCFuncObj) { }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "time"; }
#endif

    virtual DXMTypeInfo GetTypeInfo () { return AxANumberType ; }
};

class GlobalTimeBvrImpl : public TimeBvrImpl {
  public:
    virtual Perf _Perform(PerfParam& p)
    { return NEW TimePerfImpl(ShiftTimeXform(0.0)); }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "GlobalTime"; }
#endif
};

class ViewInfoPerfImpl : public PerfBase {
  public:
    ViewInfoPerfImpl(char *name, double (*fp)()) : _name(name), _fp(fp) {}

    virtual AxAValue GetRBConst(RBConstParam&) { return NULL; }

    virtual AxAValue Sample(Param&)
    { return NEW AxANumber((*_fp)()); }

    virtual void DoKids(GCFuncObj) {}
        
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _name; }
#endif

  private:
    char *_name;
    double (*_fp)();
};

class ViewInfoBvrImpl : public BvrBase {
  public:
    ViewInfoBvrImpl(char *name, double (*fp)()) 
    : _perf(NEW ViewInfoPerfImpl(name, fp)) {}
    
    virtual DWORD GetInfo(bool) { return BVR_TIMEVARYING_ONLY; }
    
    virtual Perf Perform(PerfParam& p) { return _perf; }

    virtual void DoKids(GCFuncObj proc) { (*proc)(_perf); }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return _perf->Print(os); }
#endif

    virtual DXMTypeInfo GetTypeInfo () { return AxANumberType ; }

  protected:
    Perf _perf;
};

// This dynamic const behavior takes a function and creates a constant
// out of it when it's performed.   An argument can be passed.
class DynamicConstBvr : public BvrImpl {
  public:
    DynamicConstBvr(AxAValue (*fp)(AxAValue, Real),
                    char *name,
                    DXMTypeInfo type,
                    AxAValue arg = Trivial())
    : _fp(fp), _data(arg), _name(name), _typeInfo(type) {}

    virtual Perf _Perform(PerfParam& p) {
        DynamicHeapPusher pusher(GetGCHeap());
        return ConstPerf((*_fp)(_data, p._t0));
    }

    virtual void _DoKids(GCFuncObj proc) { 
        (*proc)(_typeInfo); 
        (*proc)(_data);
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _name; }
#endif

    virtual DXMTypeInfo GetTypeInfo () { return _typeInfo; }
                                                  
  private:
    AxAValue (*_fp)(AxAValue, Real);
    AxAValue _data;
    char * _name;
    DXMTypeInfo _typeInfo;
};

Point2Value *GetMousePosition(double time)
{
    DWORD x,y ;
    
    AXAGetMousePos(time, x, y);

    return PixelPos2wcPos((short)x, (short)y);
}

Point2Value *MousePosition(AxANumber* time)
{ return GetMousePosition(ValNumber(time)); }

AxAValue LeftButtonState(AxANumber* time)
{
    return NEW AxABoolean(AXAEventGetState(ValNumber(time),
                                           AXAE_MOUSE_BUTTON,
                                           AXA_MOUSE_BUTTON_LEFT,
                                           AXAEMOD_NONE));
}

AxAValue RightButtonState(AxANumber* time)
{
    return NEW AxABoolean(AXAEventGetState(ValNumber(time),
                                           AXAE_MOUSE_BUTTON,
                                           AXA_MOUSE_BUTTON_RIGHT,
                                           AXAEMOD_NONE));
}

static Bvr trivial;

Bvr trueBvr, falseBvr;
Bvr timeBvr, globalTimeBvr;

Bvr endBvr, doneBvr;

Bvr alwaysBvr, neverBvr;

Bvr leftButtonDown, leftButtonUp, rightButtonDown, rightButtonUp;
Bvr leftButtonState, rightButtonState;

Bvr mousePosition;

Bvr pixelBvr;

Bvr zeroBvr;
Bvr oneBvr;
Bvr negOneBvr;

Bvr PixelBvr() { return pixelBvr; }

Bvr TimeBvr() { return timeBvr; }

Bvr TrivialBvr() { return trivial; }

// Make them reactive behaviors instead of time varying so that we can
// detact constant at the top level and do smart rendering.

Bvr viewFrameRateBvr;
Bvr viewTimeDeltaBvr;

/*
Bvr PRIVWindowResize;
Bvr PRIVViewerUpperRight;
Bvr PRIVViewerResolution;
*/

static AxAValue ViewerUpperRight(AxAValue data, Real time)
{ return PRIV_ViewerUpperRight(RealToNumber(time)); }

static AxAValue ViewerResolution(AxAValue data, Real time)
{ return PRIV_ViewerResolution(RealToNumber(time)); }

static AxAValue KeyState(Real key, Real time)
{
    return NEW AxABoolean(AXAEventGetState(time,
                                           AXAE_KEY,
                                           (DWORD) key,
                                           AXAEMOD_NONE));
}

static AxAValue ConstKeyState(AxAValue key, Real time)
{
    Real k = ValNumber(key);

    return KeyState(k, time);
}

Bvr PRIVKeyStateBvr(Bvr key)
{
    ConstParam cp;
    AxAValue k = key->GetConst(cp);

    if (k) {
        DynamicHeapPusher pusher(GetGCHeap());

        AxAValue c = NEW AxANumber(ValNumber(k));
        
        return
            NEW DynamicConstBvr(ConstKeyState,
                                "ConstKeyState",
                                AxABooleanType,
                                c);
    }
    else
        return PrimApplyBvr(ValPrimOp(KeyState,
                                      2,
                                      "KeyState",
                                      AxABooleanType),
                            2,
                            key,
                            globalTimeBvr);
}

Bvr KeyStateBvr(Bvr key)
{
    Bvr keyState = PRIVKeyStateBvr(key);
    Bvr ks = InitBvr(AxABooleanType);

    SetInitBvr(ks,
               Until3(keyState, 
                      OrEvent(MakeKeyUpEventBvr(key),
                              MakeKeyDownEventBvr(key)),
                      ks));

    return ks;
}

Bvr SeededRandom(double seed)
{
    AxAValue rs = RandomNumSequence(seed);
        
    return PrimApplyBvr(ValPrimOp(PRIVRandomNumSampler,
                                  2,
                                  "seededRandom",
                                  AxANumberType),
                        2,
                        ConstBvr(rs),
                        timeBvr);
}

extern AxAEData *noEvent = NULL;

AxAEData *CreateEData(Time time, Bvr data)
{ return NEW AxAEData(time, data); }

extern PerfParam* zeroStartedPerfParam = NULL;
extern TimeXform zeroShiftedTimeXform = NULL;

extern Bvr zeroTimer = NULL;

Bvr
NumToBvr (double num)
{
    DynamicHeapPusher h(GetGCHeap());
    return ConstBvr(NEW AxANumber(num)) ;
}

AxAValue
ExtendedAttrib(AxAValue val,
               AxAString *str,
               AxAVariant *var)
{
    USES_CONVERSION;
    char *pname = W2A(str->GetStr());
    
    return val->ExtendedAttrib(pname,
                               var->GetVariant());
}

AxAPrimOp * 
ValPrimOp(void* primfun,
          int nargs,
          char * name,
          DXMTypeInfo type,
          int polymorphicArgument /*= 0*/)
{ 
    // instead of relying on the caller to push the right heap, be
    // defensive here. 
    if (!IsInitializing() && GetHeapOnTopOfStack().IsTransientHeap()) {
        DynamicHeapPusher h(GetGCHeap());

        return NEW AxAPrimOp(primfun,nargs,name,type,polymorphicArgument); 
    }

    return NEW AxAPrimOp(primfun,nargs,name,type,polymorphicArgument);    
}

void
InitializeModule_Bvr()
{
    timeBvr = NEW TimeBvrImpl();
    globalTimeBvr = NEW GlobalTimeBvrImpl();
    trivial = ConstBvr(Trivial());
    // Return pixel as a time-varying behavior dependent upon
    // resolution.  However, don't actually allow it to change for the
    // time being.  Future implementations will allow this to change. 
    pixelBvr = ConstBvr(NEW AxANumber(1.0 / ViewerResolution()));
    leftButtonDown = WindEvent(WE_MOUSEBUTTON,
                               AXA_MOUSE_BUTTON_LEFT,
                               AXA_STATE_DOWN,
                               trivial);
    leftButtonUp = WindEvent(WE_MOUSEBUTTON,
                             AXA_MOUSE_BUTTON_LEFT,
                             AXA_STATE_UP,
                             trivial);
    rightButtonDown = WindEvent(WE_MOUSEBUTTON,
                                AXA_MOUSE_BUTTON_RIGHT,
                                AXA_STATE_DOWN,
                                trivial);
    rightButtonUp = WindEvent(WE_MOUSEBUTTON,
                              AXA_MOUSE_BUTTON_RIGHT,
                              AXA_STATE_UP,
                              trivial);
    /*
    PRIVWindowResize = WindEvent(WE_RESIZE,
                                 0,
                                 0,
                                 trivial);
                                 */

    mousePosition =
        PrimApplyBvr(ValPrimOp(MousePosition,
                               1,
                               "MousePosition",
                               Point2ValueType),
                     1,
                     globalTimeBvr);

    // TODO: should be rewritten something like leftButtonState until 
    // (leftButtonUp | leftButtonDown) => leftButtonState
    // so that we can do constant folding.
    
    leftButtonState =
        PrimApplyBvr(ValPrimOp(LeftButtonState, 1,
                               "LeftButtonState", AxABooleanType),
                     1,
                     globalTimeBvr);

    rightButtonState =
        PrimApplyBvr(ValPrimOp(RightButtonState, 1,
                               "RightButtonState", AxABooleanType),
                     1,
                     globalTimeBvr); 
    
    trueBvr = ConstBvr(NEW AxABoolean(TRUE));
    falseBvr = ConstBvr(NEW AxABoolean(FALSE));

    zeroBvr = ConstBvr(zero);
    oneBvr = ConstBvr(one);
    negOneBvr = ConstBvr(negOne);

    noEvent = NEW AxAEData();

    alwaysBvr = PredicateEvent(trueBvr);
    neverBvr = ConstBvr(noEvent);

    zeroTimer = TimerEvent(zeroBvr);

    /*
    PRIVViewerUpperRight =
        NEW DynamicConstBvr(ViewerUpperRight,
                            "PRIVViewerUpperRight",
                            Point2ValueType);
                                               
    PRIVViewerResolution =
        NEW DynamicConstBvr(ViewerResolution,
                            "PRIVViewerResolution",
                            AxANumberType);
                            */
    
    zeroShiftedTimeXform = ShiftTimeXform(0);
    
    zeroStartedPerfParam = NEW PerfParam(0, zeroShiftedTimeXform);

    viewFrameRateBvr = NEW ViewInfoBvrImpl("FPS", ViewGetFrameRate);
    viewTimeDeltaBvr = NEW ViewInfoBvrImpl("TimeDelta", ViewGetTimeDelta);
}

void
DeinitializeModule_Bvr(bool bShutdown)
{
    delete zeroStartedPerfParam;
    zeroStartedPerfParam = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\bvr.h ===
/*******************************************************************************
Copyright (c) 1996-1998 Microsoft Corporation.  All rights reserved.

    Behavior Data Structures

*******************************************************************************/

#ifndef _BVR_H
#define _BVR_H

#include "privinc/backend.h"
#include "privinc/basic.h"
#include "privinc/xform2i.h"
#include "privinc/util.h"
#include "gc.h"
#include "timetran.h"
#include "preference.h"
#include "dartapi.h"              // for DAContinueTimeline

class RMImpl;
class SpriteCtx;
class SpriteNode;
class Param;

struct PerfParam
{
    PerfParam(Time t0, TimeXform tt)
    : _t0(t0), _tt(tt), _continue(false), _lastSystemTime(0), _p(NULL)
    {
    }

    PerfParam(Time t0, TimeXform tt,
              bool b, DWORD stime, Param* p)
    : _t0(t0), _tt(tt), _continue(b), _lastSystemTime(stime), _p(p)
    {
    }

    Time _t0;
    TimeXform _tt;
    DWORD _lastSystemTime;
    Param* _p;
    bool _continue;
};

struct ConstParam
{
    ConstParam(bool bAllowTempConst = false)
    : _bAllowTempConst(bAllowTempConst)
    {
    }

    bool _bAllowTempConst;
};

extern PerfParam* zeroStartedPerfParam;
extern TimeXform  zeroShiftedTimeXform;

typedef DWORD SwitchToParam;
const DWORD SW_DEFAULT = 0;
const DWORD SW_CONTINUE = CRContinueTimeline;
const DWORD SW_FINAL = CRSwitchFinal;
const DWORD SW_SYNC_NEXT = CRSwitchNextTick;
const DWORD SW_WITH_TIME = CRSwitchAtTime;
const DWORD SW_SYNC_LAST = CRSwitchCurrentTick;

#define BVR_HAS_ALL 0x0
#define BVR_HAS_NO_UNTIL 0x1
#define BVR_HAS_NO_SWITCHER 0x2
#define BVR_HAS_NO_ODE  0x4
#define BVR_NOT_TIMEVARYING 0x8

#define BVR_IS_CONSTANT 0xFFFFFFFF
#define BVR_TIMEVARYING_ONLY (~BVR_NOT_TIMEVARYING)
    
class ATL_NO_VTABLE BvrBase : public GCObj {
  public:
    virtual RMImpl *Spritify(PerfParam& p,
                             SpriteCtx* ctx,
                             SpriteNode** sNodeOut);

    // Since it's an optimization, let's be conservative
    virtual DWORD GetInfo(bool recalc = false) { return BVR_HAS_ALL; }
        
    virtual Perf Perform(PerfParam&) = 0;

    virtual AxAValue GetConst(ConstParam & cp) { return NULL; }

    // Might this be shared by other behaviors?
    virtual bool     GetShared() { return true; }

    virtual BOOL InterruptBasedEvent() { return FALSE; }

    // For sequence optimization
    virtual bool IsSequence() { return false; }
    virtual Bvr GetRaw() { return this; }

    virtual Bvr GetTimer() { return NULL; }

    virtual void DoKids(GCFuncObj proc) = 0;

    // This is for DurationBvr or other constructs that support end. 
    virtual Bvr EndEvent(Bvr overrideEvent);

    // This is for pair optimization.  If we restrict the formal
    // parameter can't be a time varying pair, we may not need that.

    virtual Bvr Left();

    virtual Bvr Right();

    virtual void Trigger(Bvr data, bool bAllViews);

    virtual void SwitchTo(Bvr b,
                          bool override,
                          SwitchToParam p,
                          Time gTime);
    
    virtual void SwitchToNumbers(Real *numbers,
                                 Transform2::Xform2Type *xfType);

    // for switchers
    virtual Bvr GetCurBvr();
    virtual bool IsFinalized() { return false; }
    
    // Use by Trigger & SwitchTo only
    virtual Bvr Nth(int i) { return NULL; }

    // To support uninitialized bvr in the Java API
    virtual void Init(Bvr bvr);

    virtual DXMTypeInfo GetTypeInfo () { return NULL ; }

    virtual BVRTYPEID GetBvrTypeId() { return UNKNOWN_BTYPEID; }
};

class ATL_NO_VTABLE BvrImpl : public BvrBase {
  public:

    BvrImpl() : _pcache(NULL), _tt(NULL) {}

    // This will check the cache and call _Perform.
    virtual Perf Perform(PerfParam& p);

    virtual void DoKids(GCFuncObj proc);

    // Subclass should define these two functions and never call them
    // directly.  The DoKids function will traverse the cache first
    // before calling _DoKids.   The cache will live across samples,
    // thus it needs to be traversed.

    virtual void _DoKids(GCFuncObj proc) = 0;

    virtual Perf _Perform(PerfParam&) = 0;

    void SetCache(Perf p, PerfParam& pp);

    virtual void ClearCache();
  protected:
    Perf _pcache;
    TimeXform _tt;
};

#if _USE_PRINT
ostream& operator<<(ostream& os, Bvr bvr);
#endif

class ATL_NO_VTABLE DelegatedBvr : public BvrImpl {
  public:
    DelegatedBvr(Bvr base) : _base(base) {}

    virtual RMImpl *Spritify(PerfParam& p,
                             SpriteCtx* ctx,
                             SpriteNode** sNodeOut) {
        return _base->Spritify(p, ctx, sNodeOut);
    }

    virtual DWORD GetInfo(bool recalc = false) { return _base->GetInfo(recalc); }
        
    virtual AxAValue GetConst(ConstParam & cp) { return _base->GetConst(cp); }

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_base); }

    virtual Bvr EndEvent(Bvr overrideEvent) { return _base->EndEvent(overrideEvent); }

    virtual DXMTypeInfo GetTypeInfo () { return _base->GetTypeInfo(); }

    virtual BVRTYPEID GetBvrTypeId() { return _base->GetBvrTypeId(); }

    virtual Bvr GetTimer() { return _base->GetTimer(); }

  protected:
    Bvr _base;
};

Perf Perform(Bvr b, PerfParam& p);

Bvr ConstBvr(AxAValue c);

Bvr UnsharedConstBvr(AxAValue c);

Bvr PairBvr(Bvr a, Bvr b);

Bvr ListBvr(Bvr *lst, int n);

Bvr TimeBvr();

Bvr PixelBvr();

Bvr UntilBvr(Bvr b0, Bvr event);

Bvr PrimApplyBvr(AxAPrimOp * func,
                 int nArgs,
                 ...);

Bvr FirstBvr(Bvr p);

Bvr SecondBvr(Bvr p);

Bvr TrivialBvr();

Bvr LeafBvr(AxAValue c);

Bvr CondBvr(Bvr c, Bvr i, Bvr e);

Bvr ArrayBvr(long size, Bvr *bvrs, bool sizeChangeable = false);
long ArrayAddElement(Bvr arr, Bvr b, DWORD flag);
void ArrayRemoveElement(Bvr arr, long i);
void ArraySetElement(Bvr arr, long i, Bvr b, DWORD flag);
Bvr ArrayGetElement (Bvr, long);
long ArrayExtractElements(Bvr a, Bvr *&ret);

Bvr Nth(Bvr array, Bvr index);

Bvr TupleBvr(long size, Bvr *bvrs);

Bvr Nth(Bvr tuple, long index);

long TupleLength(Bvr tuple);

// Utility to create pair
Bvr Tuple2(Bvr b1, Bvr b2);

Bvr SwitcherBvr(Bvr b, SwitchToParam p = SW_DEFAULT);

void SwitchTo(Bvr s, Bvr b,
              bool override,
              SwitchToParam p,
              Time gTime = 0.0);

void SwitchToNumbers(Bvr s,
                     Real *numbers,
                     Transform2::Xform2Type *xfType = NULL);

Bvr GetCurSwitcherBvr(Bvr s);
bool IsSwitcher(Bvr bvr);

void ImportSignal(Bvr b, HRESULT hr = S_OK, char * errStr = NULL);
void ImportSignal(Bvr b, HRESULT hr, LPCWSTR errStr);
bool IsImport(Bvr bvr);
HRESULT ImportStatus(Bvr bvr);
class IImportSite;
IImportSite * GetImportSite(Bvr bvr);

// switch once behaviors

Bvr SwitchOnceBvr(Bvr b);

inline void SwitchOnce(Bvr s, Bvr b) { SwitchTo (s,b,true,SW_FINAL); }

Bvr ImportSwitcherBvr(Bvr b, bool bAsync);

Bvr SeededRandom(double seed);

Bvr TimeXformBvr(Bvr b, Bvr tb);

Bvr ImportanceBvr(Real importanceValue, Bvr b);

void PickableImage(Bvr rawImage, bool ignoresOcclusion,
                   Bvr& pImage, Bvr& pEvent);

void PickableGeometry(Bvr rawGeometry, bool ignoresOcclusion,
                      Bvr& pGeometry, Bvr& pEvent);

Bvr ImageAddId(Bvr img, long id, bool ignoresOcclusion);

Bvr GeometryAddId(Bvr geo, long id, bool ignoresOcclusion);
    
void CheckMatchTypes(char *str, DXMTypeInfo t1, DXMTypeInfo t2);

Bvr NumToBvr(double n);
Bvr LongToBvr(long n);
Bvr StringToBvr(WideString str);
Bvr BoolToBvr(bool b);

Bvr SampleAtLocalTime(Bvr b, Time localTime);

bool BvrIsPure1(Bvr b);
bool BvrIsPure(Bvr b);

Bvr EndBvr(Bvr b, Bvr endEvent);

extern Bvr zeroBvr;
extern Bvr oneBvr;
extern Bvr negOneBvr;

#if _USE_PRINT
ostream& operator<<(ostream& s, Bvr b);
#endif

#endif /* _BVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\comuntil.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Until code for COM, should merge with the file in until.cpp which
    contains axa language specific code.

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "timetran.h"
#include "privinc/server.h"
#include "jaxaimpl.h"
#include "events.h"
#include "sprite.h"

class UntilSWPerfImpl : public PerfImpl {
  public:
    UntilSWPerfImpl(Perf until) : _switch(until) {}

    virtual AxAValue _Sample(Param& p) {

        _switch = _switch->SwitchTo(p);

        return _switch->Sample(p);
    }

    // This is to pick up the case that it switches to a constant, so
    // we can constant fold it.
    
    virtual AxAValue _GetRBConst(RBConstParam& id)
    { return _switch->GetRBConst(id); }

    virtual Perf SwitchTo(Param&) { return _switch; }

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_switch); }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _switch; }
#endif

    virtual BVRTYPEID GetBvrTypeId() { return SWITCH_BTYPEID; }
  protected:
    Perf _switch;
};

BOOL IsSwitch(Perf p)
{ return (p->GetBvrTypeId() == SWITCH_BTYPEID); }

Perf UntilSWPerf(Perf p)
{ return NEW UntilSWPerfImpl(p); }

class UntilPerfImpl : public PerfImpl {
  public:
    UntilPerfImpl(Perf p0, Perf event, TimeXform tt, DXMTypeInfo type)
    : _p0(p0), _event(event), _p1(NULL), _te(0.0), _tt(tt),
      _type(type), _changed(false) {
        Assert(p0);
        _b0 = StartedBvr(_p0, type);
    }

    virtual AxAValue _GetRBConst(RBConstParam& p) {
        if (_p1) {
            AxAValue ret = _p1->GetRBConst(p);
            if (_changed) {
                _changed = false;
            }
            return ret;
        } else {
            p.AddEvent(this);
            return _p0->GetRBConst(p);
        }
    }

    virtual void _DoKids(GCFuncObj proc) {
        if (_p1) (*proc)(_p1);
        (*proc)(_p0);
        (*proc)(_event);
        (*proc)(_tt);
        (*proc)(_b0);
        (*proc)(_type);
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        os << "until(";
        if (_p0)
            os << _p0;
        os << ",";
        if (_p1)
            os << _p1;
        return os << "," << _event << ")";
    }
#endif

    virtual AxAValue _Sample(Param& p) {

        // If we already switched, check the sample time.  Usually it
        // would be greater than _te, but not true for snapshot.
        if (_p1) {
            if (p._time > _te) 
                return _p1->Sample(p);
            else 
                return _p0->Sample(p);
        } 

        Assert(_p0 && (_p1 == NULL));
            
        AxAValue v = _p0->Sample(p);

        if (!p._checkEvent)
            return v;

        SetCache(v, p);

        // When sampling _p0, is it possible to sample itself and
        // set _p1?

        Assert(!_p1 && "until samples back!");
        
        if (_p1) {
            if (p._time > _te) 
                return _p1->Sample(p);
            else 
                return _p0->Sample(p);
        } 

        // Haven't switched yet, check for the event.
            
        Bvr old = p._currPerf;
        p._currPerf = _b0;
        AxAEData *edata = ValEData(_event->Sample(p));
        p._currPerf = old;

        if (edata->Happened()) {
            _te = edata->HappenedTime();
            TimeXform tt = Restart(_tt, _te, p);
            Bvr data = edata->EventData();
            CheckMatchTypes("until", _type, data->GetTypeInfo());
            _p1 = Perform(data, PerfParam(_te, tt));
            _changed = true;

            if (p._time > _te)
                return _p1->Sample(p);
        }

        return v;
    }

    Perf SwitchTo(Param& p) {
        // If already switched and switched time is less than cut off
        // time, that means we'll never sample backward less than that
        // time.  Thus we can switch safely.

        if (_p1 && (_te < p._cutoff) && (p._time > _te))
            return _p1->SwitchTo(p);

        return this;
    }

    virtual BVRTYPEID GetBvrTypeId() { return UNTIL_BTYPEID; }
  protected:
    Perf _p0, _p1, _event;
    TimeXform _tt;
    Time _te;
    Bvr _b0;
    DXMTypeInfo _type;
    bool _changed;
};


BOOL IsUntil(Perf p)
{ return (p->GetBvrTypeId() == UNTIL_BTYPEID); }

Bvr Until3(Bvr b0, Bvr event, Bvr b1)
{
    CheckMatchTypes("until", b0->GetTypeInfo(), b1->GetTypeInfo());
    
    return Until(b0, HandleEvent(event, b1));
}    

class UntilEndNotifierImpl : public UntilNotifierImpl {
  public:
    virtual Bvr Notify(Bvr eventData, Bvr curRunningBvr)
    { return eventData->EndEvent(NULL); }
};

class Until2BvrImpl : public BvrImpl {
  public:
    Until2BvrImpl(Bvr b0, Bvr event) : _b0(b0), _event(event)
    { GetInfo(true);}

    virtual DWORD GetInfo(bool recalc) {
        if (recalc) {
            _info = ~BVR_HAS_NO_UNTIL & _b0->GetInfo(recalc);
                //& _event->GetInfo(recalc)
        }

        return _info;
    }
        
    // TODO: Share the notifier.
    virtual Bvr EndEvent(Bvr overrideEvent) {
        return Until(_b0->EndEvent(overrideEvent),
                     NotifyEvent(_event,
                                 NEW UntilEndNotifierImpl()));
    }
    
    RMImpl *Spritify(PerfParam& p,
                     SpriteCtx* ctx,
                     SpriteNode** sNodeOut) {
        RMImpl *p0 = _b0->Spritify(p, ctx, sNodeOut);

        Perf e = ::Perform(_event, p);
    
        return RMGroup(p0, e, p._tt, *sNodeOut, ctx);
    }
    
    void _DoKids(GCFuncObj proc) {
        (*proc)(_b0);
        (*proc)(_event);
    }

#if _USE_PRINT
    ostream& Print(ostream& os)
    { return os << "until2(" << _b0 << ", " << _event << ")"; }
#endif

    virtual Perf _Perform(PerfParam& p) {
        // Do that in this order so that end events don't get
        // processed first because of C++ function parameter
        // processing (in reverse order)
        Perf p0 = ::Perform(_b0, p);
        Perf e = ::Perform(_event, p);
        
        return UntilSWPerf(NEW UntilPerfImpl(p0,
                                             e,
                                             p._tt,
                                             _b0->GetTypeInfo()));
    }

    virtual DXMTypeInfo GetTypeInfo () { return _b0->GetTypeInfo(); }

  private:
    Bvr _b0, _event;
    DWORD _info;
};

class NotifyEventPerfImpl : public PerfImpl {
  public:
    NotifyEventPerfImpl(Perf event, UntilNotifier notifier, TimeXform tt)
    : _event(event), _notifier(notifier), _tt(tt),
      _happened(false), _edata(NULL), _te(0) {}

    void _DoKids(GCFuncObj proc) {
        (*proc)(_event);
        (*proc)(_notifier);
        (*proc)(_tt);
        (*proc)(_edata);
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "Notify(" << _event << ")"; }
#endif

    virtual AxAValue _Sample(Param& p) {
        // Can't use _edata since it can be NULL
        if (_happened) {
            return CreateEData(_te, _edata);
        }
        
        AxAEData *edata = ValEData(_event->Sample(p));

        if (edata->Happened()) {
            {
                DynamicHeapPusher dhp(GetGCHeap());
                _edata = _notifier->Notify(edata->EventData(), p._currPerf);
                _happened = true;
            }

            Time eTime = edata->HappenedTime();
            AxAValue result = CreateEData(eTime, _edata);

            return result;
            
        } else
            return noEvent;
    }
    
  private:
    Perf _event;
    UntilNotifier _notifier;
    TimeXform _tt;
    Bvr _edata;
    Time _te;
    bool _happened;
};

class NotifyEventBvrImpl : public BvrImpl {
  public:
    NotifyEventBvrImpl(Bvr event, UntilNotifier notifier)
    : _event(event), _notifier(notifier) {}

    void _DoKids(GCFuncObj proc) {
        (*proc)(_event);
        (*proc)(_notifier);
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "Notify(" << _event << ")"; }
#endif

    virtual BOOL InterruptBasedEvent() { return _event->InterruptBasedEvent();}

    virtual Perf _Perform(PerfParam& p) {
        return NEW NotifyEventPerfImpl(::Perform(_event, p),
                                       _notifier, p._tt);
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }

  private:
    Bvr _event;
    UntilNotifier _notifier;
};

Bvr Until(Bvr b0, Bvr event)
{ return NEW Until2BvrImpl(b0, event); }

Bvr NotifyEvent(Bvr event, UntilNotifier notifier)
{ return NEW NotifyEventBvrImpl(event, notifier); }

Bvr JaxaUntil(Bvr b0, Bvr event, UntilNotifier notifier)
{ return Until(b0, NotifyEvent(event, notifier)); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\callback.cpp ===
/*******************************************************************************

Copyright (c) 1995-97 Microsoft Corporation

Abstract:

    Callback behaviors 

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "jaxaimpl.h"
#include "privinc/debug.h"

class TmpConstBvrImpl : public BvrImpl {
  public:
    TmpConstBvrImpl(AxAValue c) : _cnst(c) { Assert(c); }

    // Override the main Perform since it doesn't need the cache
    virtual Perf Perform(PerfParam& p)
    { return _Perform(p); }

    virtual Perf _Perform(PerfParam&) {
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_TRANS_CONST_BVR);
        return NULL;
    }

    virtual AxAValue GetConst(ConstParam & cp) { return _cnst; }

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_cnst); }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _cnst; }
#endif
    
    virtual DXMTypeInfo GetTypeInfo () {
        if (_cnst == NULL) 
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_TRANS_GONE);
        return _cnst->GetTypeInfo();
    }

    void Invalidate() { _cnst = NULL; }

    void Set(AxAValue v) { _cnst = v; }
    
  protected:
    AxAValue _cnst;
};

//
// Implementation for bvr hook
//

class CallbackPerfImpl : public PerfImpl {
  public:
    CallbackPerfImpl(int id, Perf perf, Bvr cur, Time t0, TimeXform tt, BvrHook h)
    : _id(id), _perf(perf), _cur(cur), _notifier(h), _t0(t0), _tt(tt),_tmp(NULL) {}

    // TODO: Well, don't want constant folding here
    // Maybe we do...
    virtual AxAValue _GetRBConst(RBConstParam& id) {
        if (_perf) {
            // Go down to calculate as much rb const as we can, though
            // we say we're not constant
            _perf->GetRBConst(id);
        }
        return NULL;
    }
    //{ return _perf ? _perf->GetRBConst(id) : NULL; }
    
    // TODO: Well, don't want constant folding here
    // Maybe we do...
    virtual AxAValue GetConst(ConstParam & cp) { return NULL; }

    void _DoKids(GCFuncObj proc) {
        (*proc)(_perf);
        (*proc)(_cur);
        (*proc)(_notifier);
        (*proc)(_tt);
        if (_tmp) (*proc)(_tmp);
    }
    
    virtual AxAValue _Sample(Param& p) {
        AxAValue v = _perf->Sample(p);

        if (!p._noHook) {
            if (_tmp)
                _tmp->Set(v);
            else
                _tmp = NEW TmpConstBvrImpl(v);
        
            double localTime = EvalLocalTime(p, _tt);
            Bvr result =
                _notifier->
                Notify(_id, FALSE, _t0, p._time, localTime, _tmp, _cur);

            if (result)
            {
                ConstParam cp;
                v = result->GetConst(cp);
            }

            _tmp->Invalidate();

            if (!v) {
                RaiseException_UserError(E_FAIL, IDS_ERR_BE_BADHOOKRETURN);
            }
        }

        return v;
    }

#if _USE_PRINT
    ostream& Print(ostream& os) { return os << _perf; }
#endif
        
  private:
    TmpConstBvrImpl *_tmp;
    Perf _perf;
    BvrHook _notifier;
    Bvr _cur;
    TimeXform _tt;
    int _id;
    Time _t0;
};

class CallbackBvrImpl : public BvrImpl {
  public:
    CallbackBvrImpl(Bvr b, BvrHook h)
    : _bvr(b), _notifier(h), _type(b->GetTypeInfo()), _id(0) {}

    virtual DWORD GetInfo(bool recalc) { return _bvr->GetInfo(recalc); }

    virtual Perf _Perform(PerfParam& pp) {
        Param p(pp._t0);
        Perf perf = ::Perform(_bvr, pp);
        AxAValue v = perf->Sample(p);
        TmpConstBvrImpl *tmp = NEW TmpConstBvrImpl(v);
        Bvr b0 = StartedBvr(perf, _type);

        _notifier->Notify(++_id, TRUE, pp._t0, pp._t0, 0.0, tmp, b0);
            
        tmp->Invalidate();

        return NEW CallbackPerfImpl(_id, perf, b0, pp._t0, pp._tt, _notifier);
    }

    // TODO: Well, don't want constant folding here
    // Maybe we do...
    virtual AxAValue GetConst(ConstParam & cp) { return NULL; }

    Bvr EndEvent(Bvr overrideEvent) {
        return _bvr->EndEvent(overrideEvent);
    }


    void _DoKids(GCFuncObj proc) {
        (*proc)(_bvr);
        (*proc)(_notifier);
        (*proc)(_type);
    }
    
#if _USE_PRINT
    ostream& Print(ostream& os) { return os << _bvr; }
#endif
        
    virtual DXMTypeInfo GetTypeInfo () { return _type; }
    
  private:
    Bvr _bvr;
    BvrHook _notifier;
    DXMTypeInfo _type;
    int _id;
};

Bvr BvrCallback(Bvr b, BvrHook notifier)
{ return NEW CallbackBvrImpl(b, notifier); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\events.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Events implementation

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "appelles/events.h"

extern const char END[] = "end";
extern const char PRED[] = "pred";
extern const char TIMER[] = "timer";
extern const char SNAPSHOT[] = "snapshot";

/////////////////////////// EndEvent ///////////////////////////////

class EndEventPerfImpl : public GCBase1<Perf, PerfImpl, END> {
  public:
    EndEventPerfImpl(Perf pred) : GCBase1<Perf, PerfImpl, END>(pred) {}
    
    virtual AxAValue _Sample(Param& p) {
        AxAEData *edata = ValEData(_base->Sample(p));

        if (edata->Happened())
            return CreateEData(p._time, edata->EventData()->EndEvent(NULL));
        else
            return noEvent;
    }
};

////////// Bvr ////////////////

class EndEventBvrImpl : public GCBase1<Bvr, BvrImpl, END> {
  public:
    EndEventBvrImpl(Bvr b) : GCBase1<Bvr, BvrImpl, END>(b) {}

    virtual Perf _Perform(PerfParam& p)
    { return NEW EndEventPerfImpl(::Perform(_base, p)); }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
};

Bvr EndEvent(Bvr event)
{ return NEW EndEventBvrImpl(event); }

/////////////////////////// Boolean Event ///////////////////////////////

class PredicatePerfImpl : public GCBase1<Perf, PerfImpl, PRED> {
  public:
    PredicatePerfImpl(Perf pred) : GCBase1<Perf, PerfImpl, PRED>(pred) {}
    
    virtual AxAValue _Sample(Param& p) {
        if (BooleanTrue(_base->Sample(p)))
            return CreateEData(p._time, TrivialBvr());
        else
            return noEvent;
    }
};

////////// Bvr ////////////////

class PredicateBvrImpl : public GCBase1<Bvr, BvrImpl, PRED> {
  public:
    PredicateBvrImpl(Bvr pred) : GCBase1<Bvr, BvrImpl, PRED>(pred) {}

    virtual Perf _Perform(PerfParam& p)
    { return NEW PredicatePerfImpl(::Perform(_base, p)); }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
};

/////////////////////////// Snapshot Event ///////////////////////////////

class SnapshotPerfImpl : public GCBase2<Perf, PerfImpl, SNAPSHOT> {
  public:
    SnapshotPerfImpl(Perf event, Perf perf)
    : GCBase2<Perf, PerfImpl, SNAPSHOT>(event, perf) {}
    
    virtual AxAValue _Sample(Param& p) {
        AxAEData *edata = ValEData(_b1->Sample(p));
        
        if (edata->Happened()) {
            Bvr b;
            {
                DynamicHeapPusher pusher(GetGCHeap());

                Time old = p._time;
                int oldId = p._id;
                BOOL oldCheckEvent = p._checkEvent;
            
                p._time = edata->HappenedTime();
                p._id = NewSampleId();
                p._checkEvent = FALSE;

                // sound would get silence.
                b = ConstBvr(_b2->Sample(p)->Snapshot());
            
                p._time = old;
                p._id = oldId;
                p._checkEvent = oldCheckEvent;
            }

            return CreateEData(edata->HappenedTime(), b);
        } else {
            _b2->Sample(p);     // for events & ode
            return noEvent;
        }
    }
};

////////// Bvr ////////////////

class SnapshotBvrImpl : public GCBase2<Bvr, BvrImpl, SNAPSHOT> {
  public:
    SnapshotBvrImpl(Bvr event, Bvr b)
    : GCBase2<Bvr, BvrImpl, SNAPSHOT>(event, b) {} 

    virtual BOOL InterruptBasedEvent() { return _b1->InterruptBasedEvent(); }

    virtual Perf _Perform(PerfParam& p) {
        return NEW
            SnapshotPerfImpl(::Perform(_b1, p), ::Perform(_b2, p));
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
};

/////////////////// Event Bvr for the front end ////////////////

Bvr PredicateEvent(Bvr b)
{ return NEW PredicateBvrImpl(b); }

Bvr SnapshotEvent(Bvr e, Bvr b)
{ return NEW SnapshotBvrImpl(e, b); }

/////////////////// Timer Event ////////////////

class TimerPerfImpl : public PerfImpl {
  public:
    TimerPerfImpl(Perf t, TimeXform tt) : _time(t), _tt(tt) { }

    virtual AxAValue _Sample(Param& p) {
        volatile Time eTime, d;

        eTime = ValNumber(_time->Sample(p));

        d = EvalLocalTime(p, _tt) - eTime;

        if (d >= -1e-10) {
            // We need to find the global time of the timer.
            // with time transform, use current time, the best guess
            double t = _tt->IsShiftXform() ? (p._time - d) : p._time;

            return CreateEData(t, TrivialBvr());
        } else 
            return noEvent;
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_time);
        (*proc)(_tt);
    }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "timer(" << _time << ")"; }
#endif
    
  private:
    TimeXform _tt;
    Perf _time;
};

class TimerBvrImpl: public GCBase1<Bvr, BvrImpl, TIMER> {
  public:
    TimerBvrImpl(Bvr time) : GCBase1<Bvr, BvrImpl, TIMER>(time)
    {
#if DEVELOPER_DEBUG
        ConstParam cp;

        Assert(time->GetTypeInfo() == AxANumberType);
        Assert((!time->GetConst(cp)) || (_finite(ValNumber(time->GetConst(cp)))));
#endif
    }

    virtual Perf _Perform(PerfParam& p)
    { return NEW TimerPerfImpl(::Perform(_base, p), p._tt); }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }

    virtual Bvr GetTimer() { return _base; }
};

Bvr TimerEvent(Bvr b)
{ return NEW TimerBvrImpl(b); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\events.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _EVENTS_H
#define _EVENTS_H

#include "privinc/backend.h"

typedef Bvr Event;

enum WindEventType {
    WE_MOUSEBUTTON,
    WE_KEY,
    WE_CHAR,
    WE_RESIZE,
};

Bvr HandleEvent(Bvr event, Bvr data);
Bvr PredicateEvent(Bvr b);
Bvr SnapshotEvent(Bvr e, Bvr b);

// Event data for this event is calling EndEvent() method of e's event
// data 
Bvr EndEvent(Bvr e);

Bvr WindEvent(WindEventType et,
              DWORD data,
              BOOL bState,
              Bvr);

Bvr MakeKeyUpEventBvr(Bvr b);
Bvr MakeKeyDownEventBvr(Bvr b);
Bvr KeyUp(long key);
Bvr KeyDown(long key);

// "max" event, happens when all the event happens, produces the event
// time and data of the last happened event, it frees the passed in
// array (assumed allocated on the GCHeap)
Bvr MaxEvent(Bvr *events, int n);

extern Bvr zeroTimer;

#endif /* _EVENTS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\drect.cpp ===
/*******************************************************************************

Copyright (c) 1996 Microsoft Corporation

Abstract:

     Implement dirty rectangles

*******************************************************************************/

#include <headers.h>
#include <stdio.h>
#include "privinc/storeobj.h"
#include "privinc/basic.h"
#include "privinc/bbox2i.h"
#include "privinc/imagei.h"
#include "privinc/overimg.h"
#include "privinc/cropdimg.h"
#include "privinc/drect.h"
#include "privinc/debug.h"
#include "privinc/colori.h"
#include "privinc/opt.h"
#include "include/appelles/color.h"
#include "include/appelles/path2.h"
#include "include/appelles/linestyl.h"
#include "include/appelles/hacks.h"
#include "perf.h"

#define PIXEL_SMIDGEON_PER_SIDE 2
static Real smidgeon = 0.0;

DeclareTag(tagDisableDirtyRectMerge, "Optimizations",
           "disable final merge of drects");
DeclareTag(tagDirtyRectsVisualsBorderOnly, "Optimizations",
           "border only drects visual trace");
DeclareTag(tagDirtyRectsOneBoxOnly, "Optimizations",
           "do drect only w/ one merged box");
DeclareTag(tagDisableDirtyRectsOptimizeBoxList, "Optimizations",
           "disable drect optimize merged boxes");


BboxList::BboxList()
{
    _count = 0;

    if (smidgeon == 0.0) {
        smidgeon = PIXEL_SMIDGEON_PER_SIDE / ViewerResolution();
    }
}

BboxList::~BboxList()
{
}

void
BboxList::Add(const Bbox2 box)
{
    if (!(box == NullBbox2)) {

        // If beyond we're we've added, add to the end and construct a new
        // bbox, adding to the roots list
        int sz = _boxes.size();
        if (_count >= sz) {
        
            _boxes.push_back(NullBbox2);
        
            Assert(sz + 1 == _boxes.size());
        }

        // Copy the data in.
        Bbox2& b = _boxes[_count];
    
        b.min = box.min;
        b.max = box.max;

        b.min.x -= smidgeon;
        b.min.y -= smidgeon;
        b.max.x += smidgeon;
        b.max.y += smidgeon;
    
        _count++;
    }
}

void
BboxList::Add(ImageWithBox &ib)
{
    // Add(Bbox2Value *) copies the elements of the box, not the pointer,
    // so we can safely pass a pointer to memory that may go away
    // here. 
    Add(ib._box);
}

void
BboxList::Clear()
{
    _count = 0;
}

#if _DEBUG
extern "C" void PrintObj(GCBase* b);

void 
BboxList::Dump()
{
    DebugPrint("BboxList: 0x%x %d\n", this, _count);
    for (int i = 0; i < _count; i++) {
        PerfPrintLine("<<%g,%g>, <%g,%g>>",
                      _boxes[i].min.x, _boxes[i].min.y,
                      _boxes[i].max.x, _boxes[i].max.y);
    }
}
#endif  

///////////////////////////////////////

ConstImageList::ConstImageList()
{
    _count = 0;
}
    
ConstImageList::~ConstImageList()
{
    Clear();
}

void
ConstImageList::Add(Image *img, Bbox2& boxToCopy)
{
    int sz = _images.size();
    
    if (_count >= sz) {
        
        ImageWithBox ib(img, boxToCopy);
        _images.push_back(ib);
        Assert(sz + 1 == _images.size());
        
    } else {
        
        _images[_count]._image = img;
        _images[_count]._box = boxToCopy;
        
    }
    
    _count++;
}

void
ConstImageList::Clear()
{
    GCRoots roots = GetCurrentGCRoots();

    for (int i = 0; i < _count; i++) {
        GCRemoveFromRoots(_images[i]._image, roots);
    }

    _count = 0;
}

#if _DEBUG
void 
ConstImageList::Dump()
{
    DebugPrint("ConstImageList: 0x%x %d\n", this, _count);
    for (int i = 0; i < _count; i++) {
        DebugPrint("%x \n", _images[i]._image);
        PerfPrintLine("<<%g,%g>, <%g,%g>>",
                      _images[i]._box.min.x, _images[i]._box.min.y,
                      _images[i]._box.max.x, _images[i]._box.max.y);
    }
}
#endif  

///////////////////////////////////////

DirtyRectCtx::DirtyRectCtx(BboxList &dirtyRects,
                           int lastSampleId,
                           ConstImageList &constImages,
                           Bbox2& targetBox) :
    _dirtyRects(dirtyRects),
    _constImages(constImages)
{
    _processEverything = false;
    _accumXform = identityTransform2;
    _accumulatedClipBox = targetBox;
    _lastSampleId = lastSampleId;
}

void
DirtyRectCtx::AddToConstantImageList(Image *img,
                                     Bbox2& boxToCopy)
{
    // Guarantee we weren't built on the transient heap.
    Assert(img->GetCreationID() != PERF_CREATION_ID_BUILT_EACH_FRAME);

    // Add image to the root set of the GC to ensure that the pointer
    // doesn't get re-used.  Will release when we clear out the
    // constant image list.
    GCAddToRoots(img, GetCurrentGCRoots());

    Bbox2 clippedRect =
        IntersectBbox2Bbox2(boxToCopy, _accumulatedClipBox);

    if (!(clippedRect == NullBbox2)) {
        _constImages.Add(img, clippedRect);
    }
}


void
DirtyRectCtx::AddDirtyRect(const Bbox2 rect)
{
    Bbox2 clippedRect =
        IntersectBbox2Bbox2(rect, _accumulatedClipBox);
            
    _dirtyRects.Add(clippedRect);
}

void
DirtyRectCtx::AccumulateClipBox(const Bbox2 clipBox)
{
    Bbox2 xfdBox = TransformBbox2(_accumXform, clipBox);
    _accumulatedClipBox = 
        IntersectBbox2Bbox2(_accumulatedClipBox, xfdBox);
}

void
DirtyRectCtx::SetClipBox(const Bbox2 clipBox)
{
    _accumulatedClipBox = clipBox;
}

Bbox2 
DirtyRectCtx::GetClipBox()
{
    return _accumulatedClipBox;
}

////////////////////////////////////////

DirtyRectState::DirtyRectState()
{
    Clear();
}


void
DirtyRectState::Clear()
{
    _drectsA.Clear();
    _drectsB.Clear();

    _constImagesA.Clear();
    _constImagesB.Clear();

    _drectsAisOld = false;

    _thisMergedToOne = _lastMergedToOne = false;

    // Set up the initial "old" bbox to be *everything*
    _drectsA.Add(UniverseBbox2);
}

void
DirtyRectState::CalculateDirtyRects(Image *theImage,
                                    int lastSampleId,
                                    Bbox2& targetBox)
{
    BboxList *newRects;
    ConstImageList *newConstImages;
    
    if (_drectsAisOld) {
        newRects = &_drectsB;
        newConstImages = &_constImagesB;
    } else {
        newRects = &_drectsA;
        newConstImages = &_constImagesA;
    }
    
    DirtyRectCtx ctx(*newRects,
                     lastSampleId,
                     *newConstImages,
                     targetBox);
    
    Image::CollectDirtyRects(theImage, ctx);
}

void
DirtyRectState::Swap()
{
    // Clear out the old "old", make it the new, make the new the old.
    BboxList *oldRects;
    ConstImageList *oldConsts;
    
    if (_drectsAisOld) {
        oldRects = &_drectsA;
        oldConsts = &_constImagesA;
        _drectsAisOld = false;
    } else {
        oldRects = &_drectsB;
        oldConsts = &_constImagesB;
        _drectsAisOld = true;
    }

    oldRects->Clear();
    oldConsts->Clear();

    _lastMergedToOne = _thisMergedToOne;
    _thisMergedToOne = false;
}

void
DirtyRectState::ComputeMergedBoxes()
{
    // Many different possible merging algorithms.  We can keep
    // improving whatever we have.


    // First: put all changed boxes on merged list
    
    // This algo: if old and new are same length, compare and possibly
    // merge each.  Otherwise, just concat lists.
    _mergedBoxes.Clear();

    int i, j;
    if (_drectsA._count == _drectsB._count) {
        
        for (i = 0, j = 0; i < _drectsA._count; i++, j++) {

            Bbox2& bbA = _drectsA._boxes[i];
            Bbox2& bbB = _drectsB._boxes[j];

            Assert((!(bbA == NullBbox2)) && (!(bbB == NullBbox2)));
            
            Bbox2 tmp = bbA;
            tmp.Augment(bbB.min);
            tmp.Augment(bbB.max);
            if (tmp.Area() < bbA.Area() + bbB.Area()) {
                _mergedBoxes.Add(tmp);
            } else {
                _mergedBoxes.Add(bbA);
                _mergedBoxes.Add(bbB);
            }
        }
        
    } else {

        // Not the same size lists, just push everything on.
        for (i = 0; i < _drectsA._count; i++) {
            _mergedBoxes.Add(_drectsA._boxes[i]);
        }

        for (i = 0; i < _drectsB._count; i++) {
            _mergedBoxes.Add(_drectsB._boxes[i]);
        }
        
    }

    MergeDiffConstImages();

    // Now we have all of the individual boxes, so process them.
    
    if (_mergedBoxes._count > 1) {
        
        // Now, go through all of the boxes, and see if the sum of their
        // areas is larger than the area of their union.  If it is, then
        // we should just render that whole thing.
        Bbox2 tmp;
        Real area = 0.0;
        for (i = 0; i < _mergedBoxes._count; i++) {
            Bbox2& bb = _mergedBoxes._boxes[i];

            Assert(!(bb == NullBbox2));
            
            tmp.Augment(bb.min);
            tmp.Augment(bb.max);
            area += bb.Area();
        }

        // This factor is here to recognize that there is a threshold that
        // multiple rects need to get over before we decide to process the
        // multiple rects as opposed to the single rect.  TODO: Figure out
        // what this should be better, and consolidate it with the one in
        // overimg.cpp. 
        const Real fudgeFactor = 1.5;

#if _DEBUG
        if (!IsTagEnabled(tagDisableDirtyRectMerge)) {
#endif
            if (area * fudgeFactor >= tmp.Area()) {
                // Erase all the merges, and just put this one in.
                _mergedBoxes.Clear();
                _mergedBoxes.Add(tmp);

                _thisMergedToOne = true;
                _mergedBox = tmp;
            }

#if _DEBUG
        }
#endif  
    
    }

}

void 
DirtyRectState::MergeDiffConstImages()
{

    // Next: look at static boxes and if any have come or gone since
    // the last frame, add them to the list.  Need to look in the same
    // order through both lists, to ensure we don't miss changes in
    // z-ordering between images.

    // TODO: this is n^2 if B is totally different than A

    int m = _constImagesA._count;
    int n = _constImagesB._count;
    int i = 0;
    int j = 0;
    int k, h;

    while (i<m) {
        // no more in B, dump rest of A as unique
        if (j>=n) {
            for (k=i; k<m; k++) {
                _mergedBoxes.Add(_constImagesA._images[k]);
            }
            break;
        }

        if (_constImagesA._images[i]==_constImagesB._images[j]) {
            j++;
        } else {
            // if current A is not the same as current B,
            // loop thru rest of B to see any same image
            for (k=j+1; k<n; k++) {
                if (_constImagesA._images[i]==_constImagesB._images[k]) {
                    break;
                }
            }

            // if a same image is found, dump upto that one in B as
            // unique, else current A image is unique.
            if (k<n) {
                for (h=j; h<k; h++) {
                    _mergedBoxes.Add(_constImagesB._images[h]);
                }
                j = k+1;
            } else {
                _mergedBoxes.Add(_constImagesA._images[i]);
            }
        }

        i++;
    }
    
    for (h=j; h<n; h++) {
        _mergedBoxes.Add(_constImagesB._images[h]);
    }

#if _DEBUG
    static bool dump = false;

    if (dump) {
        Dump();
    }
#endif
}

#if _DEBUG

Image *
MaybeDrawBorder(Bbox2& box, Image *origImage)
{
    Image *newIm = origImage;
    
    if (IsTagEnabled(tagDirtyRectsVisuals)) {
                
        // Draw a box around me...

        // First, bring the box in just a smidgeon (the
        // same smidgeon that we expanded the box by) so
        // it will live on the original bbox.
        Bbox2Value *box2 = NEW Bbox2Value;
                
        box2->min.x = box.min.x + smidgeon;
        box2->min.y = box.min.y + smidgeon;
        box2->max.x = box.max.x - smidgeon;
        box2->max.y = box.max.y - smidgeon;
                
        AxAValue *pts = NEW AxAValue[5];
        pts[0] = Promote(box2->min);
        pts[1] = NEW Point2Value(box2->min.x, box2->max.y);
        pts[2] = Promote(box2->max);
        pts[3] = NEW Point2Value(box2->max.x, box2->min.y);
        pts[4] = Promote(box2->min);
        Path2 *path =
            PolyLine2(MakeValueArray(pts, 5, Point2ValueType));

        // Allow the color to cycle
        static Real r = 0.5;
        static Real g = 0.3;
        static Real b = 0.2;
        r += 0.02;
        g += 0.07;
        b += 0.05;
        Color *col = NEW Color(r, g, b);
        LineStyle *ls = LineColor(col, defaultLineStyle);

        Image *border = DrawPath(ls, path);
        if (IsTagEnabled(tagDirtyRectsVisualsBorderOnly))
            newIm = border;
        else
            newIm = Overlay(border, newIm);
    }

    return newIm;
}

void 
DirtyRectState::Dump()
{
    DebugPrint("DirtyRectState 0x%x\n", _drectsAisOld);
    _drectsA.Dump();
    _drectsB.Dump();
    _constImagesA.Dump();
    _constImagesB.Dump();
    _mergedBoxes.Dump();
}
#endif _DEBUG

// drop all the boxes that's contained in other box, reduce the total
// # of cropped images
void
OptimizeBoxes(BboxList& mergedBoxes)
{
#if _DEBUG
    if (IsTagEnabled(tagDisableDirtyRectsOptimizeBoxList)) {
        return;
    }
#endif _DEBUG

    int n = mergedBoxes._count;
    int drops = 0;
    int i, j;

    if (n<=1)
        return;

    vector<bool> dropList(n, false);

    for (i=0; i<n; i++) {
        for (j=0; j<n; j++) {
            if ((i!=j) && (!dropList[j])) {
                if (mergedBoxes._boxes[j].
                    Contains(mergedBoxes._boxes[i])) {
                    dropList[i] = true;
                    drops++;
                    break;
                }
            }
        }
    }

    if (drops>0) {
        vector<Bbox2> tmp(mergedBoxes._boxes);

        mergedBoxes.Clear();

        int& k = mergedBoxes._count;

        for (i=0; i<n; i++) {
            if (!dropList[i]) {
                mergedBoxes._boxes[k++] = tmp[i];
            }
        }
    }
}

Image *
DirtyRectState::RewriteAsCrops(Image *origImage)
{
    // Rewrite the image as the cropping of the image to the specified
    // boxes.

    if (_lastMergedToOne) {
        _mergedBoxes.Add(_mergedBox);
    }

    OptimizeBoxes(_mergedBoxes);

    int size = _mergedBoxes._count;

    Image *result;

    switch (size) {
        
      case 0:
        result = emptyImage;
        break;

      case 1:
        {
            Bbox2 bb = _mergedBoxes._boxes[0];

            // There is a bug in the rendering code that if we crop it
            // with an infinity bbox, it won't draw, so this isn't
            // just an optimization.

            if (_finite(bb.Area())) {
                result = NEW CroppedImage(bb, origImage);
            
#if _DEBUG
                result = MaybeDrawBorder(_mergedBoxes._boxes[0],
                                         result);
#endif _DEBUG 
            } else {
                result = origImage;
            }                
        }
        break;

      default:
        {
            
#if _DEBUG
            if (IsTagEnabled(tagDirtyRectsOneBoxOnly)) {
                result = origImage;
                break;
            }
#endif _DEBUG               

            if (sysInfo.IsWin9x())
            {
                result = origImage;
                break;
            }

            AxAValue *valArr = NEW AxAValue[size];
            if (!valArr) {
            
                result = origImage;
            
            } else {

                AxAValue *pImage = valArr;
                for (int i = 0; i < _mergedBoxes._count; i++) {
                    Image *newIm = NEW CroppedImage(_mergedBoxes._boxes[i],
                                                    origImage);
                
#if _DEBUG
                    newIm = MaybeDrawBorder(_mergedBoxes._boxes[i],
                                            newIm);
#endif _DEBUG               
                
                    *pImage++ = newIm;
                }

                AxAArray *arr = MakeValueArray(valArr, size, ImageType);
                result = OverlayArray(arr);

                delete [] valArr;
            }
        }
        break;
    }

#if _DEBUG    
    if (IsTagEnabled(tagDirtyRectsVisuals)) {
        result = Overlay(result, SolidColorImage(gray));
    }
#endif
        
    return result;
}


int
DirtyRectState::GetMergedBoxes(vector<Bbox2> **ppBox2PtrList)
{
    *ppBox2PtrList = &_mergedBoxes._boxes;
    return _mergedBoxes._count;
}

Image *
DirtyRectState::Process(Image *theImage,
                        int lastSampleId,
                        Bbox2 targetBox)
{
    Swap();

    CalculateDirtyRects(theImage, lastSampleId, targetBox);
            
    ComputeMergedBoxes();
    return RewriteAsCrops(theImage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\const.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Constant Behavior

*******************************************************************************/

#include <headers.h>
#include "privinc/except.h"
#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "privinc/server.h"
#include "privinc/opt.h"
#include "privinc/dddevice.h"
#include "privinc/tls.h"

////////////////////////// Const ////////////////////////////////

////////////////////////// ConstPerf ////////////////////////////////

class ConstPerfImpl : public PerfBase {
  public:
    ConstPerfImpl(AxAValue c) {
        _cnst = c;
#if DEVELOPER_DEBUG
        // For debugging, in case _cnst got gc'ed we still have
        // some info to look at...
        _type = _cnst->GetTypeInfo();
#endif
    }

    virtual AxAValue GetRBConst(RBConstParam&) {
        return _cnst;
    }

    // Don't need the cache, so override Sample instead of _Sample
    virtual AxAValue Sample(Param& p) {
        Assert(_cnst && _type);
        return _cnst;
    }

    virtual void DoKids(GCFuncObj proc) {
        Assert(_cnst && _type);
        
        (*proc)(_cnst);
    }

    virtual AxAValue GetConstPerfConst() { return _cnst; }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _cnst; }
#endif

    virtual BVRTYPEID GetBvrTypeId() { return CONST_BTYPEID; }

  protected:
    AxAValue _cnst;
#if DEVELOPER_DEBUG
    // In debug, even if _cnst gets corrupted, we can get some info...
    DXMTypeInfo _type;
#endif    
};

class ConstImagePerfImpl : public PerfImpl {
  public:
    ConstImagePerfImpl(AxAValue c) {

        _cnst = c;

        if (_cnst->GetTypeInfo() == ImageType) {
            Image *img = SAFE_CAST(Image *, _cnst);
            img->SetCreationID(PERF_CREATION_ID_FULLY_CONSTANT);
            img->SetOldestConstituentID(PERF_CREATION_ID_FULLY_CONSTANT);
        } else if (_cnst->GetTypeInfo() == GeometryType) {
            Geometry *geo = SAFE_CAST(Geometry *, _cnst);
            geo->SetCreationID(PERF_CREATION_ID_FULLY_CONSTANT);
        }

#if DEVELOPER_DEBUG
        // For debugging, in case _cnst got gc'ed we still have
        // some info to look at...
        _type = _cnst->GetTypeInfo();
#endif
        
    }

    virtual AxAValue _GetRBConst(RBConstParam&) {
        return _cnst;
    }

    // Don't need the cache, so override Sample instead of _Sample
    virtual AxAValue _Sample(Param& p) {
        Assert(_cnst && _type);
        return _cnst;
    }

    virtual void _DoKids(GCFuncObj proc) {
        Assert(_cnst && _type);
        
        // Need to traverse down to pick up the pointers in AxAClosure.
        (*proc)(_cnst);
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _cnst; }
#endif

    virtual BVRTYPEID GetBvrTypeId() { return CONST_BTYPEID; }

    virtual AxAValue GetConstPerfConst() { return _cnst; }

  protected:
    AxAValue _cnst;
#if DEVELOPER_DEBUG
    // In debug, even if _cnst gets corrupted, we can get some info...
    DXMTypeInfo _type;
#endif    
};

Perf ConstPerf(AxAValue c)
{ 
    if ((c->GetTypeInfo()==ImageType) ||
        (c->GetTypeInfo()==GeometryType))
        return NEW ConstImagePerfImpl(c);
    else
        return NEW ConstPerfImpl(c); 
}

class ConstBvrImpl : public BvrBase {
  public:
    ConstBvrImpl(AxAValue c) : _cnst(c), _perf(NULL) {
        if (IsInitializing()) {
            _perf = NEW ConstPerfImpl(_cnst);
        }
    }

    virtual DWORD GetInfo(bool) {
        return BVR_IS_CONSTANT;
    }

    virtual Perf Perform(PerfParam&) {
        if (!_perf)
            _perf = NEW ConstPerfImpl(_cnst);

        return _perf;
    }

    virtual AxAValue GetConst(ConstParam & cp) {
        return _cnst;
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_perf);
        (*proc)(_cnst);
    }

    virtual Bvr Left()
    { return ConstBvr(ValPair(_cnst)->Left()); }

    virtual Bvr Right() 
    { return ConstBvr(ValPair(_cnst)->Right()); }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _cnst; }
#endif

    virtual DXMTypeInfo GetTypeInfo () { return _cnst->GetTypeInfo(); }
    
    virtual BVRTYPEID GetBvrTypeId() { return CONST_BTYPEID; }
  protected:
    AxAValue _cnst;
    Perf _perf;
};

class ConstImageBvrImpl : public BvrImpl {
  public:
    ConstImageBvrImpl(AxAValue c) : _cnst(c) {
        Assert(c);
    }

    virtual DWORD GetInfo(bool) {
        return BVR_IS_CONSTANT;
    }

    virtual Perf _Perform(PerfParam&) {
        return NEW ConstImagePerfImpl(_cnst);
    }

    virtual AxAValue GetConst(ConstParam & cp) {
        return _cnst;
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_cnst);
    }

    virtual Bvr Left()
    { return ConstBvr(ValPair(_cnst)->Left()); }

    virtual Bvr Right() 
    { return ConstBvr(ValPair(_cnst)->Right()); }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _cnst; }
#endif

    virtual DXMTypeInfo GetTypeInfo () { return _cnst->GetTypeInfo(); }
    
    virtual BVRTYPEID GetBvrTypeId() { return CONST_BTYPEID; }
  protected:
    AxAValue _cnst;
};

class UnsharedConstBvrImpl : public ConstBvrImpl {
  public:
    UnsharedConstBvrImpl(AxAValue c) : ConstBvrImpl(c) {}
    virtual bool     GetShared() { return false; }
};


Bvr ConstBvr(AxAValue c)
{ 
    Assert(c);

    if ((c->GetTypeInfo()==ImageType) ||
        (c->GetTypeInfo()==GeometryType)) {
        if ((c!=emptyImage) && (c!=emptyGeometry))
            return NEW ConstImageBvrImpl(c);
    }
     
    return NEW ConstBvrImpl(c); 
}

Bvr UnsharedConstBvr(AxAValue c)
{ return NEW UnsharedConstBvrImpl(c); }

BOOL IsConst(Perf p)
{ return (p->GetBvrTypeId() == CONST_BTYPEID); }

AxAValue  GetPerfConst(Perf p)
{
    return p->GetConstPerfConst();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\gc.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Garbage collector 

*******************************************************************************/

#include <headers.h>

#include "gc.h"
#include "privinc/server.h"
#include "privinc/except.h"
#include "privinc/debug.h"
#include "privinc/mutex.h"
#if PERFORMANCE_REPORTING
// For Tick2Sec & GetPerfTickCount
#include "privinc/util.h"
#endif
#ifdef _DEBUG
#include <typeinfo.h>
#endif

#define FREE_IMMEDIATELY 1

DeclareTag(tagTrackGCRoots, "Gc", "Track Roots");

typedef list<GCBase*> GCListType;
typedef list<void *> ListType;
#if !FREE_IMMEDIATELY
typedef map< size_t, ListType *, less<size_t> > GCFreeMap;
#endif

#if PERFORMANCE_REPORTING
typedef map< size_t, int, less<size_t> > GCNewStatMap;

static GCNewStatMap *newStatMap;
#endif

typedef map< GCBase*, int, less<GCBase*> > GCRootMap;

class GCRootsImpl : public AxAThrowingAllocatorClass
{
  public:
    GCRootMap roots;
    CritSect cs;

    void Lock() { cs.Grab(); }
    void Release() { cs.Release(); }
};

class GCRootGrabber
{
  public:
    GCRootGrabber(GCRoots roots)
    : _roots(roots)
    { _roots->Lock(); }
    ~GCRootGrabber()
    { _roots->Release();}
  protected:
    GCRoots _roots;
};

static CritSect* statLock = NULL;

static GCRoots globals = NULL;

class GCGlobalRootsGrabber : public GCRootGrabber
{
  public:
    GCGlobalRootsGrabber()
    : GCRootGrabber(globals) {}
};

class GCInfo : public AxAThrowingAllocatorClass {
  public:
    GCListType allocated;
    //GCListType toBeFreed;
#if !FREE_IMMEDIATELY
    GCFreeMap freeMap;
#endif
    int lastAllocated;
    CritSect cs;

    void Lock() { cs.Grab(); }
    void Release() { cs.Release(); }
};

class GCListGrabber
{
  public:
    GCListGrabber(GCInfo * lst)
    : _lst(lst)
    { _lst->Lock(); }
    ~GCListGrabber()
    { _lst->Release();}
  protected:
    GCInfo * _lst;
};

// This is to ensure that we always acquire things in the right order

void GCAcquireLocks(GCInfo * lst = NULL,
                    GCRoots roots = NULL,
                    bool bGlobals = FALSE,
                    bool bstatLock = FALSE)
{
    // !! must be the reverse of below
    if (lst) lst->Lock();
    if (roots) roots->Lock();
    if (bGlobals) globals->Lock();
    if (bstatLock) statLock->Grab();
}

void GCReleaseLocks(GCInfo * lst = NULL,
                    GCRoots roots = NULL,
                    bool bGlobals = FALSE,
                    bool bstatLock = FALSE)
{
    // !! must be the reverse of the above
    if (bstatLock) statLock->Release();
    if (bGlobals) globals->Release();
    if (roots) roots->Release();
    if (lst) lst->Release();
}

class GCMultiGrabber
{
  public:
    GCMultiGrabber(GCInfo * lst = NULL,
                   GCRoots roots = NULL,
                   bool bGlobals = FALSE,
                   bool bstatLock = FALSE)
    : _lst(lst),
      _roots(roots),
      _bGlobals(bGlobals),
      _bstatLock(bstatLock)
    { GCAcquireLocks(_lst,_roots,_bGlobals,_bstatLock); }
        
    ~GCMultiGrabber()
    { GCReleaseLocks(_lst,_roots,_bGlobals,_bstatLock); }
  protected:
    GCInfo * _lst;
    GCRoots _roots;
    bool _bGlobals;
    bool _bstatLock;
};

GCRoots CreateGCRoots()
{ return NEW GCRootsImpl; }

void FreeGCRoots(GCRoots r)
{ delete r; }

GCList
CreateGCList()
{
    GCInfo* lst = NEW GCInfo;

    lst->lastAllocated = 0;

    return lst;
}

void
FreeGCList(GCList lst)
{
    delete lst;
}

inline GCInfo * GetGCList()
{ return GetCurrentGCList(); }

void GCAddToAllocated(GCBase* ptr)
{
    Assert(IsInitializing() ||
           IsGCLockAcquired(GetCurrentThreadId()));
    
    if (bInitState) {
        GCAddToRoots(ptr, NULL);
    } else {
        GCInfo *gcInfo = GetGCList();

        Assert(gcInfo);
        
        GCListGrabber csp(gcInfo);
        GCListType &lst = gcInfo->allocated;

#if _DEBUG
        if(IsTagEnabled(tagGCDebug))
            Assert(std::find(lst.begin(), lst.end(), ptr) == lst.end());
#endif _DEBUG
        
        lst.push_front(ptr);
    }
}

void GCRemoveFromAllocated(GCBase* ptr)
{
    if (bInitState) {
        GCRemoveFromRoots(ptr, NULL);
    } else {
        GCInfo *gcInfo = GetGCList();

        Assert(gcInfo);
        
        GCListGrabber csp(gcInfo);
        
        GCListType &lst = gcInfo->allocated;
        
        GCListType::iterator i = std::find(lst.begin(), lst.end(), ptr);
        
        Assert(i != lst.end());
        
        lst.erase(i);
    }
}


// Save the allocated GCObj's into the gcLst.
GCObj::GCObj() 
{
    //Assert(GetSystemHeap().ValidateMemory(this));
    
    GCAddToAllocated(this);
}

GCObj::~GCObj()
{
    Assert((_type==GCFREEING) || (_type==GCOBJTYPE));

    // Check for exception unwind.
    if (_type!=GCFREEING) {
        GCRemoveFromAllocated(this);
    }
}

#if _DEBUGMEM
void *GCObj::operator new(size_t s, int blockType, char * szFileName, int nLine)
#else
void *GCObj::operator new(size_t s)
#endif // _DEBUGMEM

{
    void *p = NULL;
    
#if !FREE_IMMEDIATELY
    GCInfo *gcInfo = GetGCList();
    if (gcInfo) {
        GCListGrabber csp(gcInfo);

        GCFreeMap freeMap = gcInfo->freeMap;
        
        GCFreeMap::iterator i = freeMap.find(s);

        if (i != freeMap.end()) {
            if (!(*i).second->empty()) {
                p = (*i).second->front();

                (*i).second->pop_front();

            }
        }
    }
#endif

    if (p == NULL) {
#if PERFORMANCE_REPORTING
        CritSectGrabber cs(*statLock);
        
        GCNewStatMap::iterator j = newStatMap->find(s);
        
        if (j != newStatMap->end())
            (*newStatMap)[s] = (*j).second + 1;
        else
            (*newStatMap)[s] = 1;
#endif
#if _DEBUGMEM
        p = (BYTE*) StoreAllocateFn(GetSystemHeap(),s, szFileName, nLine);
#else
        p = (BYTE*) StoreAllocateFn(GetSystemHeap(),s);
#endif  // _DEBUGMEM
    }
#if _DEBUGMEM
    TraceTag((tagGCDebug, "GCObj::operator new %s:Line(%d) Addr: %lx size= %d.\n", szFileName, nLine, p, s));
#endif // _DEBUGMEM

    return p;
}

// We cannot call the subclass's virtual function at this point, so we
// can't make CleanUp as vritual function and obtain the
// information here.   According to Stroustrup, we can put a size
// field in the base class and access it in delete.  However, this
// doesn't seem to work with our compiler.  We're using a header 
// field to store the size.  This assumes size_t has the right
// alignment.  
void GCObj::operator delete(void *ptr, size_t s)
{
    TraceTag((tagGCDebug, "GCObj::operator delete Addr: %lx size= %d.\n", ptr, s));

    if (bInitState) {
        StoreDeallocate(GetSystemHeap(), ptr);
        return;
    }
    
#if FREE_IMMEDIATELY
    StoreDeallocate(GetSystemHeap(), ptr);
#else
    GCInfo *gcInfo = GetGCList();
    
    Assert(gcInfo);

    GCListGrabber csp(gcInfo);

    GCFreeMap::iterator i = gcInfo->freeMap.find(s);

#if _DEBUG
    // Use a traceTag to control this so that it
    // calls free instead of reusing cells.  Important to detect
    // cases where we missed some children.

    if(IsTagEnabled(tagGCDebug)) {
        StoreDeallocate(GetSystemHeap(), ptr);
        return;
    }

    memset(ptr, 0xBB, s);
#endif DEBUG

    if (i != gcInfo->freeMap.end()) {
        (*i).second->push_back(ptr);
    } else {
        ListType * lst = THROWING_ALLOCATOR(ListType);

        lst->push_back(ptr);

        gcInfo->freeMap[s] = lst;

        Assert(gcInfo->freeMap.find(s) != gcInfo->freeMap.end());
    }
#endif
}

#if DEVELOPER_DEBUG
bool GCIsInRoots(GCBase *ptr, GCRoots r)
{
    GCRoots rm = r ? r : globals;

    return (rm->roots.find(ptr) != rm->roots.end());
}
#endif DEVELOPER_DEBUG

static void AddToRoots(GCBase *ptr, GCRoots globals)
{
    Assert(ptr && globals);
    
    GCRootGrabber gcrg(globals);

#ifdef _DEBUG
    if (IsTagEnabled(tagTrackGCRoots)) {
        if (ptr->GetType()==GCBase::GCOBJTYPE) {
            int sz = globals->roots.size();
        }
    }
#endif _DEBUG    
    
    GCRootMap::iterator i = globals->roots.find(ptr);

    if (i != globals->roots.end())
        (*i).second = (*i).second + 1;
    else
        (globals->roots)[ptr] = 1;
}

// Add/Remove GCObj from the root multi-set.  
void GCAddToRoots(GCBase *ptr, GCRoots roots)
{
    Assert(ptr);
    
    if (roots) {
        Assert(!bInitState);
    
        // Either the root is here or we have the lock
        Assert(IsGCLockAcquired(GetCurrentThreadId()) ||
               roots->roots.find(ptr) != roots->roots.end() ||
               globals->roots.find(ptr) != globals->roots.end());
        
        AddToRoots(ptr, roots);
    } else {
        Assert(bInitState);
        AddToRoots(ptr, globals);
    }
}

static void RemoveFromRoots(GCBase *ptr, GCRoots globals)
{
    Assert(ptr);
    
    GCRootGrabber gcrg(globals);

    GCRootMap::iterator i = globals->roots.find(ptr);

    Assert(i != globals->roots.end());

    Assert((*i).second > 0);

    (*i).second = (*i).second - 1;

    if ((*i).second == 0) 
        globals->roots.erase(i);

#ifdef _DEBUG
    if (IsTagEnabled(tagTrackGCRoots)) {
        if (ptr->GetType()==GCBase::GCOBJTYPE) {
            int sz = globals->roots.size();
        }
    }
#endif _DEBUG    
}

void GCRemoveFromRoots(GCBase *ptr, GCRoots roots)
{
    Assert(ptr);
    
    if (roots) {
        Assert(!bInitState);
        RemoveFromRoots(ptr, roots);
    } else {
        Assert(bInitState);
        RemoveFromRoots(ptr, globals);
    }
}

class Marker : public GCFuncObjImpl
{
  public:
    virtual void operator() (GCBase *root)
    {
        if (root && (!root->Marked())) {
            Assert((root->GetType() == GCBase::GCOBJTYPE) ||
                   (root->GetType() == GCBase::STOREOBJTYPE));
            root->SetMark(TRUE);
            root->DoKids(this);
        }
    }
};

class Marked
{
  public:
    bool operator() (GCBase* gcObj) {
        Assert(gcObj);
        Assert((gcObj->GetType() == GCBase::GCOBJTYPE) ||
               (gcObj->GetType() == GCBase::STOREOBJTYPE));
        //gcObj->ClearCache();
        return (gcObj->Marked() != 0);
    }
};

class Unmarker : public GCFuncObjImpl
{
  public:
    virtual void operator() (GCBase *root)
    {
        if (root && (root->Marked())) {
            root->SetMark(FALSE);
            root->DoKids(this);
        }
    }
};

// Does an actual GC when gets to this threshold.
static const int GCThreshold = 800;

// Incrementally free the reclaimed cells at this rate.
static const int GCFreeRate = 500;

static int lastReclaimed = 0;
static int totalReclaimed = 0;
static int numGCs = 0;
static int numFreed = 0;

#if PERFORMANCE_REPORTING
static double unmarkTime = 0.0;
static double markTime = 0.0;
static double collectTime = 0.0;
#endif 

extern int gcStat;

void IncrementalFree(GCListType& toBeFreed, bool bForce);

void MarkClearMapObjs(GCRoots roots)
{
    for (GCRootMap::iterator i = roots->roots.begin();
         i != roots->roots.end(); i++) {
        GCBase *p = (*i).first;
        Assert(p);
        p->ClearCache();
        p->SetMark(FALSE);
    }
}

void MarkRoots(GCRoots roots, bool notUnmark)
{
    GCFuncObj marker;

    if (notUnmark)
        marker = THROWING_ALLOCATOR(Marker);
    else
        marker = THROWING_ALLOCATOR(Unmarker);

    Assert(marker);

    // Mark reachable objects from the root set.
    for (GCRootMap::iterator j = roots->roots.begin(); j != roots->roots.end(); j++)
        (*marker)((*j).first);

    // Mark reachable objects from the global set.
    for (GCRootMap::iterator k = globals->roots.begin(); k != globals->roots.end(); k++)
        (*marker)((*k).first);

    delete marker;
}

// Simple mark and sweep GC algorithm for the time being.
// Should be called after a complete sampling, so that we don't need
// to track the cache.  Note unless force is TRUE, actual GC would
// only take place when number of allocated objects since last GC is >
// GCThreshold.   We can use smarter control or GC algortihm in the
// future if GC turns out to be a bottleneck performance problem.

// TODO: separate the globals so that we don't need to scan them.
// Probably need a MarkIfRoot function for root GCBases that can
// promise not to create new child.

// !!! This assumes that the roots, list, and global roots are already locked!!!!!

static int ActualGC(GCRoots roots, GCInfo *gcLst, GCListType& toBeFreed)
{
    DynamicHeapPusher dph(GetGCHeap());
    
    unsigned before = gcLst->allocated.size();
    TraceTag((tagGCStat, "Before GC: %d nodes used.\n", before));

#if PERFORMANCE_REPORTING
    DWORD startTime = GetPerfTickCount();
#endif    

    MarkClearMapObjs(globals);
    
    MarkClearMapObjs(roots);
    
    // Clear bits.
    for (GCListType::iterator i = gcLst->allocated.begin();
         i != gcLst->allocated.end(); i++) {
        GCBase *p = (*i);
        Assert(!IsBadWritePtr(p, sizeof(p)));
        p->ClearCache();
        p->SetMark(FALSE);
    }

#if PERFORMANCE_REPORTING
    {
        CritSectGrabber cs(*statLock);

        unmarkTime += Tick2Sec(GetPerfTickCount() - startTime);
    }        

    startTime = GetPerfTickCount();
#endif
    
    MarkRoots(roots, true);
    
    // Partition the marked and unmarked.  NOTE: Can't use remove_if
    // since it doesn't perserve the removed cell contents.
    GCListType::iterator newEnd =
        std::partition(gcLst->allocated.begin(),
                       gcLst->allocated.end(),
                       Marked());

    Assert((newEnd == gcLst->allocated.end()) || !(*newEnd)->Marked());

    Assert(toBeFreed.empty());
    
    // Move them into the toBeFreed list
    toBeFreed.splice(toBeFreed.begin(),
                     gcLst->allocated,
                     newEnd,
                     gcLst->allocated.end());
    
    unsigned after = gcLst->allocated.size();

    Assert(before >= after);
    
    TraceTag((tagGCStat, "After GC: %d nodes used, %d nodes reclaimed.\n",
              after, before - after));

    // Need to unmark coz transient object sub-trees can hold on to gc objs,
    // and the sub-trees are not on the root sets so won't get unmarked
    // automatically. 

    MarkRoots(roots, false);
     
    Assert((before - after) == toBeFreed.size());
    
    {
        CritSectGrabber cs(*statLock);

        lastReclaimed = before - after;

        totalReclaimed += lastReclaimed;

        numGCs++;
    }

#if PERFORMANCE_REPORTING
    {
        CritSectGrabber cs(*statLock);

        markTime += Tick2Sec(GetPerfTickCount() - startTime);
    }
#endif
    
    return after;
}

bool QueryActualGC(GCList gl, unsigned int& n)
{
    // Use the global GCList if not provided.
    GCInfo *gcLst = gl ? gl : GetGCList();

    Assert(gcLst);

    GCListGrabber csp(gcLst);

    int allocatedSinceLastGC =
        gcLst->allocated.size() - gcLst->lastAllocated;

    n = allocatedSinceLastGC;

    return (allocatedSinceLastGC > GCThreshold);
}

int GarbageCollect(GCRoots roots,
                   BOOL force, /* = FALSE */
                   GCList gl /* = NULL */)
{
    // Use the global GCList if not provided.
    GCInfo *gcLst = gl ? gl : GetGCList();

    Assert(gcLst);

    GCListType toBeFreed;

    int retVal = 0;

    // Need to get the collect lock first otherwise possible deadlock
    GC_COLLECT_BEGIN;
    GCMultiGrabber gclg(gl,roots);

    int sz = gcLst->allocated.size();

    int allocatedSinceLastGC = sz - gcLst->lastAllocated;

    if (force || (allocatedSinceLastGC > GCThreshold)) {
        gcLst->lastAllocated = ActualGC(roots, gcLst, toBeFreed);
    }

    Assert(sz >= gcLst->lastAllocated);
    
    retVal = gcLst->lastAllocated;

    // the last thing we are going to do before releasing the
    // lock is to mark all the objects invalid
    GCListType::iterator i = toBeFreed.begin() ;
    BYTE type;
    GCBase *obj;
#ifdef _DEBUG
    int numToBeFreed = 0;
#endif
        TraceTag((tagGCDebug, "GCObj::GarbageCollect checking toBeFreed list.\n"));
    while (i != toBeFreed.end()) {
        obj = *i;
            TraceTag((tagGCDebug, "GCObj::GarbageCollect checking object %lx.\n",obj));
        type = obj->GetType();
        // call all the GCObj Invalid routines
        if (type == GCBase::GCOBJTYPE) {
            Assert(DYNAMIC_CAST(GCObj* , obj));
            ((GCObj*) obj)->SetValid(false);
        }
        else {
            Assert(DYNAMIC_CAST(StoreObj*, obj));
        }
        i++;
#ifdef _DEBUG
                numToBeFreed++;
#endif
    }
        TraceTag((tagGCDebug, "GCObj::GarbageCollect Done checking toBeFreed list, %d object to be Freed.\n",numToBeFreed));

    GC_COLLECT_END;

#if PERFORMANCE_REPORTING
#ifdef _DEBUG
    if (gcStat>1) {
        PerfPrintf("Collected: %d.  Still allocated: %d\n",
                      toBeFreed.size(), retVal);
    }
#endif
#endif
    
    IncrementalFree(toBeFreed, force?true:false);

    return retVal;
}

#if PERFORMANCE_REPORTING
#ifdef _DEBUG
static GCBase *GetListTypeInfo(GCListType::iterator i)
{ return *i; }

static GCBase *GetMapTypeInfo(GCRootMap::iterator i)
{ return (*i).first; }

template<class InputIterator>
void
DumpByTypes(InputIterator first, InputIterator last,
            size_t sz, char *title, GCBase *fp(InputIterator))
{
    typedef map< const type_info*, int, less<const type_info*> > TypeMap;
    typedef map< const type_info*, size_t, less<const type_info*> >
        TypeSizeMap;

    TypeMap tMap;
    TypeMap tSzMap;

    for (InputIterator i = first; i != last; i++) {

        GCBase *b = fp(i);

        if (globals->roots.find(b) == globals->roots.end()) {
        
            TypeMap::iterator p = tMap.find(&typeid(*b));

            if (p == tMap.end()) {
                tMap[&typeid(*b)] = 1;
                //tSzMap[&typeid(*b)] = (b)->Size();
                if (DYNAMIC_CAST(GCBase*, b)->GetType() == GCBase::GCOBJTYPE)
                    tSzMap[&typeid(*b)] = GetSystemHeap().PtrSize(b);
                else
                    // Don't know which heap to use
                    tSzMap[&typeid(*b)] = 0; // GetGCHeap().PtrSize(b)
            } else
                tMap[&typeid(*b)] = (*p).second + 1;
        }
    }

    int tab = 0;

    PerfPrintf("\n");
    PerfPrintf("%s: %d\n", title, sz);
    
    for (TypeMap::iterator j = tMap.begin(); j != tMap.end(); j++) {
        PerfPrintf("%.12s-%d(%d)\t", (*j).first->name() + 6, (*j).second,
               tSzMap[(*j).first]);
        if ((++tab % 3) == 0) PerfPrintf("\n");
    }

    PerfPrintf("\n");
}
#endif

#if DEVELOPER_DEBUG
LONG GetLocksSinceLastTick();
LONG GetUnlocksSinceLastTick();
void ResetLockCounts();
LONG GetSwitchCount();
void ResetSwitchCount();
#endif

void GCPrintStat(GCList gl, GCRoots appRoots)
{
    // Use the global GCList if not provided.
    GCInfo *gcLst = gl ? gl : GetGCList();

    // DEADLOCK: TODO: Ensure we are acquiring in the right order -
    // possible deadlock!!!
    GCMultiGrabber csp(gcLst,appRoots,TRUE,TRUE);

    if (numGCs) {
#if DEVELOPER_DEBUG
        LONG l = GetLocksSinceLastTick();
        LONG ul = GetUnlocksSinceLastTick();
        ResetLockCounts();
        
        PerfPrintLine("Number of COM objects: created = %d, freed = %d; ", l, ul);

        LONG lswitches = GetSwitchCount();
        ResetSwitchCount();

        PerfPrintLine("Number of Switches: %d; ", lswitches);
#endif
        PerfPrintLine("Number of actual GC called since last report: %d; ", numGCs);
        PerfPrintLine("Number of objects allocated: %d; ", gcLst->allocated.size());
        PerfPrintLine("Number of objects allocated since last GC: %d; ",
                      gcLst->allocated.size() - gcLst->lastAllocated);
        PerfPrintLine("Reclaimed %d objects since last report; ",
                      totalReclaimed);
        PerfPrintLine("Reclaimed %d objects during last GC; ",
                      lastReclaimed);
        PerfPrintLine("Number of globals %d; ", globals->roots.size());
        
        int total = 0;
        
        PerfPrintf("Calls to new");
        for(GCNewStatMap::iterator j = newStatMap->begin();
            j != newStatMap->end(); j++) {
            if ((*j).second) {
                total += (*j).second;
                PerfPrintf("[%d]-%d ",(*j).first,(*j).second);
                (*j).second = 0;
            }
        }

        PerfPrintLine("Total = %d", total);
        
        double totalGCTime = (unmarkTime + markTime);
        double mul = 100 / totalGCTime;
        PerfPrintLine("    GC %g - unmark %g%%, mark & sweep %g%%, MT freeing %g; ",
                      totalGCTime,
                      mul * unmarkTime,
                      mul * markTime,
                      collectTime);
        unmarkTime = markTime = collectTime = 0.0;

#ifdef PERFORMANCE_REPORTING
#ifdef _DEBUG
        if (gcStat>1) {
            if (appRoots) {
                DumpByTypes(appRoots->roots.begin(),
                            appRoots->roots.end(),
                            appRoots->roots.size(),
                            "Non-global Roots", GetMapTypeInfo);
            }
            /*
            DumpByTypes(globals->begin(), globals->end(),
                        globals->size(), "Globals", GetMapTypeInfo);
                        */
            DumpByTypes(gcLst->allocated.begin(),
                        gcLst->allocated.end(),
                        gcLst->allocated.size(), 
                        "Allocated", GetListTypeInfo);
        }
#endif
#endif
       
        totalReclaimed = lastReclaimed = numGCs = 0;

#if !FREE_IMMEDIATELY
        int reused = 0;
        int reusedBtyes = 0;

        /*
        cout << numFreed << " objects freed since last report\n";
        if (!gcLst->toBeFreed.empty())
            cout << gcLst->toBeFreed.size() << " objects to be freed\n";
            */
        
        PerfPrintf("Free map report:");
        for(GCFreeMap::iterator i = gcLst->freeMap.begin();
            i != gcLst->freeMap.end(); i++) {
            int s = (*i).second->size();
            if (s) {
                PerfPrintf ("[%d]-%d ", (*i).first, s);
                reused += s;
                reusedBtyes += (*i).first * s;
            }
        }

        PerfPrintLine();
        PerfPrintf("Total reusable objects: %d; ", reused);
        PerfPrintf("Total reusable bytes: %d; ", reusedBtyes);

        PerfPrintLine();
        //numFreed = 0;
#endif
    }
}
#endif // PERFORMANCE_REPORTING

#if DEVELOPER_DEBUG
void
DumpGCRoots(GCRoots roots)
{
    if (roots->roots.size() != 0) {
        OutputDebugString ("DANIM.DLL: Detected unfreed GC roots\n");
        OutputDebugString ("Listing pointers and types:\n");
        
#if PERFORMANCE_REPORTING
        DumpByTypes(roots->roots.begin(),
                    roots->roots.end(),
                    roots->roots.size(),
                    "",
                    GetMapTypeInfo);
#endif
        for (GCRootMap::iterator i = roots->roots.begin();
             i != roots->roots.end(); i++) {
            GCBase *p = (*i).first;

            char buf[1024];
            wsprintf(buf, "0x%d\n", p);
            
            OutputDebugString(buf);
        }
    }
}

#endif

void
DeleteGCObject(GCBase * obj)
{
    BYTE type;

    type = obj->GetType();

    Assert((type == GCBase::GCOBJTYPE) ||
           (type == GCBase::STOREOBJTYPE));

#ifdef _DEBUG
    obj->SetMark(0xBB);
#endif
    // NOTE: Need to do that since we can't make delete and new
    // virtual.  Calling delete on obj won't call the subclass
    // delete. 
    obj->SetType(GCBase::GCFREEING);

    if (type == GCBase::GCOBJTYPE) {
        Assert(DYNAMIC_CAST(GCObj* , obj));
        delete (GCObj*) obj;
    }
    else {
        Assert(DYNAMIC_CAST(StoreObj*, obj));
        delete (StoreObj*) obj;
    }
}

static void IncrementalFree(GCListType& toBeFreed, bool bForce)
{
    TraceTag((tagGCDebug, "GCObj::IncrementalFree starting.\n"));
#if PERFORMANCE_REPORTING
#ifdef _DEBUG
    if (gcStat>2) {
        DumpByTypes(toBeFreed.begin(),
                    toBeFreed.end(),
                    toBeFreed.size(),
                    "ToBeFreed", GetListTypeInfo);
    }
#endif
    DWORD startTime = GetPerfTickCount();
#endif    

    // So that DeallocateFromStore in the destructor will have the
    // right heap.  
    DynamicHeapPusher dph(GetGCHeap());
    
    //for (int i=0; i<GCFreeRate; i++)
    //if (gcLst->toBeFreed.empty())
    //break;

    GCBase *obj;
#ifdef _DEBUG
    int numFreed = 0;
#endif
    while (!toBeFreed.empty()) {
        
        obj = toBeFreed.front();

        Assert(!obj->Marked());

        DeleteGCObject(obj);
        
        toBeFreed.pop_front();

#ifdef _DEBUG
        numFreed++;
#endif
    }

#if PERFORMANCE_REPORTING
    {
        CritSectGrabber cs(*statLock);

        collectTime += Tick2Sec(GetPerfTickCount() - startTime);
    }        
#endif
    TraceTag((tagGCDebug, "GCObj::IncrementalFree done, %d object Released.\n", numFreed));
}

void
CleanUpGCList(GCList gcLst, GCRoots roots)
{
    // Just remove everything from the roots
    //!!!! Must remove from the roots first otherwise the GC thread
    // could come in between the true calls and try to actually look
    // at the gclist objects.  IF we remove from the roots and GC
    // kicks it will just block us while it frees everything anyway.
    
    if (roots)
    {
        GCRootGrabber gcrg(roots);
        roots->roots.clear();
    }

    if (gcLst)
    {
        // So that DeallocateFromStore in the destructor will have the
        // right heap.
        DynamicHeapPusher dph(GetGCHeap());
    
        GCListGrabber csp(gcLst);
        
        GCListType::iterator i;
        
        for (i = gcLst->allocated.begin(); i != gcLst->allocated.end(); i++)
            DeleteGCObject(*i);
        
        gcLst->allocated.clear();
        
#if 0
        for (i = gcLst->toBeFreed.begin(); i != gcLst->toBeFreed.end(); i++)
            ::delete(*i);
#endif
        
#if !FREE_IMMEDIATELY
        GCFreeMap::iterator j;
        ListType::iterator k;
        
        for (j = gcLst->freeMap.begin(); j != gcLst->freeMap.end(); j++)
        {
            ListType * sec = (*j).second;
            
            for (k = sec->begin(); k != sec->end(); k++)
                StoreDeallocate(GetSystemHeap(), *k);
            
            delete sec;
        }
        
        gcLst->freeMap.clear();
#endif
    }
    
}

void
InitializeModule_Gc()
{
#if PERFORMANCE_REPORTING
    newStatMap = NEW GCNewStatMap;
#endif
    statLock = NEW CritSect();
    globals = NEW GCRootsImpl();
}

void
DeinitializeModule_Gc(bool bShutdown)
{
    if (globals) {
#if 0
        GCRootMap::iterator i;
        
        for (i = globals->roots.begin(); i != globals->roots.end(); i++)
            DeleteGCObject((*i).first);
#endif        
        delete globals;
    }

#if PERFORMANCE_REPORTING
    delete newStatMap;
#endif
    delete statLock;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\cond.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Conditional

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "privinc/server.h"
#include "appelles/axaprims.h"

// TODO: put it in a real .h file.
extern "C" void Mute(AxAValueObj *v, GenericDevice &dev);
extern Bvr ApplyGain(Bvr pan, Bvr snd);
extern Bvr ApplyPan(Bvr pan, Bvr snd);

DeclareTag(tagCond, "Engine", "Track Cond Transitions");

template <class T, class Impl>
class ATL_NO_VTABLE IfGCBase : public Impl {
  public:
    IfGCBase(T c, T i, T e) : _cond(c), _ifb(i), _elseb(e) {}

#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        return os
            << "if(" << _cond << ", " << _ifb << ", " << _elseb << ")";
    }
#endif

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_cond);
        (*proc)(_ifb);
        (*proc)(_elseb);
    }
    
  protected:
    T _cond;
    T _ifb;
    T _elseb;
};    

class CondPerfImpl : public IfGCBase<Perf, PerfImpl> {
  public:
    CondPerfImpl(Perf c, Perf i, Perf e)
    : IfGCBase<Perf, PerfImpl>(c, i, e), _lastConditionalState(-1) {}

    virtual AxAValue _GetRBConst(RBConstParam& rbp) {

        AxAValue c = _cond->GetRBConst(rbp);

        if (c) {
            
            return (BooleanTrue(c) ? _ifb : _elseb)->GetRBConst(rbp);
            
        } else {

            /*
            AxAValue ifConst = _ifb->GetRBConst(rbp);
            AxAValue elseConst = _elseb->GetRBConst(rbp);

            if (ifConst || elseConst) {

                TraceTag((tagCond,
                          "Cond 0x%x watching state=%d, if=0x%x, else=0x%x",
                          this,
                          _lastConditionalState,
                          ifConst,
                          elseConst));
                

                // We're going to let RBConst do its thing on the
                // "current" branch, but we need to set up a "watch" for
                // the conditional value.
                rbp.AddConditional(this);

                // TODO: couldn't figure out why the _lastConditionalState
                // was not right.  so be conservative here.
                // see bug 28210 when this is enabled.  
                //return (_lastConditionalState ? ifConst : elseConst);
                
            } 
            */
            
            return NULL;
        }
    }

    virtual bool CheckChangeables(CheckChangeablesParam& ccp) {
        Bool conditionalState =
            BooleanTrue(_cond->Sample(ccp._sampleParam));

        if (conditionalState != _lastConditionalState) {
            TraceTag((tagCond,
                      "Cond 0x%x CheckChangeables from %d to %d at %g[%d]",
                      this,
                      _lastConditionalState,
                      conditionalState,
                      ccp._sampleParam._time,
                      ccp._sampleParam._id));

            _lastConditionalState = conditionalState;
            
            return true;
        }
            
        return false;
    }
    
    virtual AxAValue _Sample(Param& p) {

        Bool conditionalState = BooleanTrue(_cond->Sample(p));

        if (conditionalState)
            return _ifb->Sample(p);
        else
            return _elseb->Sample(p);
        
    }

  private:
    Bool _lastConditionalState;
};

class CondBvrImpl : public IfGCBase<Bvr, BvrImpl> {
  public:
    CondBvrImpl(Bvr c, Bvr i, Bvr e)
    : IfGCBase<Bvr, BvrImpl>(c, i, e), _end(NULL)
    { GetInfo(true); }

    virtual DWORD GetInfo(bool recalc) {
        if (recalc) {
            _info = _cond->GetInfo(recalc) &
                _ifb->GetInfo(recalc) & _elseb->GetInfo(recalc);
        }

        return _info;
    }
    
    virtual Bvr EndEvent(Bvr overrideEvent) {
        Bvr ret = _end;
        
        if (overrideEvent || ret==NULL) {
            ret = CondBvr(_cond,
                           _ifb->EndEvent(overrideEvent),
                          _elseb->EndEvent(overrideEvent));

            if (!overrideEvent)
                _end = ret;
        }

        return ret;
    } 

    virtual void _DoKids(GCFuncObj proc) {
        IfGCBase<Bvr, BvrImpl>::_DoKids(proc);
        (*proc)(_end);
    }

    virtual Perf _Perform(PerfParam& p) {
        ConstParam cp;
        AxAValue v = _cond->GetConst(cp);

        if (v) {
            return
                (BooleanTrue(v) ? _ifb : _elseb)->Perform(p);
        } else {        
            return NEW CondPerfImpl(::Perform(_cond, p),
                                    ::Perform(_ifb, p),
                                    ::Perform(_elseb, p));
        }
    }

    virtual DXMTypeInfo GetTypeInfo () { return _ifb->GetTypeInfo(); }

    virtual AxAValue GetConst(ConstParam & cp) {
        AxAValue v = _cond->GetConst(cp);

        if (v) {
            return (BooleanTrue(v) ? _ifb : _elseb)->GetConst(cp);
        }

        return NULL;
    }
    
  private:
    DWORD _info;
    Bvr _end;
};

Bvr CondBvr(Bvr c, Bvr i, Bvr e)
{
    DXMTypeInfo t = i->GetTypeInfo();
    
    CheckMatchTypes("cond", t, e->GetTypeInfo());

    return NEW CondBvrImpl(c, i, e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "privinc/server.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\gcthread.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    GC Thread and related code

*******************************************************************************/

#include <headers.h>

#include "gci.h"
#include "privinc/server.h"
#include "privinc/except.h"
#include "privinc/debug.h"
#include "privinc/mutex.h"
#include "privinc/ipc.h"
#if PERFORMANCE_REPORTING
// For Tick2Sec & GetPerfTickCount
#include "privinc/util.h"
#endif

DeclareTag(tagGC, "GC", "GC functions");

static CritSect* collectorLock = NULL;
// Don't need a lock 'cause a false check won't hurt
bool holdGCMsg = false;

#define GCTIMER_DELAY 10000
#define GCTIMER_ID 1

// TODO: Starvation of the collector thread is still possible - needs
// to be addressed at some point

class GCAccess
{
  public:
    GCAccess()
    : _nGCAlloc(0),
      _GCAllocEvent(FALSE,TRUE)
    {}

    void Acquire(GCLockAccess access);
    void Release(GCLockAccess access);
    int GetStatus(GCLockAccess access);

#if DEVELOPER_DEBUG
    bool IsAcquired(DWORD tid) {
        GCThreadMap::iterator i = _threadMap.find(tid);

        return i != _threadMap.end();
    }
#endif
  protected:
    CritSect _GCAllocCS;
    int _nGCAlloc;
    Win32Event _GCAllocEvent;
#if DEVELOPER_DEBUG
    CritSect _debugCS;
    typedef map< DWORD, int, less<DWORD> > GCThreadMap;
    GCThreadMap _threadMap;
#endif
#ifdef NO_STARVATION
    CritSect _GCCollectCS;
#endif
};

static GCAccess * gcAccess = NULL;

void
GCAccess::Acquire(GCLockAccess access)
{
    switch (access) {
      case GCL_CREATE:
      case GCL_MODIFY:
        {
#ifdef DEVELOPER_DEBUG
            {
                CritSectGrabber csg(_debugCS);
                
                DWORD tid = GetCurrentThreadId();
                GCThreadMap::iterator i = _threadMap.find(tid);
                
                if (i != _threadMap.end()) {
                    (*i).second = (*i).second + 1;
                } else
                    _threadMap[tid] = 1;
            }
#endif
#ifdef NO_STARVATION
            // This will ensure that we do not starve
            _GCCollectCS.Grab();
            _GCCollectCS.Release();
#endif
            
            CritSectGrabber csg(_GCAllocCS);

            // The first reader would block here and all the rest will
            // block on the critsect
            
            if (++_nGCAlloc == 1)
                _GCAllocEvent.Wait();

            break;
        }
      case GCL_COLLECT:
#ifdef DEVELOPER_DEBUG
            {
                CritSectGrabber csg(_debugCS);
                
                DWORD tid = GetCurrentThreadId();
                GCThreadMap::iterator i = _threadMap.find(tid);

                Assert(i == _threadMap.end() && "DEADLOCK - bad thread tried to GC");
            }
#endif            
#ifdef NO_STARVATION
        _GCCollectCS.Grab();
#endif
        _GCAllocEvent.Wait();
        
        break;
      default:
        Assert(FALSE && "AcquireGCLock::Invalid lock type");
        break;
    }
}

void
GCAccess::Release(GCLockAccess access)
{
    switch (access) {
      case GCL_CREATE:
      case GCL_MODIFY:
        {
#ifdef DEVELOPER_DEBUG
            {
                CritSectGrabber csg(_debugCS);
                
                DWORD tid = GetCurrentThreadId();
                GCThreadMap::iterator i = _threadMap.find(tid);

                Assert(i != _threadMap.end());

                Assert((*i).second > 0);

                (*i).second = (*i).second - 1;

                if ((*i).second == 0) 
                    _threadMap.erase(i);
            }
#endif            
            CritSectGrabber csg(_GCAllocCS);

            if (--_nGCAlloc == 0)
                _GCAllocEvent.Signal();

            break;
        }
      case GCL_COLLECT:
        _GCAllocEvent.Signal();
#ifdef NO_STARVATION
        _GCCollectCS.Release();
#endif
        break;
      default:
        Assert(FALSE && "AcquireGCLock::Invalid lock type");
        break;
    }
}

int
GCAccess::GetStatus(GCLockAccess access)
{
    int n = 0;
    
    switch (access) {
      case GCL_CREATE:
      case GCL_MODIFY:
        break;
      case GCL_COLLECT:
        break;
      default:
        Assert(FALSE && "AcquireGCLock::Invalid lock type");
        break;
    }

    return n;
}

void AcquireGCLock(GCLockAccess access)
{ gcAccess->Acquire(access); }
void ReleaseGCLock(GCLockAccess access)
{ gcAccess->Release(access); }
int GetGCLockStatus(GCLockAccess access)
{ return gcAccess->GetStatus(access); }
#if DEVELOPER_DEBUG
bool IsGCLockAcquired(DWORD tid)
{ return gcAccess->IsAcquired(tid); }
#endif

//
// The main garbage collector thread
//

#define MSG_GC 0x01

class GarbageCollector : public DAThread
{
  public:
    GarbageCollector() : _GChappened(false) {}

    bool GarbageCollect(bool force, bool sync = false, DWORD dwMill = INFINITE);
    bool _GChappened;
    
  protected:
    virtual void ProcessMsg(DWORD dwMsg,
                            DWORD dwNumParams,
                            DWORD_PTR dwParams[]);

    virtual bool IPCProc (HWND hwnd,
                          UINT msg,
                          WPARAM wParam,
                          LPARAM lParam,
                          LRESULT & res);

    virtual bool InitThread();
    virtual bool DeinitThread();
    
    void doGC(bool bForce = FALSE);

#if DEVELOPER_DEBUG
    virtual char * GetName() { return "GarbageCollector"; }
#endif
};

static GarbageCollector * collector = NULL;

bool
GarbageCollector::GarbageCollect(bool force, bool sync, DWORD dwMill)
{
    bool bRet = true;
    
    if (IsStarted()) {
        if (sync || !holdGCMsg) { 
            // We should not try to sync if the current thread has the GC Lock
            Assert (!sync || !IsGCLockAcquired(GetCurrentThreadId()));
            
            if (sync)
                bRet = SendSyncMsg(MSG_GC, dwMill, 1, (DWORD) force);
            else
                bRet = SendAsyncMsg(MSG_GC, 1, (DWORD) force);

            holdGCMsg = true;
        }
    }

    return bRet;
}

bool
GarbageCollector::InitThread()
{
    if (!DAThread::InitThread())
        return false;
    
    UINT_PTR timerId = SetTimer(_hwnd, GCTIMER_ID, GCTIMER_DELAY, NULL);

    Assert (timerId != 0);

#ifdef _DEBUG
    if (IsTagEnabled(tagGCStress)) {
        while (true) {
            doGC(true);
            Sleep(100);
        }
    }
#endif

    return true;
}

bool
GarbageCollector::DeinitThread()
{
    KillTimer(_hwnd,GCTIMER_ID);

    return DAThread::DeinitThread();
}

void
GarbageCollector::ProcessMsg(DWORD dwMsg,
                             DWORD dwNumParams,
                             DWORD_PTR dwParams[])
{
    if (dwMsg == MSG_GC) {
        Assert (dwNumParams == 1);
        doGC(dwParams[0] != 0);
        holdGCMsg = false;
    } else
        Assert (false && "Invalid message sent to GC thread");
}

bool
GarbageCollector::IPCProc (HWND hwnd,
                           UINT msg,
                           WPARAM wParam,
                           LPARAM lParam,
                           LRESULT & res)
{
    // If we are in the entry point do not do anything

    if (bInitState)
        return false;

    if (msg == WM_TIMER) {
        if (wParam == GCTIMER_ID) {
            // If GC happened in last GCTIMER_DELAY, reset the GChappened flag
            if (_GChappened) {
                _GChappened = false;
            } else {
                unsigned int n;

                QueryActualGC(GetCurrentGCList(), n);

                // No GC in the last GCTIMER_DELAY and some objects allocated
                // since, let's force a GC

                Assert (GetCurrentThreadId() == _dwThreadId);
                // Call doGC directly since we know we are on the
                // correct thread
                doGC(n > 0);
            } 
        } else {
            Assert (FALSE && "Bad timer id to gc thread");
        }
    }
    
    return DAThread::IPCProc(hwnd, msg, wParam, lParam, res);
}

void
GarbageCollector::doGC(bool bForce)
{
    unsigned int i;
    
    bool bDoGC = bForce || QueryActualGC(GetCurrentGCList(), i);

    if (bDoGC) {
        ReportGCHelper(TRUE);

        __try {
            ::GarbageCollect(GetCurrentGCRoots(),
                             bForce,
                             GetCurrentGCList());
            _GChappened = true;
        } __except ( HANDLE_ANY_DA_EXCEPTION ) {
            TraceTag((tagGC,
                      "GarbageCollect: Exception caught."));
            ReportErrorHelper(DAGetLastError(), DAGetLastErrorString());
        }

        ReportGCHelper(FALSE);
    }
}

void
StartCollector()
{
    CritSectGrabber cs(*collectorLock);

    if (!collector->Start())
        RaiseException_InternalError("Could not create GC Thread");
}

void
StopCollector()
{
    CritSectGrabber cs(*collectorLock);

    if (!collector->Stop())
        RaiseException_InternalError("Could not stop GC Thread");
}

bool
GarbageCollect(bool force, bool sync, DWORD dwMill)
{
    StartCollector();

    return collector->GarbageCollect(force, sync, dwMill);
}


void
InitializeModule_GcThread()
{
    gcAccess = new GCAccess;
    collectorLock = new CritSect();
    collector = new GarbageCollector();
}

void
DeinitializeModule_GcThread(bool bShutdown)
{
    delete collector;
    delete collectorLock;
    delete gcAccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\handle.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Handle events.

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "appelles/events.h"
#include "events.h"
#include "values.h"

extern const char THENAPPLY[] = "thenApply";

/////////////////////////// Handle Event ///////////////////////////////

template<class T1, class T2, class Impl, const char* Name>
class HandleGCBase : public Impl {
  public:
    HandleGCBase(T1 e, T2 b) : _event(e), _b(b) {}

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_event);
        (*proc)(_b);
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) 
    { return os << Name << "(" << _event << ", " << _b << ")"; }
#endif

  protected:
    T1 _event;
    T2 _b;
};

///////////////// Handle Bvr ///////////////////

class HandlePerfImpl : public HandleGCBase<Perf, Bvr, PerfImpl, THENAPPLY> {
  public:
    HandlePerfImpl(Perf event, Bvr edata)
        : HandleGCBase<Perf, Bvr, PerfImpl, THENAPPLY>(event, edata) {}
    
    virtual AxAValue _Sample(Param& p) {
        AxAEData *edata = ValEData(_event->Sample(p));

        if (edata->Happened())
            return CreateEData(edata->HappenedTime(), _b);
        else
            return noEvent;
    }
};

class HandleBvrImpl : public HandleGCBase<Bvr, Bvr, BvrImpl, THENAPPLY> {
  public:
    HandleBvrImpl(Bvr event, Bvr b)
    : HandleGCBase<Bvr, Bvr, BvrImpl, THENAPPLY>(event, b) {}

    virtual BOOL InterruptBasedEvent() { return _event->InterruptBasedEvent();}

    virtual Perf _Perform(PerfParam& p) {
        return NEW HandlePerfImpl(::Perform(_event, p), _b);
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
};

Bvr HandleEvent(Bvr e, Bvr b)
{ return NEW HandleBvrImpl(e, b); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\gc.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Garbage collector header

*******************************************************************************/


#ifndef _GC_H
#define _GC_H

#include "privinc/backend.h"

class GCBase;

class ATL_NO_VTABLE GCFuncObjImpl
{
  public:
    virtual void operator() (GCBase *gcobj) = 0;
};

typedef GCFuncObjImpl *GCFuncObj;

#ifdef new
#define STOREOBJ_NEWREDEF
#undef new
#endif

class GCBase {
  public:
    enum { GCOBJTYPE, STOREOBJTYPE, GCFREEING };
        
    GCBase() : _mark(FALSE), _valid(true), _type(GCOBJTYPE) {}

    // NOTE: Call CleanUp in your destructor if you define CleanUp.
    // We can't call the virtual function from the base at clean up
    // time. 
    virtual ~GCBase() {}  
    virtual void CleanUp() { }

    void SetMark(BYTE b) { _mark = b; }
    BOOL Marked() { return _mark; }

    void SetValid(bool b) { _valid = b; }
    BOOL Valid() { return _valid; }

    void SetType(BYTE t) { _type = t; }
    BYTE GetType() { return _type; }

    virtual void DoKids(GCFuncObj) {}

    // Clear the cache before GC.  Currently only behavior would clear
    // its cache.   Assuming GC only happens between evaluations.
    virtual void ClearCache() { }

#if _USE_PRINT
    // TODO: Make it a pure virtual
    // Print a representation to a stream.
    virtual ostream& Print(ostream& os) { return os << (void*) this; }

    friend ostream& operator<<(ostream& os, GCBase& val)
    { return val.Print(os) ; }
#endif
    
  protected:
    BYTE _type;
    
  private:
    BYTE _mark;
    bool _valid;
};

class GCObj : public GCBase {
  public:
    GCObj();
    virtual ~GCObj();

#if _DEBUGMEM
    void *operator new(size_t s, int blockType, char * szFileName, int nLine);
#else
    void *operator new(size_t s);
#endif // _DEBUGMEM

    void operator delete(void *ptr, size_t s);
};

#ifdef STOREOBJ_NEWREDEF
#undef STOREOBJ_NEWREDEF
#define new new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif

GCList CreateGCList();

// Remove all the roots and delete all the objects on the list

void CleanUpGCList(GCList, GCRoots);

void FreeGCList(GCList);

GCRoots CreateGCRoots();
void FreeGCRoots(GCRoots r);

bool GarbageCollect(bool force = false,
                    bool sync = false,
                    DWORD dwMill = INFINITE);

void GCPrintStat(GCList gl = NULL, GCRoots roots = NULL);

// Add/Remove GCObj from the root multi-set.  
void GCAddToRoots(GCBase *ptr, GCRoots roots);
void GCRemoveFromRoots(GCBase *ptr, GCRoots roots);

class GCIUnknown : public GCObj {
  public:
    GCIUnknown(LPUNKNOWN d) : _data(d) {
        if (_data) _data->AddRef();
    }

    ~GCIUnknown() { CleanUp(); }

    LPUNKNOWN GetIUnknown() { return _data; }
    
    virtual void CleanUp() {
        // Check to see if we can at least access the data
        Assert(!IsBadReadPtr(_data, sizeof(_data)));

        if (!IsBadReadPtr(_data, sizeof(_data)))
            _data->Release();
    }

    virtual void DoKids(GCFuncObj proc) { }
    
  private:
    LPUNKNOWN _data;
};

#endif /* _GC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\gci.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _GCI_H
#define _GCI_H

#include "gc.h"
#include "privinc/mutex.h"

int GarbageCollect(GCRoots roots, BOOL force, GCList gl);

bool QueryActualGC(GCList gl, unsigned int& allocatedSinceGC);

void GCAddToAllocated(GCBase* obj);

void GCRemoveFromAllocated(GCBase* obj);

#endif /* _GCI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\imprtnce.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implements behavior "importance"

*******************************************************************************/

#include "headers.h"
#include "privinc/imagei.h"
#include "backend/bvr.h"
#include "backend/perf.h"
#include "privinc/dddevice.h"

class ImportancePerfImpl : public PerfImpl {
  public:
    ImportancePerfImpl(Real importanceValue,
                       Perf underlyingPerf) {
        _importanceValue = importanceValue;
        _underlyingPerf = underlyingPerf;
        _cachedValue = NULL;
        _sampleCount = 0;
        _cacheToReuse = NULL;
    }

    virtual AxAValue _Sample(Param& p) {

        Real stashedImportance = p._importance;
        Real imp = stashedImportance * _importanceValue;
        
        if (imp > 1) {
            imp = 1;
        } else if (imp <= 0) {
            imp = 0.0001;
        }

        int  updateFrequency = (int)(1.0 / imp);

        AxAValue result;
        
        if (updateFrequency == 1) {
            
            // Gonna do it every frame... let it stay on the transient
            // heap.
            p._importance = imp;
            result = _underlyingPerf->Sample(p);
            p._importance = stashedImportance;
            
        } else if (_sampleCount >= updateFrequency || !_cachedValue) {

            // TODO BUG BUG: May want to more eagerly discard previous
            // cached values rather than waiting around for GC, since
            // they might be holding onto DDraw surfaces and other
            // expensive resources, for instance.  BUG BUG

            // Be sure this goes on the GC heap, not the transient
            // heap.
            DynamicHeapPusher dhp(GetGCHeap());
            
            // Really sample when it's time to
            p._importance = imp;

            result = _underlyingPerf->Sample(p);

            ImageDisplayDev *dev =
                GetImageRendererFromViewport(GetCurrentViewport());

            // Cache off and (possibly) reuse old cache storage.  This
            // second parameter gets filled in by the Cache() method.
            
            // TODO BUG BUG: This isn't in there yet, as there are
            // still some issues with resolving the lifetime of the
            // cache.  To see where we're at, uncomment and run
            // spiral-const.htm and watch it crash.  What's happening
            // is the DDSurface that's being used as a cache is stored
            // in a map with two images and when one gets GC'd, the
            // DDSurface goes away.  When the other get's GC'd, we try
            // to make the same DDSurf go away, but it's already
            // gone.  Crash!  Best solution would be to ref count the
            // ddsurf's so there can be multiple clients of them.
            // Need to think about!!!!
            // result = result->Cache(dev, &_cacheToReuse);

            // Stash back in...
            _cachedValue = result;
            
            p._importance = stashedImportance;

            _sampleCount = 1;
            
        } else {

            // Otherwise, use old value
            Assert(_cachedValue);
            result = _cachedValue;
            _sampleCount++;
            
        }

        return result;
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "ImportancePerfImpl"; }
#endif

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_underlyingPerf);
        (*proc)(_cachedValue);
        (*proc)(_cacheToReuse);
    }

  protected:
    Real        _importanceValue;
    Perf        _underlyingPerf;
    AxAValue    _cachedValue;
    AxAValue    _cacheToReuse;
    DWORD       _sampleCount;
};

class ImportanceBvrImpl : public DelegatedBvr {
  public:
    ImportanceBvrImpl(Real importanceValue, Bvr underlyingBvr)
    : DelegatedBvr(underlyingBvr), _importanceValue(importanceValue) {}

    // Standard methods
    virtual Perf _Perform(PerfParam& p) {
        return NEW ImportancePerfImpl(_importanceValue,
                                      ::Perform(_base, p));
    }
    
  protected:
    Real _importanceValue;
};

Bvr
ImportanceBvr(Real importanceValue, Bvr b)
{
    return NEW ImportanceBvrImpl(importanceValue, b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\jaxaimpl.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Interface with the Java API events.

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "timetran.h"
#include "appelles/events.h"
#include "privinc/server.h"
#include <danim.h>
#include "jaxaimpl.h"
#include "privinc/debug.h"
#include "server/context.h"
#include "server/view.h"
#include "privinc/util.h"
#include "server/import.h"

// ========================================
// Init bvr
// ========================================

class InitPerfImpl : public DelegatedPerf {
  public:
    InitPerfImpl() : DelegatedPerf(NULL), _processing(0), _processing2(false) {}

    void SetPerf(Perf perf) { _base = perf; }

    virtual Perf SwitchTo(Param&) { return _base; }

    virtual AxAValue _Sample(Param& p) {
        if (_processing == p._id) {
            if (_processing2) {
                _processing2 = false;
                _processing = 0;
                
#ifdef _DEBUG
                if (IsTagEnabled(tagCycleCheck))
                    //TraceTag((tagError, "circular behavior detected"));
                    RaiseException_UserError(E_FAIL, IDS_ERR_BE_CYCLIC_BVR);
#endif _DEBUG    
            }
            _processing2 = true;
        }

        unsigned int stashedID = _processing;
        
        _processing = p._id;
        
        AxAValue v = _base->Sample(p);

        _processing = stashedID;
        _processing2 = false;

        return v;
    }

#if _USE_PRINT
    ostream& Print(ostream& os) {
        if ((_processing!=0) || !_base)
            return os << "init";
        else {
            _processing = 1;
            os << "init(" << _base << ")";
            _processing = 0;
            return os;
        }
    }

#endif
  protected:
    unsigned int _processing;
    bool _processing2;
};

class InitBvrImpl : public BvrImpl {
  public:
    InitBvrImpl(DXMTypeInfo t)
    : _bvr(NULL), _typeInfo(t), _processing(false) {}

    void CycleCheck() {
        if (_processing) {
            _processing = false;
            
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_CYCLIC_BVR);
        }
            
        _processing = true;
    }

    virtual DWORD GetInfo(bool recalc) {
        // TODO: Should do something special...
        if (_bvr==NULL)
            return BVR_HAS_ALL;
        
        CycleCheck();
        
        DWORD info = _bvr->GetInfo(recalc);

        _processing = false;

        return info;
    }

    virtual AxAValue GetConst(ConstParam & cp) {
        if (_bvr==NULL)
            return NULL;
        
        CycleCheck();
        
        AxAValue v = _bvr->GetConst(cp);

        _processing = false;

        return v;
    }

    virtual Perf _Perform(PerfParam& p) {
        if (!_bvr)
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_UNINITIALIZED_BVR);

        InitPerfImpl* iPerf = NEW InitPerfImpl();

        SetCache(iPerf, p);        // for recursion

        iPerf->SetPerf(::Perform(_bvr, p));
        
        return iPerf;
    }

    virtual Bvr EndEvent(Bvr overrideEvent) {
        if (!_bvr)
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_UNINITIALIZED_BVR);

        return _bvr->EndEvent(overrideEvent);
    }
    
    // TODO: may not need be virtual...
    virtual void Init(Bvr bvr) {
        Assert(bvr);
        
        if (_bvr)
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_ALREADY_INIT);
        else
            _bvr = bvr;
    }

    void _DoKids(GCFuncObj proc) {
        if (_bvr) (*proc)(_bvr);
        (*proc)(_typeInfo);
    }
    
#if _USE_PRINT
    ostream& Print(ostream& os) {
        if (_processing || !_bvr)
            return os << "init";
        else {
            _processing = true;
            os << "init(" << _bvr << ")";
            _processing = false;
            return os;
        }
    }
#endif
        
    virtual DXMTypeInfo GetTypeInfo () { return _typeInfo; }
    
  private:
    Bvr _bvr;
    DXMTypeInfo _typeInfo;
    bool _processing;
};

Bvr InitBvr(DXMTypeInfo typeInfo)
{ return NEW InitBvrImpl(typeInfo); }

void SetInitBvr(Bvr bvr, Bvr ibvr)
{
    CheckMatchTypes("uninitBvr", bvr->GetTypeInfo(), ibvr->GetTypeInfo());
        
    bvr->Init(ibvr);
}

// ========================================
// start bvr
// ========================================

class StartedBvrImpl : public BvrImpl {
  public:
    StartedBvrImpl(Perf perf, DXMTypeInfo type)
    : _perf(perf), _typeInfo(type) { Assert(perf); }

    virtual Perf _Perform(PerfParam&) { return _perf; }

    virtual BOOL StartedBvr() { return TRUE; }

    Perf GetPerf() { return _perf; }
    
    void _DoKids(GCFuncObj proc) {
        (*proc)(_perf);
        (*proc)(_typeInfo);
    }
    
#if _USE_PRINT
    ostream& Print(ostream& os) { return os << "started " << _perf; }
#endif

    virtual DXMTypeInfo GetTypeInfo () { return _typeInfo; }
    
  private:
    Perf _perf;
    DXMTypeInfo _typeInfo;
};

Bvr StartedBvr(Perf b, DXMTypeInfo type)
{ return NEW StartedBvrImpl(b, type); }

// ========================================
// app trigger event
// ========================================
class AppTriggerEventPerfImpl : public PerfImpl {
  public:
    AppTriggerEventPerfImpl(DWORD appEventId, Time t0)
    : _appEventId(appEventId), _t0(t0) {}

    virtual AxAValue _Sample(Param& p) {
        AXAWindEvent* pData =
            AXAEventOccurredAfter(_t0, AXAE_APP_TRIGGER, _appEventId,
                                  0, 0, 0);

        if (pData) {
            TraceTag((tagAppTrigger,
                      "AppTrigger: %d at %g, (t0, t, sid) = %g, %g, %d\n",
                      _appEventId, pData->when, _t0, p._time, p._id));
            return CreateEData(pData->when, (Bvr) pData->x);
        }
        else
            return noEvent;
    }

    void Trigger(Bvr data, bool bAllViews)
    { TriggerEvent(_appEventId, data, bAllViews); }

    virtual void _DoKids(GCFuncObj proc) { }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "trigger"; }
#endif

  private:
    DWORD _appEventId;
    Time _t0;
};

class AppTriggerEventBvrImpl : public BvrImpl {
  public:
    AppTriggerEventBvrImpl() : _appEventId(NewSampleId()) {}

    virtual Perf _Perform(PerfParam& p)
    { return NEW AppTriggerEventPerfImpl(_appEventId, p._t0); }

    virtual void _DoKids(GCFuncObj) {}

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "trigger"; }
#endif

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }

    void Trigger(Bvr data, bool bAllViews)
    { TriggerEvent(_appEventId, data, bAllViews); }

  private:
    DWORD _appEventId;
};

Bvr AppTriggeredEvent()
{ return NEW AppTriggerEventBvrImpl(); }

void TriggerEvent(Bvr e, Bvr data, bool bAllViews)
{
    e->Trigger(data, bAllViews);
}

class UserDataBvrImpl : public BvrImpl
{
  public:
    UserDataBvrImpl(UserData data) : _data(data) {}

    virtual Perf _Perform(PerfParam&) {
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_PERF_USERDATA);
        return NULL;
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_data);
    }

#if _USE_PRINT
    ostream& Print(ostream& os) { return os << "userdata(" << _data << ")";}
#endif

    virtual DXMTypeInfo GetTypeInfo () { return UserDataType ; }

    UserData GetData() { return _data ; }
  protected:
    UserData _data;
};

Bvr UserDataBvr(UserData data)
{ return NEW UserDataBvrImpl(data); }

UserData GetUserDataBvr(Bvr ud)
{ return SAFE_CAST(UserDataBvrImpl*,ud)->GetData() ; }

static const unsigned int BVRPURE1 = BVR_HAS_NO_UNTIL | BVR_HAS_NO_ODE;
static const unsigned int BVRPURE = BVRPURE1 | BVR_HAS_NO_SWITCHER;  

bool BvrIsPure1(Bvr b)
{
    return (b->GetInfo() & BVRPURE1) == BVRPURE1;
}

bool BvrIsPure(Bvr b)
{
    // TODO: Check for view dependent as well
    return (b->GetInfo() & BVRPURE) == BVRPURE;
}

Bvr SampleAtLocalTime(Bvr b, Time localTime)
{
//    if (BvrIsPure1(b))
    {
        Perf pf = Perform(b, *zeroStartedPerfParam);

        Param p(localTime);

        return ConstBvr(pf->Sample(p));
    }

//    return NULL;
}


/////////////////////////// Import Event ///////////////////////////////
class ImportEventImpl;

class ImportPerfImpl : public PerfImpl
{
  public:
    ImportPerfImpl(ImportEventImpl* b) : _bvr(b) {}
    
    virtual AxAValue _Sample(Param& p);

    virtual void _DoKids(GCFuncObj proc) ;

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "import"; }
#endif
  protected:
    ImportEventImpl*  _bvr;
};

////////// Bvr ////////////////

// Synchronization!! - We will not worry about adding synchronization
// since we only set this from 0 to 1 and that should never cause us
// to get invalid data for more than one sample - and that would just
// cause us to miss the event on the current sample.  In most cases
// (if not all) the set is atomic at the processor level anyway and
// will not cause us problems.

class ImportEventImpl : public BvrImpl
{
  public:
    ImportEventImpl() : _errorCode(NULL) {}
    ~ImportEventImpl() {
        CleanUp(); // GC says we must call this
    }

    virtual void CleanUp(){
        // tell the import site class that this bvr is dying
        // so all sites associated with it can cleanup...
        if (_ImportSite) {
            _ImportSite->vBvrIsDying(this);
            _ImportSite.Release();
        }
        BvrImpl::CleanUp(); // GC says we must call this
        }
    virtual Perf _Perform(PerfParam&)
    { return NEW ImportPerfImpl(this); }

    void Set(int errorCode) {
        _errorCode = NumToBvr(errorCode);
    }
    
    Bvr IsSet() { return _errorCode ; }
    
    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_errorCode);
    }
    
    void SetImportSite(IImportSite * pImport) {Assert(!_ImportSite);
                                              _ImportSite = pImport;}
    IImportSite * GetImportSite(void) {return _ImportSite;}
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "import"; }
#endif
  protected:
    DAComPtr <IImportSite> _ImportSite;
    Bvr _errorCode;
};

AxAValue ImportPerfImpl::_Sample(Param& p)
{
    Bvr rtnCode = _bvr->IsSet();
    
    if (rtnCode) { 
        ViewEventHappened() ;
        return CreateEData(p._time, rtnCode);
    } else
        return noEvent;
}

void ImportPerfImpl:: _DoKids(GCFuncObj proc)
{ (*proc)(_bvr); }

Bvr ImportEvent()
{ return NEW ImportEventImpl() ; }

void SetImportEvent(Bvr b, int errorCode)
{
    Assert(DYNAMIC_CAST(ImportEventImpl*, b) != NULL);
    
    ((ImportEventImpl *) b)->Set(errorCode) ;
}

////////////////////////// Anchor ////////////////////////////

class AnchorPerfImpl : public DelegatedPerf {
  public:
    AnchorPerfImpl(Perf p) : DelegatedPerf(p) {}

#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "runOnce(" << _base << ")"; }
#endif

};

// Anchored with the same performance all the time.
class AnchorBvrImpl : public BvrImpl {
  public:
    AnchorBvrImpl(Bvr b)
    : _b(b), _typeInfo(b->GetTypeInfo()) {
        Assert(_b);
        _info = _b->GetInfo();
        _endEvent = NULL;
    }

    virtual DWORD GetInfo(bool recalc) { return _info; }

    virtual Perf _Perform(PerfParam& p) {
        Perf anchor;
        
        ViewID id = GetCurrentViewID();

        ViewPerfMap::iterator i = _pmap.find(id);
        
        if (i == _pmap.end()) {
            anchor = NEW AnchorPerfImpl(::Perform(_b, p));

            _pmap[id] = anchor;
        } else {
            anchor = (*i).second;
        }

        // if this is > 1, multiple views sharing some runOnce
        DebugCode(int sz = _pmap.size());

        return anchor;
    }

    virtual Bvr EndEvent(Bvr overrideEvent) {
        Assert(_b);
        
        Bvr ret = _endEvent;
        
        if (overrideEvent || !ret) {
            ret = AnchorBvr(_b->EndEvent(overrideEvent));
            if (!overrideEvent) {
                _endEvent = ret;
            }
        }
        
        return ret;
    }
    
    virtual AxAValue GetConst(ConstParam & cp) {
        return _b->GetConst(cp);
    }
    
    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_b);
        (*proc)(_typeInfo);
        (*proc)(_endEvent);

        for (ViewPerfMap::iterator i = _pmap.begin();
             i != _pmap.end(); i++) {
            (*proc)((*i).second);
        }
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        os << "anchor(";
        
        if (_pmap.size()>0)
            os << _pmap[GetCurrentViewID()];
        else
            os << _b;

        return os << ")";
    }
#endif
    
    virtual DXMTypeInfo GetTypeInfo () { return _typeInfo; }
    
  private:
    typedef MetaSoundDevice *ViewID; // should be the view
    typedef map<ViewID, Perf, less<ViewID> > ViewPerfMap; 
    
    ViewID GetCurrentViewID() { return GetCurrentSoundDevice(); }
    
    Bvr _b, _endEvent;
    DXMTypeInfo _typeInfo;
    DWORD _info;

    ViewPerfMap _pmap;
};

Bvr AnchorBvr(Bvr b)
{ return NEW AnchorBvrImpl(b); }

void
SetImportOnEvent(IImportSite * import,Bvr b)
{
    if (b != NULL) {
        Assert(DYNAMIC_CAST(ImportEventImpl*, b));

        ImportEventImpl *s = SAFE_CAST(ImportEventImpl*,b);

        s->SetImportSite(import);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\jaxaimpl.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Interface with the Java API events.

*******************************************************************************/


#ifndef _JAXAIMPL_H
#define _JAXAIMPL_H

#include "gc.h"
#include "perf.h"
#include "privinc/server.h"

class ATL_NO_VTABLE UntilNotifierImpl : public GCObj {
  public:
    virtual Bvr Notify(Bvr eventData, Bvr curRunningBvr) = 0;
};

typedef UntilNotifierImpl* UntilNotifier;

class ATL_NO_VTABLE BvrHookImpl : public GCObj {
  public:
    virtual Bvr Notify(int id,
                       bool start,
                       double startTime,
                       double globalTime,
                       double localTime,
                       Bvr sampleValue,
                       Bvr curRunningBvr) = 0;
};

typedef BvrHookImpl* BvrHook;

// This is to create a unique typeid for UserDataBvr's
// Otherwise it could just as well have been a typedef
class UserDataImpl : public GCObj
{
} ;

typedef UserDataImpl * UserData;

Bvr UserDataBvr(UserData data);
UserData GetUserDataBvr(Bvr ud);

Bvr BvrCallback(Bvr b, BvrHook notifier);

Bvr JaxaUntil(Bvr b0, Bvr event, UntilNotifier notifier);

Bvr Until3(Bvr b0, Bvr event, Bvr b1);

Bvr Until(Bvr b0, Bvr event);

Bvr NotifyEvent(Bvr event, UntilNotifier notifier);

Bvr StartedBvr(Perf b, DXMTypeInfo type);
    
Bvr InitBvr(DXMTypeInfo);

void SetInitBvr(Bvr bvr, Bvr ibvr);

Bvr AppTriggeredEvent();
void TriggerEvent(Bvr e, Bvr data, bool bAllViews = true);

Bvr ImportEvent();
void SetImportEvent(Bvr b, int errorCode);

Bvr AnchorBvr(Bvr b);

Bvr IndexBvr(int i);

#endif /* _JAXAIMPL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\listpair.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Taken care list and pair behaviors

*******************************************************************************/

#include <headers.h>
#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "events.h"
#include "privinc/opt.h"


extern const char PAIR[] = "";
extern const char FIRST[] = "first";
extern const char SECOND[] = "second";

////////////////////////// Pair ////////////////////////////////

class PairPerfImpl : public GCBase2<Perf, PerfImpl, PAIR> {
  public:
    PairPerfImpl(Perf a, Perf b) : GCBase2<Perf, PerfImpl, PAIR>(a, b) {}
    
    virtual AxAValue _Sample(Param& p) {
        return NEW AxAPair(_b1->Sample(p), _b2->Sample(p));
    }

    virtual AxAValue _GetRBConst(RBConstParam& id) {
        AxAValue v1 = _b1->GetRBConst(id);
        AxAValue v2 = _b2->GetRBConst(id);

        return (v1 && v2) ? NEW AxAPair(v1, v2) : NULL;
    }

    virtual BVRTYPEID GetBvrTypeId() { return PAIR_BTYPEID; }

    Perf GetLeft() { return _b1; }
    Perf GetRight() { return _b2; }
    void SetLeft(Perf v) { _b1 = v; }
    void SetRight(Perf v) { _b2 = v; }
#ifdef TESTOPT
    virtual void IncUses()
    { _b1->IncUses();
      _b2->IncUses();
    }
    virtual void DecUses()
    { _b1->DecUses();
      _b2->DecUses();
    }

    virtual void SetUses(int x)
    { _b1->SetUses(x);
      _b2->SetUses(x);
    }

#endif
};

BOOL IsPair(Perf p)
{ return (p->GetBvrTypeId() == PAIR_BTYPEID); }

Perf GetPairLeft (Perf v)
{
    Assert (DYNAMIC_CAST(PairPerfImpl *, v)) ;
    return ((PairPerfImpl *) v) -> GetLeft();
}

Perf GetPairRight (Perf v)
{
    Assert (DYNAMIC_CAST(PairPerfImpl *, v)) ;
    return ((PairPerfImpl *) v)-> GetRight() ;
}

void SetPairLeft (Perf v,Perf left)
{
    Assert (DYNAMIC_CAST(PairPerfImpl *, v)) ;
    ((PairPerfImpl *) v)-> SetLeft(left);
}

void SetPairRight (Perf v,Perf right)
{
    Assert (DYNAMIC_CAST(PairPerfImpl *, v)) ;
    ((PairPerfImpl *) v)-> SetRight(right);
}


class PairBvrImpl : public GCBase2<Bvr, BvrImpl, PAIR> {
  public:
    PairBvrImpl(Bvr a, Bvr b) : GCBase2<Bvr, BvrImpl, PAIR>(a, b), _end(NULL) {}

    virtual Bvr EndEvent(Bvr overrideEvent) {
        Bvr ret = _end;
        
        if (overrideEvent || ret==NULL) {
            ret = PairBvr(_b1->EndEvent(overrideEvent), _b2->EndEvent(overrideEvent));
            if (!overrideEvent)
                _end = ret;
        }

        return ret;
    }
    
    virtual void _DoKids(GCFuncObj proc) {
        GCBase2<Bvr, BvrImpl, PAIR>::_DoKids(proc);
        (*proc)(_end);
    }
    
    virtual AxAValue GetConst(ConstParam & cp) {
        AxAValue v1 = _b1->GetConst(cp);
        AxAValue v2 = _b2->GetConst(cp);

        return (v1 && v2) ? NEW AxAPair(v1, v2) : NULL;
    }

    virtual Perf _Perform(PerfParam& p) {
        return NEW PairPerfImpl(::Perform(_b1, p),
                                ::Perform(_b2, p));
    }

    virtual Bvr Left() { return _b1; }
  
    virtual Bvr Right() { return _b2; }

    virtual DXMTypeInfo GetTypeInfo () { return AxAPairType; }

    virtual BVRTYPEID GetBvrTypeId() { return PAIR_BTYPEID; }

  private:
    Bvr _end;
};

Bvr PairBvr(Bvr a, Bvr b)
{ return NEW PairBvrImpl(a, b); }

////////////////////////// First ////////////////////////////////

// Not quite sure if we need first and second...  RY
// TODO: Factor these two...

class FirstPerfImpl : public GCBase1<Perf, PerfImpl, FIRST> {
  public:
    FirstPerfImpl(Perf p) : GCBase1<Perf, PerfImpl, FIRST>(p) {}
    
    virtual AxAValue _GetRBConst(RBConstParam& id) {
        AxAValue v = _base->GetRBConst(id);

        return v ? ValPair(v)->Left() : NULL;
    }
        
    virtual AxAValue _Sample(Param& p) {
        return ValPair(_base->Sample(p))->Left();
    }
#ifdef TESTOPT
   virtual void IncUses() { _base->IncUses(); }
   virtual void DecUses() { _base->DecUses(); }
   virtual void SetUses(int x) { _base->SetUses(x); }
#endif
};

class FirstBvrImpl : public GCBase1<Bvr, BvrImpl, FIRST> {
  public:
    FirstBvrImpl(Bvr p) : GCBase1<Bvr, BvrImpl, FIRST>(p) {}

    virtual Perf _Perform(PerfParam& p)
    { return NEW FirstPerfImpl(::Perform(_base, p)); }

    virtual Bvr EndEvent(Bvr overrideEvent) { return FirstBvr(_base->EndEvent(overrideEvent)); } 

    virtual DXMTypeInfo GetTypeInfo () { return _base->GetTypeInfo(); }
};

Bvr FirstBvr(Bvr p)
{
    if (p->GetBvrTypeId() == PAIR_BTYPEID)
        return SAFE_CAST(PairBvrImpl*,p)->Left();
    else
        return NEW FirstBvrImpl(p);
}

////////////////////////// Second ////////////////////////////////

class SecondPerfImpl : public GCBase1<Perf, PerfImpl, SECOND> {
  public:
    SecondPerfImpl(Perf p) : GCBase1<Perf, PerfImpl, SECOND>(p) {}
    
    virtual AxAValue _GetRBConst(RBConstParam& id) {
        AxAValue v = _base->GetRBConst(id);

        return v ? ValPair(v)->Right() : NULL;
    }
        
    virtual AxAValue _Sample(Param& p) {
        return ValPair(_base->Sample(p))->Right();
    }
#ifdef TESTOPT
   virtual void IncUses() { _base->IncUses(); }
   virtual void DecUses() { _base->DecUses(); }
   virtual void SetUses(int x) { _base->SetUses(x); }
#endif
};

class SecondBvrImpl : public GCBase1<Bvr, BvrImpl, SECOND> {
  public:
    SecondBvrImpl(Bvr p) : GCBase1<Bvr, BvrImpl, SECOND>(p) {}

    virtual Perf _Perform(PerfParam& p)
    { return NEW SecondPerfImpl(::Perform(_base, p)); }

    virtual Bvr EndEvent(Bvr overrideEvent) { return SecondBvr(_base->EndEvent(overrideEvent)); } 

    virtual DXMTypeInfo GetTypeInfo () { return _base->GetTypeInfo(); }
};

Bvr SecondBvr(Bvr p)
{
    if (p->GetBvrTypeId() == PAIR_BTYPEID)
        return SAFE_CAST(PairBvrImpl*,p)->Right();
    else
        return NEW SecondBvrImpl(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\movie.h ===
/*******************************************************************************

Copyright (c) 1995_98 Microsoft Corporation

Abstract:

     behavior for movie

*******************************************************************************/


#ifndef _MOVIE_H
#define _MOVIE_H

#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "sndbvr.h"

class MovieEndBvr;
class QuartzAVstream;
class MovieImage;

class MovieMaster : public GCObj {
  public:
    MovieMaster(char *pathname);

    virtual void DoKids(GCFuncObj proc);

    virtual Bvr EndEvent();

    QuartzAVstream *NewQuartzAVStream();

    LeafSound *NewMovieSound();

  private:
    MovieEndBvr *_end;
    QuartzAVstream *_stream;
    char *_path;
};

class MovieEndBvr : public BvrImpl {
  public:
    MovieEndBvr(MovieMaster *m) : _movie(m) {}

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_movie); }

    virtual Perf _Perform(PerfParam& p);

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }

    virtual BOOL InterruptBasedEvent() { return TRUE; }

  private:
    MovieMaster *_movie;
};

typedef enum
{ MV_CREATE, MV_STARTED, MV_STOPVIDEO, MV_STOPAUDIO, MV_STOPAV } MovieStatus;

class MovieInstance : public AxAThrowingAllocatorClass {
  public:
    MovieInstance(MovieMaster *movie, TimeXform tt)
    : _movie(movie), _tt(tt), _status(MV_CREATE),
      _img(NULL), _snd(NULL), _end(NULL), _endBvr(NULL) {}

    ~MovieInstance();

    void CreateStream();

    void SetImgPerf(Perf p) { _img = p; }
    void SetSndPerf(Perf p) { _snd = p; }
    void SetEnd(Bvr b, Perf p);
    void SetStatus(MovieStatus s) { _status = s; }

    Bvr _endBvr;
    Perf _end;                  
    Perf _img;
    Perf _snd;
    TimeXform _tt;
    MovieMaster *_movie;
    QuartzAVstream *_stream;
    MovieStatus _status;
};

class MovieList : public AxAThrowingAllocatorClass {
  public:
    ~MovieList();

    void Update();
    
    void InitiateVideo(MovieMaster *movie, PerfParam& p, Perf img)
    { Initiate(_mlist.begin(), movie, p, img, true); }
    
    MovieInstance *InitiateAudio(MovieMaster *movie, PerfParam& p, Perf snd)
    { return Initiate(_mlist.begin(), movie, p, snd, false); }

    void StopVideo(MovieMaster *movie, TimeXform tt, Perf img)
    { StopAV(movie, tt, img, true); }
    
    void StopAudio(MovieMaster *movie, TimeXform tt, Perf snd)
    { StopAV(movie, tt, snd, false); }

    Perf GetEndPerf(MovieMaster *movie, PerfParam& p);

    QuartzAVstream *GetQuartzAVstream(MovieMaster *movie,
                                      TimeXform tt,
                                      Perf img,
                                      Perf snd);

  private:
    typedef list<MovieInstance*> MList;
    typedef MList::iterator MIter;
    MList _mlist;

    MIter Search(MIter begin, MovieMaster *movie, TimeXform tt);
    
    MovieInstance *Initiate(MIter begin, MovieMaster *movie, PerfParam& p,
                            Perf perf, bool video);
    
    void StopAV(MovieMaster *movie, TimeXform tt, Perf perf, bool video);
};

MovieList *ViewGetMovieList();

Image *NewMovieImageFrame(MovieMaster *movie, TimeXform tt, Perf perf, Time l);

LeafSound *NewMovieSound(MovieMaster *movie);

SoundInstance* NewMovieSoundInstance(MovieMaster *movie,
                                     TimeXform tt,
                                     Perf perf,
                                     LeafSound *,
                                     Bvr eb,
                                     Perf e);
    
#endif /* _MOVIE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\movie.cpp ===
/*******************************************************************************

Copyright (c) 1995-98 Microsoft Corporation

Abstract:

    behavior for movie

*******************************************************************************/

#include <headers.h>
#include "movie.h"
#include "sndbvr.h"
#include "jaxaimpl.h"
#include "privinc/movieimg.h"
#include "privinc/helpq.h"
#include "privinc/stquartz.h"

Perf MovieEndBvr::_Perform(PerfParam& p)
{
    return ViewGetMovieList()->GetEndPerf(_movie, p);
}

MovieMaster::MovieMaster(char *path)
: _path(path)
{
    _stream = NEW QuartzAVstream(path);
}

void
MovieMaster::DoKids(GCFuncObj proc)
{
    (*proc)(_end);
}

LeafSound *
MovieMaster::NewMovieSound()
{
    return NEW StreamQuartzPCM(_path) ;
}

Bvr
MovieMaster::EndEvent()
{
    if (_end==NULL) 
        _end = NEW MovieEndBvr(this);

    return _end;
}

QuartzAVstream *
MovieMaster::NewQuartzAVStream()
{
    if (_stream) {
        QuartzAVstream *s = _stream;
        _stream = NULL;
        return s;
    }

    return NEW QuartzAVstream(_path);
}

class MovieImagePerf : public PerfImpl {
  public:
    MovieImagePerf(TimeXform tt, MovieMaster *m)
    : _tt(tt), _movie(m) {}

    ~MovieImagePerf() {
        ViewGetMovieList()->StopVideo(_movie, _tt, this);
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_movie);
        (*proc)(_tt);
    }

    virtual AxAValue _Sample(Param& p) {
      return NewMovieImageFrame(_movie, _tt, this, EvalLocalTime(p, _tt));
    }

  private:
    TimeXform _tt;
    MovieMaster *_movie;
};

class MovieImageBvr : public BvrImpl {
  public:
    MovieImageBvr(MovieMaster *m) : _movie(m) {}

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_movie); }

    virtual Perf _Perform(PerfParam& p) {
        Perf perf = NEW MovieImagePerf(p._tt, _movie);
        ViewGetMovieList()->InitiateVideo(_movie, p, perf);
        return perf;
    }

    virtual Bvr EndEvent() { return _movie->EndEvent(); }
    
    //virtual DWORD GetInfo(bool recalc = false) { return BVR_TIMEVARYING_ONLY; }

    virtual DXMTypeInfo GetTypeInfo () { return ImageType ; }

  private:
    MovieMaster *_movie;
};

// TODO: code factoring...
class MovieSoundPerf : public PerfImpl {
  public:
    MovieSoundPerf(TimeXform tt, MovieMaster *m, LeafSound *s)
    : _tt(tt), _movie(m), _snd(s) {}

    ~MovieSoundPerf() {
        ViewGetMovieList()->StopAudio(_movie, _tt, this);
        ViewGetSoundInstanceList()->Stop(_snd, _tt);
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_movie);
        (*proc)(_tt);
        (*proc)(_snd);
    }

    virtual AxAValue _Sample(Param& p) {
        ViewGetSoundInstanceList()->UpdateSlope(_snd, _tt, p);
        return NewTxSound(_snd, _tt);
    }

  private:
    TimeXform _tt;
    MovieMaster *_movie;
    LeafSound *_snd;
};

class MovieSoundBvr : public BvrImpl {
  public:
    MovieSoundBvr(MovieMaster *m) : _movie(m) {}

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_movie); }

    virtual Perf _Perform(PerfParam& p) {
        LeafSound *s = _movie->NewMovieSound();
        Perf perf = NEW MovieSoundPerf(p._tt, _movie, s);
        MovieInstance *m =
            ViewGetMovieList()->InitiateAudio(_movie, p, perf);
        ViewGetSoundInstanceList()->
            Add(NewMovieSoundInstance(_movie, p._tt, perf,
                                      s, m->_endBvr, m->_end));
        return perf;
    }

    virtual Bvr EndEvent() { return _movie->EndEvent(); }
    
    //virtual DWORD GetInfo(bool recalc = false) { return BVR_TIMEVARYING_ONLY; }

    virtual DXMTypeInfo GetTypeInfo () { return SoundType ; }

  private:
    MovieMaster *_movie;
};

MovieInstance::~MovieInstance()
{
    GCRoots globalRoots = GetCurrentGCRoots();

    GCRemoveFromRoots(_endBvr, globalRoots);
    GCRemoveFromRoots(_end, globalRoots);

    // TODO: what about sound buffers?
    delete _stream;
}

void
MovieInstance::CreateStream()
{
    _stream = _movie->NewQuartzAVStream();
    // check for A/V  AV cases
}

void
MovieInstance::SetEnd(Bvr b, Perf p)
{
    Assert(!_end && !_endBvr);
    
    _endBvr = b;
    _end = p;

    GCRoots globalRoots = GetCurrentGCRoots();

    GCAddToRoots(_endBvr, globalRoots);
    GCAddToRoots(_end, globalRoots);
}

MovieList::~MovieList()
{
    for (MIter i = _mlist.begin(); i != _mlist.end(); i++) {
        delete (*i);
    }
}

MovieList::MIter
MovieList::Search(MovieList::MIter begin, MovieMaster *movie, TimeXform tt)
{
    for (MovieList::MIter i = begin; i != _mlist.end(); i++) {
        if (((*i)->_movie == movie) && ((*i)->_tt == tt))
            return i;
    }

    return _mlist.end();
}

MovieInstance *
MovieList::Initiate(MIter begin,
                    MovieMaster *movie,
                    PerfParam& p,
                    Perf perf,
                    bool video)
{
    MIter i = Search(begin, movie, p._tt);

    if (i == _mlist.end()) {
        MovieInstance *m = NEW MovieInstance(movie, p._tt);
        video ? m->SetImgPerf(perf) : m->SetSndPerf(perf);
        Bvr end = AppTriggeredEvent();
        m->SetEnd(end, ::Perform(end, p));
        _mlist.push_back(m);;
        return m;
    } else {
        if ((*i)->_status == MV_CREATE) {
            if (video) {
                Assert((*i)->_img == NULL);
                (*i)->SetImgPerf(perf);
            } else {
                Assert((*i)->_snd == NULL);
                (*i)->SetSndPerf(perf);
            }
            return (*i);
        } else {
            return Initiate(i++, movie, p, perf, video);
        }
    }     
}

void
MovieList::StopAV(MovieMaster *movie,
                  TimeXform tt,
                  Perf perf,
                  bool video)
{
    MIter i = Search(_mlist.begin(), movie, tt);

    while (i != _mlist.end()) {
        if ((video && (*i)->_img == perf) ||
            (!video && (*i)->_snd == perf)) {
            switch ((*i)->_status) {
              case MV_CREATE:
              case MV_STARTED:
                if (video)
                    (*i)->SetStatus(MV_STOPVIDEO);
                else
                    (*i)->SetStatus(MV_STOPAUDIO);
                return;
                break;
              case MV_STOPVIDEO:
                if (!video) {
                    (*i)->SetStatus(MV_STOPAV);
                }
                return;
                break;
              case MV_STOPAUDIO:
                if (video) {
                    (*i)->SetStatus(MV_STOPAV);
                }
                return;
                break;
              case MV_STOPAV:
                break;
            }
        }

        i = Search(i++, movie, tt);
    }

    Assert("internal error StopAV");
}

Perf
MovieList::GetEndPerf(MovieMaster *movie, PerfParam& p)
{
    Perf result = NULL;
    MIter i = _mlist.begin();

    while (result == NULL) {
        i = Search(i, movie, p._tt);

        if (i == _mlist.end()) {
            MovieInstance *m = Initiate(i, movie, p, NULL, true);
            Bvr end = AppTriggeredEvent();
            m->SetEnd(end, ::Perform(end, p));
            result = m->_end;
        } else {
            // TODO:
            result = (*i)->_end;
        }
    }

    return result;
}

QuartzAVstream *
MovieList::GetQuartzAVstream(MovieMaster *movie,
                             TimeXform tt,
                             Perf img,
                             Perf snd)
{
    QuartzAVstream *result = NULL;
    MIter i = _mlist.begin();

    while (result == NULL) {
        i = Search(i, movie, tt);

        Assert(i != _mlist.end());

        if (((*i)->_img == img) && ((*i)->_snd == snd)) {
            result = (*i)->_stream;
        }

        i++;
    }

    return result;
}

void
MovieList::Update()
{
    for (MIter i = _mlist.begin(); i != _mlist.end(); i++) {
        MovieInstance *m = (*i);

        switch (m->_status) {
          case MV_CREATE:
            // Check AV & create stream;
            m->CreateStream();
            // TODO: Create SoundInstance
            m->SetStatus(MV_STARTED);
          case MV_STARTED:
            break;
          case MV_STOPVIDEO:
            break;
          case MV_STOPAUDIO:
            break;
          case MV_STOPAV:
            // Remove instance
            break;          
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\moviebvr.cpp ===
/*******************************************************************************

Copyright (c) 1995-98 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#include <headers.h>

#include "moviebvr.h"
#include "jaxaimpl.h"
#include "privinc/movieimg.h"
#include "privinc/bufferl.h"

class MovieEndBvr : public BvrImpl {
  public:
    MovieEndBvr() {}

    virtual Perf _Perform(PerfParam& p) {
        return ::Perform(AppTriggeredEvent(), p);
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }

    virtual BOOL InterruptBasedEvent() { return TRUE; }

    virtual void _DoKids(GCFuncObj proc) {}
};


class MovieImageBvrImpl : public BvrImpl {
  public:
    MovieImageBvrImpl(MovieImage *i, QuartzVideoBufferElement *cache)
    : _movie(i), _cache(cache), _end(NULL) {}

    ~MovieImageBvrImpl() {
        if (_cache)
            delete _cache;
    }

    virtual DXMTypeInfo GetTypeInfo () { return ImageType ; }

    virtual Bvr EndEvent(Bvr) {
        if (_end==NULL) {
            _end = NEW MovieEndBvr();
        }

        return _end;
    }

    QuartzVideoBufferElement *GrabCache() {
        QuartzVideoBufferElement *c = _cache;
        _cache = NULL;
        return c;
    }

    //virtual DWORD GetInfo(bool recalc = false)
    //{ return BVR_TIMEVARYING_ONLY; } 
    
    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_movie);
        (*proc)(_end);
    }

    virtual Perf _Perform(PerfParam& p) {
        Perf end = ::Perform(EndEvent(NULL), p); 
        return NEW MovieImagePerf(_movie, p._tt, this, end);
    }

  private:
    MovieImage *_movie;
    QuartzVideoBufferElement *_cache;
    Bvr _end;
};


MovieImagePerf::MovieImagePerf(MovieImage *m,
                               TimeXform tt,
                               MovieImageBvrImpl *b,
                               Perf end)
: _movieImage(m), _tt(tt), _bufferElement(NULL), _end(end), _base(b), 
_surface(NULL) // self initializing, actually
{}


MovieImagePerf::~MovieImagePerf()
{
    if(_bufferElement)
        delete _bufferElement;
    // don't need to explicitly delete _surface will be automagicaly released
}


QuartzVideoBufferElement *
MovieImagePerf::GrabMovieCache()
{
    return _base->GrabCache();
}


void
MovieImagePerf::TriggerEndEvent()
{
    _end->Trigger(TrivialBvr(), false);
}


void
MovieImagePerf::_DoKids(GCFuncObj proc)
{
    (*proc)(_movieImage);
    (*proc)(_end);
    (*proc)(_tt);
    (*proc)(_base);
}


AxAValue
MovieImagePerf::_Sample(Param& p)
{
    Time time = EvalLocalTime(p, _tt);

    if(_bufferElement) {
        QuartzVideoReader *videoReader = _bufferElement->GetQuartzVideoReader();
        Assert(videoReader);
        videoReader->SetTickID(ViewGetSampleID());
    }

    return NEW MovieImageFrame(time, this);
}


void
MovieImagePerf::SetSurface(DDSurface *surface)
{
    Assert(!_surface);  // this should only be set once per performance!
    _surface = surface; // automagicaly works
}


Bvr MovieImageBvr(MovieImage *i, QuartzVideoBufferElement *cache)
{ return NEW MovieImageBvrImpl(i, cache); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\moviebvr.h ===
/*******************************************************************************

Copyright (c) 1995-98 Microsoft Corporation

*******************************************************************************/

#ifndef _MOVIEBVR_H
#define _MOVIEBVR_H

#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "privinc/ddsurf.h"

class  MovieImage;
class  QuartzVideoBufferElement;
class  MovieImageBvrImpl;

Bvr MovieImageBvr(MovieImage *i, QuartzVideoBufferElement *cache);

class MovieImagePerf : public PerfImpl {
  public:
    MovieImagePerf(MovieImage *m,
                   TimeXform tt,
                   MovieImageBvrImpl *movieBvr,
                   Perf end);
    ~MovieImagePerf();
    void TriggerEndEvent();
    QuartzVideoBufferElement *GetBufferElement() { return _bufferElement; }
    void SetBufferElement(QuartzVideoBufferElement *be) { _bufferElement = be; }
    QuartzVideoBufferElement *GrabMovieCache();
    MovieImage *GetMovieImage() { return _movieImage; }
    TimeXform GetTimeXform() { return _tt; }
    virtual AxAValue _Sample(Param&);
    virtual void _DoKids(GCFuncObj proc);
    DDSurface *GetSurface() { return(_surface); } // automaticaly converts
    void SetSurface(DDSurface *surface);

  private:
    QuartzVideoBufferElement *_bufferElement;
    MovieImage               *_movieImage;
    Perf                      _end;
    TimeXform                 _tt;
    MovieImageBvrImpl        *_base;
    DDSurfPtr<DDSurface>      _surface;
};

#endif /* _MOVIEBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\ode.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    ODE code

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "appelles/axaprims.h"
#include "privinc/server.h"

////////////////////////// Integral ////////////////////////////////

extern const char INTEGRAL[] = "integral";
extern const char DERIV[] = "deriv";

///////// IntegralPerf /////////////////////

//   The integration algorithm: Given b = integral(b'), to sample b at t, we (a)
//   fetch the stored previous value of b' (cached as lastsample in the
//   integral context), (b) use this previous value as the value of b' over the
//   interval, i.e., multiply lastsample by the interval width
//   (time-!lasttime) and add to the cached value of b (lasttot), and (c) update
//   the integrand cache, by evaluating at the current time (f time).  The
//   simply and mutually recursive cases are handled because this final step
//   will cause integral cache hits.

static const double EPSILON = 1e-100;

class IntegralPerfImpl : public GCBase1<Perf, PerfImpl, INTEGRAL> {
  public:
    IntegralPerfImpl(Time t0, Perf b, TimeXform tt) : 
        GCBase1<Perf, PerfImpl, INTEGRAL>(b), _tt(tt),
        _lastTime(0.0), _lastSample(0.0), _lastIntegral(0.0) {}

    virtual AxAValue _GetRBConst(RBConstParam& p) {
        _cache = NULL;          // Prevent recursion...
        _id = p.GetId();
        AxAValue v = _base->GetRBConst(p);

        if (v) {
            if (fabs(ValNumber(v)) < EPSILON) {
                // integral needs to be called even if it's equal to
                // 0. So invalidate cache.
                _cid = 0;
                p.AddEvent(this);
                return NEW AxANumber(_lastIntegral);
            }
        }

        return NULL;
    }

    // This algorithm takes f(x) * width, which seems more stable in
    // cases like gravity2.avr.  This method, however, makes it hard to 
    // subdivide the integral space and take multiple samples.
    
    virtual AxAValue _Sample(Param& p) {
        double localTime = EvalLocalTime(p, _tt);

        if (localTime != _lastTime) {
            double width = localTime - _lastTime;

            _lastTime = localTime;

            double integrand = ValNumber(_base->Sample(p));

            //_lastIntegral += width * _lastSample;
            _lastIntegral += width * integrand;

            _lastSample = integrand;
        }

        return NEW AxANumber(_lastIntegral);
    }

    void _DoKids(GCFuncObj proc) {
        GCBase1<Perf, PerfImpl, INTEGRAL>::_DoKids(proc);
        (*proc)(_tt);
    }

  private:
    Time      _lastTime;
    double    _lastSample;
    double    _lastIntegral;
    TimeXform _tt;
};

////////// IntegralBvr /////////////////////

class IntegralBvrImpl : public GCBase1<Bvr, BvrImpl, INTEGRAL> {
  public:
    IntegralBvrImpl(Bvr b) : GCBase1<Bvr, BvrImpl, INTEGRAL>(b) {}

    virtual DWORD GetInfo(bool recalc)
    { return ~BVR_HAS_NO_ODE & _base->GetInfo(recalc); }

    virtual Perf _Perform(PerfParam& p) {
        Perf perf =
            NEW IntegralPerfImpl(p._t0, ::Perform(_base, p), p._tt);

        return perf;
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxANumberType; }
};

Bvr IntegralBvr(Bvr b)
{ return NEW IntegralBvrImpl(b); }

////////////////////////// Derivative ////////////////////////////////

////////// DerivPerf /////////////////////

static const double DELTA = 0.0000001;

class DerivPerfImpl : public GCBase1<Perf, PerfImpl, DERIV> {
  public:
    DerivPerfImpl(Time t0, Perf b) : GCBase1<Perf, PerfImpl, DERIV>(b),
        _lastTime(t0), _lastSample(0.0), _lastDeriv(0.0), _init(TRUE) {}
    
    virtual AxAValue _GetRBConst(RBConstParam& id) {
        _cache = NULL;          // Prevent recursion...
        _id = id.GetId();

        return _base->GetRBConst(id) ? NEW AxANumber(0.0) : NULL;
    }
    
    virtual AxAValue _Sample(Param& p) {
        if ((p._time != _lastTime) || _init) {
            
            // TODO: Need to factor out the code eventually.
        
            // Handle specially for initial derivative.
            // Sample a little bit ahead.  TODO: This could be problematic
            // for reactive behavior since event could happen and the
            // behavior could end at t + delta.

            if (_init) {
                _init = FALSE;

                _lastTime = p._time;
                double fx = ValNumber(_base->Sample(p));
                Time t = p._time;
            
                _lastTime = p._time = t + DELTA;
                double fxp = ValNumber(_base->Sample(p));
                p._time = t;

                _lastDeriv = (fxp - fx) / DELTA;
                _lastSample = fx;
            }

            else if (p._time > _lastTime) {
                Time lastTime = _lastTime;

                _lastTime = p._time; // for recursion
                double fx = ValNumber(_base->Sample(p));

                _lastDeriv = (fx - _lastSample) / (p._time - lastTime);

                _lastSample = fx;
            }
        }

        // TODO: May not be desirable for time <= lastTime.
        // Sampled at the same time again, or sampled
        // some time earlier, give back the last deriv. 
            
        return NEW AxANumber(_lastDeriv);
    }

  private:
    Time _lastTime;
    double _lastSample;
    double _lastDeriv;
    BOOL _init;
};

////////// DerivBvr /////////////////////

class DerivBvrImpl : public GCBase1<Bvr, BvrImpl, DERIV> {
  public:
    DerivBvrImpl(Bvr b) : GCBase1<Bvr, BvrImpl, DERIV>(b) {}
    
    virtual DWORD GetInfo(bool recalc) 
    { return ~BVR_HAS_NO_ODE & _base->GetInfo(recalc); }

    virtual Perf _Perform(PerfParam& p) {
        Perf perf =
            NEW DerivPerfImpl(p._t0, ::Perform(_base, p));

        return perf;
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxANumberType; }
};

Bvr DerivBvr(Bvr b)
{ return NEW DerivBvrImpl(b); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\perf.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Performance Data Structures

*******************************************************************************/


#ifndef _PERF_H
#define _PERF_H

#include "gc.h"
#include "privinc/storeobj.h"
#include "preference.h"

enum EventSampleType {
    EventSampleNormal,
    EventSampleAfter,
    EventSampleExact
};

struct ConstParam;

class TimeSubstitutionImpl : public StoreObj {
  public:
    TimeSubstitutionImpl(Perf p) : _perf(p), _next(NULL) {}

    void SetNext(TimeSubstitutionImpl *t) { _next = t; }
    TimeSubstitutionImpl *GetNext() { return _next; }

    Perf GetPerf() { return _perf; }

    virtual void DoKids(GCFuncObj proc);

  protected:
    Perf _perf;
    TimeSubstitutionImpl *_next;
};

class Param {
  public:
    Param(Time t, TimeSubstitution ts = NULL);

    void PushTimeSubstitution(Perf);
    void PushTimeSubstitution(TimeSubstitutionImpl *);
    TimeSubstitution PopTimeSubstitution();
    TimeSubstitution GetTimeSubstitution()
    { return _timeSubstitution; }

    Time _time;                 // sample time
    Time _sampleTime;           // sample time (not affected by event stamping)
    Time _cutoff;               // cut off time for "until" optimization 
    unsigned int _id;           // sample id
    BOOL _checkEvent;           // check for event or not during sampling
    BOOL _done;                 // for done event check
    bool _noHook;               // don't call bvr hook if true
    Real _importance;           // initially 1.0.
    
    // These are for the "and" event so that we don't break the cache
    // by changing _time...
    EventSampleType _sampleType;
    Time _eTime;

    // current performance to be passed into the notifier
    // until sets it
    Bvr _currPerf;

    unsigned int _cid;          // constant cache id

  private:
    TimeSubstitution _timeSubstitution;
};

class CheckChangeablesParam {
  public:
    CheckChangeablesParam(Param &sp) : _sampleParam(sp) {}
    
    Param &_sampleParam;
};

class RBConstParam {
  public:
    RBConstParam(unsigned int id,
                 Param& p,
                 list<Perf>& events,
                 list<Perf>& changeables,
                 list<Perf>& conditionals)
    : _id(id),
      _events(events),
      _changeables(changeables),
      _conditionals(conditionals),
      _param(p)
    {
    }

    unsigned int GetId() { return _id; }
    Param& GetParam() { return _param; }

    void AddEvent(Perf e) {
        _events.push_front(e);
    }

    void AddChangeable(Perf s) {
        _changeables.push_front(s);
    }
    
    void AddConditional(Perf c) {
        _conditionals.push_front(c);
    }

  private:
    unsigned int _id;
    list<Perf>& _events;
    list<Perf>& _changeables;
    list<Perf>& _conditionals;
    Param& _param;
};

class ATL_NO_VTABLE PerfBase : public GCObj {
  public:
    PerfBase() {}

    virtual DWORD GetInfo(bool) { return 0; }
    
    virtual AxAValue GetRBConst(RBConstParam&) = 0;

    // Until would override this and return the switched perf if event
    // time < cutOffTime
    virtual Perf SwitchTo(Param&) { return this; }

    virtual bool CheckChangeables(CheckChangeablesParam& ccp) {
        // If we get here, the class we're called on should have
        // overridden this.
        Assert(!"Shouldn't be here");
        return false;
    }

    virtual AxAValue Sample(Param&) = 0;

    virtual void DoKids(GCFuncObj proc) = 0;
        
    virtual BVRTYPEID GetBvrTypeId() { return UNKNOWN_BTYPEID; }

    // internal use, no need to throw
    virtual void Trigger(Bvr data, bool bAllViews) {}

    virtual AxAValue GetConstPerfConst() { return NULL; }
};

class ATL_NO_VTABLE PerfImpl : public PerfBase {
  public:
    PerfImpl() : _time(0.0), _cache(NULL),
        _id(0), _cid(0), //_ts(NULL),
        _optimizedCache(false) {}
    
    // Should NEVER be called inside Sample of subclass
    virtual AxAValue _Sample(Param&) = 0;

    // Returns non-NULL if it's a constant or the left portion of an
    // until bvr is constant.  DO NOT override this function, but
    // define _GetRBConst in the subclass instead.
    virtual AxAValue GetRBConst(RBConstParam&);

    virtual AxAValue _GetRBConst(RBConstParam& id) { return NULL; }

    // This is the main entry point that checks the cache first before
    // actually calling the Sample function.  
    AxAValue Sample(Param&);

    virtual void DoKids(GCFuncObj proc);
        
    // Don't need to traverse the cache since it only lives for one
    // sampling.  NOT true any more for dynamic constant cache

    virtual void _DoKids(GCFuncObj proc) = 0;

    void SetCache(AxAValue v, Param& p);

  protected:
    bool DoCaching(Param&);

    Time _time;
    AxAValue _cache;
    unsigned int _id;
    unsigned int _cid;
    //TimeSubstitution _ts;
    bool         _optimizedCache;
};

class ATL_NO_VTABLE DelegatedPerf : public PerfImpl {
  public:
    DelegatedPerf(Perf base) : _base(base) {}

    virtual AxAValue _Sample(Param& p) { return _base->Sample(p); }

    virtual AxAValue _GetRBConst(RBConstParam& p) { return _base->GetRBConst(p); }

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_base); }
        
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _base; }
#endif

    virtual BVRTYPEID GetBvrTypeId() { return _base->GetBvrTypeId(); }

  protected:
    Perf _base;
};

// Some template macros for behavior.

template<class T, class Impl, const char* Name>
class ATL_NO_VTABLE GCBase1 : public Impl {
  public:
    GCBase1(T b) : _base(b) {}

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_base); }

    virtual DWORD GetInfo(bool recalc) { return _base->GetInfo(recalc); }

#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << Name << "(" << _base << ")"; }
#endif

  protected:
    T _base;
};    

template<class T, class Impl, const char* Name>
class ATL_NO_VTABLE GCBase2 : public Impl {
  public:
    GCBase2(T b1, T b2) : _b1(b1), _b2(b2) { GetInfo(true); }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_b1);
        (*proc)(_b2);
    }

    virtual DWORD GetInfo(bool recalc) {
        if (recalc) {
            _info = _b1->GetInfo(recalc) & _b2->GetInfo(recalc);
        }
        return _info;
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << Name << "(" << _b1 << ", " << _b2 << ")"; }
#endif

  protected:
    T _b1;
    T _b2;
    DWORD _info;
};    

Perf ConstPerf(AxAValue c);

Perf TimePerf(TimeXform tt);

Perf SwitchPerf(Perf p);

unsigned int NewSampleId();

#if _USE_PRINT
ostream& operator<<(ostream& os, Perf);
#endif

AxAValue Sample(Perf, Time);

AxAValue SampleAt(Perf perf, Param& p, Time t);

AxAValue EventAt(Perf perf, Param& p, Time t);

AxAValue EventAfter(Perf perf, Param& p, Time t);

class AxAEData : public AxAValueObj {
  public:
    // Don't call these two constructors directly, use CreateEData &
    // noEvent. 
    AxAEData(Time time, Bvr data);

    AxAEData() : _happened(FALSE) {}

    BOOL Happened() { return _happened; }

    Time HappenedTime() { return _time; }

    Bvr EventData() { Assert(_data); return _data; }

    virtual void DoKids(GCFuncObj proc) {
        Assert("EData shouldn't GC'ed");
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        return os << "eventData("
                  << _happened << "," << _time << "," << _data << ")";
    }
#endif

    virtual DXMTypeInfo GetTypeInfo() { return AxAEDataType; }
    
  private:
    BOOL _happened;
    Time _time;
    Bvr _data;
};

inline AxAEData *ValEData(AxAValue v)
{
    Assert(DYNAMIC_CAST(AxAEData *, v) != NULL);
    
    return ((AxAEData*) v);
}

AxAEData *CreateEData(Time time, Bvr data);

extern AxAEData *noEvent;

/* functions for traversing performance trees */

/* Pairs */

BOOL  IsPair(Perf p);
Perf  GetPairLeft(Perf p);
Perf  GetPairRight(Perf p);
void  SetPairLeft(Perf p,Perf left);
void  SetPairRight(Perf p,Perf right);

/* Application performances */

BOOL      IsApp(Perf p);
AxAValue  GetOperator(Perf p);
Perf      GetOperand(Perf p, int index); // 0 based index
void      SetOperand(Perf p, int index, Perf newOperand); // 0 based index
int       GetNumOperands(Perf p);
Perf      PrimApplyPerf(AxAPrimOp * func,int nargs, Perf * args);

/* Constant performances */

BOOL      IsConst(Perf p);
AxAValue  GetPerfConst(Perf p);

/* Start Performances */

BOOL IsStart(Perf p);
Perf GetStartBody(Perf p);

/* Reactive Behavior Performances */

BOOL IsUntil(Perf p);
BOOL IsSwitch(Perf p);
BOOL IsSwitcher(Perf p);
BOOL IsSwitchOnce(Perf p);

#endif /* _PERF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\pick.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _PICK_H
#define _PICK_H

#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "privinc/vec2i.h"
#include "privinc/vec3i.h"
#include "privinc/xformi.h"
#include "privinc/xform2i.h"

Point2Value *GetMousePosition(double time);

Bvr ImagePickData(Point2Value *pt, Transform2 *xf);

Bvr GeomPickData(Point2Value *imgPoint, Vector3Value *offset3i, Vector3Value *offset3j);

#endif /* _PICK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\preference.h ===
#ifndef _PREFERENCE_H
#define _PREFERENCE_H

Bvr PreferenceBvr(Bvr b, BSTR pref, VARIANT val);

typedef enum {
    NoPreference,
    PreferenceOn,
    PreferenceOff
} BoolPref;



class PreferenceClosure {
  public:
    virtual void Execute() = 0;
};

class PreferenceSetter {
  public:
    PreferenceSetter(PreferenceClosure &cl,
                     BoolPref bitmapCaching,
                     BoolPref geoBitmapCaching);
    void DoIt();
    
  protected:
    PreferenceClosure &_closure;
    
    BoolPref _bitmapCaching;
    BoolPref _geoBitmapCaching;
};

#endif /* _PREFERENCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\pickevnt.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of pick event

*******************************************************************************/

#include <headers.h>
#include "appelles/image.h"
#include "appelles/gattr.h"
#include "appelles/axaprims.h"
#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "privinc/server.h"
#include "privinc/debug.h"
#include "privinc/vec2i.h"
#include "privinc/vec3i.h"
#include "privinc/xformi.h"
#include "privinc/xform2i.h"
#include "server/view.h"

extern Geometry *PRIVPickableGeometry(Geometry *geo,
                                      AxANumber *id,
                                      AxABoolean *ignoresOcclusion);
extern Image *PRIVPickableImage(Image *image,
                                AxANumber *id,
                                AxABoolean *ignoresOcclusion);

extern AxAValue PRIVPickableGeomWithData(AxAValue geo,
                                         int id,
                                         GCIUnknown *data,
                                         bool);
extern AxAValue PRIVPickableImageWithData(AxAValue geo,
                                          int id,
                                          GCIUnknown *data,
                                          bool);

extern AxAPrimOp * MinusPoint2Point2Op;
extern AxAPrimOp * TransformPoint2Op;
extern AxAPrimOp * Scale3UniformNumberOp;
extern AxAPrimOp * XCoordVector2Op;
extern AxAPrimOp * YCoordVector2Op;
extern AxAPrimOp * TransformVec3Op;
extern AxAPrimOp * PlusVector3Vector3Op;
static AxAPrimOp * PRIVPickableGeometryOp;
static AxAPrimOp * PRIVPickableImageOp;

const char *PICK = "pick";
const char *PICKEXIT = "pickexit";

inline AxAValue Number(double d)
{ return NEW AxANumber(d); }

class PickPerfImpl : public PerfImpl {
  public:
    PickPerfImpl(int id) : _id(id), _view(ViewAddPickEvent()) {}
    virtual ~PickPerfImpl() { CleanUp(); }
    virtual void CleanUp() { ViewDecPickEvent(_view); }

    virtual void _DoKids(GCFuncObj proc) { }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "pick(" << _id << ")"; }
#endif

    AxAValue _Sample(Param& p);

  private:
    int _id;
    CRView* _view;
};

AxAValue PickPerfImpl::_Sample(Param& p)
{
    Time t = p._time;

    if (p._sampleType != EventSampleNormal)
        t = p._eTime;
    
    PickQData data;
    Bvr edata = NULL;
    BOOL hit = CheckForPickEvent(_id, t, data);

    if (hit) {
        if (data._type == HitImageData::Image) {

            Point2Value  *pt;
            Transform2 *xf;

            {
                DynamicHeapPusher pusher(GetGCHeap());

                pt = XyPoint2RR(data._xCoord,
                                data._yCoord);

                // Copy onto the non-transient heap... 
                
                xf = data._wcToLc2->Copy();
            }

            Bvr intPt = ConstBvr(pt);

            Bvr lcMousePos = PrimApplyBvr(TransformPoint2Op,
                                          2,
                                          ConstBvr(xf),
                                          mousePosition);
            
            edata = PairBvr(intPt,
                            PrimApplyBvr(MinusPoint2Point2Op,
                                         2,lcMousePos, intPt));
        } else {

            Point2Value *imgPoint;
            Point3Value *lcPoint;
            Vector3Value *offset3i, *offset3j;

            {
                DynamicHeapPusher pusher(GetGCHeap());

                TraceTag ((tagPick3Offset, "raw Offset I: %f %f %f",
                           data._offset3i.x, data._offset3i.y, data._offset3i.z));

                TraceTag ((tagPick3Offset, "raw Offset J: %f %f %f",
                           data._offset3j.x, data._offset3j.y, data._offset3j.z));

                imgPoint  = XyPoint2RR (
                    data._wcImagePt.x,
                    data._wcImagePt.y);

                lcPoint   = XyzPoint3RRR (
                    data._xCoord,
                    data._yCoord,
                    data._zCoord);

                offset3i = XyzVector3RRR (
                    data._offset3i.x,
                    data._offset3i.y,
                    data._offset3i.z);

                offset3j = XyzVector3RRR (
                    data._offset3j.x,
                    data._offset3j.y,
                    data._offset3j.z);
            }

            Bvr lcPointBvr = ConstBvr(lcPoint);
            Bvr offset3iBvr = ConstBvr(offset3i);
            Bvr offset3jBvr = ConstBvr(offset3j);

            Bvr delta = PrimApplyBvr(MinusPoint2Point2Op,
                                     2,mousePosition, lcPointBvr);

            Bvr scaledx =
                PrimApplyBvr(TransformVec3Op,
                             2,
                             PrimApplyBvr(Scale3UniformNumberOp,
                                          1,
                                          PrimApplyBvr(XCoordVector2Op,
                                                       1,
                                                       delta)),
                             offset3iBvr);

            Bvr scaledy =
                PrimApplyBvr(TransformVec3Op,
                             2,
                             PrimApplyBvr(Scale3UniformNumberOp,
                                          1,
                                          PrimApplyBvr(YCoordVector2Op,
                                                       1,
                                                       delta)),
                             offset3jBvr);
                                     
            Bvr lcOffsetVec =
                PrimApplyBvr(PlusVector3Vector3Op, 2,scaledx, scaledy);
            
            edata = PairBvr(ConstBvr(lcPoint), lcOffsetVec);
        }

        return CreateEData(data._eventTime, edata);
    }

    return noEvent;
}

class PickBvrImpl : public BvrImpl {
  public:
    PickBvrImpl(int id) : _id(id) {}

    virtual Perf _Perform(PerfParam&)
    { return NEW PickPerfImpl(_id); }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }

    virtual void _DoKids(GCFuncObj proc) { }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "pick(" << _id << ")"; }
#endif

  private:
    int _id;
};

void PickableImage(Bvr image, bool ignoresOcclusion,
                   Bvr& pImage, Bvr& pEvent)
{
    int id = NewSampleId();
    pImage = PrimApplyBvr(PRIVPickableImageOp,
                          3,
                          image,
                          NumToBvr(id),
                          ignoresOcclusion ? trueBvr : falseBvr);
    pEvent = NEW PickBvrImpl(id);
}

void PickableGeometry(Bvr geometry, bool ignoresOcclusion,
                      Bvr& pGeom, Bvr& pEvent)
{
    int id = NewSampleId();
    pGeom = PrimApplyBvr(PRIVPickableGeometryOp,
                         3,
                         geometry,
                         NumToBvr(id),
                         ignoresOcclusion ? trueBvr : falseBvr);
    pEvent = NEW PickBvrImpl(id);
}

typedef AxAValue (*PickableFunc)(AxAValue, int, GCIUnknown *, bool);

class PickableDataBvr : public DelegatedBvr {
  public:
    PickableDataBvr(Bvr geo, int id, GCIUnknown *data,
                    PickableFunc fp, bool oflag) 
    : DelegatedBvr(geo), _eventId(id), _data(data), _fp(fp), _oflag(oflag) { }

    AxAValue DoConst(AxAValue v)
    { return v ? (*_fp)(v, _eventId, _data, _oflag) : NULL; }
    
    virtual AxAValue GetConst(ConstParam & cp) { return DoConst(_base->GetConst(cp)); }

    virtual Perf _Perform(PerfParam& p);

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_base);
        (*proc)(_data);
    }

  private:
    int _eventId;
    GCIUnknown *_data;
    PickableFunc _fp;
    bool _oflag;
};

class PickableDataPerf : public DelegatedPerf {
  public:
    PickableDataPerf(Perf geo, PickableDataBvr *bvr)
    : DelegatedPerf(geo), _bvr(bvr) {}

    virtual AxAValue _GetRBConst(RBConstParam& p)
    { return _bvr->DoConst(_base->GetRBConst(p)); }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_base);
        (*proc)(_bvr);
    }

    virtual AxAValue Sample(Param& p)
    { return _bvr->DoConst(_base->Sample(p)); }
    
  private:
    PickableDataBvr *_bvr;
};

Perf PickableDataBvr::_Perform(PerfParam& p)
{
    return NEW PickableDataPerf(::Perform(_base, p), this);
}

Bvr GeometryAddId(Bvr geo, IUnknown *u, bool ignoresOcclusion)
{
    return NEW PickableDataBvr(geo,
                               NewSampleId(),
                               NEW GCIUnknown(u),
                               PRIVPickableGeomWithData,
                               ignoresOcclusion);
}

Bvr ImageAddId(Bvr img, IUnknown *u, bool ignoresOcclusion)
{
    return NEW PickableDataBvr(img,
                               NewSampleId(),
                               NEW GCIUnknown(u),
                               PRIVPickableImageWithData,
                               ignoresOcclusion);
}

void
InitializeModule_PickEvent()
{
    PRIVPickableGeometryOp =
        ValPrimOp(PRIVPickableGeometry, 3, "PickableGeometry", GeometryType);
    PRIVPickableImageOp =
        ValPrimOp(PRIVPickableImage, 3, "PickableImage", ImageType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\perf.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Performance sample functions

*******************************************************************************/

#include <headers.h>
#include "privinc/except.h"
#include "values.h"
#include "perf.h"
#include "bvr.h"
#include "appelles/axaprims.h"
#include "privinc/debug.h"
#include "privinc/dddevice.h"
#include "privinc/opt.h"
#include "privinc/tls.h"

DeclareTag(tagDisableBitmapCaching, "Optimizations", "disable bitmap caching");

static const double CUT_OFF_RANGE = 0.5;

// TODO: This should be on thread local storage.
static unsigned int sampleId = 0;

unsigned int NewSampleId() { return ++sampleId; }

#if _USE_PRINT
ostream& operator<<(ostream& os, Perf p)
{
    return p->Print(os);
}
#endif

AxAValue Sample(Perf perf, Time t)
{
    Param p(t);
    
    return perf->Sample(p);
}

AxAValue SampleAt(Perf perf, Param& p, Time t)
{
    Time old = p._time;
    p._time = t;
    AxAValue result = perf->Sample(p);
    p._time = old;

    return result;
}

// We don't want to break the cache...
static AxAValue
SampleEvent(Perf perf, Param& p, Time t, EventSampleType newType)
{
    EventSampleType old = p._sampleType;
    Time oldTime = p._eTime;
    
    p._sampleType = newType;
    p._eTime = t;
    AxAValue result = perf->Sample(p);
    p._sampleType = old;
    p._eTime = oldTime;

    return result;
}

AxAValue EventAt(Perf perf, Param& p, Time t)
{
    // TODO: This seems to be faster...
    return SampleAt(perf, p, t);
    //return SampleEvent(perf, p, t, EventSampleExact);
}

AxAValue EventAfter(Perf perf, Param& p, Time t)
{ return SampleEvent(perf, p, t, EventSampleAfter); }

//////////////////////////////////

Param::Param(Time t, TimeSubstitution ts)
: _time(t), _checkEvent(TRUE), _done(FALSE),
  _sampleType(EventSampleNormal), _eTime(0.0), _currPerf(NULL),
  _noHook(false), _importance(1.0), _timeSubstitution(ts)
{
    _id         = NewSampleId();
    _cid        = -1;
    _cutoff     = t - CUT_OFF_RANGE;
    _sampleTime = t;
}

void Param::PushTimeSubstitution(Perf p)
{
    TimeSubstitution t = NEW TimeSubstitutionImpl(p);
    t->SetNext(_timeSubstitution);
    _timeSubstitution = t;
}

void Param::PushTimeSubstitution(TimeSubstitutionImpl *t)
{
    Assert(t->GetNext()==NULL);
    t->SetNext(_timeSubstitution);
    _timeSubstitution = t;
}

TimeSubstitution Param::PopTimeSubstitution()
{
    TimeSubstitution t = _timeSubstitution;
    if (t) {
        _timeSubstitution = t->GetNext();
        t->SetNext(NULL);
    }

    return t;
}

//////////////////////////////////

void PerfImpl::DoKids(GCFuncObj proc)
{
    if (_cid != 0) {
        // REVERT-RB:
        (*proc)(_cache);
    }

    _DoKids(proc);
}

void PerfImpl::SetCache(AxAValue v, Param& p)
{
    _cache = v;
    _id = p._id;
    _time = p._time;
    //_ts = p.GetTimeSubstitution();
    _optimizedCache = false;
}

#ifdef _DEBUG
#if _USE_PRINT
extern "C" void PrintObj(GCBase* b);
#endif _USE_PRINT    
#endif _DEBUG    

void
StampWithCreationID(AxAValue val, long creationID)
{
    // Stash the creation ID of this guy if it's not fully
    // constant. 
    if (val->GetTypeInfo() == ImageType) {
        Image *img = SAFE_CAST(Image *, val);
        if (img->GetCreationID() != PERF_CREATION_ID_FULLY_CONSTANT) {

            img->SetCreationID(creationID);

            long oid = img->GetOldestConstituentID();
            
            if (oid == PERF_CREATION_ID_BUILT_EACH_FRAME) {

                // If we ourselves are built on a given sample, then
                // our oldest constituent must not be getting created
                // every frame, so tell it so.
                img->SetOldestConstituentID(creationID);
            }

        }
    } else if (val->GetTypeInfo() == GeometryType) {
        Geometry *geo = SAFE_CAST(Geometry *, val);
        if (geo->GetCreationID() != PERF_CREATION_ID_FULLY_CONSTANT) {
            geo->SetCreationID(creationID);
        }
    }
}

AxAValue PerfImpl::GetRBConst(RBConstParam& p)
{
    if (_id != p.GetId()) {
        //Assert(&GetHeapOnTopOfStack() == &GetGCHeap());
        // do the assignment first, so that ode can override this.
        _id = p.GetId();
        _cid = p.GetId();
        _cache = _GetRBConst(p);

        if (_cache) {
            Assert(!GetCurrentSampleHeap().ValidateMemory(_cache));

            StampWithCreationID(_cache, _id);
        } else {
            _cid = 0;
        }
        
        _optimizedCache = false;

#ifdef _DEBUG
#if _USE_PRINT
        if (_cache && IsTagEnabled(tagDCFoldTrace)) {
            TraceTag((tagDCFoldTrace,
                      "GetRBConst(0x%x %s): -> 0x%x, cid = %d, time = %g",
                      this, _cache->GetTypeInfo()->GetName(), _cache, _cid, p.GetParam()._time));
        }
#endif _USE_PRINT    
#endif _DEBUG    
    }
#ifdef _DEBUG    
    if (_cache == NULL) {
        int dummy = 10;
    }
#endif    

    return _cache;
}

bool PerfImpl::DoCaching(Param& p)
{
#if _DEBUG
    if (!IsTagEnabled(tagDisableBitmapCaching)) {
#endif

        // if no view, don't do cache. don't create image device 
        if (GetCurrentViewport(true) == NULL) return false;
        
        if (!_optimizedCache &&
            PERVIEW_BITMAPCACHING_ON &&
            GetThreadLocalStructure()->_bitmapCaching !=
            PreferenceOff) {
            
            // REVERT-RB:
            DynamicHeapPusher h(GetGCHeap());
            //DynamicHeapPusher h(GetViewRBHeap());
            
            ImageDisplayDev *dev = 
                GetImageRendererFromViewport(GetCurrentViewport());

            CacheParam cacheParam;
            cacheParam._idev = dev;
            
            _cache = AxAValueObj::Cache(_cache, cacheParam);
            _optimizedCache = true;

            Assert(!GetCurrentSampleHeap().ValidateMemory(_cache));

            return true;
        }

#if _DEBUG
    }
#endif

    return false;
}

AxAValue PerfImpl::Sample(Param& p)
{
    bool doDCF = true;
    
#ifdef _DEBUG
    if (IsTagEnabled(tagDCFold))
        doDCF = false;
#endif _DEBUG

    if (doDCF && p._cid && (p._cid == _cid) && _cache) {
        TraceTag((tagDCFoldTrace,
                  "Sample(0x%x %s): -> 0x%x, cid = %d, time = %g",
                      this, _cache->GetTypeInfo()->GetName(), _cache, _cid, p._time));
 
        if (DoCaching(p))
            StampWithCreationID(_cache, p._id);

        return _cache;
    }

    if (IsConst(this)) {
        if (_cache) {
            // only cache if const is hit 2nd time
            if (DoCaching(p))
                StampWithCreationID(_cache, PERF_CREATION_ID_FULLY_CONSTANT);
        } else {
            SetCache(_Sample(p), p);
        }

        return _cache;
    }
    
    if (p._sampleType == EventSampleNormal) {
        if (!((_id == p._id) && (_time == p._time)
              //&& (_ts == p.GetTimeSubstitution())
            )) {
            _cid = 0;
            SetCache(_Sample(p), p);
        }

        return _cache;
    } 

    return _Sample(p);
}

AxAEData::AxAEData(Time time, Bvr data)
: _happened(TRUE), _time(time), _data(data)
{
    Assert(data && "NULL event data");

    ViewEventHappened();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\preference.cpp ===
#include "headers.h"
#include "preference.h"
#include "bvr.h"
#include "perf.h"
#include "server/context.h"
#include "privinc/tls.h"

PreferenceSetter::PreferenceSetter(PreferenceClosure &cl,
                                   BoolPref bitmapCaching,
                                   BoolPref geoBitmapCaching) : _closure(cl)
{
    _bitmapCaching = bitmapCaching;
    _geoBitmapCaching = geoBitmapCaching;
}
    
void
PreferenceSetter::DoIt() {
    // stash
    ThreadLocalStructure *tls = GetThreadLocalStructure();
    BoolPref oldbmc = tls->_bitmapCaching;
    BoolPref oldgeo = tls->_geometryBitmapCaching;

    if (oldbmc == NoPreference) {
        tls->_bitmapCaching = _bitmapCaching;
    }
    if (oldgeo == NoPreference) {
        tls->_geometryBitmapCaching = _geoBitmapCaching;
    }

    _closure.Execute();

    if (oldbmc == NoPreference) {
        tls->_bitmapCaching = NoPreference;
    }
    if (oldgeo == NoPreference) {
        tls->_geometryBitmapCaching = NoPreference;
    }
}


// Closure for sampling
class SamplePreferenceClosure : public PreferenceClosure {
  public:
    SamplePreferenceClosure(Perf base, Param &p) : _base(base), _p(p)
    {}

    void Execute() {
        _result = _base->Sample(_p);
    }

    Perf     _base;
    Param   &_p;
    AxAValue _result;
};


class RBConstPreferenceClosure : public PreferenceClosure {
  public:
    RBConstPreferenceClosure(Perf base, RBConstParam &p) : _base(base), _p(p) {}
    void Execute() {
        _result = _base->GetRBConst(_p);
    }

    Perf            _base;
    RBConstParam   &_p;
    AxAValue        _result;
};

class PerformPreferenceClosure : public PreferenceClosure {
  public:
    PerformPreferenceClosure(Bvr base, PerfParam &p) : _base(base), _p(p) {}
    void Execute() {
        _result = ::Perform(_base, _p);
    }

    Bvr          _base;
    PerfParam   &_p;
    Perf         _result;
};

class ConstPreferenceClosure : public PreferenceClosure {
  public:
    ConstPreferenceClosure(Bvr base) : _base(base) {}
    void Execute() {
        ConstParam cp;
        _result = _base->GetConst(cp);
    }

    Bvr          _base;
    AxAValue     _result;
};



///////////  Performance  //////////////


class PreferencePerfImpl : public DelegatedPerf {
  public:
    PreferencePerfImpl(Perf p,
                       BoolPref bitmapCaching,
                       BoolPref geometryBitmapCaching)
      : DelegatedPerf(p)
    {
        _bitmapCaching = bitmapCaching;
        _geometryBitmapCaching = geometryBitmapCaching;
    }

    AxAValue _GetRBConst(RBConstParam& p) {
        RBConstPreferenceClosure cl(_base, p);
        PreferenceSetter ps(cl,
                            _bitmapCaching,
                            _geometryBitmapCaching);
        ps.DoIt();
        return cl._result;
    }
    

    AxAValue _Sample(Param& p) {
        SamplePreferenceClosure cl(_base, p);
        PreferenceSetter ps(cl,
                            _bitmapCaching,
                            _geometryBitmapCaching);
        ps.DoIt();
        return cl._result;
    }
    

  protected:
    BoolPref _bitmapCaching;
    BoolPref _geometryBitmapCaching;
};


///////////  Behavior  //////////////


class PreferenceBvrImpl : public DelegatedBvr {
  public:
    PreferenceBvrImpl(Bvr b,
                      BoolPref bitmapCaching,
                      BoolPref geometryBitmapCaching)
      : DelegatedBvr(b)
    {
        _bitmapCaching = bitmapCaching;
        _geometryBitmapCaching = geometryBitmapCaching;
    }

    Perf _Perform(PerfParam& pp) {
        PerformPreferenceClosure cl(_base, pp);
        PreferenceSetter ps(cl,
                            _bitmapCaching,
                            _geometryBitmapCaching);
        ps.DoIt();
        Perf basePerf = cl._result;
        
        return NEW PreferencePerfImpl(basePerf,
                                      _bitmapCaching,
                                      _geometryBitmapCaching);
    }

    AxAValue GetConst(ConstParam & cp) { 
        ConstPreferenceClosure cl(_base);
        PreferenceSetter ps(cl,
                            _bitmapCaching,
                            _geometryBitmapCaching);
        ps.DoIt();
        return cl._result;
    }

  protected:
    BoolPref _bitmapCaching;
    BoolPref _geometryBitmapCaching;
};

    
Bvr
PreferenceBvr(Bvr b, BSTR prefName, VARIANT val)
{
    USES_CONVERSION;
    char *pname = W2A(prefName);

    Bvr result = NULL;
    
    CComVariant ccVar;
    HRESULT hr = ccVar.ChangeType(VT_BOOL, &val);

    // Fail silently if we don't recognize the value or the
    // preference. 
    if (SUCCEEDED(hr)) {

        bool prefOn = ccVar.boolVal ? true : false;

        bool gotOne = false;
        BoolPref bmapCaching = NoPreference;
        BoolPref geometryBmapCaching = NoPreference;
    
        if (0 == lstrcmp(pname, "BitmapCachingOn")) {
            gotOne = true;
            bmapCaching = prefOn ? PreferenceOn : PreferenceOff;
        } else if (0 == lstrcmp(pname, "GeometryBitmapCachingOn")) {
            gotOne = true;
            geometryBmapCaching = prefOn ? PreferenceOn : PreferenceOff;
        }

        if (!gotOne) {
            // just go with the original
            result = b;
        } else {
            result = NEW PreferenceBvrImpl(b,
                                           bmapCaching,
                                           geometryBmapCaching);
        }

        // Some of these attributes may want to also be known at the
        // static value layer, so apply via ExtendedAttrib as well,
        // and use the final result for our result.
        result = CRExtendedAttrib((CRBvrPtr)result,
                                  prefName,
                                  val);
    }
    
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\sndbvr.h ===
/*******************************************************************************

Copyright (c) 1995_98 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _SNDBVR_H
#define _SNDBVR_H

#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "privinc/helps.h"
#include "privinc/htimer.h"  // TimeStamp

class MetaSoundDevice;
class Sound;
class LeafSound;
class QuartzRenderer;
class SoundContext;

Bvr SoundBvr(LeafSound *s, Bvr end = NULL);

class SoundEndBvr : public BvrImpl {
  public:
    SoundEndBvr(LeafSound *m) : _snd(m) {}

    virtual void _DoKids(GCFuncObj proc);

    virtual Perf _Perform(PerfParam& p);

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }

    virtual BOOL InterruptBasedEvent() { return TRUE; }

  private:
    LeafSound *_snd;
};

typedef enum
{ SND_FETAL, SND_PLAYING, SND_MUTED } SoundStatus;


class SoundInstance : public AxAThrowingAllocatorClass {
  public:
    static const double TINY;
    static const double EPSILON;
    
    SoundInstance(LeafSound *snd, TimeXform tt);

    virtual ~SoundInstance();

    virtual void Create(MetaSoundDevice*, SoundContext *) = 0;
    virtual void StartAt(MetaSoundDevice*, double localTime) = 0;
    //void SeekTo(double localTime);
    virtual void Mute(bool mute) = 0;
    virtual bool Done() = 0;
    virtual bool GetLength(double& leng) = 0;
    virtual void ReleaseResources() = 0;

    // This will be called only if any attribute changes
    virtual void Adjust(MetaSoundDevice*) = 0;

    // This will be called on each update
    virtual void CheckDone() {}

    // so that the stream can grab the tick id
    virtual void SetTickID(DWORD id) {}

    virtual void CheckResources() = 0;

    void SetTime(Time l) { _lt = l; }
    Sound *GetTxSound() { return _txSnd; }
    bool Rendered() { return _hit; }
    SoundStatus GetStatus() { return _status; }

    LeafSound *GetLeafSound() { return _snd; }
    TimeXform GetTimeXform() { return _tt; }
    Perf GetEndPerf() { return _end; }

    bool IsPerfSet() { return _hasPerf; }
    void PerfSet() { _hasPerf = true; }  

    void CollectAttributes(MetaSoundDevice*);
    bool AttributesChanged();
    void UpdateSlope(Param& p);
    void Reset(Time globalTime);
    void Update(MetaSoundDevice*);
    void SetEnd(PerfParam& p);

    void Pause();
    void Resume();

    double GetAge() { return(_timeStamp.GetAge()); }

  protected:
    double Rate(double gt, Param &p);
    double Rate(double gt1, double gt2, Param &p);

    Sound     *_txSnd;
    TimeXform  _tt;
    LeafSound *_snd;
    
    Perf   _end;                  

    double _rate, _gain, _lgain, _rgain, _position;
    bool   _seek;
    bool   _intendToSeek;
    double _rateConstantTime;
    Pan    _pan;

    Time _lt, _lastlt;
    Time _gt, _lastgt;
    
    double _lastRate, _lastGain;
    Pan    _lastPan;
    bool   _lastLoop;

    bool _loop;
    bool _hit;

    bool _firstAttributeHit;

    bool _done;
    bool _paused;
    
    bool _canBeRemoved;
    bool _hasPerf;

    SoundStatus _status;

    SoundContext *_soundContext;

  private:
    TimeStamp _timeStamp;
    void   FixupPosition();
    double LocalizePosition(double position);
};


class SoundInstanceList : public AxAThrowingAllocatorClass {
  public:
    ~SoundInstanceList();
    void Update(MetaSoundDevice*);
    void Reset(Time globalTime);
    void UpdateSlope(Sound *snd, Param& p);
    SoundInstance* Initiate(LeafSound *snd, PerfParam& p, Bvr end);
    void Add(SoundInstance*);
    void Stop(Sound *snd);
    void Pause();
    void Resume();
    Perf GetEndPerf(LeafSound *snd, PerfParam& p);
    SoundInstance* GetSoundInstance(Sound *txsnd);

#ifdef DEVELOPER_DEBUG
    void Dump();
#endif

  private:
    typedef map<Sound*, SoundInstance*> MList;
    typedef MList::iterator MIter;

    MIter Search(MIter begin, LeafSound *snd, TimeXform tt);
    MList _mlist;
};

SoundInstanceList *ViewGetSoundInstanceList();
double ViewGetFramePeriod();

Sound *NewTxSound(LeafSound *snd, TimeXform tt);

SoundInstance *CreateSoundInstance(LeafSound *snd, TimeXform tt);

void AcquireMIDIHardware(Sound *snd, QuartzRenderer *filterGraph);

bool IsUsingMIDIHardware(Sound *snd, QuartzRenderer *filterGraph);

#endif /* _SNDBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\sndbvr.cpp ===
/*******************************************************************************

Copyright (c) 1995-98 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#include <headers.h>
#include "sndbvr.h"
#include "jaxaimpl.h"
#include "privinc/soundi.h"
#include <math.h>
#include "privinc/bufferl.h" // SoundBufferCache
// #include "server/context.h"  // GetSoundBufferCache !! MOVE THIS TO server.h

#define OLD_RESOURCES 4 // release inactive sound instance resources after n seconds

DeclareTag(tagSoundInstance, "Sound", "Track Sound Instances");
DeclareTag(tagSoundPause,    "Sound", "Track Sound Pauses");
DeclareTag(tagSoundTrace1,   "Sound", "Trace Sound Instances on changes");
DeclareTag(tagSoundTrace2,   "Sound", "Trace Sound Instances in more details");

const double SoundInstance::TINY    = 1.0; // smallest sound to be start sync'd
const double SoundInstance::EPSILON = 0.1;

Perf
SoundEndBvr::_Perform(PerfParam& p)
{
    return ViewGetSoundInstanceList()->GetEndPerf(_snd, p);
}

void
SoundEndBvr::_DoKids(GCFuncObj proc)
{ (*proc)(_snd); }


class SoundPerf : public PerfImpl {
  public:
    SoundPerf(Sound *s) : _snd(s) {}

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_snd);
    }

    virtual AxAValue _Sample(Param& p) {
        ViewGetSoundInstanceList()->UpdateSlope(_snd, p);
        return _snd;
    }

  private:
    Sound *_snd;
};

class SoundBvrImpl : public BvrImpl {
  public:
    SoundBvrImpl(LeafSound *m, Bvr end, bool useNaturalEnd)
    : _snd(m), _end(end), _useNaturalEnd(useNaturalEnd) {}

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_snd);
        (*proc)(_end);
    }

    virtual Perf _Perform(PerfParam& p) {
        SoundInstance *s =
            ViewGetSoundInstanceList()->
            Initiate(_snd, p, _useNaturalEnd ? NULL : _end);

        s->PerfSet();
        
        return NEW SoundPerf(s->GetTxSound());
    }

    virtual Bvr EndEvent(Bvr) {
        return _end;
    }
    
    //virtual DWORD GetInfo(bool recalc = false) { return BVR_TIMEVARYING_ONLY; }

    virtual DXMTypeInfo GetTypeInfo () { return SoundType ; }

    virtual BVRTYPEID GetBvrTypeId() { return SOUND_BTYPEID; }
    
  private:
    LeafSound *_snd;
    Bvr        _end;
    bool       _useNaturalEnd;
};

Bvr SoundBvr(LeafSound *s, Bvr end /* = NULL */)
{
    bool useNaturalEnd = false;
    
    if (end == NULL) {
        useNaturalEnd = true;
        end = NEW SoundEndBvr(s);
    }
            
    return NEW SoundBvrImpl(s, end, useNaturalEnd);
}


SoundInstance::SoundInstance(LeafSound *snd, TimeXform tt)
: _snd(snd), _tt(tt), _loop(false), _status(SND_FETAL), 
  _rate(1), _gain(0.0), _lastRate(1), _lastGain(1), _lastLoop(false),
  _hit(false), _end(NULL), _canBeRemoved(false),
  _firstAttributeHit(true), _lgain(0.0), _rgain(0.0),
  _hasPerf(false), _lastlt(-2), _lt(-1), _done(false),
  _lastgt(-2), _gt(-1), _rateConstantTime(0.0), 
  _intendToSeek(false), _seek(false), _position(0), _paused(false)
{
    _lastPan.SetLinear(0.0);
    
    DynamicHeapPusher h(GetGCHeap());
            
    _txSnd = NewTxSound(snd, tt);

    TraceTag((tagSoundInstance,
              "SoundInstance::SoundInstance 0x%x, snd = 0x%x, tt = 0x%x, tsnd = 0x%x",
              this, _snd, _tt, _txSnd));
    
    GCRoots globalRoots = GetCurrentGCRoots();

    _timeStamp.Reset();  // make sure this is initialized!

    // _txSnd deletes SoundInstance when it goes away, this is to
    // ensure _snd and _tt won't get collected before _txSnd
    GCAddToRoots(_snd, globalRoots);
    GCAddToRoots(_tt,  globalRoots);
}


SoundInstance::~SoundInstance()
{
    GCRoots globalRoots = GetCurrentGCRoots();

    if (_end) {
        GCRemoveFromRoots(_end, globalRoots);
    }

    GCRemoveFromRoots(_snd, globalRoots);
    GCRemoveFromRoots(_tt, globalRoots);

    TraceTag((tagSoundInstance,
              "~SoundInstance 0x%x, snd = 0x%x, tt = 0x%x, tsnd = 0x%x",
              this, _snd, _tt, _txSnd));
}


void
SoundInstance::Pause()
{
    _rate = 0.0;     // pause the sound
    _paused = true;  // indicate that we souldn't update
    // NOTE: This won't take effect until the next Update! 
}


void
SoundInstance::Resume()
{
    _paused = false;  // resume updating
}


void
SoundInstance::Reset(Time gt)
{
    TraceTag((tagSoundTrace2,
              "SoundInstance::Reset 0x%x, R = %g, G = %g, L = %d, T = %g",
              this, _rate, _gain, _loop, _lt));
    
    _lastRate = _rate;
    _lastGain = _gain;
    _lastPan  = _pan;
    _lastLoop = _loop;
    _lastlt   = _lt;
    _lastgt   = _gt;
    _gt       =  gt;
    _position = _lt;

    _hit      = false;

    if(!_paused)    // ignore rate if we are paused
        _rate = 1;

    // don't reset seek it is self resetting
    _firstAttributeHit = true;
    _gain     = 0.0;
    _pan.SetMagnitude(0.0, 1);
    _lgain    = _rgain = 0.0;
    _loop     = false;
}


double 
SoundInstance::LocalizePosition(double _position)
{
    double position = _position;  // default 
    double sndLength;
    bool hasLength = GetLength(sndLength);

    if (hasLength && (sndLength < SoundInstance::TINY)) {
        TraceTag((tagSoundTrace1,
                  "   TINY, seek to 0.0, position was = %g", position));
        position = 0.0; // hack so we always play all of tiny sounds...
    }
        
    if (_loop && hasLength) {
        // fixup negative case with fancy mod
        if(position < 0.0) {
            int magnitude = ceil(fabs(position) / sndLength);
            position = position + (magnitude * sndLength);
        }

        position = fmod(position, sndLength);
    } else { // not looping
        if (position < 0.0)
            position = 0.0;  // XXX for now, clamp negative positions to 0
    }

    return(position);
}


void 
SoundInstance::FixupPosition()
{
// XXX we need to do this since _loop is not set when we determine _seek in
//     update slope...

    if(_intendToSeek) {
        _position     = LocalizePosition(_position);
        _seek         = true;
        _intendToSeek = false;
    }
}


void
SoundInstance::CollectAttributes(MetaSoundDevice* dev)
{
    double gain = dev->GetGain();
    double pan  = dev->GetPan();
    
    double lgain, rgain;

    PanGainToLRGain(pan, gain, lgain, rgain);

    _lgain += lgain;
    _rgain += rgain;
    
    _loop = _loop || dev->IsLoopingSet();
    _hit = true;

    TraceTag((tagSoundTrace2,
              "SoundInstance::CollectAttributes 0x%x, G = %g, LG = %g, RG = %g, L = %d, P = %g, H = %d",
              this, gain, _lgain, _rgain, _loop, pan, _hit));
}


const double EPSILON = 0.000001;
inline double NEQ(double a, double b)
{
    return fabs(a-b) > EPSILON;
}


bool
SoundInstance::AttributesChanged()
{
    bool ret =
        (_pan.GetDirection() != _lastPan.GetDirection())      ||
        NEQ(_gain, _lastGain)                                 ||
        NEQ(_rate, _lastRate)                                 ||
        NEQ(_pan.GetdBmagnitude(), _lastPan.GetdBmagnitude()) ||
        _intendToSeek;

#ifdef _DEBUG
    if (ret) {
        TraceTag((tagSoundTrace1,
                  "SoundInstance::AttributesChanged 0x%x, T = %g, GT = %g",
                  this, _lt, _gt));
        TraceTag((tagSoundTrace1,
                  "  LAST: G = %g, R = %g; new: G = %g, R = %g",
                  _lastGain, _lastRate, _gain, _rate));
        TraceTag((tagSoundTrace1,
                  "  LAST: P = %g, %d; new: P = %g, %d",
                  _lastPan.GetdBmagnitude(), _lastPan.GetDirection(),
                  _pan.GetdBmagnitude(), _pan.GetDirection()));
    }
#endif

    CheckDone();
    
    return ret;
}


void
SoundInstance::SetEnd(PerfParam& p)
{
    _end = ::Perform(AppTriggeredEvent(), p);

    GCRoots globalRoots = GetCurrentGCRoots();

    GCAddToRoots(_end, globalRoots);
}


void
SoundInstance::Update(MetaSoundDevice* dev)
{
    SetPanGain(_lgain, _rgain, _pan, _gain);

    TraceTag((tagSoundTrace2,
              "SoundInstance::Update 0x%x, G = %g, LG = %g, RG = %g",
              this, _gain, _lgain, _rgain, _loop, _hit));

    TraceTag((tagSoundTrace2,
              "    R = %g, lastT = %g, T = %g, L = %d, H = %d",
              _rate, _lastlt, _lt, _loop, _hit));

    switch (_status) {
      case SND_FETAL:
        if(_hit) {
            // Do the start at in the first render, like the old code.
            // TODO: Maybe we can call Create and Adjust even not hit. 
            
            CheckResources();  // will do a Create(dev) if needed

            SetTickID(ViewGetSampleID()); // only seek 1 time per tick
            
            TraceTag((tagSoundTrace1,
                      "SoundInstance::Update 0x%x, CREATED, G = %g, R = %g, T = %g",
                      this, _gain, _rate, _lt));
        
            FixupPosition();
            Adjust(dev);

            // if it's a tiny sound and we're not too far off the
            // beginning, let's always play from the beginning to avoid
            // clipping relevant portion off.
            // TODO: sync issue needs to be dealt w/ correctly.
        
            double sndLength;

            if(GetLength(sndLength) && (sndLength < TINY) && (_lt < TINY)) {
                StartAt(dev, 0.0);
                
                TraceTag((tagSoundTrace1,
                          "   TINY, started at 0.0, T = %g", _lt));
            } else {
                
                StartAt(dev, _lt);
                TraceTag((tagSoundTrace1, "   started at %g", _lt));
            }
        
            _status = SND_PLAYING;
        }
      break;
        
      case SND_PLAYING:
        if(!_hit) {
            _status = SND_MUTED; // muted already
            _loop = _lastLoop;   // save value since we aren't being sampled
            
            TraceTag((tagSoundTrace1,
                      "SoundInstance::Update 0x%x, MUTE, T = %g", this, _lt));
        } else {
            // TODO: check for looping attr. change...
        
            if(AttributesChanged()) {
                FixupPosition();
                Adjust(dev); // since this can re-construct only do this if hit
            }
        }
      break;

      case SND_MUTED:
        if(AttributesChanged()) {
            FixupPosition();
            Adjust(dev);
        }
        
        if(_hit) {
            Mute(false);
            _status = SND_PLAYING;

            TraceTag((tagSoundTrace1,
                      "SoundInstance::Update 0x%x, UNMUTE", this));
        } else {
            _loop = _lastLoop; // save value since we aren't being sampled
        }
      break;          
    }

    // TODO: need more work...
    if(!_done) {
        _timeStamp.Reset();  // reset timestamp keepalive

        if((_status != SND_FETAL) && !_loop && Done()) {
            _done = true;

            if(_end) {
                TraceTag((tagSoundTrace1,
                          "SoundInstance::Update 0x%x, DONE", this));
                _end->Trigger(TrivialBvr(), false);
            }
        }
    }
    else {  // we are done, see how long we have been done...
        if(_timeStamp.GetAge() > OLD_RESOURCES) {
            TraceTag((tagSoundReaper1, 
                "SoundInstance::Update, releasing (%d) resources", this));
            ReleaseResources();
        }
    }
}


double
SoundInstance::Rate(double newgt, Param &p)
{
    return(Rate(_lastgt, newgt, p));
}


double
SoundInstance::Rate(double gt1, double gt2, Param &p)
{
    Param pp = p;  // setup a new parameter which inherits attibutes from p

    pp._time   = gt1;
    double lt1 = EvalLocalTime(pp, _tt);


    pp._time   = gt2;
    double lt2 = EvalLocalTime(pp, _tt);

    double rate = (lt2-lt1)/(gt2-gt1);
    return(rate);
}


void
SoundInstance::UpdateSlope(Param& p)
{
    if(_paused) {            // handle the case where the view is paused
        Assert(_rate==0.0);  // just making sure ::Pause() should have set this
        return;
    }

// evaluate interSampling period slope to detect events:
//     constant slope then very steep  ---> forward seek
//     constant very steep slope       ---> OK, no event, sinSynth...
//     constant slope then negative    ---> reverse seek (modtime)
// if no event --> use inter sampling period slope
// otherwise   --> seek to current local time and calculate new INTRA slope

    int    event       = 0;                  // we default to no seek event
    double interRate   = _lastRate;          // default
    double detectoRate = _lastRate;          // default
    _rate = _lastRate; // initialize (in case of early return)

    SetTime(EvalLocalTime(p, _tt));

    if(p._time != p._sampleTime) {
        TraceTag((tagSoundTrace2,
                  "UpdateSlope: Whacky time lt=%g, sampletime=%g, returning", 
                  p._time, p._sampleTime));
        return;  // return immediately, nothing for us to do
    }

    // lets detect hiccups in global time!
    if(_gt < _lastgt) {
        TraceTag((tagSoundTrace2,
                  "UpdateSlope: global time reversion gt=%g, oldgt=%g, returning", 
                  _gt, _lastgt));
        return;
    } else if(isNear(_gt, _lastgt, 0.0001)) {
        TraceTag((tagSoundTrace2,
                  "UpdateSlope: global time repeat gt=%g, oldgt=%g, returning", 
                  _gt, _lastgt));
        return;
    }


    double lastFramePeriod = _gt - _lastgt;
    TraceTag((tagSoundTrace2,
              "SoundInstance::UpdateSlope 0x%x, GT = %g, T = %g, R = %g",
              this, _gt, _lt, _rate));
    
    // calculate rates
    if(isNear(_lastgt, -1.0, 0.0001) || isNear(_lastgt, -2.0, 0.0001)) {
        event = 1;
        TraceTag((tagSoundTrace2, "UpdateSlope EVENT: _lastgt NEAR -2"));
    } else if(_tt->IsShiftXform()) {
            interRate   = 1.0; // by definition unity rate
            detectoRate = 1.0; // by definition unity rate
    } else {  // we need to work, it is a black box, need to evaluate it
        // from where we came from to where we expect to go this time
        //interRate   = Rate(_lastgt, _gt + lastFramePeriod, p);
        interRate   = Rate(_lastgt, _gt, p);
        detectoRate = Rate(_lastgt, _gt, p); // detect event in LAST period!
    }

    TraceTag((tagSoundTrace2, "UpdateSlope: (0x%x) detecto lgt:%g, gt:%g, r:%g",
              this, _lastgt, _gt, detectoRate));


    // XXX how much bounce do we really see for a 'constant' rate?
    const double runEpsilon = 0.01;   
    if(isNear(detectoRate, _lastRate, runEpsilon)) {
        _rateConstantTime+= lastFramePeriod;    // been this way for a while
    } else {
        if(_rateConstantTime > 0.4) {
            event = 2; // we changed after a significant time
        }
        _rateConstantTime = 0.0; // just changed
    }

    // negative or too steep slope are indications of seeking 
    // unfortunately very steep slopes are acceptable for sinSynth so
    // watch for constant steep slopes!
    if(detectoRate < 0.0)
        event = 3;
    if((detectoRate > 5)&&(_rateConstantTime == 0.0))
        event = 4;

    // constant and then changed an indication of something significant 
    if(event) {
        _rate = Rate(_gt+0.0001, _gt+0.001, p); // only average over a short pd

        if(_rate >= 0.1) { // XXX >0 better bcause don't need to sk if stopped!
            _intendToSeek = true;  // 'fraid we have to seek, Son.

            // XXX we really should tt the CURRENT gt
            _position = _lt; // position will be fixed up later by LocalizePosition
        } else { // intrarate negative, we don't go backwards, so don't seek
            _intendToSeek = false;
            event+=10;  // this way we know we got a negative!
        }

        if(event==1)
            _intendToSeek = false;
        
        TraceTag((tagSoundTrace1,
          "UpdateSlope 0x%x SEEKING to position:%g gt:%g reason:%d, dr=%g, r=%g, lr=%g",
                  this, _position, _gt, event, detectoRate, _rate, _lastRate));
    } else {  // no event
        _intendToSeek = false;
        _rate         = interRate;
        
        TraceTag((tagSoundTrace2,
          "UpdateSlope 0x%x No-SEEKING  lt:%g, gt:%g, interate:%g, dr=%g, count:%g",
                  this, _lt, _gt, interRate, detectoRate, _rateConstantTime));
    }

    // determine tt change by recalculating lastlt using lastgt, present tt
    // XXX all this tells us is the tt is time varying or reactive...
    //if(_lastlt != TimeTransform(_lastgt, _tt)) 


    TraceTag((tagSoundTrace2,
              "SoundInstance::UpdateSlope 0x%x, GT:%g, LT:%g, R:%g",
              this, _gt, _lt, _rate));
}


SoundInstanceList::~SoundInstanceList()
{
    for(MIter index = _mlist.begin(); index != _mlist.end(); index++) {
        if((*index).second)
            delete (*index).second;
    }
}


SoundInstanceList::MIter
SoundInstanceList::Search(SoundInstanceList::MIter begin, LeafSound *snd, TimeXform tt)
{
    for(SoundInstanceList::MIter index = begin; index != _mlist.end(); index++){
        if(((*index).second->GetLeafSound() == snd) &&
            ((*index).second->GetTimeXform() == tt))
            return index;
    }

    return _mlist.end();
}


SoundInstance *
SoundInstanceList::Initiate(LeafSound *snd, PerfParam& p, Bvr end)
{
    MIter index = Search(_mlist.begin(), snd, p._tt);

    if(index == _mlist.end()) {
        SoundInstance *soundInstance = CreateSoundInstance(snd, p._tt);
        Assert(soundInstance);
        if(!end)
            soundInstance->SetEnd(p);
        _mlist[soundInstance->GetTxSound()] = soundInstance;

        TraceTag((tagSoundInstance,
                  "Added SoundInstance(%s) 0x%x, tsnd = 0x%x, list = %d",
                  typeid(soundInstance).name(), soundInstance, 
                  soundInstance->GetTxSound(), _mlist.size()));
        Assert(GetSoundInstance(soundInstance->GetTxSound()));
        
        return soundInstance;
    } else {
        Assert((*index).second->GetStatus() == SND_FETAL);
        return (*index).second;
    }     
}


void
SoundInstanceList::Add(SoundInstance* soundInstance)
{
    Assert(soundInstance);
    _mlist[soundInstance->GetTxSound()] = soundInstance;
}


SoundInstance*
SoundInstanceList::GetSoundInstance(Sound *snd)
{
    MIter index = _mlist.find(snd);

    if(index != _mlist.end())
        return (*index).second;
    else
        return NULL;
}
    

void
SoundInstanceList::Stop(Sound *snd)
{
    MIter index = _mlist.find(snd);

    if(index != _mlist.end()) {
        delete (*index).second;
        _mlist.erase(index);
    }
}


void
SoundInstanceList::Pause()
{
    for(MIter index = _mlist.begin(); index != _mlist.end(); index++)
        ((*index).second)->Pause(); // SoundInstance
}


void
SoundInstanceList::Resume()
{
    for(MIter index = _mlist.begin(); index != _mlist.end(); index++)
        ((*index).second)->Resume(); // SoundInstance
}


Perf
SoundInstanceList::GetEndPerf(LeafSound *snd, PerfParam& p)
{
    Perf result = NULL;
    MIter index = _mlist.begin();

    while(result == NULL) {
        index = Search(index, snd, p._tt);

        if(index == _mlist.end()) {
            // this case, we hit the end event before the sound bvr,
            // so let's create slot.
            SoundInstance *m = Initiate(snd, p, NULL);
            result = m->GetEndPerf();
        } else {
            result = (*index).second->GetEndPerf();
        }
    }

    return result;
}


void
SoundInstanceList::Update(MetaSoundDevice* dev)
{
    MIter index = _mlist.begin();
    list<Sound*> toBeFreed;

    for(index = _mlist.begin(); index != _mlist.end(); index++) {
        SoundInstance *s = (*index).second;

        if(!s->IsPerfSet()) {
            delete s;
            toBeFreed.push_front((*index).first);
        }
    }
    
    // TODO: can do something more efficient
    for(list<Sound*>::iterator j = toBeFreed.begin();
         j != toBeFreed.end(); j++) {
        _mlist.erase(*j);
    }
    
    // takes care sounds to mute first to avoid click
    for(index = _mlist.begin(); index != _mlist.end(); index++) {
        SoundInstance *m = (*index).second;
        if((m->GetLeafSound()->RenderAvailable(dev)) &&
            (m->GetStatus()==SND_PLAYING) && !m->Rendered()) {
            m->Mute(true);
        }
    }

    for(index = _mlist.begin(); index != _mlist.end(); index++) {
        SoundInstance *s = (*index).second;

        Assert(s->IsPerfSet());
        
        if(s->GetLeafSound()->RenderAvailable(dev)) {
            s->SetTickID(ViewGetSampleID());
            s->Update(dev);
        }
    }

    // GetSoundBufferCache()->ReapElderly(); // remove unused sounds from cache
}


void
SoundInstanceList::Reset(Time globalTime)
{
    for(MIter index = _mlist.begin(); index != _mlist.end(); index++)
        (*index).second->Reset(globalTime);
}


void
SoundInstanceList::UpdateSlope(Sound *snd, Param& p)
{
    SoundInstance *soundInstance = GetSoundInstance(snd);

    Assert(soundInstance);

    // TODO: can optimize out if renderer not available.
    soundInstance->UpdateSlope(p);
}


#ifdef DEVELOPER_DEBUG
void
SoundInstanceList::Dump()
{
    TraceTag((tagSoundInstance, "size = %d\n", _mlist.size()));
    
    for(MIter index = _mlist.begin(); index != _mlist.end(); index++) {
        SoundInstance *m = (*index).second;
        TraceTag((tagSoundInstance,
                  "SoundInstance(%s) 0x%x, tsnd = 0x%x\n",
                  typeid(m).name(), m,  m->GetTxSound()));
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\sprite.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Sprite data structure to support retained mode sound/imaging

*******************************************************************************/

#include <headers.h>
#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "jaxaimpl.h"
#include "sprite.h"

void SpriteNode::Splice(SpriteNode* s)
{
    if (_next)
        _next->Splice(s);
    else
        _next = s;
}

class RMGroupImpl : public RMImpl {
  public:
    RMGroupImpl(RMImpl* kids, Perf e, TimeXform tt,
                SpriteNode *s, SpriteCtx *ctx)
    : RMImpl(s), _kids(kids), _event(e), _tt(tt), _ctx(ctx) {
        Assert(ctx);
        _ctx->AddRef();
        //_b0 = StartedBvr(_p0, type);
    }

    virtual ~RMGroupImpl() { _ctx->Release(); }

    bool IsGroup() { return true; }

    virtual void DoKids(GCFuncObj proc);

    virtual void Stop(Time t) { _sprite->StopList(t); }

    RMImpl* GetKids() { return _kids; }
    void SetKids(RMImpl* kids) { _kids = kids; }

    void _Sample(Param& p);
    
  private:
    RMImpl* _kids;
    Perf _event;
    TimeXform _tt;
    Bvr _b0;
    SpriteCtx *_ctx;
};

void RMImpl::Splice(RMImpl* s)
{
    if (_next)
        _next->Splice(s);
    else
        _next = s;
}
    
void RMGroupImpl::DoKids(GCFuncObj proc)
{
    (*proc)(Next());
    (*proc)(_kids);
    (*proc)(_event);
    (*proc)(_tt);
    (*proc)(_b0);
}

void RMGroupImpl::_Sample(Param& p)
{
    _kids->Sample(p);           // sample for event detection

    Bvr old = p._currPerf;
    p._currPerf = _ctx->GetEmptyBvr();
    AxAEData *edata = ValEData(_event->Sample(p));
    p._currPerf = old;

    if (edata->Happened()) {
        Time te = edata->HappenedTime();
        TimeXform tt = Restart(_tt, te, p);
        Bvr data = edata->EventData();
        CheckMatchTypes("until", _b0->GetTypeInfo(), data->GetTypeInfo());

        // Use Reset so we don't need to know the dev type to create
        // NEW one.  _ctx is ref counted.
        _ctx->Reset();
        
        SpriteNode* s;
        
        RMImpl* r = data->Spritify(PerfParam(te, tt), _ctx, &s);

        // Optimization
        /*
        if (r->IsGroup() && (r->Next() == NULL)) {
          RMGroupImpl *gp = SAFE_CAST(RMGroupImpl*, r);
          r = gp->GetKids();
        }
        */

        _sprite->StopList(te);

        // Sprites will get deleted by RMImpl, which is GC'ed
        _sprite = s;
        
        SetKids(r);
    }
}

RMImpl *RMGroup(RMImpl* kids,
                Perf e,
                TimeXform tt,
                SpriteNode* s,
                SpriteCtx* ctx)
{ return NEW RMGroupImpl(kids, e, tt, s, ctx); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\primop.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Primitive values
    TODO: Should have a ValPrimOp table instead of creating ValPrimOp
    objects all the time

*******************************************************************************/

#include <headers.h>
#include "privinc/except.h"
#include "privinc/server.h"
#include "values.h"
#include "bvr.h"
#include "events.h"
#include "appelles/events.h"
#include "appelles/axaprims.h"
#include "appelles/geom.h"
#include "privinc/soundi.h"
#include "privinc/movieimg.h"
#include "axadefs.h"

extern AxAValue PrimDispatch (AxAPrimOp * primop,
                              int nargs,
                              AxAValue cargs[]);

/////////////////////////// PrimOps ///////////////////////////////

void AxAPrimOp::DoKids(GCFuncObj proc) { (*proc)(_type); }
AxAValue AxAPrimOp::Apply (int nargs, AxAValue cargs[])
{ return PrimDispatch(this,nargs,cargs); }  

Bvr MakeKeyUpEventBvr(Bvr b)
{ return WindEvent(WE_KEY, 0, AXA_STATE_UP, b); }

Bvr MakeKeyDownEventBvr(Bvr b)
{ return WindEvent(WE_KEY, 0, AXA_STATE_DOWN, b); }

Bvr KeyUp(long key)
{ return WindEvent(WE_KEY, key, AXA_STATE_UP,
                   key ? TrivialBvr() : NumToBvr(0)) ; }

Bvr KeyDown(long key)
{ return WindEvent(WE_KEY, key, AXA_STATE_DOWN,
                   key ? TrivialBvr() : NumToBvr(0)) ; }

AxABoolean *BoolAnd(AxABoolean* a, AxABoolean* b)
{ return NEW AxABoolean(AxABooleanToBOOL(a) && AxABooleanToBOOL(b)); }

AxABoolean *BoolOr(AxABoolean* a, AxABoolean* b)
{ return NEW AxABoolean(AxABooleanToBOOL(a) || AxABooleanToBOOL(b)); }

AxABoolean *BoolNot(AxABoolean* a)
{ return NEW AxABoolean(!AxABooleanToBOOL(a)); }

// TODO: Factor out code

extern AxAPrimOp *XCoordVector2Op, *YCoordVector2Op, *XyVector2Op,
    *XCoordVector3Op, *YCoordVector3Op, *ZCoordVector3Op, *XyzVector3Op,
    *XCoordPoint2Op, *YCoordPoint2Op,
    *XCoordPoint3Op, *YCoordPoint3Op, *ZCoordPoint3Op;

Bvr IntegralVector2(Bvr v)
{
    Bvr x = PrimApplyBvr(XCoordVector2Op, 1, v);
    
    Bvr y = PrimApplyBvr(YCoordVector2Op, 1, v);

    return PrimApplyBvr(XyVector2Op, 2, IntegralBvr(x), IntegralBvr(y));
}

Bvr IntegralVector3(Bvr v)
{
    Bvr x = PrimApplyBvr(XCoordVector3Op, 1, v);
    
    Bvr y = PrimApplyBvr(YCoordVector3Op, 1, v);

    Bvr z = PrimApplyBvr(ZCoordVector3Op, 1, v);

    return PrimApplyBvr(XyzVector3Op, 3,
                        IntegralBvr(x), 
                        IntegralBvr(y),
                        IntegralBvr(z));
}

Bvr DerivVector2(Bvr v)
{
    Bvr x = PrimApplyBvr(XCoordVector2Op, 1, v);
    
    Bvr y = PrimApplyBvr(YCoordVector2Op, 1, v);

    return PrimApplyBvr(XyVector2Op, 2, DerivBvr(x), DerivBvr(y));
}

Bvr DerivVector3(Bvr v)
{
    Bvr x = PrimApplyBvr(XCoordVector3Op, 1, v);
    
    Bvr y = PrimApplyBvr(YCoordVector3Op, 1, v);

    Bvr z = PrimApplyBvr(ZCoordVector3Op, 1, v);

    return PrimApplyBvr(XyzVector3Op,
                        3,
                        DerivBvr(x),
                        DerivBvr(y),
                        DerivBvr(z));
}


Bvr DerivPoint2(Bvr v)
{
    Bvr x = PrimApplyBvr(XCoordPoint2Op, 1, v);
    
    Bvr y = PrimApplyBvr(YCoordPoint2Op, 1, v);

    return PrimApplyBvr(XyVector2Op, 2, DerivBvr(x), DerivBvr(y));
}

Bvr DerivPoint3(Bvr v)
{
    Bvr x = PrimApplyBvr(XCoordPoint3Op, 1, v);
    
    Bvr y = PrimApplyBvr(YCoordPoint3Op, 1, v);

    Bvr z = PrimApplyBvr(ZCoordPoint3Op, 1, v);

    return PrimApplyBvr(XyzVector3Op, 3,
                        DerivBvr(x),
                        DerivBvr(y),
                        DerivBvr(z));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\sprite.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Sprite data structure to support retained mode sound/imaging

*******************************************************************************/


#ifndef _SPRITE_H
#define _SPRITE_H

#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "privinc/snddev.h" // for MetaSoundDevice
#include "privinc/soundi.h" // for MetaSoundDevice

class ATL_NO_VTABLE SpriteNode : public AxAThrowingAllocatorClass {
  public:
    SpriteNode() : _next(NULL) {};
    
    virtual ~SpriteNode() { _next = NULL; }
    
    void Splice(SpriteNode* s);

    virtual void StopList(Time te) {
        Stop(te);
        if (_next) _next->StopList(te);
    }
    
    virtual void Stop(Time te) = 0;
    
    SpriteNode* Next() { return _next; }

    virtual void DoKids(GCFuncObj) {}

  private:
    SpriteNode* _next;
};

class ATL_NO_VTABLE SpriteCtx : public AxAThrowingAllocatorClass {
  public:
    SpriteCtx() : _refCnt(1) {}
    virtual ~SpriteCtx() { Assert(_refCnt == 0); }

    virtual void Reset() {}

    virtual Bvr GetEmptyBvr() = 0;

    ULONG AddRef() { return ++_refCnt; }
    ULONG Release() {
        if (0==--_refCnt) {
            delete this;
        }
        return _refCnt;
    }

  private:
    ULONG _refCnt;
};

// TODO: Probably don't need to be GCObj
class RMImpl : public GCObj {
  public:
    RMImpl(SpriteNode *s) : _next(NULL), _sprite(s),
         _lastSampleTime(0.0), _lastLocalTime(0.0) {}

    virtual ~RMImpl() { delete _sprite; }

    void Splice(RMImpl* s);
    
    RMImpl* Next() { return _next; }

    bool IsGroup() { return false; }

    virtual void DoKids(GCFuncObj proc) { (*proc)(_next); }

    void Sample(Param& p) {
        _Sample(p);
        if (_next) _next->Sample(p);
    }

    virtual void Stop(Time te) { if (_sprite) _sprite->Stop(te); }
    
    virtual void _Sample(Param& p) {}
    SpriteNode *_sprite;

    // XXX make private?
    double  _lastSampleTime;  // time we were last sampled
    double  _lastLocalTime;   // time we were last sampled
    
  protected:
    RMImpl *_next;

  private:
};

RMImpl *RMGroup(RMImpl* kids,
                Perf e,
                TimeXform tt,
                SpriteNode* s,
                SpriteCtx* ctx);

SpriteCtx *NewSoundCtx(MetaSoundDevice *metaDev);


class SoundSprite : public SpriteNode {
  public:
    SoundSprite(Sound* snd, MetaSoundDevice *metaDev, Time t0, bool loop);
    void UpdateAttributes(double time, double gain, double pan, double rate);
    virtual void DoKids(GCFuncObj proc) { (*proc)(_snd); }
    virtual void Stop(Time te) {} // Stop buffer

    // XXX should be private one day?
    Sound *_snd;
    double _gain, _rate;
    double _pan;
    bool   _loop;

  private:
    Time   _t0;
};

#endif /* _SPRITE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\switcher.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Switcher

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "sprite.h"
#include "appelles/events.h"
#include "privinc/server.h"
#include "server/context.h"
#include "server/view.h"
#include "privinc/util.h"
#include "server/import.h"
#include "privinc/colori.h"
#include "privinc/vec2i.h"
#include "privinc/vec3i.h"
#include "privinc/xformi.h"

DeclareTag(tagSwitchTo, "Engine", "SwitchTo - print");
#ifdef _DEBUG
extern "C" void PrintObj(GCBase* b);
#endif

#if DEVELOPER_DEBUG
LONG g_switchesSinceLastTick = 0;

LONG
GetSwitchCount()
{
    return g_switchesSinceLastTick;
}

void
ResetSwitchCount()
{
    g_switchesSinceLastTick = 0;
}
#endif

enum SWITCHER_TYPE {
    ST_BASE = 0,
    ST_IMPORT
};

// NOTE: It's more like until, so not considered
// constant even if _base is, unless finalized...

class SwitcherBvrImpl;
class SwitcherEndBvrImpl;
class SwitcherEndPerfImpl;

class SwitcherPerfImpl : public PerfImpl {
  public:
    SwitcherPerfImpl(Perf init, Time t0,
                     TimeXform tt, SwitcherBvrImpl *parent);

    void SetEndPerf(SwitcherEndPerfImpl *end) { _end = end; }

    virtual AxAValue _GetRBConst(RBConstParam& p)
    {
        p.AddChangeable(this);
        return _curr->GetRBConst(p);
    }

    virtual bool CheckChangeables(CheckChangeablesParam &ccp);
    
    virtual AxAValue _Sample(Param& p);
    
    virtual void _DoKids(GCFuncObj proc);

#if _USE_PRINT
    virtual ostream& Print(ostream& os);
#endif

    virtual BVRTYPEID GetBvrTypeId() { return SWITCHER_BTYPEID; }
  protected:
    Perf _curr;
    SwitcherBvrImpl *_base;
    Time _t0;
    TimeXform _tt;
    long _uniqueId;
    SwitcherEndPerfImpl *_end;
};

BOOL IsSwitcher(Perf p)
{ return (p->GetBvrTypeId() == SWITCHER_BTYPEID); }

// SYNCHRONIZATION: We need to ensure that this object's data is
// synchronized since it can change.

class SwitcherBvrImpl : public BvrImpl {
  public:
    SwitcherBvrImpl(Bvr b, SwitchToParam flag)
    : _bvr(b), _switchTime(0), _finalized(FALSE),
      _typeInfo(b->GetTypeInfo()), _endEvent(NULL), _uniqueId(0),
      _dftSwFlag(flag), _swFlag(SW_DEFAULT) {
          // TODO: check if flag is valid.
          Assert(!(flag & SW_FINAL));
    }

    virtual DWORD GetInfo(bool recalc) {
        return ~BVR_HAS_NO_SWITCHER & _bvr->GetInfo(recalc);
    }

    Perf PerformHelper(PerfParam& p);
    
    virtual Perf _Perform(PerfParam& p) {
        SwitcherPerfImpl *perf;
        Perf end;

        // If already switched before performing, use the switched one
        if (p._continue) {
            DWORD stime = SwitchToTimeStamp();
            if ((stime > 0) && (stime > p._lastSystemTime)) {
                PerfParam pp(p._p->_time,
                             Restart(p._tt, p._p->_time, *p._p));
                return PerformHelper(pp);
            }
        }

        return PerformHelper(p);
    }

    virtual void _DoKids(GCFuncObj proc);
    
    virtual DXMTypeInfo GetTypeInfo () { return _typeInfo ; }
    
    virtual BVRTYPEID GetBvrTypeId() { return SWITCHER_BTYPEID; }

    virtual Bvr EndEvent(Bvr overrideEvent);
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        return os << "sw(" << _bvr << ")";
    } 
#endif

    virtual void SwitchTo(Bvr b, bool override, SwitchToParam flag,
                          Time gTime) {
#if DEVELOPER_DEBUG
        InterlockedIncrement(&g_switchesSinceLastTick);
#endif
        
        CheckMatchTypes("switcher", b->GetTypeInfo(), _typeInfo);
        
        _SwitchTo(b, override, flag, gTime);

#if _DEBUG
        TraceTag((tagSwitchTo, "SwitchTo(%s 0x%x) 0x%x at %u finalized:%d",
                  _typeInfo->GetName(), this,
                  _bvr, _switchTime, _finalized));
#if _USE_PRINT
        if (IsTagEnabled(tagSwitchTo))
            PrintObj(_bvr);
#endif
#endif  
    }

    void _SwitchTo(Bvr b, bool override, SwitchToParam flag, Time gTime);

    // Switch values directly in. 
    void SwitchToNumbers(Real *numbers, Transform2::Xform2Type *xfType);

    bool IsFinalized() {
        CritSectGrabber csp(_critSect);
        return _finalized;
    }

    SwitchToParam GetFlag() {
        CritSectGrabber csp(_critSect);
        return _swFlag;
    }

    Bvr SwitchToBvr() {
        CritSectGrabber csp(_critSect);

        return _bvr;
    }

    DWORD SwitchToTimeStamp() {
        CritSectGrabber csp(_critSect);
        return _switchTime;
    }

    virtual AxAValue GetConst(ConstParam & cp) {
        CritSectGrabber csp(_critSect);

        if (_finalized || cp._bAllowTempConst)
        {
            return _bvr->GetConst(cp);
        }
        
        return NULL;
    }

    Time SwitchToGlobalTime() {
        CritSectGrabber csp(_critSect);
        return _gTime;
    }

    bool GetEstimatedSwitchTime(DWORD swTime, Time t, Time & newtime) {
        DWORD currentTime, lastSampledSystemTime;

        // Use system time to estimate the switch time in view
        // global timeline through interpolation.
            
        Time t0;

        if (!ViewLastSampledTime(lastSampledSystemTime,
                                 currentTime,
                                 t0))
            return false;

        Time startTime = t0;

        if ((currentTime > swTime) &&
            (swTime > lastSampledSystemTime)) {
            
            double pt = (double) (swTime - lastSampledSystemTime) /
                (double) (currentTime - lastSampledSystemTime);

            startTime = t0 + (t - t0) * pt;
        }

        newtime = startTime;

        return true;
    }

    virtual Bvr GetCurBvr() {
        CritSectGrabber csp(_critSect);

        return _bvr;
    }
    
    virtual SWITCHER_TYPE GetSwitcherType() { return ST_BASE; }

    long GetUniqueId() { return _uniqueId; }
    void UpdateUniqueId() { InterlockedIncrement(&_uniqueId); }

    virtual void Trigger(Bvr data, bool bAllViews) {
        GetCurBvr()->Trigger(data, bAllViews);
    }
    
  protected:
    Bvr _bvr;
    SwitcherEndBvrImpl *_endEvent;
    DWORD _switchTime;
    bool _finalized;
    CritSect _critSect;
    long _uniqueId;

    DWORD _swFlag, _dftSwFlag;
    
    DXMTypeInfo _typeInfo;

    Time _gTime;
};

// Switch values directly in, but we need to be sure that the
// behavior we're switching into isn't shared by other behaviors.
// If it is, create a new, unshared one to switch in for the first
// time. 
void
SwitcherBvrImpl::SwitchToNumbers(Real *numbers,
                                 Transform2::Xform2Type *xfType)
{
    UpdateUniqueId();

    // Should be established by PRIMPRECODE...
    Assert(&GetHeapOnTopOfStack() == &GetGCHeap());
        
    DXMTypeInfo ti = GetTypeInfo();

    Bvr relevantOne = _bvr;

    bool isShared = relevantOne->GetShared();

    if (isShared) {
            
        // is being shared, need to create new, unshared
        // behavior.  Plug in an new, uninitialized, unshared
        // behavior.  We'll initialize it below.  Subsequent
        // SwitchToNumbers will modify it directly.

        AxAValue newValue;
            
        if (ti == AxANumberType) {
            newValue = NEW AxANumber(0);
        } else if (ti == ColorType) {
            newValue = NEW Color();
        } else if (ti == Transform2Type && xfType &&
                   (*xfType != Transform2::Translation)) {

            switch (*xfType) {
              case Transform2::Scale:
                newValue = ScaleRR(1, 1);
                break;
              case Transform2::Rotation:
                newValue = Rotate2Radians(0);
                break;
            }

        } else if (ti == Transform3Type && xfType &&
                   (*xfType != Transform2::Translation)) {

            switch (*xfType) {
              case Transform2::Scale:
                newValue = Scale(1, 1, 1);
                break;
              case Transform2::Rotation:
                newValue = RotateXyz(0, 0, 0, 0);
                break;
            }

        } else {

            // Note that this may include points, vectors, and
            // translates.  That's because if we get here, the
            // point,vector, or translate being switched was not
            // created with the Modifiable*** constructor on
            // IDAStatics2.  This means that we don't know if it's
            // pixel mode or meter mode, and can't possibly do the
            // right thing here.  In this case, we raise an
            // error.  Thus, to use the SwitchToPoint,
            // SwitchToVector, and SwitchToTranslate modifiers,
            // you need to create your object via the
            // IDAStatics2::Modifiable*** object creators.
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_BAD_SWITCH);
        }

        Assert(newValue);

        Bvr unshared = UnsharedConstBvr(newValue);

        // Constant, doesn't matter restart or not...
        SwitchTo(unshared, true, SW_DEFAULT, 0.0);

        // Recalc our relevant one now that we've switched. 
        relevantOne = _bvr;

        // Better be the same, and better not be shared.
        Assert(unshared == relevantOne &&
               !relevantOne->GetShared()); 
    }
        
    // The underlying behavior isn't shared, so let's
    // modify it.
    ConstParam cp;
    AxAValue val = relevantOne->GetConst(cp);

    // better be const if it's unshared, since we only create
    // unshareds as consts.
    Assert(val);

    if (ti == AxANumberType) {
                
        (SAFE_CAST(AxANumber *, val))->SetNum(numbers[0]);
                
#if _DEBUG
        if(IsTagEnabled(tagSwitcher)) {
            PerfPrintf("SwitchToNumber(%x): %5.3g",
                       this, numbers[0]);
        }
#endif _DEBUG
    
    } else if (ti == ColorType) {
                
        (SAFE_CAST(Color *, val))->SetRGB(numbers[0] / 255.0,
                                          numbers[1] / 255.0,
                                          numbers[2] / 255.0);
#if _DEBUG
        if(IsTagEnabled(tagSwitcher)) {
            PerfPrintf("SwitchToColor(%x): %5.3g %5.3g %5.3g ",
                       this, numbers[0], numbers[1], numbers[2]);
        }
#endif _DEBUG

    } else if (ti == Point2ValueType) {

        Point2WithCreationSource *pt2 =
            SAFE_CAST(Point2WithCreationSource *, val);

        Real x = numbers[0];
        Real y = numbers[1];
        if (pt2->_createdInPixelMode) {
            x = ::PixelToNum(x);
            y = ::PixelYToNum(y);
        }
        pt2->Set(x, y);

#if _DEBUG
        if(IsTagEnabled(tagSwitcher)) {
            PerfPrintf("SwitchToPoint2(%x): %d %5.3g %5.3g ",
                       this, pt2->_createdInPixelMode, x, y);
        }
#endif _DEBUG

    } else if (ti == Vector2ValueType) {

        Vector2WithCreationSource *vec2 =
            SAFE_CAST(Vector2WithCreationSource *, val);

        Real x = numbers[0];
        Real y = numbers[1];
        if (vec2->_createdInPixelMode) {
            x = ::PixelToNum(x);
            y = ::PixelYToNum(y);
        }
        vec2->Set(x, y);

#if _DEBUG
        if(IsTagEnabled(tagSwitcher)) {
            PerfPrintf("SwitchToVector2(%x): %d %5.3g %5.3g ",
                       this, vec2->_createdInPixelMode, x, y);
        }
#endif _DEBUG
            
    } else if (ti == Point3ValueType) {

        Point3WithCreationSource *pt3 =
            SAFE_CAST(Point3WithCreationSource *, val);

        Real x = numbers[0];
        Real y = numbers[1];
        Real z = numbers[2];
        if (pt3->_createdInPixelMode) {
            x = ::PixelToNum(x);
            y = ::PixelYToNum(y);
            z = ::PixelToNum(z);
        } 
        pt3->Set(x, y, z);

#if _DEBUG
        if(IsTagEnabled(tagSwitcher)) {
            PerfPrintf("SwitchToPoint3(%x): %d %5.3g %5.3g %5.3g ",
                       this, pt3->_createdInPixelMode, x, y, z);
        }
#endif _DEBUG

    } else if (ti == Vector3ValueType) {

        Vector3WithCreationSource *vec3 =
            SAFE_CAST(Vector3WithCreationSource *, val);

        Real x = numbers[0];
        Real y = numbers[1];
        Real z = numbers[2];
        if (vec3->_createdInPixelMode) {
            x = ::PixelToNum(x);
            y = ::PixelYToNum(y);
            z = ::PixelToNum(z);
        } 
        vec3->Set(x, y, z);

#if _DEBUG
        if(IsTagEnabled(tagSwitcher)) {
            PerfPrintf("SwitchToVector3(%x): %d %5.3g %5.3g %5.3g ",
                       this, vec3->_createdInPixelMode, x, y, z);
        }
#endif _DEBUG

    } else if (ti == Transform2Type) {

        Assert(xfType);
            
        Transform2 *xf = SAFE_CAST(Transform2 *, val);

        bool ok = xf->SwitchToNumbers(*xfType,
                                      numbers);
            
        if (!ok) {
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_BAD_SWITCH);
        }

#if _DEBUG
        if(IsTagEnabled(tagSwitcher)) {
            PerfPrintf("SwitchToTransform2(%x): %d %5.3g %5.3g ",
                       this, numbers[0], numbers[1]);
        }
#endif _DEBUG
            
    } else if (ti == Transform3Type) {

        Assert(xfType);
            
        Transform3 *xf = SAFE_CAST(Transform3 *, val);

        bool ok = xf->SwitchToNumbers(*xfType,
                                      numbers);
            
        if (!ok) {
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_BAD_SWITCH);
        }
            
#if _DEBUG
        if(IsTagEnabled(tagSwitcher)) {
            PerfPrintf("SwitchToTransform2(%x): %d %5.3g %5.3g %5.3g ",
                       this, numbers[0], numbers[1], numbers[2]);
        }
#endif _DEBUG
            
    } else {
                
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_BAD_SWITCH);
                
    }

}

Bvr SwitcherBvr(Bvr b, SwitchToParam p /* = SW_DEFAULT */)
{ return NEW SwitcherBvrImpl(b, p); }

void SwitchTo(Bvr s, Bvr b, bool override, SwitchToParam flag, Time gTime)
{
    s->SwitchTo(b, override, flag, gTime);
}

void SwitchToNumbers(Bvr s,
                     Real *numbers,
                     Transform2::Xform2Type *xfType)
{
    s->SwitchToNumbers(numbers, xfType);
}

Bvr GetCurSwitcherBvr(Bvr s)
{ return s->GetCurBvr(); }

bool IsSwitcher(Bvr b)
{ return (b->GetBvrTypeId() == SWITCHER_BTYPEID); }

class SwitcherEndPerfImpl : public PerfImpl {
  public:
    SwitcherEndPerfImpl(Perf base) : _base(base) {}
    
    virtual AxAValue _Sample(Param& p) {
        // the parent may switch my end event
        _sw->Sample(p);
        
        return _base->Sample(p);
    }

    void SwitchEndPerf(Perf p) { _base = p; }
    void SetSwitcherPerf(Perf p) { _sw = p; }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "swEnd(" << _base << ")"; }
#endif
    
    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_base);
        (*proc)(_sw);
    }

  private:
    Perf _base;
    Perf _sw;
};

class SwitcherEndBvrImpl : public DelegatedBvr {
  public:
    SwitcherEndBvrImpl(SwitcherBvrImpl *s, Bvr end)
    : DelegatedBvr(end), _sw(s) {}

    virtual Perf _Perform(PerfParam& p) {
        SwitcherEndPerfImpl *end =
            NEW SwitcherEndPerfImpl(::Perform(_base, p));

        _pcache = end;          // recursion

        end->SetSwitcherPerf(::Perform(_sw, p));

        return end; 
    }

    void SwitchEndEvent(Bvr b) { _base = b; }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "swEnd(" << _base << ")"; }
#endif
    
    virtual void _DoKids(GCFuncObj proc) {
        DelegatedBvr::_DoKids(proc);
        (*proc)(_sw);
    }
        
  private:
    SwitcherBvrImpl *_sw;
};

void
SwitcherBvrImpl::_SwitchTo(Bvr b,
                           bool override,
                           SwitchToParam flag,
                           Time gTime)
{
    UpdateUniqueId();
        
    CritSectGrabber csp(_critSect);
    if (_finalized)
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_FINALIZED_SW);

    _bvr = b;

    EndEvent(NULL);

    _endEvent->SwitchEndEvent(_bvr->EndEvent(NULL));

    // Get the timestamp for this switch, note that it's not the
    // global time.
    _switchTime = GetPerfTickCount();

    if (flag & SW_FINAL)
        _finalized = TRUE;

    if (override)
        _swFlag = flag;
    else
        _swFlag = _dftSwFlag;

    _gTime = gTime;

    TraceTag((tagSwitcher, "SwitchTo(%s 0x%x) 0x%x at %u %d",
              _typeInfo->GetName(), this,
              _bvr, _switchTime, _finalized));
}


Perf
SwitcherBvrImpl::PerformHelper(PerfParam& p)
{
    SwitcherPerfImpl *perf;
    Perf end;

    EndEvent(NULL);         // set _endEvent

    perf = NEW SwitcherPerfImpl(::Perform(_bvr, p),
                                p._t0, p._tt, this);

    // Set the cache to prevent recursion
    _pcache = perf;
                 
    end = ::Perform(_endEvent, p);

    perf->SetEndPerf(SAFE_CAST(SwitcherEndPerfImpl *, end));

    return perf;
}

void
SwitcherBvrImpl::_DoKids(GCFuncObj proc)
{
    // Make sure the call is protected but do not keep the lock
    // while we are garbage collecting
        
    Bvr st = SwitchToBvr();

    if (st) (*proc)(st);

    (*proc)(_typeInfo);

    (*proc)(_endEvent);
}

Bvr
SwitcherBvrImpl::EndEvent(Bvr overrideEvent)
{
    if (_endEvent==NULL) {
        _endEvent =
            NEW SwitcherEndBvrImpl(this, _bvr->EndEvent(overrideEvent));
    }

    return _endEvent;
}
    
SwitcherPerfImpl::SwitcherPerfImpl(Perf init,
                                   Time t0,
                                   TimeXform tt,
                                   SwitcherBvrImpl *parent)
: _curr(init), _t0(t0), _tt(tt), _base(parent), _end(NULL)
{
    _uniqueId = parent->GetUniqueId();
    
    TraceTag((tagSwitcher, "SwitcherPerfImpl(%s 0x%x)",
              _base->GetTypeInfo()->GetName(), this));
}
    
void
SwitcherPerfImpl::_DoKids(GCFuncObj proc)
{
    (*proc)(_curr);
    (*proc)(_tt);
    (*proc)(_base);
    (*proc)(_end);
}

bool
SwitcherPerfImpl::CheckChangeables(CheckChangeablesParam &ccp)
{
    return (_base->GetUniqueId() != _uniqueId);
}

AxAValue
SwitcherPerfImpl::_Sample(Param& p)
{
    long uid = _base->GetUniqueId();
    
    if (uid != _uniqueId) {

        _uniqueId = uid;

        Bvr sw = _base->SwitchToBvr();

        // Yes there is a switch, but SwitchToNumbers don't set a
        // behavior. 

        if (sw) {

            DWORD swTime = _base->SwitchToTimeStamp();
        
            DWORD flag = _base->GetFlag();

            if ((flag & SW_CONTINUE) || (flag & SW_SYNC_LAST)) {
                DWORD lastTime, curTime;
                Time t1;
                
                if (ViewLastSampledTime(lastTime, curTime, t1)) {
                    if (flag & SW_CONTINUE) {
                        PerfParam pp(_t0, _tt, true, lastTime, &p);
                    
                        _curr = ::Perform(sw, pp);
                    
                        _end->SwitchEndPerf(::Perform(sw->EndEvent(NULL),
                                                      pp));
                    } else {
                        // save one timexform creation for const
                        TimeXform tt;

                        if (sw->GetBvrTypeId() == CONST_BTYPEID) {
                            tt = zeroShiftedTimeXform;
                            t1 = 0;
                        } else {
                            tt = Restart(_tt, t1, p);
                        }

                        PerfParam pp(t1, tt);
                
                        _curr = ::Perform(sw, pp);
                    
                        _end->SwitchEndPerf(::Perform(sw->EndEvent(NULL),
                                                      pp));
                    }
                }
            } else {
                bool bDoSwitch = true;
                
                Time startTime;

                if (flag & SW_SYNC_NEXT)
                    startTime = p._time;
                else if (flag & SW_WITH_TIME)
                    startTime = _base->SwitchToGlobalTime();
                else
                {
                    bDoSwitch = _base->GetEstimatedSwitchTime(swTime,
                                                              p._time,
                                                              startTime);
                }

                if (bDoSwitch) {
                    // save one timexform creation for const
                    TimeXform tt;

                    if (sw->GetBvrTypeId() == CONST_BTYPEID) {
                        tt = zeroShiftedTimeXform;
                        startTime = 0;
                    } else {
                        tt = Restart(_tt, startTime, p);
                    }

                    PerfParam pp(startTime, tt);
                
                    _curr = ::Perform(sw, pp);
                    
                    _end->SwitchEndPerf(::Perform(sw->EndEvent(NULL),
                                                  pp));
                }
            }

            ViewEventHappened();

            TraceTag((tagSwitcher, "Switched(%s 0x%x) [0x%x: %u] at [%f]",
                      sw->GetTypeInfo()->GetName(), this,
                      _base, _base->GetFlag(), p._time));
        }
    }
        
    return _curr->Sample(p);
}
    
#if _USE_PRINT
ostream&
SwitcherPerfImpl::Print(ostream& os)
{
    os << "sw(" << _curr;

    long uid = _base->GetUniqueId();

    if (uid != _uniqueId) {
        os << "->" << _base->SwitchToBvr();
    }

    return os << ")";
}
#endif

BOOL IsSwitchOnce(Perf p)
{ return (p->GetBvrTypeId() == SWITCHER_BTYPEID); }

class ImportSwitcherBvrImpl : public SwitcherBvrImpl
{
  public:
    ImportSwitcherBvrImpl(Bvr b, bool bAsync)
    : SwitcherBvrImpl(b, SW_DEFAULT),
      _hr(S_OK),
      _errStr(NULL),
      _bSignaled(false),
      _bAsync(bAsync)
    {
    }
    ~ImportSwitcherBvrImpl() {
        if (!_bSignaled && !_bAsync)
            ViewNotifyImportComplete(this, true);
        
        NotifyBvr();
        
        delete [] _errStr;
    }
    
    void NotifyBvr();
    
    virtual Perf _Perform(PerfParam& p) {
        HRESULT hr = S_OK;
        bool emptyExc = true;
        
        // Do all this in the critsect
        if (!_bAsync)
        {
            CritSectGrabber csp(_critSect);

            if (_bSignaled) {
                hr = _hr;
                if (_hr != S_OK) {
                    emptyExc = false;
                }
            } else {
                // Do this in the critsect so that we do not skip it
                // if the callback is completed while we are
                // processing it
                
                GetCurrentView().AddIncompleteImport(this);
            }
        }
        
        // DO NOT throw the exception in the critsect since that may
        // cause synchronization problems
        
        if (hr != S_OK) {
            if( emptyExc ) {
                RaiseException_UserError();
            } else {
                RaiseException_UserError(hr, IDS_ERR_BE_IMPORTFAILURE, _errStr);
            }
        }

        return SwitcherBvrImpl::_Perform(p);
    }

    virtual void SwitchTo(Bvr b, bool override, SwitchToParam flag,
                          Time gTime) {
        
        __try {
            // Switch first and then signal - order is important
            SwitcherBvrImpl::SwitchTo(b, override, flag, gTime);
        } __except ( HANDLE_ANY_DA_EXCEPTION ) {
            Signal();
            RETHROW;
        }

        Signal();
    }
    
    void SetImportSite(IImportSite * pImport) {Assert(!_ImportSite);
                                              _ImportSite = pImport;}
    IImportSite * GetImportSite(void) {
        CritSectGrabber csp(_critSect);
        if (_ImportSite) {
           _ImportSite->AddRef();
        }
        return _ImportSite;
    }
    void Signal(HRESULT hr = S_OK, char * errStr = NULL);

    virtual Bvr GetCurBvr() {
        CritSectGrabber csp(_critSect);

        if (!_bAsync && !_bSignaled)
            RaiseException_UserError(E_PENDING, IDS_ERR_NOT_READY);

        if (_hr)
            RaiseException_UserError(_hr, IDS_ERR_BE_IMPORTFAILURE, _errStr);

        return SwitcherBvrImpl::GetCurBvr();
    }

    virtual SWITCHER_TYPE GetSwitcherType() { return ST_IMPORT; }
    bool IsImportReady() { return _bSignaled; }
    HRESULT GetStatus() { return _hr; }
  protected:
    HRESULT _hr;
    char * _errStr;
    DAComPtr <IImportSite> _ImportSite;
    bool _bSignaled;
    bool _bAsync;
};

void
ImportSwitcherBvrImpl::NotifyBvr()
{
    DAComPtr <IImportSite> is;
    
    // Do not hold the mutex while calling vBvrIsDying
    // So copy the pointer and the reference count with the critsect,
    // then release the pointer
    {
        CritSectGrabber csp(_critSect);

        is = _ImportSite;

        _ImportSite.Release();
    }

    // tell the import site class that this bvr is dying
    // so all sites associated with it can cleanup...
    if (is)
        is->vBvrIsDying(this);
}
    
void
ImportSwitcherBvrImpl::Signal(HRESULT hr, char * errStr)
{
    bool bFirstSig;
    
    {
        CritSectGrabber csp(_critSect);
    
        bFirstSig = !_bSignaled;
        
        _bSignaled = true;

        if (bFirstSig)
        {
            _hr = hr;
            
            delete _errStr;
            _errStr = CopyString(errStr);
        }
    }

    // Need to do this outside the mutex

    if (!_bAsync && bFirstSig) {
        ViewNotifyImportComplete(this, false);
    }

    // We need to do this to ensure that the import site is
    // release ASAP
        
    NotifyBvr();
}

Bvr SwitchOnceBvr(Bvr b) { return SwitcherBvr(b); }

Bvr ImportSwitcherBvr(Bvr b, bool bAsync)
{ return NEW ImportSwitcherBvrImpl(b,bAsync); }

void
ImportSignal(Bvr b, HRESULT hr, LPCWSTR sz)
{
    USES_CONVERSION;
    ImportSignal(b, hr, W2A(sz));
}

void
ImportSignal(Bvr b, HRESULT hr, char * errStr)
{
    Assert(DYNAMIC_CAST(ImportSwitcherBvrImpl*, b));

    ImportSwitcherBvrImpl *s = SAFE_CAST(ImportSwitcherBvrImpl*,b);

    s->Signal(hr, errStr);
}

void
SetImportOnBvr(IImportSite * import,Bvr b)
{
    if (b != NULL) {
        Assert(DYNAMIC_CAST(ImportSwitcherBvrImpl*, b));

        ImportSwitcherBvrImpl *s = SAFE_CAST(ImportSwitcherBvrImpl*,b);

        s->SetImportSite(import);
    }
}

bool IsImport(Bvr b)
{
    if (!IsSwitcher(b))
        return false;

    SwitcherBvrImpl * s = SAFE_CAST(SwitcherBvrImpl*,b);

    return s->GetSwitcherType() == ST_IMPORT;
}

HRESULT ImportStatus(Bvr b)
{
    HRESULT hr;
    
    Assert(DYNAMIC_CAST(ImportSwitcherBvrImpl*, b));
    
    ImportSwitcherBvrImpl *s = SAFE_CAST(ImportSwitcherBvrImpl*,b);
    if (s->IsImportReady())
    {
        hr = s->GetStatus();
    }
    else
    {
        hr = E_PENDING;
    }

    return hr;
}

IImportSite * GetImportSite(Bvr b)
{
    IImportSite * preturn = NULL;
    if (b != NULL) {
        Assert(DYNAMIC_CAST(ImportSwitcherBvrImpl*, b));

        ImportSwitcherBvrImpl *s = SAFE_CAST(ImportSwitcherBvrImpl*,b);
        preturn = s->GetImportSite();

    }
    return preturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\timeline.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of timeline

*******************************************************************************/

#include <headers.h>
#include "events.h"
#include "gc.h"
#include "jaxaimpl.h"
#include "appelles/events.h"
#include "appelles/axaprims.h"
#include "appelles/arith.h"
#include "appelles/path2.h"
#include "timeln.h"
#include "privinc/debug.h"
#include "timetran.h"

DeclareTag(tagSoundRepeat, "Sound", "Repeat2Loop Transform");

extern AxAPrimOp *RealAddOp, *RealMultiplyOp, *RealSubtractOp, *RealDivideOp,
    //*Path2TransformOp, *Point2AtPath2Op,
    *ThetaCoordVector2Op, *RotateRealOp, *ScaleRealRealOp, *RealFloorOp,
    *RealEQOp, *RealLTOp, *RealModulusOp, *RealGTEOp,
    *BoolOrOp, *TimesTransform2Transform2Op;

extern AxANumber *Interpolate(AxANumber *from,
                              AxANumber *to,
                              AxANumber *duration,
                              AxANumber *t);

extern AxANumber *SlowInSlowOut(AxANumber *from,
                                AxANumber *to,
                                AxANumber *duration,
                                AxANumber *sharpness,
                                AxANumber *t);

extern Bvr ApplyLooping(Bvr snd);

inline Bvr Timer(double duration)
{ return TimerEvent(NumToBvr(duration)); }

inline Bvr Minus(Bvr a, Bvr b)
{ return PrimApplyBvr(RealSubtractOp, 2, a, b); }

inline Bvr TimeMinus(Bvr t)
{ return Minus(TimeBvr(), t); }

inline Bvr TimeLT(Bvr t)
{ return PrimApplyBvr(RealLTOp, 2, TimeBvr(), t); }

inline Bvr Mod(Bvr a, Bvr b)
{ return PrimApplyBvr(RealModulusOp, 2, a, b); }

inline Bvr TimeMod(Bvr m)
{ return Mod(TimeBvr(), m); }

inline Bvr Times(Bvr a, Bvr b)
{ return PrimApplyBvr(RealMultiplyOp, 2, a, b); }

inline Bvr GTE(Bvr a, Bvr b)
{ return PrimApplyBvr(RealGTEOp, 2, a, b); }

static Bvr GetPathAngle(Bvr path, Bvr eval)
{
    // TODO: share
    AxAPrimOp *Point2AtPath2Op =
        ValPrimOp(Point2AtPath2, 2, "Point2AtPath2", Point2ValueType);

    return
        PrimApplyBvr(ThetaCoordVector2Op, 1,
                     DerivPoint2(PrimApplyBvr(Point2AtPath2Op, 2,
                                              path, eval)));

}

class DurationTimeXformImpl : public TimeXformImpl {
  public:
    DurationTimeXformImpl(TimeXform tt, Perf d) : _tt(tt), _duration(d) {}
    
    virtual Time operator()(Param& p) {
        double t = (*_tt)(p);
        double d = ValNumber(_duration->Sample(p));

        return CLAMP(t, 0, d);
    }

    // Restart optimization.
    virtual TimeXform Restart(Time t0, Param& p) {
        return NEW DurationTimeXformImpl(_tt->Restart(t0, p), _duration);
    }

    virtual Time GetStartedTime() { return _tt->GetStartedTime(); }

    // The sound layer needs to distinguish the "interesting"
    // transforms. 
    virtual bool IsShiftXform() { return _tt->IsShiftXform(); }

    virtual AxAValue GetRBConst(RBConstParam& p) {
        AxAValue v = _tt->GetRBConst(p);
        AxAValue dv = _duration->GetRBConst(p);

        if (v && dv) {
            double t = ValNumber(v);
            double d = ValNumber(dv);

            return NEW AxANumber(CLAMP(t, 0, d));
        }

        return NULL;
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_tt);
        (*proc)(_duration);
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    {
        os << "dtt(";
        _tt->Print(os);
        return os << "," << _duration << ")";
    }
#endif
    
  private:
    TimeXform _tt;
    Perf _duration;
};

class EndBvrImpl : public BvrImpl {
  public:
    EndBvrImpl(Bvr raw, Bvr end)
    : _end(end), _raw(raw), _bvr(NULL), _ubvr(NULL), _usePure(false),
      _duration(NULL) {} 

    virtual Bvr EndEvent(Bvr) {
        return _end;
    }

    virtual DWORD GetInfo(bool recalc) {
        Time duration;

        DWORD f = _raw->GetInfo(recalc);

        Bvr timer = _end->GetTimer();
        
        if (timer && BvrIsPure1(timer))
            return f;
        else
            return ~BVR_HAS_NO_UNTIL & f;
    }
    
    virtual Perf _Perform(PerfParam& p) {
        if ((_bvr==NULL) && (_duration==NULL)) {
            bool doPure = true; // GREGSC: made true by default

#if _DEBUG
            if(IsTagEnabled(tagPureFunc))
                doPure = false;
#endif _DEBUG

            _duration = _end->GetTimer();
            
            // "pure" function, use cond so we can seek backward,
            // etc. 
            if (doPure && _duration && BvrIsPure1(_raw)) {
                _usePure = true;
            } else {
                _ubvr = _bvr = Until(_raw, SnapshotEvent(_end, _raw));
            }
        }

        if (p._tt->IsShiftXform()) {
            if (_ubvr == NULL)
                _ubvr = Until(_raw, SnapshotEvent(_end, _raw));

            return ::Perform(_ubvr, p);
        } else {
            _usePure = _duration != NULL;
        }

        if (_usePure) {
            Perf d = ::Perform(_duration, p);
            TimeXform tt = NEW DurationTimeXformImpl(p._tt, d);

            PerfParam pp = p;
            pp._tt = tt;

            return ::Perform(_raw, pp);
        } else {
            Assert(_bvr);
            return ::Perform(_bvr, p);
        }
    }

    virtual Bvr GetRaw() { return _raw; }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_raw);
        (*proc)(_end);
        (*proc)(_bvr);
        (*proc)(_ubvr);
        (*proc)(_duration);
    }

    virtual DXMTypeInfo GetTypeInfo() { return _raw->GetTypeInfo(); }

#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "duration(" << _raw << "," << _end << ")"; }
#endif
    
  private:
    Bvr _raw;
    Bvr _end;
    Bvr _bvr, _ubvr;
    Bvr _duration;
    bool _usePure;
};

Bvr EndBvr(Bvr b, Bvr endEvent)
{ return NEW EndBvrImpl(b, endEvent); }

Bvr DurationBvr(Bvr b, Bvr duration)
{
    ConstParam cp;
    AxAValue v = duration->GetConst(cp);

    // Check for infinity case 
    if (v && (ValNumber(v) == HUGE_VAL)) {
        if (b->EndEvent(NULL) == neverBvr)
            return b;
        else
            return EndBvr(b, neverBvr);
    }

    /*
    Bvr timer = b->GetTimer();

    AxAValue d = timer ? timer->GetConst(cp) : NULL;

    // Same duration, optimize it out...
    if (d && v && (ValNumber(d) == ValNumber(v)))
        return b;
        */
    
    return EndBvr(b, TimerEvent(duration));
}

class SequenceBvrImpl : public BvrImpl {
  public:
    SequenceBvrImpl(Bvr *s, int n)
    : _s(s), _n(n), _cache(NULL), _ucache(NULL), _end(NULL) {
        Assert(s && n>1);

        GetInfo(true);

        DoCache(true);
    }

    virtual bool IsSequence() { return true; }

    int Size() { return _n; }
    Bvr Nth(int i) { return _s[i]; }

    void DoCache(bool doPure) {
        if (doPure && CheckPure())
            CacheCond();
        else
            _ucache = CacheUntil(doPure);
    }

    virtual DWORD GetInfo(bool recalc) {
        if (recalc) {
            _info = _s[0]->GetInfo(recalc);

            for (int i=1; i<_n; i++) {
                _info &= _s[i]->GetInfo(recalc);
            }
        }

        return _info;
    }
    
    virtual Perf _Perform(PerfParam& p) {
        
        if (p._tt->IsShiftXform()) {
            if (_ucache == NULL)
                DoCache(false);

            return ::Perform(_ucache, p);
        }
        
        
        return ::Perform(_cache, p);
    }

    virtual Bvr EndEvent(Bvr overrideEvent) {
        // Just use one of them since we always override the actual
        // endevent and all we care about is creating the correct type
        // structure
        return _end;
        //return _s1->EndEvent(overrideEvent?overrideEvent:_end);
    }

    virtual void _DoKids(GCFuncObj proc) {
        for (int i=0; i<_n; i++) {
            (*proc)(_s[i]);
        }

        (*proc)(_cache);
        (*proc)(_ucache);
        (*proc)(_end);
    }

    virtual DXMTypeInfo GetTypeInfo() { return _s[0]->GetTypeInfo(); }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        os << "seq(";
        for (int i=0; i<_n; i++) {
            os << _s[i] << ((i==_n-1) ? ")" : ", ");
        }
        return os;
    }
#endif
    
  private:
    Bvr CacheUntil(bool doPure) {
        _cache = _s[_n-1];
        if (doPure)
            _end = _cache->EndEvent(NULL);

        for (int i=_n-2; i>=0; i--) {
            Bvr s = _s[i];
            Bvr ev = s->EndEvent(NULL);
            _cache = Until3(s->GetRaw(), ev, _cache);
            if (doPure) 
                _end = ThenEvent(ev, _end);
        }

        return _cache;
    }

    bool CheckPure() {
        bool doPure = true;     // GREGSC: made true by default

#if _DEBUG
    if(IsTagEnabled(tagPureFunc))
        doPure = false;
#endif _DEBUG

        if (!doPure)
            return false;

        for (int i=0; i<_n-1; i++) {
            //BvrIsPure1(_s[i]) &&
            if (!_s[i]->EndEvent(NULL)->GetTimer()) {
                return false;
            }
        }

        return true;
    }

    Bvr BuildCond(Bvr d, int i, bool init = false) {
        Bvr curr = _s[i];

        Bvr e = curr->EndEvent(NULL);

        Bvr raw = curr->GetRaw();

        Bvr accum = NULL;

        Bvr t = e->GetTimer();

        if (t) {
            accum = init ? t : PrimApplyBvr(RealAddOp, 2, d, t);
        }

        if (i==_n-1) {
            if (t) {
                _end = TimerEvent(accum);
            } else if (e == neverBvr) {
                _end = neverBvr;
            } else {
                _end = ThenEvent(TimerEvent(d), e);
            }
            
            return TimeXformBvr(curr, TimeMinus(d));
        } else {
            return CondBvr(TimeLT(accum),
                           init ? raw : TimeXformBvr(raw, TimeMinus(d)),
                           BuildCond(accum, i+1));
        }
    }

    void CacheCond() {
        _cache = BuildCond(NULL, 0, true);
    }

    Bvr _cache, _ucache, _end;
    Bvr *_s;
    int _n;
    DWORD _info;
};

int
SequenceSize(Bvr s, SequenceBvrImpl * &sp)
{
    if (s->IsSequence()) {
        Assert(DYNAMIC_CAST(SequenceBvrImpl*, s));
        sp = SAFE_CAST(SequenceBvrImpl *, s);
        return sp->Size();
    } else {
        return 1;
    }
}

void
FillSequence(Bvr* copy, int& i, Bvr s, SequenceBvrImpl *sp)
{
    if (sp) {
        for (int k=0; k<sp->Size(); k++) {
            copy[i++] = sp->Nth(k);
        }
    } else {
        copy[i++] = s;
    }
}

Bvr
Sequence(int n, Bvr *bs)
{
    Assert(n > 0);

    if (n==1) {
        return bs[0];
    }

    SequenceBvrImpl **sp = 
        (SequenceBvrImpl**) _alloca(sizeof(SequenceBvrImpl*) * n);
    int i = 0;
    int sz = 0;

    for (i=0; i<n; i++) {
        sp[i] = NULL;
        sz += SequenceSize(bs[i], sp[i]);
    }

    Bvr *copy = (Bvr *) StoreAllocate(GetSystemHeap(), sizeof(Bvr) * sz);

    int k = 0;                  // consolidated index
    for (i=0; i<n; i++) {
        FillSequence(copy, k, bs[i], sp[i]);
    }

    Assert(k == sz);
    
    return NEW SequenceBvrImpl(copy, sz);
}

Bvr
Sequence(Bvr s1, Bvr s2)
{
    Bvr bs[] = {s1, s2};

    return ::Sequence(2, bs);
}

//
// start t = localtime
// in
//   f(r, d, x) = r.st(t % d) / ss( (t-x) >= d, t - t % d) => f(r, d, edata)
//
Bvr RepeatDuration(Bvr raw, Bvr d, Bvr offset, Bvr time);

class RepeatOffsetNotifier : public UntilNotifierImpl {
  public:
    RepeatOffsetNotifier(Bvr b, Bvr d, Bvr t) : _bvr(b), _d(d), _time(t) {}

    virtual Bvr Notify(Bvr offset, Bvr curRunningBvr) {
        return RepeatDuration(_bvr, _d, offset, _time);
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_bvr);
        (*proc)(_d);
        (*proc)(_time);
    }

  private:
    Bvr _bvr, _d, _time;
};

Bvr
RepeatDuration(Bvr raw, Bvr d, Bvr offset, Bvr rtime)
{
    Bvr pred = PredicateEvent(GTE(Minus(rtime, offset), d));

    Bvr ss = Minus(rtime, Mod(rtime, d));
        
    return Until(raw, 
                 NotifyEvent(SnapshotEvent(pred, ss),
                             NEW RepeatOffsetNotifier(raw, d, rtime)));
}

class RepeatDurationBvrImpl : public BvrImpl {
  public:
    RepeatDurationBvrImpl(Bvr raw, Bvr duration)
    : _raw(raw), _duration(duration) {}
    
    virtual Perf _Perform(PerfParam& p) {
        Bvr t = AnchorBvr(TimeBvr());

        Bvr b = _raw;

        if (!p._tt->IsShiftXform()) {
            b = TimeXformBvr(_raw, Mod(t, _duration));
        }

        Bvr result = RepeatDuration(b, _duration, NumToBvr(0), t);

        return ::Perform(result, p);
    }
    
    virtual DXMTypeInfo GetTypeInfo() { return _raw->GetTypeInfo(); }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_raw);
        (*proc)(_duration);
    }
    
  private:
    Bvr _raw, _duration;
};

class RepeatNotifier : public UntilNotifierImpl {
  public:
    RepeatNotifier(Bvr b, Bvr ev, long n, Bvr trigger)
    : _bvr(b), _event(ev), _n(n), _trigger(trigger) { }
    
    virtual Bvr Notify(Bvr eventData, Bvr curRunningBvr) {
        if (_n == 0) {
            TriggerEvent(_trigger, TrivialBvr(), false);
            return curRunningBvr;
        } else {
            return Until(_bvr,
                         NotifyEvent(_event,
                                     NEW RepeatNotifier(_bvr, _event,
                                                        _n-1, _trigger)));
        }
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_bvr);
        (*proc)(_event);
        (*proc)(_trigger);
    }

  private:
    Bvr _bvr, _event, _trigger;
    long _n;
};

Bvr RepeatUsingUntil(Bvr raw, Bvr ev, int n, bool forever)
{
    Bvr d = ev->GetTimer();

    if (d) {
        Bvr r = NEW RepeatDurationBvrImpl(raw, d);

        if (forever)
            return r;
        else
            return EndBvr(r, TimerEvent(Times(d, NumToBvr(n))));
    }
    
    if (forever) {
        Bvr loop = InitBvr(raw->GetTypeInfo());

        // TODO: The EndEvent of Init should do some caching to prevent
        // infinite loop.
        SetInitBvr(loop, Until3(raw, ev, loop));

        return loop;
    } else {
        if (n==1)
            return EndBvr(raw, ev);

        Bvr trigger = AppTriggeredEvent();
    
        return
            EndBvr(Until(raw,
                         NotifyEvent(ev,
                                     NEW RepeatNotifier(raw, ev, n-1, trigger))),
                   trigger);
    }
}

Bvr RepeatUsingCond(Bvr raw, Bvr d, int n, bool forever)
{
    Bvr repeat = TimeMod(d);

    Bvr result;
    
    if (forever) {
            
        result = TimeXformBvr(raw, repeat);
            
    } else {

        // Not-forever
        Bvr totalDuration = Times(d, NumToBvr(n));
        repeat = CondBvr(TimeLT(totalDuration), repeat, d);
        Bvr endEvent = TimerEvent(totalDuration);
        Bvr nonEnding = TimeXformBvr(raw, repeat);
        result = EndBvr(nonEnding, endEvent);
            
    }

    return result;
}

Bvr
SoundLoopOptimization(Bvr s, long n, bool forever)
{
    if (forever && s->GetTypeInfo() == SoundType) {
        bool ok = false;
        Bvr b = s;

        while (b->GetBvrTypeId()==SWITCHER_BTYPEID) {
            if (IsImport(b)) {
                ok = true;
                break;
            }
        
            if (b->IsFinalized()) {
                b = b->GetCurBvr();
            } else {
                break;
            }
        }

        if (b->GetBvrTypeId()==SOUND_BTYPEID)
            ok = true;

        if (ok) {
            TraceTag((tagSoundRepeat,
                      "Sound RepeatForever -> Loop %x", s));                 
            return ApplyLooping(s);
        }
    }
    
    return NULL;
}

class RepeatBvrImpl : public BvrImpl {
  public:
    RepeatBvrImpl(Bvr raw, Bvr d, int n, bool forever)
    : _raw(raw), _d(d), _forever(forever), _end(NULL), _n(n) {
        if (!forever)
            _end = TimerEvent(Times(_d, NumToBvr(n)));
    }

    virtual Bvr EndEvent(Bvr) {
        return _forever ? neverBvr : _end;
    }
    
    virtual DWORD GetInfo(bool recalc) {
        DWORD f = _raw->GetInfo(recalc);

        if (BvrIsPure1(_d))
            return f;
        else
            return ~BVR_HAS_NO_UNTIL & f;
    }
    
    virtual Perf _Perform(PerfParam& p) {
        Bvr b = SoundLoopOptimization(_raw, _n, _forever);

        if (b==NULL) {
            if (p._tt->IsShiftXform()) 
                b = RepeatUsingUntil(_raw, TimerEvent(_d), _n, _forever);
            else
                b = RepeatUsingCond(_raw, _d, _n, _forever);
        }

        return ::Perform(b, p);
    }
    
    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_raw);
        (*proc)(_d);
        (*proc)(_end);
    }

    virtual DXMTypeInfo GetTypeInfo() { return _raw->GetTypeInfo(); }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        os << "repeat";
        if (_forever)
            os << "Forever(";
        else {
            os << "(" << _n << ",";
        }

        return os << _raw << "," << _d << ")";
    }
#endif
    
  private:
    Bvr _raw;
    Bvr _end;
    Bvr _d;
    int _n;
    bool _forever;
};

Bvr RepeatPure(Bvr b, long n, bool forever = false)
{
    Bvr s = SoundLoopOptimization(b, n, forever);

    if (s)
        return s;
    
    Bvr ev = b->EndEvent(NULL);

    if (ev == neverBvr)
        return b;

    bool doPure = true;         

#if _DEBUG
    if(IsTagEnabled(tagPureFunc))
        doPure = false;
#endif _DEBUG

    if (!doPure)
        return NULL;
        
    Bvr raw = b->GetRaw();
    Bvr d = ev->GetTimer();

    if (d) {
        if (BvrIsPure(raw)) {
            return RepeatUsingCond(raw, d, n, forever);
        } else {
            return NEW RepeatBvrImpl(raw, d, n, forever);
        }
    }

    return NULL;
}

Bvr Repeat(Bvr b, long n)
{
    // TODO: should be user error
    Assert(n > 0);

    Bvr x = RepeatPure(b, n);

    if (x)
        return x;

    Bvr ev = b->EndEvent(NULL);

    return RepeatUsingUntil(b->GetRaw(), ev, n, false);
}

Bvr RepeatForever(Bvr b)
{
    Bvr x = RepeatPure(b, 0, true);

    if (x)
        return x;

    return RepeatUsingUntil(b->GetRaw(), b->EndEvent(NULL), 0, true);
}

Bvr ScaleDurationBvr(Bvr b, Bvr scaleFactor)
{ 
    return TimeXformBvr(b, Times(TimeBvr(), scaleFactor));
}

Bvr FollowPathEval(Bvr path2, Bvr eval)
{
    // TODO: share
    AxAPrimOp *Path2TransformOp =
        ValPrimOp(Path2Transform, 2, "Path2Transform", Transform2Type);

    return PrimApplyBvr(Path2TransformOp, 2, path2, eval);
}

inline Bvr NormalizeTime(Bvr duration)
{
    return PrimApplyBvr(RealDivideOp, 2, TimeBvr(), duration);
}

inline Bvr Compose(Bvr x1, Bvr x2)
{
    return PrimApplyBvr(TimesTransform2Transform2Op, 2, x1, x2);
}

Bvr FollowPath(Bvr path2, double duration)
{
    Bvr d = NumToBvr(duration);
    
    return DurationBvr(FollowPathEval(path2, NormalizeTime(d)), d);
}

Bvr FollowPathAngleEval(Bvr path, Bvr eval)
{
    Bvr angle = GetPathAngle(path, eval);
    return Compose(FollowPathEval(path, eval),
                   PrimApplyBvr(RotateRealOp, 1, angle));
}

Bvr FollowPathAngle(Bvr path2, double duration)
{
    Bvr d = NumToBvr(duration);
    
    return DurationBvr(FollowPathAngleEval(path2, NormalizeTime(d)), d);
}

Bvr FollowPathAngleUprightEval(Bvr path, Bvr eval)
{
    Bvr angle = GetPathAngle(path, eval);
    Bvr quadrant =
        PrimApplyBvr(RealFloorOp, 1,
                     PrimApplyBvr(RealDivideOp, 2,
                                  angle, NumToBvr(pi / 2.0)));

    Bvr b0 = zeroBvr;
    Bvr b1 = oneBvr;
    Bvr bn1 = negOneBvr;

    return
        Compose(FollowPathEval(path, eval),
                CondBvr(PrimApplyBvr(BoolOrOp, 2,
                                     PrimApplyBvr(RealEQOp, 2, quadrant, b0),
                                     PrimApplyBvr(RealEQOp, 2, quadrant, bn1)),
                        PrimApplyBvr(RotateRealOp, 1, angle),
                        Compose(PrimApplyBvr(RotateRealOp, 1, angle),
                                PrimApplyBvr(ScaleRealRealOp, 2, b1, bn1))));
}

Bvr FollowPathAngleUpright(Bvr path2, double duration)
{
    Bvr d = NumToBvr(duration);
    
    return DurationBvr(FollowPathAngleUprightEval(path2, NormalizeTime(d)), d);
}

Bvr InterpolateBvr(Bvr from, Bvr to, Bvr duration)
{
    // TODO: share
    AxAPrimOp *InterpolateOp =
        ValPrimOp(Interpolate, 4, "Interpolate", AxANumberType);

    return DurationBvr(PrimApplyBvr(InterpolateOp, 4,
                                    from, to, duration, TimeBvr()),
                       duration);
}

Bvr SlowInSlowOutBvr(Bvr from, Bvr to, Bvr duration, Bvr sharpness)
{
    // TODO: share
    AxAPrimOp *SlowInSlowOutOp =
        ValPrimOp(SlowInSlowOut, 5, "SlowInSlowOut", AxANumberType);

    return DurationBvr(PrimApplyBvr(SlowInSlowOutOp, 5,
                                    from, to, duration, sharpness, TimeBvr()),
                       duration);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\timeln.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    DA Express Timeline interface (engine)

*******************************************************************************/


#ifndef _TIMELINE_H
#define _TIMELINE_H

#include "bvr.h"

Bvr DurationBvr(Bvr b, Bvr duration);

Bvr Sequence(Bvr s1, Bvr s2);

Bvr Sequence(int n, Bvr *bs);

Bvr Repeat(Bvr b, long n);

Bvr RepeatForever(Bvr b);

Bvr ScaleDurationBvr(Bvr durBvr, Bvr scaleFactor);

//Bvr ReverseBvr(Bvr b);

Bvr MotionTransform2(Bvr path2, Bvr duration);

Bvr AngleMotionTransform2(Bvr path2, Bvr duration);

Bvr UprightAngleMotionTransform2(Bvr path2, Bvr duration);

Bvr InterpolateBvr(Bvr from, Bvr to, Bvr duration);

Bvr SlowInSlowOutBvr(Bvr from, Bvr to, Bvr duration, Bvr sharpness);

#endif /* _TIMELINE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\timelni.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Internal Timeline interface

*******************************************************************************/


#ifndef _TIMELNI_H
#define _TIMELNI_H

#include "timeln.h"

class TimelineImpl : public GCObj {
  public:
    TimelineImpl(Bvr b, double duration, bool preCompute = TRUE);

    TimelineImpl(Bvr b)
    : _isInfinite(TRUE), _duration(0.0), _rawBvr(b), _bvr(b) {}

    Bvr GetBvr() { return _bvr; }
    Bvr GetRawBvr() { return _rawBvr; }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_bvr);
        (*proc)(_rawBvr);
    }

    bool Duration(double& duration) {
        if (_isInfinite)
            duration = _duration;
        return _isInfinite;
    }

  private:
    Bvr _bvr;
    Bvr _rawBvr;
    bool _isInfinite;
    double _duration;
};

#endif /* _TIMELNI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\timetran.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Time Transform

*******************************************************************************/

#include <headers.h>
#include "values.h"
#include "timetran.h"
#include "bvr.h"
#include "perf.h"
#include "appelles/axaprims.h"
#include "privinc/debug.h"

extern const char TIMEXFORM[] = "timeXform";

TimeXform Restart(TimeXform tt, Time t0, Param& p)
{ return tt->Restart(t0, p); }

class ShiftTimeXformImpl : public TimeXformImpl {
  public:
    ShiftTimeXformImpl(Time t0) : _t0(t0) {}

    Time operator()(Param& p) {
        return p._time - _t0;
    }

    TimeXform Restart(Time te, Param&)
    {
        // this causes trouble in multi-view case
        /*
        TimeXform result;
        if (te == 0.0) {
            result = zeroShiftedTimeXform;
        } else {
            result = NEW ShiftTimeXformImpl(te);
        }

        return result;
        */

        return NEW ShiftTimeXformImpl(te);
    }

    virtual void DoKids(GCFuncObj proc) {}

    virtual bool IsShiftXform() { return true; }
    
    virtual Time GetStartedTime() { return _t0; }

#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "stt(" << _t0 << ")"; }
#endif
    
  private:
    Time _t0;
};

TimeXform ShiftTimeXform(Time t0)
{ return NEW ShiftTimeXformImpl(t0); }

// Substitute time
class PerfTimeXformImpl : public TimeXformImpl {
  public:
    PerfTimeXformImpl(Perf perf, Bvr bvr, Time t0, TimeXform tt)
    : _perf(perf), _bvr(bvr), _t0(t0), _tt(tt) {}

    Time operator()(Param& p) { return ValNumber(_perf->Sample(p)); }

    // Restart _bvr as well...
    TimeXform Restart(Time te, Param& p) {
        return NEW PerfTimeXformImpl(
            ::Perform(_bvr, PerfParam(te, ::Restart(_tt, te, p))),
            _bvr, te, _tt);
    }
    
    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_perf);
        (*proc)(_bvr);
        (*proc)(_tt);
    }

    virtual Time GetStartedTime() { return _t0; }

    virtual AxAValue GetRBConst(RBConstParam& id)
    { return _perf->GetRBConst(id); }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "tt(" << _perf << ")"; }
#endif
    
  private:
    Perf _perf;
    Bvr _bvr;
    TimeXform _tt;
    Time _t0;
};

////////////////////////// TimeXform Bvr ////////////////////////////////

class TimeXformPerfImpl : public GCBase2<Perf, PerfImpl, TIMEXFORM> {
  public:
    TimeXformPerfImpl(Perf p, Perf t)
    : GCBase2<Perf, PerfImpl, TIMEXFORM>(p, t) {}

    virtual AxAValue _GetRBConst(RBConstParam& p) {
        AxAValue t = _b2->GetRBConst(p);
        AxAValue v = _b1->GetRBConst(p);

        if (v) {
            // TODO: not quite sure
            return v;
        }

        if (t) {
            return Sample(p.GetParam());
        }

        return NULL;
    }
    
    virtual AxAValue _Sample(Param& p) {
        p.PushTimeSubstitution(_b2);
        AxAValue v = _b1->Sample(p);
        p.PopTimeSubstitution();
        return v;
    }
};
        

class TimeXformBvrImpl : public GCBase2<Bvr, BvrImpl, TIMEXFORM> {
  public:
    TimeXformBvrImpl(Bvr bvr, Bvr tbvr)
    : GCBase2<Bvr, BvrImpl, TIMEXFORM>(bvr, tbvr) {}

    virtual RMImpl *Spritify(PerfParam& pp,
                             SpriteCtx* ctx,
                             SpriteNode** sNodeOut) {
        return(_b1->Spritify(PerfParam(pp._t0,
                                       NEW PerfTimeXformImpl(::Perform(_b2, pp),
                                                             _b2, pp._t0, pp._tt)), 
                             ctx, sNodeOut));
    }

    virtual Bvr EndEvent(Bvr overrideEvent) {
        return TimeXformBvr(_b1->EndEvent(overrideEvent), _b2);
    }
    
    virtual Perf _Perform(PerfParam& p) {
#ifdef _DEBUG
        if (IsTagEnabled(tagOldTimeXform)) {
            if (p._tt->IsShiftXform()) {
                // this breaks the perf cache, needed for in/out hook...
                TimeXform tt = ShiftTimeXform(p._tt->GetStartedTime());
                return NEW
                    TimeXformPerfImpl(::Perform(_b1, PerfParam(p._t0, tt)),
                                      ::Perform(_b2, p));
            } else {
                return NEW TimeXformPerfImpl(::Perform(_b1, p),
                                             ::Perform(_b2, p));
            }
        }
#endif _DEBUG

        Perf perf = ::Perform(_b2, p);

        PerfTimeXformImpl *xform = ViewGetPerfTimeXformFromCache(perf);

        if (xform==NULL) {
            xform = NEW PerfTimeXformImpl(perf, _b2, p._t0, p._tt);
            ViewSetPerfTimeXformCache(perf, xform);
        }
       
        PerfParam pp = p;

        pp._tt = xform;

        // xform can be a runOnce xform that ignores t0
        pp._t0 = xform->GetStartedTime();

        return ::Perform(_b1, pp);
    }

    // TODO: Constant folding when tbvr is constant

    virtual DXMTypeInfo GetTypeInfo () { return _b1->GetTypeInfo(); }
};

Bvr TimeXformBvr(Bvr b, Bvr tb)
{
#if _DEBUG
    if (!IsTagEnabled(tagNoTimeXformFolding)) {
#endif
        DynamicHeapPusher h(GetGCHeap());

        // NOTE: Can be called from sample, we have to push the GCHeap
        // to make sure.
        //Assert(&GetHeapOnTopOfStack() == &GetGCHeap());

        ConstParam cp;
        AxAValue v = b->GetConst(cp);

        if (v)
            return ConstBvr(v);

        v = tb->GetConst(cp);
        
        if (v && BvrIsPure(b)) {
            Perf pf = Perform(b, *zeroStartedPerfParam);

            Param p(ValNumber(v));

            p._noHook = true;

            return ConstBvr(pf->Sample(p));
        }
#if _DEBUG
    }
#endif
    
    return NEW TimeXformBvrImpl(b, tb);
}

void TimeSubstitutionImpl::DoKids(GCFuncObj proc)
{
    (*proc)(_perf);
    (*proc)(_next);
}

TimeSubstitution CopyTimeSubstitution(TimeSubstitution p)
{
    if (p==NULL)
        return NULL;

    TimeSubstitution result = NEW TimeSubstitutionImpl(p->GetPerf());
    TimeSubstitution t = result;
    p = p->GetNext();

    while (p != NULL) {
        t->SetNext(NEW TimeSubstitutionImpl(p->GetPerf()));
        t = t->GetNext();
        p = p->GetNext();
    }

    t->SetNext(NULL);
    return result;
}

double
EvalLocalTime(TimeSubstitution tSub, double globalTime)
{
    Assert(tSub);
    
    Param p(globalTime, tSub);

    TimeSubstitution ts = p.PopTimeSubstitution();

    Assert(ts->GetPerf());
    AxAValue v = ts->GetPerf()->Sample(p);
    p.PushTimeSubstitution(ts); // restore TimeSubstitution
    return ValNumber(v);
}

double
EvalLocalTime(Param& p, TimeXform tt)
{
    TimeSubstitution ts = p.PopTimeSubstitution();

    if (ts == NULL)
        return (*tt)(p);
    else {
        Assert(ts->GetPerf());
        AxAValue v = ts->GetPerf()->Sample(p);
        p.PushTimeSubstitution(ts);
        return ValNumber(v);
    }
}

double
EvalLocalTime(TimeXform tt, double globalTime)
{
    Param p(globalTime);
    
    return (*tt)(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\values.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Basic values definitions

*******************************************************************************/


#ifndef _VALUES_H
#define _VALUES_H

#include "privinc/storeobj.h"
#include "privinc/basic.h"

#include "gc.h"

enum CR_BVR_TYPEID;

class DXMTypeInfoImpl : public GCObj {
  public:
    DXMTypeInfoImpl(DATYPEID type, const char * name, CR_BVR_TYPEID crtypeid)
    : _type(type), _name(name), _crtypeid(crtypeid) {}

    DATYPEID GetTypeInfo() { return _type; }
    const char * GetName() { return _name; }
    CR_BVR_TYPEID GetCRTypeId() { return _crtypeid; }
    
    virtual BOOL Equal(DXMTypeInfo x) {
        Assert(x);
        return _type == x->GetTypeInfo();
    }

    virtual void DoKids(GCFuncObj proc) { }
    
  protected:
    DATYPEID _type;
    const char * _name;
    CR_BVR_TYPEID _crtypeid;
};

inline DATYPEID GetTypeInfo(DXMTypeInfo type)
{ return type->GetTypeInfo(); }

inline const char * GetTypeInfoName(DXMTypeInfo type)
{ return type->GetName(); }

inline CR_BVR_TYPEID GetCRTypeId(DXMTypeInfo type)
{ return type->GetCRTypeId(); }

DXMTypeInfo GetArrayTypeInfo(DXMTypeInfo b);
DXMTypeInfo *GetTupleTypeInfo(DXMTypeInfo b, long *n);

#if _USE_PRINT
ostream& operator<<(ostream& s, AxAValue v);
#endif

inline BOOL BooleanTrue(AxAValue v)
{
    Assert(DYNAMIC_CAST(AxABoolean *, v) != NULL);
    
    return ((AxABoolean*) v)->GetBool();
}

inline double ValNumber(AxAValue v)
{
    Assert(DYNAMIC_CAST(AxANumber *, v) != NULL);
    
    return ((AxANumber *) v)->GetNum();
}

inline WideString ValString(AxAValue v)
{
    Assert(DYNAMIC_CAST(AxAString *, v) != NULL);
    
    return ((AxAString *) v)->GetStr();
}

inline AxAPair *ValPair(AxAValue v)
{
    Assert(DYNAMIC_CAST(AxAPair *, v) != NULL);
    
    return ((AxAPair*) v);
}

#endif /* _VALUES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\timetran.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    TimeXform header

*******************************************************************************/


#ifndef _TIMETRAN_H
#define _TIMETRAN_H

#include "gc.h"
#include "privinc/backend.h"
#include "perf.h"

class ATL_NO_VTABLE TimeXformImpl : public GCObj
{
  public:
    virtual Time operator()(Param& p) = 0;

    // Restart optimization.
    virtual TimeXform Restart(Time t0, Param&) = 0;

    virtual Time GetStartedTime() = 0;

    // The sound layer needs to distinguish the "interesting"
    // transforms. 
    virtual bool IsShiftXform() { return false; }

    virtual AxAValue GetRBConst(RBConstParam&) { return NULL; }
};

// Creates a time transform  (t - t0)
TimeXform ShiftTimeXform(Time t0);

// Create a transform tt' = tt(t) - tt(te), NB tt'(te) = 0.
TimeXform Restart(TimeXform tt, Time te, Param& p);

double EvalLocalTime(TimeSubstitution timeTransform, double globalTime);
double EvalLocalTime(Param& p, TimeXform tt);

class PerfTimeXformImpl;

PerfTimeXformImpl *ViewGetPerfTimeXformFromCache(Perf);
void ViewSetPerfTimeXformCache(Perf, PerfTimeXformImpl *);
void ViewClearPerfTimeXformCache();

#endif /* _TIMETRAN_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\values.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of some basic values

*******************************************************************************/

#include <headers.h>
#include <string.h>
#include "privinc/except.h"
#include "privinc/storeobj.h"
#include "privinc/soundi.h"
#include "values.h"
#include "bvr.h"
#include "jaxaimpl.h"
#include "appelles/axaprims.h"
#include "privinc/server.h"
#include <danim.h>
#include "dartapi.h"

#if _USE_PRINT
ostream& operator<<(ostream& os, AxAValue v)
{ return v->Print(os); }
#endif

class AxATrivial : public AxAValueObj
{
  public:
    AxATrivial() {}

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "()"; }
#endif

    virtual DXMTypeInfo GetTypeInfo() { return AxATrivialType; }
};

static AxAValue trivial = NULL;

AxAValue Trivial() { return trivial; }

/////////////////////////// Pair ///////////////////////////////

void AxAPair::DoKids(GCFuncObj proc)
{
    (*proc)(_left);
    (*proc)(_right);
}

///////////////////////// Initialization  ///////////////////////

DXMTypeInfo AxAValueType;
DXMTypeInfo BvrType;

DXMTypeInfo CameraType;
DXMTypeInfo ColorType;
DXMTypeInfo GeometryType;
DXMTypeInfo ImageType;
DXMTypeInfo MatteType;
DXMTypeInfo MicrophoneType;
DXMTypeInfo MontageType;
DXMTypeInfo Path2Type;
DXMTypeInfo Point2ValueType;
DXMTypeInfo Point3ValueType;
DXMTypeInfo SoundType;
DXMTypeInfo TextType;
DXMTypeInfo Transform2Type;
DXMTypeInfo Transform3Type;
DXMTypeInfo Vector2ValueType;
DXMTypeInfo Vector3ValueType;
DXMTypeInfo FontFamilyType;
DXMTypeInfo FontStyleType;
DXMTypeInfo Bbox2ValueType;
DXMTypeInfo Bbox3Type;
DXMTypeInfo LineStyleType;
DXMTypeInfo EndStyleType;
DXMTypeInfo JoinStyleType;
DXMTypeInfo DashStyleType;
DXMTypeInfo AxANumberType;
DXMTypeInfo AxAStringType;
DXMTypeInfo AxABooleanType;
DXMTypeInfo AxAPairType;
DXMTypeInfo AxAArrayType;
DXMTypeInfo AxATrivialType;
DXMTypeInfo AxAEDataType;
DXMTypeInfo TupleType;
DXMTypeInfo UserDataType;
DXMTypeInfo AxALongType;
DXMTypeInfo AxAVariantType;

void
InitializeModule_Values()
{
    CameraType = NEW DXMTypeInfoImpl(CAMERA_TYPEID,"Camera",CRCAMERA_TYPEID);
    ColorType = NEW DXMTypeInfoImpl(COLOR_TYPEID,"Color",CRCOLOR_TYPEID);
    GeometryType = NEW DXMTypeInfoImpl(GEOMETRY_TYPEID,"Geometry",CRGEOMETRY_TYPEID);
    ImageType = NEW DXMTypeInfoImpl(IMAGE_TYPEID,"Image",CRIMAGE_TYPEID);
    MatteType = NEW DXMTypeInfoImpl(MATTE_TYPEID,"Matte",CRMATTE_TYPEID);
    MicrophoneType = NEW DXMTypeInfoImpl(MICROPHONE_TYPEID,"Microphone",CRMICROPHONE_TYPEID);
    MontageType = NEW DXMTypeInfoImpl(MONTAGE_TYPEID,"Montage",CRMONTAGE_TYPEID);
    Path2Type = NEW DXMTypeInfoImpl(PATH2_TYPEID,"Path2",CRPATH2_TYPEID);
    Point2ValueType = NEW DXMTypeInfoImpl(POINT2_TYPEID,"Point2",CRPOINT2_TYPEID);
    Point3ValueType = NEW DXMTypeInfoImpl(POINT3_TYPEID,"Point3",CRPOINT3_TYPEID);
    SoundType = NEW DXMTypeInfoImpl(SOUND_TYPEID,"Sound",CRSOUND_TYPEID);
    TextType = NEW DXMTypeInfoImpl(TEXT_TYPEID,"Text",CRINVALID_TYPEID);
    Transform2Type = NEW DXMTypeInfoImpl(TRANSFORM2_TYPEID,"Transform2",CRTRANSFORM2_TYPEID);
    Transform3Type = NEW DXMTypeInfoImpl(TRANSFORM3_TYPEID,"Transform3",CRTRANSFORM3_TYPEID);
    Vector2ValueType = NEW DXMTypeInfoImpl(VECTOR2_TYPEID,"Vector2",CRVECTOR2_TYPEID);
    Vector3ValueType = NEW DXMTypeInfoImpl(VECTOR3_TYPEID,"Vector3",CRVECTOR3_TYPEID);
    FontFamilyType = NEW DXMTypeInfoImpl(FONTFAMILY_TYPEID,"FontFamily",CRINVALID_TYPEID);
    FontStyleType = NEW DXMTypeInfoImpl(FONTSTYLE_TYPEID,"FontStyle",CRFONTSTYLE_TYPEID);
    Bbox2ValueType = NEW DXMTypeInfoImpl(BBOX2_TYPEID,"Bbox2",CRBBOX2_TYPEID);
    Bbox3Type = NEW DXMTypeInfoImpl(BBOX3_TYPEID,"Bbox3",CRBBOX3_TYPEID);
    LineStyleType = NEW DXMTypeInfoImpl(LINESTYLE_TYPEID,"LineStyle",CRLINESTYLE_TYPEID);
    EndStyleType = NEW DXMTypeInfoImpl(ENDSTYLE_TYPEID,"EndStyle",CRENDSTYLE_TYPEID);
    JoinStyleType = NEW DXMTypeInfoImpl(JOINSTYLE_TYPEID,"JoinStyle",CRJOINSTYLE_TYPEID);
    DashStyleType = NEW DXMTypeInfoImpl(DASHSTYLE_TYPEID,"DashStyle",CRDASHSTYLE_TYPEID);
    AxANumberType = NEW DXMTypeInfoImpl(AXANUMBER_TYPEID,"Number",CRNUMBER_TYPEID);
    AxAStringType = NEW DXMTypeInfoImpl(AXASTRING_TYPEID,"String",CRSTRING_TYPEID);
    AxABooleanType = NEW DXMTypeInfoImpl(AXABOOLEAN_TYPEID,"Boolean",CRBOOLEAN_TYPEID);
    AxAPairType = NEW DXMTypeInfoImpl(AXAPAIR_TYPEID,"Pair",CRPAIR_TYPEID);
    AxATrivialType = NEW DXMTypeInfoImpl(AXATRIVIAL_TYPEID,"Trivial",CRUNKNOWN_TYPEID);
    AxAEDataType = NEW DXMTypeInfoImpl(AXAEDATA_TYPEID,"Event",CREVENT_TYPEID);
    AxAArrayType = NEW DXMTypeInfoImpl(AXAARRAY_TYPEID,"Array",CRARRAY_TYPEID);
    TupleType = NEW DXMTypeInfoImpl(TUPLE_TYPEID,"Tuple",CRTUPLE_TYPEID);
    UserDataType = NEW DXMTypeInfoImpl(USERDATA_TYPEID,"UserData",CRUSERDATA_TYPEID);
    AxALongType = NEW DXMTypeInfoImpl(AXALONG_TYPEID,"Long",CRNUMBER_TYPEID);
    AxAVariantType = NEW DXMTypeInfoImpl(AXAVARIANT_TYPEID,"Variant",CRUNKNOWN_TYPEID);

    AxAValueType = AxATrivialType;
    BvrType = AxATrivialType;

    trivial = NEW AxATrivial();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\comlib\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\comlib\chromeimg.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _TXDIMG_H
#define _TXDIMG_H

#include "privinc/comutil.h"

class ATL_NO_VTABLE CChromeImageFactory : public CComClassFactory {
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj); 
};

class ATL_NO_VTABLE CChromeImage
    : public CComObjectRootEx<CComMultiThreadModel>,
      public CComCoClass<CChromeImage, &CLSID_ChromeImage>,
      public IChromeImage
{
  public:
    BEGIN_COM_MAP(CChromeImage)
        COM_INTERFACE_ENTRY(IChromeImage)
    END_COM_MAP();

    DECLARE_REGISTRY(CLSID_ChromeImage,
                     "DirectAnimation.ChromeImage.1",
                     "DirectAnimation.ChromeImage",
                     0,
                     THREADFLAGS_BOTH);
    
    DECLARE_CLASSFACTORY_EX(CChromeImageFactory);

    STDMETHOD(put_BaseImage)(IDAImage *baseImg);
    STDMETHOD(get_BaseImage)(IDAImage **baseImg);
    
    STDMETHOD(SetOpacity)(VARIANT v);
    STDMETHOD(GetOpacity)(VARIANT *v);
        
    STDMETHOD(SetRotate)(VARIANT angle);
    STDMETHOD(GetRotate)(VARIANT *angle);
        
    STDMETHOD(SetTranslate)(VARIANT x, VARIANT y);
    STDMETHOD(GetTranslate)(VARIANT *x, VARIANT *y);
        
    STDMETHOD(SetScale)(VARIANT x, VARIANT y);
    STDMETHOD(GetScale)(VARIANT *x, VARIANT *y);
        
    STDMETHOD(SetPreTransform)(IDATransform2 * prexf);
    STDMETHOD(GetPreTransform)(IDATransform2 ** prexf);
        
    STDMETHOD(SetPostTransform)(IDATransform2 * postxf);
    STDMETHOD(GetPostTransform)(IDATransform2 ** postxf);

    STDMETHOD(SetClipPath)(IDAPath2 * path);
    STDMETHOD(GetClipPath)(IDAPath2 ** path);

    // After setting attributes this will update the internal state
    // This must be called for any updated attributes to get
    // propogated
    
    STDMETHOD(Update)();
        
    // This will make the behavior restart at local time 0
    STDMETHOD(Restart)();
        
    // Clears any attributes
    STDMETHOD(Reset)();

    // This is the resultant image of applying all the attributes to
    // the base image.  This is what needs to be plugged into the
    // regular DA graph
        
    STDMETHOD(get_ResultantImage)(IDAImage **img);
        
    // Given the local time (we may be able to support global but not
    // sure yet), it will return the x and y position of the image in
    // local coords
    STDMETHOD(GetCurrentPosition)(double localTime,
                                  double * x, double * y);

    CChromeImage();
    ~CChromeImage();

    HRESULT Init();
    
    void Clear();
    HRESULT Switch(bool bContinue);
    HRESULT UpdateAttr();
  protected:
    CritSect                     _cs;
    // the modifiable image to use - this is the resultant image
    DAComPtr<IDAImage>           _modImg;
    DAComPtr<IDA2Behavior>       _modImgBvr;
    // Empty Image to use when needed
    DAComPtr<IDAImage>           _emptyImage;
    // This is the completely attributed image
    DAComPtr<IDAImage>           _attrImg;
    // this is the base image passed in by the user
    DAComPtr<IDAImage>           _baseImg;

    DAComPtr<IDAStatics>         _statics;

    // These are the attributes in their native form
    // TODO: We should store them in a less expensive form
    DAComPtr<IDATransform2>      _prexf;
    DAComPtr<IDATransform2>      _postxf;
    DAComPtr<IDAPath2>           _clipPath;
    CComVariant                  _opacity;
    CComVariant                  _rotAngle;
    CComVariant                  _xtrans;
    CComVariant                  _ytrans;
    CComVariant                  _xscale;
    CComVariant                  _yscale;
    bool                         _needsUpdate;

    HRESULT GetScale(IDATransform2 **xf);
    HRESULT GetRotate(IDATransform2 **xf);
    HRESULT GetTranslate(IDATransform2 **xf);
    HRESULT GetOpacity(IDANumber **n);

    HRESULT GetNumberFromVariant(VARIANT v,double def,IDANumber **num);
};

#endif /* _TXDIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\control\dactlevents.h ===
#include "..\..\types\idl\danimid.h"

//////////////////////////////////////////////////////////////////////////////
// CProxy_IDAViewerControlEvents
template <class T>
class CProxy_IDAViewerControlEvents : public IConnectionPointImpl<T, &DIID__IDAViewerControlEvents, CComDynamicUnkArray>
{
public:
    //methods:
    //_IDA3ViewerControlEvents : IDispatch
public:

    void Fire_Start()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_START, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }

    void Fire_MouseUp(long Button, long KeyFlags, long X, long Y)
    {
        VARIANTARG* pvars = NEW VARIANTARG[4];
        for (int i = 0; i < 4; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[3].vt = VT_I4;
                pvars[3].lVal= Button;
                pvars[2].vt = VT_I4;
                pvars[2].lVal= KeyFlags;
                pvars[1].vt = VT_I4;
                pvars[1].lVal= X;
                pvars[0].vt = VT_I4;
                pvars[0].lVal= Y;
                
                DISPPARAMS disp = { pvars, NULL, 4, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_MOUSEUP, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_MouseDown(long Button, long KeyFlags, long X, long Y)
    {
        VARIANTARG* pvars = NEW VARIANTARG[4];
        for (int i = 0; i < 4; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[3].vt = VT_I4;
                pvars[3].lVal= Button;
                pvars[2].vt = VT_I4;
                pvars[2].lVal= KeyFlags;
                pvars[1].vt = VT_I4;
                pvars[1].lVal= X;
                pvars[0].vt = VT_I4;
                pvars[0].lVal= Y;
                
                DISPPARAMS disp = { pvars, NULL, 4, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_MOUSEDOWN, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);

            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_MouseMove(long Button, long KeyFlags, long X, long Y)
    {
        VARIANTARG* pvars = NEW VARIANTARG[4];
        
        for (int i = 0; i < 4; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[3].vt = VT_I4;
                pvars[3].lVal= Button;
                pvars[2].vt = VT_I4;
                pvars[2].lVal= KeyFlags;
                pvars[1].vt = VT_I4;
                pvars[1].lVal= X;
                pvars[0].vt = VT_I4;
                pvars[0].lVal= Y;
                DISPPARAMS disp = { pvars, NULL, 4, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);

                pDispatch->Invoke(DISPID_DANIMEVENT_MOUSEMOVE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_Click()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_CLICK, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }
    
    void Fire_KeyPress(long KeyAscii)
    {
        VARIANTARG* pvars = NEW VARIANTARG[1];
        for (int i = 0; i < 1; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[0].vt = VT_I4;
                pvars[0].lVal= KeyAscii;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_KEYPRESS, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;        
    }

    void Fire_KeyUp(long KeyCode, long KeyData)
    {
        VARIANTARG* pvars = NEW VARIANTARG[2];
        for (int i = 0; i < 2; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[1].vt = VT_I4;
                pvars[1].lVal= KeyCode;
                pvars[0].vt = VT_I4;
                pvars[0].lVal= KeyData;
                DISPPARAMS disp = { pvars, NULL, 2, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_KEYUP, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_KeyDown(long KeyCode, long KeyData)
    {
        VARIANTARG* pvars = NEW VARIANTARG[2];
        
        for (int i = 0; i < 2; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[1].vt = VT_I4;
                pvars[1].lVal= KeyCode;
                pvars[0].vt = VT_I4;
                pvars[0].lVal= KeyData;
                
                DISPPARAMS disp = { pvars, NULL, 2, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_KEYDOWN, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_Error(long hr, BSTR ErrorText)
    {
        VARIANTARG* pvars = NEW VARIANTARG[2];
        
        for (int i = 0; i < 2; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[1].vt = VT_I4;
                pvars[1].lVal= hr;
                pvars[0].vt = VT_BSTR;
                pvars[0].bstrVal = SysAllocString(ErrorText);
                
                DISPPARAMS disp = { pvars, NULL, 2, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_ERROR, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
                SysFreeString(pvars[0].bstrVal);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_Stop()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_STOP, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }

    void Fire_Pause()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_PAUSE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }

    void Fire_Resume()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_RESUME, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\backend\wndevent.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Windows Event

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "events.h"
#include "values.h"
#include "privinc/server.h"
#include "axadefs.h"

template<class T, class Impl>
class ATL_NO_VTABLE GCWindBase : public Impl
{
  public:
    GCWindBase(WindEventType et,
               DWORD data,
               BOOL bState,
               T b)
    : _et(et),
      _data(data),
      _bState(bState),
      _b(b) {}

    virtual BOOL InterruptBasedEvent() { return TRUE; }

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_b); }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        os << "wind(" << (int)_et << "," << _data << "," << _bState;
        if (_b) os << ", " << _b;
        return os << ")";
    }
#endif

  protected:
    T _b;
    WindEventType _et;
    DWORD _data;
    BOOL _bState;
};

class WindPerfImpl : public GCWindBase<Perf, PerfImpl>
{
  public:
    WindPerfImpl(WindEventType et,
                 DWORD data,
                 BOOL bState,
                 Time t0,
                 Perf ir)
    : GCWindBase<Perf, PerfImpl>(et, data, bState, ir), _t0(t0) {}

    virtual AxAValue _Sample(Param&);
    
  private:
    Time _t0;
};

class WindBvrImpl : public GCWindBase<Bvr, BvrImpl>
{
  public:
    WindBvrImpl(WindEventType et,
                DWORD data,
                BOOL bState,
                Bvr b) : GCWindBase<Bvr, BvrImpl>(et, data, bState, b) {}

    virtual DWORD GetInfo(bool) { return BVR_TIMEVARYING_ONLY; }
    
    virtual Perf _Perform(PerfParam& p)
    { return NEW WindPerfImpl(_et, _data, _bState, p._t0, ::Perform(_b, p)); }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
};

AxAValue WindPerfImpl::_Sample(Param& p)
{
    Time sTime = (p._sampleType == EventSampleAfter) ? p._eTime : _t0; 
    
    DWORD data ;
    AXAEventId id ;

    switch(_et) {
      case WE_MOUSEBUTTON:

        id = AXAE_MOUSE_BUTTON ;
        data = _data;

        break;
            
      case WE_KEY:
        Assert(_b);

        id = AXAE_KEY ;
        // Optimization: if _data is non-zero, it means it's a
        // constant and we can save the sampling.  In jaxa, we don't
        // support time-varying keyUp/Down/State
        data = _data ? _data : unsigned(ValNumber(_b->Sample(p)));

        break;
        /* Don't think we support that anymore.
      case WE_CHAR:
        Assert(_b);

        id = AXAE_KEY ;
        data = ValChar(_b->Sample(p)) ;

        break;
        */
      case WE_RESIZE:
        if (!AXAWindowSizeChanged())
            return noEvent;

        // TODO: Need to decide what time to use - for now use the
        // sample time but may want to use the previous sample time
        
        return CreateEData(sTime, TrivialBvr());


      default:
        return noEvent;
    }    

    AXAWindEvent* pData = AXAEventOccurredAfter(sTime,
                                                id,
                                                data,
                                                _bState,
                                                AXAEMOD_NONE,
                                                AXAEMOD_NONE);

    if (!pData) 
        return noEvent;

    // Asking if a window event happens at an exact time is almost
    // always false.
    if (p._sampleType == EventSampleExact) {
        if (pData->when != p._eTime)
            return noEvent;
    }

    return CreateEData(pData->when, TrivialBvr());
}
    
Bvr WindEvent(WindEventType et,
              DWORD data,
              BOOL bState,
              Bvr b)
{ return NEW WindBvrImpl(et, data, bState, b); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\comlib\chromeimg.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1995-96 Microsoft Corporation
 *
 * Abstract:
 *******************************************************************************/


#include "headers.h"
#include "danim.h"
#include "privinc/mutex.h"
#include "privinc/server.h"
#include "privinc/backend.h"
#include "backend/bvr.h"
#include "chromeimg.h"
#include "dartapi.h"

DeclareTag(tagTXDImage, "CChromeImage", "IChromeImage methods");

#define CHECK_NULL(x) {if (!(x)) return E_INVALIDARG;}

#define CHECK_RETURN_NULL(x) {if (!(x)) return E_POINTER;}
#define CHECK_RETURN_SET_NULL(x) {if (!(x)) { return E_POINTER ;} else {*(x) = NULL;}}

STDMETHODIMP
CChromeImage::put_BaseImage(IDAImage *baseImg)
{
    CritSectGrabber _csg(_cs);

    _baseImg = baseImg;
    
    _needsUpdate = true;

    return S_OK;
}

STDMETHODIMP
CChromeImage::get_BaseImage(IDAImage **baseImg)
{
    CHECK_RETURN_SET_NULL(baseImg);

    CritSectGrabber _csg(_cs);

    if (_baseImg) {
        _baseImg->AddRef();
        *baseImg = _baseImg;
    }

    return S_OK;
}

    
STDMETHODIMP
CChromeImage::SetOpacity(VARIANT v)
{
    CritSectGrabber _csg(_cs);

    _needsUpdate = true;

    return _opacity.Copy(&v);
}

STDMETHODIMP
CChromeImage::GetOpacity(VARIANT *v)
{
    CHECK_RETURN_NULL(v);

    CritSectGrabber _csg(_cs);

    return VariantCopy(v,&_opacity);
}

        
STDMETHODIMP
CChromeImage::SetRotate(VARIANT angle)
{
    CritSectGrabber _csg(_cs);

    _needsUpdate = true;

    return _rotAngle.Copy(&angle);
}

STDMETHODIMP
CChromeImage::GetRotate(VARIANT *angle)
{
    CHECK_RETURN_NULL(angle);

    CritSectGrabber _csg(_cs);

    return VariantCopy(angle,&_rotAngle);
}

        
STDMETHODIMP
CChromeImage::SetTranslate(VARIANT x, VARIANT y)
{
    CritSectGrabber _csg(_cs);

    _needsUpdate = true;

    HRESULT hr;

    hr = _xtrans.Copy(&x);
    if (SUCCEEDED(hr))
        hr = _ytrans.Copy(&y);
    
    return hr;
}

STDMETHODIMP
CChromeImage::GetTranslate(VARIANT *x, VARIANT *y)
{
    CHECK_RETURN_NULL(x);
    CHECK_RETURN_NULL(y);

    CritSectGrabber _csg(_cs);

    HRESULT hr;

    hr = VariantCopy(x,&_xtrans);
    if (SUCCEEDED(hr))
        hr = VariantCopy(y,&_ytrans);
    
    return hr;
}

        
STDMETHODIMP
CChromeImage::SetScale(VARIANT x, VARIANT y)
{
    CritSectGrabber _csg(_cs);

    _needsUpdate = true;

    HRESULT hr;

    hr = _xscale.Copy(&x);
    if (SUCCEEDED(hr))
        hr = _yscale.Copy(&y);
    
    return hr;
}

STDMETHODIMP
CChromeImage::GetScale(VARIANT *x, VARIANT *y)
{
    CHECK_RETURN_NULL(x);
    CHECK_RETURN_NULL(y);

    CritSectGrabber _csg(_cs);

    HRESULT hr;

    hr = VariantCopy(x,&_xscale);
    if (SUCCEEDED(hr))
        hr = VariantCopy(y,&_yscale);
    
    return hr;
}

        
STDMETHODIMP
CChromeImage::SetPreTransform(IDATransform2 * prexf)
{
    CritSectGrabber _csg(_cs);

    _needsUpdate = true;

    _prexf = prexf;
    
    return S_OK;
}

STDMETHODIMP
CChromeImage::GetPreTransform(IDATransform2 ** prexf)
{
    CHECK_RETURN_SET_NULL(prexf);

    CritSectGrabber _csg(_cs);

    if (_prexf) {
        _prexf->AddRef();
        *prexf = _prexf;
    }

    return S_OK;
}

        
STDMETHODIMP
CChromeImage::SetPostTransform(IDATransform2 * postxf)
{
    CritSectGrabber _csg(_cs);

    _needsUpdate = true;

    _postxf = postxf;
    
    return S_OK;
}

STDMETHODIMP
CChromeImage::GetPostTransform(IDATransform2 ** postxf)
{
    CHECK_RETURN_SET_NULL(postxf);

    CritSectGrabber _csg(_cs);

    if (_postxf) {
        _postxf->AddRef();
        *postxf = _postxf;
    }

    return S_OK;
}


STDMETHODIMP
CChromeImage::SetClipPath(IDAPath2 * path)
{
    CritSectGrabber _csg(_cs);

    _needsUpdate = true;

    _clipPath = path;
    
    return S_OK;
}

STDMETHODIMP
CChromeImage::GetClipPath(IDAPath2 ** path)
{
    CHECK_RETURN_SET_NULL(path);

    CritSectGrabber _csg(_cs);
    if (_clipPath) {
        _clipPath->AddRef();
        *path = _clipPath;
    }

    return S_OK;
}


// After setting attributes this will update the internal state
// This must be called for any updated attributes to get
// propogated
    
STDMETHODIMP
CChromeImage::Update()
{
    CritSectGrabber _csg(_cs);

    // Switch with continue true
    return Switch(true);
}

        
// This will make the behavior restart at local time 0
STDMETHODIMP
CChromeImage::Restart()
{
    CritSectGrabber _csg(_cs);

    // Switch with continue false
    return Switch(false);
}

        
// Clears any attributes
STDMETHODIMP
CChromeImage::Reset()
{
    CritSectGrabber _csg(_cs);

    // Clear attributes

    Clear();

    // Do not update - user required to update since they probably
    // will add attributes and do not want to update to incorrect
    // image or do an extra update
    
    return S_OK;
}


// This is the resultant image of applying all the attributes to
// the base image.  This is what needs to be plugged into the
// regular DA graph
        
STDMETHODIMP
CChromeImage::get_ResultantImage(IDAImage **img)
{
    CHECK_RETURN_SET_NULL(img);

    Assert (_modImg);

    _modImg->AddRef();
    *img = _modImg;
    
    return S_OK;
}

        
// Given the local time (we may be able to support global but not
// sure yet), it will return the x and y position of the image in
// local coords
STDMETHODIMP
CChromeImage::GetCurrentPosition(double localTime,
                                double * x, double * y)
{
    CritSectGrabber _csg(_cs);
    return E_NOTIMPL;
}
                                    

CChromeImage::CChromeImage()
{
}

CChromeImage::~CChromeImage()
{
}

HRESULT
CChromeImage::Init()
{
    _needsUpdate = false;

    HRESULT hr = S_OK;
    
    hr = CoCreateInstance(CLSID_DAStatics,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDAStatics,
                          (void**)&_statics);

    if (FAILED(hr))
        return hr;
    
    __try {
        DynamicHeapPusher _dhp(GetGCHeap()) ;
        GCLockGrabber __gclg(GCL_CREATE);

        Bvr b = ConstBvr(emptyImage);
        CRBvrToCOM((CRBvrPtr) b,
                   IID_IDAImage,
                   (void **) &_emptyImage);

        CRBvrToCOM((CRBvrPtr) ::SwitcherBvr(b),
                   IID_IDAImage,
                   (void **) &_modImg);

    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        hr = DAGetLastError();
    }
    
    if (SUCCEEDED(hr)) {
        hr = _modImg->QueryInterface(IID_IDA2Behavior,
                                     (void **) & _modImgBvr);
        Assert (SUCCEEDED(hr));
    }

    return hr;
}

void
CChromeImage::Clear()
{
    _prexf.Release();
    _postxf.Release();
    _clipPath.Release();
    _opacity.Clear();
    _rotAngle.Clear();
    _xtrans.Clear();
    _ytrans.Clear();
    _xscale.Clear();
    _yscale.Clear();

    _needsUpdate = true;
}

HRESULT
CChromeImage::Switch(bool bContinue)
{
    HRESULT hr;

    hr = UpdateAttr();

    if (SUCCEEDED(hr)) 
        hr = _modImgBvr->SwitchToEx(_attrImg, bContinue?DAContinueTimeline:0);
    
    return hr;
}

HRESULT
CChromeImage::UpdateAttr()
{
    HRESULT hr = S_OK;

    if (_needsUpdate) {
        DAComPtr<IDAImage> accImg(_baseImg?_baseImg:_emptyImage);
        DAComPtr<IDATransform2> scale;
        DAComPtr<IDATransform2> rot;
        DAComPtr<IDATransform2> trans;
        DAComPtr<IDANumber> op;

        IDATransform2 * xformarr[10]; // Make it 10 to be safe
        int nxf = 0;
        
        if (SUCCEEDED(hr = GetScale(&scale)) &&
            SUCCEEDED(hr = GetRotate(&rot)) &&
            SUCCEEDED(hr = GetTranslate(&trans)) &&
            SUCCEEDED(hr = GetOpacity(&op))) {

            if (_prexf)
                xformarr[nxf++] = _prexf;
            
            if (scale)
                xformarr[nxf++] = scale;
            
            if (rot)
                xformarr[nxf++] = rot;
            
            if (trans)
                xformarr[nxf++] = trans;
            
            if (_postxf)
                xformarr[nxf++] = _postxf;
            
            Assert (nxf <= ARRAY_SIZE(xformarr));
            
            if (nxf) {
                DAComPtr<IDATransform2> xf;

                if (nxf == 1) {
                    xf = xformarr[0];
                } else {
                    hr = _statics->Compose2ArrayEx(nxf, xformarr, &
                                                   xf);
                }

                if (SUCCEEDED(hr)) {
                    DAComPtr<IDAImage> tmpImg;

                    hr = accImg->Transform(xf, &tmpImg);
                
                    accImg = tmpImg;
                }
            }
        }
            
        if (SUCCEEDED(hr) && op) {
            DAComPtr<IDAImage> tmpImg;
            
            hr = accImg->OpacityAnim(op, &tmpImg);
            
            accImg = tmpImg;
        }
            
        if (SUCCEEDED(hr) && _clipPath) {
            DAComPtr<IDAMatte> matt;

            hr = _statics->FillMatte(_clipPath, &matt);

            if (SUCCEEDED(hr)) {
                DAComPtr<IDAImage> tmpImg;
            
                hr = accImg->Clip(matt, &tmpImg);
            
                accImg = tmpImg;
            }
        }
            
        if (SUCCEEDED(hr)) {
            _attrImg = accImg;
        }
    }
    
    return hr;
}

HRESULT
CChromeImage::GetNumberFromVariant(VARIANT v, double def, IDANumber **num)
{
    CComVariant var;
        
    HRESULT hr = var.ChangeType(VT_UNKNOWN, &v);

    if (SUCCEEDED(hr)) {
        hr = var.punkVal->QueryInterface(IID_IDANumber, (void**)num);
    } else {
        double d;
        
        if (V_VT(&v) == VT_EMPTY) {
            hr = S_OK;
            d = def;
        } else {
            // See if it is a number
            hr = var.ChangeType(VT_R8, &v);
            d = var.dblVal;
        }
        
        if (SUCCEEDED(hr)) {
            hr = _statics->DANumber(d, num);
        }
    }

    return hr;
}

HRESULT
CChromeImage::GetScale(IDATransform2 **xf)
{
    DAComPtr<IDANumber> x;
    DAComPtr<IDANumber> y;

    HRESULT hr = S_OK;

    if ((V_VT(&_xscale) != VT_EMPTY ||
         V_VT(&_yscale) != VT_EMPTY) &&
        SUCCEEDED(hr = GetNumberFromVariant(_xscale, 1, &x)) &&
        SUCCEEDED(hr = GetNumberFromVariant(_yscale, 1, &y)))
        hr = _statics->Scale2Anim(x,y,xf);

    return hr;
}

HRESULT
CChromeImage::GetRotate(IDATransform2 **xf)
{
    DAComPtr<IDANumber> a;

    HRESULT hr = S_OK;

    if (V_VT(&_rotAngle) != VT_EMPTY &&
        SUCCEEDED(hr = GetNumberFromVariant(_rotAngle, 0, &a)))
        hr = _statics->Rotate2Anim(a,xf);

    return hr;
}

HRESULT
CChromeImage::GetTranslate(IDATransform2 **xf)
{
    DAComPtr<IDANumber> x;
    DAComPtr<IDANumber> y;

    HRESULT hr = S_OK;

    if ((V_VT(&_xtrans) != VT_EMPTY ||
         V_VT(&_ytrans) != VT_EMPTY) &&
        SUCCEEDED(hr = GetNumberFromVariant(_xtrans, 0, &x)) &&
        SUCCEEDED(hr = GetNumberFromVariant(_ytrans, 0, &y)))
        hr = _statics->Translate2Anim(x,y,xf);

    return hr;
}

HRESULT
CChromeImage::GetOpacity(IDANumber **n)
{
    HRESULT hr = S_OK;

    if (V_VT(&_opacity) != VT_EMPTY)
        hr = GetNumberFromVariant(_opacity, 1, n);
    
    return hr;
}

STDMETHODIMP
CChromeImageFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppv)
{
    if (ppv)
        *ppv = NULL;
    
    CComObject<CChromeImage>* pNew;

    CComObject<CChromeImage>::CreateInstance(&pNew);

    HRESULT hr = S_OK;
 
    if (pNew) {
        hr = pNew->Init();

        // Do the QI last so that ppv is not set on failure
        
        if (SUCCEEDED(hr))
            hr = pNew->QueryInterface(riid, ppv);
    } else {
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr)) {
        delete pNew;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\control\ctrl.cpp ===
// ctrl.cpp
// Disable warning for exception unwind
#pragma warning(disable:4530)

#include "headers.h"
#include "privinc/debug.h"
#include "dxactrl.h"
#include "privinc/util.h"
#include "privinc/mutex.h"
#include "privinc/resource.h"
#include "daerror.h"

extern HINSTANCE hInst;

#define DAWIN32TIMER_CLASS "DANIMTimerClass"
#define DATIMER_INTERVAL_MS 20

inline bool DA_FAILED(HRESULT hr)
{
    return (FAILED(hr) &&
            hr != E_PENDING &&
            hr != DAERR_VIEW_LOCKED &&
            hr != DAERR_VIEW_SURFACE_BUSY);
}

long g_numActivelyRenderingControls = 0;

struct TimerMapData {
    TimerMapData(WMTimerCallback cb = NULL,
                 DWORD dwData = 0,
                 DWORD dwIntervalMS = DATIMER_INTERVAL_MS)
    : _cb(cb),
      _data(dwData),
      _interval(dwIntervalMS / 1000.0),
      _lastUpdate(0.0)
        {}

    WMTimerCallback _cb;
    DWORD _data;
    double _interval;
    // Use 0 to mean we have never been updated.  This works well
    // since we will always require an update the first frame since
    // the interval will be large
    double _lastUpdate;
};
    
typedef map< UINT, TimerMapData, less<UINT> > TimerMap;

// These structures do not need CS protection since they are on a
// per thread basis
struct WindowMapData {
    WindowMapData(HWND hwnd = NULL)
    : _hwnd(hwnd),
#ifdef _DEBUG
      _lastUpdate(0.0),
#endif
      _curId(0)
        {}
    
    HWND _hwnd;
    TimerMap _timerMap;
    DWORD _curId;
#ifdef _DEBUG
    double _lastUpdate;
#endif
};

typedef map< DWORD, WindowMapData, less<DWORD> > WindowMap;

class Win32Timer : public AxAThrowingAllocatorClass
{
  public:
    Win32Timer() {}
    ~Win32Timer() { Assert(_winMap.size() == 0); }

    DWORD CreateTimer(DWORD dwInterval,
                      WMTimerCallback cb,
                      DWORD dwData);
    void DestroyTimer(DWORD id);
                      
  protected:
    CritSect _cs;
    WindowMap _winMap;

    // Returns NULL if it does not exist
    WindowMapData * GetWindowData();

    WindowMapData * CreateWindowData();
    void DestroyWindowData();
    
    void TimerCallback();
  public:
    static LRESULT CALLBACK WindowProc (HWND   hwnd,
                                        UINT   msg,
                                        WPARAM wParam,
                                        LPARAM lParam);
};

Win32Timer * win32Timer = NULL;

WindowMapData *
Win32Timer::GetWindowData()
{
    CritSectGrabber csg(_cs);

    WindowMap::iterator i = _winMap.find(GetCurrentThreadId());

    if (i == _winMap.end())
        return NULL;
    
    return &((*i).second);
}


WindowMapData *
Win32Timer::CreateWindowData()
{
    Assert(GetWindowData() == NULL);
    
    HWND hwnd = ::CreateWindow (DAWIN32TIMER_CLASS, 
                                "DirectAnimation Timer Window",
                                0, 0, 0, 0, 0, NULL, NULL, hInst, NULL);
    
    if (!hwnd)
        return NULL;

    // Need to setup a WM_TIMER
    UINT_PTR id = ::SetTimer(hwnd,
                          1,
                          DATIMER_INTERVAL_MS,
                          NULL);

    Assert (id == 0 || id == 1);

    if (id == 0) {
        DestroyWindow(hwnd);
        return NULL;
    }

    {
        CritSectGrabber csg(_cs);
        
        return &(_winMap[GetCurrentThreadId()] = WindowMapData(hwnd));
    }
}    

void
Win32Timer::DestroyWindowData()
{
    CritSectGrabber csg(_cs);

    WindowMap::iterator i = _winMap.find(GetCurrentThreadId());

    if (i != _winMap.end()) {
        Assert ((*i).second._timerMap.size() == 0);
        ::KillTimer((*i).second._hwnd, 1);
        DestroyWindow ((*i).second._hwnd);
        _winMap.erase(i);
    }
}


DWORD
Win32Timer::CreateTimer(DWORD dwInterval,
                        WMTimerCallback cb,
                        DWORD dwData)
{
    WindowMapData * m = GetWindowData();

    if (m == NULL) {
        m = CreateWindowData();
        if (m == NULL)
            return 0;
    }
    
    // Do not need CS here since everything is on a per thread basis
    
    if (++m->_curId == 0)
        ++m->_curId;

    DWORD id = m->_curId;
    
    // Need to add this to the lookup queue

    Assert (m->_timerMap.find(id) == m->_timerMap.end());
    m->_timerMap[id] = TimerMapData(cb, dwData, dwInterval);

    return id;
}

void
Win32Timer::DestroyTimer(DWORD id)
{
    WindowMapData * m = GetWindowData();

    if (m == NULL)
        return;
    
    m->_timerMap.erase(id);

    if (m->_timerMap.size() == 0)
        DestroyWindowData();
}

void
Win32Timer::TimerCallback()
{
    WindowMapData * m = GetWindowData();

    if (m == NULL) {
        Assert (FALSE && "Received timer message on thread we have no timers on");
        return;
    }
    
    double t = ::GetCurrTime();
    
    // Iterate through all the controls in the current thread and tick
    // them
    
    for (TimerMap::iterator i = m->_timerMap.begin();
         i != m->_timerMap.end();
         i++) {
        
        TimerMapData & d = (*i).second;
        DWORD id = (*i).first;

        Assert ((t - d._lastUpdate) >= 0);
        
        if ((t - d._lastUpdate) >= d._interval) {
            d._cb(id, d._data);
            d._lastUpdate = t;
        }
    }

#ifdef _DEBUG
    m->_lastUpdate = t;
#endif
}

//
// C Functions
//

DWORD
CreateWMTimer(DWORD dwInterval,
              WMTimerCallback cb,
              DWORD dwData)
{ return win32Timer->CreateTimer(dwInterval, cb, dwData); }

void
DestroyWMTimer(DWORD id)
{ win32Timer->DestroyTimer(id); }


LRESULT CALLBACK
Win32Timer::WindowProc (HWND   hwnd,
                        UINT   msg,
                        WPARAM wParam,
                        LPARAM lParam)
{
    if (msg == WM_TIMER) {
        win32Timer->TimerCallback();
    }
    
    return DefWindowProc (hwnd, msg, wParam, lParam);
}

static void RegisterWindowClass ()
{
    WNDCLASS windowclass;

    memset (&windowclass, 0, sizeof(windowclass));

    windowclass.style         = 0;
    windowclass.lpfnWndProc   = Win32Timer::WindowProc;
    windowclass.hInstance     = hInst;
    windowclass.hCursor       = NULL;
    windowclass.hbrBackground = NULL;
    windowclass.lpszClassName = DAWIN32TIMER_CLASS;

    RegisterClass (&windowclass);
}
///////////////////////////////////////////////////////////////////////

#if _DEBUG
struct DisablePopups
{
    DisablePopups() { DISABLE_ASSERT_POPUPS(TRUE); }
    ~DisablePopups() { DISABLE_ASSERT_POPUPS(FALSE); }
};
#endif    


void
WMTimerCB(DWORD id, DWORD_PTR dwData)
{
    DAControlImplementation *ctrl =
        (DAControlImplementation *)dwData;
    
    ctrl->HandleOnTimer();
}



DAControlImplementation::DAControlImplementation(
    CComObjectRootEx<CComMultiThreadModel> *ctrl,
    CComControlBase *ctrlBase,
    IDASite *daSite,
    CDAViewerControlBaseClass  *baseEvents)
{
    TraceTag((tagControlLifecycle,
              "Constructing control @ 0x%x", this));

    m_ctrl                  = ctrl;
    m_ctrlBase              = ctrlBase;
    m_ctrlBaseEvents        = baseEvents;
    m_daSite                = daSite;
    m_startupState          = INITIAL;
    m_currentState          = CUR_INITIAL;
    m_dPausedTime           = 0;
    m_startupFailed         = false;
    m_tickOrRenderFailed    = false;
    m_timerSink             = NULL;
    m_backgroundSet         = false;
    m_hErrorBitmap          = 0;
    m_opaqueForHitDetect    = true;
    m_minimumUpdateInterval = 33;   // initially target max of 30 fps

    m_tridentServices       = false;
    m_ddrawSurfaceAsTarget  = false;
    m_adviseCookie          = 0;
    m_wmtimerId             = 0;
    m_desiredCPUUsageFrac   = 0.85; // and 85% CPU usage
    m_timerSource           = DAWMTimer;
    m_wstrScript            = NULL;
    m_registeredAsActive    = false;
    
    m_szErrorString         = NULL;
    m_bMouseCaptured        = false;

    LARGE_INTEGER lpc;
    QueryPerformanceFrequency(&lpc);
    m_perfCounterFrequency = lpc.LowPart;

    m_frameNumber     = 0;
    m_framesThisCycle = 0;
    m_timeThisCycle   = 0;
    
    m_origTimerSource = DAWMTimer;

    SetRect(&m_lastRcClip, 1000, 1000, -1000, -1000);
    SetRect(&m_lastDeviceBounds, 1000, 1000, -1000, -1000);

}

DAControlImplementation::~DAControlImplementation()
{
    TraceTag((tagControlLifecycle,
              "Destroying control @ 0x%x", this));

    // Remove the timer when we're being destroyed.
    StopTimer();

    if (m_szErrorString)
    {
        delete m_szErrorString;
        m_szErrorString = NULL;
    }
    if (m_hErrorBitmap)
    {
        DeleteObject(m_hErrorBitmap);
        m_hErrorBitmap = NULL;
    }

    delete m_wstrScript;
    RELEASE(m_timerSink);
}

// IDASite & IDAViewSite
// Make the call back to the script.
STDMETHODIMP
DAControlImplementation::ReportError(long hr,
                       BSTR errorText)
{
    BSTR bstrScript;
    DISPID dispid;
    DAComPtr<IOleClientSite> pClient;
    DAComPtr<IOleContainer> pRoot;
    DAComPtr<IHTMLDocument> pHTMLDoc;
    DAComPtr<IDispatch> pDispatch;

    m_ctrlBaseEvents->FireError(hr, errorText);

   {
        Lock();
        if (m_wstrScript)
            bstrScript = SysAllocString(m_wstrScript);
        else
            bstrScript = NULL;
        Unlock();
    }

    if (bstrScript == NULL)
        return S_OK;

            if (FAILED(m_spAptClientSite->GetContainer(&pRoot)) ||
            FAILED(pRoot->QueryInterface(IID_IHTMLDocument, (void **)&pHTMLDoc)) ||
            FAILED(pHTMLDoc->get_Script(&pDispatch)) ||
            FAILED(pDispatch->GetIDsOfNames(IID_NULL, &bstrScript, 1,
                                            LOCALE_USER_DEFAULT,
                                            &dispid))) {
            SysFreeString(bstrScript); 
            return E_FAIL;
        }
    SysFreeString(bstrScript); 

    // paramters needed to be passed 
        VARIANTARG varArg;
    ::VariantInit(&varArg); // Initialize the VARIANT
    DISPPARAMS dp;
    dp.rgvarg = &varArg;
    dp.rgdispidNamedArgs = 0;
    dp.cArgs  = 1;
    dp.cNamedArgs   = 0;
    dp.rgvarg[0].vt = VT_BSTR;
    dp.rgvarg[0].bstrVal = errorText;

    hr = pDispatch->Invoke(dispid, IID_NULL,
                                   LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                                   &dp, NULL, NULL, NULL);


    // need to free the information that we put into dispparams
    SysFreeString(dp.rgvarg[0].bstrVal); 
    ::VariantClear(&varArg); // clears the CComVarient

    return hr;
}


STDMETHODIMP
DAControlImplementation::ReportGC(short bStarting)
{
    return S_OK;
}

STDMETHODIMP
DAControlImplementation::SetStatusText(BSTR StatusText)
{
    return S_OK;
}

// IViewObjectEx
// TODO: hack for now until this makes it into the public Trident
// header files.    
#define VIEWSTATUS_SURFACE 0x10
#define VIEWSTATUS_3DSURFACE 0x20

// TODO: this should be different if we are windowed
STDMETHODIMP
DAControlImplementation::GetViewStatus(DWORD* pdwStatus)
{
    *pdwStatus = VIEWSTATUS_SURFACE | VIEWSTATUS_3DSURFACE;

    return S_OK;
}

// IOleInPlaceActiveObject
//
STDMETHODIMP
DAControlImplementation::TranslateAccelerator(LPMSG lpmsg)
{
    BOOL b;

    MsgHandler(lpmsg->message,
               lpmsg->wParam, lpmsg->lParam,
               b);

    return b?S_OK:S_FALSE;
}

STDMETHODIMP
DAControlImplementation::QueryHitPoint(DWORD dwAspect,
                         LPCRECT pRectBounds,
                         POINT ptlLoc,
                         LONG lCloseHint,
                         DWORD *pHitResult)
{
    *pHitResult = HITRESULT_OUTSIDE;

    if (dwAspect == DVASPECT_CONTENT) {

        int inRect = PtInRect(pRectBounds, ptlLoc);

        // If we have a view, and we are inside the rectangle,
        // then we need to ask the view whether or not we've
        // hit the image inside.
        if (m_opaqueForHitDetect || !m_ctrlBase->m_bWndLess) {

            *pHitResult = inRect ? HITRESULT_HIT : HITRESULT_OUTSIDE;

        } else if (m_view.p && inRect) {

            HRESULT hr = m_view->QueryHitPoint(dwAspect,
                                               pRectBounds,
                                               ptlLoc,
                                               lCloseHint,
                                               pHitResult);

            // if we failed, assume that it didn't hit.
            if (FAILED(hr)) {
                *pHitResult = HITRESULT_OUTSIDE;
            }
        }

        return S_OK;
    }

    return E_FAIL;

}

HRESULT
DAControlImplementation::InPlaceActivate(LONG iVerb, const RECT* prcPosRect)
{
    TraceTag((tagControlLifecycle,
              "InPlaceActivate @ 0x%x", this));

    HRESULT hr = S_OK;

    if (m_startupState == START_NEEDED) {
        hr = StartControl();
    }

    if (!m_registeredAsActive) {
        InterlockedIncrement(&g_numActivelyRenderingControls);
        m_registeredAsActive = true;
    }

    if (SUCCEEDED(hr))
    {
        m_ctrlBaseEvents->FireStart();
    }
    return hr;
}

STDMETHODIMP
DAControlImplementation::InPlaceDeactivate()
{
    // This replaces the implementation in ATL's atlctl.h, and just
    // adds our shutdown code at the beginning.

    TraceTag((tagControlLifecycle,
              "InPlaceDeactivate @ 0x%x", this));

    // Remove the timer when we're being deactivated.
    StopTimer();

    // If there is a view, tell it to stop, and reset
    // relevant state.
    if (m_view) {
        m_view->StopModel();
    }

    m_view.Release();
    m_msgFilter.SetView(NULL);
    m_msgFilter.SetSite(NULL);
    m_msgFilter.SetWindow(NULL);
    m_startupState = INITIAL;
    m_startupFailed = false;
    m_tickOrRenderFailed = false;
    if (m_szErrorString)
    {
        delete m_szErrorString;
        m_szErrorString = NULL;
    }

    if (m_pixelStatics) {
        m_pixelStatics->put_Site(NULL);
       m_pixelStatics.Release();
    }

    if (m_meterStatics) {
         m_meterStatics->put_Site(NULL);
        m_meterStatics.Release();
    } 

    m_modelImage.Release();
    m_modelBackgroundImage.Release();
    m_modelSound.Release();

    if (m_registeredAsActive) {
        m_registeredAsActive = false;
        InterlockedDecrement(&g_numActivelyRenderingControls);
    }

    return S_OK;
}

// SetObjectRects ??
// ccomcontrolbase::
// m_rcPos  member of base class:

HRESULT
DAControlImplementation::OnDraw(ATL_DRAWINFO& di, HWND window)
{
    HRESULT hr = S_OK;

    // If we're not yet in-place-actived, don't even try to render, as
    // it will fail and throw us into a bad state.
    if (!m_ctrlBase->m_bInPlaceActive) {
        return S_OK;
    }

    if (m_tickOrRenderFailed) {
        //render the error bitmap
        if (m_hErrorBitmap == NULL)
        {
            m_hErrorBitmap = (HBITMAP)LoadImage(_Module.GetResourceInstance(), 
                                                "ErrorBitmap",
                                                IMAGE_BITMAP,
                                                0,     
                                                0,
                                                LR_DEFAULTCOLOR);
            
        }
        
        if (m_hErrorBitmap != NULL)
        {
            HDC memDC = NULL;
            HBITMAP temp = NULL;
            BITMAP bm;

            memDC = CreateCompatibleDC(di.hdcDraw);
            GetObject(m_hErrorBitmap, sizeof(bm), &bm);

            if (memDC)
            {
                temp = (HBITMAP)SelectObject(memDC, m_hErrorBitmap);
                if (temp)
                {
                    BitBlt(di.hdcDraw, 
                           di.prcBounds->left + ((di.prcBounds->right - di.prcBounds->left) / 2) - (bm.bmWidth / 2), 
                           di.prcBounds->top + ((di.prcBounds->bottom - di.prcBounds->top) / 2) - (bm.bmHeight / 2), 
                           bm.bmWidth, 
                           bm.bmHeight, 
                           memDC, 
                           0, 
                           0, 
                           SRCCOPY); 

                    SelectObject(memDC, temp);
                }
                DeleteDC(memDC);
            }
            return hr;
        }

        // If we failed before, return failure all the time.
        return E_FAIL;
    }

#if _DEBUG
    // Turn off assertion popups if this is a windowless drawing.
    // This is because popups freeze the process when you are in an
    // OnDraw method, and windowless is a good indication that that's
    // where we are.  Will turn back on below.
    DisablePopups dp;
#endif    

    // If startup failed, we can't draw anything, so just bail out
    // with failure.
    if (m_startupFailed) {
        return E_FAIL;
    }

    if( (m_startupState >= START_CALLED)) {
        hr = SetUpSurface(di);
        if (FAILED(hr)) {
            FlagFailure();
            return hr;
        }
    }

    if(m_startupState == START_CALLED) {

        // Only call SetModelAndStart2 once all the blocking imports
        // are complete, otherwise, we'll block inside of OnDraw,
        // which is bad.  If we don't call SetModelAndStart2, our
        // state will be the same as it has been, and we'll just do
        // this again on the next OnDraw.

        bool bIsComplete = true;

        // TODO: May need to worry about synchronization around the
        // static libraries
        if (m_pixelStatics.p) {
            VARIANT_BOOL bComplete;
            hr = m_pixelStatics->get_AreBlockingImportsComplete(&bComplete);
            if (FAILED(hr)) {
                FlagFailure();
                return hr;
            }

            if (!bComplete) bIsComplete = false;
        }

        if (bIsComplete && m_meterStatics.p) {
            VARIANT_BOOL bComplete;
            hr = m_meterStatics->get_AreBlockingImportsComplete(&bComplete);
            if (FAILED(hr)) {
                FlagFailure();
                return hr;
            }

            if (!bComplete) bIsComplete = false;
        }

        // Only if all the downloads are complete do we go ahead and
        // start the model.
        if (bIsComplete) {
            hr = SetModelAndStart2(window);
            if (FAILED(hr)) {
                FlagFailure();
                return hr;
            }
            Assert(m_startupState == STARTED);
        }

    } 

    if (m_startupState < STARTED_AND_RENDERABLE)
    {
        return hr;
    }

    if (m_currentState == CUR_PAUSED)
    {
        m_view->Render();
        return hr;
    }

    // Only set the view origin if we are windowless otherwise it is 0,0
    if (m_ctrlBase->m_bWndLess) {
        // Set the view origin each time we come in here.  Count on the
        // message filter to be reasonably smart if these aren't
        // changing.  We do it each time in case it's moving.  Probably
        // can be optimized, but not a big deal.
        m_msgFilter.SetViewOrigin((unsigned short)m_ctrlBase->m_rcPos.left,
                                  (unsigned short)m_ctrlBase->m_rcPos.top);

        hr = DoRender();
        if (FAILED(hr)) return hr;

    } else {

        // Not windowless..., the only way this method would have been
        // called is on a window event, like de-iconify or
        // un-obscure.

        // TODO: prcBounds from ATL is always the entire control
        // area.  Perhaps we want to be smarter by getting the clip
        // rect list out of the dc and using it to repaint.  On the
        // other hand, this shouldn't be called too frequently, so we
        // may be OK.

        LPCRECTL b = di.prcBounds;
        TraceTag((tagControlLifecycle, "Calling Repaint"));
        hr = m_view->RePaint(b->left,
                             b->top,
                             b->right - b->left,
                             b->bottom - b->top);

        if (FAILED(hr)) {
            TraceTag((tagError, "Repaint failed(%hr)", hr));
            m_view->StopModel();
            m_tickOrRenderFailed = true;
            //if no error info is available
            if (!m_szErrorString)
            {
                LoadErrorFromView(m_view, &m_szErrorString, IDS_RENDER_ERROR);
            }
            return hr;
        }
    }

    // Done rendering, allow the system to release the ddsurf it has
    // by stashing NULL in its place.
    if (m_tridentServices && m_ctrlBase->m_bWndLess && m_ddrawSurfaceAsTarget) {
        hr = m_view->put_IDirectDrawSurface(NULL);
        if (FAILED(hr)) return hr;
    } 
        

    return S_OK;
}

HRESULT
DAControlImplementation::MsgHandler(UINT uMsg,
                                    WPARAM wParam,
                                    LPARAM lParam,
                                    BOOL& bHandled)
{
    USES_CONVERSION;
    bHandled = false;
    HRESULT hr = S_OK;
    long xPos = 0;
    long yPos = 0;
    bool bClearError = false;

    switch (uMsg) {
      case WM_LBUTTONUP:
          OnLButtonUp(uMsg, wParam, lParam);
          break;
      case WM_MBUTTONUP:
          OnMButtonUp(uMsg, wParam, lParam);
          break;
      case WM_RBUTTONUP:
          OnRButtonUp(uMsg, wParam, lParam);
          break;
      case WM_LBUTTONDOWN:     
          OnLButtonDown(uMsg, wParam, lParam);
          break;
      case WM_MBUTTONDOWN:
          OnMButtonDown(uMsg, wParam, lParam);
          break;
      case WM_RBUTTONDOWN:     
          OnRButtonDown(uMsg, wParam, lParam);
          break;
      case WM_MOUSEMOVE:
          OnMouseMove(uMsg, wParam, lParam);
          if (m_tickOrRenderFailed)
          {
              xPos = LOWORD(lParam);  // horizontal position of cursor 
              yPos = HIWORD(lParam);  // vertical position of cursor 
              //if the control is windowless
              if (!m_ctrlBase->m_hWndCD)
              {
                 if (!m_bMouseCaptured)
                 {
                     DAComPtr <IOleInPlaceSiteWindowless> pWndlessSite;

                     hr = THR(m_spAptClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void**)&pWndlessSite));
                     if (SUCCEEDED(hr))
                     {
                         pWndlessSite->SetCapture(true);
                         m_bMouseCaptured = true;
                     }
                 }

                 if ((xPos < m_ctrlBase->m_rcPos.left) || 
                     (xPos > m_ctrlBase->m_rcPos.right) ||
                     (yPos < m_ctrlBase->m_rcPos.top) || 
                     (yPos > m_ctrlBase->m_rcPos.bottom))
                  {
                     DAComPtr <IOleInPlaceSiteWindowless> pWndlessSite;

                     hr = THR(m_spAptClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void**)&pWndlessSite));
                     if (SUCCEEDED(hr))
                     {
                         pWndlessSite->SetCapture(false);

                     }
                     m_bMouseCaptured = false;
                     bClearError = true;
                  }
              }
              //else the control is windowed
              else
              {
                  if (!m_bMouseCaptured)
                  {
                      SetCapture(m_ctrlBase->m_hWndCD);
                      m_bMouseCaptured = true;
                  }          
              
                  if ((xPos < 0) || 
                      (xPos > (m_ctrlBase->m_rcPos.right - m_ctrlBase->m_rcPos.left)) ||
                      (yPos < 0) || 
                      (yPos > (m_ctrlBase->m_rcPos.bottom - m_ctrlBase->m_rcPos.top)))
                  {
                      ReleaseCapture();
                      m_bMouseCaptured = false;
                      bClearError = true;
                  }

              }

              //set the status text if the host is IE
              DAComPtr<IOleClientSite> pClient;
              DAComPtr<IOleContainer> pRoot;
              DAComPtr <IHTMLDocument2> pDocument;
              DAComPtr <IHTMLWindow2> pWindow;
  
              hr = THR(m_spAptClientSite->GetContainer(&pRoot));
              if (SUCCEEDED(hr))
              {
                  hr = THR(pRoot->QueryInterface(IID_IHTMLDocument2, (void **)&pDocument));
                  if (SUCCEEDED(hr))
                  {
    
                      hr = THR(pDocument->get_parentWindow(&pWindow));
                      if (SUCCEEDED(hr))
                      {
                          if (bClearError)
                          {
                              BSTR ErrorString;
                              IGNORE_HR(pWindow->get_defaultStatus(&ErrorString));
                              IGNORE_HR(pWindow->put_status(ErrorString));
                              SysFreeString(ErrorString);
                          }
                          else if (!bClearError && m_szErrorString)
                          {
                              BSTR ErrorString = SysAllocString(T2W(m_szErrorString));
                              IGNORE_HR(pWindow->put_status(ErrorString));
                              SysFreeString(ErrorString);
                          }
                      }
                  }
              }
          }
          break;
      case WM_KEYDOWN:
          OnKeyDown(uMsg, wParam, lParam);
          break;
      case WM_KEYUP:
          OnKeyDown(uMsg, wParam, lParam);
          break;
      case WM_CHAR:
          OnChar(uMsg, wParam, lParam);
          break;
    }


        // It must be started and renderable since we may still be waiting
    // for imports and the start time will not be correct
    if (m_startupState < STARTED_AND_RENDERABLE ||
        m_startupFailed ||
        m_tickOrRenderFailed) 
    {

        return 0;

    }

    if (WM_ERASEBKGND == uMsg)
    {
          bHandled = true;
          return 1;
    }

    Assert(m_view && "control needs a view to handle messages!");
    bHandled = m_msgFilter.Filter(GetCurrTime(),
                                  uMsg,
                                  wParam,
                                  lParam);

    return 0;
}


STDMETHODIMP
DAControlImplementation::get_UpdateInterval(double *pVal)
{
    if (!pVal) return E_POINTER;

    *pVal = (float)(m_minimumUpdateInterval) / 1000.0;
    return S_OK;
}

STDMETHODIMP
DAControlImplementation::put_UpdateInterval(double newVal)
{
    m_minimumUpdateInterval = (ULONG)(newVal * 1000.0);

    HRESULT hr = S_OK;

    // Re-establish timer only if we've already been started up.
    if (m_startupState >= START_CALLED) {
        hr = ReestablishTimer();
    }

    return hr;
}


STDMETHODIMP
DAControlImplementation::GetPreference(BSTR prefName,
                                       VARIANT *pVariant)
{
    if (!pVariant) return E_POINTER;

    Lock();

    USES_CONVERSION;
    HRESULT hr = DoPreference(W2A(prefName), false, pVariant);

    Unlock();
    return hr;
}

STDMETHODIMP
DAControlImplementation::SetPreference(BSTR prefName,
                         VARIANT variant)
{
    Lock();

    USES_CONVERSION;
    HRESULT hr = DoPreference(W2A(prefName), true, &variant);

    Unlock();
    return hr;
}


STDMETHODIMP
DAControlImplementation::get_View(IDAView **ppView)
{
    if (!ppView) return E_POINTER;

    HRESULT hr = EnsureViewIsCreated();
    if (SUCCEEDED(hr)) {
        m_view->AddRef();
        *ppView = m_view;
    }

    return hr;
}

STDMETHODIMP
DAControlImplementation::put_View(IDAView *pView)
{
    // Can only set this if we haven't started yet.
    if (m_startupState >= STARTED) {
        return E_FAIL;
    } else {
        m_view.Release();

        return pView->QueryInterface(IID_IDA3View, (void **)&m_view);
    }
}

STDMETHODIMP
DAControlImplementation::get_Image(IDAImage **ppImage)
{
    if (!ppImage) return E_POINTER;

    if (m_modelImage.p) m_modelImage->AddRef();
    *ppImage = m_modelImage;
    return S_OK;
}

STDMETHODIMP
DAControlImplementation::put_Image(IDAImage *pImage)
{
    // Can only set this if we haven't started yet.
    if (m_startupState >= STARTED) {
        return E_FAIL;
    } else {
        m_modelImage = pImage;
        return S_OK;
    }
}

STDMETHODIMP
DAControlImplementation::get_BackgroundImage(IDAImage **ppImage)
{
    if (!ppImage) return E_POINTER;

    if (m_modelBackgroundImage.p) m_modelBackgroundImage->AddRef();
    *ppImage = m_modelBackgroundImage;
    return S_OK;
}

STDMETHODIMP
DAControlImplementation::put_BackgroundImage(IDAImage *pImage)
{
    // Can only set this if we haven't started yet.
    if (m_startupState >= STARTED) {
        return E_FAIL;
    } else {
        m_modelBackgroundImage = pImage;
        m_backgroundSet = true;
        return S_OK;
    }
}

STDMETHODIMP
DAControlImplementation::get_Sound(IDASound **ppSound)
{
    if (!ppSound) return E_POINTER;

    if (m_modelSound.p) m_modelSound->AddRef();
    *ppSound = m_modelSound;
    return S_OK;
}

STDMETHODIMP
DAControlImplementation::put_Sound(IDASound *pSound)
{
    // Can only set this if we haven't started yet.
    if (m_startupState >= STARTED) {
        return E_FAIL;
    } else {
        m_modelSound = pSound;
        return S_OK;
    }
}

STDMETHODIMP
DAControlImplementation::get_OpaqueForHitDetect(VARIANT_BOOL *b)
{
    if (!b) return E_POINTER;

    *b = m_opaqueForHitDetect;

    return S_OK;
}

STDMETHODIMP
DAControlImplementation::put_OpaqueForHitDetect(VARIANT_BOOL b)
{
    m_opaqueForHitDetect = b ? true : false;
    
    return S_OK;
}

STDMETHODIMP
DAControlImplementation::get_TimerSource(DA_TIMER_SOURCE *ts)
{
    if (!ts) return E_POINTER;

    *ts = m_timerSource;

    return S_OK;
}

STDMETHODIMP
DAControlImplementation::put_TimerSource(DA_TIMER_SOURCE ts)
{
    m_timerSource = ts;

    HRESULT hr = S_OK;

    // Re-establish timer only if we've already been started up.
    if (m_startupState >= START_CALLED) {
        hr = ReestablishTimer();
    }

    return hr;
}

STDMETHODIMP
DAControlImplementation::get_PixelLibrary(IDAStatics **ppStatics)
{
    if (!ppStatics) return E_POINTER;

    HRESULT hr = EnsurePixelStaticsIsCreated();
    if (SUCCEEDED(hr)) {
        m_pixelStatics->AddRef();
        *ppStatics = m_pixelStatics;
    }

    return hr;
}

STDMETHODIMP
DAControlImplementation::get_MeterLibrary(IDAStatics **ppStatics)
{
    if (!ppStatics) return E_POINTER;

    HRESULT hr = EnsureMeterStaticsIsCreated();
    if (SUCCEEDED(hr)) {
        m_meterStatics->AddRef();
        *ppStatics = m_meterStatics;
    }

    return hr;
}


// Convenience method for adding behaviors to the view's run list.
// Note that this particular API doesn't allow for removing the
// behavior.  Need to use the View interface directly if that's what
// you want.
STDMETHODIMP
DAControlImplementation::AddBehaviorToRun(IDABehavior *bvr)
{
    HRESULT hr = EnsureViewIsCreated();
    if (FAILED(hr)) return hr;

    LONG cookie;
    hr = m_view->AddBvrToRun(bvr, &cookie);
    Assert(!(FAILED(hr)));

    return hr;
}

// Exported to script, so that a error handler can be registered to be 
// called in the event of an error.
STDMETHODIMP
DAControlImplementation::RegisterErrorHandler(BSTR scriptlet)
{
    HRESULT hr = S_OK;
    Lock();
    delete m_wstrScript;
    if(scriptlet == NULL)
        m_wstrScript = NULL;
    else
    {
        m_wstrScript   = CopyString(scriptlet);
        if(m_wstrScript == NULL)
            hr = E_FAIL;
    }
    Unlock();
    return hr;
}

STDMETHODIMP 
DAControlImplementation::Stop()
{
    if (m_currentState == CUR_STARTED || m_currentState == CUR_PAUSED)
    {
        StopTimer();
        m_view->StopModel();

        m_currentState = CUR_STOPPED;
        m_startupState = INITIAL;
        m_startupFailed = false;
        m_tickOrRenderFailed = false;
        if (m_szErrorString)
        {
            delete m_szErrorString;
            m_szErrorString = NULL;
        }

        m_ctrlBaseEvents->FireStop();

        return S_OK;
    }
    return E_FAIL;    
}


STDMETHODIMP 
DAControlImplementation::Pause()
{
    if (m_currentState == CUR_STARTED)
    {
        m_dPausedTime = GetGlobalTime();
        m_view->Pause();
        m_currentState = CUR_PAUSED;
        
        m_ctrlBaseEvents->FirePause();
        return S_OK;
    }
    return E_FAIL;
}


STDMETHODIMP 
DAControlImplementation::Resume()
{
    HRESULT hr = S_OK;
    if (m_currentState == CUR_PAUSED)
    {   
        m_startTime = GetGlobalTime() - (m_dPausedTime - m_startTime) + 0.0001;
        m_view->Resume();
        m_currentState = CUR_STARTED;
        
        m_ctrlBaseEvents->FireResume();

        return hr;
    }
    return E_FAIL;
}


STDMETHODIMP 
DAControlImplementation::Tick()
{
    IGNORE_HR(InternalTick());
    return S_OK;
}

STDMETHODIMP
DAControlImplementation::Start()
{
    // passed state1
    if (m_startupState >= START_NEEDED) {
        Assert(FALSE && "start has already been called");
        return E_FAIL;
    }

    // If we are not inplaceactive indicate we need to be started
    if (!m_ctrlBase->m_bInPlaceActive) {
        m_startupState = START_NEEDED;
        return S_OK;
    }

    return StartControl();
}

// Could not get the friend working for the timersink class so I
// just made a public function
void DAControlImplementation::ClearTimerSink() { m_timerSink = NULL; }

HRESULT
DAControlImplementation::HandleOnTimer()
{
    Assert (m_minimumUpdateInterval > 0);
    if (m_minimumUpdateInterval > 0)
    {
        IGNORE_HR(InternalTick());
    }

    return S_OK;
}


// Reestablish the Trident timer with the current updateInterval
// property. 
void DAControlImplementation::StopTimer()
{
    ReestablishTridentTimer(false);

    if (m_wmtimerId) {
        DestroyWMTimer(m_wmtimerId);
        m_wmtimerId = 0;
    }
}

// Reestablish the Trident timer with the current updateInterval
// property. 
HRESULT
DAControlImplementation::ReestablishTridentTimer(bool startNewOne)
{
    HRESULT hr = S_OK;

    if (m_adviseCookie) {
        hr = m_timer->Unadvise(m_adviseCookie);
        if (FAILED(hr)) {
            TraceTag((tagError, "Timer::Unadvise failed(%hr)", hr));
        }
        m_adviseCookie = 0;
    }

    if (startNewOne) {

        // Next, get the current time and, with the update interval, set
        // the timer to advise us periodically.
        VARIANT vtimeMin, vtimeMax, vtimeInt;

        VariantInit( &vtimeMin );
        VariantInit( &vtimeMax );
        VariantInit( &vtimeInt );
        V_VT(&vtimeMin) = VT_UI4;
        V_VT(&vtimeMax) = VT_UI4;
        V_VT(&vtimeInt) = VT_UI4;
        V_UI4(&vtimeMin) = 0;
        V_UI4(&vtimeMax) = 0;

        V_UI4(&vtimeInt) = m_tridentTimerInterval;

        hr = m_timer->Advise(vtimeMin,
                             vtimeMax,
                             vtimeInt,
                             0,
                             (ITimerSink *)m_timerSink,
                             &m_adviseCookie);

        if (FAILED(hr) || !m_adviseCookie) {
            TraceTag((tagError, "Timer::Advise failed(%hr)", hr));
        }

    }

    return hr;
}

// Reestablish appropriate timer with the current updateInterval
// property. 
HRESULT
DAControlImplementation::ReestablishTimer()
{
    HRESULT hr = S_OK;

    StopTimer();

    if (m_minimumUpdateInterval == 0)
    {
        return hr;
    }

    DA_TIMER_SOURCE ts;

    switch(m_timerSource) {

      case DAContainerTimer:
        // If they do not have Trident services we do not have
        // container timers so use Multimedia timers
        if (m_tridentServices)
            ts = DAContainerTimer;
        else
            ts = DAWMTimer;
        break;

      case DAMultimediaTimer:
      case DAWMTimer:
      default:
        ts = DAWMTimer;
        break;
    }


    switch(ts) {
      case DAContainerTimer:
        m_tridentTimerInterval = m_minimumUpdateInterval; // initially
        hr = ReestablishTridentTimer(true);
        break;

      case DAWMTimer:
        {
            // Need to setup a WM_TIMER
            m_wmtimerId = CreateWMTimer(m_minimumUpdateInterval,
                                        WMTimerCB,
                                        (DWORD_PTR)this);
            if (m_wmtimerId == 0) {
                TraceTag((tagError, "SetTimer failed(%hr)", hr));
                return E_FAIL;
            }
        }
      break;

      case DAMultimediaTimer:
      default:
        // this would be a bug since the above code should not allow this
        Assert (FALSE && "Invalid TimerSource");
    }

    return hr;
}

HRESULT
DAControlImplementation::InitGenericContainerServices()
{
    m_tridentServices = false;
    HRESULT hr = ReestablishTimer();
    if (FAILED(hr)) {
        return hr;
    }

    hr = m_view->put_CompositeDirectlyToTarget(false);
    if (FAILED(hr)) {
        return hr;
    }

    return S_OK;
}

HRESULT
DAControlImplementation::InitTridentContainerServices()
{
    HRESULT hr = S_OK;

    if (!m_ctrlBase->m_spClientSite) {
        return E_FAIL;
    }

    CComPtr<IServiceProvider> serviceProvider;
    hr = m_ctrlBase->m_spClientSite->QueryInterface(IID_IServiceProvider,
                                        (void**)&serviceProvider);
    if (FAILED(hr)) {
        return hr;
    }

    CComPtr<ITimerService> pTimerService;
    hr = serviceProvider->QueryService(SID_STimerService,
                                       IID_ITimerService,
                                       (void**)&pTimerService);
    if (FAILED(hr)) {
        return hr;
    }

    hr = serviceProvider->QueryService(SID_SDirectDraw3,
                                       IID_IDirectDraw3,
                                       (void**)&m_directDraw3);

    if (FAILED(hr)) {
        return hr;
    }

    hr = pTimerService->GetNamedTimer(NAMEDTIMER_DRAW, &m_timer);

    if (FAILED(hr)) {
        return hr;
    }

    // Create the sink that the timer will call back to.
    m_timerSink = new CDXAControlSink(this);

    // Establish the initial time.
    VariantInit( &m_timeVariant );
    V_VT(&m_timeVariant) = VT_UI4;
    m_timer->GetTime(&m_timeVariant);

    // Set up m_tridentServices flag before setting up the timer.
    m_tridentServices = true;
    m_lastCheckTime = GetCurrentTridentTime();

    hr = ReestablishTimer();

    if (FAILED(hr)) {
        m_tridentServices = false;
        return hr;
    }

    return hr;
}


void
DAControlImplementation::FlagFailure()
{
    m_startupFailed = true;
    m_tickOrRenderFailed = true;

    m_view->StopModel();
    StopTimer(); // stop the timer
    
    if (!m_szErrorString)
    {
       m_szErrorString = NEW TCHAR[256];
       if (m_szErrorString)
       {
           LoadString(_Module.GetResourceInstance(), 
              IDS_UNEXPECTED_ERROR,
              m_szErrorString, 
              256);
       }
       m_ctrlBase->FireViewChange();
    }
}

HRESULT
DAControlImplementation::SetUpSurface(ATL_DRAWINFO& di)
{
    // Grab and set appropriate surface.
    HRESULT hr = S_OK;
    CComPtr<IDirectDrawSurface> pDDrawSurf;

    if (m_ctrlBase->m_bWndLess) {

        if (m_tridentServices) {

            if(di.hdcDraw==NULL) {
                return E_INVALIDARG;            
            }

            hr = m_directDraw3->GetSurfaceFromDC(di.hdcDraw,
                                                 &pDDrawSurf);
            if (SUCCEEDED(hr)) {

                hr = m_view->put_IDirectDrawSurface(pDDrawSurf);
                if (FAILED(hr)) {
                    TraceTag((tagError, "put_IDirectDrawSurface failed(%hr)", hr));
                    return hr;
                }
                m_ddrawSurfaceAsTarget = true;
                
                hr = m_view->put_CompositeDirectlyToTarget(true);
                
                if (FAILED(hr)) {
                    TraceTag((tagError, "CompositeDirectlyToTarget failed(%hr)", hr));
                    return hr;
                }

            } else {

                m_ddrawSurfaceAsTarget = false;
                
            }
        }

        if( !m_ddrawSurfaceAsTarget ) {

            // Use generic services by passing down the DC to render
            // to. 
            hr = m_view->put_DC(di.hdcDraw);
            if (FAILED(hr)) {
                TraceTag((tagError, "put_HDC failed(%hr)", hr));
                return hr;
            }

        }
    }

    // View takes a viewport and a clip rectangle that are
    // in DEVICE coordinates and are RELATIVE to the given surface


    //
    // Get the bounds in DC coords and convert to
    // Device coords
    //
    RECT rcDeviceBounds = *((RECT *)di.prcBounds);
    LPtoDP(di.hdcDraw, (POINT *) &rcDeviceBounds, 2);

    if (!(rcDeviceBounds == m_lastDeviceBounds)) {

        hr = m_view->SetViewport(rcDeviceBounds.left,
                                 rcDeviceBounds.top,
                                 rcDeviceBounds.right - rcDeviceBounds.left,
                                 rcDeviceBounds.bottom - rcDeviceBounds.top);
        if (FAILED(hr)) {
            TraceTag((tagError, "SetViewport failed(%hr)", hr));
            return hr;
        }

        m_lastDeviceBounds = rcDeviceBounds;
        
    }

    if (m_ctrlBase->m_bWndLess) {
        //
        // Get the clip rect (should be region) in
        // DC coords and convert to Device coords
        //
        // TODO: more robust to use GetClipRgn
        RECT rcClip;  // in dc coords
        GetClipBox(di.hdcDraw, &rcClip);
        LPtoDP(di.hdcDraw, (POINT *) &rcClip, 2);

        if (!(rcClip == m_lastRcClip)) {

            hr = m_view->SetClipRect(rcClip.left,
                                     rcClip.top,
                                     rcClip.right - rcClip.left,
                                     rcClip.bottom - rcClip.top);
            if (FAILED(hr)) {
                TraceTag((tagError, "SetViewport failed(%hr)", hr));
                return hr;
            }

            m_lastRcClip = rcClip;

        }
    }

    return hr;
}



ULONG
DAControlImplementation::GetCurrentTridentTime()
{
    HRESULT hr = m_timer->GetTime(&m_timeVariant);
    Assert(SUCCEEDED(hr));
    return (V_UI4(&m_timeVariant));
}


DWORD
DAControlImplementation::GetPerfTickCount()
{
    LARGE_INTEGER lpc;
    BOOL result = QueryPerformanceCounter(&lpc);
    return lpc.LowPart;
}

void
DAControlImplementation::StartPerfTimer()
{
    m_perfTimerStart = GetPerfTickCount();
}

void
DAControlImplementation::StopPerfTimer()
{
    DWORD ticks;

    if (GetPerfTickCount() < m_perfTimerStart) {
        // timer wrapped around (very rare), just grab amount from 0. 
        ticks = GetPerfTickCount();
    } else {
        ticks = GetPerfTickCount() - m_perfTimerStart;
    }

    m_perfTimerTickCount += ticks;
}

void
DAControlImplementation::ResetPerfTimer()
{
    m_perfTimerTickCount = 0;
}

ULONG
DAControlImplementation::GetPerfTimerInMillis()
{
    float f = ((double) m_perfTimerTickCount) /
        (double) m_perfCounterFrequency;

    return (ULONG)(f * 1000);
}


HRESULT
DAControlImplementation::DoRender()
{
    StartPerfTimer();    
    HRESULT hr = m_view->Render();
    StopPerfTimer();

    if (DA_FAILED(hr))
    {
        TraceTag((tagError,"Control: failed in Render - %hr", hr));
        m_view->StopModel();
        m_tickOrRenderFailed = true;
        
        //if no error info is available
        if (!m_szErrorString)
        {
            LoadErrorFromView(m_view, &m_szErrorString, IDS_RENDER_ERROR);
        }

        return hr;
    }

    ULONG thisFrameTime = GetPerfTimerInMillis();
    hr = PossiblyUpdateTimerInterval(thisFrameTime);

    return hr;
}

HRESULT
DAControlImplementation::PossiblyUpdateTimerInterval(ULONG newFrameTime)
{
    HRESULT hr = S_OK;

    if (!m_adviseCookie) {
        // Not using Trident timers...

        // Check to see if we wanted to be using Trident timers,
        // but backed off because we had multiple controls. 
        if (m_origTimerSource == DAContainerTimer &&
            g_numActivelyRenderingControls == 1) {

            m_timerSource = DAContainerTimer;
            hr = ReestablishTimer();

        }

        return hr;
    }

    m_frameNumber++;
    m_framesThisCycle++;
    m_timeThisCycle += newFrameTime;

    const ULONG millisBetweenChecks = 2000;

    ULONG millisSoFar =
        GetCurrentTridentTime() - m_lastCheckTime;

    // Check after the third frame to get to the desired rate as
    // quickly as possible, and then periodically after that. 
    if (m_frameNumber == 3 ||
        millisSoFar >= millisBetweenChecks) {

        // Look into re-establishing the timer.
        float millisPerFrame =
            ((float)m_timeThisCycle) / ((float)m_framesThisCycle); 

        // If the number of controls has gotten above 1, then back
        // the control off to WM_TIMERs if we're using Trident
        // timers.
        if (g_numActivelyRenderingControls > 1) {

            Assert(m_timerSource == DAContainerTimer);
            m_origTimerSource = DAContainerTimer;
            m_timerSource = DAWMTimer;
            hr = ReestablishTimer();
            return hr;

        }

        Assert(g_numActivelyRenderingControls == 1);

        float newSleepAmt =
            millisPerFrame / m_desiredCPUUsageFrac;

        // Clamp to the minimum.  We don't clamp to a max because
        // that may always result in swamping the timers.
        if (newSleepAmt < m_minimumUpdateInterval) {
            newSleepAmt = m_minimumUpdateInterval;
        }

        const float currSleepAmt = (float)m_tridentTimerInterval;

        // Percent different the old amount has to be from the new
        // amount to warrant a change to the timer.
        const float differenceThresholdPercent = 0.15f;

        if ((fabs(currSleepAmt - newSleepAmt) / currSleepAmt) >
            differenceThresholdPercent) {

            TraceTag((tagControlLifecycle,
                      "Ctrl 0x%x of %d: Resetting update interval from %d msec to %d msec.",
                      this,
                      g_numActivelyRenderingControls,
                      m_tridentTimerInterval,
                      (ULONG)newSleepAmt));

            m_tridentTimerInterval = (ULONG)newSleepAmt;
            hr = ReestablishTridentTimer(true);
        }

        m_framesThisCycle = 0;
        m_timeThisCycle = 0;

        m_lastCheckTime = GetCurrentTridentTime();
    }

    return hr;

}

double DAControlImplementation::GetGlobalTime()
{
    // TODO: Note that this timer stuff is somewhat suspect, in that
    // it only uses a DWORD, and thus will wrap around every 49 or so
    // days.  Using the Trident timer services, we don't have much of
    // a choice.  Should generally be reasonable to be doing this,
    // though we should be aware of the issue.

    // Get the current time differently depending on whether we're
    // using Trident timing services.
    if (m_tridentServices) {
        m_timer->GetTime(&m_timeVariant);

        return (V_UI4(&m_timeVariant) / 1000.0);
    } else {
        return ::GetCurrTime();
    }
}

double DAControlImplementation::GetCurrTime()
{
    // Since m_startTime is not valid until started and renderable
    // assert if we are not in this state.
    Assert (m_startupState >= STARTED_AND_RENDERABLE);

    return (GetGlobalTime() - m_startTime);
}



HRESULT
DAControlImplementation::NewStaticsObject(IDAStatics **ppStatics)
{
    HRESULT  hr = CoCreateInstance(CLSID_DAStatics,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IDAStatics,
                                   (void **) ppStatics);

    if(FAILED(hr))
    {
        TraceTag((tagError, "statics creation failed(%hr)", hr));
        return hr;
    }

    // Immediately set the client site on the statics object.
    hr = (*ppStatics)->put_ClientSite(m_ctrlBase->m_spClientSite);

    if (FAILED(hr))
    {
        TraceTag((tagError, "setting client site failed(%hr)", hr));
    }

    // Initialize the Marshaled pointer 
    m_spAptClientSite = m_ctrlBase->m_spClientSite;

    hr = (*ppStatics)->put_Site(m_daSite);

    if (FAILED(hr))
    {
        TraceTag((tagError, "setting IDASite failed(%hr)", hr));
    }

    return hr;
}

HRESULT
DAControlImplementation::EnsureMeterStaticsIsCreated()
{
    HRESULT hr = S_OK;

    Lock();
    if (!m_meterStatics) {
        hr = NewStaticsObject(&m_meterStatics);
    }
    Unlock();

    return hr;
}

HRESULT
DAControlImplementation::EnsurePixelStaticsIsCreated()
{
    HRESULT hr = S_OK;

    Lock();
    if (!m_pixelStatics) {
        hr = NewStaticsObject(&m_pixelStatics);
        if (FAILED(hr)) {
            TraceTag((tagError, "pixel statics creation failed(%hr)", hr));
        } else {
            hr = m_pixelStatics->put_PixelConstructionMode(TRUE);

            if (FAILED(hr)) {
                TraceTag((tagError, "failed to set pixel mode failed(%hr)", hr));
                m_pixelStatics.Release();
            }
        }
    }
    Unlock();

    return hr;
}

HRESULT
DAControlImplementation::EnsureViewIsCreated()
{
    HRESULT hr = S_OK;

    Lock();

    if (!m_view) {
        hr = CoCreateInstance(CLSID_DAView,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDA3View,
                              (void **) &m_view);

        TraceTag((tagError, "view creation failed(%hr)", hr));
    }
    Unlock();

    return hr;
}


HRESULT
DAControlImplementation::StartControl()
{
    HRESULT hr = S_OK;

    hr = EnsureViewIsCreated();
    if (FAILED(hr)) {
        goto Cleanup;
    }

    if (!m_modelImage || !m_modelSound || !m_modelBackgroundImage) {

        hr = EnsureMeterStaticsIsCreated();
        if (FAILED(hr)) {
            goto Cleanup;
        }

        if (!m_modelImage) {
            hr = m_meterStatics->get_EmptyImage(&m_modelImage);
            if (FAILED(hr)) {
                TraceTag((tagError, "empty image creation failed(%hr)", hr));
                goto Cleanup;
            }
        }

        // TODO: May want to consider making the default background
        // image a solid color image of the bg color of the
        // container. 
        if (!m_modelBackgroundImage) {
            hr = m_meterStatics->get_EmptyImage(&m_modelBackgroundImage);
            if (FAILED(hr)) {
                TraceTag((tagError, "empty image creation failed(%hr)", hr));
                goto Cleanup;
            }
        }

        if (!m_modelSound) {
            hr = m_meterStatics->get_Silence(&m_modelSound);
            if (FAILED(hr)) {
                TraceTag((tagError, "silence creation failed(%hr)", hr));
                goto Cleanup;
            }
        }
    }

    // Initialize timer upon start.  Don't do at it construction
    // time, because not everything is setup that needs to be (in
    // particular, the client site is not yet set.)

    // TODO: This should be done at inplaceactivate time I think (kgallo)

    hr = InitTridentContainerServices();
    if (FAILED(hr)) {

        // If this doesn't work, the only "valid" reason is if we're
        // not in a container that supports Trident's ITimer and
        // surface factory services.  In this case, fall back to
        // different means of getting these services.

        hr = InitGenericContainerServices();
        if (FAILED(hr)) {
            // If this doesn't work, then we need to give up.
            goto Cleanup;
        }

    }
    m_currentState = CUR_STARTED;
    m_startupState = START_CALLED;

 Cleanup:    
    return hr;
}

// Only can get here if start has been called.
HRESULT
DAControlImplementation::SetModelAndStart2(HWND window)
{
    HRESULT hr = S_OK;

    CComPtr<IDAImage> imageToUse;

    if (m_ctrlBase->m_bWndLess) {

        // If windowless, don't use the background image. 
        imageToUse = m_modelImage;

    } else {

        hr = m_view->put_Window2(m_ctrlBase->m_hWndCD);

        if (FAILED(hr)) {
            TraceTag((tagError, "put_Window failed(%hr)", hr));
            return hr;
        }

        m_ddrawSurfaceAsTarget = false;
        
        hr = EnsureMeterStaticsIsCreated();
        if (FAILED(hr)) {
            return hr;
        }

        if (m_backgroundSet) {
           hr = m_meterStatics->Overlay(m_modelImage,
                                        m_modelBackgroundImage,
                                        &imageToUse);
           if (FAILED(hr)) {
               TraceTag((tagError, "Overlay failed(%hr)", hr));
               return hr;
           }
        } else {
           imageToUse = m_modelImage;
        }
    }

    m_view->put_ClientSite(m_ctrlBase->m_spClientSite);

    // Always start at 0 and then sync the clock itself
    hr = m_view->StartModelEx(imageToUse, m_modelSound, 0, DAAsyncFlag);

    if (FAILED(hr) && hr != E_PENDING) {
        TraceTag((tagError, "StartModelEx failed with hr=%x\n",hr));
        return hr;
    }

    m_msgFilter.SetView(m_view);
    if (window)
        m_msgFilter.SetWindow(window);

    if (m_ctrlBase->m_bWndLess)
        m_msgFilter.SetSite(m_ctrlBase->m_spInPlaceSite);

    m_startupState = STARTED;

    return S_OK;
}


HRESULT
DAControlImplementation::DoPreference(char *prefName,
                                      bool puttingPref,
                                      VARIANT *pV)
{
    HRESULT hr = S_OK;
    Bool b;
    double dbl;
    int i;

    if (!puttingPref) {
        // Getting a preference, so clear out the variant first 
        VariantClear(pV);
    }

    DOUBLE_ENTRY("DesiredCPUUsageFraction",
                 m_desiredCPUUsageFrac); 

    // If we get here, we've hit an invalid entry, but just return.
    return S_OK;
}


// =========================================
// Initialization
// =========================================

void
InitializeModule_Control()
{
    RegisterWindowClass();
    win32Timer = NEW Win32Timer;
}

void
DeinitializeModule_Control(bool bShutdown)
{
    delete win32Timer;
}



//IPersistPropertyBag
HRESULT 
DAControlImplementation::InitNew()
{
    return S_OK;
}

HRESULT 
DAControlImplementation::Load(IPropertyBag* pPropBag, IErrorLog* pErrorLog)
{
    VARIANT vPropVal;
    HRESULT hr = S_OK;

    VariantInit (&vPropVal);

    // get OpaqueForHitDetect
    vPropVal.vt = VT_BOOL;
    hr = THR(pPropBag->Read(PROP_OPAQUEFORHITDETECT, &vPropVal, pErrorLog));
    if (FAILED(hr)) //default to False
    {
        vPropVal.boolVal = VARIANT_FALSE;
    }
    IGNORE_HR(put_OpaqueForHitDetect(vPropVal.boolVal));
    VariantClear(&vPropVal);

    // get UpdateInterval
    vPropVal.vt = VT_R8;
    hr = THR(pPropBag->Read(PROP_UPDATEINTERVAL, &vPropVal, pErrorLog));
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
        if (vPropVal.vt != VT_R8)
        {
            hr = VariantChangeType(&vPropVal, &vPropVal, 0, VT_R8);
        }
        if (SUCCEEDED(hr))
        {
            IGNORE_HR(put_UpdateInterval(vPropVal.dblVal));
        }
        
    }

    VariantClear(&vPropVal);
    return S_OK;
}

HRESULT 
DAControlImplementation::Save(IPropertyBag* pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    VARIANT vPropVal;
    HRESULT hr = S_OK;

    VariantInit (&vPropVal);

    //OpaqueForHitDetect
    vPropVal.vt = VT_BOOL;
    hr = THR(get_OpaqueForHitDetect(&vPropVal.boolVal));
    if (FAILED (hr)) //default to False
    {
        vPropVal.boolVal = VARIANT_FALSE;
    }
    pPropBag->Write(PROP_OPAQUEFORHITDETECT, &vPropVal);
    VariantClear(&vPropVal);

    //UpdateInterval
    vPropVal.vt = VT_R8;
    hr = THR(get_UpdateInterval(&vPropVal.dblVal));
    if (SUCCEEDED(hr))
    {
        pPropBag->Write(PROP_UPDATEINTERVAL, &vPropVal);
    }
    VariantClear(&vPropVal);

    return S_OK;
}


//Event handlers
HRESULT 
DAControlImplementation::OnLButtonUp(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    SIZE szPixels;
    m_ctrlBaseEvents->FireMouseUp(MK_LBUTTON, 
                                   wParam & (MK_CONTROL + MK_SHIFT), 
                                   (short int)LOWORD(lParam), 
                                   (short int)HIWORD(lParam));   
    
    DWORD dwHitResult = 0;
    POINT Point;

    Point.x = (short int)(LOWORD(lParam));
    Point.y = (short int)(HIWORD(lParam));
    THR(QueryHitPoint(DVASPECT_CONTENT,
                      &(m_ctrlBase->m_rcPos),
                      Point,
                      3,
                      &dwHitResult));
    if (dwHitResult)
    {   
        m_ctrlBase->SetControlFocus(true); 
        m_ctrlBaseEvents->FireClick();   
    }

    return S_OK;
}

HRESULT 
DAControlImplementation::OnMButtonUp(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    m_ctrlBaseEvents->FireMouseUp(MK_MBUTTON, 
                                   wParam & (MK_CONTROL + MK_SHIFT), 
                                   (short int)LOWORD(lParam), 
                                   (short int)HIWORD(lParam));
    
    return S_OK;
}

HRESULT 
DAControlImplementation::OnRButtonUp(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    m_ctrlBaseEvents->FireMouseUp(MK_RBUTTON, 
                                   wParam & (MK_CONTROL + MK_SHIFT), 
                                  (short int)LOWORD(lParam), 
                                  (short int)HIWORD(lParam));        
    return S_OK;
}

HRESULT 
DAControlImplementation::OnLButtonDown(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    m_ctrlBaseEvents->FireMouseDown(MK_LBUTTON, 
                                     wParam & (MK_CONTROL + MK_SHIFT), 
                                    (short int)LOWORD(lParam), 
                                    (short int)HIWORD(lParam));
    return S_OK;
    
}

HRESULT 
DAControlImplementation::OnMButtonDown(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    m_ctrlBaseEvents->FireMouseDown(MK_MBUTTON, 
                                     wParam & (MK_CONTROL + MK_SHIFT), 
                                    (short int)LOWORD(lParam), 
                                    (short int)HIWORD(lParam));
    return S_OK;
}

HRESULT 
DAControlImplementation::OnRButtonDown(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    m_ctrlBaseEvents->FireMouseDown(MK_RBUTTON, 
                                     wParam & (MK_CONTROL + MK_SHIFT), 
                                    (short int)LOWORD(lParam), 
                                    (short int)HIWORD(lParam));
    return S_OK;
}

HRESULT 
DAControlImplementation::OnMouseMove(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    m_ctrlBaseEvents->FireMouseMove(wParam & (MK_LBUTTON + MK_RBUTTON + MK_MBUTTON), 
                                     wParam & (MK_CONTROL + MK_SHIFT), 
                                    (short int)LOWORD(lParam), 
                                    (short int)HIWORD(lParam));
    return S_OK;
}


HRESULT 
DAControlImplementation::OnKeyDown(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    m_ctrlBaseEvents->FireKeyDown(wParam, lParam);
    return S_OK; 
}

HRESULT 
DAControlImplementation::OnKeyUp(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    m_ctrlBaseEvents->FireKeyUp(wParam, lParam);
    return S_OK;
}
HRESULT 
DAControlImplementation::OnChar(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    m_ctrlBaseEvents->FireKeyPress((TCHAR)wParam);
    return S_OK;
}


HRESULT 
DAControlImplementation::InternalTick()
{
    HRESULT hr = S_OK;

    if (m_tickOrRenderFailed) {
        return E_FAIL;
    }

    double time;

    // When a timer event comes in, just notify that the view has
    // changed, and then update.  Only do so if we've started, and
    // tick or render hasn't failed.

    switch (m_startupState) {

      case START_CALLED:
        // Need to cause an invalidate once start has been called,
        // just to fire things off in the right order.

        m_ctrlBase->FireViewChange();
        return S_OK;

      case STARTED:
        time = 0;

        // Always store the start time before the tick to ensure we
        // get an accurate time if the tick succeeds

        m_startTime = GetGlobalTime();

        break;

      case STARTED_AND_RENDERABLE:
        time = GetCurrTime();
        break;

      default:
        return S_OK;
    }

    VARIANT_BOOL needToRender;

    ResetPerfTimer();
    StartPerfTimer();
    hr = m_view->Tick(time, &needToRender);
    StopPerfTimer();

    if (DA_FAILED(hr))
    {
        // Set the failure flag first since the Assert can
        // cause us to get reentered
        m_view->StopModel();
        m_tickOrRenderFailed = true;
        TraceTag((tagError,"Control: failed in Tick"));
        //if no error info is available
        if (!m_szErrorString)
        {
            LoadErrorFromView(m_view, &m_szErrorString, IDS_TICK_ERROR);
        }
        return hr;
    }

    // But only programmatically cause an invalidation if a
    // rendering is needed. If E_PENDING or DAERR_VIEW_LOCKED is
    // returned then needToRender is false

    if (needToRender) {
        // This really only needs to be set 
        m_startupState = STARTED_AND_RENDERABLE;

        // Disable assertion popups; otherwise we restart rendering and do the
        // same popup over and over.

#if _DEBUG          
        DisablePopups dp;
#endif
        if (m_ctrlBase->m_bWndLess) {

            // TODO: Make more dynamic
#define MAX_RECTS 15
            RECT dirtyRects[MAX_RECTS];
            LONG numRects;
            hr = m_view->GetInvalidatedRects(NULL,
                                             MAX_RECTS,
                                             dirtyRects,
                                             &numRects);

            if (FAILED(hr)) {
                TraceTag((tagError,"Control: failed in Render"));
                m_view->StopModel();
                m_tickOrRenderFailed = true;

                //if no error info is available
                if (!m_szErrorString)
                {
                    LoadErrorFromView(m_view, &m_szErrorString, IDS_RENDER_ERROR);
                }
                return hr;
            }

            // TODO: Fill in when ready.
            if (true || numRects == 0 || numRects > MAX_RECTS) {

                m_ctrlBase->FireViewChange();

            } else {

                // Modified from atl21/atlctl.cpp,
                // CComControlBase::FireViewChange()
                if (m_ctrlBase->m_bInPlaceActive &&
                    m_ctrlBase->m_spInPlaceSite != NULL) {

                    int rectsToDo =
                        numRects > MAX_RECTS ? MAX_RECTS : numRects;

                    RECT *rect = dirtyRects;
                    for (int i = 0; i < rectsToDo; i++) {

                        hr = m_ctrlBase->m_spInPlaceSite->
                            InvalidateRect(rect, TRUE);

                        if (FAILED(hr)) {
                            TraceTag((tagError, "Invalidate rects failed(%hr)", hr));
                            m_view->StopModel();
                            m_tickOrRenderFailed = true;
                            
                            //if no error info is available
                            if (!m_szErrorString)
                            {
                               m_szErrorString = NEW TCHAR[256];
                               if (m_szErrorString)
                               {
                                   LoadString(_Module.GetResourceInstance(), 
                                      IDS_RENDER_ERROR,
                                      m_szErrorString, 
                                      256);
                               }
                               m_ctrlBase->FireViewChange();
                            }

                            return hr;
                        }
                        rect++;
                    }
                }
            }

        } else {

            hr = DoRender();
            if (FAILED(hr)) return hr;

        }
    }

    return hr;
}


HRESULT 
DAControlImplementation::LoadErrorFromView(IDA3View *view, LPTSTR *ErrorString, UINT ErrorID)
{
    USES_CONVERSION;

    //get the error from the interface
    HRESULT hr = S_OK;
    DAComPtr <IErrorInfo> pErrorInfo;
    DAComPtr <ISupportErrorInfo> pSupportErrorInfo;

    hr = THR(view->QueryInterface(IID_ISupportErrorInfo, (void**)&pSupportErrorInfo));
    if (SUCCEEDED(hr))
    {
        hr = pSupportErrorInfo->InterfaceSupportsErrorInfo(IID_IDA3View);
        if (hr == S_OK)
        {
            hr = GetErrorInfo(0, &pErrorInfo);
            if (hr == S_OK)
            {
                BSTR bstrErrorDesc;
                hr = THR(pErrorInfo->GetDescription(&bstrErrorDesc));
                if (SUCCEEDED(hr))
                {
                    LPTSTR temp;
                    temp  = OLE2T(bstrErrorDesc);
                    if (temp)
                    {
                        *ErrorString = NEW TCHAR[SysStringLen(bstrErrorDesc) + 1];
                        if (*ErrorString)
                        {
                            _tcscat(*ErrorString, temp);
                        }
                    }
                    SysFreeString(bstrErrorDesc);
                }
            }
        }
    }
    //or load a generic error message
    if (!m_szErrorString)
    {
       *ErrorString = NEW TCHAR[256];
       if (*ErrorString)
       {
           LoadString(_Module.GetResourceInstance(), 
              ErrorID,
              *ErrorString, 
              256);
       }
       m_ctrlBase->FireViewChange();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\control\filter.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implements windowless controls ViewFilter and ViewFilterSite
    interfaces. 

*******************************************************************************/


STDMETHOD(SetSource)(IViewFilter *pFilter)
{
    HRESULT hr = S_OK;
    
    // If there already is a filter established, then we want to
    // deactivate and prepare to start again.
    if (m_pViewSourceFilter.p) {
        InPlaceDeactivate();
    }
    
    m_pViewSourceFilter = pFilter;
    if (m_pViewSourceFilter.p) {
        hr = m_pViewSourceFilter->SetSite(this);
        if (FAILED(hr)) return hr;
    }

    if (m_pViewFilterSite.p) {
        m_pViewFilterSite->InvalidateRect(NULL, FALSE);
        if (FAILED(hr)) return hr;
    }

    return hr;
}

STDMETHOD(GetSource)(IViewFilter **ppFilter)
{
    if (!ppFilter) return E_POINTER;

    *ppFilter = m_pViewSourceFilter;
    if (*ppFilter) {
        (*ppFilter)->AddRef();
    }

    return S_OK;
}

STDMETHOD(SetSite)(IViewFilterSite *pSite)
{
    m_pViewFilterSite = pSite;
    
    return S_OK;
}

STDMETHOD(GetSite)(IViewFilterSite **ppSite)
{
    if (!ppSite) return E_POINTER;

    *ppSite = m_pViewFilterSite;
    if (*ppSite) {
        (*ppSite)->AddRef();
    }

    return S_OK;
}

STDMETHOD(SetPosition)(LPCRECT prc)
{
    HRESULT hr = S_OK;
    if (prc) {
        
        m_rcPos  = *prc;

        if (m_pViewSourceFilter) {
            hr = m_pViewSourceFilter->SetPosition(prc);
            if (FAILED(hr)) return hr;
        }
    }

    return hr;
}

STDMETHOD(Draw)(HDC hdc, LPCRECT prcBounds)
{
    HRESULT hr;
    
    // First time through?
    if (m_usedAsViewFilter == IS_NOT_A_VIEW_FILTER) {
        
        m_usedAsViewFilter = SETTING_UP_AS_A_VIEW_FILTER;

        hr = Start();
        if (FAILED(hr)) return hr;
    }

    if (!hdc || !prcBounds) {
        return E_INVALIDARG;
    }

    // Only if there is both a filter site, and we care about the
    // input image do we need to do this stuff.
    if (m_pViewFilterSite.p && m_inputImage.p) {

        // Grab ddsurf to render into, grab its HDC, tell upstream to
        // render, release dc.  When done, our ddraw surf will have
        // the upstream bits in it.
        IDirectDrawSurface *upstreamDDSurf;
        HDC upstreamHDC;
        RECT normalizedRect;
        if (FAILED(hr = GrabUpstreamDDrawSurf(prcBounds,
                                              &upstreamDDSurf,
                                              &normalizedRect)) ||
            FAILED(hr = upstreamDDSurf->GetDC(&upstreamHDC)) ||
            FAILED(hr = m_pViewSourceFilter->Draw(upstreamHDC, &normalizedRect)) ||
            FAILED(hr = upstreamDDSurf->ReleaseDC(upstreamHDC))) {

            return hr;
        }
    }
    
    // Call the generic OnDraw method.
    ATL_DRAWINFO drawInfo;
    RECTL newBounds;
    drawInfo.prcBounds = &newBounds;

    newBounds.top    = prcBounds->top;
    newBounds.left   = prcBounds->left;
    newBounds.right  = prcBounds->right;
    newBounds.bottom = prcBounds->bottom;
        
    drawInfo.hdcDraw = hdc;
        
    hr = OnDraw(drawInfo);

    return hr;
}

static HRESULT
SetupColorKey(IDirectDrawSurface *pSurf,
              int height,
              int width)
{
    HRESULT hr;

    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);
    if (FAILED(hr = pSurf->GetSurfaceDesc(&ddsd))) return hr;

    DDPIXELFORMAT ddpf = ddsd.ddpfPixelFormat;

    // TODO: Get color key to use out of the registry.
    const BYTE ckRed = 1;
    const BYTE ckGreen = 245;
    const BYTE ckBlue = 254;

    DWORD fillValue;
    switch (ddpf.dwRGBBitCount) {
      case 32:
      case 24:
        fillValue = ckRed << 16 | ckGreen << 8 | ckBlue;
        break;

      case 16:
        // Assume 5/6/5 color cube.  If we're wrong, that's OK, the
        // color key will just be different from what we thought.
        {
            const BYTE red5 =
                (BYTE)(((double)ckRed / 256.0) * (double)(1 << 5));
            const BYTE green6 =
                (BYTE)(((double)ckGreen / 256.0) * (double)(1 << 6));
            const BYTE blue5 =
                (BYTE)(((double)ckBlue / 256.0) * (double)(1 << 5));

            fillValue = red5 << 11 | green6 << 5 | blue5;
        }
        break;
        
      default:
        // TODO: Can't deal with 8bit right now.
        return E_NOTIMPL;
    }

    // Fill in the surface with our color key, then tell ddraw that
    // this is our colorkey.
    DDBLTFX fx;
    ZeroMemory(&fx, sizeof(DDBLTFX));
    fx.dwSize = sizeof(DDBLTFX);
    fx.dwFillColor = fillValue;

    RECT r;
    r.top = r.left = 0;
    r.bottom = height;
    r.right = width;

    DDCOLORKEY ckey;
    ckey.dwColorSpaceLowValue = fillValue;
    ckey.dwColorSpaceHighValue = fillValue;
    
    if (FAILED(hr = pSurf->Blt(&r,
                               NULL,
                               NULL,
                               DDBLT_COLORFILL | DDBLT_WAIT,
                               &fx)) ||
        FAILED(hr = pSurf->SetColorKey(DDCKEY_SRCBLT, &ckey))) {

        return hr;
    }
                                       
    return hr;
}

HRESULT
GrabUpstreamDDrawSurf(LPCRECT prcBounds,
                      IDirectDrawSurface **ppSurf,
                      LPRECT normalizedRect)
{
    HRESULT hr;
    
    // If surface is big enough, just return it.
    unsigned short width = prcBounds->right - prcBounds->left;
    unsigned short height = prcBounds->bottom - prcBounds->top;

    normalizedRect->top = normalizedRect->left = 0;
    normalizedRect->right = width;
    normalizedRect->bottom = height;
    
    if (m_upstreamDDSurfWidth < width ||
        m_upstreamDDSurfHeight < height) {

        // Else, release surface if it's there, and create new one.
        if (m_upstreamDDSurf.p) {
            m_upstreamDDSurf.Release();
        }

        // Create a surface of the appropriate dimensions

        m_upstreamDDSurfWidth = width;
        m_upstreamDDSurfHeight = height;
    
        DDSURFACEDESC       ddsd;
        ZeroMemory(&ddsd, sizeof(ddsd));

        ddsd.dwSize = sizeof( ddsd );
        ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
        ddsd.dwWidth  = width;
        ddsd.dwHeight = height;
        ddsd.ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY |
                              DDSCAPS_OWNDC;

        if (FAILED(hr = m_directDraw3->CreateSurface(&ddsd,
                                                     &m_upstreamDDSurf,
                                                     NULL))) {
            return hr;
        }

        // Be sure that the input image is created.
        if (!m_inputImage) {
            CComPtr<IDAImage> fakeImage; // don't care about keeping this.
            if (FAILED(hr = get_InputImage(&fakeImage))) {
                return hr;
            }
        }

        Assert(m_inputImage.p && "Shouldn't be here with inputImage set");
        
        // Now, take this guy and import into DA as an imported ddraw
        // image, then switch our input image to this behavior.
        EnsureMeterStaticsIsCreated();
        CComPtr<IDAImage> importedDDrawImage;
        if (FAILED(hr = m_meterStatics->ImportDirectDrawSurface(
                           m_upstreamDDSurf,
                           NULL,
                           &importedDDrawImage)) ||
            FAILED(hr = m_inputImage->SwitchTo(importedDDrawImage))) {

            return hr;
        }
    }

    if (FAILED(hr = SetupColorKey(m_upstreamDDSurf,
                                  height,
                                  width))) {
        return hr;
    }

    *ppSurf = m_upstreamDDSurf;
    return S_OK;
}

STDMETHOD(GetStatusBits)(DWORD *pdwFlags)
{
    if (!pdwFlags)
        return E_POINTER;

    *pdwFlags = 0;
    return S_OK;
}

// IViewFilterSite methods

// Don't support GetDC and ReleaseDC being called from upstream.
STDMETHOD(GetDC)(LPCRECT prc,
                 DWORD dwFlags,
                 HDC *phdc)
{
    return E_NOTIMPL;
}

STDMETHOD(ReleaseDC)(HDC hdc)
{ 
    return E_NOTIMPL;
}

STDMETHOD(InvalidateRect)(LPCRECT prc, BOOL fErase)
{
    HRESULT hr = S_OK;        
        
    if (m_pViewFilterSite) {
        hr = m_pViewFilterSite->InvalidateRect(prc, fErase);
    }
    
    return hr;
}

STDMETHOD(InvalidateRgn)(HRGN hrgn, BOOL fErase)
{
    HRESULT hr = S_OK;
    Assert(hrgn);

    if (m_pViewFilterSite.p) {
        hr = m_pViewFilterSite->InvalidateRgn(hrgn, fErase);
    }
    
    return hr;
}

STDMETHOD(OnStatusBitsChange)(DWORD dwFlags)
{
    return E_NOTIMPL;
//    return S_FALSE;
}

STDMETHOD(get_InputImage)(IDAImage **pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    *pVal = NULL;

    // The input image for the filter is modeled as an image bvr
    // that changes as the incoming surface changes on each
    // invocation of Draw.  We achieve this by constructing a
    // switcher here and returning the switcher's behavior.  Then, on
    // calls into Draw where the surface size has changed, we plug in
    // a new ddraw image.  When size hasn't changed, we use the old
    // one. 


    if (!m_inputImage) {
        HRESULT hr;
        
        hr = EnsureMeterStaticsIsCreated();
        if (FAILED(hr)) return hr;

        CComPtr<IDAImage> emptyImage;
        CComPtr<IDABehavior> bvr;
        
        hr = m_meterStatics->get_EmptyImage(&emptyImage);
        if (FAILED(hr)) return hr;

        hr = m_meterStatics->ModifiableBehavior(emptyImage, &bvr);
        if (FAILED(hr)) return hr;

        m_inputImage = (IDAImage *) bvr.p;
    }

    // AddRef because we're passing outside of here
    m_inputImage->AddRef();

    *pVal = m_inputImage;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\control\dxactrl.h ===
// dxactrl.h : Declaration of the Cdxactrl

#ifndef __DXACTRL_H_
#define __DXACTRL_H_

#include "privinc/resource.h"       // main symbols
#include <ocmm.h>
#include <htmlfilter.h>
#include "danim.h"
#include "apelutil.h"
#include "ddraw.h"
#include "ddrawex.h"
#include "privinc/mutex.h"
#include "privinc/util.h"
#include "privinc/comutil.h"
#include <mshtml.h>
#include "dactlevents.h"


// TODO: Move these to a string table
#define PROP_OPAQUEFORHITDETECT   L"OpaqueForHitDetect"
#define PROP_UPDATEINTERVAL       L"UpdateInterval"
    


// forward decls
class AXAMsgFilter;
class CDAViewerControlWindowed;
class CDAViewerControlWindowless;

typedef void ( *WMTimerCallback)(DWORD id,
                                 DWORD_PTR dwData);

DWORD CreateWMTimer(DWORD dwInterval,
                    WMTimerCallback cb,
                    DWORD dwData);

void DestroyWMTimer(DWORD id);

class CDAViewerControlBaseClass
{
public:

    //public events
    virtual void FireStart(){};
    virtual void FireMouseUp(long Button, long KeyFlags, long X, long Y){};
    virtual void FireMouseDown(long Button, long KeyFlags, long X, long Y){};
    virtual void FireMouseMove(long Button, long KeyFlags, long X, long Y){};
    virtual void FireClick(){};
    virtual void FireKeyPress(long KeyAscii){};
    virtual void FireKeyUp(long KeyCode, long KeyData){};
    virtual void FireKeyDown(long KeyCode, long KeyData){};
    virtual void FireError(long hr, BSTR ErrorText){};
    virtual void FireStop(){};
    virtual void FirePause(){};
    virtual void FireResume(){};
};

class DAControlImplementation
{
  public:


    ////////////////////////  TimerSink  ///////////////////
    class CDXAControlSink : public ITimerSink 
    {
      public:

        CDXAControlSink( DAControlImplementation *pdac ) {
            m_dac = pdac;
            m_cRefs = 1;
        }

        ~CDXAControlSink() {
            if (m_dac) {
                m_dac->ClearTimerSink();
            }
        }

        // IUnknown methods
        STDMETHODIMP_(ULONG) AddRef() { return ++m_cRefs; }
        STDMETHODIMP_(ULONG) Release() {
            if ( 0 == --m_cRefs ) {
                ULONG refCount = m_cRefs;
                delete this;
                return refCount;
            }
            return m_cRefs;
        }

        STDMETHODIMP QueryInterface (REFIID riid, void **ppv) {
            if ( !ppv )
                return E_POINTER;

            *ppv = NULL;
            if (riid == IID_IUnknown) {
                *ppv = (void *)(IUnknown *)this;
            } else if (riid == IID_ITimerSink) {
                *ppv = (void *)(ITimerSink *)this;
            }

            if (*ppv)
              {
                  ((IUnknown *)*ppv)->AddRef();
                  return S_OK;
              }

            return E_NOINTERFACE;
        }

        // ITimerSink methods
        STDMETHOD(OnTimer)(VARIANT timeAdvise) {
            Assert( (VT_UI4 == V_VT(&timeAdvise)) && "Variant type mismatch" );
            return( m_dac ?
                    m_dac->HandleOnTimer() :
                    S_OK );
        }

        
      protected:
        ULONG                  m_cRefs;
        DAControlImplementation  *m_dac;

    };

    DAControlImplementation(CComObjectRootEx<CComMultiThreadModel> *ctrl,
                            CComControlBase *ctrlBase,
                            IDASite *daSite,
                            CDAViewerControlBaseClass *baseEvents);

    ~DAControlImplementation();

    STDMETHOD(ReportError)(long hr,
                           BSTR errorText);
    STDMETHOD(ReportGC)(short bStarting);
    STDMETHOD(SetStatusText)(BSTR StatusText);
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus);
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg);
    STDMETHOD(QueryHitPoint)(DWORD dwAspect,
                             LPCRECT pRectBounds,
                             POINT ptlLoc,
                             LONG lCloseHint,
                             DWORD *pHitResult);
    HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect);
    STDMETHOD(InPlaceDeactivate)();

    HRESULT OnDraw(ATL_DRAWINFO& di, HWND window);

    HRESULT MsgHandler(UINT uMsg,
                       WPARAM wParam,
                       LPARAM lParam,
                       BOOL& bHandled);

    //Event handlers
    HRESULT OnLButtonUp(UINT nMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnMButtonUp(UINT nMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnRButtonUp(UINT nMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnLButtonDown(UINT nMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnMButtonDown(UINT nMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnRButtonDown(UINT nMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnMouseMove(UINT nMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnKeyDown(UINT nMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnKeyUp(UINT nMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnChar(UINT nMsg, WPARAM wParam, LPARAM lParam);

    STDMETHOD(get_UpdateInterval)(double *pVal);
    STDMETHOD(put_UpdateInterval)(double newVal);
    STDMETHOD(GetPreference)(BSTR prefName,
                             VARIANT *pVariant);
    STDMETHOD(SetPreference)(BSTR prefName,
                             VARIANT variant);
    STDMETHOD(get_View)(IDAView **ppView);
    STDMETHOD(put_View)(IDAView *pView);
    STDMETHOD(get_Image)(IDAImage **ppImage);
    STDMETHOD(put_Image)(IDAImage *pImage);
    STDMETHOD(get_BackgroundImage)(IDAImage **ppImage);
    STDMETHOD(put_BackgroundImage)(IDAImage *pImage);
    STDMETHOD(get_Sound)(IDASound **ppSound);
    STDMETHOD(put_Sound)(IDASound *pSound);
    STDMETHOD(get_OpaqueForHitDetect)(VARIANT_BOOL *b);
    STDMETHOD(put_OpaqueForHitDetect)(VARIANT_BOOL b);
    STDMETHOD(get_TimerSource)(DA_TIMER_SOURCE *ts);
    STDMETHOD(put_TimerSource)(DA_TIMER_SOURCE ts);
    STDMETHOD(get_PixelLibrary)(IDAStatics **ppStatics);
    STDMETHOD(get_MeterLibrary)(IDAStatics **ppStatics);

    STDMETHODIMP AddBehaviorToRun(IDABehavior *bvr);

    STDMETHODIMP RegisterErrorHandler(BSTR scriptlet);

    STDMETHODIMP Start();
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Resume();
    STDMETHODIMP Tick();


    //IPersistPropertyBag Stuff
    HRESULT InitNew();
    HRESULT Load(IPropertyBag* pPropBag, IErrorLog* pErrorLog);
    HRESULT Save(IPropertyBag* pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    void SetBaseCtl(CDAViewerControlWindowed *pBaseCtl);
    void SetBaseCtl(CDAViewerControlWindowless *pBaseCtl);

    // Could not get the friend working for the timersink class so I
    // just made a public function
    void ClearTimerSink();

    HRESULT HandleOnTimer();

  protected:
    ///// Methods

    void StopTimer();

    HRESULT ReestablishTridentTimer(bool startNewOne);

    // Reestablish appropriate timer with the current updateInterval
    // property. 
    HRESULT ReestablishTimer();

    HRESULT InitGenericContainerServices();
    HRESULT InitTridentContainerServices();

    void FlagFailure();
    
    HRESULT SetUpSurface(ATL_DRAWINFO& di);

    ULONG GetCurrentTridentTime();

    DWORD GetPerfTickCount();

    void StartPerfTimer();

    void StopPerfTimer();

    void ResetPerfTimer();

    ULONG GetPerfTimerInMillis();

    HRESULT DoRender();

    HRESULT PossiblyUpdateTimerInterval(ULONG newFrameTime);

    double GetGlobalTime();
    double GetCurrTime();

    HRESULT NewStaticsObject(IDAStatics **ppStatics);

    HRESULT EnsureMeterStaticsIsCreated();
    HRESULT EnsurePixelStaticsIsCreated();
    HRESULT EnsureViewIsCreated();

    HRESULT StartControl();

    // Only can get here if start has been called.
    HRESULT SetModelAndStart2(HWND window);

    HRESULT DoPreference(char *prefName,
                         bool puttingPref,
                         VARIANT *pV);

    void Lock() { m_ctrl->Lock(); }
    void Unlock() { m_ctrl->Unlock(); }

    HRESULT InternalTick();

    HRESULT LoadErrorFromView(IDA3View *view, LPTSTR *ErrorString, UINT ErrorID);

    ///// Data members
    CComObjectRootEx<CComMultiThreadModel> *m_ctrl;
    CComControlBase                        *m_ctrlBase;

    // Don't grab a reference to this guy, since it comes directly
    // from the containing object, and mucking with its refcount will
    // mess up the state of the object (causes re-entrancy problems).
    IDASite                                *m_daSite;
    
    DAComPtr<ITimer>                        m_timer;
    DWORD                                   m_adviseCookie;
    
    enum {
        INITIAL = 1,
        START_NEEDED = 2,
        START_CALLED = 3,
        STARTED = 4,
        STARTED_AND_RENDERABLE = 5
    } m_startupState;

    enum 
    {
        CUR_INITIAL = 1,
        CUR_STARTED = 2,
        CUR_STOPPED = 3,
        CUR_PAUSED = 4,
    } m_currentState;

    double              m_dPausedTime;
    // Maintain a "failed" flag independently of the startup state,
    // because failure can happen in any of the startup states.
    bool                m_startupFailed;

    // If we fail during ticking or rendering, we'll stop ticking and
    // rendering. 
    bool                m_tickOrRenderFailed;

    // Cached information to avoid resets
    RECT                m_lastRcClip;
    RECT                m_lastDeviceBounds;
    
    // Set to true only if the background is explicitly set by user 

    bool                m_backgroundSet;
    VARIANT             m_timeVariant;
    double              m_startTime;
    DAComPtr<IDirectDraw3> m_directDraw3;
    CDXAControlSink    *m_timerSink;

    DAComPtr<IDA3View>  m_view;

    AXAMsgFilter        m_msgFilter;

    DAComPtr<IDAImage>   m_modelImage;
    DAComPtr<IDAImage>   m_modelBackgroundImage;
    DAComPtr<IDASound>   m_modelSound;
    DAComPtr<IDAStatics> m_pixelStatics;
    DAComPtr<IDAStatics> m_meterStatics;

    DAComPtr<IOleClientSite> m_spAptClientSite;
    WideString           m_wstrScript;
    
    // Properties
    ULONG               m_minimumUpdateInterval;
    bool                m_opaqueForHitDetect;
    DA_TIMER_SOURCE     m_timerSource;
    DA_TIMER_SOURCE     m_origTimerSource;
    
    // The following members are for supporting containers that don't
    // provide the Trident timer and surface services.
    
    // can we use Trident services, or do we fail to generic services.
    bool                m_tridentServices;
    UINT                m_wmtimerId;
    bool                m_ddrawSurfaceAsTarget;

    // For Trident timer regulation
    ULONG               m_tridentTimerInterval;
    DWORD               m_perfCounterFrequency;
    DWORD               m_perfTimerTickCount;
    DWORD               m_perfTimerStart;
    double              m_desiredCPUUsageFrac;
    ULONG               m_framesThisCycle;
    ULONG               m_frameNumber;
    ULONG               m_timeThisCycle;
    ULONG               m_lastCheckTime;
    bool                m_registeredAsActive;
    CDAViewerControlBaseClass *m_ctrlBaseEvents;
    HBITMAP             m_hErrorBitmap;
    LPTSTR              m_szErrorString;
    bool                m_bMouseCaptured;
};


/////////////////////////////////////////////////////////////////////////////
// Templated control


template <class T, const CLSID* pclsid,
          class iface, const IID* piid,
          class ifaceAux, const IID* piidAux>
class ATL_NO_VTABLE CDAViewerControlBase : 
        public CComObjectRootEx<CComMultiThreadModel>,
        public CComCoClass<T, pclsid>,
        public CComControl<T>,
        public CProxy_IDAViewerControlEvents<T>,
        public IDispatchImpl<iface, piid, &LIBID_DirectAnimation>,
        public IProvideClassInfo2Impl<pclsid, &DIID__IDAViewerControlEvents, &LIBID_DirectAnimation>,
        //public IProvideClassInfo2Impl<pclsid, NULL, &LIBID_DirectAnimation>,
        public IConnectionPointContainerImpl<T>,
        public IPersistPropertyBag,
        public IPersistStreamInitImpl<T>,
        public IPersistStorageImpl<T>,
        public IQuickActivateImpl<T>,
        public IOleControlImpl<T>,
        public IOleObjectImpl<T>,
        public IOleInPlaceActiveObjectImpl<T>,
        public IViewObjectExImpl<T>,
        public IOleInPlaceObjectWindowlessImpl<T>,
        public IDataObjectImpl<T>,
        public ISpecifyPropertyPagesImpl<T>,
        public IObjectSafety,
        public IDAViewSite,
        public IDASite,
        public CDAViewerControlBaseClass
{
  public:
    BEGIN_COM_MAP(T)
        COM_INTERFACE_ENTRY_IID(*piid, iface)
        COM_INTERFACE_ENTRY_IID(*piidAux, ifaceAux)     
        COM_INTERFACE_ENTRY(IDAViewerControl)
        COM_INTERFACE_ENTRY(IDASite)
        COM_INTERFACE_ENTRY(IDAViewSite)
        COM_INTERFACE_ENTRY2(IDispatch,iface)
        COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
        COM_INTERFACE_ENTRY_IMPL(IOleControl)
        COM_INTERFACE_ENTRY_IMPL(IOleObject)
        COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
        COM_INTERFACE_ENTRY(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_IMPL(IDataObject)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        END_COM_MAP();
        
    BEGIN_PROPERTY_MAP(T)
        // Example entries
        // PROP_ENTRY("Property Description", dispid, clsid)
        // PROP_PAGE(CLSID_StockColorPage)
    END_PROPERTY_MAP();

    BEGIN_CONNECTION_POINT_MAP(T)
        CONNECTION_POINT_ENTRY(DIID__IDAViewerControlEvents)
    END_CONNECTION_POINT_MAP()
    
    BEGIN_MSG_MAP(T)
        // Use the following replacement for message range handler since we
        // always want to process all messages.  We also need to ensure that
        // bHandled is set to true if MsgHandler processed it
        BOOL bWasHandled;
        LRESULT lResult2;
        lResult2 = m_dac->MsgHandler(uMsg, wParam, lParam, bWasHandled);

        MESSAGE_HANDLER(WM_PAINT, OnPaint)
        MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
        MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)

        if (bWasHandled) {
            lResult = lResult2;
            return TRUE;
        }
        
    END_MSG_MAP();

    // IDASite & IDAViewSite
    // Make the call back to the script.
    STDMETHOD(ReportError)(long hr, BSTR ErrorText)
    {
        return m_dac->ReportError(hr, ErrorText);
    }

    STDMETHOD(ReportGC)(short bStarting)
    {
        return S_OK;
    }
    
    STDMETHOD(SetStatusText)(BSTR StatusText)
    {
        return S_OK;
    }

      
    // IViewObjectEx
    
    // TODO: this should be different if we are windowed
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        return m_dac->GetViewStatus(pdwStatus);
    }
    
    // IOleInPlaceActiveObject
    //
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg)
    {
        return m_dac->TranslateAccelerator(lpmsg);
    }
    
    // IOleInPlaceObjectWindowlessImpl
    STDMETHOD(OnWindowMessage)(UINT msg,
                               WPARAM wParam,
                               LPARAM lParam,
                               LRESULT *plResult)
    {
        return ProcessWindowMessage(m_hWnd, msg,
                                    wParam, lParam,
                                    *plResult)?S_OK:S_FALSE;
    }

    // IDAViewerControl
    CDAViewerControlBase(bool bWindowedOnly = false)
    {
        m_dwSafety = 0;
        m_bWindowOnly = bWindowedOnly;
        m_dac = NEW DAControlImplementation(this,
                                            this,
                                            this,
                                            this);
    }


    ~CDAViewerControlBase()
    {
        delete m_dac;
    }


    STDMETHOD(QueryHitPoint)(DWORD dwAspect,
                                    LPCRECT pRectBounds,
                                    POINT ptlLoc,
                                    LONG lCloseHint,
                                    DWORD *pHitResult)
    {
        return m_dac->QueryHitPoint(dwAspect,
                                    pRectBounds,
                                    ptlLoc,
                                    lCloseHint,
                                    pHitResult);
    }


    STDMETHOD(InPlaceActivate)(LONG iVerb, const RECT* prcPosRect)
    {
        
        HRESULT hr = CComControl<T>::InPlaceActivate(iVerb,
                                             prcPosRect);

        if (SUCCEEDED(hr)) {
            hr = m_dac->InPlaceActivate(iVerb, prcPosRect);
        }
        
        return hr;
    }

    STDMETHOD(InPlaceDeactivate)()
    {
        HRESULT hr = m_dac->InPlaceDeactivate();

        Assert(SUCCEEDED(hr));  // should never fail.

        // ... continue by calling the "original" deactivate.
        return IOleInPlaceObject_InPlaceDeactivate();
    }

    HRESULT
    OnDraw(ATL_DRAWINFO& di)
    {
        return m_dac->OnDraw(di, m_hWnd);
    }

    STDMETHOD(get_UpdateInterval)(double *pVal)
    {
        return m_dac->get_UpdateInterval(pVal);
    }

    STDMETHOD(put_UpdateInterval)(double newVal)
    {
        SetDirty(TRUE);
        return m_dac->put_UpdateInterval(newVal);
    }

    STDMETHOD(GetPreference)(BSTR prefName, VARIANT *pVariant)
    {
        return m_dac->GetPreference(prefName, pVariant);
    }

    STDMETHOD(SetPreference)(BSTR prefName, VARIANT variant)
    {
        return m_dac->SetPreference(prefName, variant);
    }


    STDMETHOD(get_View)(IDAView **ppView)
    {
        return m_dac->get_View(ppView);
    }

    STDMETHOD(put_View)(IDAView *pView)
    {
        return m_dac->put_View(pView);
    }

    STDMETHOD(get_Image)(IDAImage **ppImage)
    {
        return m_dac->get_Image(ppImage);
    }

    STDMETHOD(put_Image)(IDAImage *pImage)
    {
        return m_dac->put_Image(pImage);
    }

    STDMETHOD(get_BackgroundImage)(IDAImage **ppImage)
    {
        return m_dac->get_BackgroundImage(ppImage);
    }

    STDMETHOD(put_BackgroundImage)(IDAImage *pImage)
    {
        return m_dac->put_BackgroundImage(pImage);
    }

    STDMETHOD(get_Sound)(IDASound **ppSound)
    {
        return m_dac->get_Sound(ppSound);
    }

    STDMETHOD(put_Sound)(IDASound *pSound)
    {
        return m_dac->put_Sound(pSound);
    }

    STDMETHOD(get_OpaqueForHitDetect)(VARIANT_BOOL *b)
    {
        return m_dac->get_OpaqueForHitDetect(b);
    }

    STDMETHOD(put_OpaqueForHitDetect)(VARIANT_BOOL b)
    {
        SetDirty(TRUE);
        return m_dac->put_OpaqueForHitDetect(b);
    }

    STDMETHOD(get_TimerSource)(DA_TIMER_SOURCE *ts)
    {
        return m_dac->get_TimerSource(ts);
    }

    STDMETHOD(put_TimerSource)(DA_TIMER_SOURCE ts)
    {
        return m_dac->put_TimerSource(ts);
    }

    STDMETHOD(get_PixelLibrary)(IDAStatics **ppStatics)
    {
        return m_dac->get_PixelLibrary(ppStatics);
    }

    STDMETHOD(get_MeterLibrary)(IDAStatics **ppStatics)
    {
        return m_dac->get_MeterLibrary(ppStatics);
    }

    STDMETHODIMP AddBehaviorToRun(IDABehavior *bvr)
    {
        return m_dac->AddBehaviorToRun(bvr);
    }

    // Exported to script, so that a error handler can be registered to be 
    // called in the event of an error.
    STDMETHODIMP RegisterErrorHandler(BSTR scriptlet)
    {
        return m_dac->RegisterErrorHandler(scriptlet);
    }

    STDMETHODIMP Start()
    {
        HRESULT hr = THR(m_dac->Start());
        return hr;
    }


    STDMETHODIMP Stop()
    {
        HRESULT hr = THR(m_dac->Stop());
        return hr;
    }


    STDMETHODIMP Pause()
    {
        HRESULT hr = THR(m_dac->Pause());
        return hr;
    }


    STDMETHODIMP Resume()
    {
        HRESULT hr = THR(m_dac->Resume());
        return hr;
    }

    STDMETHODIMP Tick()
    {
        return m_dac->Tick();
    }

    STDMETHOD(get_InputImage)(IDAImage **pVal) {
        if (!pVal) {
            return E_POINTER;
        }

        *pVal = NULL;
        return E_NOTIMPL;
    }

    //event stuff
    
    void FireStart()
    {
        Fire_Start();
    }
    void FireMouseUp(long Button, long KeyFlags, long X, long Y)
    {
        Fire_MouseUp(Button, KeyFlags, X, Y);
    }
    void FireMouseDown(long Button, long KeyFlags, long X, long Y)
    {
        Fire_MouseDown(Button, KeyFlags, X, Y);
    }
    void FireMouseMove(long Button, long KeyFlags, long X, long Y)
    {
        Fire_MouseMove(Button, KeyFlags, X, Y);
    }
    void FireClick()
    {
        Fire_Click();
    }
    void FireKeyPress(long KeyAscii)
    {
        Fire_KeyPress(KeyAscii);
    }
    void FireKeyUp(long KeyCode, long KeyData)
    {
        Fire_KeyUp(KeyCode, KeyData);
    }
    void FireKeyDown(long KeyCode, long KeyData)
    {
        Fire_KeyDown(KeyCode, KeyData);
    }
    void FireError(long hr, BSTR ErrorText)
    {
        Fire_Error(hr, ErrorText);
    }
    void FireStop()
    {
        Fire_Stop();
    }
    void FirePause()
    {
        Fire_Pause();
    }
    void FireResume()
    {
        Fire_Resume();
    }

    //IPersistPropertyBag
    STDMETHOD(InitNew)(void)
    {
        return m_dac->InitNew();
    }

    STDMETHOD(GetClassID)(CLSID *pClassID)
    {
        *pClassID = *pclsid;
        return S_OK;
    }

    STDMETHOD(Load)(IPropertyBag* pPropBag, IErrorLog* pErrorLog)
    {
        return m_dac->Load(pPropBag, pErrorLog);
    }

    STDMETHOD(Save)(IPropertyBag* pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
    {
        return m_dac->Save(pPropBag, fClearDirty, fSaveAllProperties);
        //clear the dirty flag
        if (fClearDirty == TRUE)
        {
            SetDirty(FALSE);
        }

    }

    // Need to copy this here since multiple interface need this
    // implemented...just a pass though to IDispatchImpl

    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    { return
          IDispatchImpl<iface,
                        piid,
                        &LIBID_DirectAnimation>::GetTypeInfoCount(pctinfo); }
    
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    { return
          IDispatchImpl<iface,
                        piid,
                        &LIBID_DirectAnimation>::GetTypeInfo(itinfo,
                                                             lcid,
                                                             pptinfo); }

    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                             LCID lcid, DISPID* rgdispid)
    { return
          IDispatchImpl<iface,
                        piid,
                        &LIBID_DirectAnimation>::GetIDsOfNames(riid,
                                                               rgszNames,
                                                               cNames,
                                                               lcid,
                                                               rgdispid); }

    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
                      LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, UINT* puArgErr)
    { return
          IDispatchImpl<iface,
                        piid,
                        &LIBID_DirectAnimation>::Invoke(dispidMember,
                                                        riid,
                                                        lcid,
                                                        wFlags,
                                                        pdispparams,
                                                        pvarResult,
                                                        pexcepinfo,
                                                        puArgErr);}
    
    //IObjectSafety Implementation for CDAViewerControlBase
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD *pdwSupportedOptions, 
                                         DWORD *pdwEnabledOptions)
    {
        HRESULT hr = S_OK;
        if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
        {
            return E_POINTER;
        }

        if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag)
        {
            *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
            *pdwEnabledOptions = m_dwSafety & (INTERFACESAFE_FOR_UNTRUSTED_CALLER);
        }
        else
        {
            *pdwSupportedOptions = 0;
            *pdwEnabledOptions = 0;
            hr = E_NOINTERFACE;
        }
        return hr;
    };

    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD dwOptionSetMask, 
                                         DWORD dwEnabledOptions)
    {
        // If we're being asked to set our safe for scripting option then oblige
        if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag)
        {
            // Store our current safety level to return in GetInterfaceSafetyOptions
            m_dwSafety = dwEnabledOptions & dwOptionSetMask;
            return S_OK;
        }
        return E_NOINTERFACE;
    }
    
      protected:
        DAControlImplementation         *m_dac;
        long                            m_dwSafety;
    
    };

class CDAViewerControlWindowless :
    public CDAViewerControlBase<CDAViewerControlWindowless,
                                &CLSID_DAViewerControl,
                                IDA3ViewerControl,
                                &IID_IDA3ViewerControl,
                                IDAViewerControl,
                                &IID_IDAViewerControl>

{
  public:
    CDAViewerControlWindowless()
    : CDAViewerControlBase<CDAViewerControlWindowless,
                           &CLSID_DAViewerControl,
                           IDA3ViewerControl,
                           &IID_IDA3ViewerControl,
                           IDAViewerControl,
                           &IID_IDAViewerControl> (false) 
    {

    }
    
    DECLARE_REGISTRY_RESOURCEID(IDR_DXACTRL);
#if DEVELOPER_DEBUG
    DA_DECLARE_AGGREGATABLE(CDAViewerControlWindowless);
#if _DEBUG
    const char * GetName() { return "CDAViewerControlWindowless"; }
#endif
#endif
};

class CDAViewerControlWindowed :
    public CDAViewerControlBase<CDAViewerControlWindowed,
                                &CLSID_DAViewerControlWindowed,
                                IDA3ViewerControlWindowed,
                                &IID_IDA3ViewerControlWindowed,
                                IDAViewerControlWindowed,
                                &IID_IDAViewerControlWindowed>
{
  public:
    CDAViewerControlWindowed()
    : CDAViewerControlBase<CDAViewerControlWindowed,
                           &CLSID_DAViewerControlWindowed,
                           IDA3ViewerControlWindowed,
                           &IID_IDA3ViewerControlWindowed,
                           IDAViewerControlWindowed,
                           &IID_IDAViewerControlWindowed> (true) 
    {

    }
    DECLARE_REGISTRY_RESOURCEID(IDR_DXACTRL_WINDOWED);

#if DEVELOPER_DEBUG
    DA_DECLARE_AGGREGATABLE(CDAViewerControlWindowed);
#if _DEBUG
    const char * GetName() { return "CDAViewerControlWindowed"; }
#endif
#endif
};

#endif //__DXACTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\2dchar.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

#include "appelles/Path2.h"
#include "privinc/dddevice.h"
#include "privinc/viewport.h"
#include "privinc/texti.h"
#include "privinc/TextImg.h"
#include "privinc/Linei.h"
#include "privinc/OverImg.h"
#include "privinc/DaGdi.h"
#include "privinc/debug.h"
#include "backend/bvr.h"


// forward decl
TextPoints *GenerateCacheTextPoints(DirectDrawImageDevice* dev,
                                    TextCtx& textCtx,
                                    WideString str,
                                    bool doGlyphMetrics);

//Real ComputeOffset( Transform2 *charXf, TextPoints::DAGLYPHMETRICS *daGm );


void DirectDrawImageDevice::
_RenderDynamicTextCharacter(TextCtx& textCtx, 
                            WideString wstr, 
                            Image *textImg,
                            Transform2 *overridingXf,
                            textRenderStyle textStyle,
                            RenderStringTargetCtx *targetCtx,
                            DAGDI &myGDI)
{
    //
    // get the textpoints from the cache...
    //
    Assert( textCtx.GetCharacterTransform() );

    /*
    // Push text rendering attribs: text alignment
    DWORD oldTextAlign = textCtx.GetTextAlign();

    // hm.... may not need this stuff afterall...
    //textCtx.SetAlign_BaselineLeft();

    // Push text rendering attribs: do glyph metrics
    bool oldDoGlyphMetrics = textCtx.GetDoGlyphMetrics();
    textCtx.SetDoGlyphMetrics( true );
    */
    
    //
    // find the bounding box and start the offset at the left of the bbox
    //
    Bbox2 box = DeriveDynamicTextBbox(textCtx, wstr, false);
    Real halfWidth = box.Width() * 0.5;
    Real realXOffset = -halfWidth;
    
    //
    // pre xform the character <using font transform>
    // post xform the character with the accumulated xform
    //
        
    // WideString character to pass into RenderDynamicText
    WCHAR oneWstrChar[2];
    Transform2 *currXf, *tranXf, *xfToUse, *charXf;
    WideString lpWstr = wstr;
    int numBytes;
    bool aaState = false;

    // get strlen from the string mon.
    int mbStrLen = wcslen( wstr );
    TextPoints *txtPts;
    bool doGlyphMetrics = true;

    Real currLeftProj = 0,
         currRightProj = 0,
         lastRightProj = 0;
    
    for(int i=0; i < mbStrLen; i++) {

        // clear first char
        oneWstrChar[0] = (WCHAR)0;
        // copy one wstr character into oneWstrChar
        wcsncpy(oneWstrChar, lpWstr, 1);
        // null terminate, just to be sure
        oneWstrChar[1] = (WCHAR)0;
                
        // Get metrics for this character
        txtPts = GenerateCacheTextPoints(this, textCtx, oneWstrChar, doGlyphMetrics);
        Assert( txtPts->_glyphMetrics );

        charXf = textCtx.GetCharacterTransform();

        ComputeLeftRightProj(charXf,
                             txtPts->_glyphMetrics[0],
                             &currLeftProj,
                             &currRightProj);
        
        //
        // Offset in x for the next character
        //
        realXOffset += lastRightProj + currLeftProj;

        //
        // Do transforms
        //
        currXf = overridingXf ? overridingXf : GetTransform();

        tranXf = TranslateRR( realXOffset, 0 );

        // charXf first, then translate
        xfToUse = TimesTransform2Transform2(tranXf, charXf);

        // then the current accumulated transform
        xfToUse = TimesTransform2Transform2(currXf, xfToUse);

        if(myGDI.DoAntiAliasing()) {
            aaState = true;
        }
        
        _RenderDynamicText(textCtx,
                           oneWstrChar,
                           textImg,
                           xfToUse,  // overriding xf
                           textStyle,
                           targetCtx,
                           myGDI);

        myGDI.SetAntialiasing( aaState );

        // the current character is now the last character
        lastRightProj = currRightProj;
        
        // debug only
        #if 0
        {
            GLYPHMETRICS *gm = & txtPts->_glyphMetrics[0].gm;
            DWORD width, height, x, y;
            width = gm->gmBlackBoxX;
            height = gm->gmBlackBoxY;
            x = gm->gmptGlyphOrigin.x;
            y = gm->gmptGlyphOrigin.y;
        
            RECT r; SetRect(&r, x, y, x+width, y+height);
            OffsetRect(&r, _viewport.Width() / 2, _viewport.Height() / 2 );
            OffsetRect(&r, pixOffset, 0);

            pixOffset += gm->gmCellIncX;
            DrawRect(
                targetCtx->GetTargetDDSurf(),
                &r,
                255, 255, 90);
        }
        #endif
       
        // next WideChar
        lpWstr++;
    }
    // restore pushed attribs
    //textCtx.SetTextAlign( oldTextAlign );
    //textCtx.SetDoGlyphMetrics( oldDoGlyphMetrics );
    myGDI.ClearState();
}


void ComputeLeftRightProj(Transform2 *charXf,
                          TextPoints::DAGLYPHMETRICS &daGm,
                          Real *leftProj,
                          Real *rightProj)
{
    Real cellWidth, cellHeight;

    // compute cell width, and cell height
    #if 1
    cellWidth  = daGm.gmCellIncX;
    cellHeight = daGm.gmBlackBoxY + (daGm.gmCellIncX - daGm.gmBlackBoxX);
    #else
    cellWidth  = daGm.gmBlackBoxX;
    cellHeight = daGm.gmBlackBoxY;
    #endif
    
    // !!! BASELINE CENTER !!!  (won't work for other alignments...)
    Bbox2 box(-cellWidth * 0.5,  // xmin
              0,                  // ymin
              cellWidth * 0.5,    // xmax
              cellHeight );       // ymax

    box = TransformBbox2( charXf, box );

    // be sure to subtract the translation
    //Point2Value *cntrPt = TransformPoint2Value( charXf, origin2 );

    *leftProj = fabs( box.min.x );
    *rightProj = fabs( box.max.x );
}
        
/*
Real ComputeOffset( Transform2 *charXf, TextPoints::DAGLYPHMETRICS *daGm )
{
    Real cellWidth, cellHeight;

    // compute cell width, and cell height
    #if 1
    cellWidth  = 0.5 * daGm->gmCellIncX;
    cellHeight = daGm->gmBlackBoxY + (daGm->gmCellIncX - daGm->gmBlackBoxX);
    #else
    cellWidth  = daGm->gmBlackBoxX;
    cellHeight = daGm->gmBlackBoxY;
    #endif

    Assert(cellHeight >= 0);
    Assert(cellWidth >= 0);
    
    if( (cellHeight + cellWidth) < 0.0000001 ) return 0;
    
    // call that vector V
    Vector2Value *cellVec = NEW Vector2Value( cellWidth, cellHeight );
    
    // transform the vector.
    Vector2Value *vec = TransformVector2( charXf, cellVec );

    // projection of vec onto cellVec
    Real proj = Dot(*vec, *cellVec) / cellVec->LengthSquared();

    // offset is percentage
    Real offset = (proj * cellWidth) +  (( 1-proj ) * cellHeight);

    offset = fabs(offset);
    
    return offset;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\2dalpha.cpp ===
/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

-------------------------------------*/
#include "headers.h"

#include <privinc/dddevice.h>


#define MY_RAND_MAX 32767
#define MyRand(seed)  (( ( (seed) = (seed) * 214013L + 2531011L) >> 16) & 0x7fff)


inline WORD DirectDrawImageDevice::
BlendWORD(WORD dest, int destOpac, WORD src, int opac,
          DWORD redShift, DWORD greenShift, DWORD blueShift,
          WORD redMask, WORD greenMask, WORD blueMask,
          WORD redBlueMask)
{

#if 1
    register WORD rbDest;
    register WORD gDest;

    //
    // destination word = alpha * (a - b) + b
    // where a=src, and b=dest
    //

    //
    // the idea here is to have two parts: R0B and 0G0 
    // and perform operations in parallel.  this saves several instructions
    //

    rbDest = (dest & redBlueMask);
    gDest = dest & greenMask;

    return 
        ( (((( (src & redBlueMask) - rbDest) * opac) >> 5) + rbDest) & redBlueMask) | 
        ( (((( (src & greenMask) - gDest)  * opac) >> 5) + gDest) & greenMask);
#endif

#if 0

    //
    // Build a color table whose index is a 5bit value cross
    // another 5 bit value (the alpha) to produce the resultant
    // value
    static built = 0;
    static WORD table[32][32];
    static int mults[32];
  {
      if(!built) {
          
          for(int i=0; i<32; i++) 
          {
              for(int j=0; j<32; j++)
              {
                  table[i][j] = WORD(Real(i) * Real(j) / 31.0);
              }
          }
          int tmp;
          mults[0] = 64;
          for(i=1; i<32; i++)
          {
              tmp = int( 31.0 / Real(i) );
              mults[i] = tmp;
          }
          built = 1;
      }
  }
    
#define R(w) ((w) & redMask)
#define G(w) ((w) & greenMask)
#define B(w) ((w) & blueMask)

    // In 5,5,5 red just needs to be shifted.
    // blue just needs to be masked.
    WORD red = (table[(src >> redShift)][opac] +
                table[(dest >> redShift)][destOpac]);

    WORD grn = (table[(G(src) >> greenShift)][opac] +
                table[(G(dest) >> greenShift)][destOpac]);

    WORD blu = (table[B(src)][opac] +
                table[B(dest)][destOpac]);


    return 
        ((red << redShift)   |
         (grn << greenShift) |
         (blu));
#endif

}
    

inline DWORD DirectDrawImageDevice::
BlendDWORD(DWORD dest, int destOpac, DWORD src, int opac,
           DWORD redShift, DWORD greenShift, DWORD blueShift,
           DWORD redMask, DWORD greenMask, DWORD blueMask,
           DWORD redBlueMask)
{
    register DWORD rbDest;
    register DWORD gDest;

    //
    // destination dword = alpha * (src - dest) + dest
    //

    rbDest = (dest & redBlueMask);
    gDest = dest & greenMask;

    return 
        (
         ((((((src & redBlueMask) - rbDest) * opac) >> 8) + rbDest) & redBlueMask) |
         ((((((src & greenMask) - gDest) * opac) >> 8) + gDest) & greenMask)
         );
}
        
//
// Alpha blend a premultiplied word
//
inline WORD DirectDrawImageDevice::
BlendPremulWORD(WORD dest, int destOpac, WORD src,
                DWORD redShift, DWORD greenShift, DWORD blueShift,
                WORD redMask, WORD greenMask, WORD blueMask,
                WORD redBlueMask)
{
    return 
        (((src & redBlueMask) +  ((destOpac * (dest & redBlueMask)) >> 5)) & redBlueMask ) | 
        (((src & greenMask) +  ((destOpac * (dest & greenMask)) >> 5)) & greenMask );
}

//
// Alpha blend a premultiplied double word
//
inline DWORD DirectDrawImageDevice::
BlendPremulDWORD(DWORD dest, int destOpac, DWORD src,
                 DWORD redShift, DWORD greenShift, DWORD blueShift,
                 DWORD redMask, DWORD greenMask, DWORD blueMask,
                 DWORD redBlueMask)
{
    return 
        (((src & redBlueMask) +  ((destOpac * (dest & redBlueMask)) >> 8)) & redBlueMask) |
        (((src & greenMask) +  ((destOpac * (dest & greenMask)) >> 8)) & greenMask );
}


//-----------------------------------------------------
// A l p h a   B l i t
//
// given src & dest surfaces, opacity, colorKey & 
// destination rectangle (same on both surfaces) this
// function copies from src to dest using the opacity
// value and color keys if that's appropriate.
//-----------------------------------------------------
void DirectDrawImageDevice::
AlphaBlit(destPkg_t *destPkg,
          RECT *srcRect,
          LPDDRAWSURFACE srcSurf, 
          Real opacity, 
          Bool doClrKey, 
          DWORD clrKey,
          RECT *clipRect,
          RECT *destRect)
{
    Assert(opacity >= 0.0 && opacity <= 1.0 && "bad opacity in AlphaBlit");
    Assert(sizeof(WORD) == 2 && "Hm... WORD isn't 2 bytes");
    Assert(srcRect && "NULL srcRect in AlphaBlit");
    Assert((clipRect!=NULL ? destRect!=NULL : destRect==NULL) && "clipRect & destRect must be both null or not");

    #if 0
    #if _DEBUG
    if(destRect) {
        Assert( (destRect->right - destRect->left) == (srcRect->right - srcRect->left) && 
                "widths differ: alphaBlit src and dest rect");
        Assert( (srcRect->bottom - srcRect->top) == (destRect->bottom - destRect->top) && 
                "heights differ: alphaBlit src and dest rect");
    }
    #endif
    #endif
    
    //
    // basically clip the rectanlges
    //
    RECT modSrcRect = *srcRect;
    int xOffset = 0;
    register int yOffset = 0;

    if( destRect ) {

        xOffset = destRect->left - srcRect->left;
        yOffset = destRect->top - srcRect->top;

        RECT insctRect;
        IntersectRect(&insctRect, destRect, clipRect);

        if( EqualRect(&insctRect, destRect) ) {
            //
            // rect is within the extent of the viewport. no clipping necessary
            //
        } else {
            if( IsRectEmpty(&insctRect) ) {
                //
                // No rectangle !
                //
                return;
            } else {
                //
                // valid, but needs clipping
                //
                OffsetRect(&insctRect, -xOffset, -yOffset);

                IntersectRect(&modSrcRect, &insctRect, srcRect);
                TraceTag((tagImageDeviceInformative,
                          "clipped alpha rect: (%d %d %d %d)",
                          srcRect->left,srcRect->top,srcRect->right,srcRect->bottom));
                
            }
        }
        #if 0
        Assert( (modSrcRect.right - modSrcRect.left) == (insctRect.right - insctRect.left) && 
               "widths differ: alphaBlit modSrcRect and insctRect rect");
        Assert( (modSrcRect.bottom - modSrcRect.top) == (insctRect.bottom - insctRect.top) && 
               "heights differ: alphaBlit modSrcRect and insctRect
rect");
        #endif
    }

    int left = modSrcRect.left;
    int right = modSrcRect.right;
    int top = modSrcRect.top;
    int bottom = modSrcRect.bottom;


    DWORD redMask   = _viewport._targetDescriptor._pixelFormat.dwRBitMask;
    DWORD greenMask = _viewport._targetDescriptor._pixelFormat.dwGBitMask;
    DWORD blueMask  = _viewport._targetDescriptor._pixelFormat.dwBBitMask;
    DWORD redBlueMask = redMask | blueMask;

    DWORD redShift   = _viewport._targetDescriptor._redShift;
    DWORD greenShift = _viewport._targetDescriptor._greenShift;
    DWORD blueShift  = _viewport._targetDescriptor._blueShift;
    

    //
    // Grab locks
    //
    DDSURFACEDESC destDesc;
    DDSURFACEDESC srcDesc;
    destDesc.dwSize = sizeof(DDSURFACEDESC);
    srcDesc.dwSize = sizeof(DDSURFACEDESC);

    void *destp;
    long destPitch;
    LPDDRAWSURFACE destSurf;
    if(destPkg->isSurface) {
        destSurf = destPkg->lpSurface;
    
        destDesc.dwFlags = DDSD_PITCH | DDSD_LPSURFACE;
        _ddrval = destSurf->Lock(NULL, &destDesc, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
        IfDDErrorInternal(_ddrval, "Can't Get destSurf lock for AlphaBlit");
        destp = destDesc.lpSurface;
        destPitch = destDesc.lPitch;
    } else {
        destSurf = NULL;
        destp = destPkg->lpBits;
        destPitch = destPkg->lPitch;
        // bits point to top left of cliprect on dest!
        // xxx boy this is a bad hack if I've ever seen one...  
        xOffset = - left;
        yOffset = - top;
    }
    
    TraceTag((tagImageDeviceAlpha, "--->Locking2 %x\n", srcSurf));
    _ddrval = srcSurf->Lock(NULL, &srcDesc, DDLOCK_READONLY | DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
    if(_ddrval != DD_OK) {
        if(destSurf) {
            destSurf->Unlock(destDesc.lpSurface);
        }
        IfDDErrorInternal(_ddrval, "Can't Get srcSurf lock for AlphaBlit");
    }

    void *srcp  = srcDesc.lpSurface;

    register int i;
    register int j;

    //
    // Switch on bit depth & do the alpha conversion
    //

    switch(_viewport._targetDescriptor._pixelFormat.dwRGBBitCount) {
      case 8:
        //
        // use stipling
        // 
      {
          register unsigned char *src = 0;
          register unsigned char *dest = 0;

          //register int opac = int(31.0 * opacity);
          //register int destOpacity = 31 - opac;
          register unsigned int randPercent = unsigned int(opacity * MY_RAND_MAX);

          register int leftBytes = left;  // 1 byte per pixel
          register int destLeftBytes = left + xOffset;

          #define BlendByte(src, dest, percent)  if(MyRand(_randSeed) < percent) { dest = src; }
          
          _randSeed = 777;

          if(doClrKey) 
          {
              //
              // Alpha with color key in rect
              //
              for(j=top; j < bottom; j++) 
              {
                  src = ((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                  dest = ((unsigned char *)destp + destPitch * (j+yOffset) + destLeftBytes);
                  
                  for(i=left; i < right; i++) 
                  {
                      if(clrKey != *src)
                      {
                          BlendByte(*src, *dest, randPercent);
                      } 
                      dest++; src++;
                  }
              }
          } 
          else 
          {

              //
              // Alpha in rect, no color key.. save a test each pixel.
              //
              for(j=top; j < bottom; j++) 
              {
                  src = ((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                  dest = ((unsigned char *)destp + destPitch * (j+yOffset) + destLeftBytes);
                  
                  for(i=left; i < right; i++)
                  {
                      BlendByte(*src, *dest, randPercent);
                      dest++; src++;
                  }
              }
          }

          //srcSurf->Unlock(srcDesc.lpSurface);
          //destSurf->Unlock(destDesc.lpSurface);

          #undef BlendByte
          break;
      }

      case 16:
      {
          register WORD *src = 0;
          register WORD *dest = 0;

          register int opac = int(31.0 * opacity);

          register int leftBytes = 2 * left; // 2 bytes per pixel
          register int destLeftBytes = leftBytes + 2*xOffset;

          if(doClrKey) 
          {
              //
              // Alpha with color key in rect
              //
              for(j=top; j < bottom; j++) 
              {
                  src = (WORD *) ((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                  dest = (WORD *) ((unsigned char *)destp + destPitch * (j+yOffset) + destLeftBytes);
                  
                  for(i=left; i < right; i++) 
                  {
                      if(clrKey != *src) 
                      {
                          *dest = BlendWORD(*dest, 0, *src, opac,
                                            redShift, greenShift, blueShift,
                                            (WORD)redMask, (WORD)greenMask, (WORD)blueMask,
                                            (WORD)redBlueMask);
                      }
                      dest++;
                      src++;
                  }
              }
          } 
          else 
          {
              //
              // Alpha in rect, no color key.. save a test each pixel.
              //
              for(j=top; j < bottom; j++) 
              {
                  src = (WORD *) ((BYTE *)srcp + srcDesc.lPitch * j  + leftBytes);
                  dest = (WORD *) ((BYTE *)destp + destPitch * (j+yOffset) + destLeftBytes);
                  
                  for(i=left; i < right; i++) 
                  {
#if 1
                      *dest = BlendWORD(*dest, 0, *src, opac,
                                        redShift, greenShift, blueShift,
                                        (WORD)redMask, (WORD)greenMask, (WORD)blueMask,
                                        (WORD)redBlueMask);
#else
                      _asm 
                      {
                          //
                          // alpha * (a - b) + b
                          //
                          mov eax, dword ptr[src] ; eax = src
                          mov ax, word ptr[eax]   ; ax = *src
                          mov edx, redBlueMask    ; edx = redBlueMask
                          mov di, ax       ; di = *src   <stash>
                          and eax, edx     ; rbSrc  = (*src  & redBlueMask);
                          
                          mov ebx, dword ptr[dest] ;
                          mov bx, word ptr[ebx]    ;
                          mov si, bx        ; si = *dest  <stash>;
                          and ebx, edx  ;   rbDest = (*dest & redBlueMask);

                          sub eax, ebx    ; eax = rbSrc - rbDest;
                          imul eax, opac   ; eax = (rbSrc - rbDest) * opac;
                          sar eax, 5h     ; eax >>= 5 or eax /= 32;
                          add eax, ebx    ; rb += rbDest; 
                          // alpha * (A - B) + B
                          //rb = (((rbSrc - rbDest) * opac) >> 5) + rbDest;
    
                          mov bx, di           ; bx = *src;
                          and ebx, greenMask   ; gSrc = src & GRN;

                          mov cx, si           ; cx = *dest;
                          and ecx, greenMask   ; gDest = dest & GRN;

                          // alpha * (A - B) + B
                          sub ebx, ecx     ; gSrc -= gDest;
                          imul ebx, opac   ; ebx = gSrc * opac;
                          sar ebx, 5       ; ebx = ebx >> 5;
                          add ebx, ecx     ; gSrc = gSrc + gDest;
                          //g = (((gSrc - gDest)  * opac) >> 5) + gDest;

                          and eax, edx           ; rb &= redBlueMask;
                          and ebx, greenMask     ; g  &= GRN;
                          or  eax, ebx           ; rb = rb | g;
                          
                          // *dest = rb
                          mov ebx, dword ptr[dest];
                          mov word ptr[ebx], ax;
                      }
                      
#endif
                      dest++;
                      src++;
                  }
              }
          }


          //TraceTag(("<----Unlocking2 %x\n",srcSurf));
          //srcSurf->Unlock(srcDesc.lpSurface);
          //printf("<----Unlocking1 %x\n",destSurf);
          //destSurf->Unlock(destDesc.lpSurface);
          break;
      }

      case 24:
        //
        // ------- 24 BPP -------------
        //
      {
          register unsigned char *src = 0;
          register unsigned char *dest = 0;

          register int opac = int(255.0 * opacity);
          register int destOpacity = 255 - opac;

          register int leftBytes = 3 * left; // 3 bytes per pixel
          register int destLeftBytes = leftBytes  +  3 * xOffset;

          //
          // This alg assumes ff ff ff for rgb (or bgr, whatever)
          //

          #define BlendByte(src, dest, opac, destOpac)  (((src * opac) >> 8) + ((dest * destOpac) >> 8))

          if(doClrKey) 
          {
              // color key is in the bottom 24 bits.
              clrKey = clrKey & 0x00ffffff;

              //
              // Alpha with color key in rect
              //
              for(j=top; j < bottom; j++)
              {
                  src = ((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                  dest = ((unsigned char *)destp + destPitch * (j+yOffset)  + destLeftBytes);
                  
                  for(i=left; i < right-1; i++)
                  {
                      if(clrKey != ( *((DWORD *)src) & 0x00ffffff ) ) 
                      {
                          *dest = BlendByte(*src, *dest, opac, destOpacity);
                          dest++; src++;
                          *dest = BlendByte(*src, *dest, opac, destOpacity);
                          dest++; src++;
                          *dest = BlendByte(*src, *dest, opac, destOpacity);
                          dest++; src++;
                      } 
                      else 
                      {
                          dest += 3;
                          src += 3;
                      }
                  }

                  // deal with the last pixel in the scanline, we may only have
                  // 3 bytes (not a dword) left on the surface.
                  DWORD lastpel = (*((WORD *)src) | *(src+2) << 16);
                  if(clrKey != lastpel)
                  {
                      *dest = BlendByte(*src, *dest, opac, destOpacity);
                      dest++; src++;
                      *dest = BlendByte(*src, *dest, opac, destOpacity);
                      dest++; src++;
                      *dest = BlendByte(*src, *dest, opac, destOpacity);
                      dest++; src++;
                  }
                  else
                  {
                      dest += 3;
                      src += 3;
                  }
              }
          } 
          else 
          {

              //
              // Alpha in rect, no color key.. save a test each pixel.
              //
              for(j=top; j < bottom; j++) 
              {
                  src = ((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                  dest = ((unsigned char *)destp + destPitch * (j+yOffset)  + destLeftBytes);
                  
                  for(i=left; i < right; i++)
                  {
                      *dest = BlendByte(*src, *dest, opac, destOpacity);
                      dest++; src++;
                      *dest = BlendByte(*src, *dest, opac, destOpacity);
                      dest++; src++;
                      *dest = BlendByte(*src, *dest, opac, destOpacity);
                      dest++; src++;
                  }
              }
          }

          //srcSurf->Unlock(srcDesc.lpSurface);
          //destSurf->Unlock(destDesc.lpSurface);

          #undef BlendByte
          break;
      }


      case 32:
        //
        // ------- 32 BPP -------------
        //
      {
          register DWORD *src = 0;
          register DWORD *dest = 0;

          register int opac = int(255.0 * opacity);
          register int destOpacity = 255 - opac;

          register int leftBytes = 4 * left; // 4 bytes per pixel
          register int destLeftBytes = leftBytes + 4*xOffset;

          //
          // This alg assumes ff ff ff for rgb (or bgr, whatever)
          //

          if(doClrKey) 
          {
              //
              // Alpha with color key in rect
              //
              for(j=top; j < bottom; j++) 
              {
                  src = (DWORD *)((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                  dest = (DWORD *)((unsigned char *)destp + destPitch * (j+yOffset)  + destLeftBytes);

                  for(i=left; i < right; i++) 
                  {
                      if(clrKey != *src)
                      {
                          *dest = BlendDWORD(*dest, destOpacity, *src, opac,
                                             redShift, greenShift, blueShift,
                                             redMask, greenMask, blueMask,
                                             redBlueMask);
                      } 
                      dest++; src++;
                  }
              }
          } 
          else 
          {
              //
              // Alpha in rect, no color key.. save a test each pixel.
              //
              for(j=top; j < bottom; j++) 
              {
                  src = (DWORD *)((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                  dest = (DWORD *)((unsigned char *)destp + destPitch * (j+yOffset)  + destLeftBytes);
                  
                  for(i=left; i < right; i++)
                  {
                      *dest = BlendDWORD(*dest, destOpacity, *src, opac,
                                         redShift, greenShift, blueShift,
                                         redMask, greenMask, blueMask,
                                         redBlueMask);
                      dest++; src++;
                  }
              }
          }

          break;
      }

      default:
        // Opacity not supported at this bit depth
        RaiseException_UserError(E_FAIL, IDS_ERR_IMG_OPACITY_DEPTH);
        break;
    }

    //TraceTag((tagImageDeviceAlpha, "<----Unlocking srcSurf %x",srcSurf));
    srcSurf->Unlock(srcDesc.lpSurface);
    if(destSurf) {
        destSurf->Unlock(destDesc.lpSurface);
    }
    
}


//-----------------------------------------------------
// A l p h a   B l i t
//
// Combines the src dword (after premultiplying it) with
// the destination surface colors using opacity within
// rect
//-----------------------------------------------------
void DirectDrawImageDevice::
AlphaBlit(LPDDRAWSURFACE destSurf, 
          RECT *rect, 
          Real opacity,
          DWORD src)
{
    Assert(rect && "NULL rect in AlphaBlit");

    DWORD redMask   = _viewport._targetDescriptor._pixelFormat.dwRBitMask;
    DWORD greenMask = _viewport._targetDescriptor._pixelFormat.dwGBitMask;
    DWORD blueMask  = _viewport._targetDescriptor._pixelFormat.dwBBitMask;
    DWORD redBlueMask = redMask | blueMask;

    DWORD redShift   = _viewport._targetDescriptor._redShift;
    DWORD greenShift = _viewport._targetDescriptor._greenShift;
    DWORD blueShift  = _viewport._targetDescriptor._blueShift;
    
    int left = rect->left;
    int right = rect->right;
    int top = rect->top;
    int bottom = rect->bottom;

    //
    // Grab lock
    //
    DDSURFACEDESC destDesc;
    destDesc.dwSize = sizeof(DDSURFACEDESC);

    _ddrval = destSurf->Lock(NULL, &destDesc, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
    IfDDErrorInternal(_ddrval, "Can't Get destSurf lock for premultiplied AlphaBlit");
    
    void *destp = destDesc.lpSurface;

    register int i;
    register int j;

    //
    // Switch on bit depth & do the alpha conversion
    //

    switch(_viewport._targetDescriptor._pixelFormat.dwRGBBitCount) {
      case 8:
        //
        // use stipling
        // 
      {
          register unsigned char *dest = 0;
          register unsigned char srcb = (unsigned char)src;

          //register int opac = int(31.0 * opacity);
          //register int destOpacity = 31 - opac;
          register int randPercent = int(opacity * RAND_MAX);

          register int leftBytes = left;  // 1 byte per pixel

          #define BlendByte(src, dest, percent)  if(rand() < percent) { dest = src; }
          
          srand(777);

          //
          // Alpha in rect using stippling
          //
          for(j=top; j < bottom; j++) 
          {
              dest = ((unsigned char *)destp + destDesc.lPitch * j  + leftBytes);
              
              for(i=left; i < right; i++)
              {
                  BlendByte(srcb, *dest, randPercent);
                  dest++;
              }
          }

          destSurf->Unlock(destDesc.lpSurface);

          #undef BlendByte
          break;
      }
        break;
      case 16:
      {
          register WORD *dest;
          register WORD srcw = WORD(src);

          int opac = int(31.0 * opacity);
          register int destOpacity = 31 - opac;

          // premultiply source word
          srcw = BlendWORD(0, destOpacity, srcw, opac,
                           redShift, greenShift, blueShift,
                           (WORD)redMask, (WORD)greenMask, (WORD)blueMask,
                           (WORD)redBlueMask);

          register int leftBytes = 2 * left; // 2 bytes per pixel

              //
              // Alpha in rect, no color key.. save a test each pixel.
              //
              for(j=top; j < bottom; j++) 
              {
                  dest = (WORD *) ((BYTE *)destp + destDesc.lPitch * j  + leftBytes);
                  
                  for(i=left; i < right; i++) 
                  {
                      *dest = BlendPremulWORD(*dest, destOpacity, srcw,
                                              redShift, greenShift, blueShift,
                                              (WORD)redMask, (WORD)greenMask, (WORD)blueMask,
                                              (WORD)redBlueMask);
                      dest++;
                  }
              }

          destSurf->Unlock(destDesc.lpSurface);
          break;
      }

      case 24:
        //
        // ------- 24 BPP -------------
        //
      {
          register unsigned char *dest = 0;
          register unsigned char *srcp = (unsigned char *) (&src);

          int opac = int(255.0 * opacity);
          register int destOpacity = 255 - opac;

          // Premultiply src
          *srcp = (*srcp * opac) >> 8;
          *(srcp+1) = (*(srcp+1) * opac) >> 8;
          *(srcp+2) = (*(srcp+2) * opac) >> 8;

          register int leftBytes = 3 * left; // 3 bytes per pixel

          //
          // This alg assumes ff ff ff for rgb (or bgr, whatever)
          //

          #define BlendByte(src, dest, destOpacity)  ( src + ((dest * destOpacity) >> 8) )

              //
              // Alpha in rect, no color key.. save a test each pixel.
              //
              for(j=top; j < bottom; j++) 
              {
                  dest = ((unsigned char *)destp + destDesc.lPitch * j  + leftBytes);
                  
                  for(i=left; i < right; i++)
                  {
                      *dest = BlendByte(*srcp, *dest, destOpacity);
                      dest++; 
                      *dest = BlendByte(*(srcp+1), *dest, destOpacity);
                      dest++; 
                      *dest = BlendByte(*(srcp+2), *dest, destOpacity);
                      dest++; 
                  }
              }

          destSurf->Unlock(destDesc.lpSurface);

          #undef BlendByte
          break;
      }


      case 32:
        //
        // ------- 32 BPP -------------
        //
      {
          register DWORD *dest = 0;
          register DWORD srcw = src;

          int opac = int(255.0 * opacity);
          register int destOpacity = 255 - opac;

          // premultiply source double word

          srcw = BlendDWORD(0, destOpacity, srcw, opac,
                            redShift, greenShift, blueShift,
                            redMask, greenMask, blueMask,
                            redBlueMask);

          register int leftBytes = 4 * left; // 4 bytes per pixel

          //
          // Alpha in rect, no color key.. save a test each pixel.
          //
          for(j=top; j < bottom; j++) 
          {
              dest = (DWORD *)((unsigned char *)destp + destDesc.lPitch * j  + leftBytes);
              
              for(i=left; i < right; i++)
              {
                  *dest = BlendPremulDWORD(*dest, destOpacity, srcw,
                                           redShift, greenShift, blueShift,
                                           redMask, greenMask, blueMask,
                                           redBlueMask);
                  dest++; 
              }
          }
          
          destSurf->Unlock(destDesc.lpSurface);
          break;
      }

      default:
        // Opacity not supported at this bit depth
        RaiseException_UserError(E_FAIL, IDS_ERR_IMG_OPACITY_DEPTH);
        break;
    }
}





//-----------------------------------------------------
// C O L O R  K E Y  B L I T
//
//-----------------------------------------------------
void DirectDrawImageDevice::
ColorKeyBlit(destPkg_t *destPkg,
             RECT *srcRect,
             LPDDRAWSURFACE srcSurf, 
             DWORD clrKey,
             RECT *clipRect,
             RECT *destRect)
{
    Assert(sizeof(WORD) == 2 && "Hm... WORD isn't 2 bytes");
    Assert(srcRect && "NULL srcRect in AlphaBlit");
    Assert((clipRect!=NULL ? destRect!=NULL : destRect==NULL) && "clipRect & destRect must be both null or not");

    #if _DEBUG
    if(destRect) {
        Assert( (destRect->right - destRect->left) == (srcRect->right - srcRect->left) && 
                "widths differ: alphaBlit src and dest rect");
        Assert( (srcRect->bottom - srcRect->top) == (destRect->bottom - destRect->top) && 
                "heights differ: alphaBlit src and dest rect");
    }
    #endif
    
    //
    // basically clip the rectanlges
    //
    RECT modSrcRect = *srcRect;
    int xOffset = 0;
    register int yOffset = 0;

    if( destRect ) {

        xOffset = destRect->left - srcRect->left;
        yOffset = destRect->top - srcRect->top;

        RECT insctRect;
        IntersectRect(&insctRect, destRect, clipRect);

        if( EqualRect(&insctRect, destRect) ) {
            //
            // rect is within the extent of the viewport. no clipping necessary
            //
        } else {
            if( IsRectEmpty(&insctRect) ) {
                //
                // No rectangle !
                //
                return;
            } else {
                //
                // valid, but needs clipping
                //
                OffsetRect(&insctRect, -xOffset, -yOffset);

                IntersectRect(&modSrcRect, &insctRect, srcRect);
                TraceTag((tagImageDeviceInformative,
                          "clipped alpha rect: (%d %d %d %d)",
                          srcRect->left,srcRect->top,srcRect->right,srcRect->bottom));
                
            }
        }

        Assert( (modSrcRect.right - modSrcRect.left) == (insctRect.right - insctRect.left) && 
               "widths differ: alphaBlit modSrcRect and insctRect rect");
        Assert( (modSrcRect.bottom - modSrcRect.top) == (insctRect.bottom - insctRect.top) && 
               "heights differ: alphaBlit modSrcRect and insctRect rect");
    }

    int left = modSrcRect.left;
    int right = modSrcRect.right;
    int top = modSrcRect.top;
    int bottom = modSrcRect.bottom;


    DWORD redMask   = _viewport._targetDescriptor._pixelFormat.dwRBitMask;
    DWORD greenMask = _viewport._targetDescriptor._pixelFormat.dwGBitMask;
    DWORD blueMask  = _viewport._targetDescriptor._pixelFormat.dwBBitMask;
    DWORD redBlueMask = redMask | blueMask;

    DWORD redShift   = _viewport._targetDescriptor._redShift;
    DWORD greenShift = _viewport._targetDescriptor._greenShift;
    DWORD blueShift  = _viewport._targetDescriptor._blueShift;
    

    //
    // Grab locks
    //
    DDSURFACEDESC destDesc;
    DDSURFACEDESC srcDesc;
    destDesc.dwSize = sizeof(DDSURFACEDESC);
    srcDesc.dwSize = sizeof(DDSURFACEDESC);

    void *destp;
    long destPitch;
    LPDDRAWSURFACE destSurf;
    if(destPkg->isSurface) {
        destSurf = destPkg->lpSurface;
    
        destDesc.dwFlags = DDSD_PITCH | DDSD_LPSURFACE;
        _ddrval = destSurf->Lock(NULL, &destDesc, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
        IfDDErrorInternal(_ddrval, "Can't Get destSurf lock for AlphaBlit");
        destp = destDesc.lpSurface;
        destPitch = destDesc.lPitch;
    } else {
        destSurf = NULL;
        destp = destPkg->lpBits;  
        destPitch = destPkg->lPitch;
        // bits point to top left of cliprect on dest!
        // xxx boy this is a bad hack if I've ever seen one...  
        xOffset = - left;
        yOffset = - top;
    }
    
    //printf("--->Locking2 %x\n",srcSurf);
    _ddrval = srcSurf->Lock(NULL, &srcDesc, DDLOCK_READONLY | DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
    if(_ddrval != DD_OK) {
        if(destSurf) {
            destSurf->Unlock(destDesc.lpSurface);
        }
        IfDDErrorInternal(_ddrval, "Can't Get srcSurf lock for AlphaBlit");
    }

    void *srcp  = srcDesc.lpSurface;

    register int i;
    register int j;

    __try {
        //
        // Switch on bit depth & do the alpha conversion
        //

        switch(_viewport._targetDescriptor._pixelFormat.dwRGBBitCount) {
          case 8:
          {
              register unsigned char *src = 0;
              register unsigned char *dest = 0;

              register int leftBytes = left;  // 1 byte per pixel
              register int destLeftBytes = left + xOffset;

              for(j=top; j < bottom; j++) 
                {
                    src = ((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                    dest = ((unsigned char *)destp + destPitch * (j+yOffset) + destLeftBytes);
                  
                    for(i=left; i < right; i++) 
                      {
                          if(clrKey != *src)
                            {
                                *dest = *src;
                            } 
                          dest++; src++;
                      }
                }
          
              break;
          }

          case 16:
          {
              register WORD *src = 0;
              register WORD *dest = 0;

              register int leftBytes = 2 * left; // 2 bytes per pixel
              register int destLeftBytes = leftBytes + 2*xOffset;

              for(j=top; j < bottom; j++) 
                {
                    src = (WORD *) ((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                    dest = (WORD *) ((unsigned char *)destp + destPitch * (j+yOffset) + destLeftBytes);
                
                    for(i=left; i < right; i++) 
                      {
                          if(!((j == bottom-1) && (i == right-1)))
                          {
                            if(clrKey != *src) 
                            {
                                *dest = *src;
                            }

                            dest++;
                            src++;

                          } else {

                              DWORD lastPixel;
                              unsigned char *pbDest=(UCHAR*)dest,*pbSrc=(UCHAR*)src;

                              // read and write 1 byte at a time to make sure we dont go past end boundary
                              // assumes little-endian byte order
                              lastPixel = (((*pbSrc+1)) << 8) | *pbSrc;
                      
                              if(lastPixel != clrKey) {
			        *pbDest = *pbSrc;
			        pbDest++; pbSrc++;
			        *pbDest = *pbSrc;
			        pbDest++; pbSrc++;
                              }
                          }
		      }
                }
              break;
          }

          case 24:
            //
            // ------- 24 BPP -------------
            //
          {
              register unsigned char *src = 0;
              register unsigned char *dest = 0;

              register int leftBytes = 3 * left; // 3 bytes per pixel
              register int destLeftBytes = leftBytes  +  3 * xOffset;

              //
              // This alg assumes ff ff ff for rgb (or bgr, whatever)
              //

              // color key is in the bottom 24 bits.
              clrKey = clrKey & 0x00ffffff;
          
              //
              // Alpha with color key in rect
              //
              for(j=top; j < bottom; j++) 
                {
                      src = ((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                      dest = ((unsigned char *)destp + destPitch * (j+yOffset)  + destLeftBytes);

                      for(i=left; i < right; i++)
                      {
                        if(!((j == bottom-1) && (i == right-1)))
                          {
                                // this assumes little-endian dwords
                                if(clrKey != ( *((DWORD *)src) & 0x00ffffff ) ) 
                                  {
                                      *dest = *src;
                                      dest++; src++;
                                      *dest = *src;
                                      dest++; src++;
                                      *dest = *src;
                                      dest++; src++;
                                  } 
                                else 
                                  {
                                      dest += 3;
                                      src += 3;
                                  }
                          } else {

                                  // we are on the last pixel.  *((DWORD *)src) would
                                  // fetch 4 bytes, but there are only 3 left in the pixmap
                                  // so it would fault.  workaround: explicitly fetch the
                                  // last 3 bytes

                                  DWORD lastPixel;

                                     // assumes little-endian byte order
                                     lastPixel = ((*(src+2)) << 16) | ((*(src+1)) << 8) | *src;

                                     if(lastPixel != clrKey) {
                                       *dest++ = *src++;
                                       *dest++ = *src++;
                                       *dest++ = *src++;
                                     }
                          }
                        }
                }
              break;
          }


          case 32:
            //
            // ------- 32 BPP -------------
            //
          {
              register DWORD *src = 0;
              register DWORD *dest = 0;

              register int leftBytes = 4 * left; // 4 bytes per pixel
              register int destLeftBytes = leftBytes + 4*xOffset;

              //
              // This alg assumes ff ff ff for rgb (or bgr, whatever)
              //

              for(j=top; j < bottom; j++) 
                {
                    src = (DWORD *)((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                    dest = (DWORD *)((unsigned char *)destp + destPitch * (j+yOffset)  + destLeftBytes);
                
                    for(i=left; i < right; i++) 
                      {
                          if(clrKey != *src)
                            {
                                *dest = *src;
                            } 
                          dest++; src++;
                      }
                }
              break;
          }

          default:
            // Opacity not supported at this bit depth
            RaiseException_UserError(E_FAIL, IDS_ERR_IMG_OPACITY_DEPTH);
            break;
        }

    } __except (EXCEPTION(0xc0000005)) {
        // This will catch all ACCESS VIOLATION ececptions
        // with Dx3 we get random crashes.

        // TODO: we should do more research to fix this.

        srcSurf->Unlock(srcDesc.lpSurface);
        if(destSurf) {
            destSurf->Unlock(destDesc.lpSurface);
        }
        return;
    }


    srcSurf->Unlock(srcDesc.lpSurface);
    if(destSurf) {
        destSurf->Unlock(destDesc.lpSurface);
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\2drender.cpp ===
/*******************************************************************************
Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

    Implement methods for 2d rendering for the DirectDrawImageDevice class.

*******************************************************************************/

#include "headers.h"

#include <d3d.h>
#include <privinc/d3dutil.h>
#include <privinc/dddevice.h>
#include <privinc/linei.h>
#include <privinc/path2i.h>
#include <privinc/cropdimg.h>
#include <privinc/overimg.h>
#include <privinc/transimg.h>
#include <privinc/geometry.h>
#include <privinc/SurfaceManager.h>
#include <privinc/DaGdi.h>
#include <backend/bvr.h>
#include <appelles/path2.h>

DeclareTag(tagImageDeviceSimpleBltTrace,    "ImageDevice", "Trace simple blt");
DeclareTag(tagImageDeviceHighQualityXforms, "ImageDevice", "Override: turn on high quality xforms");
DeclareTag(tagRMGradientWorkaround, "2D", "Turn on 2dGradient edge workaround for d3drm");
DeclareTag(tagShowBezierPicking, "Picking", "Display bezier picking in action");

//
// Forward Decl
//


typedef struct {
    Image *image;
    DirectDrawImageDevice *dev;
    DDSurface  *srcDDSurf;
    DDSurface  *destDDSurf;
    HDC dc;
} devCallBackCtx_t;

#if _DEBUG
void DoBits16(LPDDRAWSURFACE surf16, LONG width, LONG height);
void DoBits32(LPDDRAWSURFACE surf16, LONG width, LONG height);
#endif


void DirectDrawImageDevice::RenderGradientImage (
    GradientImage *img,
    int            pointCount,
    Point2Value  **points,
    Color        **colors)
{
    SetDealtWithAttrib(ATTRIB_CROP, true);
    SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, true);
    SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, true);

    // optimize: in the future d3d could do opacity for us.
    //SetDealtWithAttrib(ATTRIB_OPAC, true);

    DDSurface *destDDSurf;
    if(!AllAttributorsTrue()) {
        destDDSurf = GetCompositingStack()->ScratchDDSurface();
    } else {
        destDDSurf = GetCompositingStack()->TargetDDSurface();
    }


    int i;
    for (i=2;  i < pointCount;  ++i)
    {
        Point2Value *pts[3];
        Color  *clrs[3];
        int     numPts = 3;

        pts[0] = points[ 0 ];
        pts[1] = points[i-1];
        pts[2] = points[ i ];

        clrs[0] = colors[ 0 ];
        clrs[1] = colors[i-1];
        clrs[2] = colors[ i ];

        // ASSERT: this is a convex polygon!
        // optimize: GradientImage class owns one of these already
        BoundingPolygon *polygon = NewBoundingPolygon();
        polygon->AddToPolygon(numPts, pts);

        bool doInclusiveCrop = true;
        DoBoundingPolygon(*polygon, doInclusiveCrop);

        polygon->Crop (destDDSurf->Bbox());

        //
        // Crop with clipBox
        //
        //
        // If this is the target surf, make sure our rect is
        // offset (if needed) and intersected with viewport.
        //
        // COMPOSITE
        RECT destRect = *(destDDSurf->GetSurfRect());
        Bbox2 destBox = destDDSurf->Bbox();

        if( IsCompositeDirectly() &&
            destDDSurf == _viewport._targetPackage._targetDDSurf ) {

            // compositing directly to target...
            Assert(_viewport._targetPackage._prcViewport);

            destRect = *_viewport._targetPackage._prcViewport;
            RectToBbox( WIDTH(&destRect),
                        HEIGHT(&destRect),
                        destBox,
                        _viewport.GetResolution());

            // Intersect with clip
            if(_viewport._targetPackage._prcClip) {
                IntersectRect(&destRect,
                              &destRect,
                              _viewport._targetPackage._prcClip);
            }

            // intersect with surf rect
            IntersectRect(&destRect,
                          &destRect,
                          destDDSurf->GetSurfRect());


            //
            // The dest bbox needs to be clipped in proportion to the destRect
            //
            RECT *origRect = _viewport._targetPackage._prcViewport;
            Real rDiff;
            if(destRect.left > origRect->left) {
                rDiff = Real(destRect.left -  origRect->left) / GetResolution();
                destBox.min.x += rDiff;
            }
            if(destRect.right <  origRect->right) {
                rDiff = Real(destRect.right -  origRect->right) / GetResolution();
                destBox.max.x += rDiff;
            }
            if(destRect.top >  origRect->top) {
                // positive diff mean the top fell
                rDiff = - Real(destRect.top -  origRect->top) / GetResolution();
                destBox.max.y += rDiff;
            }
            if(destRect.bottom <  origRect->bottom) {
                rDiff = - Real(destRect.bottom -  origRect->bottom) / GetResolution();
                destBox.min.y += rDiff;
            }

            // temp debug
            //static DWORD c=13;
            //_viewport.ClearSurface(destDDSurf->IDDSurface(), c+=29, &destRect);
            // temp debug

            //
            // Crop polygon to clip box
            //
            polygon->Crop(destBox);
        }

        Color **interpolatedColors = clrs;

        interpolatedColors = (Color **)
            AllocateFromStore (polygon->GetPointCount() * sizeof(Color*));

        //
        // Copy orig polygon to d3d verts
        //
        Point2Value *xfPt;
        D3DRMVERTEX *d3dVertArray =
            (D3DRMVERTEX *) AllocateFromStore (numPts * sizeof(D3DRMVERTEX));

        int vi;
        for(vi=0;  vi < numPts;  vi++) {

            xfPt = TransformPoint2Value(GetTransform(), pts[vi]);

            // Coord in dest surface
            d3dVertArray[vi].position.x = D3DVALUE(xfPt->x);
            d3dVertArray[vi].position.y = D3DVALUE(xfPt->y);
            d3dVertArray[vi].position.z = D3DVALUE(0);
        }

        Point2Value *pt;
        Real barycoords[3];
        Point3Value pts3[3];
        Point2Value pts2[3];
        Point2Value **vertArray = (Point2Value **)
            AllocateFromStore (polygon->GetPointCount() * sizeof(Point2Value*));

        // XXX: this assumes that render3dpoly will pull verts out in
        // the same order...
        bool bReversed;
        if(polygon->GetPointArray(vertArray, true, &bReversed) < 3) {
            // not enough pts in vertArray
            continue;
        }
        int index;

        int p;
        for(p=0; p<polygon->GetPointCount(); p++) {

            pt = vertArray[p];

            Point3Value pt3(pt->x, pt->y, 0);
            GetTriFanBaryCoords(pt3,
                                numPts,
                                d3dVertArray,
                                barycoords,
                                &index);

            int index2;

            if (bReversed) {
                Assert (index != 0);
                index2 = numPts - index; // index is based off of
                                         // original clrs array.
                index = index2 - 1;
            } else {
                index2 = index + 1;
            }

            Real red = barycoords[0] * clrs[0]->red +
                barycoords[1] * clrs[index]->red +
                barycoords[2] * clrs[index2]->red;

            Real green = barycoords[0] * clrs[0]->green +
                barycoords[1] * clrs[index]->green +
                barycoords[2] * clrs[index2]->green;

            Real blue = barycoords[0] * clrs[0]->blue +
                barycoords[1] * clrs[index]->blue +
                barycoords[2] * clrs[index2]->blue;

            // The points are already reversed but the
            // Render3DPolygon also reverses the points.  So we
            // need to make them reversed again.
            // TODO: Need to make this more optimal

            // The reverse of the vertices is done like:
            // [v0 v1 v2 ... vn-1 vn]  reverse-> [v0 vn vn-1 ... v2 v1]
            //
            int clridx;

            if (bReversed) {
                clridx = p?(polygon->GetPointCount() - p):0;
            } else {
                clridx = p;
            }

            interpolatedColors[clridx] = NEW Color(red, green, blue);

        }

        Render3DPolygon(NULL, destDDSurf, polygon, NULL, interpolatedColors, false);

        // Free the items that we allocated
        if (interpolatedColors) DeallocateFromStore(interpolatedColors);
        if (vertArray) DeallocateFromStore(vertArray);
        if (d3dVertArray) DeallocateFromStore(d3dVertArray);

    }

}

void DirectDrawImageDevice::
TransformPointsToGDISpace(Transform2   *a,
                          Point2Value **srcPts,
                          POINT        *gdiPts,
                          int           numPts)
{ ::TransformPointsToGDISpace(a,srcPts,gdiPts,numPts,_viewport.Width()/2,
                             _viewport.Height()/2,GetResolution());
}

void DirectDrawImageDevice::
TransformPointsToGDISpace(Transform2   *a,
                          Point2       *ptArray,
                          POINT        *gdiPts,
                          int           numPts)
{ ::TransformPoint2ArrayToGDISpace(a,ptArray,gdiPts,numPts,_viewport.Width()/2,
                             _viewport.Height()/2,GetResolution());
}


void DirectDrawImageDevice::
_ScalePenWidth( Transform2 *xf, Real inWidth, Real *outRealW )
{
    Real xs, ys;
    DecomposeMatrix( xf, &xs, &ys, NULL );
    Real scale = (xs + ys) * 0.5;

    // NOTE: this is NOT intended to be in meters!  this is the
    // continuous version of the width of the pen, but it's subpixel
    // accurate (no truncation!).
    *outRealW = scale * inWidth * GetResolution();
}

#define NO_LINE 0

void DirectDrawImageDevice::
RenderLine(Path2 *path, LineStyle *style)
{
    if(!CanDisplay()) return;

    // bail if the dashStyle is NULL
    if( style->GetDashStyle() == ds_Null ) {
        ResetAttributors();
        return;
    }

        
    // final box is for post clip, post crop, post xform to determine culling
    Bbox2 finalBox = _viewport.GetTargetBbox();
    
    // if we're cropped out of existance
    Bbox2 accumCropBox = NullBbox2;
    if( IsCropped() ) {

        Bbox2 pathBox = path->BoundingBox();

        // figure out the width of the line and augment the bbox...
        double dwidth   = 1.0;
        if(!style->Detail() && style->Width() != 0.0) {
            _ScalePenWidth( GetTransform(), style->Width(), &dwidth );
            pathBox.min.x -= dwidth;
            pathBox.min.y -= dwidth;
            pathBox.max.x += dwidth;
            pathBox.max.y += dwidth;
        }
        accumCropBox = DoBoundingBox(pathBox);
        finalBox = IntersectBbox2Bbox2(finalBox, accumCropBox);

        // CULL
        if( finalBox == NullBbox2 ) {
            ResetAttributors();
            return;
        }
    }

    // FIX: TODO: for complex xf, need to figure out dest extent and
    // render that so we don't see clipped lines after transforming surface

    DDSurface *targDDSurf = GetCompositingStack()->TargetDDSurface();
    DDSurface *opacDDSurf = NULL;
    DAGDI &myGDI = *(GetDaGdi());

    bool bAA = UseImageQualityFlags(
        CRQUAL_AA_LINES_ON | CRQUAL_AA_LINES_OFF,
        CRQUAL_AA_LINES_ON,
        style->GetAntiAlias());


    myGDI.SetAntialiasing(bAA);

    if(myGDI.GetDx2d() && !myGDI.DoAntiAliasing())
    {
        myGDI.SetSampleResolution(1);
        myGDI.SetAntialiasing(true);
    }

    if(myGDI.DoAntiAliasing()) {
        SetDealtWithAttrib(ATTRIB_OPAC, true);

        myGDI.SetViewportSize(_viewport._width,_viewport._height );
    }

    //
    // If we need to do opacity, grab a temporary surface
    // for RenderLine
    //
    #define LINE_OPAC 1
    #if LINE_OPAC
    if( !GetDealtWithAttrib(ATTRIB_OPAC) ) {
        GetCompositingStack()->GetSurfaceFromFreePool(&opacDDSurf, dontClear);
    }
    #endif

    CompositingSurfaceReturner goBack(GetCompositingStack(),
                                      opacDDSurf,
                                      true);

    // lines can do everything, baby.
    SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, true);
    SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, true);
    SetDealtWithAttrib(ATTRIB_CROP, true);
    #if LINE_OPAC
    SetDealtWithAttrib(ATTRIB_OPAC, true);
    #endif

    if( !AllAttributorsTrue() &&
        (targDDSurf == GetCompositingStack()->TargetDDSurface()) ) {
        targDDSurf = GetCompositingStack()->ScratchDDSurface();
    }

    RenderLine(path, style, targDDSurf, opacDDSurf);

    // implicit: Return the borrowed surface
}

void DirectDrawImageDevice::
RenderLine(Path2 *path,
           LineStyle *style,
           DDSurface *finalTargetDDSurf,
           DDSurface *opacDDSurf)

{
    bool bLineCorrect   = false;

    DAGDI &myGDI = *(GetDaGdi());
    DDSurface *targDDSurf = finalTargetDDSurf;
    if( opacDDSurf ) {
        Assert( IsTransparent() &&
                "RenderLine asked to do opacity but"
                "we're not transparent");
        targDDSurf = opacDDSurf;
    }

    Transform2 *xfToUse = GetTransform();

    // COMPOSITE
    // if we're composite to targ, transform the points a bit.
    xfToUse = DoCompositeOffset(targDDSurf, xfToUse);

    bool pathCanRenderNatively = path->CanRenderNatively();
    if( pathCanRenderNatively ) {
        myGDI.SetSuperScaleFactor(1.0);
    }
    else if(sysInfo.IsWin9x()) {
        // This to take care to the 'Taco' issue ( win9x GDI 16-bit runnover)
        // Only if we are on windows 9x.

        Bbox2 pathBbox = TransformPath2(xfToUse,path)->BoundingBox();
        Bbox2 viewBbox = _viewport._targetBbox;
        viewBbox        = DoCompositeOffset(targDDSurf, viewBbox);
        double dwidth   = 1.0;
        if(!style->Detail() && style->Width() != 0.0) {
            _ScalePenWidth( GetTransform(), style->Width(), &dwidth );
        }

        dwidth /= GetResolution();

        if(!viewBbox.Contains(pathBbox) || dwidth >= 10) {
            // box is not contained......see if we intersect.
            Bbox2 Bbox = IntersectBbox2Bbox2(viewBbox,pathBbox);
            if((!(Bbox == NullBbox2)) || dwidth >= 10) {
                // We are contained.

                // Determine the scale needed to get this into 1 meter space.
                // ..we need to find the max of the width and height.
                float max = MAX(MAX(fabs(pathBbox.max.x),fabs(pathBbox.min.x)),
                                MAX(fabs(pathBbox.max.y),fabs(pathBbox.min.y)));
                if(max >= 10.0 || dwidth >= 10) {
                    // only do if view is over a 1 meter.
                    myGDI.SetSuperScaleFactor(10/MAX(max,dwidth));
                    bLineCorrect = true;
                    }
                else
                    myGDI.SetSuperScaleMode(false);
            }
            else
                return; // this is a trivial reject case...
        }
    }



    //
    // Create a pen from 'style' and 'color'
    //
    DAColor dac( style->GetColor(),
                 GetOpacity(),
                 _viewport.GetTargetDescriptor() );

    DWORD colorKey = 0;

    RECT rect;
    rect = *(targDDSurf->GetSurfRect());

    RectRegion  cropRectRegion(NULL);

    if( IsCropped() ) {
       //
       // Derive destination rectangle
       //

        // TODO:
        //Bbox2 *srcImageBox = TransformBbox2Image( GetTransform() , image->BoundingBox());
        //Bbox2 *srcImageBox = image->BoundingBox();

        Bbox2 srcImageBox = UniverseBbox2;
        _boundingBox = IntersectBbox2Bbox2(_viewport.GetTargetBbox(),
                                           DoBoundingBox(srcImageBox));

        if( !_boundingBox.IsValid() ) return;

        // Note that since the image has already been transformed, we need
        // only to get the rectangle in Win32 coords, a straight forward mapping
        // with no transforms from the _boundingBox.  This is a COPY operation
        // basicaly
        DoDestRectScale(&rect, GetResolution(), _boundingBox);

        // CrpRect points to rect
        cropRectRegion.SetRect(&rect);
    } else {

        // it's not cropped, but we can still
        // get a bounding box to make opacity cheaper
        if( opacDDSurf ) {
            //
            // Get a dest bbox & rect
            //
            Bbox2 destBox = TransformBbox2( GetTransform(),
                                            path->BoundingBox() );
            //
            // fudge so we don't clip anything with the opacity blit
            //
            Real tenPix = 10 / GetResolution();
            destBox.min.x -= tenPix;  destBox.min.y -= tenPix;
            destBox.max.x += tenPix;  destBox.max.y += tenPix;
            DoDestRectScale(&rect, GetResolution(), destBox);
        }
    }


    //
    // Set the interesting rect on the surface
    // this could have been modified if IsCropped
    //
    targDDSurf->SetInterestingSurfRect(&rect);

    //
    // Ok, if we have an opacDDSurf, then let's clear
    // it in the dest rect with a guaranteed unique
    // color key
    //
    if( opacDDSurf ) {
        #if 0
        colorKey = _viewport.MapColorToDWORD(penColor) ^ 0x1;
        _viewport.ClearSurface( opacDDSurf->IDDSurface(), colorKey, &rect );
        opacDDSurf->SetColorKey( colorKey );
        #else
        _viewport.ClearDDSurfaceDefaultAndSetColorKey(opacDDSurf);
        #endif
    }

    bool detail = style->Detail();
    DashStyleEnum dashStyle = style->GetDashStyle();

    // we shouldn't be this far if dashStyle is Null.  should return
    // at tope of function.
    Assert( dashStyle != ds_Null );

    bool dashed = (dashStyle != ds_Solid);

    Pen pen( dac );

    if (detail) { // default line, FAST PATH
        pen.AddStyle( dashStyle );

    } else {
        Real width = style->Width();
        // this won't be needed if we give dx2d the xform
        Real scaledRealWidth = width;

        // DAX structured graphics control sets width to 0.0; handle
        // this special case to avoid the expense of decomposing
        // the transformation matrix.

        // also if we are less than 1.5 pixels wide and are not doing aa then we
        // should just use a detail line.

        if (width == 0.0 || 
                ((width < 1.5/GetResolution() ) && (myGDI.GetSampleResolution() == 1) )) {
            width = 1.0;
            scaledRealWidth = 1.0;
            bLineCorrect = false;
            detail = true;
        } else {

            _ScalePenWidth( GetTransform(), width, &scaledRealWidth );

            if(myGDI.DoAntiAliasing()) {
#if DEBUG
                if(!IsTagEnabled(tagAAScaleOff))
#endif
                    if( myGDI.GetSuperScaleMode() == true )
                {
                scaledRealWidth *=myGDI.GetSuperScaleFactor();
                }

            }
        }

        if(!bLineCorrect && detail) { // linewidth is pixel or sub-pixel, use detail
            detail = true;
            pen.AddStyle( dashStyle );

        } else {

            pen.AddStyle( PS_GEOMETRIC |
                          dashStyle |
                          style->GetJoinStyle() << 12 ); // Shift left 3 nibbles to match GDI

            if(path->IsClosed() && myGDI.DoAntiAliasing()) {
                // this is a workaournd for bug 23931 (missing wedge). don't add endstyle
            }
            else {
                pen.AddStyle(style->GetEndStyle() << 8);   // Shift left 2 nibbles to match GDI
            }

            if( style->GetJoinStyle() == js_Miter ) {
                if(style->GetMiterLimit() != -1)
                    pen.SetMiterLimit( style->GetMiterLimit() );
            }
            pen.SetWidth( scaledRealWidth );

        }
    }

    //
    // only draw if we actually got a pen
    //
    if(1) { // penObj scope

        // Can only do a simple rendering if ExtractAsSingleContour() returns
        // true.  If this condition holds, we can just use the GDI
        // Polyline or PolyBezier function, rather than building a GDI path
        // and then stroking.   Note that we have to handle closing the path
        // as a special case.

        // ONLY IF AA
        if(myGDI.DoAntiAliasing()) {
            xfToUse = TimesTransform2Transform2(myGDI.GetSuperScaleTransform(), xfToUse);
        }


        if( IsCompositeDirectly() &&
                targDDSurf == _viewport._externalTargetDDSurface ) {

            RECT croppedRect;
            if (_viewport._targetPackage._prcClip) {
                IntersectRect(&croppedRect,
                              _viewport._targetPackage._prcViewport,
                              _viewport._targetPackage._prcClip);
            } else {
                croppedRect = *_viewport._targetPackage._prcViewport;
            }

            if(cropRectRegion.GetRectPtr()) {
                DoCompositeOffset(targDDSurf, cropRectRegion.GetRectPtr());
            }
            cropRectRegion.Intersect(&croppedRect);

        } // if targ==external

        if( pathCanRenderNatively &&
            !opacDDSurf   &&
            !targDDSurf->ColorKeyIsValid()) {

            // tell the path to render, it knows what to do.  just
            // give it a properly configured dagdi and it'll take care
            // of the rest!

            // Pen must be in meter space, pre transformed!, but only for dx2d
            if( !style->Detail() &&
                style->Width()!=0.0 &&
                (myGDI.GetDx2d() && myGDI.DoAntiAliasing()) ) {
                pen.SetWidth( style->Width() );
            }

            myGDI.SetPen( &pen );
            myGDI.SetClipRegion( &cropRectRegion );
            myGDI.SetDDSurface(targDDSurf);

            #if NO_LINE
            ////////////////////////////////////////
            myGDI.ClearState();
            return;
            ////////////////////////////////////////
            #endif

            path->RenderToDaGdi( &myGDI, xfToUse,
                                 _viewport.Width()/2,
                                 _viewport.Height()/2,
                                 GetResolution() );
            myGDI.ClearState();


            return; // can be smarter and allow opacDDSurf to do it's
                    // thing below.  however, we plan on always having
                    // dx2d around, hence opacDDSurf won't ever be
                    // turned on.
        }

        int    numPts;
        POINT *gdiPts;
        Bool   isPolyline;
        bool   bDoRender = true;

        Bool canDoSimpleRender =
            path->ExtractAsSingleContour(xfToUse,
                                         &numPts,
                                         &gdiPts,
                                         &isPolyline);
        // Windows 95: The PS_ENDCAP_ROUND, PS_ENDCAP_SQUARE, PS_ENDCAP_FLAT,
        // PS_JOIN_BEVEL, PS_JOIN_MITER, and PS_JOIN_ROUND styles are supported
        // only for geometric pens when used to draw paths.

        if (canDoSimpleRender && (!sysInfo.IsWin9x() || detail) &&
                                 (!path->IsClosed() || (detail && !dashed)))
          {
              int ret;
           
              PolygonRegion poly(gdiPts, numPts);

              myGDI.SetPen( &pen );
              myGDI.SetClipRegion( &cropRectRegion );
              myGDI.SetDDSurface(targDDSurf);

            #if NO_LINE
            ////////////////////////////////////////
            myGDI.ClearState();
            return;
            ////////////////////////////////////////
            #endif


              if (isPolyline) {
                  myGDI.Polyline(&poly);
              } else {
                  myGDI.PolyBezier(&poly);
              }

              if (path->IsClosed()) {
                  POINT line[2];
                  line[0] = gdiPts[numPts-1];
                  line[1] = gdiPts[0];
                  PolygonRegion poly_yuk(line, 2);
                  myGDI.Polyline(&poly_yuk);
              }
              myGDI.ClearState();

          } else {

            //
            // Grab the DC from target surface (after above clear!)
            //
            HDC dc = targDDSurf->GetDC("Couldn't Get DC in RenderLine");
            DCReleaser dcReleaser(targDDSurf, "Couldn't release DC on targDDSurf in RenderLine");

            if (dashed) {
                //
                // Transparent for dashed lines
                //
                SetBkMode(dc, TRANSPARENT);
            }

            //
            // Push the AA state because aa lines into dc path doesn't
            // make sense.
            //
            {
                bool isAA       = myGDI.DoAntiAliasing();
                bool isScaleOn  = myGDI.GetSuperScaleMode();
                float scaleFac  = myGDI.GetSuperScaleFactor();
                int  res        = myGDI.GetSampleResolution();
                myGDI.SetAntialiasing(false);
                path->AccumPathIntoDC(dc, xfToUse);
                // restore
                myGDI.SetSuperScaleFactor(scaleFac);
                myGDI.SetSuperScaleMode(isScaleOn);
                myGDI.SetAntialiasing(isAA);
                myGDI.SetSampleResolution(res);
            }

            int ret;
            bool bReleasedDC = false;

            #if NO_LINE
            ////////////////////////////////////////
            myGDI.ClearState();
            return;
            ////////////////////////////////////////
                #endif

            if(bDoRender) {
                myGDI.SetPen(&pen);
                myGDI.SetClipRegion(&cropRectRegion);
                myGDI.SetDDSurface(targDDSurf);
                myGDI.StrokePath( dc, bReleasedDC );
            }

            // don't want to release DC twice :)
            if(bReleasedDC) {
               dcReleaser._surf = NULL; // DC already released.
            }

            myGDI.ClearState();

        }

        //
        // DO OPACITY
        //

        if( opacDDSurf ) {

            #if NO_LINE
            ////////////////////////////////////////
            return;
            ////////////////////////////////////////
            #endif

            Assert(targDDSurf == opacDDSurf);

            // COMPOSITE
            // TODO: need to intersect this rect with the
            // viewport and destsurf rect
            DoCompositeOffset(finalTargetDDSurf, &rect);

            finalTargetDDSurf->SetInterestingSurfRect(&rect);

            //
            // color keyed alpha blit to the finalTargetDDSurf
            // from the opacDDSurf (which is currently targDDSurf)
            //
            destPkg_t destPkg = {true, finalTargetDDSurf->IDDSurface(), NULL};
            TIME_ALPHA(AlphaBlit(&destPkg,
                                 opacDDSurf->GetSurfRect(), // srcRect
                                 opacDDSurf->IDDSurface(),
                                 GetOpacity(),
                                 opacDDSurf->ColorKeyIsValid(),
                                 opacDDSurf->ColorKey(),
                                 finalTargetDDSurf->GetInterestingSurfRect(),
                                 finalTargetDDSurf->GetSurfRect()));
        }

    } // penObj scope
}


bool
DirectDrawImageDevice::DetectHitOnBezier(
    Path2 *bzp,
    PointIntersectCtx& ctx,
    LineStyle *style )
{
    if( ! IsInitialized() ) return false;

    // get the color.
    // paint the hit? pixel another color
    // draw the cropped (down to that pixel) bezier using gdi (no aa!)
    // check the pixel's color

    DAGDI &myGDI = *GetDaGdi();

    ResetContextMembers();

    Point2Value *pt = ctx.GetLcPoint();
    Assert(pt);

    POINT gdiPt;
    TransformPointsToGDISpace(ctx.GetTransform(), &pt, &gdiPt, 1 );

    DWORD x = gdiPt.x;
    DWORD y = gdiPt.y;

    DDSurface *dds = GetCompositingStack()->ScratchDDSurface();

    #if _DEBUG
    if( IsTagEnabled( tagShowBezierPicking ) )
    {
        _viewport.ClearSurface( dds, 0x000fabcd, dds->GetSurfRect() );
    }
    #endif

    DAColor dac( style->GetColor(),
                 1.0,
                 _viewport.GetTargetDescriptor() );


    RECT r;  SetRect( &r, x-2, y-2, x+2, y+2 );
    #if _DEBUG
    if( IsTagEnabled( tagShowBezierPicking ) )
    {
        r = *dds->GetSurfRect();
    }
    #endif

    RectRegion  cropRectRegion(&r);
    Pen pen( dac );
    {
        pen.AddStyle( PS_GEOMETRIC |
                      style->GetDashStyle() |
                      style->GetEndStyle() << 8 |   // Shift left 2 nibbles to match GDI
                      style->GetJoinStyle() << 12 ); // Shift left 3 nibbles to match GDI
        if( style->GetJoinStyle() == js_Miter ) {
            if(style->GetMiterLimit() != -1)
                pen.SetMiterLimit( style->GetMiterLimit() );
        }

        // start at one pixel
        Real width = 1.0 / GetResolution();

        if(!style->Detail() && style->Width() != 0.0) {
            _ScalePenWidth( ctx.GetImageOnlyTransform(), style->Width(), &width );
        }

        pen.SetWidth( width );
    }

    COLORREF fakeClr = pen.GetColorRef();
    fakeClr = RGB(
        GetRValue(fakeClr) + 64,
        GetGValue(fakeClr),
        GetBValue(fakeClr)
        );


    myGDI.SetAntialiasing( false );
    myGDI.SetSuperScaleMode( false );
    myGDI.SetPen(&pen);
    myGDI.SetClipRegion(&cropRectRegion);
    myGDI.SetDDSurface(dds);

    bool bReleasedDC = false;
    HDC dc = dds->GetDC("");
    DCReleaser dcReleaser(dds, "");

    fakeClr = ::SetPixel(dc, x, y, fakeClr);
    Assert( fakeClr != -1 );
    bzp->AccumPathIntoDC(dc, ctx.GetTransform());
    myGDI.StrokePath( dc, bReleasedDC );
    myGDI.ClearState();

    Assert( !bReleasedDC );

    COLORREF outClr = ::GetPixel(dc, x, y);

    // check it. if the color we put on the surface at (x,y) remains
    // the same, we haven't hit.  Hit is outClr different than fakeClr

    bool hit =  outClr != fakeClr;

    #if _DEBUG
    if( IsTagEnabled( tagShowBezierPicking ) )
    {
        dcReleaser.Release();
        showme( dds );
    }
    #endif

    // do some asserts
    return hit;

}

void DirectDrawImageDevice::
RenderDiscreteImageComplex(DiscreteImage *image,
                           DDSurface *srcDDSurf,
                           DDSurface *destDDSurf)
{
    #if 0
    // raise exception if trying to rot/shr dxtransform output
    if( srcDDSurf->HasIDXSurface() ) {
        RaiseException_UserError(DAERR_DXTRANSFORM_UNSUPPORTED_OPERATION,
                                 IDS_ERR_IMG_BAD_DXTRANSF_USE);
    }
    #endif

    Bbox2 srcBox = srcDDSurf->Bbox();

    BoundingPolygon *polygon = NewBoundingPolygon(srcBox);
    DoBoundingPolygon(*polygon);

    // xxx: this isn't necessary if d3d clips polygons
    // that lie off the viewport.  does it ?

    polygon->Crop( destDDSurf->Bbox() );

    GeomRenderer* const geomdev = _viewport.GetGeomDevice (destDDSurf);

    if (!geomdev)
        return;

    bool oldQualState = geomdev->GetDoImageSizedTextures();

    if(GetImageQualityFlags() & CRQUAL_QUALITY_TRANSFORMS_ON) {
        geomdev->SetDoImageSizedTextures(true);
    } else {
        geomdev->SetDoImageSizedTextures(false);
    }

    #if _DEBUG
        if( IsTagEnabled(tagImageDeviceHighQualityXforms) ) {
            geomdev->SetDoImageSizedTextures(true);
        }
    #endif

    RenderComplexTransformCrop(
        srcDDSurf,
        destDDSurf,
        *polygon,
        image);

    geomdev->SetDoImageSizedTextures(oldQualState);
}

void DirectDrawImageDevice::
RenderComplexTransformCrop(DDSurface *srcDDSurf,
                           DDSurface *destDDSurf,
                           BoundingPolygon &destPolygon,
                           DiscreteImage *image)
{
    Render3DPolygon(srcDDSurf, destDDSurf, &destPolygon, image, NULL, false);
}


// improve float consistency.  yeehaw.
// TODO:  Remove these pragmas when VC5 does floating point properly.
#pragma optimize("p", on)


void DirectDrawImageDevice::
Render3DPolygon(DDSurface *srcDDSurf,
                DDSurface *destDDSurf,
                BoundingPolygon *destPolygon,
                DiscreteImage *image,
                Color **clrs,
                bool bUseFirstColor)
{
    Assert(destPolygon && destDDSurf && "bad args to Render3DPolygon");

    // 3D is disabled on Pre-DX3 systems.

    if (sysInfo.VersionD3D() < 3)
        RaiseException_UserError (E_FAIL, IDS_ERR_PRE_DX3);

    // figure out polygonal region:
    //  - calculate destination region by starting with a
    //    rectangle and transforming & cropping it.
    //  - using inverse xform, find 'texture' coords in src
    //    that correspond to vertecies in dest.
    //  - translation component is expressed in viewport
    //    location through d3drm.
    //  - the transform is in image space, but our coords
    //    will be reals, except in d3drm space...
    //  - if surface has color key, texture will reflect that.

    Real srcWidth, srcHeight;
    Bbox2 box = NullBbox2;

    bool doTexture = true;
    if(!srcDDSurf) {
        Assert(clrs && !image && "bad args to Render3DPolygon");
        doTexture = false;
    } else {
        Assert(!clrs && "bad args to Render3DPolygon");
    }

    if(doTexture) {
        box = srcDDSurf->Bbox();

        Assert(box != NullBbox2);

        srcWidth = box.max.x - box.min.x;
        srcHeight = box.max.y - box.min.y;
    }

    int vCount = destPolygon->GetPointCount();
    if(vCount <=2) return;

    //
    // fill vert array
    //
    D3DRMVERTEX *d3dVertArray = (D3DRMVERTEX *)AllocateFromMyStore(vCount * sizeof(D3DRMVERTEX));
    Point2Value **vertArray = (Point2Value **)AllocateFromMyStore(vCount * sizeof(Point2Value *));
    unsigned *vIndicies = (unsigned *)AllocateFromMyStore(vCount * sizeof(unsigned));

    ZeroMemory(d3dVertArray, vCount * sizeof(D3DRMVERTEX));

    //
    // Get Point array from polygon
    //
    bool bReversed;
    if( destPolygon->GetPointArray(vertArray, true, &bReversed) < 3) {
        return;
    }

    Transform2 *invXf = InverseTransform2(GetTransform());

    if (!invXf) return;

    Point2Value *vert;
    RECT destRect = *(destDDSurf->GetSurfRect());
    Bbox2 destBox = destDDSurf->Bbox();

    if( IsCompositeDirectly() &&
        destDDSurf == _viewport._targetPackage._targetDDSurf ) {

        // compositing directly to target...
        Assert(_viewport._targetPackage._prcViewport);

        destRect = *_viewport._targetPackage._prcViewport;
        RectToBbox( WIDTH(&destRect),
                    HEIGHT(&destRect),
                    destBox,
                    _viewport.GetResolution());

        // Intersect with clip
        if(_viewport._targetPackage._prcClip) {
            IntersectRect(&destRect,
                          &destRect,
                          _viewport._targetPackage._prcClip);
        }

        // intersect with surf rect
        IntersectRect(&destRect,
                      &destRect,
                      destDDSurf->GetSurfRect());


        //
        // The dest bbox needs to be clipped in proportion to the destRect
        //
        RECT *origRect = _viewport._targetPackage._prcViewport;
        Real rDiff;
        if(destRect.left > origRect->left) {
            rDiff = Real(destRect.left -  origRect->left) / GetResolution();
            destBox.min.x += rDiff;
        }
        if(destRect.right <  origRect->right) {
            rDiff = Real(destRect.right -  origRect->right) / GetResolution();
            destBox.max.x += rDiff;
        }
        if(destRect.top >  origRect->top) {
            // positive diff mean the top fell
            rDiff = - Real(destRect.top -  origRect->top) / GetResolution();
            destBox.max.y += rDiff;
        }
        if(destRect.bottom <  origRect->bottom) {
            rDiff = - Real(destRect.bottom -  origRect->bottom) / GetResolution();
            destBox.min.y += rDiff;
        }

        if(doTexture) {
            destPolygon->Crop(destBox);
        }
    }

    //
    // DX3 D3DRM bug workaround...
    // this problem manifests:
    // 1.> for SOME (nvidia3) hardware renders in DX5
    // 2.> software rasterizers in DX3
    //
    // Some rasterizers dont like it when a vertex falls RIGHT on the viewport extent,
    // and ignore the whole triangle.  Actually, it doesn't like vertices that
    // are >= extent.  Set this factor to one pixel spacing.
    // TODO: in the future, perhaps we can turn this on only for the
    // cards that have problems ?
    //
    bool doViewportEdgeWorkaround = false;


    if( !GetD3DRM3() ) {
        // dx5 or earlier is installed.. let's turn the workaround on.
        doViewportEdgeWorkaround = true;
    }

    #if _DEBUG
    if( IsTagEnabled( tagRMGradientWorkaround ) ) {
        doViewportEdgeWorkaround = true;
    }
    #endif


    Bbox2 vpBbox;
    const Real fudge = 1.00 / GetResolution();
    if( doViewportEdgeWorkaround ) {
        // aliasing, in honor of Kevin and Dave
        if(doTexture) {
            vpBbox = _viewport.GetTargetBbox();
        } else {
            vpBbox = destBox;
        }
    }

    // The polygon is in clockwise winding order to start with.  If we're in
    // right-handed mode (RM6+), then we set up the vertex index to reverse
    // the polygon's vertex order, otherwise we preserve the order.

    bool     right_handed = (GetD3DRM3() != 0);
    int      vindex;
    D3DVALUE Nz;        // Normal Vector Z Coordinate

    if (right_handed)
    {   vindex = vCount - 1;
        Nz = 1;
    }
    else
    {   vindex = 0;
        Nz = -1;
    }

    int i;

    for(i=0; i < vCount; i++) {

        if (right_handed)
            vIndicies[i] = vindex--;
        else
            vIndicies[i] = vindex++;

        if( doViewportEdgeWorkaround )
        {
            float xl, xr;

            Assert(vpBbox != NullBbox2);

            xl = D3DVALUE(vpBbox.min.x);
            xr = D3DVALUE(vpBbox.max.x);

            // @BUG, VC5 ddalal.  seems like a vc5 bug here, our old favorite.
            // needed to explicitly create vx & vy else, the compare
            // doesn't work.

            float vx, vy;
            vx = D3DVALUE(vertArray[i]->x);
            vy = D3DVALUE(vertArray[i]->y);

            if( vx >= xr) {
                vertArray[i]->x = xr - fudge;
            }
            if( vx <= xl ) {
                vertArray[i]->x = xl + fudge;
            }

            xl = D3DVALUE(vpBbox.min.y);
            xr = D3DVALUE(vpBbox.max.y);

            if( vy >= xr) {
                vertArray[i]->y = xr - fudge;
            }
            if( vy <= xl) {
                vertArray[i]->y = xl + fudge;
            }
        } // viewport edge workaround


        // Coord in dest surface
        d3dVertArray[i].position.x = D3DVALUE(vertArray[i]->x);
        d3dVertArray[i].position.y = D3DVALUE(vertArray[i]->y);
        d3dVertArray[i].position.z = D3DVALUE(0);

        if (doTexture) {
            //
            // Texture coords. divide to normalize into range: [0,1]
            //
            vert = TransformPoint2Value(invXf, vertArray[i]);
            d3dVertArray[i].tu = D3DVALUE(0.5 + vert->x / srcWidth);
            d3dVertArray[i].tv = D3DVALUE(0.5 - vert->y / srcHeight);

            //
            // Now scale the coords away from 0 and 1 because these
            // u,v coords aren't well defined (at least in d3d
            // software rasterizers).
            //

            Real takeOff = 0.5;  // move the u,v coords in by half a pixel
            Real texelU = takeOff / Real(DEFAULT_TEXTURE_WIDTH);
            Real texelV = takeOff / Real(DEFAULT_TEXTURE_HEIGHT);
            Real spanU = 1.0 - (2.0 * texelU);
            Real spanV = 1.0 - (2.0 * texelV);

            //
            // we scale them to range in (0+e, 1-e)  where 'e' is
            // 'takeOff' (half a pixel right now) on the texture.
            // So if you think of U as a percentage (0 to 1) then
            // we want U to be a half pixel plus a percentage of the
            // new span, which is now the whole u range minus one
            // whole pixel (whatever that is in u,v space)
            //
            d3dVertArray[i].tu = texelU + ( d3dVertArray[i].tu * spanU );
            d3dVertArray[i].tv = texelV + ( d3dVertArray[i].tv * spanV );

        } else {
            d3dVertArray[i].tu = D3DVALUE(0);
            d3dVertArray[i].tv = D3DVALUE(0);
        }

        d3dVertArray[i].normal.x = D3DVALUE(0);
        d3dVertArray[i].normal.y = D3DVALUE(0);
        d3dVertArray[i].normal.z = Nz;

        if(doTexture) {
            //
            // D3DRM BUG: If the vertex color is anything but white
            // guess what, you get black.  Steve feel free to add this
            // to your list of "1001 ways to get black."
            //
            d3dVertArray[i].color = 0xffffffff;
        } else {
            // The reverse of the vertices is done like:
            // [v0 v1 v2 ... vn-1 vn]  reverse-> [v0 vn vn-1 ... v2 v1]
            //
            int clridx;

            if (bReversed) {
                clridx = i?(vCount - i):0;
            } else {
                clridx = i;
            }

            // Only use the first color if this flag is set
            if(bUseFirstColor) clridx = 0;

            d3dVertArray[i].color = GetD3DColor(clrs[clridx], 1.0);
        }
    } // for

    HeapReseter heapReseter(*_scratchHeap);

    //
    // Get geometry device from destDDsurf
    //
    // OPTIMIZE: this destDDSurf doesn't really need a zbuffer
    // attached to it because it's not going to use it.
    // we could potentially attach zbuffers realllly lazily when
    // someone knows the surface will be used for real geometry
    // and if we can attach a zbuffer AFTER the device has been
    // created off of a surface...

    GeomRenderer *gdev = _viewport.GetGeomDevice(destDDSurf);

    if (!gdev) return;

    // Ok hack for geom device not able to get itself back in a good
    // state after throwing an exception because surfacebusy or lost
    if ( ! gdev->ReadyToRender() ) {
        destDDSurf->DestroyGeomDevice();
        return;
    }
#ifndef BUILD_USING_CRRM
    //
    // Create a mesh
    //
    DAComPtr<IDirect3DRMMesh> mesh;

    TD3D (GetD3DRM1()->CreateMesh(&mesh));

    //
    // convert to triangles, ready for D3DRM
    //
    long groupId;

    TD3D (mesh->AddGroup(vCount,    // vertex count
                         1,         // face count
                         vCount,    // verts per face
                         vIndicies, // indicies
                         &groupId));

    TD3D (mesh->SetVertices(groupId, 0, vCount, d3dVertArray));

    if(doTexture) {
        //
        // Set Quality to be unlit flat.  this should provide a speedup
        // but it doesn't because D3DRM still MUST look at the vertex color.
        // I think this is a bug.
        //
        TD3D (mesh->SetGroupQuality(groupId, D3DRMRENDER_UNLITFLAT));
    } else {
        TD3D (mesh->SetGroupQuality
                 (groupId, D3DRMSHADE_GOURAUD|D3DRMLIGHT_OFF|D3DRMFILL_SOLID));
    }
#endif
    void *texture = NULL;
    if(doTexture) {
        //
        // Derive the texture handle (after the first time: look it up,
        // it's cached).  Note that we apply this with the 'vrml texture'
        // flag set to true, since that prevents the
        // AxA-texturing-specific transformations from occuring.

        if(image) {
            texture = gdev->DeriveTextureHandle(image, true, false, this);
        } else {
            // TODO: associate color key with DDSurface
            // TODO: this will work for now, but only because
            // TODO: discrete image is special cased above
            Assert( srcDDSurf->IsTextureSurf() && "srcDDSurf not texture in RenderComplexTranformCrop");
            #if 1
            DWORD clrKey = _viewport._defaultColorKey;
            bool  clrKeyValid = true;
            texture = gdev->LookupTextureHandle
                          (srcDDSurf->IDDSurface(), clrKey, clrKeyValid, true);
            #else
            DWORD clrKey = 0;
            bool  clrKeyValid = srcDDSurf->ColorKeyIsValid();
            if( srcDDSurf->ColorKeyIsValid() ) {
                clrKey = srcDDSurf->ColorKey();
            } else if( ColorKeyIsSet() ) {
                clrKey = GetColorKey();
            } else {
                clrKey = _viewport._defaultColorKey;
            }
            texture = gdev->LookupTextureHandle(srcDDSurf->IDDSurface(), clrKey, clrKeyValid);
            #endif
        }
    }

    //
    // Set interesting rect on dest surface
    //
    Bbox2 polyBox = destPolygon->BoundingBox();
    RECT interestingRect;
    DoDestRectScale(&interestingRect, GetResolution(), polyBox, NULL);

    DoCompositeOffset(destDDSurf, &interestingRect);
    destDDSurf->SetInterestingSurfRect(&interestingRect);

    //
    // render
    //

    // For now always turn on dithering

    bool bDither = true; // !doTexture;
#ifndef BUILD_USING_CRRM
    gdev->RenderTexMesh (texture, mesh, groupId, destBox, &destRect, bDither);
#else
    gdev->RenderTexMesh (texture, vCount, d3dVertArray, vIndicies, doTexture,
                         destBox, &destRect, bDither);
#endif
    //DrawRect(destDDSurf, &destRect, 0,255,0, 0,0,0);
    //DrawRect(destDDSurf, destDDSurf->Bbox(), _viewport.Width(), _viewport.Height(), GetResolution(), 255,255,0);

    // mesh: implicit release
}

// restore optimizations to defualt
#pragma optimize("", on)


void DirectDrawImageDevice::
DoBoundingPolygon(BoundingPolygon &polygon,
                  bool doInclusiveCrop,
                  DoBboxFlags_t flags)
{
    list<Image*>::reverse_iterator _iter;

    for(_iter = _imageQueue.rbegin();
        _iter != _imageQueue.rend(); _iter++)
    {
        if( flags == do_crop || flags == do_all ) {
            Bbox2 box;
            if ((*_iter)->CheckImageTypeId(CROPPEDIMAGE_VTYPEID)) {
                box = SAFE_CAST(CroppedImage*,(*_iter))->GetBox();
                if( doInclusiveCrop ) {
                    box.max.x += 1.0/GetResolution();
                    box.min.y -= 1.0/GetResolution();
                }
                polygon.Crop( box );
                continue;
            }
        }

        if( flags == do_xform || flags == do_all ) {
            if ((*_iter)->CheckImageTypeId(TRANSFORM2IMAGE_VTYPEID)) {
                polygon.Transform(SAFE_CAST(Transform2Image*,(*_iter))->GetTransform());
                continue;
            }
        }
    }
}


// PRE CONDITION: the corresponding state has been accumulated in the device (such as opacity, xforms, etc..)
// POST CONDITION: The attributor in question has been dealt with.

void DirectDrawImageDevice::
SmartRender(Image *image, int attrib)
{
    if( !image->IsRenderable() ) {
        ResetAttributors();
        return;
    }

    if(attrib == ATTRIB_OPAC) {
        if( IsFullyOpaque() ) {

            //
            // make sure to set this first!
            //
            SetDealtWithAttrib(ATTRIB_OPAC, true);

            //
            // opacity doesn't matter, just tell the
            // image to render and return
            //
            image->Render(*this);
            return;
        } else if( ! IsFullyClear()) {
            //
            // There is some transparency worth thinking
            // about, so continue with regular SmartRender
            //
        } else {
            //
            // This image is fully transparent, don't render
            // don't crop, don't transform, nothing...
            //
            SetDealtWithAttrib(ATTRIB_OPAC, true);
            // fortunately we're guaranteed that
            // opac will hit first since it's floated
            // but just so we don't have this subtle
            // dependency... we'll reset all attribs
            ResetAttributors();
            return;
        }
    }

    //
    // Set the attributor to false and...
    //
    SetDealtWithAttrib(attrib, false);

    //
    // Do some attrib munging for simple and complex xforms
    // so that if simple AND complex exist ANYWHERE in the attrib
    // stack then turn off the simple attrib, and keep the complex
    // one on (false).  In addition, we set attrib
    //
    if( (GetDealtWithAttrib(ATTRIB_XFORM_SIMPLE) == false) &&
        (GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX) == false) ) {
        SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, true);
    }

    //
    // Now, if this attrib is simple and complex has been set,
    // then the attrib is the COMPLEX
    //
    if(attrib==ATTRIB_XFORM_SIMPLE && (GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX)==false) ) {
        attrib = ATTRIB_XFORM_COMPLEX;
    }

    //
    // ...render the image, then..
    //
    image->Render(*this);

    //
    // ...if the image understands how to do the attribution
    // then it changes the state set in the device.
    //

    DDSurface *srcDDSurf, *destDDSurf;
    bool returnTextures = false;

    bool clearScratchDDSurf = false;
    DDSurface *scratchDDSurfToClear = NULL;

    if( ! GetDealtWithAttrib( attrib ) ) {

        //
        // The image couldn't deal, so it left it's best shot
        // in the current scratch surface.
        //

        // Now, if it's there's a complex transform anywhere in the
        // stack, the current scratch
        // is a special texture surface, so we need to check for that.
        if( !GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX) ) {
            srcDDSurf = _currentScratchDDTexture;
            returnTextures = true;
            #if _DEBUG
            _currentScratchDDTexture = NULL;
            #endif
        } else {
            srcDDSurf = GetCompositingStack()->ScratchDDSurface();
            clearScratchDDSurf = true;
            scratchDDSurfToClear = srcDDSurf;
        }

        Assert(srcDDSurf && "srcDDSurf NULL in SmartRender");

        // TODO: This should never happen but there seems to be
        // another bug when we are out of memory that causes this to
        // be NULL.  Let's just be safe and check so we do not crash
        // on low memory

        if (!srcDDSurf)
        {
            RaiseException_OutOfMemory("could not allocate ddsurf",
                                       sizeof (srcDDSurf));
        }

        //
        // Set the state on this attributor to true
        //
        SetDealtWithAttrib(attrib, true);

        DDSurface *newScratch = NULL;

        if( AllAttributorsTrue() ||
           // or, only crop and some xf remain
           ((attrib==ATTRIB_XFORM_COMPLEX || attrib==ATTRIB_XFORM_SIMPLE) && !GetDealtWithAttrib(ATTRIB_CROP)) ||
           ((attrib==ATTRIB_CROP) && (!GetDealtWithAttrib(ATTRIB_XFORM_SIMPLE) || !GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX)))
           )
        {

            //
            // This was the last attributor, compose to the target surf
            //
            destDDSurf = GetCompositingStack()->TargetDDSurface();

            TraceTag((tagImageDeviceAlgebra,
                      "AllAttributorsTrue == true. src(Scratch):%x  dest(target):%x",
                      srcDDSurf->IDDSurface(),
                      destDDSurf->IDDSurface()));


        } else {
            //
            // There are more attribs to be dealt with,
            // do a scratch to scratch compose
            //

            //
            // XXX NOTE: if this is a complex xform, then the dest
            // surface will lazily have a goemRenderer created
            // on it.  in the future, we might want to manage
            // and/or characterize this more inteligently..
            //

            GetCompositingStack()->GetSurfaceFromFreePool(&newScratch, doClear);

            //
            // Clear the newScratch's interesting rect.  so far,
            // there's really nothing interesting on it!
            //
            RECT r={0,0,0,0};
            newScratch->SetInterestingSurfRect(&r);

            destDDSurf = newScratch;

            TraceTag((tagImageDeviceAlgebra,
                      "AllAttributorsTrue == false. src(scratch):%x  dest(newscratch):%x",
                      srcDDSurf->IDDSurface(),
                      destDDSurf->IDDSurface()));
        }

        //printf("-- SmartRender:  src %x   dest %x\n",srcDDSurf, destDDSurf);

        //
        // This is the meat of smart render.
        // --If the transform is simple, then render it, and only consider
        //   the transforms accumulated; not the crops.  This might be wrong.
        // --COMPLEX: render it.  same as above
        // --CROP: we should either use the current crop or the accum crops... but
        //         we can't use the accum crops because they might be interleaved with xfs.
        //         so when we crop we should also take care of transforms.
        //  The rule for xfs and crops then becomes: the lowest crop of transform takes care of all crops & xfs
        //  What if the leaf can do crop, but not xf ?  Then we're hosed
        //  What if the leaf can do xf, but not crop ?  The final crop can be applied given that the leaf has be xfed.
        // --OPAC: This is guaranteed to be taken care of at the top of the tree and under each branch.
        //
        // Ok, what about clip ?  No leafs know about, or can handle clip since it uses generalized regions,
        // renders the image to a surface and then clips it to the targetsurface.  clip can't handle opacity above or below
        // or complex xfs.
        //
        // SO: The final rule is:  if you can do crop or xf, you'd
        // better be able to do the other.  This isn't good...
        //
        switch(attrib) {

          case ATTRIB_XFORM_SIMPLE:

            Assert((GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX) == TRUE) && "attrib_complex shouldn't be set for simple");
            TraceTag((tagImageDeviceAlgebra, "About to SimpleTransformBlit src:%x to dest:%x", srcDDSurf, destDDSurf));

            RenderSimpleTransformCrop(srcDDSurf, destDDSurf);

            // we took care of crop as well.
            SetDealtWithAttrib(ATTRIB_CROP, true);
            break;

          case ATTRIB_XFORM_COMPLEX:

            Assert((GetDealtWithAttrib(ATTRIB_XFORM_SIMPLE) == TRUE) && "attrib_simple shouldn't be set for complex");
            Assert( srcDDSurf->IsTextureSurf() &&  "Rendering for complex xf, srcSurf not a texture surf");

            // Invarient:  source surface has been blit to by image
            // Invarient:  source surface is a texture surface (power of two size, etc...)
            // Invarient:  dest surface has or will have a device instantiated from it

            //
            // Prepare bounding polygon, since we don't know where the interesting image
            // lies on the src surface, we use the bounding box of the src surface
            // and transform it, relying on the color key on the surface to give the right result
            //

            //
            // NOTE: we can also do cropping easily here, as long as crop can also do xfs.
            //
            {
                BoundingPolygon *polygon = NewBoundingPolygon(srcDDSurf->Bbox());
                DoBoundingPolygon(*polygon);
                // xxx: is this necessary if d3d clips polygons
                // that lie off the viewport ?
                polygon->Crop( destDDSurf->Bbox() );

                RenderComplexTransformCrop(srcDDSurf, destDDSurf, *polygon);

                // we took care of crop as well.
                SetDealtWithAttrib(ATTRIB_CROP, true);
            }

            break;

          case ATTRIB_CROP:

            // do a cropping blit to destSurf
            if( !GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX) ) {
                //
                // take this opportunity to do the complex xf as well as crop
                //
                BoundingPolygon *polygon = NewBoundingPolygon(srcDDSurf->Bbox());
                DoBoundingPolygon(*polygon);
                // xxx: is this necessary if d3d clips polygons
                // that lie off the viewport ?
                polygon->Crop( destDDSurf->Bbox() );

                RenderComplexTransformCrop(srcDDSurf, destDDSurf, *polygon);

                // we took care of any complex xf as well.
                SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, true);

            } else {
                //
                // There might be a simple xf on here, if so we'll take care
                // of it.
                //
                RenderSimpleTransformCrop(srcDDSurf, destDDSurf);

                // we took care of any simple xf as well.
                SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, true);
            }
            break;

          case ATTRIB_OPAC:

            // Using current opacity, do a clrkeyed alpha blit
            // to the destination surface

            // optimization:  rather than always doing a color keyed
            // blit, we could do a non color keyed one if the image in
            // srcDDSurf doesn't actually need it.
            {
                RECT destClipRect = *(destDDSurf->GetSurfRect());
                RECT destRect = *(srcDDSurf->GetInterestingSurfRect());
                RECT srcRect =  *(srcDDSurf->GetInterestingSurfRect());

                if( destDDSurf == _viewport._externalTargetDDSurface) {
                    DoCompositeOffset(destDDSurf, &destRect);

                    DoCompositeOffset(destDDSurf, &destClipRect);
                    IntersectRect(&destClipRect, &destClipRect,
                                  _viewport._targetPackage._prcViewport);
                    IntersectRect(&destClipRect, &destClipRect,
                                  _viewport._targetPackage._targetDDSurf->GetSurfRect());
                    if (_viewport._targetPackage._prcClip) {
                        IntersectRect(&destClipRect, &destClipRect,
                                      _viewport._targetPackage._prcClip);
                    }
                }
                destPkg_t destPkg = {true, destDDSurf->IDDSurface(), NULL};

                if(srcDDSurf->ColorKeyIsValid()) {
                    //printf("Alpha Blit (cc %f): from: %x,  to:%x\n",GetOpacity(),
                    //srcDDSurf, destDDSurf);
                    TIME_ALPHA(AlphaBlit(&destPkg,
                                         &srcRect,
                                         srcDDSurf->IDDSurface(),
                                         GetOpacity(),
                                         true,
                                         srcDDSurf->ColorKey(),
                                         &destClipRect,
                                         &destRect));
                } else {
                    //printf("Alpha Blit (%f): from: %x,  to:%x\n", GetOpacity(),
                    //srcDDSurf, destDDSurf);
                    TIME_ALPHA(AlphaBlit(&destPkg,
                                         &srcRect,
                                         srcDDSurf->IDDSurface(),
                                         GetOpacity(),
                                         false, 0,
                                         &destClipRect,
                                         &destRect));
                }
            }
            break;

          default:
            break;
        }


        if(newScratch) {
            //
            // Set the temp surface as the NEW scratch
            // and return old scratch to pool
            //
            GetCompositingStack()->ReplaceAndReturnScratchSurface( newScratch );
            RELEASE_DDSURF(newScratch, "SmartRender", this);
        } else if ( clearScratchDDSurf ) {
            Assert( GetCompositingStack()->ScratchDDSurface() == scratchDDSurfToClear);
            _viewport.ClearDDSurfaceDefaultAndSetColorKey(scratchDDSurfToClear );
        }

        // If we used a texture surface as the src surface, return it
        if(returnTextures) {
            ReturnTextureSurfaces(_freeTextureSurfacePool,
                                  _usedTextureSurfacePool);
        }

    } // if not dealt with attrib
}


static void
Clamp(LONG *min, LONG *max, LONG minClamp, LONG maxClamp)
{
    if(*min < minClamp) {
        // adjust down (add to max)
        if(*max < maxClamp) *max += -(*min);
        *min = 0;
    } else if(*max > maxClamp) {
        // adjust UP (subtract from min)
        if(*min > minClamp) *min = *min - (*max - maxClamp);
        *max = maxClamp;
    }
}

void DirectDrawImageDevice::
RenderSimpleTransformCrop(DDSurface *srcDDSurf,
                          DDSurface *destDDSurf,
                          bool useSrcSurfClrKey)
{
    DWORD flags=0;
    ZeroMemory(&_bltFx, sizeof(_bltFx));
    _bltFx.dwSize = sizeof(_bltFx);

    //----------------------------------------
    // Calculate accumulated bounding box
    //----------------------------------------
    _boundingBox = DoBoundingBox(srcDDSurf->Bbox());

    if( !_boundingBox.IsValid() ) return;

    //----------------------------------------
    // Source Rectangle (in src surface space, conventional coords)
    // Calculate src rect in src surface coordinates, derived from
    // _boundingBox and accumulated transforms
    //----------------------------------------
    LONG srcWidth =        srcDDSurf->Width();
    LONG srcHeight =        srcDDSurf->Height();

    RECT srcRect;
    Bool valid = DoSrcRect(&srcRect, _boundingBox,
                           srcDDSurf->Resolution(),
                           srcDDSurf->Width(),
                           srcDDSurf->Height());

    if(!valid) return;

    //----------------------------------------
    // Destination Rectangle
    // Calculate dest rect in IntermediateSurface
    // coordinate space from accumulated bbox
    //----------------------------------------
    RECT  destRect;
    Real destRes = destDDSurf->Resolution();
    //SmartDestRect(&destRect, destRes, _boundingBox, destDDSurf, &srcRect);
    SmartDestRect(&destRect, destRes, _boundingBox, NULL, &srcRect);

    #if 0
    //----------------------------------------
    // Check to see if widths are off by one
    //----------------------------------------
    LONG destWidth  = destRect.right - destRect.left;
    LONG destHeight = destRect.bottom - destRect.top;
    #endif

    #if 0
    LONG finalSrcWidth  = srcRect.right - srcRect.left;
    LONG finalSrcHeight = srcRect.bottom - srcRect.top;

    if(labs(destWidth - finalSrcWidth) == 1) {
        TraceTag((tagImageDeviceInformative, "src//dest widths differ by 1"));
        // they differ by one.
        if(destWidth > srcWidth) destRect.right--;
        else destRect.right++;
        Assert(((srcRect.right - srcRect.left) == (destRect.right - destRect.left)) &&
                  "Even after fixing, srcRect & destRect not same WIDTH in renderDib");
        Clamp(&srcRect.left, &srcRect.right, 0, finalSrcWidth );
    }

    if(labs(destHeight - finalSrcHeight) == 1) {
        TraceTag((tagImageDeviceInformative, "src//dest height differ by 1"));
        // they differ by one.
        if(destHeight > srcHeight) destRect.top++;
        else destRect.top--;
        Assert(((srcRect.bottom - srcRect.top) == (destRect.bottom - destRect.top)) &&
                  "Even after fixing, srcRect & destRect not same HEIGHT in renderDib");
        Clamp(&srcRect.top, &srcRect.bottom, 0, finalSrcHeight);
    }
    #endif

    #if 0
    LONG mySrcWidth  = srcRect.right - srcRect.left;
    LONG mySrcHeight = srcRect.bottom - srcRect.top;
    printf("srcWidth = %d,  destWidth = %d.  ratio = %2.4f\n", mySrcWidth, destWidth, Real(mySrcWidth) / Real(destWidth));
    printf("srcHeight = %d,  destHeight = %d.  ratio = %2.4f\n", mySrcHeight, destHeight, Real(mySrcHeight) / Real(destHeight));
    /******** This is the relevent metric ...
    printf("left diff = %d\n", srcRect.left-destRect.left);
    printf("top diff = %d\n", srcRect.top-destRect.top);
    *****/
    /*
    printf("srcWidth = %d,  destWidth = %d.  ratio = %2.4f\n", srcWidth, destWidth, Real(srcWidth) / Real(destWidth));
    printf("srcLeft  = %d,  destLeft  = %d\n", srcRect.left, destRect.left);
    printf("srcRight  = %d,  destRight  = %d\n", srcRect.right, destRect.right);
    */
    #endif


    Vector2 a = TransformVector2(GetTransform(), XVector2);
    Vector2 b = TransformVector2(GetTransform(), YVector2);

    Real xScale = a.x;
    Real yScale = b.y;

    if(xScale < 0) {
        flags |= DDBLT_DDFX;
        _bltFx.dwDDFX |= DDBLTFX_MIRRORLEFTRIGHT;
    }

    if(yScale < 0) {
        flags |= DDBLT_DDFX;
        _bltFx.dwDDFX |= DDBLTFX_MIRRORUPDOWN;
    }

    //--------------------------------------------------
    // Scale
    //--------------------------------------------------

    // WAIT TILL DDRAW FIXES THIS BUG: flip BEFORE clip
    #if 1
    if(_bltFx.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT) {


        // DD clipps before it mirrors, so... we need to clip
        // the part of the src surface that is off of the dest
        // surface.

        if(destRect.right > _viewport.Width()) {

            // off the right.
            //              _width
            //                 |
            // a----d----------b----c
            // |                    |
            // |                    |
            // |                    |
            // |                    |
            // a----d----------b----c
            // The section dc is what we need to display
            // in the same place as section ab.
            // So destination is ab while src is dc.

            int diff = destRect.right - _viewport.Width();
            destRect.right -= diff;  // manual clipping!
            srcRect.left += diff;   // cut off left side
        }

        if(destRect.left < 0) {

            int diff = - destRect.left;
            destRect.left = 0;  // manual clipping!
            srcRect.right -= diff;   // cut off right side
        }
    }

    if(_bltFx.dwDDFX & DDBLTFX_MIRRORUPDOWN) {

        if(destRect.bottom > _viewport.Height()) {

            int diff = destRect.bottom - _viewport.Height();
            destRect.bottom = _viewport.Height();  // manual clipping!
            srcRect.top += diff;   // cut off top side
        }

        if(destRect.top < 0) {

            int diff = - destRect.top;
            destRect.top = 0;  // manual clipping!
            srcRect.bottom -= diff;   // cut off bottom side
        }
    }
    #endif

    //
    // check src & dest rect for validity after flip munging & such
    //
    if((destRect.top >= destRect.bottom) || (destRect.left >= destRect.right))
        return;

    if((srcRect.top >= srcRect.bottom) || (srcRect.left >= srcRect.right))
        return;

    // OPTIMIZE: can do alpha here!  see history before apr 24 97.  -ddalal

    if( useSrcSurfClrKey ) {
        flags |= DDBLT_KEYSRCOVERRIDE;
        _bltFx.ddckSrcColorkey.dwColorSpaceLowValue =
            _bltFx.ddckSrcColorkey.dwColorSpaceHighValue = srcDDSurf->ColorKey();
    }

    // to ddraw
    flags |= DDBLT_WAIT;

    bool doQualityScale = true;

    //
    // If we're scaling UP and the dest rect will be clipped, do higher
    // quality blit.  Use GDI.  If there's no color key, blit and copy
    // back.
    //
    RECT postClip;
    bool doDdrawBlit = true;
    DDSurface *tempDDSurf = NULL;

    CompositingSurfaceReturner goBack(
        GetCompositingStack(),
        tempDDSurf,
        true);
    
    // Turn off gdi scale if we're neg scaling
    if( (xScale < 0) || (yScale < 0)) {
        doDdrawBlit = true;
        doQualityScale = false;
    }

    //
    // if this is an idxsurface, here's the only place we support it
    // (so far).  Check for it, if so turn off highquality scale, and
    // call the DDSurface blitter which will delegate to the DXTrans
    // blitter instead of the ddraw blitter
    //
    if( srcDDSurf->HasIDXSurface() ) {
        doQualityScale = false;
        doDdrawBlit = true;
    }

    #if _DEBUG
    if(IsTagEnabled(tagImageDeviceQualityScaleOff)) {
        doQualityScale = false;
        doDdrawBlit = true;
    } else {
        // leave it alone
    }
    #endif


    if( doQualityScale ) {
        if( (WIDTH(&destRect) > WIDTH(&srcRect)) ||
            (HEIGHT(&destRect) > HEIGHT(&srcRect)) ) {

            IntersectRect(&postClip, &destRect, &_viewport._clientRect);

            if(IsCropped()) {

                //
                // consider the destRect as a cliprect and
                // find the scale factor regardless of the crops
                //
                Bbox2 box = DoBoundingBox(srcDDSurf->Bbox(), do_xform);
                RECT newDestRect;
                RECT newSrcRect;
                RECT clipRect = destRect;

                DoSrcRect(&newSrcRect, box,
                          srcDDSurf->Resolution(),
                          srcDDSurf->Width(),
                          srcDDSurf->Height());
                SmartDestRect(&newDestRect, destRes, box, NULL, &newSrcRect);

                if(srcDDSurf->ColorKeyIsValid() || useSrcSurfClrKey ) {
                    // must do gdi scaled composite to a temp surface
                    // then do a color keyed blit (below)

                    GetCompositingStack()->GetSurfaceFromFreePool(&tempDDSurf, doClear);
                    goBack._ddSurf = tempDDSurf;  // Critical in order
                                                  // to return the surface
                    
                    TraceTag((tagImageDeviceSimpleBltTrace, "GDI (tmp) BLT1: srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                              srcRect.left, srcRect.top, srcRect.right, srcRect.bottom,
                              destRect.left, destRect.top, destRect.right, destRect.bottom));

                    GdiBlit(tempDDSurf, srcDDSurf, &newDestRect, &newSrcRect, NULL, &clipRect);

                    // now the dest and src rects are the post clip rectangle
                    srcRect = destRect = postClip;

                    // now the src surf is the temp surf.
                    srcDDSurf = tempDDSurf;
                } else {
                    // COMPOSITE
                    DoCompositeOffset(destDDSurf, &clipRect);
                    DoCompositeOffset(destDDSurf, &newDestRect);

                    HRGN clipRgn = NULL;
                    clipRgn = destDDSurf->GetClipRgn();

                    TraceTag((tagImageDeviceSimpleBltTrace, "GDI BLT1: srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                              srcRect.left, srcRect.top, srcRect.right, srcRect.bottom,
                              destRect.left, destRect.top, destRect.right, destRect.bottom));

                    GdiBlit(destDDSurf, srcDDSurf, &newDestRect, &newSrcRect, clipRgn, &clipRect);

                    doDdrawBlit = false;
                }

            } else {  // is cropped

                if(srcDDSurf->ColorKeyIsValid() || useSrcSurfClrKey) {
                    // must do gdi scaled composite to a temp surface
                    // then do a color keyed blit (below)

                    GetCompositingStack()->GetSurfaceFromFreePool(&tempDDSurf, doClear);
                    goBack._ddSurf = tempDDSurf;  // Critical in order
                                                  // to return the surface

                    TraceTag((tagImageDeviceSimpleBltTrace, "GDI (tmp) BLT2: srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                              srcRect.left, srcRect.top, srcRect.right, srcRect.bottom,
                              destRect.left, destRect.top, destRect.right, destRect.bottom));

                    GdiBlit(tempDDSurf, srcDDSurf, &destRect, &srcRect, NULL, NULL);

                    // now the dest and src rects are the post clip rectangle
                    srcRect = destRect = postClip;

                    // now the src surf is the temp surf.
                    srcDDSurf = tempDDSurf;
                } else {
                    // COMPOSITE
                    DoCompositeOffset(destDDSurf, &destRect);

                    HRGN clipRgn = NULL;
                    clipRgn = destDDSurf->GetClipRgn();

                    TraceTag((tagImageDeviceSimpleBltTrace, "GDI BLT2: srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                              srcRect.left, srcRect.top, srcRect.right, srcRect.bottom,
                              destRect.left, destRect.top, destRect.right, destRect.bottom));

                    GdiBlit(destDDSurf, srcDDSurf, &destRect, &srcRect, clipRgn, NULL);

                    doDdrawBlit = false;
                }
            } // else is cropped

        } // if width/height scale

    } // if doQuality

    if( doDdrawBlit ) {

        // COMPOSITE
        DoCompositeOffset(destDDSurf, &destRect);

        //
        // BLIT
        //

        if( srcDDSurf->HasIDXSurface() ) {


            DAGDI &myGDI = *GetDaGdi();

            RectRegion clipRegion( &destRect );
            if( IsCompositeDirectly() &&
                destDDSurf == _viewport._targetPackage._targetDDSurf ) {

                clipRegion.Intersect(_viewport._targetPackage._prcViewport);
                if( _viewport._targetPackage._prcClip ) {
                    clipRegion.Intersect(_viewport._targetPackage._prcClip);
                }
            }

            myGDI.SetClipRegion( &clipRegion );


            myGDI.SetAntialiasing( true );
            Assert( myGDI.DoAntiAliasing() );

            myGDI.SetDDSurface( destDDSurf );

            TraceTag((tagImageDeviceSimpleBltTrace, "IXDSURFACE BLT: srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                          srcRect.left, srcRect.top, srcRect.right, srcRect.bottom,
                          destRect.left, destRect.top, destRect.right, destRect.bottom));

            _ddrval = myGDI.Blt( srcDDSurf, srcRect, destRect );
            myGDI.ClearState();
        } else {

            TraceTag((tagImageDeviceSimpleBltTrace, "DDRAW BLT: srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                          srcRect.left, srcRect.top, srcRect.right, srcRect.bottom,
                          destRect.left, destRect.top, destRect.right, destRect.bottom));

            if( destDDSurf->GetBitDepth() == 8 && srcDDSurf->GetBitDepth() != 8) {
                 GdiBlit(destDDSurf, srcDDSurf, &destRect, &srcRect, NULL, NULL);
                _ddrval = DD_OK;
            }
            else {
                TIME_DDRAW(_ddrval = destDDSurf->Blt(&destRect,
                                                 srcDDSurf, &srcRect,
                                                 flags, &_bltFx));
            }


            // TEMP TEMP
            //showme( destDDSurf );
        }


        if(_ddrval == DD_OK) {
        } else {
            if(_ddrval == DDERR_SURFACELOST)
                destDDSurf->IDDSurface()->Restore();
            else {
                printDDError(_ddrval);
                TraceTag((tagError, "blt failed renderSimpleXform: srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                          srcRect.left, srcRect.top, srcRect.right, srcRect.bottom,
                          destRect.left, destRect.top, destRect.right, destRect.bottom));
                    return;
            }
        }
    }

    // tempDDSurf is returned by goBack

    #if 0
    //
    // print rect ratio
    //
    {
        Real wr = Real(WIDTH(&destRect)) / Real(WIDTH(&srcRect));
        Real hr = Real(HEIGHT(&destRect)) / Real(HEIGHT(&srcRect));

        TraceTag((tagError, "Ratios: w: %f   h: %f", wr, hr));
    }
    #endif

    //
    // set the interesting rectangle on the destination surface
    //
    destDDSurf->SetInterestingSurfRect(&destRect);
}

extern COLORREF g_preference_defaultColorKey;



void DirectDrawImageDevice::
RenderDirectDrawSurfaceImage(DirectDrawSurfaceImage *img)
{
    RenderDiscreteImage(img);
}

//
// This funciton DOES NO SCALING, AND NO AFFINE IMAGE
// TRANSFORMS!!  (only translation).  It asserts that
// the rects are equal sized
//
void DirectDrawImageDevice::
ComposeToIDDSurf(DDSurface *destDDSurf,
                 DDSurface *srcDDSurf,
                 RECT destRect,
                 RECT srcRect,
                 RECT destClipRect)
{
    Assert( WIDTH(&destRect) == WIDTH(&srcRect) );
    Assert( HEIGHT(&destRect) == HEIGHT(&srcRect) );

    // destRect in is destDDSurf coords.
    // destClipRect is in destDDSurf coords.
    // srcRect is in srcDDSurf coords
    
    Real opToUse = GetOpacity();

    if( IsTransparent( opToUse ) ) {
        destPkg_t destPkg;
        destPkg.isSurface = true;
        destPkg.lpSurface = destDDSurf->IDDSurface();

        AlphaBlit(&destPkg,
                  &srcRect,
                  srcDDSurf->IDDSurface(),
                  opToUse,
                  true, // do color key
                  _viewport._defaultColorKey,
                  &destClipRect,
                  &destRect);
    } else if( IsFullyOpaque( opToUse ) ) {

        RECT Clippeddest;
        if (!IntersectRect(&Clippeddest, &destRect, &destClipRect)) {
            return;
        }
        if (WIDTH(&srcRect) != WIDTH(&Clippeddest)) {
            srcRect.left += (Clippeddest.left - destRect.left);
            srcRect.right = srcRect.left + WIDTH(&Clippeddest);
        }
        if (HEIGHT(&srcRect) != HEIGHT(&Clippeddest)) {
            srcRect.top += (Clippeddest.top - destRect.top);
            srcRect.bottom = srcRect.top + HEIGHT(&Clippeddest);
        }
        destRect = Clippeddest;

        _viewport.ColorKeyedCompose(
            destDDSurf, &destRect,
            srcDDSurf, &srcRect,
            _viewport._defaultColorKey);
    }
}


//
// Blits from the dcs of the surfaces using stretchblit
//
// this guy should be in ddutil.cpp... argh compiler
// complains... circular dep etc.. so, keep it here!
//
void GdiBlit(GenericSurface *destSurf,
             GenericSurface *srcSurf,
             RECT *destRect,
             RECT *srcRect,
             HRGN clipRgn,
             RECT *clipRect)
{
    RECT newSrcRect = *srcRect;
    RECT newDestRect = *destRect;
    RECT replaceDestRect;

    // check to see if target rect is just too darn huge
    long destWidth = WIDTH(&newDestRect);
    long destHeight = HEIGHT(&newDestRect);

    if ((destWidth >= 8192) || (destHeight >= 8192)) {

        // a destRect this large may cause GDI to fail, so we hack it down
        // and scale the srcRect down to match

        if (clipRect) {
            replaceDestRect = *clipRect;
        } else {
            replaceDestRect = *(destSurf->GetSurfRect());
        }
                
        long srcWidth = WIDTH(&newSrcRect);
        long srcHeight = HEIGHT(&newSrcRect);

        newSrcRect.right  = (long) (((double) (replaceDestRect.right  - newDestRect.left) / destWidth ) * srcWidth  + (double) newSrcRect.left);
        newSrcRect.bottom = (long) (((double) (replaceDestRect.bottom - newDestRect.top ) / destHeight) * srcHeight + (double) newSrcRect.top );
        newSrcRect.left = (long) (((double) (replaceDestRect.left - newDestRect.left) / destWidth ) * srcWidth  + (double) newSrcRect.left);
        newSrcRect.top  = (long) (((double) (replaceDestRect.top  - newDestRect.top)  / destHeight) * srcHeight + (double) newSrcRect.top );

        if (newSrcRect.right <= newSrcRect.left) newSrcRect.right = newSrcRect.left + 1;
        if (newSrcRect.bottom <= newSrcRect.top) newSrcRect.bottom = newSrcRect.top + 1;

        newDestRect = replaceDestRect;
    }

    // compose from src to targ
    // using gdi's stretchblt

    HDC srcDC = srcSurf->GetDC("Couldn't get dc on src surf in ComposeToHDC");
    HDC destDC = destSurf->GetDC("Couldn't get dc on dest surf in ComposeToHDC");

    BOOL ret;

    if( clipRect ) {
        //
        // Create one
        //
        HRGN newClipRgn = CreateRectRgnIndirect(clipRect);
        if(!newClipRgn) {
            RaiseException_ResourceError("CreateRectRgnIndirect failed");
        }
        if( !clipRgn ) {
            clipRgn = newClipRgn;
        } else {
            // there is one, intersect
            ret = CombineRgn(clipRgn, newClipRgn, clipRgn, RGN_AND);
            if(ret == ERROR) {
                RaiseException_InternalError("GdiBlit: CombineRgn failed");
            }
            DeleteObject(newClipRgn);
        }
    }

    HRGN oldRgn = NULL;
    if(clipRgn) {
        if(GetClipRgn(destDC, oldRgn) < 1) {
            oldRgn = NULL;
        }
        int ret;
        TIME_GDI(ret = SelectClipRgn(destDC, clipRgn));
        if(ret == ERROR) {
            RaiseException_InternalError("SelectClipRgn failed in GdiBlit");
        }
    }

    TIME_GDI(ret = StretchBlt(destDC,
                              newDestRect.left,
                              newDestRect.top,
                              newDestRect.right - newDestRect.left,
                              newDestRect.bottom - newDestRect.top,
                              srcDC,
                              newSrcRect.left,
                              newSrcRect.top,
                              newSrcRect.right - newSrcRect.left,
                              newSrcRect.bottom - newSrcRect.top,
                              SRCCOPY));

    // TEMP TEMP
    //showme( (DDSurface *)destSurf );

    if(!ret) {
        TraceTag((tagError, "GdiBlit:  StretechBlt failed: srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                  newSrcRect.left, newSrcRect.top, newSrcRect.right, newSrcRect.bottom,
                  newDestRect.left, newDestRect.top, newDestRect.right,  newDestRect.bottom));
    }

    if(clipRgn) {
        TIME_GDI(SelectClipRgn(destDC, oldRgn));
        DeleteObject(oldRgn); // oldRgn is a COPY of the original rgn
        DeleteObject(clipRgn);
    }


    destSurf->ReleaseDC("Couldn't release dc on dest surf in ComposeToHDC");
    srcSurf->ReleaseDC("Couldn't release dc on src surf in ComposeToHDC");

    if(!ret) {
        TraceTag((tagError, "StretchBlt failed in ComposeToHDC"));
        RaiseException_InternalError("StretchBlt failed in ComposeToHDC");
    }
}

//
// Blits from the dcs of the surfaces using stretchblit
//
// this guy should be in ddutil.cpp... argh compiler
// complains... circular dep etc.. so, keep it here!
//
void GdiPrintBlit(GenericSurface *destSurf,
                  GenericSurface *srcSurf,
                  RECT *destRect,
                  RECT *srcRect)
{
    // compose from src to targ
    // using gdi's stretchblt

    DWORD size = ((((srcRect->right - srcRect->left) * 3) + 3) & ~3) * (srcRect->bottom - srcRect->top);
    PVOID pv = ThrowIfFailed(malloc(size));

    bool ok = true;

    HDC srcDC = srcSurf->GetDC("Couldn't get dc on src surf in GdiPrintBlit");
    HDC destDC = destSurf->GetDC("Couldn't get dc on dest surf in GdiPrintBlit");

    HBITMAP hbm = CreateCompatibleBitmap(srcDC,
                                         srcRect->right - srcRect->left,
                                         srcRect->bottom - srcRect->top);
    HDC srcDCtmp = CreateCompatibleDC(srcDC);

    if (hbm && srcDCtmp) {
        BITMAPINFO bi;
        memset(&bi,0,sizeof(bi));

        bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        bi.bmiHeader. biWidth = srcRect->right - srcRect->left;
        bi.bmiHeader. biHeight = srcRect->bottom - srcRect->top;
        bi.bmiHeader. biPlanes = 1;
        bi.bmiHeader. biBitCount = 24;
        bi.bmiHeader.biCompression = BI_RGB;
        bi.bmiHeader.biSizeImage = size;

        HBITMAP hbmold = (HBITMAP) SelectObject(srcDCtmp, hbm);

        ok = (BitBlt(srcDCtmp,0,0,
                     srcRect->right - srcRect->left,
                     srcRect->bottom - srcRect->top,
                     srcDC,
                     srcRect->left,
                     srcRect->top,
                     SRCCOPY) &&
              GetDIBits(srcDCtmp,
                        hbm,
                        0,
                        srcRect->bottom - srcRect->top,
                        pv,
                        &bi,
                        DIB_RGB_COLORS) &&
              StretchDIBits(destDC,
                            destRect->left,
                            destRect->top,
                            destRect->right - destRect->left,
                            destRect->bottom - destRect->top,
                            0,0,
                            srcRect->right - srcRect->left,
                            srcRect->bottom - srcRect->top,
                            pv,
                            &bi,
                            DIB_RGB_COLORS,
                            SRCCOPY));

        SelectObject (srcDCtmp, hbmold);
    } else {
        TraceTag((tagError, "CreateCompatibleBitmap failed in GdiPrintBlit"));
        ok = false;
    }

    if (srcDCtmp) DeleteDC(srcDCtmp);
    if (hbm) DeleteObject(hbm);

    free(pv);

    destSurf->ReleaseDC("Couldn't release dc on dest surf in GdiPrintBlit");
    srcSurf->ReleaseDC("Couldn't release dc on src surf in GdiPrintBlit");

    if(!ok) {
        RaiseException_InternalError("GdiPrintBlit failed");
    }
}

void DirectDrawImageDevice::
ComposeToHDC(GDISurface *destGDISurf,
             DDSurface *srcDDSurf,
             RECT *destRect,
             RECT *srcRect)
{
    Assert(destGDISurf);
    Assert(srcDDSurf);
    Assert(destRect);
    Assert(srcRect);

    //
    // Copy from the DC to a surface
    //
    DDSurfPtr<DDSurface> tempSurf;
    GetCompositingStack()->GetSurfaceFromFreePool(&tempSurf, dontClear);

    // Workaround for DX3 bug: ddraw limits the Blt to the size of the primary
    // surface if Clipper is set.  This looks bad when the offscreen surface
    // is bigger than the primary surface.
    // The workaround: Set the Clipper to NULL before the Blt, then set it back
    // to what it was.
    // Begin workaround part 1
    LPDIRECTDRAWCLIPPER currClipp=NULL;
    _ddrval = tempSurf->IDDSurface()->GetClipper( &currClipp );
    if(_ddrval != DD_OK &&
       _ddrval != DDERR_NOCLIPPERATTACHED) {
        IfDDErrorInternal(_ddrval, "Could not get clipper on trident surf");
    }

    if( currClipp ) {
        tempSurf->IDDSurface()->SetClipper(NULL);
        IfDDErrorInternal(_ddrval, "Couldn't set clipper to NULL");
    }
    // End workaround part 1

    bool IsDestPrinter;
    RECT tempRect = *(tempSurf->GetSurfRect());

    {
        HDC destdc = destGDISurf->GetDC("");
        HDC tmpdc = tempSurf->GetDC("");

        IsDestPrinter = ((GetDeviceCaps(destdc,TECHNOLOGY) == DT_RASPRINTER) ||
                         (GetDeviceCaps(destdc,TECHNOLOGY) == DT_PLOTTER)) ;

        if (IsDestPrinter) {
            PatBlt(tmpdc,
                   tempRect.left,
                   tempRect.top,
                   tempRect.right - tempRect.left,
                   tempRect.bottom - tempRect.top,
                   WHITENESS);
        }

        tempSurf->ReleaseDC("");
        destGDISurf->ReleaseDC("");
    }

    if (!IsDestPrinter) {
        //
        // Copy the destination rectangle from the dest dc
        // onto the tempRect in the tempSurf
        //
        GdiBlit(tempSurf,  // destiantion
                destGDISurf, // src surface
                &tempRect,
                destRect);
    }

    //
    // Color keyed blit to surface
    //
    _viewport.ColorKeyedCompose(tempSurf, // dest
                                &tempRect, // destRect
                                srcDDSurf, // src
                                srcRect,   // srcRect
                                _viewport._defaultColorKey);

    //
    // Copy from surface to dc
    //

    if (!IsDestPrinter) {
        GdiBlit(destGDISurf,
                tempSurf,
                destRect,
                &tempRect);
    } else {
        GdiPrintBlit(destGDISurf,
                     tempSurf,
                     destRect,
                     &tempRect);
    }

    // Begin workaround part 2
    if( currClipp ) {
        _ddrval = tempSurf->IDDSurface()->SetClipper(currClipp);

        // dump our reference.
        currClipp->Release();

        IfDDErrorInternal(_ddrval, "Couldn't set clipper");
    }
    // End workaround part 2

    GetCompositingStack()->ReturnSurfaceToFreePool(tempSurf);
}

// always passes back a 32bpp surface as big or bigger than width/height
void DirectDrawImageDevice::
Get32Surf(IDDrawSurface **surf32,
          LONG width, LONG height)
{
    bool doCreate = false;

    if((!_scratchSurf32Struct._surf32) ||
       (width > _scratchSurf32Struct._width) ||
       (height > _scratchSurf32Struct._height)) {
        doCreate = true;
    }

    if( doCreate ) {

        if(_scratchSurf32Struct._surf32) {
            _scratchSurf32Struct._surf32->Release();
        }
        _scratchSurf32Struct._width  = width;
        _scratchSurf32Struct._height = height;

        DDSURFACEDESC       ddsd;
        ZeroMemory(&ddsd, sizeof(ddsd));

        ddsd.dwSize = sizeof( ddsd );
        ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
        ddsd.dwWidth  = width;
        ddsd.dwHeight = height;
        ddsd.ddpfPixelFormat.dwSize = sizeof(ddsd.ddpfPixelFormat);
        ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB;
        ddsd.ddpfPixelFormat.dwRGBBitCount = 32;
        // ARGB: seems like the only 32bpp format ddraw likes...
        ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0xff000000;
        ddsd.ddpfPixelFormat.dwRBitMask        = 0x00ff0000;
        ddsd.ddpfPixelFormat.dwGBitMask        = 0x0000ff00;
        ddsd.ddpfPixelFormat.dwBBitMask        = 0x000000ff;

        ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;

        _ddrval = _viewport.CREATESURF( &ddsd,
                                        &_scratchSurf32Struct._surf32,
                                        NULL,
                                        "32bpp surf" );

        IfDDErrorInternal(_ddrval, "DirectDrawImageDevice::Get32Surf - CreateSurface Failed.");
    }

    *surf32 = _scratchSurf32Struct._surf32;
}



#if _DEBUG

void
DoBits16(LPDDRAWSURFACE surf16,
         LONG width, LONG height)
{
    HRESULT hr;
        //
        // Lock (16bpp) ddsurface  (SRC)
        //
        void *srcp;
        long pitch;
        DDSURFACEDESC srcDesc;
        srcDesc.dwSize = sizeof(DDSURFACEDESC);
        hr = surf16->Lock(NULL, &srcDesc, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
        IfDDErrorInternal(hr, "Can't Get ddsurf lock for DoBits16");
        srcp = srcDesc.lpSurface;
        pitch = srcDesc.lPitch;

        WORD *src;
        for(int i=0; i<height; i++) {
            src = (WORD *) ((BYTE *)srcp + (pitch * i));

            for(int j=0; j<width; j++) {
                *src = (WORD) (i * width + j);
                src++;
            }
        }

        surf16->Unlock(srcp);
}




void
DoBits32(LPDDRAWSURFACE surf32,
         LONG width, LONG height)
{
    HRESULT hr;
        //
        // Lock (32bpp) ddsurface  (SRC)
        //
        void *srcp;
        long pitch;
        DDSURFACEDESC srcDesc;
        srcDesc.dwSize = sizeof(DDSURFACEDESC);
        hr = surf32->Lock(NULL, &srcDesc, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
        IfDDErrorInternal(hr, "Can't Get ddsurf lock for DoBits32");
        srcp = srcDesc.lpSurface;
        pitch = srcDesc.lPitch;

        DWORD *src;
        for(int i=0; i<height; i++) {
            src = (DWORD *) ((BYTE *)srcp + (pitch * i));

            for(int j=0; j<width; j++) {
                *src = (i * width + j);
                src++;
            }
        }

        surf32->Unlock(srcp);
}

#endif _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\2dgradimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#include "headers.h"
#include <privinc/dddevice.h>
#include <privinc/GradImg.h>
#include <privinc/Path2i.h>
#include <privinc/dagdi.h>

// forward
extern Path2 *NewPolylinePath2(DWORD numPts, Point2Value **pts, BYTE *codes);

void DirectDrawImageDevice::RenderMulticolorGradientImage(
    MulticolorGradientImage *gradImg,
    int numOffsets,
    double offsets[],
    Color **clrs)
{
    if(!CanDisplay()) return;

    // i can do xf, opac, crop, etc...
    ResetAttributors();
    
    // final box is for post clip, post crop, post xform to determine culling
    Bbox2 finalBox = _viewport.GetTargetBbox();

    //
    // Get bbox of clip path, if any
    //
    Path2 *clippingPath;
    Transform2 *clippingPathXf;
    GetClippingPath( &clippingPath, &clippingPathXf );

    // if we're clipped out of existance
    if( clippingPath ) {

        // MAJOR TODO: if there's a crop above the matte it needs to
        // be reflected here.  this work should be done in
        // RenderMatteImage, 'cause it has all the context

        Bbox2 pathBox = clippingPath->BoundingBox();
        pathBox = TransformBbox2(clippingPathXf, pathBox);
        finalBox = IntersectBbox2Bbox2(finalBox, pathBox);

        // CULL
        if( finalBox == NullBbox2 ) return;
    }

    // if we're cropped out of existance
    Bbox2 accumCropBox = NullBbox2;
    if( IsCropped() ) {
        accumCropBox = DoBoundingBox(gradImg->BoundingBox());
        finalBox = IntersectBbox2Bbox2(finalBox, accumCropBox);

        // CULL
        if( finalBox == NullBbox2 ) return;
    }

    
    DDSurface *destDDSurf = GetCompositingStack()->TargetDDSurface();

    RectRegion clipRect( NULL );

    if( (accumCropBox != NullBbox2) &&  (accumCropBox != UniverseBbox2) ) {
        RECT destRect;
        DoDestRectScale(&destRect, GetResolution(), accumCropBox, destDDSurf);
        clipRect.SetRect(&destRect);
    }

    if( clipRect.GetRectPtr() ) {
        DoCompositeOffset(destDDSurf, clipRect.GetRectPtr());
    }
        
    if( IsCompositeDirectly() &&
        destDDSurf == _viewport._targetPackage._targetDDSurf ) {
        
        clipRect.Intersect(_viewport._targetPackage._prcViewport);
        if(_viewport._targetPackage._prcClip) {
            clipRect.Intersect(_viewport._targetPackage._prcClip);
        }
    }

    DAGDI &myGDI = *(GetDaGdi());

    myGDI.SetDDSurface(destDDSurf);
    myGDI.SetAntialiasing( true );
    myGDI.SetSampleResolution( 4 );
    myGDI.SetSuperScaleFactor( 1 );
    myGDI.SetClipRegion( &clipRect );
    
    // work only for rgb, NOT for rgba
    Real *dblClrs = (Real *)alloca(sizeof(double) * 3 * numOffsets);
    for(int i=0, j=0; i<3*numOffsets; i+=3, j++) {
        dblClrs[i  ] = clrs[j]->red;
        dblClrs[i+1] = clrs[j]->green;
        dblClrs[i+2] = clrs[j]->blue;
    }

    Transform2 *xfToUse = DoCompositeOffset(destDDSurf, GetTransform());

    MulticolorGradientBrush gradBrush(
        offsets,
        dblClrs,
        numOffsets,
        GetOpacity(),
        xfToUse,
        gradImg->GetType());

    myGDI.SetBrush(&gradBrush);
    
    if( !clippingPath ) {

        DWORD    numPts = 4;
        Point2Value **pts   = (Point2Value **) AllocateFromStore (numPts * sizeof(Point2Value *));
        BYTE    *codes = (BYTE *)AllocateFromStore(numPts * sizeof(BYTE));

        pts[0] = NEW Point2Value(finalBox.min.x, finalBox.min.y);
        pts[1] = NEW Point2Value(finalBox.max.x, finalBox.min.y);
        pts[2] = NEW Point2Value(finalBox.max.x, finalBox.max.y);
        pts[3] = NEW Point2Value(finalBox.min.x, finalBox.max.y);

        codes[0] = PT_MOVETO;
        codes[1] = PT_LINETO;
        codes[2] = PT_LINETO;
        codes[3] = PT_LINETO | PT_CLOSEFIGURE;

        clippingPath = NewPolylinePath2(numPts, pts, codes);
        clippingPathXf = identityTransform2;
    }

    clippingPathXf = DoCompositeOffset(destDDSurf, clippingPathXf);
    
    clippingPath->RenderToDaGdi(
        &myGDI,
        clippingPathXf,
        _viewport.Width()/2,
        _viewport.Height()/2,
        GetResolution() );

    myGDI.ClearState();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\2dtext.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

   DirectDrawImageDevice text related methods

*******************************************************************************/


#include "headers.h"


#include <mbstring.h>
#include "appelles/Path2.h"
#include "privinc/dddevice.h"
#include "privinc/viewport.h"
#include "privinc/texti.h"
#include "privinc/TextImg.h"
#include "privinc/Linei.h"
#include "privinc/OverImg.h"
#include "privinc/DaGdi.h"
#include "privinc/debug.h"
#include "backend/bvr.h"

static HFONT MyCreateFont(LOGFONTW & lf)
{
    if (sysInfo.IsWin9x()) {
        LOGFONTA lfa ;
        ZeroMemory(&lfa,sizeof(lfa));
        
        lfa.lfHeight = lf.lfHeight;
        lfa.lfWidth = lf.lfWidth;
        lfa.lfEscapement = lf.lfEscapement;
        lfa.lfOrientation = lf.lfOrientation;
        lfa.lfWeight = lf.lfWeight;
        lfa.lfItalic = lf.lfItalic;
        lfa.lfUnderline = lf.lfUnderline;
        lfa.lfStrikeOut = lf.lfStrikeOut;
        lfa.lfCharSet = lf.lfCharSet;
        lfa.lfOutPrecision = lf.lfOutPrecision;
        lfa.lfClipPrecision = lf.lfClipPrecision;
        lfa.lfQuality = lf.lfQuality;
        lfa.lfPitchAndFamily = lf.lfPitchAndFamily;

        USES_CONVERSION;
        
        lstrcpyA(lfa.lfFaceName, W2A(lf.lfFaceName));
        
        return CreateFontIndirectA(&lfa);
    }

    return CreateFontIndirectW(&lf);
}



static inline bool
IsRTLFont(LOGFONTW *plf)
{
    return (plf->lfCharSet == ARABIC_CHARSET || plf->lfCharSet == HEBREW_CHARSET);
}


void DirectDrawImageDevice::
RenderText(TextCtx& textCtx, 
           WideString str, 
           Image *textImg)
{
    if(!CanDisplay()) return;
    
    DDSurface *targDDSurf = GetCompositingStack()->TargetDDSurface();

    SetDealtWithAttrib(ATTRIB_CROP, TRUE);
    SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, TRUE);
    SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, TRUE);

    DAGDI &myGDI = *(GetDaGdi());
    bool bAA = UseImageQualityFlags(
        CRQUAL_AA_TEXT_ON | CRQUAL_AA_TEXT_OFF,
        CRQUAL_AA_TEXT_ON, 
        (textCtx.GetAntiAlias() > 0.0) ? true : false);

    myGDI.SetAntialiasing(bAA);

    // Always set up for using Dx2D
    if (myGDI.GetDx2d()) {
        SetDealtWithAttrib(ATTRIB_OPAC, TRUE);
        myGDI.SetViewportSize(_viewport._width,_viewport._height );
    }   

    if( !AllAttributorsTrue() &&
        (targDDSurf == GetCompositingStack()->TargetDDSurface()) ) {
        targDDSurf = GetCompositingStack()->ScratchDDSurface(doClear);
    }
    
    if(textCtx.GetFixedText()) {
        RenderStaticText(textCtx, 
                         str, 
                         textImg,
                         targDDSurf,
                         myGDI);
    } else {
        RenderStringTargetCtx ctx(targDDSurf);
        RenderDynamicTextOrCharacter(textCtx, 
                                     str, 
                                     textImg,
                                     NULL,
                                     textRenderStyle_filled,
                                     &ctx,
                                     myGDI);
    }
}


void DirectDrawImageDevice::
GenerateTextPoints(
    // IN
    TextCtx& textCtx, 
    WideString str, 
    DDSurface *targDDSurf,
    HDC optionalDC,
    bool doGlyphMetrics,

    // OUT
    TextPoints& txtPts)
{
    // for now we MUST ALWAYS do metrics for cache consistency
    Assert( doGlyphMetrics == true );

    // THE CODE IN THIS SCOPE SHOULD BE DONE
    // ONCE PER STRING BOLD ITALIC FONTFAMILY FONT

    POINT *points;

    // -----------------------------------
    // Get the points of the string
    // -----------------------------------
    int iFontSize = 200; // for starters
    {
        // -----------------------------------
        // Create the font
        // -----------------------------------
        _viewport.MakeLogicalFont(textCtx, &_logicalFont, iFontSize, iFontSize);
        UINT bUnderline9x=0;
        UINT bStrikeout9x=0;
        if(sysInfo.IsWin9x()  && (_logicalFont.lfUnderline || _logicalFont.lfStrikeOut)) {
            // we are on w95 and have been asked to underline of strikeout
            bUnderline9x = _logicalFont.lfUnderline;
            bStrikeout9x = _logicalFont.lfStrikeOut;
            _logicalFont.lfUnderline = 0;
            _logicalFont.lfStrikeOut = 0;
        }
        HFONT theFont = MyCreateFont(_logicalFont);


        HDC targDC;
        if( targDDSurf ) {
            targDC = targDDSurf->GetDC("Couldn't get DC in RenderStringOnImage");
        } else {
            targDC = optionalDC;
        }

        // dcReleaser works with NULL surfs
        DCReleaser dcReleaser(targDDSurf, "Couldn't release DC in RenderStringOnImage");

        GetTextPoints(targDC, theFont, str, &points, txtPts,
                      bUnderline9x, bStrikeout9x, doGlyphMetrics);

        ::DeleteObject(theFont);
    }

    // -----------------------------------
    // XForm the points from gdi space into
    // real space.  this is meant to happen once
    // and toss the LONG pixels
    // -----------------------------------
    txtPts._pts =
        (DXFPOINT *)StoreAllocate(GetSystemHeap(), txtPts._count * sizeof(DXFPOINT));

    Real resolution = GetResolution();
    
    // This is the scale that needs to be applied to get the
    // text down to cannonical size (12 points) from the
    // size given from GetTextPoints
    txtPts._normScale =
        (METERS_PER_POINT * DEFAULT_TEXT_POINT_SIZE) /
        (Real(iFontSize) / resolution);

    // -----------------------------------
    // Transform to cannonical text space
    // -----------------------------------
    DXFPOINT *dst = txtPts._pts;
    POINT    *src = points;
    Real      scale = txtPts._normScale;
    
    for (int i=0; i<txtPts._count; i++) {
        dst->x = scale * (Real)(src->x) / resolution;
        dst->y = scale * (Real)(src->y) / resolution;
        dst++;
        src++;
    }

    // ------------------------------------------------
    // Transform glyph metrics to cannonical text space
    // ------------------------------------------------
    if( doGlyphMetrics ) {
        GLYPHMETRICS *gm;
        for (int i=0; i<txtPts._strLen; i++) {
            gm = &(txtPts._glyphMetrics[i].gm);
            /*
              UINT  gmBlackBoxX; 
              UINT  gmBlackBoxY;
              POINT gmptGlyphOrigin; // use origin to offset the text
              short gmCellIncX; 
              short gmCellIncY;
              */

            // um... lots of resolution lost...
            txtPts._glyphMetrics[i].gmBlackBoxY = 
                txtPts._normScale * (Real(gm->gmBlackBoxY) / resolution);
            txtPts._glyphMetrics[i].gmBlackBoxX = 
                txtPts._normScale * (Real(gm->gmBlackBoxX) / resolution);
            txtPts._glyphMetrics[i].gmptGlyphOriginX = 
                txtPts._normScale * (Real(gm->gmptGlyphOrigin.x) / resolution);
            txtPts._glyphMetrics[i].gmptGlyphOriginY = 
                txtPts._normScale * (Real(gm->gmptGlyphOrigin.y) / resolution);
            txtPts._glyphMetrics[i].gmCellIncX = 
                txtPts._normScale * (Real(gm->gmCellIncX) / resolution);
            txtPts._glyphMetrics[i].gmCellIncY = 
                txtPts._normScale * (Real(gm->gmCellIncY) / resolution);
        }
    }

    // don't need these any more
    if (points) {
        // 14024: On NT, GetPath doesn't like the memory we
        // allocate with AllocateFromStore somehow.
        //DeallocateFromStore(points);
        StoreDeallocate(GetSystemHeap(), points);
    }
}


TextPoints *GenerateCacheTextPoints(DirectDrawImageDevice* dev,
                                    TextCtx& textCtx,
                                    WideString str,
                                    bool doGlyphMetrics)
{
    // for now we MUST ALWAYS do metrics for cache consistency
    Assert( doGlyphMetrics == true );

    TextPoints *txtPts = dev->GetTextPointsCache(&textCtx, str);

    if (txtPts == NULL) {
        TraceTag((tagTextPtsCache,
                  "GetTextPoints cache miss: %ls\n", str));
        
        txtPts = NEW TextPoints(GetSystemHeap(), true);

        // OPTIMIZE: how expensive is this ?
        // can we potentially cache it ?
        HDC dc;
        TIME_GDI( dc = CreateCompatibleDC(NULL) );

        dev->GenerateTextPoints(textCtx, str, NULL, dc, doGlyphMetrics, *txtPts);

        TraceTag((tagTextPtsCache,
                  "0x%x GetTextPoints cache miss: \"%ls\", %d pts",
                  dev, str, txtPts->_count));
        
        dev->SetTextPointsCache(&textCtx, str, txtPts);

        TIME_GDI( DeleteDC(dc) );
        
    } // end cache scope

    return txtPts;
}

    
void DirectDrawImageDevice::
RenderDynamicTextOrCharacter(
    TextCtx& textCtx, 
    WideString str, 
    Image *textImg,  // not used yet..
    Transform2 *overridingXf,
    textRenderStyle textStyle,
    RenderStringTargetCtx *targetCtx,
    DAGDI &myGDI)
{
    Assert( targetCtx );
    if(!CanDisplay()) return;

    //
    // If we're rendering individual characters
    if( textCtx.GetCharacterTransform() ) {
        _RenderDynamicTextCharacter(textCtx,
                                    str,
                                    textImg,
                                    overridingXf,
                                    textStyle,
                                    targetCtx,
                                   myGDI);
    } else {
        _RenderDynamicText(textCtx, 
                           str, 
                           textImg,
                           overridingXf,
                           textStyle,
                           targetCtx,
                           myGDI);
    }
}

void DirectDrawImageDevice::
_RenderDynamicText(
    TextCtx& textCtx, 
    WideString str, 
    Image *textImg,  // not used yet..
    Transform2 *overridingXf,
    textRenderStyle textStyle,
    RenderStringTargetCtx *targetCtx,
    DAGDI &myGDI)
{
    // textImg and targDDSurf can be NULL
    // optionalDC and overridingXf can be NULL

    //
    // OK, when justDrawPath is true that means that someone wants us
    // to just draw stuff into a path.  they've already begun the path
    // and done a bunch of stuff.  we're not supposed to draw.
    // We're also not supposed to TOUCH the dc excep for path stuff
    // this means: no offset, no clipping!
    //

    //----------------------------------------
    // if we don't do metrics and the
    // text gets rendered again with
    // metrics required we'll assert
    // because the cache will hit, but
    // the metrics aren't there.
    // TODO: the right thing to do is have a better cache <larger>
    // or have it dynamically update the cache if we want metrics but
    // don't have them.  for now get them ALL the time!
    //----------------------------------------
    //bool doGlyphMetrics = false;
    bool doGlyphMetrics = true;
    TextPoints *txtPts = GenerateCacheTextPoints(this, textCtx, str, doGlyphMetrics);

    //
    // no need to do any work. it's empty text <a space for example,
    // no null text>
    //
    if( txtPts->_count <= 0 ) {
        return;
    }
    
    Transform2 *oldXf = NULL;
    if(overridingXf) {
        oldXf = GetTransform();
        SetTransform(overridingXf);
    }
    

    // -----------------------------------
    // Transform the points using real xf
    // in real space
    // -----------------------------------

    Transform2 *xfToUse  = GetTransform();

    if( targetCtx->GetTargetDDSurf() ) {
        // COMPOSITE
        // if we're composite to targ, transform the points a bit.
        xfToUse = DoCompositeOffset(targetCtx->GetTargetDDSurf(), xfToUse);
    }

    // stash the xform to be used with pixelTextBoundingRect
    Transform2 *preAAScaleXf = xfToUse;

    // The fast path means that we're not rendering into a DC's path,
    // and we have Dx2d available.
    bool fastPath =
        myGDI.GetDx2d()  && targetCtx->GetTargetDDSurf();

    // Ensure that we're never rendering to a DC if we think we're
    // anti-aliasing.

// Disabled for now!!    
//    Assert(myGDI.DoAntiAliasing() ? !targetCtx->GetTargetDC() : true);
    
    if(fastPath) {
        xfToUse = TimesTransform2Transform2(myGDI.GetSuperScaleTransform(), xfToUse);
    }

    DWORD w2 = _viewport.Width()/2;
    DWORD h2 = _viewport.Height()/2;

    // Only take the path use GDI if we're not doing anti-aliasing and
    // Dx2D isn't available.  Too slow -- Dx2D lets us set a world
    // transform which makes things *much* faster.
    POINT *gdiPoints = NULL;

    // Only go the GDI route if we either don't have Dx2D, or our
    // target is not a surface (in which case we're going to be
    // rendering into a path).
    Real resolution = GetResolution();
    
    if (!fastPath) {

        gdiPoints =
            (POINT *)AllocateFromStore( txtPts->_count * sizeof(POINT) );

        TransformDXPoint2ArrayToGDISpace(xfToUse,
                                       txtPts->_pts,
                                       gdiPoints,
                                       txtPts->_count,
                                       w2, h2,
                                       resolution);
    }

    //
    // Get the pixel bounding rect of the text, after xforms, after
    // the cannonical thing, etc...  we saved the indicies of these
    // points when we generated them and found the min/max.
    // Note the top/left, bottom/right weirdness where the maxy index,
    // for example is actually the top point's Y value.
    //
    RECT pixelTextBoundingRect;
    {
        float xx[4], yy[4];
        DXFPOINT pts[4];

        pts[0].x = txtPts->_pts[ txtPts->_minxIndex ].x;
        pts[0].y = txtPts->_pts[ txtPts->_minyIndex ].y;

        pts[1].x = txtPts->_pts[ txtPts->_minxIndex ].x;
        pts[1].y = txtPts->_pts[ txtPts->_maxyIndex ].y;

        pts[2].x = txtPts->_pts[ txtPts->_maxxIndex ].x;
        pts[2].y = txtPts->_pts[ txtPts->_minyIndex ].y;

        pts[3].x = txtPts->_pts[ txtPts->_maxxIndex ].x;
        pts[3].y = txtPts->_pts[ txtPts->_maxyIndex ].y;

        POINT r[4];

        // xform the points that form an axis aligned rect (pre xf).
        TransformDXPoint2ArrayToGDISpace( preAAScaleXf, pts, r, 4, w2, h2, resolution);

        // figure out the post xf axis aligned rect
        DWORD minx, maxx, miny, maxy;
        minx = MIN(r[0].x, MIN(r[1].x, MIN(r[2].x, r[3].x)));
        maxx = MAX(r[0].x, MAX(r[1].x, MAX(r[2].x, r[3].x)));
        miny = MIN(r[0].y, MIN(r[1].y, MIN(r[2].y, r[3].y)));
        maxy = MAX(r[0].y, MAX(r[1].y, MAX(r[2].y, r[3].y)));

        // make right bottom edge exclusive.
        SetRect(&pixelTextBoundingRect, minx, miny, maxx+2, maxy+2 );
    }

    // Set up for the right style of text rendering
    PolygonRegion  drawPolygon;
    if (gdiPoints) {
        drawPolygon.Init(gdiPoints, txtPts->_count);
    } else {
        drawPolygon.Init(txtPts, w2, h2, resolution, xfToUse);
    }
    
    // Get the text COLOR
    DAColor dac( textCtx.GetColor(),
                 GetOpacity(),
                 _viewport.GetTargetDescriptor() );

    // Select a clip region in the dc if cropped.
    RectRegion  clipRectRegion(NULL);
    
    //
    // remember, we're not supposed to touch the
    // dc is we're asked to justDrawPath
    //

    if( targetCtx->GetTargetDDSurf() ) {
        
        DDSurface *targDDSurf = targetCtx->GetTargetDDSurf();
        if( IsCropped() ) {

            RECT croppedRect;
        
            // Compute accumulated bounding box
            Bbox2 box = IntersectBbox2Bbox2(
                _viewport.GetTargetBbox(),
                DoBoundingBox(UniverseBbox2));
                        
            // Figure out destination rectangle
            DoDestRectScale(&croppedRect, resolution, box);

            DoCompositeOffset(targDDSurf, &croppedRect);
        
            if( targDDSurf == _viewport._targetPackage._targetDDSurf ) {

                RECT clipRect;
                if (_viewport._targetPackage._prcClip) {
                    IntersectRect(&clipRect,
                                  _viewport._targetPackage._prcViewport,
                                  _viewport._targetPackage._prcClip);
                } else {
                    clipRect = *_viewport._targetPackage._prcViewport;
                }
                IntersectRect(&croppedRect,
                              &croppedRect,
                              &clipRect);
            }

            clipRectRegion.Intersect( & croppedRect );
        
        } else {  // not cropped
            
            // XXX: should we clip it to the surface anyway ???
            // XXX FACTOR THIS OUT
        
            RECT croppedRect = *(targDDSurf->GetSurfRect());
            if( targDDSurf == _viewport._targetPackage._targetDDSurf ) {
                if (_viewport._targetPackage._prcClip) {
                    IntersectRect(&croppedRect,
                                  _viewport._targetPackage._prcViewport,
                                  _viewport._targetPackage._prcClip);
                } else {
                    croppedRect = *_viewport._targetPackage._prcViewport;
                }
            }
            
            clipRectRegion.Intersect( & croppedRect );
        }

        //
        // Now take the croppedRect and intersect that with the
        // pixelTextBoundingRect to get a smaller "interestingRect" to
        // set on the surface
        //
        Assert(clipRectRegion.GetRectPtr());
        IntersectRect( &pixelTextBoundingRect,
                       &pixelTextBoundingRect,
                       clipRectRegion.GetRectPtr() );

        //
        // Set the final offset interesting rect on the surface
        //
        targDDSurf->SetInterestingSurfRect( &pixelTextBoundingRect );

        DebugCode(
            if (IsTagEnabled(tagTextBoxes)) {
                DrawRect(targDDSurf, &pixelTextBoundingRect, 255, 10, 30);
            }
        );
    } // targetDDSurf


    Assert( drawPolygon.GetNumPts() == txtPts->_count );

    myGDI.SetClipRegion( &clipRectRegion );

    if( targetCtx->GetTargetDDSurf() ) {

        Assert( textStyle == textRenderStyle_filled );

        Pen solidPen( dac );
        SolidBrush solidBrush( dac );

        myGDI.SetPen( &solidPen );
        myGDI.SetBrush( &solidBrush );
        myGDI.SetDDSurface( targetCtx->GetTargetDDSurf() );
        
        myGDI.PolyDraw(&drawPolygon, txtPts->_types);

    } else {

        Assert( targetCtx->GetTargetDC() );
        Assert( textStyle == textRenderStyle_invalid );

// Disabled for now!!   
//        Assert( !myGDI.DoAntiAliasing() );

        myGDI.PolyDraw_GDIOnly(targetCtx->GetTargetDC(),
                               &drawPolygon,
                               txtPts->_types);
    }

    myGDI.ClearState();
    
    // return xf if any
    if(oldXf) {
        SetTransform(oldXf);
    }

    if(gdiPoints) {
        DeallocateFromStore(gdiPoints);
    }
}




const Bbox2 DirectDrawImageDevice::
DeriveDynamicTextBbox(TextCtx& textCtx, WideString str,bool bCharBox)
{
    Bbox2 box;

    //----------------------------------------
    // if we don't do metrics and the
    // text gets rendered again with
    // metrics required we'll assert
    // because the cache will hit, but
    // the metrics aren't there.
    // TODO: the right thing to do is have a better cache <larger>
    // or have it dynamically update the cache if we want metrics but
    // don't have them.  for now get them ALL the time!
    //----------------------------------------
    //bool doGlyphMetrics = false;
    bool doGlyphMetrics = true;
    TextPoints *txtPts =
        GenerateCacheTextPoints(this,
                                textCtx, 
                                str,
                                doGlyphMetrics);

    Real res = GetResolution();
    
    box.min.Set(Real(txtPts->_normScale * (txtPts->_minPt.x - 1)) / res,
                 Real(txtPts->_normScale * (txtPts->_minPt.y - 1)) / res);
    box.max.Set(Real(txtPts->_normScale * (txtPts->_maxPt.x + 1)) / res,
                 Real(txtPts->_normScale * (txtPts->_maxPt.y + 1)) / res);

    if(bCharBox) {
        Bbox2 boxChar;
        Real realXOffset = -(box.Width() * 0.5);
        
        // WideString character to pass into RenderDynamicText
        WCHAR oneWstrChar[2];
        Transform2 *currXf, *tranXf, *xfToUse, *charXf;
        WideString lpWstr = str;

        // get strlen from the string mon.
        int mbStrLen = wcslen( str );
        TextPoints *txtPts;

        Real currLeftProj = 0,
             currRightProj = 0,
             lastRightProj = 0;
        for(int i=0; i < mbStrLen; i++) {

            // clear first char
            oneWstrChar[0] = (WCHAR)0;
            // copy one wstr character into oneWstrChar
            wcsncpy(oneWstrChar, lpWstr, 1);
            // null terminate, just to be sure
            oneWstrChar[1] = (WCHAR)0;
                
            // Get metrics for this character
            txtPts = GenerateCacheTextPoints(this, textCtx, oneWstrChar, true);
            Assert( txtPts->_glyphMetrics );

            charXf = textCtx.GetCharacterTransform();

            ComputeLeftRightProj(charXf,
                                 txtPts->_glyphMetrics[0],
                                 &currLeftProj,
                                 &currRightProj);
        
            //
            // Offset in x for the next character
            //
            realXOffset += lastRightProj + currLeftProj;

            //
            // Do transforms
            //
            tranXf = TranslateRR( realXOffset, 0 );

            // charXf first, then translate
            xfToUse = TimesTransform2Transform2(tranXf, charXf);

            Bbox2 tempBox;

            tempBox.Set(Real(txtPts->_normScale * (txtPts->_minPt.x - 1)) / res,
                             Real(txtPts->_normScale * (txtPts->_minPt.y - 1)) / res,
                             Real(txtPts->_normScale * (txtPts->_maxPt.x + 1)) / res,
                             Real(txtPts->_normScale * (txtPts->_maxPt.y + 1)) / res);
       
            // the current character is now the last character
            lastRightProj = currRightProj;
                    
            // Add to the BBox2.
            Bbox2 tbox = TransformBbox2(xfToUse, tempBox);
            boxChar.Augment(tbox.min);
            boxChar.Augment(tbox.max);
 
            // next WideChar
            lpWstr++;
        }
        return boxChar;
    }
    
    return box;
}


void  GetCharacterGlyphMetrics(
    HDC hDC,
    WideString wideStr,
    TextPoints& txtPts)
{
    bool ok = true;
    
    //
    // convert string to ansi multibyte string
    //
    int mbl = wcstombs(NULL, wideStr, 0);
    unsigned char *mbc = NEW unsigned char[mbl+2];
    
    wcstombs((char *)mbc, wideStr, mbl);
    mbc[mbl] = mbc[mbl+1] = 0;
    
    //
    // get text characters from text cache
    //

    //int mbStrLen = _mbstrlen(mbc); // uses LC_CTYPE locale
    int mbStrLen = _mbslen(mbc);  // uses current locale

    // set characher count
    txtPts._strLen = mbStrLen;

    // allocate glyphmetrics array and hand off to txtPts
    Assert(txtPts._glyphMetrics == NULL);
    txtPts._glyphMetrics = (TextPoints::DAGLYPHMETRICS *)
        StoreAllocate(GetSystemHeap(), mbStrLen * sizeof(TextPoints::DAGLYPHMETRICS));

    // zero it out
    memset( txtPts._glyphMetrics, 0, mbStrLen * sizeof(TextPoints::DAGLYPHMETRICS));

    MAT2 mat2;  ZeroMemory( &mat2, sizeof(mat2));
    mat2.eM11.value = 1;
    mat2.eM22.value = 1;

    /*
    typedef struct _GLYPHMETRICS { // glmt
        UINT  gmBlackBoxX; 
        UINT  gmBlackBoxY;
        POINT gmptGlyphOrigin; // use origin to offset the text
        short gmCellIncX; 
        short gmCellIncY;
    } GLYPHMETRICS;       
    */
    
    char oneMbChar[4];
    ZeroMemory( oneMbChar, 4 * sizeof( char ));

    int inc, ret, i;
    unsigned char *multiByte = mbc;

    GLYPHMETRICS *lpGm;
    for(i=0; i < mbStrLen; i++) {

        lpGm = &( txtPts._glyphMetrics[i].gm );
        
        // how many bytes is the first character in this string ?
        inc = _mbclen( multiByte );

        // clear oneMbChar
        ZeroMemory( oneMbChar, 4 * sizeof( char ));
        
        // Convert one multibyte char into a widechar
        Assert( inc <= 4 );
        CopyMemory( oneMbChar, multiByte, inc );
        
        // Figure out the intercharacter spacing for this character
        ret = GetGlyphOutline(
            hDC,
            *((UINT *)oneMbChar), // one multibyte character
            GGO_METRICS,
            lpGm,
            0, NULL,
            &mat2);
        
        if( ret == GDI_ERROR ) {
            DebugCode(
            {
                void *msgBuf;
                FormatMessage( 
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    GetLastError(),
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                    (LPTSTR) &msgBuf,
                    0,
                    NULL );
                
                AssertStr(false, (char *)msgBuf);
                
                LocalFree( msgBuf );
            }
            );
            ok = false;
            break;
        }
        
        // increment past the current multibyte character
        multiByte += inc;
    }

    delete mbc;
    
    if(!ok) {
        RaiseException_InternalError("RenderDynamicTextCharacter failed");
    }
}

// taken from ihammer: mbyrd
void DirectDrawImageDevice::
GetTextPoints(
    HDC hDC,
    HFONT font,
    WideString wideStr,
    POINT **points,   // out
    TextPoints& txtPts,
    UINT bUnderline,
    UINT bStrikeout,
    bool doGlyphMetrics)
{
    int cnt = 0;
    POINT *pts = 0;
    BYTE  *tps = 0;


    HFONT hFont = font;
    HFONT hOldFont = (HFONT)NULL;
    UINT uiOldAlign = 0;
    int iOldMode = 0;

    
    iOldMode = ::SetBkMode(hDC, TRANSPARENT);
    hOldFont = (HFONT)::SelectObject(hDC, hFont);
    
    DWORD dwAlign =  TA_BASELINE | TA_CENTER;
    if (IsRTLFont(&_logicalFont))
        dwAlign |= TA_RTLREADING;
    
    // Make sure we handle fonts with vertical default 
    // baseline, like Japanese
    if ((VTA_CENTER && ::GetTextAlign(hDC)))
        dwAlign |=  VTA_CENTER;
    
    uiOldAlign = ::SetTextAlign(hDC, dwAlign);


    if( doGlyphMetrics ) {
        // Before we begin path & get all the points we need to get all
        // the metrics for each letter.  this is for xforming characters only
        GetCharacterGlyphMetrics(hDC, wideStr, txtPts);
    }
        
    // start the path...
    ::BeginPath(hDC);

    if (sysInfo.IsWin9x()) {
        USES_CONVERSION;

        char *p = W2A(wideStr);
        
        // Draw the text at 0, 0
        ::ExtTextOut(
            hDC,
            0,
            0,
            0,
            NULL,
            p,
            lstrlen(p),
            NULL);
    
        // Let us do the underline/strikeout...
        if(bUnderline || bStrikeout) {
            SIZE textSize;
            if( GetTextExtentPoint32(hDC, p, lstrlen(p), &textSize)) {
                int width  = textSize.cx /2;
                int offset  = textSize.cy / 10;

                // do the underline / strikeout
                if(bStrikeout) {
                    ::MoveToEx(hDC, -width, -offset * 2.5, NULL);
                    ::LineTo(hDC, width, -offset * 2.5);
                }
                if(bUnderline) {
                    ::MoveToEx(hDC, -width, offset, NULL);
                    ::LineTo(hDC, width, offset);
                }
            }
        }

    } else {
        // Draw the text at 0, 0
        ::ExtTextOutW(
            hDC,
            0,
            0,
            0,
            NULL,
            wideStr,
            lstrlenW(wideStr),
            NULL);
    }    

    // start the path...
    ::EndPath(hDC);
    
    // Reset the hDC...
    ::SetBkMode(hDC, iOldMode);
    ::SetTextAlign(hDC, uiOldAlign);
    ::SelectObject(hDC, hOldFont);
    
    // Get the path from the hDC...
    cnt = ::GetPath(hDC, NULL, NULL, 0);
    
    int iMinX = 0; int iMaxX = 0;
    int iMinY = 0; int iMaxY = 0;

    //
    // These keep track of the INDEX of the min/max points in the
    // point array.
    //
    ULONG iMinX_index = 0, iMaxX_index = 0;
    ULONG iMinY_index = 0, iMaxY_index = 0;
    
    if ( cnt > 0)
      {
          
          // Allocate the buffers for the path...
          // 14024: On NT, GetPath doesn't like the memory we
          // allocate with AllocateFromStore somehow.
          //pts = (POINT *)AllocateFromStore( sizeof(POINT) * cnt );
          pts = (POINT *) StoreAllocate(GetSystemHeap(), sizeof(POINT) * cnt );
          tps = (BYTE *) StoreAllocate(GetSystemHeap(), sizeof(BYTE) * cnt );
          
          if ( pts && tps )
            {
                iMinX = 32000;  iMaxX = -32000;
                iMinY = 32000;  iMaxY = -32000;
                int iPointIndex = 0;
                
                // Get the points...
                ::GetPath(hDC, pts, tps, cnt);

                // Transform the points...
                for(iPointIndex=0;iPointIndex<cnt;iPointIndex++)
                  {
                      int iXPos = (int)((short)(pts[iPointIndex].x & 0x0000FFFF));

                      // negate the position
                      int iYPos = - (int)((short)(pts[iPointIndex].y & 0x0000FFFF));

                      // XXX DO i need to do this ?
                      // Transform based on our origin and rotation...
                      //xformObject.Transform2dPoint(&iXPos, &iYPos);
                      
                      pts[iPointIndex].x = iXPos;
                      pts[iPointIndex].y = iYPos;
                      
                      if (iXPos < iMinX) {
                          iMinX = iXPos;
                          iMinX_index = iPointIndex;
                      }
                      if (iXPos > iMaxX) {
                          iMaxX = iXPos;
                          iMaxX_index = iPointIndex;
                      }
                      if (iYPos < iMinY) {
                          iMinY = iYPos;
                          iMinY_index = iPointIndex;
                      }
                      if (iYPos > iMaxY) {
                          iMaxY = iYPos;
                          iMaxY_index = iPointIndex;
                      }
                  }
                
            }
          else
            {
                if (pts) {
                    // 14024: On NT, GetPath doesn't like the memory we
                    // allocate with AllocateFromStore somehow.
                    //DeallocateFromStore(pts);
                    StoreDeallocate(GetSystemHeap(), pts);
                }
                if (tps) {
                    StoreDeallocate(GetSystemHeap(), tps);
                }
            }
      } else {
          // this is ok.
      }
    
    txtPts._count = cnt;
    (*points) = pts;
    txtPts._types = tps;
    txtPts._minPt.x = iMinX;  txtPts._minPt.y = iMinY;
    txtPts._maxPt.x = iMaxX;  txtPts._maxPt.y = iMaxY;  

    txtPts._minxIndex = iMinX_index;
    txtPts._maxxIndex = iMaxX_index;
    txtPts._minyIndex = iMinY_index;
    txtPts._maxyIndex = iMaxY_index;
    
    txtPts._centerPt.x = Real(iMinX + iMaxX) * 0.5;
    txtPts._centerPt.y = Real(iMinY + iMaxY) * 0.5;
}


// OLD TEXT CODE

void DirectDrawImageDevice::
RenderStaticTextOnDC(TextCtx& textCtx, 
                     WideString str, 
                     HDC dc,
                     Transform2 *xform)
{
    Transform2 *oldXf = GetTransform();
    SetTransform(xform);

    Bbox2 seedBox = NullBbox2;
    if(IsCropped()) {
        seedBox = DeriveStaticTextBbox(textCtx, str);
    }

    // Just figure it out every frame.  optimize later.
    _viewport.MakeLogicalFont(textCtx, &_logicalFont);

    // Figure out scale factors
    Real xScale=1, yScale=1, rot=0;
    DecomposeMatrix(GetTransform(), &xScale, &yScale, &rot);

    HFONT newFont=NULL;
    newFont = MyCreateFont(_logicalFont);
    Assert(newFont && "Couldn't create font in RenderStaticTextOnDC");

    { // font1 scope
            
        ObjectSelector font1(dc, newFont);
        Assert(font1.Success() && "Couldn't select font in RenderStaticTextOnDC");
            
        SetBkMode(dc, TRANSPARENT);
            
        SetMapMode(dc, MM_TEXT); // Each logical unit = 1 pixel
            
        //
        // Get ave char width of font.
        //
        TEXTMETRIC textMetric;
        GetTextMetrics(dc, &textMetric);
            
        SIZE size;
        WideString c = str; int len = lstrlenW(c);
            
        // Scale font the yScale times the default point size.
        // This formula for determining height comes from the
        // Win32 documentation of the LOGFONT structure.
        // Do rounding to the nearest integer when converting from float
        // to int.  It does truncation otherwise.
        LONG height =
            -MulDiv((int)(DEFAULT_TEXT_POINT_SIZE * yScale + 0.5),
                    GetDeviceCaps(dc, LOGPIXELSY),
                    72);

        // Set the width to xScale times the default character
        // width. 
        _logicalFont.lfWidth  = 0;
        _logicalFont.lfHeight = height;

        // --------------------------------------------------
        // Create Font using the modified logicalFont struct.
        // --------------------------------------------------
        HFONT newerFont = NULL;
        newerFont = MyCreateFont(_logicalFont);
        Assert(newerFont && "Couldn't create font in RenderStaticTextOnDC");

        { // font2 scope
            
            ObjectSelector font2(dc, newerFont);
            Assert(font2.Success() && "Couldn't select font2 in RenderStaticTextOnDC");

            RECT destRect;

            Real res = GetResolution();
            
        #if 0
            if(IsCropped()) {

                // -- Compute accumulated bounding box  --
                Bbox2 box = DoBoundingBox(seedBox);

                // -- Figure out destination rectangle --
                // -- using resolution and box (which happens
                // -- to be the destination box) --
                DoDestRectScale(&destRect, res, box);

                // TraceTag((tagImageDeviceInformative, "%d %d  %d %d\n",
                // destRect.left, destRect.top, destRect.right, destRect.bottom));
            }
        #endif
            // Get size (in pixels) AFTER scale!
            GetTextExtentPoint32W(dc, c, len, &size);

            //
            // Calculate NEW positioning of object.  For now, do so just by
            // using the translation and scale component.
            //
            Point2 newOrigin = TransformPoint2(GetTransform(), Origin2);
            LONG x = Real2Pix(newOrigin.x, res);
            LONG y = Real2Pix(newOrigin.y, res);

            //
            // Map (x,y) from image to device coords
            //

            // for correct rotation, around center, we should offset
            // these coords by [ R*sin(t), R*cos(t) ]
            
            //Real xOff =  Real(size.cy) * 0.5  * sin(rot);
            //Real yOff =  Real(size.cy) * 0.5  * cos(rot);
            Real xOff =  0;
            Real yOff =  0;
            
            x = x +  (GetWidth()/2) + (LONG)(xOff);
            y = ( GetHeight()/2 - y ) + (LONG)(yOff);

            //
            // Set text alignment to be baseline center
            //
            TIME_GDI( SetTextAlign(dc, TA_BASELINE | TA_CENTER | TA_NOUPDATECP ) );

            // don't htink this is needed since the text is actually
            // pretransformed tot eh correct offset point when we get
            // here.  so this extra offset is not needed.
            #if 0
            // gotta find the surface from which we got the dc!
            // this is for propper offsetting.
            DDSurface *surf = NULL;
            if(IsCompositeDirectly()) {
                if( _viewport._externalTargetDDSurface ) {
                    HDC edc = _viewport._externalTargetDDSurface->GetDC("Couldn't get dc on externalTarg surf");
                    if(edc == dc) {
                        surf = _viewport._externalTargetDDSurface;
                    }
                    _viewport._externalTargetDDSurface->ReleaseDC("Couldn't relase dc on externalTarg surf");
                }
            }
            
            // COMPOSITE
            if(ShouldDoOffset(surf) && IsCompositeDirectly()) {
                x += _pixOffsetPt.x;
                y += _pixOffsetPt.y;
            }
            #endif
            
            #if 0    
            if(IsCropped()) {
                
                //DoCompositeOffset(surf, &destRect);
                
                TIME_GDI(ExtTextOutW(dc, x, y,
                                      ETO_CLIPPED,
                                      &destRect,
                                      c, lstrlenW(c), NULL));
            } else {
                TIME_GDI( TextOutW(dc, x, y, c, lstrlenW(c)) );
            }
            #endif
            TIME_GDI( TextOutW(dc, x, y, c, lstrlenW(c)) );
        } // font2 scope
    } // font1 scope

    SetTransform(oldXf);
}

// OLD TEXT CODE
void DirectDrawImageDevice::
RenderStaticText(TextCtx& textCtx, 
                 WideString str, 
                 Image *textImg,
                 DDSurface *targDDSurf,
                 DAGDI &myGDI)
{
    Bbox2 seedBox;

    //
    // Important to do this BEFORE we grab the DC, otherwise
    // we try to grab is twice since BoundinbBox also grabs it
    //
    if(IsCropped()) {
        seedBox = textImg->BoundingBox();
    }


    // XXXXXXXXXXXXXXXXXXXXXXXX
    // FIX TODO:  set interesint rect on target surface
    // XXXXXXXXXXXXXXXXXXXXXXXX
    
    DAColor dac( textCtx.GetColor(),
                 GetOpacity(),
                 _viewport.GetTargetDescriptor() );

    HFONT newFont=NULL;
    HFONT newerFont = NULL;

    // Just figure it out every frame.  optimize later.
    _viewport.MakeLogicalFont(textCtx, &_logicalFont);

    // Figure out scale factors
    Real xScale=1, yScale=1, rot=0;
    DecomposeMatrix(GetTransform(), &xScale, &yScale, &rot);

    //
    // Set state on DAGDI
    //
    myGDI.SetDDSurface( targDDSurf );
    RectRegion  rectClipRegion(NULL);
    LONG x=0,y=0;
    float xf=0.0,yf=0.0;
    WCHAR *c = str;
    int strLen = lstrlenW(c);
    RECT pixelTextBoundingRect;
    
    HDC surfaceDC = targDDSurf->GetDC("Couldn't get DC in RenderStringOnImage");
    { // dc scope
        
        // The existence of this releaser ensures that it will be released
        // when the scope is exited, be it by throwing an exception,
        // returning, or just normally exiting the scope.
        DCReleaser dcReleaser(targDDSurf, "Couldn't release DC in RenderStringOnImage");

        newFont = MyCreateFont(_logicalFont);
        Assert(newFont && "Couldn't create font in RenderStringOnImage");

        { // font1 scope
            ObjectSelector font1(surfaceDC, newFont);
            Assert(font1.Success() && "Coulnd't select font in RenderStringOnImage");

            //
            // OPTIMIZE: these need to be done once on
            // cached dcs
            //
            TIME_GDI( SetBkMode(surfaceDC, TRANSPARENT) );

            TIME_GDI( SetMapMode(surfaceDC, MM_TEXT) ); // Each logical unit = 1 pixel
            
            //
            // Get ave char width of font.
            //
            TEXTMETRIC textMetric;
            TIME_GDI( GetTextMetrics(surfaceDC, &textMetric) );
                
            SIZE size;
                
            #if 0
            // Get size (in pixels) BEFORE scale!
            GetTextExtentPoint32(surfaceDC, c, strLen, &size);
            #endif

            // Scale font the yScale times the default point size.
            // This formula for determining height comes from the
            // Win32 documentation of the LOGFONT structure.
            // Do rounding to the nearest integer when converting from float
            // to int.  It does truncation otherwise.
            LONG height =
                -MulDiv((int)(DEFAULT_TEXT_POINT_SIZE * yScale + 0.5),
                        GetDeviceCaps(surfaceDC, LOGPIXELSY),
                        72);

            // Set the width to xScale times the default character
            // width. 
            _logicalFont.lfWidth  = 0;
            _logicalFont.lfHeight = height;
                
            if(_logicalFont.lfHeight == 0) {
                // too small, unexpected results: user will get
                // default size...
                return;
            }
                
            // --------------------------------------------------
            // Create Font using the modified logicalFont struct.
            // --------------------------------------------------
            TIME_GDI( newerFont = MyCreateFont(_logicalFont) );
            Assert(newerFont && "Couldn't create font in RenderStringOnImage");

            { // font2 scope

                HGDIOBJ oldFont = NULL;
                TIME_GDI( oldFont = ::SelectObject(surfaceDC, newerFont) );

                Real res = GetResolution();
                
                if(IsCropped()) {
                        
                    // -- Compute accumulated bounding box  --
                    Bbox2 box = DoBoundingBox(seedBox);
                        
                    // -- Figure out destination rectangle --
                    // -- using resolution and box (which happens
                    // -- to be the destination box) --
                    RECT r;
                    DoDestRectScale(&r, res, box);
                    rectClipRegion.Intersect(&r);
                        
                    // TraceTag((tagImageDeviceInformative, "%d %d  %d %d\n",
                    // destRect.left, destRect.top, destRect.right, destRect.bottom));
                }
                    
                // Get size (in pixels) AFTER scale!
                TIME_GDI( GetTextExtentPoint32W(surfaceDC, c, strLen, &size) );

                //
                // Derive bounding rect on the surface
                //
                SetRect(&pixelTextBoundingRect,
                        -(size.cx+1) / 2,  // left
                        -size.cy,          // top: overestimate
                        (size.cx+1) / 2,   // right
                        size.cy);          // bottom: overestimate
                           
                //
                // Calculate NEW positioning of object.  For now, do so just by
                // using the translation and scale component.
                //

                Point2 newOrigin = TransformPoint2(GetTransform(), Origin2);
                
                if(myGDI.DoAntiAliasing()) {

                    xf = newOrigin.x * res;
                    yf = newOrigin.y * res;
                    xf = xf +  (GetWidth()/2);
                    yf = ( GetHeight()/2 - yf );
                    
                    // COMPOSITE
                    if(ShouldDoOffset(targDDSurf) && IsCompositeDirectly()) {
                        xf += (float)_pixOffsetPt.x;
                        yf += (float)_pixOffsetPt.y;
                    }

                    OffsetRect(&pixelTextBoundingRect, (DWORD)xf, (DWORD)yf);
                    
                } else {
                             
                    x = Real2Pix(newOrigin.x, res);
                    y = Real2Pix(newOrigin.y, res);

                    //
                    // Map (x,y) from image to device coords
                    //

                    // for correct rotation, around center, we should offset these coords
                    // by [ R*sin(t), R*cos(t) ]
                    //Real xOff =  Real(size.cy) * 0.5  * sin(rot);
                    //Real yOff =  Real(size.cy) * 0.5  * cos(rot);
                    Real xOff =  0;
                    Real yOff =  0;


                    x = x +  (GetWidth()/2) + (LONG)(xOff);
                    y = ( GetHeight()/2 - y ) + (LONG)(yOff);

                    // COMPOSITE
                    if(ShouldDoOffset(targDDSurf) && IsCompositeDirectly()) {
                        x += _pixOffsetPt.x;
                        y += _pixOffsetPt.y;
                    }

                    OffsetRect(&pixelTextBoundingRect, x, y);
                    
                }

                if(IsCropped()) {
                    DoCompositeOffset(targDDSurf, rectClipRegion.GetRectPtr());
                }

                TIME_GDI( ::SelectObject(surfaceDC, oldFont) );
            } // font2 scope
        } // font1 scope
    } // dc scope



    if( IsCompositeDirectly() &&
        targDDSurf == _viewport._targetPackage._targetDDSurf &&
        _viewport._targetPackage._prcClip ) {
            rectClipRegion.Intersect(_viewport._targetPackage._prcClip);
    }
    
    //
    // Set the final interesting rect on the surface
    //
    IntersectRect(&pixelTextBoundingRect,
                  &pixelTextBoundingRect,
                  rectClipRegion.GetRectPtr()); 
    targDDSurf->SetInterestingSurfRect( &pixelTextBoundingRect );

    DebugCode(
        if (IsTagEnabled(tagTextBoxes)) {
            DrawRect(targDDSurf,&pixelTextBoundingRect, 255, 10, 30);
        }
    );

    
    DAFont font( newerFont );
    SolidBrush brush( dac );
    myGDI.SetFont( &font );
    myGDI.SetBrush( &brush );
    myGDI.SetClipRegion(&rectClipRegion );
    myGDI.TextOut(x, y, xf, yf, c, strLen);
    myGDI.ClearState();

    if( newerFont ) {
        TIME_GDI( ::DeleteObject( newerFont ) );
    }
}

// OLD TEXT CODE

//-----------------------------------------------------
// D e r i v e   B b o x   ( T E X T )
//
// Figures out what the bounding box is on a given
// string & textctx.
//-----------------------------------------------------
const Bbox2 DirectDrawImageDevice::
DeriveStaticTextBbox(TextCtx& textCtx, WideString str)
{
    Bbox2 retBox = NullBbox2;

    // TODO: Deal with the remainder of the components described in
    // the current 2D transform on this device.  Specifically, scale,
    // rotate, and shear components.

    HFONT newFont=NULL;
    HFONT newerFont = NULL;

    // Just figure it out every frame.  optimize later.
    _viewport.MakeLogicalFont(textCtx, &_logicalFont);

    HDC surfaceDC = GetCompositingStack()->TargetDDSurface()->GetDC("Couldn't get DC in DeriveStaticTextBbox");

    int fontSize = textCtx.GetFontSize();
    Real scale = fontSize / DEFAULT_TEXT_POINT_SIZE;
    // This formula for determining height comes from the
    // Win32 documentation of the LOGFONT structure.
    LONG height =
        -MulDiv(fontSize,
                GetDeviceCaps(surfaceDC, LOGPIXELSY),
                72);
    _logicalFont.lfHeight = height;

    { // dc scope
        // The existence of this releaser ensures that it will be released
        // when the scope is exited, be it by throwing an exception,
        // returning, or just normally exiting the scope.
        DCReleaser dcReleaser(GetCompositingStack()->TargetDDSurface(), "Couldn't release DC in RenderStringOnImage");

        // TODO: grab font before DC and put in a ResourceGrabber.

        // This gets default font size
        newFont = MyCreateFont(_logicalFont);
        Assert(newFont && "Couldn't create font in DeriveStaticTextBbox");

        { // font1 scope
            ObjectSelector font1(surfaceDC, newFont);
            Assert(font1.Success() && "Couldn't select font in DeriveStaticTextBbox");

            // pixel coords = logical units
            TIME_GDI( SetMapMode(surfaceDC, MM_TEXT));
            
            SIZE size; int len = lstrlenW(str);
            TIME_GDI( GetTextExtentPoint32W(surfaceDC, str, len, &size));
            
            //TraceTag((tagImageDeviceInformative, "text<box>: \"%s\" is %d wide, %d high\n",str,size.cx,size.cy));

            // the fudge factor seems to be needed for correct left/right
            // boundaries for Bold text.
            Real fudge = 1.0;
            if(textCtx.GetBold()) {
                fudge = 1.1;
            }

            // convert to real coords
            Real res = GetResolution();
            Real l = (- (fudge * Real(size.cx+1) / (scale*2.0))) / res;
            Real r = (+ (fudge * Real(size.cx+1) / (scale*2.0))) / res;

            // BASELINE VERSION
            TEXTMETRIC textMetric;
            GetTextMetrics(surfaceDC, &textMetric);
            // top is dropped by the descent.  bottom is 0 - descent
            Real t = (+ Real(size.cy)) / (scale * res);
            Real b = (- Real(textMetric.tmDescent)) / res;

            // BOTTOM VERSION
            // top is dropped by the descent.  bottom is 0 - descent
            //Real t = (+ Real(size.cy)) / res;
            //Real b = (- Real(0.0)) / res;
            
            retBox.Set(l,b, r,t);
        } // font1 scope
    } // dc scope

    Assert((retBox != NullBbox2) && "retBox == NullBbox2 in DeriveStaticTextBbox");
    return retBox;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\aadev.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    AudioActive rendering device for MIDI Sounds

*******************************************************************************/

#include "headers.h"
#include <sys/types.h>
#include <sys/timeb.h>
#include <msimusic.h>
#include <stdio.h>
#include "privinc/aadev.h"
#include "privinc/mutex.h"
#include "privinc/util.h"
#include "privinc/storeobj.h"
#include "privinc/debug.h"
#include "privinc/except.h"
#include "privinc/helpaa.h"


AudioActiveDev::AudioActiveDev()
{
    _aactiveAvailable = FALSE;    // assume false in case we throw

    // Init the path list, it should be cleared (deleted and
    // recreated) before each render.  When a sound finish is
    // detected, it should push the path to this donePathList.
    donePathList = AVPathListCreate();

    TraceTag((tagSoundDevLife, "AudioActiveDev constructor"));

    // initialize these
    _aaEngine         =  NULL;  // hasn't been instantiated yet
    _aactiveAvailable =  TRUE;  // optimistic for later lazy setup
}


AudioActiveDev::~AudioActiveDev()
{
    TraceTag((tagSoundDevLife, "AudioActiveDev destructor"));

    if(donePathList)
        AVPathListDelete(donePathList);

    if(_aaEngine)
        delete _aaEngine;
}


void AudioActiveDev::BeginRendering()
{

    TraceTag((tagSoundRenders, "AudioActiveDev::BeginRendering()"));

#ifdef ONEDAY
    // Now clear the list, the sampler should be done with it.

    AVPathListDelete(donePathList);
    PushDynamicHeap(GetSystemHeap());
    donePathList = AVPathListCreate();
    PopDynamicHeap();
#endif
}


void AudioActiveDev::EndRendering()
{
    TraceTag((tagSoundRenders, "AudioActiveDev::EndRendering()"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\2dmatte.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#include "headers.h"

#include <privinc/dddevice.h>
#include <privinc/linei.h>
#include <privinc/path2i.h>
#include <privinc/DaGdi.h>
#include <privinc/linei.h>
#include <privinc/SurfaceManager.h>
#include <appelles/path2.h>
#include <privinc/gradimg.h>

typedef struct {
    Image *image;
    DirectDrawImageDevice *dev;
    DDSurface  *srcDDSurf;
    DDSurface  *destDDSurf;
    HDC dc;
    bool justDoPath;
} devCallBackCtx_t;


HDC GetDCForMatteCallback(void *ctx)
{
    //OutputDebugString("---> Callback <----\n");
    devCallBackCtx_t *devCtx = (devCallBackCtx_t *)ctx;

    if(!devCtx->dc)
        devCtx->dc = devCtx->dev->GetDCForMatteCallBack(devCtx->image,
                                                        devCtx->srcDDSurf,
                                                        devCtx->destDDSurf);
    
    return devCtx->dc;
}

HDC DirectDrawImageDevice::
GetDCForMatteCallBack(Image *image, DDSurface *srcDDSurf, DDSurface *destDDSurf)
{
    Assert(image && "image ptr NULL in GetDCForMatteCallBack");
    Assert(srcDDSurf && "srcDDSurf ptr NULL in GetDCForMatteCallBack");
    Assert(destDDSurf && "destDDSurf ptr NULL in GetDCForMatteCallBack");

    if (image->CheckImageTypeId(SOLIDCOLORIMAGE_VTYPEID)) {
        //
        // nothing to do really
        //

    } else {

        //
        // Blit image to scratch surface <if not trivial
        // image like dib or solid color> using src & dest
        // boxes.. just like any other image.  Use
        // surface of size of viewport.
        //

        //
        // we actually don't care if the color key is set or not..
        // so let's unset it to make sure no one is using it!
        //
        //srcDDSurf->UnSetColorKey();

        //
        // Render image
        //
        Image *xfImage = TransformImage( GetTransform(), image);

        RenderImageOnDDSurface( xfImage, srcDDSurf );
    }

    //
    // Grab and return the DC
    //
    return destDDSurf->GetDC("Couldn't get DC on destDDSurf in GetDCForMatteCallBack");
}


#define NO_MATTE 0

void DirectDrawImageDevice::
RenderMatteImage(MatteImage *matteImage,
                 Matte *matte,
                 Image *srcImage)
{
    if(! srcImage->IsRenderable()) {
        ResetAttributors();
        return;
    }

    DAGDI &myGDI = *(GetDaGdi());
    // TODO: we want to set antialiased on mattes but now there's no api
    
    SolidColorImageClass *solidPtr =
        srcImage->CheckImageTypeId(SOLIDCOLORIMAGE_VTYPEID)?
        SAFE_CAST(SolidColorImageClass *,srcImage):
        NULL;

    Path2 *pathBase = matte->IsPathRepresentableMatte();

    // If the image supports clipping, set the path, tell it to render
    // and return!
    if( pathBase ) {
        if( srcImage->CanClipNatively() ) {
            #if _DEBUG
            {
                Transform2 *x; Path2 *p;
                GetClippingPath(&p, &x);
                Assert( !p && !x );
            }
            #endif
            SetClippingPath( pathBase, GetTransform() );
            srcImage->Render(*this);
            SetClippingPath( NULL, NULL );
            return;
        }
    }
    
    //
    // figure out if we're doing aa clip & the matte is path
    // representable
    //
    bool doAAClip = false;
    bool doAASolid = false;

    if( pathBase ) {

        // check aa solids
        
        DWORD dwFlags =
            CRQUAL_AA_SOLIDS_ON |
            CRQUAL_AA_SOLIDS_OFF;
        
        bool bres = UseImageQualityFlags(
            dwFlags,
            CRQUAL_AA_SOLIDS_ON,
            false);
        
        myGDI.SetAntialiasing(bres);

        // check if myGDI thinks we can aa
        if( myGDI.DoAntiAliasing() ) {
            doAASolid = solidPtr ? true : false;
        }

        // Check aa clipping

        dwFlags =
            CRQUAL_AA_CLIP_ON |
            CRQUAL_AA_CLIP_OFF;
        
        bres = UseImageQualityFlags(
            dwFlags,
            CRQUAL_AA_CLIP_ON,
            false);
        
        myGDI.SetAntialiasing(bres);

        // check if myGDI thinks we can aa
        if( myGDI.DoAntiAliasing() ) {
            doAAClip = !solidPtr ? true : false;
            if( !GetDealtWithAttrib(ATTRIB_OPAC) ) {
                doAAClip = false;
            }
        }
        
        // reset everything for the following render
        myGDI.ClearState();
    }

    bool doAA = doAAClip || doAASolid;
    

    SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, true);
    SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, true);
    SetDealtWithAttrib(ATTRIB_CROP, true);

    if( doAASolid ) {
        SetDealtWithAttrib(ATTRIB_OPAC, true);
    }

    DDSurface *srcDDSurf = NULL;
    DDSurface *destDDSurf = GetCompositingStack()->TargetDDSurface();

    bool returnSrcSurf = false;
    bool doColorKey = false;

    
    // if there's an attributor set.. OR
    // if there's a color key on the src surface which
    // means that we need an extra color keyed blit after
    // the stretch blit (if any)

    bool bAllAttribTrue = AllAttributorsTrue() ? true : false ;
    if( !bAllAttribTrue || !solidPtr) {

        //
        // definitely Need scratch surface as src
        // Note: we try not to grab this guy too early
        // simply because it involves an expensive clear
        //
        srcDDSurf = GetCompositingStack()->ScratchDDSurface(
                doClear,
                _viewport.Width(),
                _viewport.Height());
            
        bool bValidClrKey = GetCompositingStack()->ScratchDDSurface()->ColorKeyIsValid();

        // if we're not doing aa clip, then look for reasons to get a
        // temp surface to blit to and then have to do a clr keyed
        // blit from.  
        if( (!bAllAttribTrue || bValidClrKey) &&
            !doAAClip ) {

            //
            // Ok, so now src and dest are both temp surfaces because
            // 1.> there's a remaining attributor that needs to be
            // dealt with
            // 2.> Or... we're going to do an extra blit at the end to
            // take care of color keyeing (stuff that shows THROUGH
            // the matte to whatever is below us)
            //

            // need to return extra surface...
            returnSrcSurf = true;

            //
            // Get a reference to a surface form the free pool as: srcDDSurf
            // xxx optimize: do we really want to clear this guy ?
            //
            GetCompositingStack()->GetSurfaceFromFreePool(&srcDDSurf,
                                                          doClear,
                                                          _viewport.Width(),
                                                          _viewport.Height(),
                                                          scratch);
            destDDSurf = GetCompositingStack()->ScratchDDSurface(
                doClear,
                _viewport.Width(),
                _viewport.Height());

            //
            // Ok, so we need to do a color keyed blit iff:
            // 1.> there's some color key on the src surface
            // 2.> all attributors have been taken care of...
            // 3.> the image isn't a solid color image..
            if(srcDDSurf->ColorKeyIsValid() &&
               bAllAttribTrue &&
               !solidPtr) {
                doColorKey = true;
            }
        }
    }

    //
    // This guy automatically returns the compositing surface
    // on unwinding of the stack, if it needs to be returned. note
    // that upon return the reference is also Released
    //
    CompositingSurfaceReturner goBack(GetCompositingStack(),
                                      srcDDSurf,
                                      returnSrcSurf);

    if (solidPtr) {

        int    numPts;
        POINT *gdiPts;
        Bool   isPolyline;
        
        // Check to see if we have Quality overrides
        DWORD dwFlags = CRQUAL_AA_SOLIDS_ON | CRQUAL_AA_SOLIDS_OFF | CRQUAL_AA_CLIP_ON | CRQUAL_AA_CLIP_OFF;
        bool bres = UseImageQualityFlags(dwFlags,
                                CRQUAL_AA_SOLIDS_ON | CRQUAL_AA_CLIP_ON, false);

        myGDI.SetAntialiasing(bres);

        // the client can tell us to render using a certain sample resolution
        if( GetSampleResolution() > 0 ) {
            myGDI.SetSampleResolution( GetSampleResolution() );
        }
        
        Transform2 *xfToUse = GetTransform();

        // COMPOSITE
        // if we're composite to targ, translate the points a bit.
        xfToUse = DoCompositeOffset( destDDSurf, xfToUse );
         
        // ONLY IF AA
        if(myGDI.DoAntiAliasing()) {
            myGDI.SetViewportSize(_viewport._width,_viewport._height );
            xfToUse = TimesTransform2Transform2(myGDI.GetSuperScaleTransform(), xfToUse);
        }

        Bool canDoSimpleRender = false;
        bool renderPathNatively = false;

        // OPTIMIZATION:  check to see if the matte is path based, and
        // if it is, if the path is natively renderable
        if( pathBase && pathBase->CanRenderNatively() ) {
            renderPathNatively = true;
        } else {
            canDoSimpleRender =
                matte->ExtractAsSingleContour(xfToUse,
                                              &numPts,
                                              &gdiPts,
                                              &isPolyline);
        }
        
        // Can only do simple filled renders on polylines, since the
        // PolyBezier GDI function only draws with the current pen,
        // but doesn't fill.
        if ( (canDoSimpleRender && isPolyline) ||
              renderPathNatively )
          {
              
              DAColor dac( solidPtr->GetColor(),
                           GetOpacity(),
                           _viewport.GetTargetDescriptor() );
              
              SolidBrush solidBrush( dac );
              RectRegion rectRegion(NULL);
              
              RECT clipRect;
              if( destDDSurf == _viewport._targetPackage._targetDDSurf ) {
                  if (_viewport._targetPackage._prcClip) {
                      IntersectRect(&clipRect,
                                    _viewport._targetPackage._prcViewport,
                                    _viewport._targetPackage._prcClip);
                  } else {
                      clipRect = *_viewport._targetPackage._prcViewport;
                  }
              } else {
                  clipRect = *(destDDSurf->GetSurfRect());
              }

              // If doing cropping, crop to the correct region.
              if (IsCropped()) {
                  
                  _boundingBox =
                      IntersectBbox2Bbox2(destDDSurf->Bbox(),
                                          DoBoundingBox(UniverseBbox2));
                  
                  if( !_boundingBox.IsValid() ) return;
                  
                  
                  // Note that since the image has already been
                  // transformed, we need only to get the rectangle in
                  // Win32 coords, a straight forward mapping with no
                  // transforms from the _boundingBox.  This is a COPY
                  // operation basicaly
                  RECT croppedRect;
                  DoDestRectScale(&croppedRect,
                                  destDDSurf->Resolution(),
                                  _boundingBox);
                  
                  // COMPOSITE
                  DoCompositeOffset(destDDSurf, &croppedRect);
                  IntersectRect(&croppedRect,
                                &clipRect,
                                &croppedRect);
                  
                  rectRegion.SetRect(&croppedRect);
                  // TEST: no test
                  
              } else {
                  
                  // TEST: mambo man example
                  rectRegion.SetRect(&clipRect);
                  
                  //TraceTag((tagError, "Matte uncropped fast path: Offset: (%d, %d)",  _pixOffsetPt.x, _pixOffsetPt.y));
              }
              
              myGDI.SetClipRegion(&rectRegion);
              myGDI.SetBrush(&solidBrush);
              
              myGDI.SetDDSurface(destDDSurf);
              
              // This is correct, but too risky for the cr1 release.
              //destDDSurf->UnionInterestingRect( rectRegion.GetRectPtr() );
              
              if( renderPathNatively ) {

                 #if NO_MATTE
                 ResetAttributors();
                 myGDI.ClearState();
                 return;
                 #endif
                  
                  pathBase->RenderToDaGdi(
                      &myGDI,
                      xfToUse,
                      _viewport.Width()/2,
                      _viewport.Height()/2,
                      GetResolution() );

              } else {
                  //
                  // Draw a filled polygon with a solid
                  // colored brush
                  //
                  PolygonRegion  polygonRegion(gdiPts, numPts);
                  myGDI.Polygon(&polygonRegion);
              }
              
              myGDI.ClearState();
              
              // compositing Surface is returned
              return;
        } else {
            myGDI.ClearState();
        }
    } // if solidPtr


    //
    // If there isn't a srcSurface selected, then grab a
    // scratch surface.
    //
    if(!srcDDSurf) srcDDSurf = GetCompositingStack()->ScratchDDSurface();

    devCallBackCtx_t devCtx;

    devCtx.image = srcImage;
    devCtx.dev = this;
    devCtx.dc = NULL;
    devCtx.srcDDSurf = srcDDSurf;
    devCtx.destDDSurf = destDDSurf;
    devCtx.justDoPath = doAAClip;

    HRGN region=NULL;  HRGN *pRgn = &region;
    if( doAA ) pRgn = NULL;

    Transform2 *xfToUse = GetTransform();
    if( doAAClip ) {
        //xfToUse = DoCompositeOffset(destDDSurf, xfToUse);
        DoCompositeOffset(destDDSurf, myGDI);
    }
  
    Bool needDC = matteImage->RenderWithCallBack(
        ::GetDCForMatteCallback,
        &devCtx,
        pRgn,
        xfToUse,
        doAA);

    //
    // Now that we've rendered, set up the DAGDI state properly
    //
    myGDI.SetAntialiasing(doAA);
    Assert( doAA ? myGDI.DoAntiAliasing() : !myGDI.DoAntiAliasing() );

    if(!devCtx.dc) {
        //
        // No DC allocated-->No work for us to do.
        //
        return;
    }

    HDC destDC = devCtx.dc;
    DCReleaser dcReleaser(destDDSurf, "Couldn't release DC on destDDSurf in RenderMatteImage");

    if(!needDC || !region) {

        if(!region && doAA) {
            // it's ok, continue
        } else {
            //
            // Don't need the DC, even though it's allocated.  goodbye.
            // or, region is null, that's not very helpful.
            //
            return;
        }
    }

    GDI_Deleter regionDeleter((HGDIOBJ)region);
    BOOL ret;

    if(solidPtr) {

        //
        // Special case SolidColorImage
        //

        DAColor dac( solidPtr->GetColor(),
                     GetOpacity(),
                     _viewport.GetTargetDescriptor() );

        SolidBrush solidBrush( dac );
        GdiRegion gdiRegion(region);

        RectRegion rectRegion(NULL);

        if(IsCropped() ||
            destDDSurf == _viewport._externalTargetDDSurface) {

            // XXX: universeBbox2 could be bounding box on region
            // instead.
            RECT croppedRect;
            if( IsCropped() ) {
                _boundingBox = DoBoundingBox(UniverseBbox2);
                if( !_boundingBox.IsValid() ) return;
                
                // Note that since the image has already been transformed, we need
                // only to get the rectangle in Win32 coords, a straight forward mapping
                // with no transforms from the _boundingBox.  This is a COPY operation
                // basicaly
                DoDestRectScale(&croppedRect, destDDSurf->Resolution(), _boundingBox);

                DoCompositeOffset( destDDSurf, &croppedRect );

            } else {
                croppedRect = *_viewport._targetPackage._prcViewport;
            }

            if( destDDSurf == _viewport._externalTargetDDSurface ) {
                if (_viewport._targetPackage._prcClip) {
                    IntersectRect(&croppedRect,
                                  &croppedRect,
                                  _viewport._targetPackage._prcClip);
                }
                IntersectRect(&croppedRect,
                              &croppedRect,
                              _viewport._targetPackage._prcViewport);
            }

            //
            // Offset the region we're to paint into...
            //
            DoCompositeOffset(destDDSurf, region); // todo: take a
                                                   // GDIRegion
                                                   // instead of HRGN

            //
            // Intersect cropping region with 'region'
            //
            RECT croppedRectGDI = croppedRect;
            if(_viewport.GetAlreadyOffset(destDDSurf))
            {
                // if we are already offset then we need to offset the 
                // crop aswell.
                DoCompositeOffset(destDDSurf, &croppedRectGDI);
            }
            gdiRegion.Intersect(&croppedRectGDI);

            // rect region for doAA
            rectRegion.Intersect( &croppedRect );
        } else {

            // COMPOSITE
            DoCompositeOffset(destDDSurf, region);
        }

        
        //TraceTag((tagError, " slow solid clr matte offset: (%d, %d)", _pixOffsetPt.x, _pixOffsetPt.y));       

        // Check to see if we have Quality overrides
        DWORD dwFlags = CRQUAL_AA_SOLIDS_ON | CRQUAL_AA_SOLIDS_OFF |
                        CRQUAL_AA_CLIP_ON | CRQUAL_AA_CLIP_OFF;
        bool bres = UseImageQualityFlags(
            dwFlags,
            CRQUAL_AA_SOLIDS_ON | CRQUAL_AA_CLIP_ON,
            false);
        
        myGDI.SetAntialiasing(bres);
        myGDI.SetDDSurface( destDDSurf );
        // This is correct, but too risky for the cr1 release.
        //destDDSurf->UnionInterestingRect( rectRegion.GetRectPtr() );
        myGDI.SetBrush( &solidBrush );

        // the client can tell us to render using a certain sample resolution
        if( GetSampleResolution() > 0 ) {
            myGDI.SetSampleResolution( GetSampleResolution() );
        }
        

        if( doAASolid ) {

            Assert( myGDI.DoAntiAliasing() );
            
            bool bReleasedDC = false;

            myGDI.SetClipRegion( &rectRegion );

            myGDI.SetSuperScaleMode( false );

            DoCompositeOffset( destDDSurf, myGDI );
            
            myGDI.StrokeOrFillPath_AAOnly( destDC, bReleasedDC );

            // don't want to release DC twice :)
            if(bReleasedDC) {
               dcReleaser._surf = NULL; // DC already released. 
            }

        } else {
            myGDI.FillRegion( destDC, &gdiRegion );
        }           
        myGDI.ClearState();

        
    } else {

        //
        // Regular Image: the accumulated image is waiting in 'srcDDSurf'
        //

        //
        // Derive src & dest bboxes
        //

        _boundingBox = IntersectBbox2Bbox2(destDDSurf->Bbox(),
                                           DoBoundingBox(srcImage->BoundingBox()));

        if( !_boundingBox.IsValid() ) return;

        // Note that since the image has already been transformed, we need
        // only to get the rectangle in Win32 coords, a straight forward mapping
        // with no transforms from the _boundingBox.  This is a COPY operation
        // basicaly
        RECT rect;
        DoDestRectScale(&rect, GetResolution(), _boundingBox);

        //
        // Select Clip Region into Destination DC
        //

        RECT destRect = rect;
        RECT srcRect = rect;

        // COMPOSITE
        DoCompositeOffset(destDDSurf, &destRect);

        // ----------------------------------------
        // if we're doing aa clip on this guy
        // ----------------------------------------
        if( doAAClip ) {
            RECT clipRect;
            POINT offsetPt = {0,0};
            if( destDDSurf == _viewport._targetPackage._targetDDSurf ) {
                if (_viewport._targetPackage._prcClip) {
                    IntersectRect(&clipRect,
                                  _viewport._targetPackage._prcViewport,
                                  _viewport._targetPackage._prcClip);
                } else {
                    clipRect = *_viewport._targetPackage._prcViewport;
                }
            } else {
                clipRect = *(destDDSurf->GetSurfRect());
            }

            if( ShouldDoOffset( destDDSurf ) ) {
                offsetPt = _pixOffsetPt;
            }
            
            bool releasedDC = false;
            _RenderMatteImageAAClip(myGDI,
                                    clipRect,
                                    destDC,
                                    destDDSurf,
                                    destRect,
                                    srcDDSurf,
                                    srcRect,
                                    releasedDC,
                                    offsetPt);

            destDDSurf->UnionInterestingRect( &destRect );

            // don't want to release dc twice
            if( releasedDC ) {
                dcReleaser._surf = NULL;
            }

            // TODO; it would be nice to return here and NOT do the
            // color keyed blit, but here's the problems:
            // 1.> we need to do a color keyed blit because the
            // underlying animated image we're clipping might have a
            // color key in it (in fact we think it does.  see
            // 'bValidClrKey'
            // 2.> we would rather NOT do a color keyed blit because
            // it's slower AND because the whole point of aa clipping
            // is that the edges will blend with the background.
            // hence a color keyed blit will be useless since the
            // edges have already blended with the cyan color key..
            //return;
        } else {
        
            // COMPOSITE
            DoCompositeOffset(destDDSurf, region);
            int err = SelectClipRgn(destDC, region);

            if(err == ERROR) {
                TraceTag((tagError, "SelectClipRgn failed in RenderMatteImage"));
                return;
            }

            //
            // Get Source DC
            //

            HDC srcDC;
            srcDC = srcDDSurf->GetDC("GetDC failed on srcDDSurf in RenderImageIntoRegion.");

            //
            // Blit from scratch surface into clipping region
            // on TargetSurface using Win32 GDI
            //
            
            //OutputDebugString("Matte: clipping regular image... \n");
            TIME_GDI(ret = StretchBlt(destDC,
                                      destRect.left,
                                      destRect.top,
                                      destRect.right - destRect.left,
                                      destRect.bottom - destRect.top,
                                      srcDC,
                                      srcRect.left,
                                      srcRect.top,
                                      srcRect.right - srcRect.left,
                                      srcRect.bottom - srcRect.top,
                                      SRCCOPY));

            err = SelectClipRgn(destDC, NULL);
            srcDDSurf->ReleaseDC("ReleaseDC faild on srcDDSurf in RenderImageIntoRegion.");

            destDDSurf->UnionInterestingRect( &destRect );
            
            #if _DEBUG
            if(!ret) {
                TraceTag((tagError,"StrecthBlt failed in RenderPolygonImage"));
            }
            if(err == ERROR) {
                TraceTag((tagError, "SelectClipRgn NULL failed in RenderMatteImage"));
            }
            #endif

        }
        
        if(doColorKey) {
            // force release of the dc because following blit will
            // try to lock surface and fail if we don't.
            // this operation is idempotent so poping the dcReleaser
            // off the stack won't RErelease the dc.
            dcReleaser.Release();

            // using a clrkeyed blit, drop the bits from destDDSurf
            // into targetDDSurf.
            srcDDSurf = destDDSurf;
            destDDSurf = GetCompositingStack()->TargetDDSurface();

            RECT *srcRect = srcDDSurf->GetSurfRect();
            RECT destRect = *srcRect;

            // COMPOSITE
            DoCompositeOffset(destDDSurf, &destRect);

            // OPTIMIZE (this one is a biggie): use interestingRect
            // for the compositing...

            //OutputDebugString("Matte: ...and doing color keyed compose \n");
            _viewport.ColorKeyedCompose(destDDSurf,
                                        &destRect,
                                        srcDDSurf,
                                        srcRect, 
                                        _viewport._defaultColorKey);

            // NOTE: The below code will want to be added to support the Quality interface
            // when the time comes.....
            //  bool bres = UseImageQualityFlags(CRQUAL_AA_SOLIDS_ON | CRQUAL_AA_SOLIDS_OFF | CRQUAL_AA_CLIP_ON | CRQUAL_AA_CLIP_OFF,
            //                    CRQUAL_AA_SOLIDS_ON | CRQUAL_AA_CLIP_ON, false);
            //  myGDI.SetAntialiasing(bres);                                        
        }
    }
} 


void DirectDrawImageDevice::
_RenderMatteImageAAClip(DAGDI &myGDI,
                        RECT &clipRect,
                        HDC destDC,
                        DDSurface *destDDSurf,
                        RECT &destRect,
                        DDSurface *srcDDSurf,
                        RECT &srcRect,
                        bool &releasedDC,
                        const POINT &offsetPt)
{
    Assert( myGDI.DoAntiAliasing() );

    // set a brush using ddsurface

    TextureBrush textureBrush( *srcDDSurf, offsetPt.x, offsetPt.y );
    RectRegion clipRegion( &clipRect );

    myGDI.SetDDSurface( destDDSurf );
    myGDI.SetClipRegion( &clipRegion );
    myGDI.SetBrush( &textureBrush );

    // turn off super scale here.  it buys us nothing and it's hard to
    // get the paths under the matte to scale themselves up for us...
    myGDI.SetSuperScaleMode( false );
    
    myGDI.StrokeOrFillPath_AAOnly(destDC, releasedDC);

    myGDI.ClearState();
}


void DirectDrawImageDevice::
DoCompositeOffset(DDSurface *surf, DAGDI &myGDI)
{
    if(ShouldDoOffset(surf)) {
        Assert(IsCompositeDirectly());
        myGDI.SetOffset( _pixOffsetPt );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\bufferl.cpp ===
/*******************************************************************************

Copyright (c) 1997 Microsoft Corporation

Abstract: BufferList code to manage sound value's information on the device

*******************************************************************************/
#include "headers.h"
#include "privinc/debug.h"
#include "privinc/bufferl.h"

BufferElement::BufferElement()
{
    Init();
}

void
BufferElement::Init()
{
    _playing       = false;
    _valid         = true;
    _marked        = false;
    
    _threaded      = false;
    _captiveFile   = NULL;
    
    _syncStart     = false;
    _kill          = false;
    
    _intendToMute  = false;

    _age           = 0;
}

BufferElement::~BufferElement()
{
    TraceTag((tagSoundReaper1, "BufferElement::~BufferElement (0x%08X)", this));
}

SynthBufferElement::SynthBufferElement(DSstreamingBuffer *sbuffer,
                                       DirectSoundProxy *dsProxy,
                                       double sf,
                                       double offset,
                                       int sampleRate)
: _sinFrequency(sf), 
  _value(offset), // sin waves start at zero unles phased...
  _delta(2.0 * pi * sf / sampleRate),
  DSstreamingBufferElement(sbuffer, dsProxy)
{
}

QuartzBufferElement::~QuartzBufferElement()
{
    extern Mutex avModeMutex;
    MutexGrabber mg(avModeMutex, TRUE); // Grab mutex

    QuartzBufferElement::FreeAudioReader();
} // mutex grabber


void
QuartzBufferElement::FreeAudioReader()
{
    if(_quartzAudioReader) { // release our hold on reader
        // lets null the member b4 freeing
        QuartzAudioReader *quartzAudioReader = _quartzAudioReader;
        _quartzAudioReader = NULL;
         //TraceTag((tagError, "QuartzBufferElement::FreeAudioReader() freeing %x !!", _quartzAudioReader));
        quartzAudioReader->QuartzAudioReader::Release();
        quartzAudioReader->Release();  // attempt to make object go away
    }
}


void
QuartzVideoBufferElement::FreeVideoReader()
{
    if(_quartzVideoReader) { // release our hold on reader
        //TraceTag((tagError, "QuartzBufferElement::FreeAudioReader() freeing %x !!", _quartzAudioReader));
        _quartzVideoReader->QuartzVideoReader::Release();
        _quartzVideoReader->Release();  // attempt to make object go away
        _quartzVideoReader = NULL;
    }
}


QuartzVideoReader *
QuartzVideoBufferElement::FallbackVideo(bool seekable, DDSurface *surface)
{
    Assert(_quartzVideoReader);

    // fallback by cloaning a new one
    char *url = _quartzVideoReader->GetURL(); // get the media url

    QuartzVideoStream *newVideoStream = 
        NEW QuartzVideoStream(url, surface, seekable);

    // XXX determine where we were then seek new stream to correct location...

    // release the present stream
    _quartzVideoReader->QuartzVideoReader::Release();
    _quartzVideoReader->Release();  // with the option of releasing the whole av

    _quartzVideoReader = newVideoStream; 

    return(newVideoStream);
}

void
QuartzVideoBufferElement::FirstTimeSeek(double time)
{
    if (!_started) {
        _started = true;
        _quartzVideoReader->Seek(time);
    }
}

QuartzVideoBufferElement::~QuartzVideoBufferElement()
{
    QuartzVideoBufferElement::FreeVideoReader();
}


void
QuartzBufferElement::SetAudioReader(QuartzAudioReader *quartzAudioReader)
{
    Assert(!_quartzAudioReader); // this should already be nulled!
    
    //TraceTag((tagError, "QuartzBufferElement::SetAudioReader() setting to %x", quartzAudioReader));

    _quartzAudioReader = quartzAudioReader;
}


QuartzAudioReader *
QuartzBufferElement::FallbackAudio()
{
    char *url = _quartzAudioReader->GetURL();
    long frameNumber = _quartzAudioReader->GetNextFrame(); // frame we left off

    // XXX: Potential leak.  Make sure that this can be freed later if we
    // drop the reference.
    //FreeAudioReader(); // free the old audio reader

    _quartzAudioReader = NEW QuartzAudioStream(url); // create new audio reader

    //TraceTag((tagError, "QuartzBufferElement::FallbackAudio() new reader %x !!", _quartzAudioReader));

    // seek the new stream to where we left off on the old stream
    _quartzAudioReader->SeekFrames(frameNumber);

    return(_quartzAudioReader);
}

void
DSbufferElement::SetDSproxy(DirectSoundProxy *dsProxy)
{
    Assert(!_dsProxy); // this should only be set once!
    _dsProxy = dsProxy;
}


DSbufferElement::~DSbufferElement()
{
    TraceTag((tagSoundReaper1, "DSbufferElement::~BufferElement (0x%08X)", 
        this));

    if(_dsProxy)
        delete _dsProxy;
}

DSstreamingBufferElement::~DSstreamingBufferElement() 
{
    if(_dsBuffer) {
        delete _dsBuffer; 
        _dsBuffer = NULL;
    }
}

void
DSstreamingBufferElement::SetParams(double rate, bool doSeek, 
                                    double seek, bool loop)
{
    _rate = rate;
    _loop = loop;

    // these should only get set, they get cleared by RenderSamples
    if(doSeek) {
        _seek   = seek;
        _doSeek = doSeek; // must be set AFTER seek has been written!
    }
}


CComPtr<IStream> BufferElement::RemoveFile()
{
    CComPtr<IStream> tmpFile = _captiveFile;
    _captiveFile = NULL; // free our revcount...
    return(tmpFile);
}


void
SoundBufferCache::FlushCache(bool grab)
{
    CritSectGrabber mg(_soundListMutex, grab); // Grab mutex

    // destroy each BufferList on the cache!
    for(SoundList::iterator index = _sounds.begin();
        index != _sounds.end();
        index++) {
        Assert((*index).second);
        delete((*index).second); // destroy BufferList!
    }

    // now remove every BufferList on the cache
    _sounds.erase(_sounds.begin(), _sounds.end());
} // end mutex scope


SoundBufferCache::~SoundBufferCache()
{
    TraceTag((tagSoundReaper2, "~SoundBufferCache"));
    FlushCache(false);
}


void 
SoundBufferCache::AddBuffer(AxAValueObj *value, BufferElement *element)
{
    TraceTag((tagSoundReaper2, "SoundBufferCache::AddBuffer value=0x%08X",
        value));

    CritSectGrabber mg(_soundListMutex); // Grab mutex
    _sounds[value] = element;
}   // end mutex scope


void SoundBufferCache::DeleteBuffer(AxAValueObj *value)
{
    TraceTag((tagSoundReaper2, "~SoundBufferCache::DeleteBuffer 0x%08X", value));

    CritSectGrabber mg(_soundListMutex); // Grab mutex

    SoundList::iterator index = _sounds.find(value);

    if(index != _sounds.end()) { // ok for bufferlist not to be found
        BufferElement *bufferElement = (*index).second;
        if(bufferElement) {
            delete bufferElement;
            (*index).second = NULL;
        }
        _sounds.erase(index);
    }
    else {
        Assert(TRUE); // just something to set a breakpoint on...
    }
} // end mutex scope


BufferElement *
SoundBufferCache::GetBuffer(AxAValueObj *value) 
{
    CritSectGrabber mg(_soundListMutex); // Grab mutex

    BufferElement *bufferElement = (BufferElement *)NULL;  // assume not found

    SoundList::iterator index = _sounds.find(value);
    if(index != _sounds.end())
        bufferElement = (*index).second;  // found it!

    return(bufferElement);
} // end mutex scope


void SoundBufferCache::RemoveBuffer(AxAValueObj *value)
{
    TraceTag((tagSoundReaper2, "SoundBufferCache::RemoveBuffer(val=0x%08X)", 
        value));

    CritSectGrabber mg(_soundListMutex); // Grab mutex

#if _DEBUG
    if(IsTagEnabled(tagSoundReaper2)) {
        OutputDebugString(("sound cache before:\n"));
        PrintCache();
    }
#endif

    SoundList::iterator index = _sounds.find(value);
    if(index != _sounds.end()) // ok for bufferlist not to be found
        _sounds.erase(index);
    else
        Assert(TRUE);

#if _DEBUG
    if(IsTagEnabled(tagSoundReaper2)) {
        OutputDebugString(("\n sound cache after:\n"));
        PrintCache();
    }
#endif
} // end mutex scope


void SoundBufferCache::ReapElderly()
{

    CritSectGrabber mg(_soundListMutex); // Grab mutex

#if _DEBUG
    if(IsTagEnabled(tagSoundReaper2)) {
        OutputDebugString(("sound cache before reaper:\n"));
        PrintCache();
    }
#endif

    bool found = false;
    SoundList::iterator index;
    for(index = _sounds.begin(); index != _sounds.end(); index++) {
        BufferElement *bufferElement = 
            (*index).second;
            //SAFE_CAST(BufferElement *, (*index).second);

        if(bufferElement->IncrementAge()) {
            bufferElement->_marked = true; // manditory retirement!
            found = true;

            TraceTag((tagSoundReaper2, "Reaping(BE=0x%08X)", index));
        }
    }
    if(found) {
        // this moves all matching elements to the end of the structure

        // XXX FIX THIS!!
        //index = std::remove_if(_sounds.begin(), _sounds.end(), CleanupBuffer());

        _sounds.erase(index, _sounds.end()); // this deletes them!
    }
} // end mutex scope



#if _DEBUG
void SoundBufferCache::PrintCache()
{
    int count = 0;
    char string[400];

    CritSectGrabber mg(_soundListMutex); // Grab mutex

    for(SoundList::iterator index = _sounds.begin();
        index != _sounds.end();
        index++) {
        wsprintf(string, "%d: value=0x%08X buffer=0x%08X\n", 
            count++, (*index).first, 
            (const char *)((*index).second) );
        OutputDebugString(string);
    }
} // end mutex scope
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\colorkeyedimage_render.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

*******************************************************************************/

#include "headers.h"
#include <privinc/dddevice.h>
#include <privinc/ColorKeyedImage.h>


void DirectDrawImageDevice::
RenderColorKeyedImage( ColorKeyedImage *image )
{
    // sohail doesn't like this.  will accept bad results
    #if 0
    //
    // Detect alpha or aa anywhere in the underlying image.  Raise a
    // UserError
    //
    if( image->GetFlags() & IMGFLAG_CONTAINS_OPACITY ) {
        RaiseException_UserError(E_INVALIDARG, IDS_ERR_IMG_OPACITY_IN_COLORKEYEDIMAGE);
    }
    #endif
    
    // can do simple xform and crop ONLY.  but neither if complex is around

    //
    // Fill a temp surface with the color key.
    // OPTIMIZE: fill only the part you need post clipping...
    //
    DWORD dwClrKey;
    dwClrKey = _viewport.MapColorToDWORD( image->GetColorKey() );
    
    DDSurface *intermediateDDSurf;
    GetCompositingStack()->GetSurfaceFromFreePool( &intermediateDDSurf, dontClear );

    bool ownRef = true;
    CompositingSurfaceReturner goBack(GetCompositingStack(),
                                      intermediateDDSurf,
                                      ownRef);
    
    _viewport.ClearDDSurfaceDefaultAndSetColorKey( intermediateDDSurf, dwClrKey );
    
    //
    // Render the Image on the surface.  Make sure to do all this post
    // xform & clipping.
    //
    bool inheritContext = true;
    {
        ////////////////////// push opacity state //////////////////
        
        Real curOpac = GetOpacity();
        SetOpacity(1.0);
        BOOL opDealt = GetDealtWithAttrib(ATTRIB_OPAC);
        SetDealtWithAttrib(ATTRIB_OPAC, TRUE);

        DirectDrawImageDevice *dev;

        //
        // Render
        //
        RenderImageOnDDSurface( image->GetUnderlyingImage(),
                                intermediateDDSurf,
                                1.0, FALSE,
                                inheritContext,
                                &dev );

        Assert(dev);
        
        SetOpacity(curOpac);

        // Inherit back the attributors that were finished.
        InheritAttributorStateArray( dev );

        // restore the opacity attrib since we took it away to start
        // with and the underlying image never had a chance to deal
        // with it and opacity in the underlying image is not
        // supported <see exception above>
        SetDealtWithAttrib(ATTRIB_OPAC, opDealt);
    }
    
    //
    // Ok, now the underlying image is rendered on a colored temp
    // surface with background = clrKey.
    // Compose this surface on the target.
    //

    DDSurface *targDDSurf = NewSurfaceHelper();

    // to display rendered surface
    //showme( intermediateDDSurf );

    RECT destRect = *(intermediateDDSurf->GetSurfRect());
    DoCompositeOffset( targDDSurf, &destRect );
    
    RECT *srcRect = intermediateDDSurf->GetSurfRect();

    // Could be faster if we use interesting rect...
    _viewport.ColorKeyedCompose( targDDSurf, &destRect, 
                                 intermediateDDSurf, srcRect,
                                 intermediateDDSurf->ColorKey() );

    // Union interesting rect on the targDDSurf
    targDDSurf->UnionInterestingRect( intermediateDDSurf->GetInterestingSurfRect() );

    // surface is returned when SurfaceReturner is popped off
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\bground.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Class which manages background thread in which to perform streaming
    rendering.

*******************************************************************************/
#include "headers.h"
#include "privinc/debug.h"
#include "privinc/dsdev.h"
#include "privinc/htimer.h"
#include "privinc/mutex.h"
#include "privinc/server.h"
#include "privinc/bufferl.h"

typedef SynthListElement *SLEptr;
class DeleteSLbuffer {
  public:
    bool operator()(SLEptr p);
};

// XXX {Delete,Cleanup}SLbuffer should be the same routine w/an argument
//     but it is late...
bool DeleteSLbuffer::operator()(SLEptr p)
{
    bool status = false;    // default to not found

    if(p && (p->_marked)) { // A Marked Man! (delete him)
        delete p;           // delete the bufferElement
        p = NULL;           // just to be safe
        status = true;      // cause the map entry to be moved for removal
    }

    return status;
}


class CleanupSLbuffer {
  public:
    bool operator()(SLEptr p) {
        return (p->_marked);
    }
};

void renderSoundsHelper()
{
    SynthListElement *synth;
    vector<SynthListElement *>::iterator index;
    bool death; // set it we find a dead sound needing cleanup

    // mutex scope
    MutexGrabber mg(*BackGround::_synthListLock, TRUE); // Grab mutex
    vector<SynthListElement *> &synthList = *BackGround::_synthList;

    death = false; // assume we won't find dead sounds
    index = synthList.begin();

    while(index!= synthList.end()) {
        synth = *index++;

        if((synth->_sound) && (synth->_bufferElement->_playing)) {
                
            if(!synth->_bufferElement->GetKillFlag()) {

                synth->_bufferElement->RenderSamples();
            }
            else { // the buffer is marked for deletion!
                synth->_marked = true; // mark it as dead...
                death = true;
            }
        }
    } 

    if(death) { // now remove any dead sounds from synthList!
        //static vector<SynthListElement *> dirgeList;
        vector<SynthListElement *>::iterator index;

        /*
        // first move all marked elements to a dirge list
        // (so they won't be found on the actual synth list if 
        //  the destructors try to access the synth list)
        for(index= synthList.begin(); 
            index != synthList.end(); index++) {
            if((*index)->_marked)
                dirgeList.push_back(*index); // cp marked synth ptr
        }
        */
        
        // second move the marked elements to the end of the synth list
        // (NOT deleting the contents)
        index = std::remove_if(synthList.begin(), synthList.end(), 
                               DeleteSLbuffer());

        // third remove the containers from the synth list
        synthList.erase(index, synthList.end()); // now remove nodes!

        /*
        // now we can safely remove the contents of the dirge list
        // w/o the destuctors finding themselves on the synth list!
        index = std::remove_if(dirgeList.begin(), dirgeList.end(), 
                               DeleteSLbuffer());

        // then finaly remove the husks from the dirge list
        dirgeList.erase(index, dirgeList.end()); // now remove nodes!
        */
    }

    // mutex auto release
}

// this is the fn() which is the embodiment of the background thread!
LPTHREAD_START_ROUTINE renderSounds(void *)
{
    double startTime;           // time we start bursting one cycle of sound
    double endTime;             // time we finished burtsing one cycle of sound
    double timeUntilNextTime;   // how long until we need to begin next cycle
    double nextTime;            // time we want to wake up to begin next cycle
    double epsilonTime = 0.001; // time not worth going to sleep over (XXX tune)
    double latensy = 0.5;       // 500ms!
    DWORD  sleepTime;           // time we are going to sleep in ms
    // hires timer object
    HiresTimer&  timer = CreateHiresTimer();          
    LARGE_INTEGER tmpTime;

    CoInitialize(NULL); // needed on each thread to be able to cocreate...


    // make this a hi-priority thread
    BOOL status = 
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);


    // XXX should be able to block on a semiphore if there is nothing todo

    while(!BackGround::_done) {
        // determine when we woke up and compare that to when we intended to!
        QueryPerformanceCounter(&tmpTime);
        startTime = timer.GetTime();
            
        __try { 
            renderSoundsHelper();  // does the work...
        } 
        __except ( HANDLE_ANY_DA_EXCEPTION ) {
            ReportErrorHelper(DAGetLastError(), DAGetLastErrorString());
        }

        QueryPerformanceCounter(&tmpTime); // time after traversing list
        endTime = timer.GetTime();

        // determine how long to sleep (so we wake up < latensy)
        timeUntilNextTime = 0.25*latensy - (endTime-startTime);

        // can't wait negative time, not worth Sleeping for very small time!
        if(timeUntilNextTime >= epsilonTime) {
            nextTime = endTime + timeUntilNextTime; // time intend to wake up
            sleepTime = (DWORD)(timeUntilNextTime * 1000.0);
            Sleep(sleepTime); // wish we could block waiting for low-water!
        }
        else
            nextTime = endTime;
    }

    CoUninitialize();
    delete &timer;
    TraceTag((tagSoundReaper2, "renderSounds EXITING"));

    SetEvent(BackGround::_terminationHandle);

    return(0);
}


SynthListElement::SynthListElement(LeafSound * snd,
                                   DSstreamingBufferElement *buf)
: _marked(false), _sound(snd), _bufferElement(buf)
{
}


SynthListElement::~SynthListElement()
{
    if(_bufferElement) {
        _bufferElement->GetStreamingBuffer()->stop(); // stop immediately!

        delete _bufferElement;
        _bufferElement = NULL;
    }

    GCRemoveFromRoots(_sound, GetCurrentGCRoots());
}


Mutex    *BackGround::_synthListLock;
vector<SynthListElement *> *BackGround::_synthList = NULL;
CritSect *BackGround::_cs = NULL;
bool      BackGround::_done = false;
HANDLE    BackGround::_terminationHandle = NULL;
HANDLE    BackGround::_threadHandle      = NULL;
DWORD     BackGround::_threadID          = 0;

void 
BackGround::Configure()
{
    _synthListLock = NEW Mutex;
    _cs            = NEW CritSect;
    _synthList     = NEW vector<SynthListElement *>;
}


void 
BackGround::UnConfigure()
{
    ShutdownThread();
    delete _synthList;
    delete _cs;
    delete _synthListLock;
}


bool 
BackGround::CreateThread()
{
    CritSectGrabber _cs(* BackGround::_cs);

    if(_threadID)
        return true;

    if(!(_terminationHandle = CreateEvent(NULL, TRUE, FALSE, NULL)))
        return false;

    TraceTag((tagSoundDebug, "BackGround instantiated"));
    if(!(_threadHandle = ::CreateThread(NULL, 0,
                                      (LPTHREAD_START_ROUTINE)renderSounds,
                                      0,
                                      0,
                                      &_threadID))) {

         CloseHandle(_terminationHandle);
         _terminationHandle = NULL;
         return false;
    }
    return true;
}


void
BackGround::ShutdownThread()
{
    TraceTag((tagSoundReaper2, "BackGround::ShutdownThread STARTED"));
    if(_threadID) {
        // set done=1, wait for the thread to die, if timeout, then kill thread!
        TraceTag((tagSoundReaper2, "~BufferList POISONING thread"));
        _done = true;    // tell the thread to kill itself

        DWORD dwRes;
        HANDLE h[] = { _threadHandle, _terminationHandle };

        dwRes = 
            WaitForMultipleObjects(2,h,FALSE,THREAD_TERMINATION_TIMEOUT_MS);

        if(dwRes == WAIT_TIMEOUT) {
            TraceTag((tagError,
                      "Background thread not dying, using more force"));

            ::TerminateThread(_threadHandle, -1);
        }
        CloseHandle(_terminationHandle);
        CloseHandle(_threadHandle);
        _threadID = 0;
    }
    TraceTag((tagSoundReaper2, "BackGround::ShutdownThread COMPLETE"));
}


void
BackGround::AddSound(LeafSound       *sound,
                     MetaSoundDevice *metaDev,
                     DSstreamingBufferElement   *bufferElement)
{
    Assert(bufferElement && metaDev && sound);
    
    bufferElement->SetThreaded(true); // make it a threaded sound
    SynthListElement *element =
        NEW SynthListElement(sound, bufferElement);

    element->_devKey        = (ULONG_PTR)metaDev;

    GCAddToRoots(sound, GetCurrentGCRoots());

    { // mutex scope
        // grab lock (released when we leave scope)
        // XXX the default 2nd param broken?
        MutexGrabber mg(*_synthListLock, TRUE);  

        _synthList->push_back(element);
    } // release mutex as we leave scope

    TraceTag((tagSoundDebug, "BackGround::AddSound"));
}

void
BackGround::RemoveSounds(unsigned devKey)
{ // remove all sounds matching this key from the database
    vector<SynthListElement *>::iterator index;
    MutexGrabber mg(*_synthListLock, TRUE);  // grab lock

    for(index = _synthList->begin(); index!=_synthList->end(); index++) {
        if((*index)->_devKey==devKey)
            (*index)->_marked = true;
    }

    // move marked elements to the end of list and delete contents
    index = std::remove_if(_synthList->begin(), _synthList->end(), 
                           DeleteSLbuffer());
    _synthList->erase(index, _synthList->end()); // now remove nodes!
}

void
BackGround::SetParams(DSstreamingBufferElement *bufferElement,
                      double rate, bool doSeek, double seek, bool loop)
{
    // mutex scope
    MutexGrabber mg(*BackGround::_synthListLock, TRUE); // Grab mutex

    bufferElement->SetParams(rate, doSeek, seek, loop);
}

void
InitializeModule_bground()
{
    BackGround::Configure();
}


void
DeinitializeModule_bground(bool bShutdown)
{
    BackGround::UnConfigure();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\dagdi.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Delegates calls to Dx2D or GDI

*******************************************************************************/

#include  "headers.h"
#include  <privinc/ddsurf.h>
#include  <privinc/dddevice.h>
#include  <privinc/viewport.h>
#include  <privinc/DaGdi.h>
#include  <dxtrans.h>
#include  <dxvector.h>
#include  <dxbounds.h>

#if _DEBUG

// Don't make const for change-ability in the debugger
static int g_AliasedSampleResolution=2;

#else

static const int g_AliasedSampleResolution=2;

#endif


#define initScale 32;
//#define initScale 1;


// forwards
DXSAMPLE MapColorToDXSAMPLE(Color *c, Real opac);
//COLORREF MapColorToCOLORREF( Color *c, TargetDescriptor &td );

// --------------------------------------------------
// DACOLOR
// --------------------------------------------------
DAColor::DAColor( Color *c, Real opacity, TargetDescriptor &td )
{
    _dxSample = MapColorToDXSAMPLE(c, opacity);
    _colorRef = RGB( _dxSample.Red, _dxSample.Green, _dxSample.Blue );
// maybe later if needed
//    _colorRef = MapColorToCOLORREF(c, td);
}



// --------------------------------------------------
// DAGDI
// --------------------------------------------------
DAGDI::DAGDI(DirectDrawViewport *vp)
{
    _hr = 0;
    _emptyGdiPen = NULL;
    _bReleasedDC = false;
    _width=_height = 0;
    _sampleResolution = 4;
    _viewport = vp;

    _pixelWidth = _pixelHeight = 0;
    _resolution = -1;
    _n2g = NULL;

    ZeroMemory( &_dxpen, sizeof(DXPEN) );
    
    ClearState();
}

DAGDI::~DAGDI()
{
}

void DAGDI::
ClearState()
{
    _pen=NULL;
    _font=NULL;
    _brush=NULL;
    _clipRegion=NULL;
    _antialiased=false;
    _scaleOn = true;
    _doOffset = false;
    _pixOffset.x = _pixOffset.y = 0;
    _scaleFactor = initScale;
    SetSampleResolution( 4 );
    SetDDSurface( NULL );
}
    
void DAGDI::
SetOffset( POINT &pt )
{
    _doOffset = true;
    _pixOffset = pt;
}

int
DAGDI::GetAdjustedResolution()
{
    int resolution;
    
    if (DoAntiAliasing())
        resolution = GetSampleResolution();
    else
        resolution = g_AliasedSampleResolution;

    return resolution;
}

void DAGDI::
SetDx2d( IDX2D *dx2d, IDXSurfaceFactory *sf)
{
    if (_dx2d != dx2d) {

        // Release (and set to null) the surfaces we believe are
        // cached.  We need to do this so in case there's a a changed
        // Dx2D object, we don't falsely use this cached stuff meant
        // for another Dx2D object.
        _previouslySetIDirectDrawSurface.Release();
        _previouslySetDXSurface.Release();
        
    }
    
    _dx2d = dx2d;
    _IDXSurfaceFactory = sf;
}
    

void DAGDI::
GenericLine(HDC dc,
            PolygonRegion *outline,
            whatStyle_enum whatStyle)
{
    if(DoAntiAliasing()) {
        _GenericLine_Dx2d(dc, outline, whatStyle);
    } else {
        _GenericLine_Gdi(dc, outline, whatStyle);
    }
}

void DAGDI::
TextOut(int x, int y, float xf, float yf, WCHAR *str, ULONG strlen)
{
    if(DoAntiAliasing()) {
        _TextOut_Dx2d(xf, yf, str, strlen);
    } else {
        HDC hdc = _GetDC();        
        _TextOut_Gdi(hdc, x, y, str, strlen);
        _ReleaseDC();
    }
}

void
DAGDI::SetSurfaceFromDDSurf(DDSurface *ddsurf)
{
    DAComPtr<IDXSurface> setSurf;
    HRESULT hr;

    TIME_DX2D( hr = GetDx2d()->GetSurface(IID_IDXSurface, (void **)&setSurf) );

    Assert(ddsurf->IDDSurface() ||
           ddsurf->HasIDXSurface()); // be sure it's not, for example, an HDC

    if (FAILED(hr) || (ddsurf->IDDSurface() !=
                          _previouslySetIDirectDrawSurface) ||
        
                      (setSurf != _previouslySetDXSurface)) {

        _previouslySetDXSurface.Release();
        if( ddsurf->HasIDXSurface() ) {
            _previouslySetDXSurface = ddsurf->GetIDXSurface( _IDXSurfaceFactory );
        } else {
            CreateFromDDSurface( _IDXSurfaceFactory,
                                 ddsurf,
                                 NULL,
                                 &_previouslySetDXSurface );
        }

        TIME_DX2D( hr = GetDx2d()->SetSurface( _previouslySetDXSurface ) );
        Assert(SUCCEEDED(hr));

        // Does addref and release properly
        _previouslySetIDirectDrawSurface = ddsurf->IDDSurface();
    }

}

HRESULT DAGDI::
Blt( DDSurface *srcDDSurf, RECT &srcRect, RECT &destRect )
{
    Assert( _GetDDSurface() );

    _hr = S_OK;
    
    // we're not using the select ctx here becuase it's very ddraw
    // specific.  we want to set an idxsurface and THEN set the
    // clipper
    
    if( DoAntiAliasing() ) {

        bool doScale =
            (WIDTH(&srcRect) != WIDTH(&destRect)) ||
            (HEIGHT(&srcRect) != HEIGHT(&destRect));

        if( doScale ) {
            
            POINT offsetPt = {0,0};
            _SetScaleTransformIntoDx2d( srcRect, destRect, &offsetPt );

            SetSurfaceFromDDSurf(_GetDDSurface());

            DAComPtr<IUnknown> srcUnk;
            srcDDSurf
                ->GetIDXSurface( _IDXSurfaceFactory )
                ->QueryInterface(IID_IUnknown, (void **)&srcUnk);
            Assert(srcUnk);

            Assert(GetClipRegion());
            Assert(GetClipRegion()->GetType() == Region::rect);

            if( ((RectRegion *)GetClipRegion())->GetRectPtr() ) {
                TIME_DX2D(_hr = GetDx2d()->SetClipRect( ((RectRegion*)GetClipRegion())->GetRectPtr() ));
                Assert( SUCCEEDED( _hr ));
            }

            TIME_DX2D( _hr = GetDx2d()->Blt( srcUnk, &srcRect, &offsetPt ) );

            TIME_DX2D( _hr = GetDx2d()->SetClipRect( NULL ) );

        } else {

            RECT clipRect = *(((RectRegion*)GetClipRegion())->GetRectPtr());
            
            // Intersect the clipRect and destRect, move the
            // intersection to the src sruface space.  this is now the
            // clippedSrc rect.
            RECT clippedSrc;
            IntersectRect(&clippedSrc, &destRect, &clipRect);
            RECT clippedDest = clippedSrc;  // intsct of dest & clip
            OffsetRect(&clippedSrc, - destRect.left, - destRect.top);
            OffsetRect(&clippedSrc, srcRect.left, srcRect.top);

            // Since the srcRect is the clipped dest rect back mapped
            // into src space, it's placement in dest space is simply
            // the top left of the intersection of dest and clip.
            CDXDVec placement(clippedDest.left, clippedDest.top, 0,0);
            CDXDBnds clipBounds(clippedSrc);
            
            DWORD flags = DXBOF_DO_OVER;

            /* if we get the idxsurfae from dx2d the call deadlocks.
             * bug in dx2d.  ketan's looking into it.  so we set
             * surface NULL here which totally blows the optimizations
             * we've made in DAGDI::SetDDSurface()
             */
            //DAComPtr<IDXSurface> setSurf;
            //TIME_DX2D( _hr = GetDx2d()->GetSurface(IID_IDXSurface, (void **)&setSurf) );
            _hr = GetDx2d()->SetSurface(NULL);

            DAComPtr<IDXSurface> idxs;
            DDSurfPtr<DDSurface> holdDDSurf;

            if((_viewport->GetTargetBitDepth() == 8) &&
                _viewport->IsNT5Windowed()) 
            {
                // this is a workaournd for a bug in the DXtrans code.  They ignore
                // the palette that is attached to the surface and assume the 
                // halftone palette. bug#38986
                // Part one ...
                DDSurfPtr<DDSurface> tempDDSurf;
                _viewport->GetCompositingStack()->GetSurfaceFromFreePool(&tempDDSurf, doClear);
                _viewport->AttachCurrentPalette(tempDDSurf->IDDSurface(),true);
                GdiBlit(tempDDSurf,_GetDDSurface(),&clippedDest,&clippedDest);

                holdDDSurf = _GetDDSurface();
                SetDDSurface(tempDDSurf);
            }

            _hr = _IDXSurfaceFactory->CreateFromDDSurface(
               _GetDDSurface()->IDDSurface_IUnk(),
                NULL,   // this should be "&DDPF_PMARGB32" for IHammer filters, but no easy way to detect that (QBUG 36688)
                0,
                NULL,
                IID_IDXSurface,
                (void **)&idxs);
   
            
            _hr = _IDXSurfaceFactory->BitBlt(
                idxs,
                &placement, // offset of the clipBounds
                srcDDSurf->GetIDXSurface( _IDXSurfaceFactory ),
                &clipBounds, // this is a rect in src surface space
                flags);

            if((_viewport->GetTargetBitDepth() == 8) &&
                _viewport->IsNT5Windowed()) 
            {      
                // Part two ...

                GdiBlit(holdDDSurf,_GetDDSurface(),&clippedDest,&clippedDest);
                SetDDSurface(holdDDSurf);

            }

        }
        
        if( FAILED( _hr ) ) {
            DebugCode( hresult( _hr ) );
            TraceTag((tagError, "DAGDI: blt failed (%x): srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                      _hr,
                      srcRect.left, srcRect.top, srcRect.right, srcRect.bottom,
                      destRect.left, destRect.top, destRect.right, destRect.bottom));            
        }

        TIME_DX2D( _hr = GetDx2d()->SetClipRect( NULL ) );
        
    } else {
        Assert(0 && "shouldn't be here. blt only for aa");
    }

    return _hr;
}

void DAGDI::
_SetScaleTransformIntoDx2d( RECT &srcRect, RECT &destRect, POINT *outOffset )
{
    float ws = float( WIDTH( &destRect ) ) /  float( WIDTH( &srcRect ) );
    float hs = float( HEIGHT( &destRect ) ) /  float( HEIGHT( &srcRect ) );

    outOffset->x = destRect.left;
    outOffset->y = destRect.top;

    CDX2DXForm xf;
    xf.Scale( ws, hs );
    TIME_DX2D ( GetDx2d()->SetWorldTransform( &xf ) );
}


void DAGDI::
_MeterToPixelTransform(Transform2 *xf,
                       DWORD pixelWidth,
                       DWORD pixelHeight,
                       Real  res,
                       DX2DXFORM &outXf)
{
            // these are important Normal --> GDI && GDI --> Normal
            //  DX2DXFORM n2g = { 1.0, 0,
            //                      0, -1.0,
            //                      w, h,
            //                    DX2DXO_SCALE_AND_TRANS };
            //
            //  DX2DXFORM g2n = { 1.0, 0,
            //                      0, -1.0,
            //                     -w, h,
            //                    DX2DXO_SCALE_AND_TRANS };
            //


    // We want:
    // <normal to gdi> * <world xf> * <world pts> = gdi pts

    // CACHE!
    if( (pixelHeight != _pixelHeight) ||
        (pixelWidth != _pixelWidth) ||
        (res != _resolution) ||
        (!_n2g) ) {
        _pixelWidth = pixelWidth;
        _pixelHeight = pixelHeight;
        _resolution = res;
        
        Real w = Real(_pixelWidth) / 2.0;
        Real h = Real(_pixelHeight) / 2.0;

        delete _n2g;

        {
            DynamicHeapPusher hp(GetSystemHeap());
            _n2g = FullXform(_resolution,  0  ,  w,
                             0  , -_resolution,  h);
        }
    }

    Transform2 *finalXf = TimesTransform2Transform2(_n2g, xf);

    // Grab the matrix out and fill in the Dx2D matrix form.
    Real m[6];
    finalXf->GetMatrix(m);
    
    // Note: The da matrix has translation elements in 2 and 5.
    outXf.eM11 = m[0];
    outXf.eM12 = m[1];
    outXf.eM21 = m[3];
    outXf.eM22 = m[4];
    outXf.eDx  = m[2];
    outXf.eDy  = m[5];
    outXf.eOp  = DX2DXO_GENERAL_AND_TRANS;
}

void DAGDI::
PolyDraw(PolygonRegion *drawRegion, BYTE *codes)
{
    Assert( drawRegion && codes );
    Assert( _GetDDSurface() );
    
    SelectCtx ctx(GetPen(), GetBrush(), GetClipRegion());

    if( drawRegion->GetGdiPts() ) {

        Assert( GetPen() || GetBrush() );
        
        bool fill = false;
        bool stroke = false;
        
        if( GetBrush() ) { fill = true; }
        if( GetPen() ) { stroke = true; }

        // use GDI

        DDSurface *destDDSurf = _GetDDSurface();
        HDC hdc = destDDSurf->GetDC("Couldn't get DC on destDDSurf for DAGDI::PolyDraw");
        DCReleaser dcReleaser(destDDSurf, "Couldn't release DC DAGDI::PolyDraw");

        if( fill ) {
            TIME_GDI( ::BeginPath(hdc) );
            PolyDraw_GDIOnly( hdc, drawRegion, codes );
            TIME_GDI( ::EndPath(hdc) );
            
            _SelectIntoDC( hdc, &ctx );

            if( stroke ) {
                TIME_GDI( ::StrokeAndFillPath(hdc) );
            } else {
                TIME_GDI( ::FillPath(hdc) );
            }

            _UnSelectFromDC( hdc, &ctx );
            
        } else {
            Assert( stroke );
            _SelectIntoDC( hdc, &ctx );
            PolyDraw_GDIOnly( hdc, drawRegion, codes );
            _UnSelectFromDC( hdc, &ctx );
        }            
        
   } else {
       
        Assert( GetDx2d() );
        Assert( _GetDDSurface() );
        Assert( _GetDDSurface()->IDDSurface() ||
                _GetDDSurface()->HasIDXSurface());

       // TODO NOTE: if we know that we'll never be called with
       // beziers, then use DX2D_NO_FLATTEN as a dwFlag
       
        DXFPOINT *dxfPts;

        _SelectIntoDx2d( &ctx );
        bool allocatedPts = _Dx2d_GdiToDxf_Select(&dxfPts, drawRegion);

        //
        // make sure we can lock the surface
        //
        DebugCode(
            if(! _debugonly_CanLockSurface(_GetDDSurface()) ) {
                TraceTag((tagError, "Surface is busy BEFORE Dx2d->AAPolyDraw call"));
            }
        );

        TIME_DX2D( _hr = GetDx2d()->AAPolyDraw( dxfPts,
                                                codes,
                                                drawRegion->GetNumPts(),
                                                GetAdjustedResolution(),
                                                ctx.GetFlags() ));
        
        if( _hr == DDERR_SURFACELOST )
            _GetDDSurface()->IDDSurface()->Restore();
        
        DebugCode(
            if(! _debugonly_CanLockSurface(_GetDDSurface()) ) {
                TraceTag((tagError, "Surface is busy AFTER! Dx2d->AAPolyDraw call"));
            }
        );

        _Dx2d_GdiToDxf_UnSelect(allocatedPts ? dxfPts : NULL);
        _UnSelectFromDx2d( &ctx );
   }
}

// -----------------------------------------------------------------------
// Draw strictly to dcs using GDI calls.
// NOTE: Does NOT use dx2d ever!!
// -----------------------------------------------------------------------
void DAGDI::
PolyDraw_GDIOnly(HDC hdc, POINT *gdiPts, BYTE *codes, ULONG numPts)
{
    Assert( hdc && gdiPts && codes );

    BOOL ret;

    if( sysInfo.IsNT() ) {
        
        TIME_GDI( ret = ::PolyDraw(hdc, gdiPts, codes, numPts) );
        #if _DEBUG
        if(!ret) {
            void *msgBuf;
            FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                GetLastError(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPTSTR) &msgBuf,
                0,
                NULL );
                
            AssertStr(false, (char *)msgBuf);
                
            LocalFree( msgBuf );

            TraceTag((tagError, "NT PolyDraw failed"));
        }
        #endif
        Assert(ret && "NT PolyDraw failed");       
    } else {
        _Win95PolyDraw(hdc, gdiPts, codes, numPts);
    }
}

//
// Fills a polygon (outlined by 'pts') with the selected brush
// right now this is strictly a color.  no reason it can't be
// otherwise in the future.
//
void DAGDI::Polygon(PolygonRegion *polygon)
{    
    Assert( polygon );
    Assert( _GetDDSurface() );
    Assert( !GetPen() );
    Assert( GetBrush() );
    Assert( GetBrush()->GetType()==Brush::solid );
    Assert( GetClipRegion() );
    Assert( GetClipRegion()->GetType() == Region::rect );

    SelectCtx ctx(GetPen(), GetBrush(), GetClipRegion());

    if( ! DoAntiAliasing() ) {

        int ret;
        
        DDSurface *destDDSurf = _GetDDSurface();
        HDC dc = destDDSurf->GetDC("Couldn't get DC on destDDSurf for simple rendering");
        DCReleaser dcReleaser(destDDSurf, "Couldn't release DC in RenderMatteImage");

        _SelectIntoDC( dc, &ctx );
        
        TIME_GDI( ret = ::Polygon(dc, polygon->GetGdiPts(), polygon->GetNumPts()); );
        Assert(ret && "Polygon failed");

        _UnSelectFromDC( dc, &ctx );

    } else {
        // just intended to FILL
        Assert( !GetPen() );
        Assert( GetBrush() );
        Assert( GetBrush()->GetType()==Brush::solid );
        Assert( GetDx2d() );

        DXFPOINT *dxfPts;

        _SelectIntoDx2d( &ctx );

        bool allocatedPts = _Dx2d_GdiToDxf_Select(&dxfPts, polygon);

        // we know there aren't (and shouldn't be) any beziers here
        _Dx2d_PolyLine(dxfPts, polygon->GetNumPts(), ctx.GetFlags() | DX2D_NO_FLATTEN);

        _Dx2d_GdiToDxf_UnSelect(allocatedPts ? dxfPts : NULL);

        _UnSelectFromDx2d( &ctx );        
    }

}

    
void DAGDI::
_SetMulticolorGradientBrush(MulticolorGradientBrush *gradBr)
{
    Assert( GetDx2d() );
    Assert( _viewport );
    Assert( gradBr );
    
    //
    // Set up xform based on gradXf
    //
    DX2DXFORM gx;
    _MeterToPixelTransform(gradBr->_gradXf,
                           _viewport->Width(),
                           _viewport->Height(),
                           _viewport->GetResolution(),
                           gx);

    CDX2DXForm dx2d_gradXf( gx );
    
    DWORD dwFlags = 0;
    
    switch ( gradBr->GetType() )
      {
        
        default:
        case Brush::radialGradient:
          
          GetDx2d()->SetRadialGradientBrush(
              gradBr->_offsets,
              gradBr->_colors,
              gradBr->_count,
              gradBr->_opacity,
              &dx2d_gradXf,
              dwFlags);
          break;
          
        case Brush::linearGradient:
          
          GetDx2d()->SetLinearGradientBrush(
              gradBr->_offsets,
              gradBr->_colors,
              gradBr->_count,
              gradBr->_opacity,
              &dx2d_gradXf,
              dwFlags);
          break;
      } // switch
}

    
void DAGDI::
FillRegion(HDC dc, GdiRegion *gdiRegion)
{
    Assert( dc );
    Assert( gdiRegion );
    Assert( GetBrush() );
    Assert( GetBrush()->GetType() == Brush::solid );

    // XXX
    // Can't use dx2d here.  must rewrite path2 prims for fill Region!
    // XXX
    //if( ! DoAntiAliasing() ) {


    if(1) {
        
        Assert(dc);
        
        int ret;
        HRGN hrgn = gdiRegion->GetHRGN();

        if(_viewport->GetAlreadyOffset(GetDDSurface())) 
        {
            POINT p = _viewport->GetImageRenderer()->GetOffset();
            ::LPtoDP(dc,&p,1);
            ::OffsetRgn(hrgn, -p.x,-p.y);
        }

        HBRUSH hbrush;
        TIME_GDI( hbrush = ::CreateSolidBrush( ((SolidBrush *)GetBrush())->GetColorRef()) );
        
        GDI_Deleter byeBrush( hbrush );
        
        TIME_GDI( ret = ::FillRgn(dc, hrgn, hbrush));
        
        #if _DEBUG
        if(!ret) {
            DWORD err = GetLastError();

            // For some reason, FillRgn can fail, yet GetLastError()
            // can return 0.  In these cases, the results seem to be
            // OK.
            
            if (err != 0) {
                void *msgBuf;
                FormatMessage( 
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    err,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                    (LPTSTR) &msgBuf,
                    0,
                    NULL );
            
                TraceTag((tagError, "FillRgn failed in RenderPolygonImage with %d - %s",
                          err, (char*)msgBuf));

                LocalFree(msgBuf);
            }
        }
        #endif
    } else {

        // place holder for dx2d fill region.
        
    }
}

void DAGDI::
StrokeOrFillPath_AAOnly( HDC destDC, bool &releasedDC )
{
    Assert( DoAntiAliasing() );

    Assert( ( GetBrush() && !GetPen() ) ||
            (!GetBrush() &&  GetPen() ));

    SelectCtx ctx(GetPen(), GetBrush(), GetClipRegion());

    _SelectIntoDx2d( &ctx );

    _bReleasedDC = false; // reset the flag.

    _Dx2d_StrokeOrFillPath( destDC, ctx.GetFlags() );

    releasedDC = _bReleasedDC;

    _UnSelectFromDx2d( &ctx );
}


void DAGDI::
_TextOut_Gdi(HDC hdc, int x, int y, WCHAR *str, ULONG strLen)
{
    Assert( GetFont() );
    Assert( GetBrush() );

    TIME_GDI( ::SetBkMode(hdc, TRANSPARENT) );
    TIME_GDI( ::SetMapMode(hdc, MM_TEXT) ); // Each logical unit = 1 pixel

    RECT *clipRect = NULL;
    if( GetClipRegion() ) {
        Assert( GetClipRegion()->GetType() == Region::rect );
        clipRect = ((RectRegion *)GetClipRegion())->GetRectPtr();
    }

    Assert( GetBrush()->GetType()==Brush::solid );
    
    TIME_GDI( ::SetTextColor( hdc, ((SolidBrush *)GetBrush())->GetColorRef() ));

    //
    // Set text alignment to be baseline center
    //
    TIME_GDI( ::SetTextAlign(hdc, TA_BASELINE | TA_CENTER | TA_NOUPDATECP ) );
    
    // select font into dc
    HGDIOBJ oldFont = NULL;
    TIME_GDI( oldFont = ::SelectObject(hdc, GetFont()->GetHFONT() ) );
    
    
    // TODO: move most of gdi code out of 2dtext into here
    bool isCropped = (clipRect != NULL);

    if (sysInfo.IsWin9x()) {
        USES_CONVERSION;

        char * p = W2A(str);
        int  cLen = lstrlen(p);

        if( isCropped ) {
            TIME_GDI( ::ExtTextOut(hdc, x, y,
                                   ETO_CLIPPED,
                                   clipRect,
                                   p, cLen, NULL) );
        } else {
            TIME_GDI( ::TextOut(hdc, x, y, p, cLen) );
        }
    } else {
        if( isCropped ) {
            TIME_GDI( ::ExtTextOutW(hdc, x, y,
                                  ETO_CLIPPED,
                                  clipRect,
                                  str, strLen, NULL) );
        } else {
            TIME_GDI( ::TextOutW(hdc, x, y, str, strLen) );
        }
    }

    // select oldFont back into dc
    TIME_GDI( ::SelectObject(hdc, oldFont ) );
    
}


void DAGDI::
_TextOut_Dx2d(float x, float y, WCHAR *str, ULONG strLen)
{
    DebugCode(
        if( ! _GetDDSurface()->_debugonly_IsDCReleased() ) {
            OutputDebugString("dc taken in ddsurface");
        }
    );
        
    Assert( GetFont() );
    Assert( GetBrush() );
    Assert( GetDx2d() );
    Assert( _GetDDSurface() );
    Assert( _GetDDSurface()->IDDSurface() );
    
    SelectCtx ctx( GetPen(), GetBrush(), GetClipRegion() );
    _SelectIntoDx2d( &ctx );

    TIME_DX2D( _hr = GetDx2d()->SetFont( GetFont()->GetHFONT() ) );
    Assert( SUCCEEDED(_hr) );

    DWORD dwAlign =  TA_BASELINE | TA_CENTER;     

    DXFPOINT pos = { x, y };
    TIME_DX2D( _hr = GetDx2d()->AAText( pos, str, strLen, dwAlign ) );

    if( _hr == DDERR_SURFACELOST )
        _GetDDSurface()->IDDSurface()->Restore();

    _UnSelectFromDx2d( &ctx );
}

void DAGDI::
_SelectIntoDC(HDC hdc, SelectCtx *ctx)              
{
    Assert( ctx && hdc );

    // -------------
    // DO PEN
    // -------------
    
    HPEN gdiPen;  // do I really need to always set a gdipen?
    if( ctx->pen ) {

        if( sysInfo.IsWin9x() && ( ctx->pen->GetMiterLimit() < 1.0 ) ) {
            ctx->pen->SetMiterLimit( -1 );  // turn it off
        }

        if( ctx->pen->IsGeometricPen() ) {

            LOGBRUSH logBrush;
            logBrush.lbStyle = BS_SOLID;
            logBrush.lbColor = ctx->pen->GetColorRef();
        
            TIME_GDI(gdiPen = ::ExtCreatePen(
                ctx->pen->GetStyle(),
                ctx->pen->GetWidth(),
                &logBrush, 0, NULL));
        
            ctx->destroyHPEN = true;

        } else if( ctx->pen->IsCosmeticPen() ) {

            TIME_GDI( gdiPen = ::CreatePen(ctx->pen->GetStyle(), 0, ctx->pen->GetColorRef()) );

            ctx->destroyHPEN = true;
        
        } else {
            Assert(0 && "Bad pen type");
        }

        if( ctx->pen->DoMiterLimit() ) {
            int ret;
            TIME_GDI( ret = ::SetMiterLimit( hdc, ctx->pen->GetMiterLimit(), &(ctx->oldMiterLimit) ));
            Assert(ret && "SetMiterLimit failed!");
        }
        
    } else {
        gdiPen = _GetEmptyHPEN();
    }

    Assert(gdiPen);
    // Select the pen into the DC
    TIME_GDI( ctx->oldPen = SelectObject( hdc, gdiPen ) );

    // -------------
    // DO BRUSH
    // -------------

    if( ctx->brush ) {

        Assert( ctx->brush->GetType() == Brush::solid );
        HBRUSH gdiBrush;
        
        TIME_GDI( gdiBrush = (HBRUSH)::CreateSolidBrush( ((SolidBrush *)ctx->brush)->GetColorRef() ));
        
        ctx->destroyHBRUSH = true;
        
        TIME_GDI( ctx->oldBrush = (HBRUSH)::SelectObject(hdc, gdiBrush) );

    }
    DebugCode( else { Assert( !(ctx->oldBrush) ); } )
        
    // -------------
    // DO REGION
    // -------------

    // TODO: support other region types as needed
    
    Assert(ctx->clipRegion);
    Assert(ctx->clipRegion->GetType() == Region::rect);

    if( ((RectRegion *)ctx->clipRegion)->GetRectPtr() ) {



        TIME_GDI( ctx->newRgn = ::CreateRectRgnIndirect( ((RectRegion*)ctx->clipRegion)->GetRectPtr()  ) );
        Assert( ctx->newRgn );
        ctx->destroyHRGN = true;

        int ret;
        TIME_GDI( ret = ::SelectClipRgn( hdc, ctx->newRgn ) );
        Assert(ret != ERROR);
    }
}

void DAGDI::
_UnSelectFromDC(HDC hdc,
                SelectCtx *ctx)
{
    Assert( ctx && hdc );
    if( ctx->oldPen ) {
        HPEN curHpen;
        // Select the pen back into the DC
        TIME_GDI( curHpen = (HPEN)::SelectObject(hdc, ctx->oldPen) );
        if( ctx->destroyHPEN ) {
            TIME_GDI( ::DeleteObject((HGDIOBJ)curHpen) );
        }
    }

    if( ctx->pen ) {
        if( ctx->pen->DoMiterLimit() ) {
            // make sure what we expect is in there...
            DebugCode(
                float curLimit;  ::GetMiterLimit(hdc, &curLimit);
                Assert( ctx->pen->GetMiterLimit() == curLimit );
                );
            int ret;
            TIME_GDI( ret = ::SetMiterLimit( hdc, ctx->oldMiterLimit, NULL ) );
            Assert(ret && "SetMiterLimit failed!");
        }
    }
    
    if( ctx->oldBrush ) {
        HBRUSH curHbrush;
        // Select the pen back into the DC
        TIME_GDI( curHbrush = (HBRUSH)::SelectObject(hdc, ctx->oldBrush) );
        if( ctx->destroyHBRUSH ) {
            TIME_GDI( ::DeleteObject((HGDIOBJ)curHbrush) );
        }
    }

    // If there's a region involed, unselect whatever's in the dc, and
    // destroy it...  since we created it    
    if( ctx->newRgn ) {
        TIME_GDI( ::SelectClipRgn(hdc, NULL) );
        if( ctx->destroyHRGN ) {
            TIME_GDI( ::DeleteObject(ctx->newRgn) );
        }
    }
}



void DAGDI::
_SelectIntoDx2d(SelectCtx *ctx)         
{
    Assert( ctx );
    Assert( _GetDDSurface() );


    // -------------
    // DO SURFACE
    // -------------
    // Only set the surface if it's not currently the same surface.

    SetSurfaceFromDDSurf(_GetDDSurface());

    // -------------
    // DO PEN
    // -------------

    if( ctx->pen ) {
        
        ctx->AccumFlag( DX2D_STROKE );

        // caching opportunity.  dxtrans is going to implement this
        // internally probably more efficiently than us.
        // so looks like we don't need to
        //if( ! ctx->pen->IsSamePen(_dxpen) )
          {
              _dxpen.Color = ctx->pen->GetDxColor();
              _dxpen.Width = ctx->pen->GetfWidth();
              _dxpen.Style = ctx->pen->GetStyle();

              // already 0'd out
              //_dxpen.pTexture = NULL;
              //_dxpen.TexturePos.x = dxpen.TexturePos.y = 0.0;

              TIME_DX2D( GetDx2d()->SetPen( &_dxpen ) );
          }

          if( ctx->pen->IsCosmeticPen() &&
              _GetDDSurface()->ColorKeyIsValid() ) {
              ctx->oldSampleRes = GetSampleResolution();
              Assert( ctx->oldSampleRes > 0 );
              SetSampleResolution(1);
          }              
    }
    

    // -------------
    // DO BRUSH
    // -------------

    if( ctx->brush ) {

        ctx->AccumFlag( DX2D_FILL );
        
        DXBRUSH dxbrush;
        DAComPtr<IDXSurface> _IDXSurface;
        bool useDxbrush = true;
        
        switch ( ctx->brush->GetType() ) {

          case Brush::solid:

            dxbrush.Color = ((SolidBrush *)ctx->brush)->GetDxColor();
            dxbrush.pTexture = NULL;
            dxbrush.TexturePos.x = dxbrush.TexturePos.y = 0.0;
            break;
            
          case Brush::texture:

            {
                TextureBrush *tb = (TextureBrush *)ctx->brush;
                HRESULT hr;

                hr = _IDXSurfaceFactory->CreateFromDDSurface(
                    tb->GetSurface().IDDSurface_IUnk(),
                    NULL,
                    0,
                    NULL,
                    IID_IDXSurface,
                    (void **)&_IDXSurface);

                if( FAILED(hr) ) {
                    RaiseException_InternalError("Create IDXSurface from DDSurface failed");
                }
                
                dxbrush.Color = 0;
                dxbrush.pTexture = _IDXSurface;
                dxbrush.TexturePos.x = tb->OffsetX();
                dxbrush.TexturePos.y = tb->OffsetY();
            }

            break;
            
          case Brush::radialGradient:
          case Brush::linearGradient:

            _SetMulticolorGradientBrush( (MulticolorGradientBrush *)ctx->brush );
            useDxbrush = false;
            break;

          default:
            Assert(!"Bad brush type: dagdi");
        } // switch

        if( useDxbrush ) {
            TIME_DX2D( GetDx2d()->SetBrush( &dxbrush ) );
        }
        
    }  // if brush

    
    // -------------
    // DO REGION
    // -------------

    if(ctx->clipRegion) {
        if(ctx->clipRegion->GetType() == Region::rect) {
            // Given that it's a rectptr, set it on Dx2D

            #if _36098_WORKAROUND
            RECT *ptr = ((RectRegion *)ctx->clipRegion)->GetRectPtr();
            RECT r;
            if( ptr ) {
                r.right = ptr->right + 1;
                r.bottom = ptr->bottom + 1;
                r.left = ptr->left - 1;
                r.top = ptr->top - 1;
            }

            TIME_DX2D( GetDx2d()->SetClipRect( ptr ? &r : NULL ) );
            #else
            TIME_DX2D( GetDx2d()->SetClipRect( ((RectRegion *)ctx->clipRegion)->GetRectPtr()));
            #endif
            
        } else {
            // todo: support other regions as needed
            Assert(0 && "non-rect clipRegion for dx2d!");
        }
    }
}

void DAGDI::
_UnSelectFromDx2d(SelectCtx *ctx)
{
    Assert( ctx );

    TIME_DX2D( GetDx2d()->SetClipRect( NULL ) );

    if( ctx->oldSampleRes > 0 ) {
        SetSampleResolution( ctx->oldSampleRes );
    }    
}

void DAGDI::
_GenericLine_Gdi(HDC dc,
                 PolygonRegion *outline,
                 whatStyle_enum whatStyle)
{
    int ret;
    POINT *gdiPts;
    int numPts;
    bool bNeedReleaseDC=FALSE;

    if(dc == NULL)
    {
        dc = _GetDC();
        bNeedReleaseDC = TRUE;
    }


    Assert(GetClipRegion()->GetType() == Region::rect );

    SelectCtx ctx( GetPen(), GetBrush(), GetClipRegion() );
                   
    _SelectIntoDC( dc, &ctx );


    if(outline) {
        gdiPts = outline->GetGdiPts();
        numPts = outline->GetNumPts();
    }
    
    switch ( whatStyle ) {

      case doBezier:

        Assert(outline);
        TIME_GDI( ret = ::PolyBezier(dc, gdiPts, numPts) );
        Assert(ret && "PolyBezier failed");
        break;
        
      case doLine:

        Assert(outline);
        TIME_GDI( ret = ::Polyline(dc, gdiPts, numPts) );
        Assert(ret && "Polyline failed");
        break;
        
      case doStroke:
        
        TIME_GDI( ::StrokePath(dc) );
        break;
        
      default:
        Assert(0 && "Bad enum in PolylineOrBezier");
    }
    
    // Pull it back out
    _UnSelectFromDC( dc, &ctx );
    if(bNeedReleaseDC) {
        _ReleaseDC();
    }
}


void DAGDI::
_GenericLine_Dx2d(HDC dc,
                  PolygonRegion *outline,
                  whatStyle_enum whatStyle)
{
    Assert( GetDx2d() );
    Assert( GetPen() );
    Assert( !GetBrush() );
    Assert(GetClipRegion());
    Assert(GetClipRegion()->GetType() == Region::rect );

    SelectCtx ctx( GetPen(), GetBrush(), GetClipRegion() );
                   
    _SelectIntoDx2d( &ctx );
    
    DXFPOINT *dxfPts = NULL;
    ULONG numPts;
    bool allocatedPts;
    if(outline) {
        numPts = outline->GetNumPts();
        allocatedPts = _Dx2d_GdiToDxf_Select(&dxfPts, outline);
    }

    switch ( whatStyle ) {

      case doBezier:

        Assert(outline);
        _hr = _Dx2d_PolyBezier(dxfPts, numPts, ctx.GetFlags());
        Assert( SUCCEEDED(_hr) && "AAPolyBezier failed");

        break;
        
      case doLine:

        Assert(outline);
        _hr = _Dx2d_PolyLine(dxfPts, numPts, ctx.GetFlags() | DX2D_NO_FLATTEN);
        Assert( SUCCEEDED(_hr) && "AAPolyline failed");        
        break;
        
      case doStroke:
        _hr = _Dx2d_StrokeOrFillPath(dc, ctx.GetFlags());
        Assert( SUCCEEDED(_hr) && "AAStrokePath failed");
        break;
        
      default:
        Assert(0 && "Bad enum in _GenericLine_dx2d");
    }
    
    // Reset transform to NULL and delete dxfpoints
    _Dx2d_GdiToDxf_UnSelect(allocatedPts ? dxfPts : NULL);

    // Pull it back out
    _UnSelectFromDx2d( &ctx );
}


HRESULT DAGDI::
_Dx2d_PolyBezier(DXFPOINT *dxfPts, ULONG numPts, DWORD dwFlags)
{
    //--- Make up the types
    BYTE* pTypes = (BYTE*)alloca( numPts );
    ULONG i = 0;
    pTypes[i++] = PT_MOVETO;
    for( ; i < numPts; ++i ) pTypes[i] = PT_BEZIERTO;

    
    // HACK HACK for B1.  take this out later...
    Assert( _GetDDSurface() );
    Assert( _GetDDSurface()->IDDSurface() );
    _GetDDSurface()->_hack_ReleaseDCIfYouHaveOne();
    // HACK HACK for B1
        
    //
    // make sure we can lock the surface
    //
    DebugCode(
        if(! _debugonly_CanLockSurface(_GetDDSurface()) ) {
            OutputDebugString("Surface is busy BEFORE Dx2d->PolyBezier call");
        }
    );
    
    TIME_DX2D( _hr = GetDx2d()->AAPolyDraw( dxfPts, pTypes, numPts, GetAdjustedResolution(), dwFlags ) );

    if( _hr == DDERR_SURFACELOST )
        _GetDDSurface()->IDDSurface()->Restore();
    
    DebugCode(
        if(! _debugonly_CanLockSurface(_GetDDSurface()) ) {
            OutputDebugString("Surface is busy AFTER! Dx2d->PolyBezier call");
        }
    );
        
    return _hr;
}

HRESULT DAGDI::
_Dx2d_PolyLine(DXFPOINT *dxfPts, ULONG numPts, DWORD dwFlags)
{
    //--- Make up the types
    BYTE* pTypes = (BYTE*)alloca( numPts );
    ULONG i = 0;
    pTypes[i++] = PT_MOVETO;
    for( ; i < numPts; ++i ) pTypes[i] = PT_LINETO;

    // HACK HACK for B1.  take this out later...
    Assert( _GetDDSurface() );
    Assert( _GetDDSurface()->IDDSurface() );
    _GetDDSurface()->_hack_ReleaseDCIfYouHaveOne();
    // HACK HACK for B1

    //
    // make sure we can lock the surface
    //
    DebugCode(
        if(! _debugonly_CanLockSurface(_GetDDSurface()) ) {
            OutputDebugString("Surface is busy BEFORE Dx2d->PolyBezier call");
        }
    );
    
    TIME_DX2D( _hr = GetDx2d()->AAPolyDraw( dxfPts, pTypes, numPts, GetAdjustedResolution() ,dwFlags ) );

    if( _hr == DDERR_SURFACELOST )
        _GetDDSurface()->IDDSurface()->Restore();
    
    DebugCode( if( FAILED(_hr)) TraceTag((tagError, "AAPolyDraw (PolyLine) returned %x", _hr)); );
    
    //
    // make sure we can lock the surface
    //
    DebugCode(
        if(! _debugonly_CanLockSurface(_GetDDSurface()) ) {
            OutputDebugString("Surface is busy AFTER! Dx2d->PolyBezier call");
        }
    );
    
    return _hr;
}

HRESULT DAGDI::
_Dx2d_StrokeOrFillPath(HDC hDC, DWORD dwFlags)
{
    _hr = S_OK;

    //--- Get the path and convert to floats
    ULONG ulCount;
    TIME_GDI( ulCount = ::GetPath( hDC, NULL, NULL, 0 ) );

    DebugCode(
        if(!ulCount) TraceTag((tagError, "_Dx2d_StrokeOrFillPath DC has no points in it."));
        );
    
    if( ulCount != 0xFFFFFFFF  &&  ulCount > 0)
    {
        POINT* pPoints = (POINT*)alloca( ulCount * sizeof( POINT ) );
        BYTE*  pTypes  = (BYTE*)alloca( ulCount * sizeof( BYTE ) );
        TIME_GDI( ::GetPath( hDC, pPoints, pTypes, ulCount ) );

        //--- Convert to floats
        DXFPOINT *pRenderPoints;
        PolygonRegion polygon(pPoints,ulCount);
        bool allocatedPts = _Dx2d_GdiToDxf_Select(&pRenderPoints, &polygon);

        Assert( _GetDDSurface() );
        Assert( _GetDDSurface()->IDDSurface() );
        _GetDDSurface()->ReleaseDC("Release the DC on the surface"); 
        _bReleasedDC = true;

        //
        // make sure we can lock the surface
        //
        DebugCode(
            if(! _debugonly_CanLockSurface(_GetDDSurface()) ) {
                OutputDebugString("_Dx2d_StrokeOrFillPath: Surface is busy BEFORE Dx2d->AAPolyDraw call");
            }
        );

        TIME_DX2D( _hr = GetDx2d()->AAPolyDraw( pRenderPoints, pTypes, ulCount, GetAdjustedResolution(), dwFlags ));

        if( _hr == DDERR_SURFACELOST )
            _GetDDSurface()->IDDSurface()->Restore();
        
        DebugCode(
            if(! _debugonly_CanLockSurface(_GetDDSurface()) ) {
                OutputDebugString("_Dx2d_StrokeOrFillPath: Surface is busy AFTER! Dx2d->AAPolyDraw call");
            }
        );
        _Dx2d_GdiToDxf_UnSelect(allocatedPts ? pRenderPoints : NULL);
    }

    return _hr;
}



bool DAGDI::
_Dx2d_GdiToDxf_Select(DXFPOINT **pdxfPts, PolygonRegion *polygon)
{
    Assert(pdxfPts);

    bool allocatedPoints;
    
    POINT *gdiPts = polygon->GetGdiPts();
    if (gdiPts) {
        
        //
        // Transform the points to float space.  Not concerned about
        // saving the allocation on this, since this is not the fast
        // path through the code.
        //

        ULONG numPts = polygon->GetNumPts();
        *pdxfPts = NEW DXFPOINT[numPts];
        for(int i=0; i<numPts; i++) {
            (*pdxfPts)[i].x = (float)gdiPts[i].x;
            (*pdxfPts)[i].y = (float)gdiPts[i].y;
        }

        allocatedPoints = true;
        
    } else {
    
        TextPoints *txtPts = polygon->GetTextPts();
        Assert(txtPts->_pts);
        *pdxfPts = txtPts->_pts;

        allocatedPoints = false;
        
    }
    
    CDX2DXForm xf;
    
#if _DEBUG
    if(!IsTagEnabled(tagAAScaleOff)) {
#endif
        if( GetSuperScaleMode() == true ) {
            //
            // Set up scaling xform to extend range for higher fidelity
            //

            DWORD w = _width / 2;
            DWORD h = _height / 2;

            float s = 1.0 / GetSuperScaleFactor();


            // these are important Normal --> GDI && GDI --> Normal
            //  DX2DXFORM n2g = { 1.0, 0,
            //                      0, -1.0,
            //                      w, h,
            //                    DX2DXO_SCALE_AND_TRANS };
            //
            //  DX2DXFORM g2n = { 1.0, 0,
            //                      0, -1.0,
            //                     -w, h,
            //                    DX2DXO_SCALE_AND_TRANS };
            //

            if (!gdiPts) {
                // Take the resolution and w/h parameters from polygon and
                // come up with a transform that takes our space to the
                // corresponding GDI space using n2g above, and concatenate in
                // the below transform as well:

                // Normal->Gdi * scaleDown * Gdi->Normal * PTS =  NewPoints
                // CDX2DXForm xf;
                // DX2DXFORM mine = { s, 0,
                //                    0, s,
                //                    ((-(w*s)) + w), 
                //                    ((-(h*s)) + h),
                //                   DX2DXO_SCALE_AND_TRANS };

                DWORD w2, h2;
                Real  res;
                polygon->GetWHRes(&w2, &h2, &res);

                Real wf = (Real)w;
                Real w2f = (Real)w2;
                Real hf = (Real)h;
                Real h2f = (Real)h2;
        
                Real a00 = res * s;
                Real a01 = 0;
                Real a02 = s * w2f + ((-wf*s) + wf);

                Real a10 = 0;
                Real a11 = -res * s;
                Real a12 = s * h2 + ((-hf*s) + hf);

                Transform2 *toCombine =
                    FullXform(a00, a01, a02, a10, a11, a12);

                // Combine with the DA modeling transform, which is applied
                // first. 
                Transform2 *toUse =
                    TimesTransform2Transform2(toCombine,
                                              polygon->GetTransform());

                // Grab the matrix out and fill in the Dx2D matrix form.
                Real m[6];
                toUse->GetMatrix(m);

                // Note: The da matrix has translation elements in 2 and 5.

                DX2DXFORM mine = { m[0], m[1],
                                   m[3], m[4],
                                   m[2],
                                   m[5],
                                   DX2DXO_GENERAL_AND_TRANS };

                xf.Set( mine );

            } else {


                // Points already translated into GDI space...  just add
                // on from the old code path

                // Normal->Gdi * scaleDown * Gdi->Normal * PTS =  NewPoints
                DX2DXFORM mine = { s, 0,
                                   0, s,
                                   ((-(w*s)) + w), 
                                   ((-(h*s)) + h),
                                   DX2DXO_SCALE_AND_TRANS };
            
                xf.Set( mine );
            
            }
        
        }
#if _DEBUG
    }
#endif
    
    if( DoOffset() ) {
        // not implemented yet (can't do super scale and offset)
        Assert( GetSuperScaleMode() == false );

        xf.Translate(_pixOffset.x, _pixOffset.y);
    }

    TIME_DX2D( _hr = GetDx2d()->SetWorldTransform( &xf ) );
    Assert( SUCCEEDED(_hr) && "DX2D: Couldn't set WorldTransform");

    return allocatedPoints;
}

void DAGDI::
_Dx2d_GdiToDxf_UnSelect(DXFPOINT *dxfPts)
{
    delete dxfPts;
    
    TIME_DX2D( GetDx2d()->SetWorldTransform( NULL ) );
}

void DAGDI::
_Win95PolyDraw(HDC dc, POINT *pts, BYTE *types, int count)
{
    POINT lastMoveTo;
    bool  lastMoveToValid = false;

    for (int i=0; i<count; i++)
      {
          BYTE bPointType = types[i];

          switch (bPointType)
            {
              case PT_MOVETO :
              case PT_MOVETO | PT_CLOSEFIGURE:
                ::MoveToEx(dc, pts[i].x, pts[i].y, NULL);
                lastMoveTo.x = pts[i].x;
                lastMoveTo.y = pts[i].y;
                lastMoveToValid = true;
                break;
                
              case PT_LINETO | PT_CLOSEFIGURE:
              case PT_LINETO :
                TIME_GDI(::LineTo(dc, pts[i].x, pts[i].y) );
                break;
                
              case PT_BEZIERTO | PT_CLOSEFIGURE:
              case PT_BEZIERTO :
                TIME_GDI(::PolyBezierTo(dc, &pts[i], 3));

                // Since we skip over i and i+1, the point type should
                // really be that of i+2.
                bPointType = types[i+2];

                // Skip over the next two.
                i+=2;
                
                break;
              default:
                Assert (FALSE);
            }
          
          // We must explicitly close the figure in this case...
          if ((bPointType & PT_CLOSEFIGURE) == PT_CLOSEFIGURE)
            {
                // Don't call CloseFigure here, since that's only
                // valid within a BeginPath/EndPath.  Rather, do an
                // explicit LineTo the point we did the last MoveTo
                // to.
                if (lastMoveToValid) {
                    TIME_GDI(::LineTo(dc, lastMoveTo.x, lastMoveTo.y));
                }
            }
      }
}

#if _DEBUG
bool DAGDI::_debugonly_CanLockSurface( DDSurface *dds )
{

    // try to lock it and release
    DDSURFACEDESC desc;
    desc.dwSize = sizeof(DDSURFACEDESC);

    LPDDRAWSURFACE surf = dds->IDDSurface();
    
    desc.dwFlags = DDSD_PITCH | DDSD_LPSURFACE;
    HRESULT hr = surf->Lock(NULL, &desc, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
    if( FAILED(hr) ) {
        printDDError(hr);
    } else {
        hr = surf->Unlock(desc.lpSurface);
        if( FAILED(hr) ) {
            printDDError(hr);
        }
    }
    return  FAILED(hr) ? false : true;
}
#endif

HDC  DAGDI::_GetDC()
{
    Assert(_GetDDSurface());
    return _GetDDSurface()->GetDC("Couldn't get DC in DAGDI::_GetDC");

}

void  DAGDI::_ReleaseDC()
{
    Assert(_GetDDSurface());
    _GetDDSurface()->ReleaseDC("releasedc failed in dagdi::_getdc");    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\dddevice.cpp ===
/******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    DirectDraw image rendering device

*******************************************************************************/

#include "headers.h"

#include <privinc/vec2i.h>
#include <privinc/SurfaceManager.h>
#include <privinc/dddevice.h>
#include <privinc/textctx.h>
#include <privinc/texti.h>
#include <privinc/debug.h>
#include <privinc/except.h>
#include <privinc/util.h>
#include <privinc/cropdimg.h>
#include <privinc/transimg.h>
#include <privinc/cachdimg.h>
#include <server/view.h> // GetCurrentView()
#include <privinc/d3dutil.h>
#include <privinc/dagdi.h>
#include <privinc/opt.h>

//---------------------------------------------------------
// Local functions
//---------------------------------------------------------
Real Pix2Real(LONG pixel, Real res);
Real Round(Real x);
LONG Real2Pix(Real imgCoord, Real res);

//---------------------------------------------------------
// local defines & consts
//---------------------------------------------------------
#define PLEASE_CLIP TRUE
#define MAX_TRIES  4
static const Real EPSILON  = 0.0000002;

#define TEST_EXCEPTIONS 0

//---------------------------------------------------------
// Local Macros
//---------------------------------------------------------
#if _DEBUG
#define INLINE  static
#else
#define INLINE  static inline
#endif

#define WIDTH(rect) ((rect)->right - (rect)->left)
#define HEIGHT(rect) ((rect)->bottom - (rect)->top)

//---------------------------------------------------------
// Local Helper Functions
//---------------------------------------------------------

// Includes IfErrorXXXX inline functions
#include "privinc/error.h"

#if _DEBUG
void PrintRect(RECT *rect, char *str)
{
    TraceTag((tagError, "%s :(%d,%d,%d,%d)",
              str,
              rect->left, rect->top,
              rect->right, rect->bottom));
}
#endif

static Bool SameFormat(LPDDPIXELFORMAT a, LPDDPIXELFORMAT b)
{
    return((a->dwRGBBitCount     == b->dwRGBBitCount) &&
           (a->dwRBitMask        == b->dwRBitMask) &&
           (a->dwGBitMask        == b->dwGBitMask) &&
           (a->dwBBitMask        == b->dwBBitMask) &&
           (a->dwRGBAlphaBitMask == b->dwRGBAlphaBitMask));
}

static inline Real Pix2Real(LONG pixel, Real res)
{
    return Real(pixel) / res;
}

/* floor: need to use it for consistent truncation of floating point in C++ */

inline  LONG Real2Pix(Real imgCoord, Real res)
{
    // kill some 'precision'.  Round to the nearest
    // 100th of a pixel to remove roundoff error.
    // THEN round to the nearest pixel.
    Real halfPixel = imgCoord * res;
    halfPixel = halfPixel + 0.001;
    halfPixel = halfPixel * 100.0;
    halfPixel = Real( LONG(halfPixel) );
    halfPixel = halfPixel / 100.0;
    return (LONG)(floor(halfPixel + 0.5));
}


HRESULT DirectDrawImageDevice::RenderSolidColorMSHTML(DDSurface *ddSurf,SolidColorImageClass& img, RECT *destRect)
{
    HRESULT hres = E_FAIL;

    // Get the DC from the given surface.
    HDC  hdc = ddSurf->GetDC("Couldn't Get DC in RenderSolidColorMSHTML");
    if(hdc) {
        // Get the color to use and convert to a COLORREF
        Color *c = img.GetColor();
        COLORREF cref = RGB(c->red*255,c->green*255,c->blue*255);

        // Create a brush base on the COLORREF
        HBRUSH hbr;
        TIME_GDI( hbr = ::CreateSolidBrush(cref) );

        // Select the brush into the DC
        HGDIOBJ  hobj;
        TIME_GDI( hobj = ::SelectObject(hdc, hbr) );

        // Clip manually for pal blit
        //
        if( IsCompositeDirectly() &&
            ddSurf == _viewport._targetPackage._targetDDSurf ) {
            IntersectRect(destRect, destRect,
                          _viewport._targetPackage._prcViewport);
            if(_viewport._targetPackage._prcClip) {
                IntersectRect(destRect, destRect,
                              _viewport._targetPackage._prcClip);
            }
        }

        // do the PalBlt to the surface.
        BOOL bres;
        TIME_GDI( bres = ::PatBlt(hdc,destRect->left,destRect->top,
                                destRect->right - destRect->left,
                                destRect->bottom - destRect->top,
                                PATCOPY) );

        // Unselect brush from the DC
        TIME_GDI( ::SelectObject(hdc, hobj) );

        // Delete the brush from the DC
        TIME_GDI( ::DeleteObject((HGDIOBJ)hbr) );

        // Release the DC
        ddSurf->ReleaseDC("Couldn't Release DC in RenderSolidColorMSHTML");

        if(bres) {
            hres = DD_OK;
        }
    }
    return hres;
}


class TextPtsCacheEntry : public AxAThrowingAllocatorClass {
  public:
    TextPtsCacheEntry() : _txtPts(NULL), _str(NULL), _fontFamily(NULL) {}
    ~TextPtsCacheEntry() {
        delete _str;
        delete _fontFamily;
        delete _txtPts;
    }

    WideString _str;
    WideString _fontFamily;

    FontFamilyEnum  _font;
    Bool        _bold;
    Bool        _italic;
    Bool        _strikethrough;
    Bool        _underline;
    double      _weight;
    TextPoints *_txtPts;
};

//--------------------------------------------------
// D I R E C T   D R A W   I M A G E   D E V I C E
//
// <constructor>
// pre: DDRAW initiazlied
//--------------------------------------------------
DirectDrawImageDevice::
DirectDrawImageDevice(DirectDrawViewport &viewport)
: _viewport(viewport),
  _scratchHeap(NULL)
{
    TraceTag((tagImageDeviceInformative, "Creating %x (viewport=%x)", this, &_viewport));

    //----------------------------------------------------------------------
    // Initialize members
    //----------------------------------------------------------------------

    _textureSurfaceManager = NULL;
    _usedTextureSurfacePool = NULL;
    _freeTextureSurfacePool = NULL;
    _intraFrameUsedTextureSurfacePool = NULL;
    _intraFrameTextureSurfaceMap = NULL;
    _intraFrameUpsideDownTextureSurfaceMap = NULL;

    SetCompositingStack(NULL);
    SetSurfacePool(NULL);
    SetSurfaceMap(NULL);

    ZeroMemory(&_scratchSurf32Struct, sizeof(_scratchSurf32Struct));
    _resetDefaultColorKey = FALSE;

    _pen = NULL;

    ZeroMemory(&_textureContext, sizeof(_textureContext));
    _textureContext.ddsd.dwSize = sizeof(DDSURFACEDESC);

    _currentScratchDDTexture = NULL;

    ZeroMemory(&_bltFx, sizeof(_bltFx));
    _bltFx.dwSize = sizeof(_bltFx);

    // Initialize the textureSurface & related members

    _textureClipper      = NULL;
    _textureWidth     = _textureHeight = 0;
    SetRect(&_textureRect, 0,0,0,0);

    _tileClipper = NULL;

    _minOpacity = 0.0;
    _maxOpacity = 1.0;
    //_finalOpacity = 1.0;

    _tx = _ty = 0.0;
    _offsetXf = NULL;
    _doOffset = false;
    _pixOffsetPt.x = _pixOffsetPt.y = 0;

    // Antialiasing related member vars
    _renderForAntiAliasing = false;

    for (int i=0; i<TEXTPTSCACHESIZE; i++)
        _textPtsCache[i] = NULL;

    _textPtsCacheIndex = 0;

    _daGdi = NULL;

    _deviceInitialized = FALSE;

    _alreadyDisabledDirtyRects = false;

    // Do this last since it can throw an exception

    _scratchHeap = &TransientHeap("ImageDevice", 256, (float)2.0);

    InitializeDevice();
}

void DirectDrawImageDevice::
InitializeDevice()
{
    //
    // make sure viewport is initialized (these are idempotent ops)
    //
    _viewport.InitializeDevice();

    if( !_viewport.IsInitialized() ) return;
    if( IsInitialized() ) return;

    //
    // Precompute some useful values for alpha blending
    //
    if(_viewport.GetTargetBitDepth() > 8) {
        _minOpacity = 1.0 / _viewport._targetDescriptor._red;
        _maxOpacity = (_viewport._targetDescriptor._red - 1) / _viewport._targetDescriptor._red;
    } else {
        // XXX these are arbitrary for 256 (or less) color mode
        _minOpacity = 0.005;
        _maxOpacity = 0.995;
    }


    //
    // TODO: future: these pools need to belong to the viewport...
    //
    _textureSurfaceManager = NEW SurfaceManager(_viewport);
    _freeTextureSurfacePool = NEW SurfacePool(*_textureSurfaceManager, _viewport._targetDescriptor._pixelFormat);
    _intraFrameUsedTextureSurfacePool = NEW SurfacePool(*_textureSurfaceManager, _viewport._targetDescriptor._pixelFormat);
    _usedTextureSurfacePool = NEW SurfacePool(*_textureSurfaceManager, _viewport._targetDescriptor._pixelFormat);

    _intraFrameTextureSurfaceMap =
        NEW SurfaceMap(*_textureSurfaceManager,
                       _viewport._targetDescriptor._pixelFormat,
                       isTexture);
    _intraFrameUpsideDownTextureSurfaceMap =
        NEW SurfaceMap(*_textureSurfaceManager,
                       _viewport._targetDescriptor._pixelFormat,
                       isTexture);
    //
    // Do prelim texture stuff
    //
    EndEnumTextureFormats();

    _deviceInitialized = TRUE;


    //
    // DAGDI
    //
    _daGdi = NEW DAGDI( &_viewport );
    _daGdi->SetDx2d( _viewport.GetDX2d(),
                     _viewport.GetDXSurfaceFactory() );
}




//--------------------------------------------------
// D I R E C T   D R A W   I M A G E   D E V I C E
//
// <destructor>
//--------------------------------------------------
DirectDrawImageDevice::
~DirectDrawImageDevice()
{
    TraceTag((tagImageDeviceInformative, "Destroying %x", this));
    //printf("<---Destroying %x\n", this);

    if (_offsetXf) {
        GCRemoveFromRoots(_offsetXf, GetCurrentGCRoots());
        _offsetXf = NULL; // gc'd
    }

    ReturnTextureSurfaces(_freeTextureSurfacePool, _usedTextureSurfacePool);

    for (int i=0; i<TEXTPTSCACHESIZE; i++)
        delete _textPtsCache[i];

    delete _textureSurfaceManager;

    delete _daGdi;

    if (_scratchHeap)
        DestroyTransientHeap(*_scratchHeap);
}

void
DirectDrawImageDevice::SetOffset(POINT pixOffsetPt)
{
    _doOffset = true;
    _pixOffsetPt = pixOffsetPt;

    // Now, notice that pixOffset is in our favorite coordinate
    // space... GDI.  So, positive Y means... DOWN!
    _tx = FASTPIX2METER(_pixOffsetPt.x, GetResolution());
    _ty = FASTPIX2METER( - _pixOffsetPt.y, GetResolution());
    {
        DynamicHeapPusher h(GetGCHeap());

        GCRoots roots = GetCurrentGCRoots();

        if (_offsetXf)
            GCRemoveFromRoots(_offsetXf, roots);

        GC_CREATE_BEGIN;
        _offsetXf = TranslateRR( _tx, _ty );
        GCAddToRoots(_offsetXf, roots);

        GC_CREATE_END;
    }
}

void
DirectDrawImageDevice::UnsetOffset()
{
    _doOffset = false;
    _pixOffsetPt.x = _pixOffsetPt.y = 0;
    _tx = _ty = 0.0;
    if (_offsetXf)
        GCRemoveFromRoots(_offsetXf, GetCurrentGCRoots());
    _offsetXf = NULL; // gc'd
}

// Consider NULL and "" the same
inline int MyStrCmpW(WideString s1, WideString s2)
{
    s1 = s1 ? s1 : L"";
    s2 = s2 ? s2 : L"";

    return StrCmpW(s1, s2);
}

TextPoints *
DirectDrawImageDevice::GetTextPointsCache(TextCtx *ctx, WideString str)
{
    for (int i=0; i<TEXTPTSCACHESIZE; i++) {
        if (_textPtsCache[i] &&
            (ctx->GetFont() == _textPtsCache[i]->_font) &&
            (ctx->GetBold() == _textPtsCache[i]->_bold) &&
            (ctx->GetItalic() == _textPtsCache[i]->_italic) &&
            (ctx->GetStrikethrough() == _textPtsCache[i]->_strikethrough) &&
            (ctx->GetUnderline() == _textPtsCache[i]->_underline) &&
            (ctx->GetWeight() == _textPtsCache[i]->_weight) &&
            (!MyStrCmpW(ctx->GetFontFamily(),
                        _textPtsCache[i]->_fontFamily)) &&
            (!MyStrCmpW(str, _textPtsCache[i]->_str)))
            return _textPtsCache[i]->_txtPts;
    }

    return NULL;
}

void
DirectDrawImageDevice::SetTextPointsCache(TextCtx *ctx,
                                          WideString str,
                                          TextPoints *txtPts)
{
    int emptySlot = -1;

    for (int i=0; i<TEXTPTSCACHESIZE; i++) {
        if (_textPtsCache[i] == NULL) {
            emptySlot = i;
            break;
        }
    }

    if (emptySlot<0) {
        _textPtsCacheIndex = (_textPtsCacheIndex + 1) % TEXTPTSCACHESIZE;
        emptySlot = _textPtsCacheIndex;
    }

    if (_textPtsCache[emptySlot] != NULL) {
        delete _textPtsCache[emptySlot];
    }

    _textPtsCache[emptySlot] = NEW TextPtsCacheEntry();

    TextPtsCacheEntry* p = _textPtsCache[emptySlot];

    p->_font = ctx->GetFont();
    p->_bold = ctx->GetBold();
    p->_italic = ctx->GetItalic();
    p->_strikethrough = ctx->GetStrikethrough();
    p->_underline = ctx->GetUnderline();
    p->_weight = ctx->GetWeight();

    p->_fontFamily = CopyString(ctx->GetFontFamily());
    p->_str = CopyString(str);
    p->_txtPts = txtPts;
}



/*****************************************************************************
This routine is used to try to look up the resultant surface for a given
static (constant-folded) image.  If it cannot cache the image, or if there
was a problem encountered while trying to generate the cached image, this
routine will return NULL, otherwise it will return the surface with the
rendered result.
*****************************************************************************/

DDSurface *try_LookupSurfaceFromDiscreteImage(
    DirectDrawImageDevice *that,
    CachedImage *cachedImg,
    bool b,
    Image **pImageCacheBase,
    bool alphaSurf)
{
    DDSurface *ret;

    // We return null for any exception because in some cases we encounter
    // problems during caching only -- if we fail here, we might still succeed
    // with the actual (non-cached) render.

    __try {
        ret = that->LookupSurfaceFromDiscreteImage( cachedImg, b, pImageCacheBase, alphaSurf );
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        ret = NULL;
    }

    return ret;
}


// forward
Image *
MakeImageQualityImage(Image *img,
                      long width,
                      long height,
                      DWORD dwQualFlags);

void SetSurfaceAlphaBitsToOpaque(IDirectDrawSurface *imsurf,
                                 DWORD fullClrKey);

const DWORD cacheClrKey = 0x02010001;

Image *DirectDrawImageDevice::
CanCacheImage(Image *img,
              Image **pImageCacheBase,
              const CacheParam &p)
{
    InitializeDevice();

    // Initialization failed, bail...
    if (!_deviceInitialized) {
        return NULL;
    }

    bool usedAsTexture = p._isTexture;

    // Here we need to decide if we're to cache with alpha or not.
    // A=alpha aware images
    // B=not alpha aware images
    // AB=mix of a&b.
    //
    // we should cache 'A' w/ alpha.  cache 'B' without. and don't
    // cache 'AB'

    /*  The problem with caching to aa surfaces all the time...
        However, a ddraw blt on a the same surface will completely
        ignore the alpha byte, leaving it at 0.

        The only solution i can think of is to color key the surface
        (sigh...) by filling in the color key with alpha=0.
        Then after a non-alpha aware primitive draws
        (like ddraw's blt for example) it will overwrite the clr
        key pixels (while leaving 0 in the alpha byte).
        When an alpha aware primitve draws, it will set the alpha
        to something appropriate and it doesn't care about clr keyed
        pixels (they're effectively transparent, so overwrite them!).

        Then when the dx2d->BitBlt comes along to compose this surface onto
        the final target surface it will only blend the interesting
        pixels AND will copy the pixels that aren't the color key but
        have 0 alpha ?
        */

    // try to cache the image...
    // if it fails, return null.
    // if it succeeds, return the cached image

    Bbox2 ImgBbox=img->BoundingBox();

    if((ImgBbox==UniverseBbox2)||(ImgBbox==NullBbox2)) {
        // can't cache img with infinite or null bbox
        return NULL;
    }



    // Interrogate the graph and decide if we should cache or not
    bool cacheWithAlpha;
    {
        Image::TraversalContext ctx;
        img->Traverse(ctx);

        if( (ctx.ContainsLine() ||
             ctx.ContainsSolidMatte()) &&
            !ctx.ContainsOther() ) {
            cacheWithAlpha = true;
        } else if( (ctx.ContainsLine() ||
                    ctx.ContainsSolidMatte()) &&
                   ctx.ContainsOther() ) {
            // don't cache at all.
            // this assumes that the lines/matte can possibly be aa
            // later or now.  If we can get this guarantee from Ricky
            // then we won't waste possible cache opportunities
            return NULL;
        } else {
            // Contains other only
            cacheWithAlpha = false;
        }
    }


    Point2 center;
    DynamicHeap& heap = GetTmpHeap();

    {
        DynamicHeapPusher h(heap);

        center = img->BoundingBox().Center();
    }

    // REVERT-RB:
    Assert(&GetHeapOnTopOfStack() == &GetGCHeap());
    // Assert(&GetHeapOnTopOfStack() == &GetViewRBHeap());

    Image *centeredImg = NEW Transform2Image(TranslateRR(-center.x,-center.y),img);

    if( cacheWithAlpha ) {
        // this is here until ricky can pass down info on weather or not
        // to cache with aa or until dx2d caches the alpha channel separately.
        centeredImg = MakeImageQualityImage(
            centeredImg,
            -1,-1,
            CRQUAL_AA_LINES_ON |
            CRQUAL_AA_SOLIDS_ON |
            CRQUAL_AA_TEXT_ON |
            CRQUAL_AA_CLIP_ON );
    }

    CachedImage *cachedImg = NEW CachedImage(centeredImg, usedAsTexture);
    Image *translatedImg = NEW Transform2Image(TranslateRR(center.x,center.y),
                                               cachedImg);


    DDSurface *cachedDDSurf = NULL;
    {
        DynamicHeapPusher h(heap);

        cachedDDSurf = try_LookupSurfaceFromDiscreteImage( this,
                                                           cachedImg,
                                                           true,
                                                           pImageCacheBase,
                                                           cacheWithAlpha );

        ResetDynamicHeap(heap);
    }

    // we cached a ddsurface & it's an alpha cache
    if( cachedDDSurf && cacheWithAlpha ) {
        // clean surface so dx2d bitblt will not ignore the non-alpha
        // aware prmitives that may have renderd onto the suraface.
        SetSurfaceAlphaBitsToOpaque( cachedDDSurf->IDDSurface(),
                                     cacheClrKey );
    }

    if( cachedDDSurf ) {
        return translatedImg;
    } else {
        return NULL;
    }
}

//--------------------------------------------------
// D e c o m p o s e   M a t r i x
//
// Takse a Transform2 and decomposes it into
// scales, rotates, & shears.
// right now, it's just scale & rotate
//--------------------------------------------------
void  DirectDrawImageDevice::
DecomposeMatrix(Transform2 *xform, Real *xScale, Real *yScale, Real *rot)
{
    Real  matrix[6];
    xform->GetMatrix(matrix);

    //----------------------------------------------------
    // Decompose matrix into Translate * Rotation * Scale
    // Note, rotation and scale are order independent
    // All this decomposition stuff is in Gems III, pg 108
    // This decomposes the nonsingular linear transform M into:
    // M = S * R * H1 * H2
    // Where: S = scale,  R = rotate, and H = Shear
    // To apply the results correctly, we must first
    // shear, then rotate, then scale (left mul assumed).
    //----------------------------------------------------
    // XXX: NO SHEAR YET.

    /*
    Vector2Value *u = XyVector2(RealToNumber(matrix[0]),RealToNumber(matrix[1])); // a00, a01
    Vector2Value *v = XyVector2(RealToNumber(matrix[3]),RealToNumber(matrix[4])); // a10, a11
    Real uLength = NumberToReal(LengthVector2(u));
    Vector2Value *uStar;
    if(uLength < EPSILON  && uLength > -EPSILON) {
        uStar = zeroVector2; }
    else {
        Real oneOverULength = 1.0 / uLength;
        uStar = ScaleVector2Real(u, RealToNumber(oneOverULength));
    }
    if(xScale) *xScale = uLength;
    if(yScale) *yScale = NumberToReal(
        LengthVector2(
        MinusVector2Vector2(v,
        ScaleVector2Real(uStar,
        DotVector2Vector2(v,uStar)))));

    if(rot) {
        Assert( ((uStar->x) <= 1.0) && ((uStar->x) >= -1.0)  &&  "bad bad!");
        *rot = acos(uStar->x);
        if( asin(- uStar->y) < 0) *rot = - *rot;
    }
    */

    Real ux = matrix[0];
    Real uy = matrix[1]; // a00, a01
    Real vx = matrix[3];
    Real vy = matrix[4]; // a10, a11
    Real uStarx, uStary;

    Real uLength = sqrt(ux * ux + uy * uy);
    if(uLength < EPSILON  && uLength > -EPSILON) {
        uStarx = uStary = 0.0; }
    else {
        Real oneOverULength = 1.0 / uLength;
        uStarx = oneOverULength * ux;
        uStary = oneOverULength * uy;
    }
    if(xScale) *xScale = uLength;

    Real dotvuStar = vx * uStarx + vy * uStary;
    Real susx = uStarx * dotvuStar;
    Real susy = uStary * dotvuStar;

    Real mx = vx - susx;
    Real my = vy - susy;

    if(yScale) *yScale = sqrt(mx * mx + my * my);

    if(rot) {
        Assert( ((uStarx) <= 1.0) && ((uStarx) >= -1.0)  &&  "bad bad!");
        *rot = acos(uStarx);
        if( asin(- uStary) < 0) *rot = - *rot;
    }
}


DDSurface *
DirectDrawImageDevice::NewSurfaceHelper()
{
    DDSurface *targDDSurf = GetCompositingStack()->TargetDDSurface();

    if( !AllAttributorsTrue() ) {
        if(!GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX)) {

            GetTextureDDSurface(NULL,
                                _freeTextureSurfacePool,
                                _usedTextureSurfacePool,
                                -1,
                                -1,
                                notVidmem,
                                false,
                                &targDDSurf);

            _currentScratchDDTexture = targDDSurf;

            // Already have a reference on the usedPool, don't need
            // the one that GetTextureDDSurface() gave back to us.
            RELEASE_DDSURF(targDDSurf,
                           "Don't need extra reference",
                           this);

        } else {
            targDDSurf = GetCompositingStack()->ScratchDDSurface(doClear);
        }
    }

    return targDDSurf;
}

//-----------------------------------------------------
// R e n d e r  P r o j e c t e d  G e o m   I m a g e
//
// Takes a projectedgeomimage, its geometry and a
// camera.  figures out destination rectangle for the
// image and the src rectangle in camera coords.
// Then asks the D3D rendered to render the geometry
// with the camera from the camera box to the destination
// rectangle on the target surface.
//-----------------------------------------------------
void DirectDrawImageDevice::
RenderProjectedGeomImage(ProjectedGeomImage *img,
                         Geometry *geo,
                         Camera *cam)
{
    #if TEST_EXCEPTIONS
    static int bogus=0;
    bogus++;
    if( bogus > 20 ) {
        RaiseException_ResourceError("blah blah");
        bogus = 10;
    }
    #endif

    // The Alpha platform has too many problems with DX3.  Pass only if we have
    // DX6 available to us.

    // 3D is disabled on pre-DX3 systems.

    if (sysInfo.VersionD3D() < 3)
        RaiseException_UserError (E_FAIL, IDS_ERR_PRE_DX3);

    // CANT DO:
    // XFORM_COMPLEX, OPAC

    //
    // if there's NO complex, then we can do:
    // simple and crop
    // but... only if there's no negative scale!
    //

    bool doScale = false;
    if(GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX)) {
        if( !IsNegScaleTransform() ) {
            SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, TRUE);
            SetDealtWithAttrib(ATTRIB_CROP, TRUE);
            doScale = true;
        }
    }

    DDSurface *targDDSurf = NewSurfaceHelper();

    // if some attrib is left, and we've somehow left the
    // target set to Target... we set it to scratch.
    if( !AllAttributorsTrue() &&
        (targDDSurf == GetCompositingStack()->TargetDDSurface()) ) {
        targDDSurf = GetCompositingStack()->ScratchDDSurface();
    }

    Bbox2 cameraBox;
    RECT destRect;

    if( doScale ) {
        // Calculate bounding box after all transforms, etc...

        // intersect with viewport bbox because img's bbox
        // could be infinite.
        _boundingBox = IntersectBbox2Bbox2(
            _viewport.GetTargetBbox(),
            DoBoundingBox(UniverseBbox2));

        if( !_boundingBox.IsValid() ) return;

        // figure out dest size in pixels

        // a short term things for and ie beta2
        // drop.  TODO: remove and cleanup when we have a minute to breath.
        if(targDDSurf == _viewport._targetPackage._targetDDSurf ) {
            DoDestRectScale(&destRect, GetResolution(), _boundingBox, NULL);
        } else {
            DoDestRectScale(&destRect, GetResolution(), _boundingBox, targDDSurf);
        }

        targDDSurf->SetInterestingSurfRect(&destRect);

        // Now make a NEW bbox in camera coords that reflects 'destRect'.

        Real w = Pix2Real(_viewport.Width(), GetResolution()) / 2.0;
        Real h = Pix2Real(_viewport.Height(), GetResolution()) / 2.0;
        Real res = GetResolution();

        Bbox2 snappedBox(Pix2Real(destRect.left, res) - w,
                         Pix2Real(_viewport.Height() - destRect.bottom, res) - h,
                         Pix2Real(destRect.right, res) - w,
                         Pix2Real(_viewport.Height() - destRect.top, res) - h);


        // figure out src box in camera coords

        Transform2 *invXf = InverseTransform2(GetTransform());

        if (!invXf) return;

        cameraBox = TransformBbox2( invXf, snappedBox );

    } else {

        // we're going to keep this off for now simply because it won't
        // receive adequate test coverage in 20 minutes...
        //cameraBox = TransformBbox2( InverseTransform2(GetTransform()), _viewport.GetTargetBbox() );
        cameraBox = _viewport.GetTargetBbox();
        if( IsCompositeDirectly() &&
            targDDSurf == _viewport._targetPackage._targetDDSurf) {
            destRect = *(_viewport._targetPackage._prcViewport);
        } else {
            destRect = *(targDDSurf->GetSurfRect());
        }

    }

    // COMPOSITE
    // OK, now offset if compositing directly to target
    if( IsCompositeDirectly() &&
        targDDSurf == _viewport._targetPackage._targetDDSurf) {

        // compositing directly to target...

        if( doScale ) {
            DoCompositeOffset(targDDSurf, &destRect);
        }

        // Intersect with clip
        RECT clippedRect = destRect;

        if(_viewport._targetPackage._prcClip) {
            IntersectRect(&clippedRect,
                          &clippedRect,
                          _viewport._targetPackage._prcClip);
        }

        //
        // The dest bbox needs to be clipped in proportion to the destRect
        //
        RECT *origRect = &destRect;
        Real rDiff, boxh, boxw, percent;
        boxw = cameraBox.max.x - cameraBox.min.x;
        boxh = cameraBox.max.y - cameraBox.min.y;
        Real rectw = Real(WIDTH(origRect)) / GetResolution(),
             recth = Real(HEIGHT(origRect)) / GetResolution();

        if(clippedRect.left > origRect->left) {
            rDiff = Real(clippedRect.left -  origRect->left) / GetResolution();
            percent = rDiff / rectw;
            cameraBox.min.x += (percent * boxw);
        }
        if(clippedRect.right < origRect->right) {
            rDiff = Real(clippedRect.right -  origRect->right) / GetResolution();
            percent = rDiff / rectw;
            cameraBox.max.x += (percent * boxw);
        }
        if(clippedRect.top > origRect->top) {
            // positive diff mean the top fell
            rDiff = - Real(clippedRect.top -  origRect->top) / GetResolution();
            percent = rDiff / recth;
            cameraBox.max.y += (percent * boxh);
        }
        if(clippedRect.bottom < origRect->bottom) {
            rDiff = - Real(clippedRect.bottom -  origRect->bottom) / GetResolution();
            percent = rDiff / recth;
            cameraBox.min.y += (percent * boxh);
        }

        destRect = clippedRect;
    }

    GeomRenderer *gdev = _viewport.GetGeomDevice(targDDSurf);

    if (!gdev) return;
    // Ok hack for geom device not able to get itself back in a good
    // state after throwing an exception because surfacebusy or lost
    if ( ! gdev->ReadyToRender() ) {
        targDDSurf->DestroyGeomDevice();
        return;
    }


    #if 0
    // TEMP (debug)
    LONG hz, wz, hs, ws;
    // make sure zbuffer and surface are the same size
    GetSurfaceSize(targDDSurf->GetZBuffer()->Surface(), &wz, &hz);
    GetSurfaceSize(targDDSurf->Surface(), &ws, &hs);

    _viewport.ClearSurface(targDDSurf->Surface(), 0x1234, &destRect);

    ZeroMemory(&_bltFx, sizeof(_bltFx));
    _bltFx.dwSize = sizeof(_bltFx);
    _bltFx.dwFillDepth = 777;
    _ddrval = targDDSurf->GetZBuffer()->Surface()->
        Blt(&destRect, NULL, NULL, DDBLT_WAIT | DDBLT_DEPTHFILL, &_bltFx);

    // TEMP
    #endif

    #if 0
        // make sure zbuffer and surface are the same size
        LONG hz, wz, hs, ws;
        GetSurfaceSize(targDDSurf->Surface(), &ws, &hs);
        GetSurfaceSize(targDDSurf->GetZBuffer()->Surface(),
                       &wz, &hz);
        if((ws != wz) ||
           (hs != hz) ||
           (ws != targDDSurf->Width()) ||
           (hs != targDDSurf->Height())) {
            _asm { int 3 };
        }
   #endif

    gdev->RenderGeometry
        (this,
         destRect,          // Where to render the stuff on the surface
         geo,
         cam,
         cameraBox);        // what the camera renders


    // A bunch of texture surfaces have now been allocated and pushed
    // on the "used" stack.  Move them back to the 'free' stack.

    ReturnTextureSurfaces(_freeTextureSurfacePool, _usedTextureSurfacePool);
}

HRGN DirectDrawImageDevice::
CreateRegion(int numPts, Point2Value **pts, Transform2 *xform)
{
    PushDynamicHeap(*_scratchHeap);

    int i;
    Point2Value **destPts;

    if(xform) {
        destPts = (Point2Value **)AllocateFromStore(numPts * sizeof(Point2Value *));
        for(i=0; i<numPts; i++) {
            destPts[i] = TransformPoint2Value(xform, pts[i]);
        }
    } else {
        destPts = pts;
    }

    //
    // Map continuous image space to win32 coordinate space
    //

    POINT *gdiPts = (POINT *)AllocateFromStore(numPts * sizeof(POINT));
    for(i=0; i<numPts; i++) {
        gdiPts[i].x = _viewport.Width()/2 + Real2Pix(destPts[i]->x, GetResolution());
        gdiPts[i].y = _viewport.Height()/2 - Real2Pix(destPts[i]->y, GetResolution());
    }

    PopDynamicHeap();
    HeapReseter heapReseter(*_scratchHeap);

    //
    // Create a region in Windows coordinate space
    //

    HRGN region;
    TIME_GDI( region = CreatePolygonRgn(gdiPts, numPts, ALTERNATE) );
    if(!region) {
        TraceTag((tagError, "Couldn't create polygon region"));
    }

    return region;
}

Bool DirectDrawImageDevice::
DetectHit(HRGN region, Point2Value *pt)
{
    Assert(region && pt && "Bad region in DDImageDev->DetectHit()");

    int x = _viewport.Width()/2 + Real2Pix(pt->x, GetResolution());
    int y = _viewport.Height()/2 - Real2Pix(pt->y, GetResolution());

    Bool ret;
    TIME_GDI(ret = PtInRegion(region, x, y));

    return ret;
}


DDSurface *DirectDrawImageDevice::
LookupSurfaceFromDiscreteImage(DiscreteImage *image,
                               bool bForCaching,
                               Image **pImageCacheBase,
                               bool bAlphaSurface)
{
    DDSurfPtr<DDSurface> discoDDSurf;

    discoDDSurf = GetSurfaceMap()->LookupSurfaceFromImage(image);

    // is it a directdrawsurfaceimage ?
    DirectDrawSurfaceImage *ddsImg = NULL;
    if (image->CheckImageTypeId(DIRECTDRAWSURFACEIMAGE_VTYPEID)) {
        ddsImg = SAFE_CAST(DirectDrawSurfaceImage *, image);

        if( (ddsImg->GetCreationID() == PERF_CREATION_ID_BUILT_EACH_FRAME) &&
            discoDDSurf)
          {
              DAComPtr<IDDrawSurface> idds;
              ddsImg->GetIDDrawSurface( &idds );
              discoDDSurf->SetSurfacePtr( idds );

              DAComPtr<IDXSurface> idxs;
              ddsImg->GetIDXSurface( &idxs );
              if( idxs ) {
                  discoDDSurf->SetIDXSurface( idxs );
              }
          }
    }


    if (discoDDSurf) {
        return discoDDSurf;
    }

    // Must be called before we continue on.
    image->InitializeWithDevice(this, GetResolution());

    bool cacheSucceeded = false;

    if (pImageCacheBase && *pImageCacheBase) {

        // Look it up based on the cache we want to reuse
        discoDDSurf =
            GetSurfaceMap()->LookupSurfaceFromImage(*pImageCacheBase);

        // If we found one, be sure it's the right size.
        if (discoDDSurf &&
            (discoDDSurf->Width() < image->GetPixelWidth() ||
             discoDDSurf->Height() < image->GetPixelHeight())) {

            // Can't used the cached image...
            discoDDSurf = NULL;

        } else {

            cacheSucceeded = true;

        }
    }

    if (!discoDDSurf) {

        DAComPtr<IDDrawSurface> surface;
        image->GetIDDrawSurface(&surface);

        if( bAlphaSurface ) {

            Assert(!surface);
            // this is intended only for cached surfaces

            DDPIXELFORMAT pf;
            ZeroMemory(&pf, sizeof(pf));
            pf.dwSize = sizeof(pf);
            pf.dwFlags = DDPF_RGB;
            pf.dwRGBBitCount = 32;
            pf.dwRBitMask        = 0x00ff0000;
            pf.dwGBitMask        = 0x0000ff00;
            pf.dwBBitMask        = 0x000000ff;
            pf.dwRGBAlphaBitMask = 0x00000000;

            // TEMP TMEP
            TraceTag((tagError, "cache img w,h = (%d, %d)\n",
                      image->GetPixelWidth(),
                      image->GetPixelHeight()));

            if( (image->GetPixelWidth() > 1024) ||
                (image->GetPixelHeight() > 1024) ) {
                RaiseException_SurfaceCacheError("Requested cache size is too large");
            }

            _viewport.CreateSizedDDSurface(& discoDDSurf,
                                           pf,
                                           image->GetPixelWidth(),
                                           image->GetPixelHeight(),
                                           NULL,
                                           notVidmem);

            //DWORD colorKey;
            //bool colorKeyValid = image->ValidColorKey(surface, &colorKey);
            //if(colorKeyValid) discoDDSurf->SetColorKey(colorKey);

            discoDDSurf->SetBboxFromSurfaceDimensions(GetResolution(), true);

            // force creation of an idxsurface
            discoDDSurf->GetIDXSurface( _viewport._IDXSurfaceFactory );

        } else
        if( !surface ) {

                DDSURFACEDESC       ddsd;
                //
                // create a DirectDrawSurface for this bitmap
                //
                ZeroMemory(&ddsd, sizeof(ddsd));
                ddsd.dwSize = sizeof(ddsd);
                ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
                ddsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_3DDEVICE; // can be used as texture
                ddsd.dwWidth  = image->GetPixelWidth();
                ddsd.dwHeight = image->GetPixelHeight();
                ddsd.ddpfPixelFormat = GetSurfaceMap()->GetPixelFormat();
                ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

                // TODO: Should come back and base the size on the amount
                // of physical memory
                // Put a hard limit for now on what we are willing to cache
                // This must be less that 2K x 2K to catch a D3D limitation.
                if(bForCaching &&
                   (ddsd.dwWidth > 1024 || ddsd.dwHeight > 1024)) {
                    RaiseException_SurfaceCacheError("Requested cache size is too large");
                }

                // TODO XXX: ok, the right way to do this is try it first,
                // if it fails because of size constraints take it out of
                // vidmem (if it's there), if systemmem doesn't work, then
                // we need to tile this image somehow, or scale it down to
                // fit the biggest surface (loosing fidelity)...

                // We also know that D3D on Win95 also has this hard limit
                // but since we cannot determine here whether we are going
                // to use it for 3D we will just catch the error later on.

                if( sysInfo.IsNT() ) {

                    // These are the limits Jeff Noyle suggested for nt4, sp3
                    if((ddsd.dwWidth > 2048 ||  ddsd.dwHeight > 2048)) {
                        RaiseException_SurfaceCacheError("Requested (import or cache) image too large to fit in memory (on NT4 w/ sp3)");
                    }
                }

                if((ddsd.dwWidth <= 0 ||  ddsd.dwHeight <= 0)) {
                    TraceTag((tagError, "Requested surface size unacceptable (requested: %d, %d)",
                              ddsd.dwWidth, ddsd.dwHeight));
                    //Assert(FALSE && "Image size <0 in LookupSurfaceFromImage.  should never happen!");
                    RaiseException_SurfaceCacheError("Invalid size (<0) requested (import or cache) image");

                }

                if( (ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) ) {

                    if((ddsd.dwWidth > 1024 ||  ddsd.dwHeight > 1024)) {
                        TraceTag((tagError, "Requested surface size unacceptable (requested: %d, %d)",
                                  ddsd.dwWidth, ddsd.dwHeight));
                        RaiseException_SurfaceCacheError("Requested surface size unacceptable");
                    }
                }

                TraceTag((tagDiscreteImageInformative,
                          "Creating surface (%d, %d) for Discrete Image %x",
                          ddsd.dwWidth, ddsd.dwHeight, image));

                #if _DEBUG
                char errStr[1024];
                wsprintf(errStr, "Discrete Image (%d, %d)\n",  ddsd.dwWidth, ddsd.dwHeight);
                #else
                char *errStr = NULL; // will be exunged by compiler
                #endif

                _ddrval = _viewport.CREATESURF( &ddsd, &surface, NULL, errStr );
                if( FAILED(_ddrval) ) {
                    if( ddsd.ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) {
                        if( _ddrval == DDERR_INVALIDPARAMS ||
                            _ddrval == DDERR_OUTOFMEMORY ) {
                            RaiseException_SurfaceCacheError("Requested (import or cache) image too large to fit in memory");
                        }
                    } else {
                        Assert(FALSE && "Need to handle failure on VIDEOMEMORY surfaces");
                        RaiseException_SurfaceCacheError("Need to handle failure on VIDEOMEMORY surfaces");
                    }
                }

                Assert(surface);

        } // if !surface

        // if there's a surface already (above if(!surface)) and we're
        // not doing bAlphaSurface create a DDSurface wrapper with all
        // the trimmings
        if( !bAlphaSurface ) {

            DWORD colorKey;
            bool colorKeyValid = image->ValidColorKey(surface, &colorKey);

            // Ok, here we get the idxsurface FROM the ddsImg
            // (directDrawSurfaceImage).  If this image has been created
            // by the dxtransform image (see dxxf.cpp), then it will
            // contain an idxsurface in addition to an iddsurface.  We
            // grab the idxsurface and shove it in the discoDDSurf so that
            // during simpleTransformCrop we can check the srcDDSurf for
            // an idxsurface, if it has one we use dx2d->Blt() to do a
            // scaled per pixel alpha blit.
            DAComPtr<IDXSurface> idxs;
            if( ddsImg ) {
                // it's a direct draw surface image.
                // check to see if it has an idxsurface associated with
                // it.

                ddsImg->GetIDXSurface( &idxs );
                if( idxs ) {
                    colorKeyValid = false;
                    colorKey = -1;
                }
            }

            NEWDDSURF(&discoDDSurf,
                      surface,
                      image->BoundingBox(),
                      image->GetRectPtr(),
                      image->GetResolution(),
                      colorKey,
                      colorKeyValid,
                      false, false,
                      "DiscreteImage Surface");

            if( idxs ) {
                discoDDSurf->SetIDXSurface( idxs );
            }

        } // if !bAlphaSurface

        // surface release on exit scope

    }// if(!discoDDSurf)

    // Always do this stuff...
    if (image->NeedColorKeySetForMe()) {
        if(!bAlphaSurface) {
            // clear the surface first, set the color key
            _viewport.ClearDDSurfaceDefaultAndSetColorKey(discoDDSurf);
        } else {
            _viewport.ClearSurface(discoDDSurf, cacheClrKey, NULL);
        }
    }

    GetSurfaceMap()->StashSurfaceUsingImage(image, discoDDSurf);

    //
    // Tell the discrete image to drop the bits into this surface
    // Intented to be a one time operation
    //
    image->InitIntoDDSurface(discoDDSurf, this);

    // If there is a cache addr to fill in, and the previous cache
    // hadn't succeeded, then cache according to this new image.
    if (pImageCacheBase && !cacheSucceeded) {
        *pImageCacheBase = image;
    }

    return discoDDSurf;
}

bool
IsComplexTransformWithSmallRotation(Real e,
                                    Transform2 *xf,
                                    Bool complexAttributeSet,
                                    bool *pDirtyRectsDisablingScale)
{
    Real m[6];
    xf->GetMatrix(m);

    Real scx = m[0];
    Real scy = m[4];

    // Disable dirty rects if we're scaling down (or it's a negative
    // scale) because of visual instability with blitting subrects of
    // scaled images under known blitters (GDI, DDraw, Dx2D).  When we
    // find a blitter that this will work for, remove this hack.

    if ((scx < 1.0 - e) || (scy < 1.0 - e)) {

        *pDirtyRectsDisablingScale = true;

    } else {

        // Also disable dirty rects on non-NT if we're scaling up.  On
        // NT, the GDI blitter is good at scaling up.  It doesn't
        // appear to be on W95.
        if (!sysInfo.IsNT() && ((scx > 1.0 + e) || (scy > 1.0 + e))) {
            *pDirtyRectsDisablingScale = true;

        } else {

            *pDirtyRectsDisablingScale = false;

        }
    }


    // This will see if it is not oriented either 180 or 0 degrees
    if ( (m[1] > e) || (m[1] < -e)  ||
         (m[3] > e) || (m[3] < -e) )
    {
        return true;
    }

    // If it's a rot by 180, the scale compenents are -1.
    // However, that's not enough, we also need to know if the
    // transform stack has a complex transform ..somewhere...
    // If so, then we're guaranteed NOT to return a false positive, ie
    // telling the client of this call that it's a complex xf when in
    // fact it's just a -1,-1 scale (or -A,-B).

    if ( (scx < 0 && scy < 0) &&
         complexAttributeSet )
    {
        return true;
    }

    return false;

}

//-----------------------------------------------------
// R e n d e r  D i b
//
// Given a discrete image, get's the image's dd surface.
// Figures out src and destination rectangle in terms
// of src and destination surfaces (discrete surf & target
// surf, respectively).  Then blits.
//-----------------------------------------------------
void DirectDrawImageDevice::
RenderDiscreteImage(DiscreteImage *image)
{
    Bool cmplxAttrSet = !GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX);

    SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, TRUE);
    SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, TRUE);
    SetDealtWithAttrib(ATTRIB_CROP, TRUE);

    // FIX XXX TODO: optimization, can do opac too if not complex
    //SetDealtWithAttrib(ATTRIB_OPAC, TRUE);

    // do I really need this ?
    if(IsFullyClear()) return;

    DDSurface *srcDDSurf = LookupSurfaceFromDiscreteImage(image);
    Assert(srcDDSurf && "Couldn't create a surface for discrete image! (too big ??)");

    DDSurface *destDDSurf = GetCompositingStack()->TargetDDSurface();

    bool dirtyRectDisablingScale;
    Bool isComplex =
        ::IsComplexTransformWithSmallRotation(EPSILON,
                                              GetTransform(),
                                              cmplxAttrSet,
                                              &dirtyRectDisablingScale);

    if (dirtyRectDisablingScale && !_alreadyDisabledDirtyRects) {
        GetCurrentView().DisableDirtyRects();
        _alreadyDisabledDirtyRects = true;
    }

    if( !AllAttributorsTrue() ) {
        destDDSurf = GetCompositingStack()->ScratchDDSurface(doClear);
    }

    if( isComplex ) {
        RenderDiscreteImageComplex(image,
                                   srcDDSurf,
                                   destDDSurf);
    } else {
        RenderSimpleTransformCrop(srcDDSurf,
                                  destDDSurf,
                                  srcDDSurf->ColorKeyIsValid());
    }
}

#define NO_SOLID 0

//-----------------------------------------------------
// R e n d e r  S o l i d  C o l o r  I m a g e
//
// Give a real color, find the corresponding color
// for the pixel format of the destination surface
// and do the blit.
//-----------------------------------------------------
void DirectDrawImageDevice::
RenderSolidColorImage(SolidColorImageClass& img)
{
    #if TEST_EXCEPTIONS
    static int foo=0;
    foo++;
    if( foo > 20 ) {
        RaiseException_ResourceError("blah blah");
        foo=10;
    }
    #endif

    #if NO_SOLID
    //////////////////////////////////////////
    ResetAttributors();
    return;
    //////////////////////////////////////////
    #endif


    RECT r;
    RECT tempDestRect;          // needs to have same lifetime as the function
    RECT *destRect = &r;

    if(!IsCropped())  {
        // If we're not cropped, we can do complex xf

        SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, TRUE);
    }

    SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, TRUE);
    SetDealtWithAttrib(ATTRIB_CROP, TRUE);

    if(GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX)) {
        // no complex xf, we can do opacity.
        SetDealtWithAttrib(ATTRIB_OPAC, TRUE);
    } else {
        // complex xf, call 3D rendering to render.
        SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, TRUE);

        DDSurface *targDDSurf;
        if(!AllAttributorsTrue()) {
            targDDSurf = GetCompositingStack()->ScratchDDSurface();
        } else {
            targDDSurf = GetCompositingStack()->TargetDDSurface();
        }

        Bbox2 box = DoBoundingBox(img.BoundingBox(),do_crop);

        BoundingPolygon *polygon = NewBoundingPolygon(box);
        DoBoundingPolygon(*polygon);
        polygon->Crop( targDDSurf->Bbox() );

        Color *c1[1];
        c1[0] = img.GetColor();

        Render3DPolygon(NULL, targDDSurf, polygon, NULL, c1, true);

        return;
    }

    DDSurface *targDDSurf;
    if(!AllAttributorsTrue()) {
        targDDSurf = GetCompositingStack()->ScratchDDSurface();
    } else {
        targDDSurf = GetCompositingStack()->TargetDDSurface();
    }

    //
    // If the image is cropped and the transform is
    // simple, figure out the destRect
    //
    if(IsCropped())  {
        // -- Compute accumulated bounding box  --

        Bbox2 box = IntersectBbox2Bbox2(
            _viewport.GetTargetBbox(),
            DoBoundingBox(img.BoundingBox()));

        // -- Validate Bounding Box --

        if( !box.IsValid() ) return;

        // -- Figure out destination rectangle --

        DoDestRectScale(destRect, GetResolution(), box);

    } else {

        // Don't want to pass along a reference to the client rect,
        // since we don't want to modify it.  Therefore, just copy
        // it.

                tempDestRect = _viewport._clientRect;
        destRect = &tempDestRect;

    }

    // COMPOSITE
    DoCompositeOffset(targDDSurf, destRect);

    if( ! IsFullyOpaque())
    {
        //TraceTag((tagError, "SolidColorImage: alpha clr %x\n",_viewport.MapColorToDWORD(img.GetColor())));


        //
        // Clip manually for alpha blit
        //
        if( IsCompositeDirectly() &&
            targDDSurf == _viewport._targetPackage._targetDDSurf ) {
            IntersectRect(destRect, destRect,
                          _viewport._targetPackage._prcViewport);
            if(_viewport._targetPackage._prcClip) {
                IntersectRect(destRect, destRect,
                              _viewport._targetPackage._prcClip);
            }
        }

        //
        // use our own alpha blit for single color src
        //
        TIME_ALPHA(AlphaBlit(targDDSurf->IDDSurface(),
                             destRect,
                             GetOpacity(),
                             _viewport.MapColorToDWORD(img.GetColor())));
    }
    else
    {
        //TraceTag((tagError, "SolidColorImage:  clr %x\n",_viewport.MapColorToDWORD(img.GetColor())));
        //
        // regular blit
        //

        // -- Prepare the bltFX struct

        ZeroMemory(&_bltFx, sizeof(_bltFx));
        _bltFx.dwSize = sizeof(_bltFx);
        _bltFx.dwFillColor = _viewport.MapColorToDWORD(img.GetColor());

        /*
        ///Assert(FALSE);
        char buf[256];
        sprintf(buf, "SolidColorBlit clolor:%x (%d,%d) to %x",
                _bltFx.dwFillColor,
                WIDTH(destRect),
                HEIGHT(destRect),
                targDDSurf->IDDSurface());
        ::MessageBox(NULL, buf, "Property Put", MB_OK);
        */

        // -- Blit
        if(GetImageQualityFlags() & CRQUAL_MSHTML_COLORS_ON) {
            _ddrval = RenderSolidColorMSHTML(targDDSurf, img, destRect);
        }
        else {
            TIME_DDRAW(_ddrval = targDDSurf->ColorFillBlt(destRect, DDBLT_WAIT | DDBLT_COLORFILL, &_bltFx));
        }

        if(_ddrval != DD_OK && _ddrval != DDERR_INVALIDRECT) {

            if (_ddrval == DDERR_SURFACEBUSY)
            {   RaiseException_UserError
                    (DAERR_VIEW_SURFACE_BUSY, IDS_ERR_IMG_SURFACE_BUSY);
            }

            printDDError(_ddrval);
            TraceTag((tagError, "ImgDev: %x. blt failed solidColorImage %x: destRect:(%d,%d,%d,%d)",
                      this, &img,
                      destRect->left, destRect->top,
                      destRect->right, destRect->bottom));
            TraceTag((tagError,"Could not COLORFILL blt in RenderSolidColorImage"));
        }
    }

    targDDSurf->SetInterestingSurfRect(destRect);
}

//-----------------------------------------------------
// E n d   E n u m   T e x t u r e   F o r m a t s
//
// Analyses what we decided to keep from EnumTextureFormats
// and makes sure the info is valid.  Sets some state info
// and prepares a the texture surface.  Decides on texture
// format.
//-----------------------------------------------------
void DirectDrawImageDevice::
EndEnumTextureFormats()
{
    _textureContext.isEnumerating = FALSE;

    _textureContext.ddsd.dwFlags |= DDSD_PIXELFORMAT;
    _textureContext.ddsd.ddpfPixelFormat = _viewport._targetDescriptor._pixelFormat;
    _textureContext.useDeviceFormat = TRUE;
    _textureContext.ddsd.ddsCaps.dwCaps |= DDSCAPS_TEXTURE;
    _textureContext.sizeIsSet = FALSE;
    _textureWidth = DEFAULT_TEXTURE_WIDTH;
    _textureHeight = DEFAULT_TEXTURE_HEIGHT;

    //
    // Make sure everything is ok
    //
    Assert((_textureContext.ddsd.ddsCaps.dwCaps & DDSCAPS_TEXTURE) && "not texture!");
    Assert((_textureContext.ddsd.ddsCaps.dwCaps & DDSD_PIXELFORMAT) && "_textureContext pixelformat not set");

    _textureContext.isValid = TRUE;

    //
    // Dump some information about the final texture format
    //
    TraceTag((tagImageDeviceInformative, "Final Texture Format is: depth=%d, R=%x, G=%x, B=%x",
              _textureContext.ddsd.ddpfPixelFormat.dwRGBBitCount,
              _textureContext.ddsd.ddpfPixelFormat.dwRBitMask,
              _textureContext.ddsd.ddpfPixelFormat.dwGBitMask,
              _textureContext.ddsd.ddpfPixelFormat.dwBBitMask));

    TraceTag((tagImageDeviceInformative, "Final Texture Format is %s device format",
              _textureContext.useDeviceFormat ? "identical to" : "different from"));
}

//-----------------------------------------------------
// P r e p a r e   D 3 D   T e x t u r e   S u r f a c e
//
// Given a pointer to a surf ptr & widht & height (optional)
// this function creates a surface with in the format D3D
// wants for textures, using the _textureContext structure
// which was filled by the EnumTextureFormats functions.
//-----------------------------------------------------
void DirectDrawImageDevice::
PrepareD3DTextureSurface(
    LPDDRAWSURFACE *surf,  // out
    RECT *rect,  // out
    DDPIXELFORMAT &pf,
    DDSURFACEDESC *desc,
    bool attachClipper)
{
    Assert(_textureContext.isValid && "Texture Context not valid in prepareD3DTextureSurface");
    Assert(surf != NULL && "Bad surf ptr passed into PrepareD3DTextureSurface");

    DDSURFACEDESC D3DTextureDesc = _textureContext.ddsd;
    DDSURFACEDESC *textureDesc;
    if(!desc) {
        textureDesc = &D3DTextureDesc;
    } else {
        textureDesc = desc;
    }

    textureDesc->dwFlags |= DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
    textureDesc->ddsCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_3DDEVICE;

    textureDesc->ddsCaps.dwCaps &=
        ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_SYSTEMMEMORY | DDSCAPS_OFFSCREENPLAIN);

    if (g_preference_UseVideoMemory)
        textureDesc->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
    else
        textureDesc->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

    textureDesc->dwFlags |= DDSD_PIXELFORMAT;
    textureDesc->ddpfPixelFormat = pf;

    // ------------------------------------------------------
    // Set up the D3DTextureDesc (SurfaceDescriptor) for an acceptable
    // texture format in preparation to blit the source texture image to it
    // ------------------------------------------------------
    if(_textureContext.sizeIsSet == FALSE) {

        if(!desc) {
            textureDesc->dwWidth  = _textureWidth;
            textureDesc->dwHeight = _textureHeight;
        }

        TraceTag((tagImageDeviceInformative,
                  "Set textureDesc.[dwWidth,dwHeight] to (%d,%d) <for Image texture>\n",
                  textureDesc->dwWidth, textureDesc->dwHeight));
    }

    *surf = 0;

    if(rect) {
        SetRect(rect, 0,0,
                textureDesc->dwWidth,
                textureDesc->dwHeight);
    }
    //
    // Create a surface according to the derived textureDesc.
    //
    _viewport.CreateSpecialSurface(surf,
                                   textureDesc,
                                   "Could not create texture surface");

    //
    // Create and set clipper on surface!
    //
    if( attachClipper ) {
        LPDIRECTDRAWCLIPPER D3DTextureClipper = NULL;
        RECT D3DTextureRect;

        SetRect(&D3DTextureRect, 0,0,  textureDesc->dwWidth, textureDesc->dwHeight);
        _viewport.CreateClipper(&D3DTextureClipper);
        _viewport.SetCliplistOnSurface(*surf, &D3DTextureClipper, &D3DTextureRect);
        // We need to release the clipper ( get the ref count set) so that when the
        // surface is released, the clipper will automatically get released.
        D3DTextureClipper->Release();
    }
}


//-----------------------------------------------------
// R e f o r m a t   S u r f a c e
//
// Give a src and dest surface, this function color converts
// and stretches the src surface into the destination surface's
// format and size.  Used primarily for animated textures
// when the device surface format differs from D3D's texture format
//-----------------------------------------------------
Bool DirectDrawImageDevice::
ReformatSurface(LPDDRAWSURFACE destSurf, LONG destWidth, LONG destHeight,
                LPDDRAWSURFACE srcSurf, LONG srcWidth, LONG srcHeight,
                DDSURFACEDESC *srcDesc)
#if 0
		DWORD srcKey,
		bool srcKeyValid,
		DWORD *destClrKey)
#endif
{
    if( srcDesc ) {
        RECT srcRect;
        SetRect(&srcRect,0,0,srcWidth, srcHeight);

        RECT destRect;
        SetRect(&destRect,0,0,destWidth, destHeight);

        // Blit to take care of any scales needed!
        TIME_DDRAW(_ddrval = destSurf->Blt(&destRect, srcSurf, &srcRect, DDBLT_WAIT, NULL));
	if( _ddrval != DDERR_UNSUPPORTED ) {

	  IfDDErrorInternal(_ddrval, "Reformat Surface: Couldn't blit resize surface!");

	} else {

	  //
	  // seems like we should color convert!
	  //

	  // NEXT CHECKIN
#if 0
	  // Convert color key.  works only for 32bpp source surface for now
	  if( srcKeyValid & destClrKey ) {
	    COLORREF ref;
	    DDPIXELFORMAT pf; pf.dwSize = sizeof(DDPIXELFORMAT);
	    srcSurf->GetPixelFormat(&pf);
	    if( pf.dwRGBBitCount == 32 ) {
	      ref = RGB(
			srcKey & pf.dwRBitMask,
			srcKey & pf.dwGBitMask,
			srcKey & pf.dwBBitMask );
	      *destClrKey = DDColorMatch(destSurf, ref);
	    }
	  }
#endif

	  Assert( destSurf != srcSurf );

	  HDC destDC;
	  _ddrval = destSurf->GetDC(&destDC);
	  if( _ddrval == DDERR_SURFACELOST ) {
            _ddrval = destSurf->Restore();
            if( SUCCEEDED( _ddrval ) ) // try again
	      _ddrval = destSurf->GetDC(&destDC);
	  }
	  IfDDErrorInternal(_ddrval, "Couldn't get dc on dest surf");

	  HDC srcDC;
	  _ddrval = srcSurf->GetDC(&srcDC);
	  if( _ddrval == DDERR_SURFACELOST ) {
            _ddrval = srcSurf->Restore();
            if( SUCCEEDED( _ddrval ) ) // try again
	      _ddrval = srcSurf->GetDC(&srcDC);
	  }

	  if( FAILED( _ddrval ) ) {
	    destSurf->ReleaseDC( destDC );
	  }

	  IfDDErrorInternal(_ddrval, "Couldn't get dc on src surf");

	  BOOL ret;
	  TIME_GDI(ret = StretchBlt(destDC,
				    0,0,destWidth, destHeight,
				    srcDC,
				    0,0,srcWidth, srcHeight,
				    SRCCOPY));
	  
	  srcSurf->ReleaseDC( srcDC ) ;
	  destSurf->ReleaseDC( destDC ) ;

	  if( !ret ) {
	    // TODO: fail
	    return false;
	  }
	} // else

    } // if srcDesc

    return TRUE;
}



//-----------------------------------------------------
// G e t   T e x t u r e   S u r f a c e
//
// Grabs a texture surface from a pool of unused
// texture surfaces.  These are returned to the
// free pool after every geometry rendering
// Return it addref'd.
//-----------------------------------------------------
void DirectDrawImageDevice::
GetTextureDDSurface(DDSurface *preferredSurf,
                    SurfacePool *sourcePool,
                    SurfacePool *destPool,
                    DWORD prefWidth,
                    DWORD prefHeight,
                    vidmem_enum vid,
                    bool usePreferedDimensions,
                    DDSurface **pResult)
{
    DDSurfPtr<DDSurface> ddSurf;
    LPDDRAWSURFACE surf;
    RECT rect;

    if( usePreferedDimensions ) {
        // grab a size compatible surface.
        // NOTE: this creates one if needed...
        sourcePool->FindAndReleaseSizeCompatibleDDSurf(
            preferredSurf,
            prefWidth,
            prefHeight,
            vid,
            NULL,
            &ddSurf );

        if( !ddSurf ) {
            DDSURFACEDESC desc;
            memset(&desc, 0, sizeof(desc));
            desc.dwSize = sizeof(desc);
            desc.dwFlags = DDSD_WIDTH | DDSD_HEIGHT;
            desc.dwWidth = prefWidth;
            desc.dwHeight = prefHeight;
            PrepareD3DTextureSurface(&surf, &rect,
                                     sourcePool->GetPixelFormat(),
                                     &desc, false);
        }
    } else {
        // gives me its reference...
        sourcePool->PopSurface( &ddSurf );

        if( !ddSurf ) {
            PrepareD3DTextureSurface(&surf, &rect, sourcePool->GetPixelFormat());
        }
    }

    if(ddSurf) {
        // we're done...
    } else {
        // otherwise, one has been created..

        Real w = Pix2Real(rect.right - rect.left, GetResolution());
        Real h = Pix2Real(rect.bottom - rect.top, GetResolution());

        Bbox2 box(- w * 0.5, - h * 0.5,
                    w * 0.5,   h * 0.5);

        NEWDDSURF(&ddSurf,
                  surf,
                  box,
                  &rect,
                  GetResolution(),
                  0, false,
                  false, false,
                  "TextureSurface");

        ddSurf->SetIsTextureSurf(true);

        surf->Release(); // release my ref to surf
    }

    _viewport.ClearDDSurfaceDefaultAndSetColorKey(ddSurf);

    if (destPool) {
        // XXX: could be smarter about texture surface managment by
        // xxx: reusing texture surfaces when we can.
        destPool->AddSurface(ddSurf);

        // lend a copy of the destPool's reference
    }

    ADDREF_DDSURF(ddSurf, "GetTextureDDSurface", this);
    *pResult = ddSurf;
}

//-----------------------------------------------------
// R e t u r n   T e x t u r e   S u r f a c e
//
// Returns a texture surface to the pool of unused surfs
//-----------------------------------------------------
void DirectDrawImageDevice::
ReturnTextureSurfaces(SurfacePool *freePool,
                      SurfacePool *usedPool)
{
    Assert((freePool && usedPool) || (!freePool && !usedPool));

    if(freePool && usedPool) {
        freePool->CopyAndEmpty(usedPool);
    }
}

//-----------------------------------------------------
// R e n d e r   I m a g e   F o r   T e x t u r e
//
// Renders an image onto some surface and returns a pointer
// to that surface for use by whoever for that frame.
// 'region' isn't used now.
//-----------------------------------------------------
DDSurface *
DirectDrawImageDevice::RenderImageForTexture(
    Image *image,
    int pixelsWide,
    int pixelsHigh,
    DWORD *colorKey,
    bool *clrKeyIsValid,
    bool &old_static_image,
    bool doFitToDimensions,
    SurfacePool *srcPool,
    SurfacePool *dstPool,
    DDSurface   *preferredSurf,
    bool        *pChosenSurfFromPool, // out
    DDSurface  **pDropSurfHereWithRefCount,   // out
    bool         upsideDown)
{
    DDSurface *resultSurf = NULL;

    if (pChosenSurfFromPool) {
        *pChosenSurfFromPool = false;
    }

    old_static_image = false;

    DiscreteImage *discoPtr =
        image->CheckImageTypeId(DISCRETEIMAGE_VTYPEID)?
        SAFE_CAST(DiscreteImage *,image):
        NULL;

    SurfaceMap *surfMapToUse;
    if (upsideDown) {
        surfMapToUse = _viewport._imageUpsideDownTextureSurfaceMap;
    } else {
        surfMapToUse = _viewport._imageTextureSurfaceMap;
    }

    //
    // TODO
    // XXX: all this code should be collected into one common path
    // XXX: since a dicrete image is a movie, a dib, and a cached image
    // TODO
    //

    if (image->CheckImageTypeId(MOVIEIMAGE_VTYPEID) ||
        image->CheckImageTypeId(MOVIEIMAGEFRAME_VTYPEID))
    {
        MovieImageFrame *frame;
        MovieImage *movie;
        if(image->CheckImageTypeId(MOVIEIMAGE_VTYPEID)) {
            movie = SAFE_CAST(MovieImage *,image);
            frame = GetMovieImageFrame();
        } else {
            frame = SAFE_CAST(MovieImageFrame *,image);
            movie = frame->GetMovieImage();
        }

        Real time = frame->GetTime();

        // @@@ organize texture sources...
        // associate this image with a texture surf...
        DDSurfPtr<DDSurface> mvDDSurf = surfMapToUse->LookupSurfaceFromImage(movie);

        if(!mvDDSurf) {
            DDSURFACEDESC movieDesc;
            ZeroMemory(&movieDesc, sizeof(movieDesc));
            movieDesc.dwSize = sizeof(movieDesc);

            //
            // create one
            //
            movieDesc.dwWidth  = pixelsWide;
            movieDesc.dwHeight = pixelsHigh;
            LPDDRAWSURFACE movieTextureSurf;
            RECT rect;

            PrepareD3DTextureSurface (&movieTextureSurf, &rect,
                                      surfMapToUse->GetPixelFormat(),
                                      &movieDesc);

            Real rw = Pix2Real(pixelsWide, GetResolution());
            Real rh = Pix2Real(pixelsHigh, GetResolution());
            Bbox2 box(-rw/2.0, -rh/2.0, rw/2.0, rh/2.0);

            NEWDDSURF(&mvDDSurf,
                      movieTextureSurf,
                      box,
                      &rect,
                      GetResolution(),
                      0, false,
                      false, false,
                      "Movie Texture Surface");

            mvDDSurf->SetIsTextureSurf( true );

            movieTextureSurf->Release(); // rel my ref
            movieTextureSurf = NULL;

            //
            // Stash the texture surface in the image map
            //
            surfMapToUse->StashSurfaceUsingImage(movie, mvDDSurf);
        }

        RenderMovieImage(movie, time, frame->GetPerf(), false, mvDDSurf);

        // if texture is supposed to be upside down, flip it now
        if (upsideDown) {
            mvDDSurf->MirrorUpDown();
        }

        resultSurf = mvDDSurf;

    } else if(discoPtr) {

        //
        // Lookup surface in _imageMap: XXX INEFFICIENT!
        //
        DDSurface *srcDDSurface = LookupSurfaceFromDiscreteImage(discoPtr);
        Assert(srcDDSurface && "LookupSurfaceFromDiscreteImage() failed in RenderImageForTexture");

        #if 0
        // raise exception if trying to texture dxtransform output
        if( srcDDSurface->HasIDXSurface() ) {
            RaiseException_UserError(DAERR_DXTRANSFORM_UNSUPPORTED_OPERATION,
                                     IDS_ERR_IMG_BAD_DXTRANSF_USE);
        }
        #endif


        LPDDRAWSURFACE discoSurf = srcDDSurface->IDDSurface();

        // Late binding for chroma keys on discrete images
        // should only bind once (but can bind multiple times when we
        // properly leverage the 2ndary color key stuff...) and should
        // never bind to color keyed gifs or imported images with
        // early bound color keys or importeddirectdrawsurface images
        // with color keyes set.
        {
            // use the key set on the device if there's one
            if ( ColorKeyIsSet() )
              {
                  if ( !(srcDDSurface->ColorKeyIsValid()) ||
                       discoPtr->HasSecondaryColorKey() )
                    {
                        Color *daKey = GetColorKey();
                        DWORD clrKey = _viewport.MapColorToDWORD( daKey );
                        // Set it on the surfaces!
                        srcDDSurface->SetColorKey( clrKey );
                        discoPtr->SetSecondaryColorKey( clrKey );
                    }
              }
        }

        DDSURFACEDESC discoDesc;

        //
        // Try to find the texture surface
        //
        DDSurfPtr<DDSurface> ddTxtrSurf;
        ddTxtrSurf = surfMapToUse->LookupSurfaceFromImage(discoPtr);

        if( ddTxtrSurf ) {

            old_static_image = true;

        } else {

            ZeroMemory(&discoDesc, sizeof(discoDesc));
            discoDesc.dwSize = sizeof(discoDesc);
            _ddrval = discoSurf->GetSurfaceDesc(&discoDesc);
            IfDDErrorInternal(_ddrval, "Failed on GetSurfaceDesc");

            // ------------------------------------------------------
            // Set up the texture SurfaceDescriptor for an acceptable
            // texture format (in this case it's powers of 2 sizes)
            // in preparation to blit the source texture image to it
            // ------------------------------------------------------

            LONG srcWidth = discoDesc.dwWidth;
            LONG srcHeight = discoDesc.dwHeight;
            discoDesc.dwWidth  = pixelsWide;
            discoDesc.dwHeight = pixelsHigh;

            LPDDRAWSURFACE discoTextureSurf;
            if( srcWidth == pixelsWide  &&
                srcHeight == pixelsHigh) {
                //
                // don't need to create a mirror surface
                //

                TraceTag((tagGTextureInfo, "texture surface: using native (no color conversion)."));

                discoTextureSurf = srcDDSurface->IDDSurface();
                discoTextureSurf->AddRef();

            } else {
                PrepareD3DTextureSurface (&discoTextureSurf, NULL,
                                          surfMapToUse->GetPixelFormat(),
                                          &discoDesc);

                // this actually just scales the surface.  legacy name
                if(!ReformatSurface(discoTextureSurf, discoDesc.dwWidth, discoDesc.dwHeight,
                                    discoSurf, srcWidth, srcHeight, &discoDesc))
#if 0
				    clrKey, validKey,
				    &destKey))
#endif
                  {
                      Assert(FALSE && "Trouble reformating surface!");
                      return NULL;
                  }
            }


            RECT rect = {0,0,discoDesc.dwWidth, discoDesc.dwHeight};
            Real w = Pix2Real(discoDesc.dwWidth, GetResolution());
            Real h = Pix2Real(discoDesc.dwHeight, GetResolution());
            Bbox2 box(-w/2.0, -h/2.0,  w/2.0, h/2.0);

            bool validKey = srcDDSurface->ColorKeyIsValid();
            DWORD clrKey = validKey ? srcDDSurface->ColorKey() : 0;

            NEWDDSURF(&ddTxtrSurf,
                      discoTextureSurf,
                      box,
                      &rect,
                      GetResolution(),
                      clrKey,
                      validKey,
                      false, false,
                      "DscImg Texture Surface");

            ddTxtrSurf->SetIsTextureSurf( true );

            discoTextureSurf->Release();
            discoTextureSurf = NULL;

            //
            // Stash the texture surface in the image map
            //
            surfMapToUse->StashSurfaceUsingImage(discoPtr, ddTxtrSurf);

        } //    if( !ddTxtrSurf )

        Assert(ddTxtrSurf && "ddTxtrSurf shouldn't be NULL!!");
        Assert(ddTxtrSurf->IDDSurface() && "ddTxtrSurf->_surface shouldn't be NULL!!");
        Assert(colorKey && "colorKey OUT is NULL <RenderImageForTexture>");
        Assert(clrKeyIsValid && "clrKeyIsValid OUT is NULL <RenderImageForTexture>");

        *clrKeyIsValid = ddTxtrSurf->ColorKeyIsValid();
        if( ddTxtrSurf->ColorKeyIsValid() ) {
            *colorKey = ddTxtrSurf->ColorKey();  // xxx: do I always
                                                 // need a color key
                                                 // here ?
        }

        // if texture is supposed to be upside down, flip it now
        if (upsideDown && !old_static_image) {
            ddTxtrSurf->MirrorUpDown();
        }

        resultSurf = ddTxtrSurf;

    } else {

        DDSurfPtr<DDSurface> finalTextureDDSurf;

        if (upsideDown) {
            finalTextureDDSurf =
                _intraFrameUpsideDownTextureSurfaceMap->LookupSurfaceFromImage(image);
        } else {
            finalTextureDDSurf =
                _intraFrameTextureSurfaceMap->LookupSurfaceFromImage(image);
        }

        if (finalTextureDDSurf) {

            old_static_image = true;

        } else {

            if (!doFitToDimensions) {
                pixelsWide = -1;
                pixelsHigh = -1;
            }

            // Since finalTextureDDSurf is a DDSurfPtr<>, it will be
            // filled in with an addref'd value (that's what
            // GetTextureDDSurface() does.  When the function is
            // exited, it's ref count will be decremented.)

            // remember that GetTextureDDSurface clears the surface to
            // the default colorkey by default!
            GetTextureDDSurface(preferredSurf,
                                srcPool,
                                dstPool,
                                pixelsWide,
                                pixelsHigh,
                                notVidmem,
                                doFitToDimensions,
                                &finalTextureDDSurf);


            if (pChosenSurfFromPool) {
                *pChosenSurfFromPool = true;
            }


            // ------------------------------------------------------
            // Render image onto the texture surface
            // ------------------------------------------------------

            *clrKeyIsValid = finalTextureDDSurf->ColorKeyIsValid();
            if( finalTextureDDSurf->ColorKeyIsValid() ) {
                *colorKey = finalTextureDDSurf->ColorKey();
            }

            if (image->IsRenderable()) {
                if( doFitToDimensions ) {

                    Bbox2 box = image->BoundingBox();
                    if( !box.IsValid() ||
                        (box == UniverseBbox2)) {
                        RaiseException_InternalError(
                            "RenderImageForTexture: image must have "
                            "valid bbox!");
                    }

                    Transform2 *xf = CenterAndScaleRegion(
                        box,
                        pixelsWide,
                        pixelsHigh );

                    Image *fittedImage = TransformImage(xf, image); // fitted Image
                    RenderImageOnDDSurface(fittedImage, finalTextureDDSurf);
                } else {
                    RenderImageOnDDSurface(image, finalTextureDDSurf);
                }
            }

            // TODO: question: should I use image or fittedimage ?
            if (upsideDown) {
                _intraFrameUpsideDownTextureSurfaceMap->
                    StashSurfaceUsingImage(image, finalTextureDDSurf);
            } else {
                _intraFrameTextureSurfaceMap->
                    StashSurfaceUsingImage(image, finalTextureDDSurf);
            }
        }

        // if texture is supposed to be upside down, flip it now
        if (upsideDown && !old_static_image) {
            finalTextureDDSurf->MirrorUpDown();
        }

        resultSurf = finalTextureDDSurf;
    }

    // WORKAROUND: take this out when we can get Permedia cards
    //             to behave themselves vis-a-vis alpha bits in textures
    if (!old_static_image) {
        SetSurfaceAlphaBitsToOpaque(resultSurf->IDDSurface(),
                                    *colorKey,
                                    *clrKeyIsValid);
    }

    if (pDropSurfHereWithRefCount) {

        // Do an addref and return in this variable.
        ADDREF_DDSURF(resultSurf,
                      "Extra Ref Return", this);

        *pDropSurfHereWithRefCount = resultSurf;
    }


    return resultSurf;
}

#define _BACKGROUND_OPTIMIZATION 0


#define INFO(a) if(a) a->Report()

//-----------------------------------------------------
// B e g i n    R e n d e r i n g
//
//-----------------------------------------------------
void DirectDrawImageDevice::
BeginRendering(Image *img, Real opacity)
{
    InitializeDevice();

    //
    // Clear all the context
    //
    ResetContextMembers();

    // Reset DAGDI, if it exists
    if( GetDaGdi() ) {
        GetDaGdi()->ClearState();
    }
    
    #if _DEBUG
    INFO(_freeTextureSurfacePool);
    #endif
}

//-----------------------------------------------------
// E n d   R e n d e r i n g
//
// Calls _viewport's EndRendering and resets some flags
//-----------------------------------------------------
void DirectDrawImageDevice::
EndRendering(DirtyRectState &d)
{
    if(!CanDisplay()) return;

    Assert(_deviceInitialized && "Trying to render an uninitialized device!");
    _viewport.EndRendering(d);

    Assert(AllAttributorsTrue() && "Not all attribs are true in EndRendering");

    // top level renderer gets cleaned out like other level renderers
    // do as well.
    CleanupIntermediateRenderer();
}

#define MAX_SURFACES 20

void
DirectDrawImageDevice::CleanupIntermediateRenderer()
{
    // Nested devices get cleaned up when they're done.

    ReturnTextureSurfaces(_freeTextureSurfacePool, _usedTextureSurfacePool);

    ReturnTextureSurfaces(_freeTextureSurfacePool,
                          _intraFrameUsedTextureSurfacePool);

    // clear out intra-frame cache at the end of a frame
    _intraFrameTextureSurfaceMap->DeleteImagesFromMap(false);
    _intraFrameUpsideDownTextureSurfaceMap->DeleteImagesFromMap(false);

    // destroy extra surface in texture pool, keep it to a minimum size.
    int size = _freeTextureSurfacePool->Size();
    if( size > MAX_SURFACES ) {
      int toRelease = (size - MAX_SURFACES);
      _freeTextureSurfacePool->ReleaseAndEmpty( toRelease );
    }
}

//-----------------------------------------------------
// R e n d e r   I m a g e
//
// Dispatches image's render method
//-----------------------------------------------------
void DirectDrawImageDevice::
RenderImage(Image *img)
{
    // by default, tell the image to render itself on
    // on the device.

    if(!CanDisplay()) return;

    Assert(_deviceInitialized && "Trying to render an uninitialized image device!");

    img->Render(*this);
}



// ----------------------------------------------------------------------
// R e n d e r   T i l e d   I m a g e
//
// Given a 'tile' region on an image in image coords: tile that image
// infinitely.
// ----------------------------------------------------------------------
void DirectDrawImageDevice::
RenderTiledImage(
    const Point2 &min,
    const Point2 &max,
    Image *tileSrcImage)
{
    // FIX: TODO: can I actually do all these ??
    SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, TRUE);
    SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, TRUE);
    SetDealtWithAttrib(ATTRIB_CROP, TRUE);
    SetDealtWithAttrib(ATTRIB_OPAC, TRUE);

    Assert( !IsComplexTransform() && "Can't rotate or shear tiled images yet!!!");

    // --------------------------------------------------
    // Figure out all the tile info you could use
    // --------------------------------------------------

    // Dest tile info
    Real destRealTileMinX;
    Real destRealTileMaxX;
    Real destRealTileMinY;
    Real destRealTileMaxY;
    Real destRealTileWidth ;
    Real destRealTileHeight;

  {
      // this scope is for these two points, they don't stay valid!
      Point2 destRealTileMin = TransformPoint2(GetTransform(), min);
      Point2 destRealTileMax = TransformPoint2(GetTransform(), max);

      // Transform the WIDTH not the points and then figure out width
      // that method is too unstable.
      Vector2 v = max - min;
      v = TransformVector2(GetTransform(), v);
      destRealTileWidth = fabs(v.x);
      destRealTileHeight= fabs(v.y);

      if( destRealTileMin.x < destRealTileMax.x) {
          destRealTileMinX = destRealTileMin.x;
          destRealTileMaxX = destRealTileMax.x;
      } else {
          destRealTileMinX = destRealTileMax.x;
          destRealTileMaxX = destRealTileMin.x;
      }


      if( destRealTileMin.y < destRealTileMax.y) {
          destRealTileMinY = destRealTileMin.y;
          destRealTileMaxY = destRealTileMax.y;
      } else {
          destRealTileMinY = destRealTileMax.y;
          destRealTileMaxY = destRealTileMin.y;
      }
  }


  //----------------------------------------
  // Calculate Bounding Boxes on the TILED image,
  // NOT the tile.  This is the resultant image
  // after all the tiling is done
  //----------------------------------------

    _boundingBox = IntersectBbox2Bbox2(_viewport.GetTargetBbox(),
                                       DoBoundingBox(UniverseBbox2));

    if( !_boundingBox.IsValid() ) return;

    //----------------------------------------
    // Source Bbox in real coordinates
    // Derived from _boundingBox and accumulated transforms.
    //----------------------------------------
    Transform2 *invXf = InverseTransform2(GetTransform());

    if (!invXf) return;

    Bbox2 srcBox = TransformBbox2(invXf, _boundingBox);

    Real srcXmin = srcBox.min.x;
    Real srcYmin = srcBox.min.y;
    Real srcXmax = srcBox.max.x;
    Real srcYmax = srcBox.max.y;

    Real realSrcWidth  = srcXmax - srcXmin;
    Real realSrcHeight = srcYmax - srcYmin;

    // --------------------------------------------------
    // Destination Bbox in real coordinates
    // --------------------------------------------------
    Bbox2 destBox = _boundingBox;

    Real destXmin = destBox.min.x;
    Real destYmin = destBox.min.y;
    Real destXmax = destBox.max.x;
    Real destYmax = destBox.max.y;

    Real realDestWidth  = destXmax - destXmin;
    Real realDestHeight = destYmax - destYmin;

    DDSurface *targDDSurf = NULL;
    if(AllAttributorsTrue() ) {
        targDDSurf = GetCompositingStack()->TargetDDSurface();
    } else {
        Assert(FALSE && "Not implemented");
    }

    // --------------------------------------------------
    // Set clip on intermediate surface to be destRect
    // --------------------------------------------------
    RECT destRect;
    if(targDDSurf == _viewport._targetPackage._targetDDSurf ) {
        DoDestRectScale(&destRect, GetResolution(), destBox, NULL);
    } else {
        DoDestRectScale(&destRect, GetResolution(), destBox, targDDSurf);
    }

    if(!_tileClipper)  _viewport.CreateClipper(&_tileClipper);
    // Get the clipper on the target surface, if any.
    LPDIRECTDRAWCLIPPER origClipper = NULL;
    targDDSurf->IDDSurface()->GetClipper(&origClipper);

    // COMPOSITE
    DoCompositeOffset(targDDSurf, &destRect);

    if( IsCompositeDirectly() &&
        targDDSurf == _viewport._targetPackage._targetDDSurf &&
        _viewport._targetPackage._prcClip ) {
            IntersectRect(&destRect,
                          &destRect,
                          _viewport._targetPackage._prcClip);
    }

    _viewport.SetCliplistOnSurface( targDDSurf->IDDSurface(), &_tileClipper, &destRect);

    //
    // theTile:  this image is cropped and transformed.  BUT, note
    // that super cropping (cropping larger that the underlying image)
    // will not have an effect on the underlying image's bbox.  So, we
    // need to build bboxes separately.
    //
    Image *theTile = TransformImage(
        GetTransform(),CreateCropImage(min, max, tileSrcImage));

    //
    // Get the tile box, not that this includes the extent of
    // (min,max) without using bbox on the 'theTile' image because
    // cropping to min,max isn't guaranteed to have an effect on the
    // bbox of the image if the crop is larger than the underlying
    // image's bbox.
    //
    Bbox2 theTileBox(destRealTileMinX,destRealTileMinY,
                     destRealTileMaxX,destRealTileMaxY);

    // --------------------------------------------------
    // Determine if we should do a fast tile or slow tile
    // --------------------------------------------------
    bool fastTile = true;
    //Bool fastTile = FALSE;

    // Is the tile larger than the destination surface ?
    Real viewWidth = Real(GetWidth()) / GetResolution();
    Real viewHeight = Real(GetHeight()) / GetResolution();
    if(destRealTileWidth >= viewWidth || destRealTileHeight > viewHeight) {
        fastTile = false;
    }


    #if 0
    if( srcImage->HasOpacityAnywhere() ) {
        fastTile = false;
    }
    #endif

    if( fastTile ) {


        // --------------------------------------------------
        // Figure out pixel coords of dest tile
        // --------------------------------------------------

        Real res = GetResolution();
        LONG destTileWidthPixel = Real2Pix(destRealTileWidth, res);
        LONG destTileHeightPixel = Real2Pix(destRealTileHeight, res);

        Assert((destTileWidthPixel >= 0 ) && "neg tile width!");
        Assert((destTileHeightPixel >= 0 ) && "neg tile height!");

        // widths of less than 3 pixels not worth the time...
        if( destTileWidthPixel <= 2  ||  destTileHeightPixel <= 2) return;

        LONG minXPix = Real2Pix(destXmin, res);
        LONG maxXPix = Real2Pix(destXmax, res);
        LONG tileMinXPix = Real2Pix(destRealTileMinX, res);
        LONG tileMaxXPix = tileMinXPix + destTileWidthPixel;

        LONG destFirstXPixel = tileMinXPix - destTileWidthPixel * ((( tileMinXPix - minXPix ) / destTileWidthPixel) + 1);
        LONG destMaxXPixel = tileMaxXPix + destTileWidthPixel * ((( maxXPix - tileMaxXPix ) / destTileWidthPixel) + 1);
        destFirstXPixel += _viewport.Width() / 2;
        destMaxXPixel += _viewport.Width() / 2;

        LONG topPix = Real2Pix(destYmax, res);
        LONG botPix = Real2Pix(destYmin, res);
        LONG tileTopPix = Real2Pix(destRealTileMaxY, res);
        LONG tileBotPix = Real2Pix(destRealTileMinY, res);

        LONG top = tileTopPix + destTileHeightPixel * ((( topPix - tileTopPix ) / destTileHeightPixel) + 2);
        LONG bot = tileBotPix - destTileHeightPixel * ((( tileBotPix - botPix ) / destTileHeightPixel) + 2);
        LONG destFirstYPixel = _viewport.Height()/2 - top;
        LONG destMaxYPixel = _viewport.Height()/2 - bot;

#if 0
        LONG Ytop, Ybot;
        Ytop = _viewport.Height() / 2 - Real2Pix(max->y, res);
        Ybot = _viewport.Height() / 2 - Real2Pix(min->y, res);
        LONG Xmin, Xmax;
        Xmin = Real2Pix(min->x, res) + _viewport.Width() / 2;
        Xmax = Real2Pix(max->x, res) + _viewport.Width() / 2;

        RECT srcTR = { Xmin, Ytop, Xmax, Ybot };
        RECT *srcTileRect = &srcTR;
#else
        RECT *srcTileRect = NULL;
#endif
        //
        // this function converts based on the current transform..
        // if no scale, then it's a simple copy & offset
        //
        RECT theTileRect;
        SmartDestRect(&theTileRect, GetResolution(), theTileBox,
                      NULL, srcTileRect);
//        theTileRect.right = theTileRect.left + destTileWidthPixel;
//        theTileRect.bottom = theTileRect.top + destTileHeightPixel;


        Image *theCtrTile = NULL;

        //
        // move the tile back into the scratch surface so we can get at it
        // after it's rendered
        //
        Real hfWidth = 0.5 * (theTileBox.max.x - theTileBox.min.x);
        Real hfHeight= 0.5 * (theTileBox.max.y - theTileBox.min.y);
        Real xltx = - (theTileBox.min.x + hfWidth);
        Real xlty = - (theTileBox.min.y + hfHeight);

        //
        // Move the tile to the center
        //
        Transform2 *xlt = TranslateRR( xltx, xlty );

        theCtrTile = TransformImage(xlt, theTile);
        Bbox2 theCtrTileBox = TransformBbox2(xlt, theTileBox);

        RECT theCtrTileRect;

        // Get the scratch surface..
        {
            DDSurface *scr =
                GetCompositingStack()->GetScratchDDSurfacePtr();
            if( scr ) {
                if( !( (scr->Width() == targDDSurf->Width()) &&
                       (scr->Height() == targDDSurf->Height()))  ) {
                    // dump currnet scratch!
                    GetCompositingStack()->ReleaseScratch();
                }
            }
        }

        DDSurface *scratchDDSurf = GetCompositingStack()->ScratchDDSurface(doClear);
#if 0
        //this doesn't work on dx2 for some reason...

        RECT *scrRect = scratchDDSurf->GetSurfRect();
        LONG left = (WIDTH(scrRect) / 2)  -  (destTileWidthPixel / 2);
        LONG topp = (HEIGHT(scrRect) / 2)  - (destTileHeightPixel / 2);

        SetRect(&theCtrTileRect,
                left, topp,
                left + destTileWidthPixel,
                topp + destTileHeightPixel);
#else
        SmartDestRect(&theCtrTileRect, GetResolution(), theCtrTileBox,
                      NULL, &theTileRect);
        //theCtrTileRect.right = theCtrTileRect.left + destTileWidthPixel;
        //theCtrTileRect.bottom = theCtrTileRect.top + destTileHeightPixel;

#endif

        //
        // Base 'theTileRect' on theCtrTileRect by offseting the latter
        //

        // if translate only, this is not necessary
        LONG w = WIDTH(&theCtrTileRect);
        LONG h = HEIGHT(&theCtrTileRect);

        theTileRect.right = theTileRect.left + w;
        theTileRect.bottom = theTileRect.top + h;

        //
        // compose tile to scratch surface
        //
        RenderImageOnDDSurface(theCtrTile, scratchDDSurf, 1.0, FALSE);

        LONG tx, ty;
        RECT currentRect;
        ZeroMemory(&_bltFx, sizeof(_bltFx));
        _bltFx.dwSize = sizeof(_bltFx);
        #if 0
        DWORD flags = DDBLT_WAIT;
        #else
        DWORD flags = DDBLT_WAIT | DDBLT_KEYSRCOVERRIDE;
        _bltFx.ddckSrcColorkey.dwColorSpaceLowValue =
            _bltFx.ddckSrcColorkey.dwColorSpaceHighValue =
            _viewport._defaultColorKey;
        #endif

        //
        // Render tiles
        //

        for(LONG x=destFirstXPixel; x < destMaxXPixel; x += destTileWidthPixel) {
            for(LONG y=destMaxYPixel; y > destFirstYPixel; y -= destTileHeightPixel) {
                tx = x - theTileRect.left;
                ty = y - theTileRect.top;

                currentRect = theTileRect;
                OffsetRect(&currentRect, tx, ty);

                // COMPOSITE
                DoCompositeOffset(targDDSurf, &currentRect);

                if( IsTransparent() ) {

                    //
                    // Do alpha blit!  TODO: would be nice to confirm the need for the colorKey...
                    //
                    destPkg_t destPkg = {TRUE, targDDSurf->IDDSurface(), NULL};
                    TIME_ALPHA(AlphaBlit(&destPkg, &theCtrTileRect,
                                         scratchDDSurf->IDDSurface(),
                                         _opacity,
                                         TRUE, _viewport._defaultColorKey,
                                         //FALSE, _viewport._defaultColorKey,
                                         &destRect,
                                         &currentRect));

                } else {

                    // Blit from the cenetered tile rectangle off of the scratch surface to the
                    // destination rectangle, which is the tile rectangle (uncentered, after all
                    // xforms) offset by tx,ty
                    #if 0
                    printf("destTileWidthPixel %d   destw: %d   srcw:%d\n",
                           destTileWidthPixel, WIDTH(&currentRect), WIDTH(&theCtrTileRect));
                    #endif
                    TIME_DDRAW(_ddrval = targDDSurf->Blt(&currentRect,
                                                         scratchDDSurf,
                                                         &theCtrTileRect,
                                                         flags,
                                                         &_bltFx));
                    if(_ddrval != DD_OK) {
                        printDDError(_ddrval);
                        RECT *surfR = scratchDDSurf->GetSurfRect();
                        TraceTag((tagError, "Fast tile blt failed: "
                                  "destRect:(%d,%d,%d,%d)   "
                                  "srcRect:(%d,%d,%d,%d)   "
                                  "srcSurfRect:(%d,%d,%d,%d)  ",
                                  currentRect.left, currentRect.top, currentRect.right, currentRect.bottom,
                                  theCtrTileRect.left, theCtrTileRect.top, theCtrTileRect.right, theCtrTileRect.bottom,
                                  surfR->left, surfR->top, surfR->right, surfR->bottom));
                        TraceTag((tagError,"Could not tile blt for fast tile"));
                    }

                }

            } // for y
        } // for x


    } else {  // fast tile

        // Find 1st blit coords in bottom left (minx, miny) based on
        // original tile position in real coords.
        Real xRemainder = fmod((destXmin - destRealTileMinX), destRealTileWidth);
        Real yRemainder = fmod((destYmin - destRealTileMinY), destRealTileHeight);
        Real destFirstX = destXmin - (xRemainder < 0 ? ( xRemainder + destRealTileWidth )  : xRemainder );
        Real destFirstY = destYmin - (yRemainder < 0 ? ( yRemainder + destRealTileHeight ) : yRemainder );


        // Tile loop
        // XXX: note a little bit of inefficiency, sometimes the extra column/row is not
        // xxx: needed on right and top edge.
        Real tx, ty;

        #if _DEBUG
        int blitCount=0;
        #endif

        Image *srcTile = TransformImage(GetTransform(),tileSrcImage);

        for(Real x=destFirstX; x < destXmax; x += destRealTileWidth) {
            for(Real y=destFirstY; y < destYmax; y += destRealTileHeight) {
                #if _DEBUG
                blitCount++;
                #endif

                tx = x - destRealTileMinX + _tx;
                ty = y - destRealTileMinY + _ty;
                Image *srcImage = TransformImage(
                    TranslateRR(tx, ty),
                    srcTile);

                if(IsCropped())
                {
                    // if we are cropped we need to crop the tile ....yee ha
                    Bbox2 _bBox = DoCompositeOffset(targDDSurf, _boundingBox);
                    srcImage = CreateCropImage(_bBox.min,_bBox.max, srcImage);
                }

                 // And render.
                RenderImageOnDDSurface(srcImage, targDDSurf, GetOpacity(), FALSE);

                //_viewport.Width(), _viewport.Height(), _viewport._clientRect, GetOpacity());

            } // for y
        } // for x

        //printf("Num blits:  %d\n",blitCount);
    } // fast Tile

    // Reset orignal clipper on targetSurf
    // XXX: this can be done better by not needing a clipper... its also faster...
    if( origClipper ) {
        _viewport.SetCliplistOnSurface( targDDSurf->IDDSurface(),
                                        & origClipper,
                                        NULL);
    }

    targDDSurf->SetInterestingSurfRect( &destRect );

}  // RenderTiledImage()


Transform2 *DirectDrawImageDevice::
CenterAndScaleRegion( const Bbox2 &regionBox, DWORD pixelW, DWORD pixelH )
{
    Assert( !( regionBox == UniverseBbox2 ) );
    Assert( regionBox.IsValid() );

    Real pixel = 1.0 / ::ViewerResolution();

    //
    // Translate center of box to be at origin
    //
    Point2 pt = regionBox.Center();
    Transform2 *xlt = TranslateRR( - pt.x, - pt.y );

    //
    // Now, scale box to be the right size <pixels>
    //
    // scale to requested size
    Assert( pixelH > 0 );    Assert( pixelW > 0 );
    Real imW = Pix2Real( pixelW, GetResolution() );
    Real imH = Pix2Real( pixelH, GetResolution() );

    Real rgW = regionBox.Width();
    Real rgH = regionBox.Height();

    // scale the region to be the size of the pixel width/height
    Transform2 *sc = ScaleRR( imW / rgW, imH / rgH );

    Transform2 *xf = TimesTransform2Transform2(sc, xlt);

    return xf;
}

void _TrySmartRender(DirectDrawImageDevice *dev,
                     Image *image,
                     int attr,
                     bool &doRethrow,
                     DWORD &excCode)
{
    __try {
        dev->SmartRender(image, ATTRIB_OPAC);
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        doRethrow = true;
        excCode = GetExceptionCode();
    }
}


//-----------------------------------------------------
// R e n d e r   I m a g e   O n   S u r f a c e
//
// given an image and a target surface and the extent of
// that surface, grab a device from _viewport, use that
// device to render the image and then return the device.
// Note that this manually manipulates (pushes and pops)
// state in the _viewport.
// Also, if a valid clipper is passed in, it doesn't
// replace the current clipper, just trusts that
// the right clipper is set on the target surface
//-----------------------------------------------------
void DirectDrawImageDevice::
RenderImageOnDDSurface(
    Image *image,
    DDSurface *ddSurf,
    Real opacity,
    Bool pushClipper,  // needed if the surface is an external surface
                       // i think.
    bool inheritContext,
    DirectDrawImageDevice **usedDev)
{
    if (!image->IsRenderable()) {
        return;
    }

    bool pushState = true;

    if( GetCompositingStack()->TargetDDSurface() == ddSurf ) {
        pushState = false;
    }


    LONG w;
    LONG h;
    RECT r;
    Bbox2 b;
    LPDIRECTDRAWCLIPPER oldClipper;
    Bool returnScratch;
    DDSurfPtr<DDSurface> scratchSurf;
    TargetSurfacePusher targsurf_stack ( *GetCompositingStack() );

    if( pushState) {
        // -- Swap state in viewport --
        // -- this MUST be done before the device is instantiated
        // -- because the device creates a d3d device off of the
        // -- viewport's intermediate surface.

        // Save state
        w = _viewport.Width();
        h = _viewport.Height();
        r = _viewport._clientRect;
        b = _viewport.GetTargetBbox();

        //printf("--> PUSH saving state old:(%d,%d)\n",h,w);
        //printf("--> PUSH              NEW:(%d,%d)\n",ddSurf->Width(), ddSurf->Height());

        // Change state
        _viewport.SetWidth(ddSurf->Width());
        _viewport.SetHeight(ddSurf->Height());

        #if 0
        /// not needed...
        if( ddSurf == _viewport._externalTargetDDSurface ) {
            RECT *r = _viewport._targetPackage._prcViewport;
            _viewport._clientRect = *(_viewport._targetPackage._prcViewport);
            Real w = Pix2Real(r->right - r->left, GetResolution());
            Real h = Pix2Real(r->bottom - r->top, GetResolution());

            _viewport._targetBbox.min.Set(-w*0.5, -h*0.5);
            _viewport._targetBbox.max.Set( w*0.5,  h*0.5);
        } else { }
        #endif

        _viewport._clientRect = *(ddSurf->GetSurfRect());
        _viewport._targetBbox = ddSurf->Bbox();

        // push target surface
        targsurf_stack.Push (ddSurf);

        oldClipper = _viewport._targetSurfaceClipper;

        if(pushClipper) {

            Assert(ddSurf != _viewport._externalTargetDDSurface &&
                   "Can't pushClipper on trident's target surface in"
                   "RenderImageOnDDSurface");

#define USING_DX5 0

            #if USING_DX5 // Use this code when we switch to DX5

            // Stash and Create a clipper for this surface
            _viewport._targetSurfaceClipper = NULL;
            _viewport.CreateClipper(&_viewport._targetSurfaceClipper);
            _viewport.SetCliplistOnSurface(ddSurf->IDDSurface(),
                                           & _viewport._targetSurfaceClipper,
                                           & _viewport._clientRect);
            #else

            // nt4 ddraw sp3 workaround, this should be removed when
            // we switch to DX5
            {
                // due to an nt4 ddraw bug, we're goign to reset the
                // clip rgn, not the clipper

                // Get current clipper.
                // modify rgn
                // release our reference
                LPDIRECTDRAWCLIPPER currClipp=NULL;
                _ddrval = ddSurf->IDDSurface()->GetClipper( &currClipp );
                if(_ddrval != DD_OK &&
                   _ddrval != DDERR_NOCLIPPERATTACHED) {
                    IfDDErrorInternal(_ddrval, "Could not get clipper on trident surf");
                } else if (_ddrval == DDERR_NOCLIPPERATTACHED) {
                    _viewport.CreateClipper(&currClipp);
                    _ddrval = ddSurf->IDDSurface()->SetClipper(currClipp);
                    IfDDErrorInternal(_ddrval, "SetClipper");
                }

                Assert(currClipp);
                RECT *rect = &_viewport._clientRect;

                // modify the rect
                struct {
                    char foo[sizeof(RGNDATA) + sizeof(RECT)];
                } bar;
                RGNDATA *clipList = (RGNDATA *) &bar;
                clipList->rdh.dwSize = sizeof(clipList->rdh);
                clipList->rdh.nCount = 1;
                clipList->rdh.iType = RDH_RECTANGLES;
                clipList->rdh.nRgnSize = sizeof(RECT);
                clipList->rdh.rcBound = *rect;
                memcpy(&(clipList->Buffer), rect, sizeof(RECT));

                // Clear any former cliplists
                _ddrval = currClipp->SetClipList(NULL,0);

                // Set clip list on the clipper
                _ddrval = currClipp->SetClipList(clipList,0);
                IfDDErrorInternal(_ddrval, "Could not SetClipList");

                _viewport._targetSurfaceClipper = currClipp;

                // dump our reference.
                currClipp->Release();
            } // workaround
            #endif
        }

        // XXX: there are other things that need to be swapped out
        // xxx: here.  They are all those things whcih are associated
        // xxx: with a the current 'viewport' size.  this include the
        // scratch surface as well as all the compositing surfaces which
        // are all assumed to be the same size.  so the right solution is
        // to make compositing surface pools, each pool contains surfaces
        // of a certain size.  this will mostly work for now, but the
        // right solution is to create this pool.  filed as bug#1625

        returnScratch = FALSE;
        if(GetCompositingStack()->GetScratchDDSurfacePtr()) {
            returnScratch = TRUE;
            // grabs my own reference!
            GetCompositingStack()->ScratchDDSurface( &scratchSurf );
            GetCompositingStack()->SetScratchDDSurface(NULL);
        }

    } // If Push State

    // Create Or Get Directdraw Device.
    DirectDrawImageDevice *dev = _viewport.PopImageDevice();

    //
    // Outvar: usedDev
    //
    if( usedDev ) {
        *usedDev = dev;
    }

    Assert((&dev->_viewport == &_viewport) &&
           "!Different viewports in same dev stack!");

    // TODO: the right thing here is to leverage all these cool
    // classes and not need to play with all the state like we're doing...
    dev->SetSurfaceSources(GetCompositingStack(),
                           GetSurfacePool(),
                           GetSurfaceMap());

    if( inheritContext ) {
        dev->InheritContextMembers(this);
    } else {
        dev->SetOpacity(opacity);

        //
        // push these flags thru since they can't be done by
        // attribution after the fact
        //
        dev->SetImageQualityFlags( this->GetImageQualityFlags() );

        //
        // push the rendering resolution context also
        //
        {
            long w,h;
            this->GetRenderResolution( &w, &h );
            dev->SetRenderResolution( w, h );
        }

        dev->ResetAttributors();
    }

    //
    // Ok, this tells the device to render and check for opacity
    // from the top, in case 'opacity' which we set was something
    // interesting
    //
    // XXX: What about other attributors ?
    // If There are any parent attribs on this image, we DONT
    // CARE.  That's the point of this method, to render THIS
    // image onto a surface.  The opacity is a consesion made
    // since it's a funky operator.  this should allll go away
    // with premult alpha.
    bool doRethrow=false;
    DWORD excCode;
    _TrySmartRender(dev, image, ATTRIB_OPAC,
                    doRethrow, excCode);

    Assert( GetCompositingStack()->TargetDDSurface() == ddSurf &&
            "pushed ddSurf != popped ddSurf in RenderImageOnDDSurface");

    if( pushState ) {

        // Pop state
        _viewport.SetWidth(w);
        _viewport.SetHeight(h);
        _viewport._clientRect = r;
        _viewport._targetBbox = b;

        if(pushClipper) {
            #if USING_DX5 // Use this code when we switch to DX5
            // FUTURE: cache these clippers and reuse them...
            // detach clipper from surface
            ddSurf->IDDSurface()->SetClipper(NULL);  // detach
            if(_viewport._targetSurfaceClipper) {
                _viewport._targetSurfaceClipper->Release();
                _viewport._targetSurfaceClipper = NULL;
            }

            #else

            // nt4 ddraw sp3 workaround, this should be removed when
            // we switch to DX5
            {
                // due to an nt4 ddraw bug, we're goign to reset the
                // clip rgn, not the clipper

                // Get current clipper.
                // modify rgn
                // release our reference
                LPDIRECTDRAWCLIPPER currClipp=NULL;
                _ddrval = ddSurf->IDDSurface()->GetClipper( &currClipp );
                if(_ddrval != DD_OK &&
                   _ddrval != DDERR_NOCLIPPERATTACHED) {
                    IfDDErrorInternal(_ddrval, "Could not get clipper on trident surf");
                }

                if ((_ddrval == DD_OK) && oldClipper) {
                    Assert(currClipp);
                    RECT *rect = &_viewport._clientRect;

                    // modify the rect
                    struct {
                        char foo[sizeof(RGNDATA) + sizeof(RECT)];
                    } bar;
                    RGNDATA *clipList = (RGNDATA *) &bar;
                    clipList->rdh.dwSize = sizeof(clipList->rdh);
                    clipList->rdh.nCount = 1;
                    clipList->rdh.iType = RDH_RECTANGLES;
                    clipList->rdh.nRgnSize = sizeof(RECT);
                    clipList->rdh.rcBound = *rect;
                    memcpy(&(clipList->Buffer), rect, sizeof(RECT));

                    // Clear any former cliplists
                    _ddrval = currClipp->SetClipList(NULL,0);

                    // Set clip list on the clipper
                    _ddrval = currClipp->SetClipList(clipList,0);
                    IfDDErrorInternal(_ddrval, "Could not SetClipList");

                    // dump our reference.
                    currClipp->Release();
                }
            } // workaround
            #endif

            _viewport._targetSurfaceClipper = oldClipper;
        }


        if(returnScratch) {
            GetCompositingStack()->ReplaceAndReturnScratchSurface(scratchSurf);
        }
    }

    _viewport.PushImageDevice(dev);

    if( doRethrow ) {
        RaiseException( excCode, 0,0,0);
    }
}

//-----------------------------------------------------
// D o   S r c   R e c t
//
// Using the accumulated transform, this function derives the
// source rectangle given source resolution, source pixelHeight,
// and the src bounding box in continuous image coordinate space.
// The resultant rectangle is in pixel image coordinate space.
// returns TRUE if the rect is valid, false if it's not.
//-----------------------------------------------------
Bool DirectDrawImageDevice::
DoSrcRect(RECT *srcRect,
          const Bbox2 &box,
          Real srcRes,
          LONG srcWidth,
          LONG srcHeight)
{
    Real xmin, ymin, xmax, ymax;

    Transform2 *invXf = InverseTransform2(GetTransform());

    if (!invXf) return FALSE;

    // Take the current box, and return original box
    Bbox2 srcBox = TransformBbox2(invXf, box);

//    if(!srcBox.IsValid()) return FALSE;

    xmin = srcBox.min.x;
    ymin = srcBox.min.y;
    xmax = srcBox.max.x;
    ymax = srcBox.max.y;

    if((xmin >= xmax) || (ymin >= ymax)) return FALSE;

    //----------------------------------------
    // Notice, however that the user expressed
    // the coordinates assuming 0,0 is the center
    // of the discrete image; so it must be offset by
    // 1/2 its (h,w).
    //----------------------------------------


    // This method treats integral widths differently than
    // non integral widths.

    LONG pixelXmin, pixelYmin,
         pixelXmax, pixelYmax,
         pixelWidth, pixelHeight;

    #if 0
    int static doAgain = 0;
    Assert(Real2Pix(xmin , srcRes) == -60);
    if(Real2Pix(xmin , srcRes) != -60) {
        printf("%d  double is:  %x %x\n",
               Real2Pix(xmin , srcRes),
               *((unsigned int *)(&xmin)),
               *((unsigned int *)(&xmin) + 1));
        doAgain = 1;
    } else if(doAgain) {
        printf("%d  double is:  %x %x\n",
               Real2Pix(xmin , srcRes),
               *((unsigned int *)(&xmin)),
               *((unsigned int *)(&xmin) + 1));
        doAgain = 0;
    }
    #endif

    pixelXmin = Real2Pix(xmin , srcRes);
    pixelYmax = Real2Pix(ymax , srcRes);

    // Calc pixel width/height
    // use simple real to pixel calculation
    pixelWidth  = LONG((xmax-xmin) * srcRes);
    pixelHeight = LONG((ymax-ymin) * srcRes);

    // If the real height/widht is integral multiples of pixels
    // then use that value, otherwise use the rounded up pixel widht/height

    // Base from the LEFT
    if( fabs((xmax-xmin) - (Pix2Real(pixelWidth,srcRes))) < 0.0000000002)
        pixelXmax = pixelXmin + pixelWidth;
    else
        pixelXmax = pixelXmin + pixelWidth + 1;

    // Base from the TOP
    if( fabs((ymax-ymin) - (Pix2Real(pixelHeight,srcRes))) < 0.0000000002)
        pixelYmin = pixelYmax - pixelHeight;
    else
        pixelYmin = pixelYmax - (pixelHeight + 1);

    LONG xOff = srcWidth / 2;
    LONG yOff = srcHeight / 2;

    pixelXmin += xOff;
    pixelXmax += xOff;

    // do remapping of y coords... sigh.
    LONG Ytop, Ybottom;

    Ytop    = (srcHeight - pixelYmax) - yOff;
    Ybottom = (srcHeight - pixelYmin) - yOff;

    // Now assert that the maxes are reasonable
    // TODO: revisit later: determine if necessary
#if 1
    if(Ytop < 0) Ytop = 0;
    if(Ybottom > srcHeight) Ybottom = srcHeight;

    if(pixelXmin < 0) pixelXmin = 0;
    if(pixelXmax > srcWidth) pixelXmax = srcWidth;
#endif

    SetRect(srcRect,
            pixelXmin, Ytop,
            pixelXmax, Ybottom);

    return TRUE;
}

void DoGdiY(LONG height,
            Real res,
            const Bbox2 &box,
            LONG *top)
{
    //
    // The trick with Y is to interpret the coords coming in as bottom
    // up.  This means that (0,0) turns on the pixel to the top right
    // of (0,0).  If the window is 4x4, then the (0,0) pixel is: [2,1]
    // because GDI turns on pixels to the BOTTOM right.
    // If the window is 3x3, then the (0,0) pixel is [1,1]
    //

    LONG halfHeight = height / 2;
    *top = height - (Real2Pix(box.max.y, res) + halfHeight);
}

void DirectDrawImageDevice::
SmartDestRect(RECT *destRect,
              Real destRes,
              const Bbox2 &box,
              DDSurface *destSurf,
              RECT *srcRect)
{
    if(IsFlipTranslateTransform() && srcRect) {
        LONG left, top;
        left = Real2Pix(box.min.x, destRes) + _viewport.Width() / 2;
        DoGdiY(_viewport.Height(), destRes, box, &top);
        SetRect(destRect,
                left, top,
                left + WIDTH(srcRect),
                top + HEIGHT(srcRect));
    } else {
        DoDestRectScale(destRect, destRes, box, destSurf);
    }
}


//-----------------------------------------------------
// D o   D e s t   R e c t   S c a l e
//
// This function derives the destination rectangle given
// the destination resolution and a destination bounding box
// in destination coordinate space (where 0,0 is at the
// center of the viewport).  The resultant rectangle
// is in screen coordinate space, where 0,0 is at the
// top left of the viewport.
//-----------------------------------------------------
void DirectDrawImageDevice::
DoDestRectScale(RECT *destRect, Real destRes, const Bbox2 &box, DDSurface *destSurf)
{
    Real xmin = box.min.x;    Real xmax = box.max.x;
    Real ymin = box.min.y;    Real ymax = box.max.y;

    LONG pixelXmin, pixelXmax;
    pixelXmin = _viewport.Width() / 2 + Real2Pix(xmin,  destRes);
    pixelXmax = _viewport.Width() / 2 + Real2Pix(xmax,  destRes);
    //pixelXmax = pixelXmin + Real2Pix(xmax - xmin,  destRes);

    LONG Ytop, Ybottom;
    int height = _viewport.Height();

    // This is to ensure that we handle odd sized viewport correctly.
    if(height % 2) { height++;}

    Ytop    = height / 2  - Real2Pix(ymax,  destRes);
    Ybottom = height / 2  - Real2Pix(ymin,  destRes);

    //Ybottom = Ytop + Real2Pix(ymax - ymin,  destRes);

    SetRect(destRect, pixelXmin, Ytop, pixelXmax, Ybottom);
    if(destSurf) {
        RECT foo = *destRect;
        // XXX: won't need 'foo' if this fcn can take the destination
        // xxx: rect as one of its src args.
        IntersectRect(destRect, &foo, destSurf->GetSurfRect());
    }
}


//-----------------------------------------------------
// D o   B o u n d i n g   B o x
//
// given the seed or first box, apply all the accumulated
// transforms and crops that the images in the queue
// contain to the firstBox.  The resultant box, which is
// returned, represents what all the accumulated xforms
// and crops do to that box when applied as the user
// intended.
//-----------------------------------------------------
const Bbox2 DirectDrawImageDevice::
DoBoundingBox(const Bbox2 &firstBox, DoBboxFlags_t flags)
{
    Bbox2 box = firstBox;

    list<Image*>::reverse_iterator _iter;

    Assert(flags != invalid);

    if(flags == do_all) {
        for(_iter = _imageQueue.rbegin();
            _iter != _imageQueue.rend(); _iter++)
        {
            box = (*_iter)->OperateOn(box);
        }
    } else {

        // optimize: this is a waste of space
        for(_iter = _imageQueue.rbegin();
            _iter != _imageQueue.rend(); _iter++)
        {
            if(flags == do_crop) {
                if( (*_iter)->CheckImageTypeId(CROPPEDIMAGE_VTYPEID)) {
                    box = (*_iter)->OperateOn(box);
                }
            } else if(flags == do_xform) {
                if( (*_iter)->CheckImageTypeId(TRANSFORM2IMAGE_VTYPEID)) {
                    box = (*_iter)->OperateOn(box);
                }
            }
        }
    }

    return box;
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//
// Global Constructor and accessor functions
// These are exported external to this file
//
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////




//--------------------------------------------------
// a couple of globals used here
//--------------------------------------------------
Real globalViewerResolution = 0;






//--------------------------------------------------
// V i e w e r   U p p e r   R i g h t
//
// first arg is time, currenlty unused but prevent constfold
// Figures out the upper right hand point in the viewer.
//--------------------------------------------------
Point2Value *PRIV_ViewerUpperRight(AxANumber *)
{
    Assert(GetCurrentViewport() && "ViewerUpperRight called with no image device instantiated");

    DirectDrawViewport *vp = GetCurrentViewport();
    Real res = vp->GetResolution();
    // grab dimensions from center to top right corner
    Real w = 0.5 * ((Real)vp->Width()) / res;
    Real h = 0.5 * ((Real)vp->Height()) / res;
    return XyPoint2RR(w,h);
}

//--------------------------------------------------
// V i e w e r   R e s o l u t i o n
//
// first arg is time, currenlty unused but prevent constfold
// Figures out resolution
// in pixels per meter using win32's information about
// the physical screen size & pixel width.
//--------------------------------------------------
double ViewerResolution()
{
    if(!globalViewerResolution) {
        // Derive the resolution from Win32
        HDC hdc = GetDC(NULL);
        int oldMode = SetMapMode(hdc, MM_TEXT);
        IfErrorInternal(!oldMode, "Could not SetMapMode() in ViewerResolution()");

        int w_milimeters = GetDeviceCaps(hdc, HORZSIZE);
        int w_pixels = GetDeviceCaps(hdc, HORZRES);
        ::ReleaseDC(NULL, hdc);
        globalViewerResolution =   Real(w_pixels) / (Real(w_milimeters) / 1000.0);
        TraceTag((tagImageDeviceInformative, "ViewerResolution querried from Win32: pixel width = %d"
                  "  width in milimeters = %d.  Resolution (pixel per meters) = %f",
                  w_pixels, w_milimeters, globalViewerResolution));
    }

    return globalViewerResolution;
}

AxANumber * PRIV_ViewerResolution(AxANumber *)
{ return RealToNumber(::ViewerResolution()); }


#undef MAX_TRIES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\dsdev.cpp ===
/*******************************************************************************

Copyright (c) 1995-97 Microsoft Corporation

Abstract:

    DirectSound rendering device for PCM Sounds

*******************************************************************************/

#include "headers.h"
#include <sys/types.h>
#include <dsound.h>
#include "privinc/dsdev.h"
#include "privinc/mutex.h"
#include "privinc/util.h"
#include "privinc/storeobj.h"
#include "privinc/debug.h"
#include "privinc/bground.h"
#include "privinc/miscpref.h"
#include "privinc/server.h"  // GetCurrentSoundDevice

// definition of DirectSoundProxy static members
int              DirectSoundProxy::_refCount;
CritSect        *DirectSoundProxy::_mutex;
IDirectSound    *DirectSoundProxy::_lpDirectSound;
HINSTANCE        DirectSoundProxy::_hinst;
DSprimaryBuffer *DirectSoundProxy::_primaryBuffer;

// definition of DirectSoundDev static members
BackGround      *DirectSoundDev::_backGround;


void DirectSoundProxy::Configure()
{
    _mutex         = NEW CritSect;
    _refCount      =            0;
    _lpDirectSound =         NULL;
    _primaryBuffer =         NULL;
}


void DirectSoundProxy::UnConfigure()
{
    delete _mutex;
    _mutex         = NULL;
    _lpDirectSound = NULL;
    _primaryBuffer = NULL;
}


DirectSoundProxy *CreateProxy(DirectSoundDev *dsDev)
{
    DirectSoundProxy *proxy;
    __try {
        proxy = DirectSoundProxy::CreateProxy(dsDev->GetHWND());
    }
    __except ( HANDLE_ANY_DA_EXCEPTION ) {
        dsDev->SetAvailability(false); // stubs out audio!
        RETHROW;
    }
    return(proxy);
}


DirectSoundProxy *DirectSoundProxy::CreateProxy(HWND hwnd)
{
    CritSectGrabber csg(*_mutex); // grab mutex

    if(!_refCount)  // if revcount zero, then its time to create new com
        CreateCom(hwnd);

    _refCount++;

    return(NEW DirectSoundProxy);
} // mutex out of scope


void
DirectSoundProxy::CreateCom(HWND hwnd)
{
        extern miscPrefType miscPrefs;

    if(miscPrefs._disableAudio)
        RaiseException_InternalError("DirectSoundCreate disabled from registry");
    char string[200];
    Assert(!_lpDirectSound);  // had better be NULL

    typedef long (WINAPI * fptrType)(void *, void *, void *);
    fptrType      dsCreate;

    if(!_hinst) // Attempt to load dsound.dll if it isn't already
        _hinst = LoadLibrary("dsound.dll");
    if(_hinst == NULL) {
        wsprintf(string, "Failed to load dsound.dll (%d)\n", GetLastError());
        RaiseException_InternalError(string); // XXX we will be caught
    } else {
        // set createDirectSound function pointer.
        FARPROC fcnPtr = GetProcAddress(_hinst, "DirectSoundCreate");
        if(fcnPtr == NULL) {
            wsprintf(string, "Failed to load dsound.dll\n");
            RaiseException_InternalError(string); // XXX we will be caught
            }
    dsCreate = (fptrType)fcnPtr;
    }

    switch (dsCreate(NULL, &_lpDirectSound, NULL)) {
     case DS_OK: break;
     case DSERR_ALLOCATED:     
         RaiseException_InternalError("DirectSoundCreate resource allocated");
     case DSERR_INVALIDPARAM:  
         RaiseException_InternalError("DirectSoundCreate invalid param");
     case DSERR_NOAGGREGATION: 
         RaiseException_InternalError("DirectSoundCreate no aggregation");
     case DSERR_NODRIVER:      
         RaiseException_InternalError("DirectSoundCreate nodriver");
     case DSERR_OUTOFMEMORY:   
         RaiseException_InternalError("DirectSoundCreate out of memory");
     default:                  
         RaiseException_InternalError("DirectSoundCreate unknown err");
    }

    // create a proxy just so we can create the DSprimaryBuffer!
    DirectSoundProxy *dsProxy = NEW DirectSoundProxy();
    _primaryBuffer= NEW DSprimaryBuffer(hwnd, dsProxy);
}


void
DirectSoundProxy::DestroyCom()
{
    int result = _lpDirectSound->Release();
    TraceTag((tagSoundReaper1, "DirectSoundProxy::DestroyCom (%d)", result));
    _lpDirectSound = NULL;

    // we don't unload the library...
}


DirectSoundProxy::~DirectSoundProxy()
{
    CritSectGrabber csg(*_mutex); // grab mutex
    _refCount--;
    TraceTag((tagSoundReaper1, "~DirectSoundProxy rc:%d", _refCount));
    Assert(_refCount >= 0);

    if(!_refCount) {
        // consider releasing the com goodies...
        DestroyCom();
    }


    // mutex out of scope
}


HRESULT
DirectSoundProxy::CreateSoundBuffer(LPDSBUFFERDESC dsbdesc, 
    LPLPDIRECTSOUNDBUFFER dsBuffer, IUnknown FAR *foo)
{
    Assert(_lpDirectSound);
    HRESULT result = _lpDirectSound->CreateSoundBuffer(dsbdesc, dsBuffer, foo);

    return(result);
}


HRESULT DirectSoundProxy::GetCaps(LPDSCAPS caps)
{
    Assert(_lpDirectSound);
    HRESULT result = _lpDirectSound->GetCaps(caps);
    return(result);
}


HRESULT DirectSoundProxy::DuplicateSoundBuffer(LPDIRECTSOUNDBUFFER dsBuffer1,
    LPLPDIRECTSOUNDBUFFER dsBuffer2)
{
    Assert(_lpDirectSound);
    HRESULT result = _lpDirectSound->DuplicateSoundBuffer(dsBuffer1, dsBuffer2);
    return(result);
}


HRESULT DirectSoundProxy::SetCooperativeLevel(HWND hwnd, DWORD dword)
{
    Assert(_lpDirectSound);
    HRESULT result = _lpDirectSound->SetCooperativeLevel(hwnd, dword);
    return(result);
}


HRESULT DirectSoundProxy::Compact()
{
    Assert(_lpDirectSound);
    HRESULT result = _lpDirectSound->Compact();
    return(result);
}


HRESULT DirectSoundProxy::GetSpeakerConfig(LPDWORD dword)
{
    Assert(_lpDirectSound);
    HRESULT result = _lpDirectSound->GetSpeakerConfig(dword);
    return(result);
}


HRESULT DirectSoundProxy::SetSpeakerConfig(DWORD dword)
{
    Assert(_lpDirectSound);
    HRESULT result = _lpDirectSound->SetSpeakerConfig(dword);
    return(result);
}


HRESULT DirectSoundProxy::Initialize(GUID *guid)
{
    Assert(_lpDirectSound);
    HRESULT result = _lpDirectSound->Initialize(guid);
    return(result);
}


DirectSoundDev::DirectSoundDev(HWND hwnd, Real latentsySeconds)
: _hwnd(hwnd), _dsoundAvailable(true)
{
    TraceTag((tagSoundDevLife, "DirectSoundDev constructor"));

    // setup latentsy and nap
    _jitter = 50;  // set scheduling jitter in ms
    _latentsy = (int)(latentsySeconds * 1000.0);
    if(_latentsy < (2 * _jitter)) {  // force l >= 2*j
        _latentsy = 2 * _jitter;
    }
    _nap = _latentsy - _jitter;
}


void DirectSoundDev::Configure()
{
    _backGround = NULL;  // background thread creation delayed to 1st addSound
}


void DirectSoundDev::UnConfigure()
{
    if(_backGround) 
        delete _backGround; // asks the thread to shutdown
}


void
DirectSoundDev::AddSound(LeafSound *sound, MetaSoundDevice *metaDev,
                         DSstreamingBufferElement *bufferElement)
{
    // This method is not re-entrant (needs mutex) but that is OK since we
    // can only be called from one thread for now...


    if(!_backGround) {  // create the BackGround renderer as needed
        _backGround = NEW BackGround();
        if(!_backGround->CreateThread()) {
            delete _backGround;
            _backGround = NULL;
            RaiseException_InternalError("Failed to create bground thread");
        }
    }
    _backGround->AddSound(sound, metaDev, bufferElement);
}

void
DirectSoundDev::RemoveSounds(MetaSoundDevice *metaDev)
{
    // this is called w/o a _backGround
    if(_backGround) {
        UINT_PTR devKey = (UINT_PTR)metaDev;
        _backGround->RemoveSounds(devKey);
    }
}

void 
DirectSoundDev::SetParams(DSstreamingBufferElement *ds,
                          double rate, bool doSeek, double seek, bool loop)
{
    Assert(_backGround);
    if(_backGround)
        _backGround->SetParams(ds, rate, doSeek, seek, loop);
}


DSstaticBuffer *
DirectSoundDev::GetDSMasterBuffer(Sound *snd)
{
    DSstaticBuffer *staticBuffer = NULL; // default to returning NULL, not found
    CritSectGrabber mg(_dsMasterCS);     // begin mutex scope

    DSMasterBufferList::iterator i = _dsMasterBufferList.find(snd);

    if(i != _dsMasterBufferList.end()) {
        staticBuffer = (*i).second;
        staticBuffer->ResetTimeStamp();  // we are accessed so reset timestamp
    }

    return(staticBuffer);
}

void
DeleteDSStaticBuffer(DSstaticBuffer *b)
{
    DirectSoundProxy *proxy = b->GetDSProxy();

    delete b;

    Assert(proxy);
        
    // delete the buffer first, otherwise, a zero ref count proxy
    // would destroy the buffer
    delete proxy;
}

void
DirectSoundDev::RemoveDSMasterBuffer(Sound *snd)
{
    DSstaticBuffer *b = NULL;
    
    {
        CritSectGrabber mg(_dsMasterCS); // begin mutex scope
        DSMasterBufferList::iterator i = _dsMasterBufferList.find(snd);

        if(i != _dsMasterBufferList.end()) {
            b = (*i).second;
            _dsMasterBufferList.erase(i);
        }
    }

    if (b) {
        DeleteDSStaticBuffer(b);
    }
}


void
DirectSoundDev::AddDSMasterBuffer(Sound *snd, DSstaticBuffer *dsMasterBuffer)
{
    CritSectGrabber mg(_dsMasterCS); // begin mutex scope
    Assert(_dsMasterBufferList.find(snd) ==
           _dsMasterBufferList.end());

    dsMasterBuffer->ResetTimeStamp();  // initialize timestamp at creation time
    _dsMasterBufferList[snd] = dsMasterBuffer;
}


#define TERMINAL_AGE 10  //XXX should be set via registry or preference...
#ifdef ONE_DAY // how do you use remove_if with a map?
typedef Sound *Sptr;
typedef DSstaticBuffer *SBptr;
class ElderlyEliminator {
    public:
       bool operator()(Sptr s, SBptr p); // XXX needs the proper pair to work
};


bool ElderlyEliminator::operator()(Sptr sound, SBptr staticBuffer)
{
    bool status = false;        // default to not found
    // Assert(staticBuffer);
    if(staticBuffer && (staticBuffer->GetAge() > TERMINAL_AGE)) {
        DeleteDSStaticBuffer(staticBuffer);
        staticBuffer = NULL;

        status = true; // cause the map entry to be moved for removal
    }
    return status;
}
#endif


bool
DirectSoundDev::ReapElderlyMasterBuffers()
{
    bool found = false;
    DSMasterBufferList::iterator index;

#ifdef ONE_DAY // how do you use remove_if with a map?
    // this deletes and moves all elderly buffers to the end of the structure
    index = 
        std::remove_if(_dsMasterBufferList.begin(), _dsMasterBufferList.end(), 
            ElderlyEliminator());
    if(index!= _dsMasterBufferList.end()) {
        _dsMasterBufferList.erase(index, _dsMasterBufferList.end()); // this deletes them!
        found = true;
    }
#else // have to move forward with what we can get working...

    DSMasterBufferList tempList;

    // copy the good, delete the old
    for(index =  _dsMasterBufferList.begin(); 
        index != _dsMasterBufferList.end(); index++) {

        double age = (*index).second->GetAge();
        if((age > TERMINAL_AGE)) {
            TraceTag((tagSoundReaper1, 
                "ReapElderlyMasterBuffers() static buffer(%d) died of old age",
                 (*index).second));
            DeleteDSStaticBuffer((*index).second); // delete but don't copy
        }
        else {
            tempList[(*index).first] = (*index).second; // copy
        }
    }

    // delete the old map
    _dsMasterBufferList.erase(_dsMasterBufferList.begin(), _dsMasterBufferList.end());

    // copy back
    for(index = tempList.begin(); index != tempList.end(); index++)
        _dsMasterBufferList[(*index).first] = (*index).second;

    // delete the temp map
    tempList.erase(tempList.begin(), tempList.end());


#endif
    return(found);
}

void
DirectSoundDev::AddStreamFile(Sound *snd,
                              CComPtr<IStream> istream)
{
    Assert(_streamList.find(snd) == _streamList.end());

    _streamList[snd] = istream;
}


void
DirectSoundDev::RemoveStreamFile(Sound *snd)
{
    StreamFileList::iterator i = _streamList.find(snd);

    if (_streamList.find(snd) != _streamList.end())
        _streamList.erase(i);
}
   

DirectSoundDev::~DirectSoundDev()
{
    TraceTag((tagSoundDevLife, "DirectSoundDev destructor"));

    // don't acquire the cs here.  ViewIterator can't kick in.
    //CritSectGrabber mg(_dsMasterCS); // begin mutex scope

    for(DSMasterBufferList::iterator i = _dsMasterBufferList.begin();
         i != _dsMasterBufferList.end(); i++) {
        DeleteDSStaticBuffer((*i).second);
    }
}


void
InitializeModule_dsdev()
{
    DirectSoundProxy::Configure();
    DirectSoundDev::Configure();
}


void
DeinitializeModule_dsdev(bool bShutdown)
{
    DirectSoundDev::UnConfigure();
    DirectSoundProxy::UnConfigure();
}


void
ReapElderlyMasterBuffers()
{
    DirectSoundDev *dsDev = GetCurrentDSoundDevice();
    if(dsDev)
        dsDev->ReapElderlyMasterBuffers();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\miscpref.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    miscpref.cpp

    Manages misc registry preferences.  

*******************************************************************************/

#include "headers.h"
#include <stdio.h>
#include "privinc/debug.h"
#include "privinc/registry.h"
#include "privinc/miscpref.h"
#include "privinc/soundi.h"   // for the CANONICALSAMPLERATE


// MISC Parameter Definitions

// This structure is filled in by the UpdateUserPreferences function,
// and contains the misc setttings fetched from the registry.
miscPrefType miscPrefs;


/*****************************************************************************
This procedure snapshots the user preferences from the registry.
*****************************************************************************/
static void UpdateUserPreferences(PrivatePreferences *prefs,
                                  Bool isInitializationTime)
{
    IntRegistryEntry synchronize("AUDIO", PREF_AUDIO_SYNCHRONIZE, 0);
    miscPrefs._synchronize = synchronize.GetValue()?1:0;

#ifdef REGISTRY_MIDI
    IntRegistryEntry qMIDI("AUDIO", PREF_AUDIO_QMIDI, 1);
    miscPrefs._qMIDI = qMIDI.GetValue()?1:0;
#endif

    { // open registry key, read value
    miscPrefs._disableAudio = false; // default
    HKEY hKey;
    char *subKey = "Software\\Microsoft\\DirectAnimation\\Preferences\\AUDIO";
    char *valueName = "disable dsound";
    DWORD type, data, dataSize = sizeof(data);

    // does reg entry exist?
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, subKey,
                                      NULL, KEY_ALL_ACCESS, &hKey)) {

        // if we can read value...
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, valueName, NULL, &type,
                                      (LPBYTE) &data, &dataSize))
            if(data)
                miscPrefs._disableAudio = true; // dissable iff T + defined
    }

    RegCloseKey(hKey);
    }

    IntRegistryEntry 
        frameRate("AUDIO", PREF_AUDIO_FRAMERATE, CANONICALFRAMERATE);
    miscPrefs._frameRate = abs(frameRate.GetValue());

    // presently only allow 1 or 2 bytes per sample
    IntRegistryEntry 
        sampleBytes("AUDIO", PREF_AUDIO_SAMPLE_BYTES, CANONICALSAMPLEBYTES);
    int tmpSampleBytes = sampleBytes.GetValue();
    if(tmpSampleBytes < 1)
        miscPrefs._sampleBytes = 1;
    else if(tmpSampleBytes > 2)
        miscPrefs._sampleBytes = 2;
    else
        miscPrefs._sampleBytes = tmpSampleBytes;
}


/*****************************************************************************
Initialize the static values in this file.
*****************************************************************************/

void InitializeModule_MiscPref()
{
    ExtendPreferenceUpdaterList(UpdateUserPreferences);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\ddrender.cpp ===
/* -*-C++-*-  */
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Code for the Direct-Draw geometry renderer.  These functions and structures
are used to render 3D geometry onto a DirectDraw surface.
*******************************************************************************/

#include "headers.h"

#include <limits.h>

#include "appelles/xform.h"

#include "privinc/ddrender.h"
#include "privinc/dddevice.h"
#include "privinc/camerai.h"
#include "privinc/xformi.h"
#include "privinc/matutil.h"
#include "privinc/bbox2i.h"
#include "privinc/bbox3i.h"
#include "privinc/lighti.h"
#include "privinc/hresinfo.h"
#include "privinc/ddutil.h"
#include "privinc/d3dutil.h"
#include "privinc/debug.h"
#include "privinc/except.h"
#include "privinc/util.h"
#include "privinc/stlsubst.h"
#include "privinc/movieimg.h"
#include "privinc/geometry.h"
#include "privinc/resource.h"
#include "privinc/rmvisgeo.h"
#include "privinc/comutil.h"
#include "privinc/cachdimg.h"
#include "privinc/opt.h"
#include "privinc/vec3i.h"

#if FIXED_POINT_INTERNAL
    #error "D3D Fixed-point specified; we assume floating point."
#endif

    // Local Variables

static CritSect *D3DCritSect = NULL;    // D3D Critical Section



/*****************************************************************************
The context attribute state manages the current attribute values during
rendering traversal.
*****************************************************************************/

void CtxAttrState::InitToDefaults (void)
{
    _transform   = identityTransform3;
    _emissive    = NULL;
    _ambient     = NULL;
    _diffuse     = NULL;
    _specular    = NULL;
    _specularExp = -1;
    _opacity     = -1;
    _texmap      = NULL;
    _texture     = NULL;
    _tdBlend     = false;

    _depthEmissive    = 0;
    _depthAmbient     = 0;
    _depthDiffuse     = 0;
    _depthSpecular    = 0;
    _depthSpecularExp = 0;
    _depthTexture     = 0;
    _depthTDBlend     = 0;
}



/*****************************************************************************
The following are necessary for STL.
*****************************************************************************/

bool PreTransformedImageBundle::operator< (
    const PreTransformedImageBundle &b) const
{
    bool result = (width < b.width ||
                   height < b.height ||
                   preTransformedImageId < b.preTransformedImageId);

    return result;
}


bool PreTransformedImageBundle::operator== (
    const PreTransformedImageBundle &b) const
{

    bool result = (width == b.width &&
                   height == b.height &&
                   preTransformedImageId == b.preTransformedImageId);

    return result;
}




/*****************************************************************************
Startup/Shutdown functions for this module.
*****************************************************************************/

void InitDDRender (void)
{
    D3DCritSect = NEW CritSect;
}

void ShutdownDDRender (void)
{
    delete D3DCritSect;
}



/*****************************************************************************
This function creates and initializes a new GeomRenderer object according to
the current platform.
*****************************************************************************/

GeomRenderer* NewGeomRenderer (
    DirectDrawViewport *viewport,   // Owning Viewport
    DDSurface          *ddsurf)     // Destination DDraw Surface
{
    GeomRenderer *geomRenderer;

    if (GetD3DRM3())
        geomRenderer = NEW GeomRendererRM3();
    else
    {
        geomRenderer = NEW GeomRendererRM1();
    }

    viewport->AttachCurrentPalette(ddsurf->IDDSurface());

    if (FAILED(geomRenderer->Initialize (viewport, ddsurf)))
    {   
        delete geomRenderer;
        geomRenderer = NULL;
    }

    // print out the ddobj associated with ddsurf

    #if _DEBUG
    {
        if (IsTagEnabled(tagDirectDrawObject))
        {
            IUnknown *lpDD = NULL;

            TraceTag((tagDirectDrawObject, "NewGeomRenderer%s (%x) ...",
                      GetD3DRM3() ? "3" : "1", geomRenderer));

            DDObjFromSurface(ddsurf->IDDSurface(), &lpDD, true);

            RELEASE( lpDD );
        }
    }
    #endif

    return geomRenderer;
}





//////////////////////////////////////////////////////////////////////////////
///////////////////////////////   GeomRenderer   /////////////////////////////
//////////////////////////////////////////////////////////////////////////////

long GeomRenderer::_id_next = 0;

GeomRenderer::GeomRenderer (void)
    : _imageDevice          (NULL),
      _renderState          (RSUninit),
      _doImageSizedTextures (false),
      _targetSurfWidth      (0),
      _targetSurfHeight     (0),
      _camera               (0)
{
    CritSectGrabber csg(*D3DCritSect);
    _id = _id_next++;
}


GeomRenderer::~GeomRenderer (void)
{
}



/*****************************************************************************
The following methods manage composing attributes.
*****************************************************************************/

Transform3 *GeomRenderer::GetTransform (void)
{   return _currAttrState._transform;
}

void GeomRenderer::SetTransform (Transform3 *xf)
{   _currAttrState._transform = xf;
}

Real GeomRenderer::GetOpacity (void)
{   return _currAttrState._opacity;
}

void GeomRenderer::SetOpacity (Real opacity)
{   _currAttrState._opacity = opacity;
}


/*****************************************************************************
The following methods manage the outer-overriding attributes.  The depth
counters indicate the depth of application.  Since we render in a top-down
traversal and our attributes are outer-overriding, this means that we only
change a given attribute when the depth transitions to or from 0.
*****************************************************************************/

void GeomRenderer::PushEmissive (Color *color)
{   if (_currAttrState._depthEmissive++ == 0)
        _currAttrState._emissive = color;
}

void GeomRenderer::PopEmissive (void)
{   if (--_currAttrState._depthEmissive == 0)
        _currAttrState._emissive = NULL;
}

//------------------------------------------------------

void GeomRenderer::PushAmbient (Color *color)
{   if (_currAttrState._depthAmbient++ == 0)
        _currAttrState._ambient = color;
}

void GeomRenderer::PopAmbient (void)
{   if (--_currAttrState._depthAmbient == 0)
        _currAttrState._ambient = NULL;
}

//------------------------------------------------------

void GeomRenderer::PushSpecular (Color *color)
{   if (_currAttrState._depthSpecular++ == 0)
        _currAttrState._specular = color;
}

void GeomRenderer::PopSpecular (void)
{   if (--_currAttrState._depthSpecular == 0)
        _currAttrState._specular = NULL;
}

//------------------------------------------------------

void GeomRenderer::PushSpecularExp (Real power)
{   if (_currAttrState._depthSpecularExp++ == 0)
        _currAttrState._specularExp = (power < 1) ? 1.0 : power;
}

void GeomRenderer::PopSpecularExp (void)
{   if (--_currAttrState._depthSpecularExp == 0)
        _currAttrState._specularExp = -1;
}

//------------------------------------------------------

void GeomRenderer::PushDiffuse (Color *color)
{
    if (  (0 == _currAttrState._depthDiffuse++)
       && (_currAttrState._tdBlend || !_currAttrState._texture)
       )
    {
        _currAttrState._diffuse = color;
    }
}

void GeomRenderer::PopDiffuse (void)
{   if (0 == --_currAttrState._depthDiffuse)
        _currAttrState._diffuse = NULL;
}

//------------------------------------------------------

void GeomRenderer::PushTexture (void *texture)
{
    if (!g_prefs3D.texmapping) return;

    if (  (_currAttrState._depthTexture++ == 0)
       && (_currAttrState._tdBlend || !_currAttrState._diffuse)
       )
    {
        _currAttrState._texture   = texture;
    }
}

void GeomRenderer::PopTexture (void)
{
    if (!g_prefs3D.texmapping) return;

    if (--_currAttrState._depthTexture == 0)
    {   _currAttrState._texture   = NULL;
    }
}

//------------------------------------------------------

void GeomRenderer::PushTexDiffBlend (bool blended)
{
    if (0 == _currAttrState._depthTDBlend++)
        _currAttrState._tdBlend = blended;
}

void GeomRenderer::PopTexDiffBlend (void)
{
    if (0 == --_currAttrState._depthTDBlend)
        _currAttrState._tdBlend = false;
}



/*****************************************************************************
This routine adjusts the given texture dimensions according to the limitations
(if any) of the underlying rendering device.  Devices may require textures
that are powers of two in width or height, or that are square.  In either
case, size the texture up to meet the requirements.
*****************************************************************************/

void AdjustTextureSize (
    D3DDEVICEDESC *deviceDesc,
    int           *pixelsWide,
    int           *pixelsHigh)
{
    if (deviceDesc->dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_POW2) {
        *pixelsWide = CeilingPowerOf2 (*pixelsWide);
        *pixelsHigh = CeilingPowerOf2 (*pixelsHigh);
    }

    if (deviceDesc->dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_SQUAREONLY) {
        *pixelsWide = *pixelsHigh = MAX (*pixelsWide, *pixelsHigh);
    }
}



/*****************************************************************************
This routine determines the pixel dimensions of the given image, depending on
its type.
*****************************************************************************/

void FigureOutTextureSize(
    Image                 *image,
    DirectDrawImageDevice *imageDevice,
    D3DDEVICEDESC         *deviceDesc,
    int                   *pixelsWide,
    int                   *pixelsHigh,
    bool                  *letD3DScaleIt,
    bool                   doImageSizedTextures)
{
    *letD3DScaleIt = false;

    // For images of arbitrary size (e.g. rendered 3D images), we just use an
    // arbitrary default dimension.

    *pixelsHigh = DEFAULT_TEXTURE_HEIGHT;
    *pixelsWide = DEFAULT_TEXTURE_WIDTH;

    if( doImageSizedTextures ) {

        DiscreteImage *discImg =
            image->CheckImageTypeId(DISCRETEIMAGE_VTYPEID)?
            SAFE_CAST(DiscreteImage *,image):
            NULL;

        LONG lw = *pixelsWide, lh = *pixelsHigh;

        // Fetch the actual pixel dimensions if the image is discrete,
        // otherwise figure out the display pixel dimensions of the bounded
        // image in real units.

        if( discImg ) {
            lw = discImg->GetPixelWidth();
            lh = discImg->GetPixelHeight();
        } else {
            Bbox2 box = image->BoundingBox();
            if((box != NullBbox2) && (box != UniverseBbox2))  {
                Real w, h;
                w = box.Width();
                h = box.Height();
                lw = LONG(w * imageDevice->GetResolution());
                lh = LONG(h * imageDevice->GetResolution());
            }
        }

        if( (lw <= deviceDesc->dwMaxTextureWidth  &&
             lh <= deviceDesc->dwMaxTextureHeight) ||
            (deviceDesc->dwMaxTextureWidth == 0  ||
             deviceDesc->dwMaxTextureHeight == 0) ) {

            *pixelsHigh = lh;
            *pixelsWide = lw;

            // Ultimately, we'll want to do high quality filtered scales (up
            // and down) so that the texture looks really good.  for now it's
            // just as good to have d3d do it.

            *letD3DScaleIt = true;
        }
    }

    if ( !letD3DScaleIt ) {
        AdjustTextureSize (deviceDesc,pixelsWide,pixelsHigh);
    }
}



/*****************************************************************************
Map the [0,1] region of the image onto the centered box of width x height,
since that's what will be texture mapped onto the geometry, and, for now, we
assume texture bounds of [0,1].  Note that this is based on the *nominal*
pixel height and width, and not necessarily the actual height and width, since
that may have been adjusted through the use of RenderingResolution().
*****************************************************************************/

Image *BuildTransformedImage (Image *image,int pixelsWide,int pixelsHigh)
{
    Real pixel     = 1.0 / ::ViewerResolution();
    Real scaleFacX = pixelsWide * pixel;
    Real scaleFacY = pixelsHigh * pixel;
    Real xltFacX   = - (pixelsWide / 2) * pixel;
    Real xltFacY   = - (pixelsHigh / 2) * pixel;

    Transform2 *sc  = ScaleRR (scaleFacX, scaleFacY);
    Transform2 *xlt = TranslateRR (xltFacX, xltFacY);
    Transform2 *xf  = TimesTransform2Transform2 (xlt, sc);

    return TransformImage (xf,image);
}



/*****************************************************************************
This function Derives a texture handle & a D3DTexture from image & geometry.
As a side effect, it notifies D3DRM if the texture contents have changed.
*****************************************************************************/

void* GeomRenderer::DeriveTextureHandle (
    Image                 *origImage,
    bool                   applyAsVrmlTexture,
    bool                   oldStyle,
    DirectDrawImageDevice *imageDevice)
{
    if (!imageDevice) {
        imageDevice = _imageDevice;
    }

    AssertStr (imageDevice, "NULL imageDevice in DeriveTextureHandle");
    AssertStr ((origImage != 0), "DeriveTextureHandle has null image ptr");

    bool letD3DScaleIt;
    int pixelsHigh;
    int pixelsWide;

    // If we're doing old-style texturing, we need to tile finite source images
    // and crop to [0,0]x[1,1] infinite source images.

    if (oldStyle)
    {
        Bbox2 imgbox = origImage->BoundingBox();

        if (_finite(imgbox.Width()) && _finite(imgbox.Height()))
        {
            origImage = TileImage (origImage);
        }
        else
        {
            Point2 min(0,0);
            Point2 max(1,1);

            origImage = CreateCropImage (min, max, origImage);
        }
    }

    FigureOutTextureSize
    (   origImage, imageDevice, &_deviceDesc, &pixelsWide, &pixelsHigh,
        &letD3DScaleIt, GetDoImageSizedTextures()
    );

    Image *imageToUse;

    if (applyAsVrmlTexture) {

        TraceTag ((tagGTextureInfo, "Applied as VRML texture."));

        Assert(DYNAMIC_CAST(DiscreteImage *, origImage) != NULL
               && "Expected vrml textures to always be DiscreteImages");
        imageToUse = origImage;

    } else {

        // See if we have an image stashed away that maps the original image
        // to pixelsWide by pixelsHigh.  This will occur if we are multiply
        // instancing a textured geometry with the same texture.

        imageToUse = LookupInIntraFrameTextureImageCache
                         (pixelsWide, pixelsHigh, origImage->Id(), oldStyle);

        if (!imageToUse) {

            imageToUse = BuildTransformedImage(origImage,pixelsWide,pixelsHigh);

            TraceTag ((tagGTextureInfo,
                "Adding xformed img %x (id %lx) to intraframe cache.",
                imageToUse, imageToUse->Id()));

            AddToIntraFrameTextureImageCache
                (pixelsWide, pixelsHigh, origImage->Id(), imageToUse, oldStyle);

        } else {
            TraceTag ((tagGTextureInfo,
                "Found intra-frame cached image %x (id %lx)",
                imageToUse, imageToUse->Id()));
        }
    }

    DWORD colorKey;
    bool keyIsValid = false;
    bool old_static_image;

    DDSurface *imdds =
        imageDevice->RenderImageForTexture (
            imageToUse,
            pixelsWide,
            pixelsHigh,
            &colorKey,
            &keyIsValid,
            old_static_image,
            false,
            imageDevice->_freeTextureSurfacePool,
            imageDevice->_intraFrameUsedTextureSurfacePool,
            NULL,
            NULL,
            NULL,
            oldStyle);

    IDirectDrawSurface *imsurf = imdds->IDDSurface();

    bool dynamic = !old_static_image;

    #if _DEBUG
    {
        if (IsTagEnabled(tagForceTexUpd))
            dynamic = true;
    }
    #endif

    void *texhandle = LookupTextureHandle (imsurf,colorKey,keyIsValid,dynamic);

    TraceTag ((tagGTextureInfo, "Rendered to surface %x", imsurf));
    TraceTag ((tagGTextureInfo, "Surface yields texhandle %x", texhandle));

    return texhandle;
}



/*****************************************************************************
The following methods manage the interframe texture cache.
*****************************************************************************/

void GeomRenderer::ClearIntraFrameTextureImageCache()
{
    _intraFrameTextureImageCache.erase(
        _intraFrameTextureImageCache.begin(),
        _intraFrameTextureImageCache.end());
    _intraFrameTextureImageCacheUpsideDown.erase(
        _intraFrameTextureImageCacheUpsideDown.begin(),
        _intraFrameTextureImageCacheUpsideDown.end());
}



/*****************************************************************************
*****************************************************************************/

void GeomRenderer::AddToIntraFrameTextureImageCache (
    int    width,
    int    height,
    long   origImageId,
    Image *finalImage,
    bool   upsideDown)
{
    PreTransformedImageBundle bundle;
    bundle.width = width;
    bundle.height = height;
    bundle.preTransformedImageId = origImageId;

    #if _DEBUG
    {   // Pre-condition is that the image hasn't yet been added to the cache.
        if (upsideDown) {
            imageMap_t::iterator i;
            i = _intraFrameTextureImageCacheUpsideDown.find(bundle);
            Assert (i == _intraFrameTextureImageCacheUpsideDown.end());
        } else {
            imageMap_t::iterator i;
            i = _intraFrameTextureImageCache.find(bundle);
            Assert (i == _intraFrameTextureImageCache.end());
        }
    }
    #endif

    if (upsideDown) {
        _intraFrameTextureImageCacheUpsideDown[bundle] = finalImage;
    } else {
        _intraFrameTextureImageCache[bundle] = finalImage;
    }
}



/*****************************************************************************
*****************************************************************************/

Image *GeomRenderer::LookupInIntraFrameTextureImageCache (
    int  width,
    int  height,
    long origImageId,
    bool upsideDown)
{
    PreTransformedImageBundle bundle;
    bundle.width = width;
    bundle.height = height;
    bundle.preTransformedImageId = origImageId;

    if (upsideDown) {
        imageMap_t::iterator i =
            _intraFrameTextureImageCacheUpsideDown.find(bundle);

        if (i != _intraFrameTextureImageCacheUpsideDown.end()) {
            return (*i).second;
        }
    } else {
        imageMap_t::iterator i = _intraFrameTextureImageCache.find(bundle);

        if (i != _intraFrameTextureImageCache.end()) {
            return (*i).second;
        }
    }

    return NULL;
}



/*****************************************************************************
This method governs transitions from state to state in the geometry renderer.
We return true if all proceeded according to protocol.  Any invalid transition
puts the renderer object in a scram state, which effectively shuts it down
from further operation.
*****************************************************************************/

bool GeomRenderer::SetState (RenderState state)
{
    // If we're currently in scram state, then just return false.

    if (_renderState == RSScram)
        return false;

    // Keep track of initial state for debugging.

    DebugCode (RenderState oldState = _renderState;)

    switch (state)
    {
        // We can transition from any state into the ready state.  However,
        // we should always be coming from some other state.

        case RSReady:
            _renderState = (_renderState != RSReady) ? RSReady : RSScram;
            break;

        // Transitioning to rendering or picking means we have to currently be
        // in a ready state.

        case RSRendering:
        case RSPicking:
            _renderState = (_renderState == RSReady) ? state : RSScram;
            break;

        default:
            AssertStr (0, "Invalid Render State");
            _renderState = RSScram;
            break;
    }

    if (_renderState == RSScram)
    {
        TraceTag ((tagError, "!!! Bad State: GeomRenderer[%d]", _id));
        return false;
    }

    return true;
}






//////////////////////////////////////////////////////////////////////////////
/////////////////////////////   GeomRendererRM1   ////////////////////////////
//////////////////////////////////////////////////////////////////////////////

GeomRendererRM1::GeomRendererRM1 (void)
    :
    _d3d          (NULL),
    _d3drm        (NULL),
    _surface      (NULL),
    _viewport     (NULL),
    _Rdevice      (NULL),
    _Rviewport    (NULL),
    _Idevice      (NULL),
    _Iviewport    (NULL),
    _scene        (NULL),
    _camFrame     (NULL),
    _geomFrame    (NULL),
    _texMeshFrame (NULL),
    _amblight     (NULL),
    _pickReady    (false)
{
    TraceTag ((tagGRenderObj, "Creating GeomRendererRM1[%x]", _id));

    _lastrect.right  =
    _lastrect.left   =
    _lastrect.top    =
    _lastrect.bottom = -1;

    ZEROMEM (_Iviewdata);

    _Iviewdata.dwSize = sizeof (_Iviewdata);
    _Iviewdata.dvMaxX = D3DVAL (1);
    _Iviewdata.dvMaxY = D3DVAL (1);
    _Iviewdata.dvMinZ = D3DVAL (0);
    _Iviewdata.dvMaxZ = D3DVAL (1);
}



GeomRendererRM1::~GeomRendererRM1 (void)
{
    TraceTag ((tagGRenderObj, "Destroying GeomRendererRM1[%x]", _id));

    // Release each light in the light pool.

    // Delete each light in the light pool.  For each framed light, the only
    // reference to the light will be the frame, and the only refence to the
    // light frame will be the scene frame.

    _nextlight = _lightpool.begin();

    while (_nextlight != _lightpool.end())
    {   (*_nextlight)->frame->Release();
        delete (*_nextlight);
        ++ _nextlight;
    }

    // Release texture handles

    SurfTexMap::iterator i = _surfTexMap.begin();

    while (i != _surfTexMap.end())
    {   (*i++).second -> Release();
    }

    // Release retained-mode objects.

    RELEASE (_amblight);

    RELEASE (_texMeshFrame);
    RELEASE (_geomFrame);
    RELEASE (_camFrame);
    RELEASE (_scene);

    RELEASE (_Rviewport);
    RELEASE (_Rdevice);

    // Release immediate-mode objects.

    if (_Iviewport && _Idevice) {
        _Idevice->DeleteViewport (_Iviewport);
    }

    RELEASE (_Iviewport);
    RELEASE (_Idevice);
    RELEASE (_d3drm);
    RELEASE (_d3d);

    if (_viewport) _viewport->RemoveGeomDev (this);
}



/*****************************************************************************
Initialization of the RM1 geometry rendering class.
*****************************************************************************/

HRESULT GeomRendererRM1::Initialize (
    DirectDrawViewport *viewport,
    DDSurface          *ddsurf)      // Destination DDraw Surface
{
    // Initialize() can only be called once.

    if (_renderState != RSUninit) return E_FAIL;

    _surface = ddsurf->IDDSurface();

    HRESULT result;    // Error Return Code

    // stash away dimensions of target surface

    DDSURFACEDESC desc;
    ZeroMemory(&desc,sizeof(DDSURFACEDESC));
    desc.dwSize = sizeof(DDSURFACEDESC);
    desc.dwFlags = DDSD_HEIGHT | DDSD_WIDTH;
    if (FAILED(AD3D(result = _surface->GetSurfaceDesc(&desc))))
        return result;
    _targetSurfWidth = desc.dwWidth;
    _targetSurfHeight = desc.dwHeight;

    DWORD targetBitDepth = ddsurf->GetBitDepth();
    if ( targetBitDepth == 8 )
    {
        // We want D3D to always obey our palette without changing it.  To
        // enforce that, we grab the palette from every surface that comes our
        // way, set the D3D palette read-only flag on each entry, and store it
        // back to the surface.  Note that D3D v3 devices have a bug in that
        // they ignore subsequent changes to the palette on the target surface
        // palette.  This bug works in our favor for now, since we only have
        // to set the flags once on initialization.  For a change in palette,
        // the *surface* (not just the rendering device) must be released.

        // Get the palette from the target surface, extract the individual
        // palette entries, set the D3D read-only flag, and then write the
        // entries back to the surface's palette.

        IDirectDrawPalette *palette;

        if (FAILED(AD3D(result = _surface->GetPalette(&palette))))
            return result;

        PALETTEENTRY entries[256];

        if (FAILED(AD3D(result = palette->GetEntries (0, 0, 256, entries))))
            return result;

        if (!(entries[0].peFlags & D3DPAL_READONLY)) {
            TraceTag ((tagGRenderObj,
                "GeomRendererRM1::Initialize - making palette readonly."));

            int i;
            for (i=0;  i < 256;  ++i)
                entries[i].peFlags = D3DPAL_READONLY;

            result = palette->SetEntries (0, 0, 256, entries);

            if (FAILED(AD3D(result)))
                return result;
        }

        palette->Release();
    }

    // Get the main interface for Direct3D immediate-mode.

    result = viewport->DirectDraw2()
           -> QueryInterface(IID_IDirect3D,(void**)&_d3d);

    if (FAILED(AD3D(result)))
        return result;

    // Find the available 3D rendering devices for the given DDraw object.

    ChosenD3DDevices *chosenDevs = SelectD3DDevices (viewport->DirectDraw1());

    // Use the hardware renderer if one is available for the bitdepth of the
    // target surface, the surface is in video memory, and hardare rendering
    // is enabled.

    GUID devguid;

    if (ddsurf->IsSystemMemory())
    {
        devguid = chosenDevs->software.guid;
        _deviceDesc = chosenDevs->software.desc;
        TraceTag ((tag3DDevSelect, "Using 3D Software Renderer"));
    }
    else
    {
        devguid = chosenDevs->hardware.guid;
        _deviceDesc = chosenDevs->hardware.desc;

        // The surface is in video memory; ensure that we have a hardware
        // renderer available to use.

        if (devguid == GUID_NULL)
        {   TraceTag ((tag3DDevSelect,
                "No 3D HW renderer available for videomem target."));
            return E_FAIL;
        }

        // Ensure that the chosen HW renderer supports the target bitdepth.

        if (!(_deviceDesc.dwDeviceRenderBitDepth
                    & BPPtoDDBD( targetBitDepth )))
        {
            TraceTag ((tag3DDevSelect,
                "3D hardware does not support target bit depth of %d.",
                targetBitDepth ));
            return E_FAIL;
        }

        TraceTag ((tag3DDevSelect, "Using 3D Hardware Renderer"));
    }

    if (devguid == GUID_NULL) {
        TraceTag ((tag3DDevSelect,"No 3D hardware or software renderer found!"));
        return E_FAIL;
    }

    // NOTE:  The following QI will fail if the target machine has debug DDraw
    //        DLL's and retail DDrawEx.DLL.

    result = _surface->QueryInterface (devguid, (void**)&_Idevice);

    if (FAILED(AD3D(result)))
        return result;

    // Get the main D3D retained-mode object.

    _d3drm = GetD3DRM1();
    _d3drm->AddRef();

    result = _d3drm->CreateDeviceFromD3D (_d3d, _Idevice, &_Rdevice);
    if (FAILED(AD3D(result)))
        return result;

    // Set the rendering preferences.

    TraceTag
    ((  tagGRenderObj, "Current Rendering Preferences:\n"
            "\t%s, %s, %s\n"
            "\tdithering %s, texmapping %s, perspective texmap %s\n"
            "\tQuality flags %08x\tTexture Quality %s",
        (g_prefs3D.lightColorMode == D3DCOLOR_RGB) ? "RGB" : "mono",
        (g_prefs3D.fillMode == D3DRMFILL_SOLID) ? "solid"
            : ((g_prefs3D.fillMode == D3DRMFILL_WIREFRAME) ? "wireframe"
                : "points"),
        (g_prefs3D.shadeMode == D3DRMSHADE_FLAT) ? "flat"
            : ((g_prefs3D.shadeMode == D3DRMSHADE_GOURAUD) ? "Gouraud"
                : "Phong"),
        g_prefs3D.dithering ? "on" : "off",
        g_prefs3D.texmapping ? "on" : "off",
        g_prefs3D.texmapPerspect ? "on" : "off",
        g_prefs3D.qualityFlags,
        g_prefs3D.texturingQuality == D3DRMTEXTURE_NEAREST ? "nearest"
                      : "bilinear"
    ));

    result = AD3D(_Rdevice->SetDither (g_prefs3D.dithering));
    if (FAILED(result)) return result;

    _texQuality = g_prefs3D.texturingQuality;
    result = AD3D(_Rdevice->SetTextureQuality (_texQuality));
    if (FAILED(result)) return result;

    result = AD3D(_Rdevice->SetQuality (g_prefs3D.qualityFlags));
    if (FAILED(result)) return result;

    // Create the immediate-mode viewport object.

    result = _d3d->CreateViewport (&_Iviewport, NULL);
    if (FAILED(AD3D(result)))
        return result;

    result = _Idevice->AddViewport (_Iviewport);
    if (FAILED(AD3D(result)))
        return result;

    // Create the primary scene frame, the camera frame, and the lights frame.

    if (  FAILED (AD3D (result=_d3drm->CreateFrame (0,&_scene)))
       || FAILED (AD3D (result=_d3drm->CreateFrame (_scene, &_camFrame)))
       || FAILED (AD3D (result=_d3drm->CreateFrame (_scene, &_geomFrame)))
       )
    {
        return result;
    }

    result = _geomFrame->SetMaterialMode (D3DRMMATERIAL_FROMMESH);
    if (FAILED(AD3D(result)))
        return result;

    result = _d3drm->CreateLightRGB (D3DRMLIGHT_AMBIENT, 0,0,0, &_amblight);
    if (FAILED(AD3D(result)))
        return result;

    if (FAILED(AD3D(result=_scene->AddLight(_amblight))))
        return result;

    (_viewport = viewport) -> AddGeomDev (this);

    return SetState(RSReady) ? NOERROR : E_FAIL;
}



/*****************************************************************************
Renders the given geometry onto the associated DirectDraw surface.
*****************************************************************************/

void GeomRendererRM1::RenderGeometry (
    DirectDrawImageDevice *imgDev,
    RECT                   target,    // Target Rectangle on DDraw Surface
    Geometry              *geometry,  // Geometry to Render
    Camera                *camera,    // Viewing Camera
    const Bbox2           &viewbox)   // Source Region in Camera Coordinates
{
    if (!SetState(RSRendering)) return;

    // The camera pointer is only relevant in a single frame, and while
    // rendering.  It gets reset back to nil to ensure that we don't incur a
    // leak by holding the value across frames.

    Assert (_camera == 0);
    _camera = camera;

    _imageDevice = imgDev;  // Set image dev for this frame

    // Initialize the rendering state and D3D renderer.

    BeginRendering (target, geometry, viewbox);

    // Render the geometry only if it is visible.  The geometry may be
    // completely behind us, for example.

    if (_geomvisible)
    {   geometry->Render (*this);
        _pickReady = true;
    }
    else
        TraceTag ((tagGRendering, "Geometry is invisible; skipping render"));

    // Clean up after rendering.

    EndRendering ();

    DebugCode (_imageDevice = NULL);
    _camera = NULL;

    SetState (RSReady);
}



/*****************************************************************************
This procedure prepares the 3D DD renderer before traversing the tree.  It is
primarily responsible for initializing the graphics state and setting up D3D
for rendering.
*****************************************************************************/

void GeomRendererRM1::BeginRendering (
    RECT      target,    // Target DDraw Surface Rectangle
    Geometry *geometry,  // Geometry To Render
    const Bbox2 &region)    // Target Region in Camera Coordinates
{
    TraceTag ((tagGRendering, "BeginRendering"));

    // Set up the camera.  If it turns out that the geometry is invisible,
    // then just return.

    SetView (&target, region, geometry->BoundingVol());

    if (!_geomvisible) return;

    // We're using D3D immediate-mode because retained-mode doesn't (yet)
    // have the ability to clear only the Z buffer.

    TraceTag ((tagGRendering, "Clearing Z buffer."));
    TD3D (_Iviewport->Clear (1, (D3DRECT*)(&target), D3DCLEAR_ZBUFFER));

    // Reset the object pools.

    _nextlight = _lightpool.begin();

    // Initialize the geometry state and material attributes.

    _currAttrState.InitToDefaults();

    // Preprocess the textures in the scene graph.

    geometry->CollectTextures (*this);

    // Gather the light sources from the geometry.

    _ambient_light.SetRGB (0,0,0);    // Initialize to black

    LightContext lcontext (this);

    geometry->CollectLights (lcontext);

    // Since the ambient light is really the accumulation of all ambient lights
    // found in the geometry, we add the total contribution here as a single
    // ambient light.

    TD3D (_amblight->SetColorRGB (
        D3DVALUE (_ambient_light.red),
        D3DVALUE (_ambient_light.green),
        D3DVALUE (_ambient_light.blue)));

    // Reset the texture quality if it's changed.

    if (_texQuality != g_prefs3D.texturingQuality)
    {
        _texQuality = g_prefs3D.texturingQuality;
        TD3D (_Rdevice->SetTextureQuality (_texQuality));
    }
}



/*****************************************************************************
This routine is called after the rendering traversal of the geometry is
completed.
*****************************************************************************/

void GeomRendererRM1::EndRendering (void)
{
    // Ensure that all attributes have been popped.

    Assert (  !_geomvisible ||
        !(_currAttrState._depthEmissive||
          _currAttrState._depthAmbient||
          _currAttrState._depthDiffuse||
          _currAttrState._depthSpecular||
          _currAttrState._depthSpecularExp||
          _currAttrState._depthTexture));

    TraceTag ((tagGRendering, "EndRendering"));

    TD3D (_Rdevice->Update());

    // Detach all light sources from the scene.

    _nextlight = _lightpool.begin();

    while (_nextlight != _lightpool.end())
    {
        if ((*_nextlight)->active)
        {   TD3D (_scene->DeleteChild ((*_nextlight)->frame));
            (*_nextlight)->active = false;
        }
        ++ _nextlight;
    }

    ClearIntraFrameTextureImageCache();
}



/*****************************************************************************
This function sets up the RM and IM viewports given the target rectangle.
*****************************************************************************/

void GeomRendererRM1::SetupViewport (RECT *target)
{
    // If the current target rectangle is the same as the last one, then reset
    // the camera and continue, otherwise we need to re-configure the D3DRM
    // viewport.

    if (!target || (*target == _lastrect))
    {
        TD3D (_Rviewport->SetCamera (_camFrame));
    }
    else
    {
        LONG width  = target->right  - target->left;
        LONG height = target->bottom - target->top;

        // If the viewport already exists, then re-configure and set the
        // updated camera frame.  If the D3DRM viewport does not yet exist,
        // then we create it here.

        if (_Rviewport)
        {
            TD3D (_Rviewport->Configure
                  ((LONG) target->left, (LONG) target->top, width, height));
            TD3D (_Rviewport->SetCamera (_camFrame));
        }
        else
        {
            TD3D (_d3drm->CreateViewport (
                _Rdevice, _camFrame,
                target->left, target->top, width, height, &_Rviewport));
        }

        // Reset the IM viewport.

        D3DRECT *d3d_rect = (D3DRECT*) target;

        _Iviewdata.dwX      = target->left;
        _Iviewdata.dwY      = target->top;
        _Iviewdata.dwWidth  = width;
        _Iviewdata.dwHeight = height;
        _Iviewdata.dvScaleX = D3DVAL (width  / 2);
        _Iviewdata.dvScaleY = D3DVAL (height / 2);

        TD3D (_Iviewport->SetViewport (&_Iviewdata));

        _lastrect = *target;
    }

    TD3D (_Rviewport->SetUniformScaling (FALSE));
}



/*****************************************************************************
This function sets the D3D viewing projection based on the given camera.
*****************************************************************************/

    // Because of a VC5 bug, we can only force option P (honor float casts)
    // around certain pieces of code.  For example, if you turn on -Op for the
    // whole project, you'll get erroneous complaints about overfloat in
    // static constant assignments.  We need to do strict single-precision
    // arithmetic here before we hand values off to D3D, or we'll choke.

#pragma optimize ("p", on)

#pragma warning(disable:4056)

void GeomRendererRM1::SetView (
    RECT   *target,      // Target Rectangle on Surface
    const Bbox2 &iview,  // Idealized 2D Viewport In The Image Plane
    Bbox3  *volume)      // Volume to View
{
    // First load the camera/viewing transform into the camera frame.  Note
    // that the Appelles camera is centered at the origin of the image plane,
    // while the D3D RM camera is centered at the projection point.  Thus, we
    // need to translate back to the projection point and then get the camera-
    // to-world transform.

    Real Sx, Sy, Sz;
    _camera->GetScale (&Sx, &Sy, &Sz);

    // Clamp the maximum projection point distance to 10^4, since greater
    // distances will clobber Z resolution and make the front and back clip
    // planes take the same values.

    const Real Zclamp = 1e4;

    if (Sz > Zclamp) Sz = Zclamp;

    D3DRMMATRIX4D d3dmat;

    LoadD3DMatrix
        (d3dmat, TimesXformXform (_camera->CameraToWorld(),Translate(0,0,-Sz)));

    TD3D (_camFrame->AddTransform (D3DRMCOMBINE_REPLACE, d3dmat));

    if (target) {
        if ((target->left >= target->right) ||
            (target->top >= target->bottom) ||
            (target->top < 0) ||
            (target->bottom > _targetSurfHeight) ||
            (target->left < 0) ||
            (target->right > _targetSurfWidth))
        {   _geomvisible = false;
            return;
        }
    }

    SetupViewport (target);

    if (_camera->Type() == Camera::PERSPECTIVE)
    {   TD3D (_Rviewport->SetProjection (D3DRMPROJECT_PERSPECTIVE));
    }
    else
    {   TD3D (_Rviewport->SetProjection (D3DRMPROJECT_ORTHOGRAPHIC));
    }

    // Ensure that the geometry is viewable.  If we're looking at nil geometry,
    // then flag the geometry as invisible and return.

    if (!volume->PositiveFinite())
    {   _geomvisible = false;
        return;
    }

    // Get the near and far planes for the object and camera, and widen them
    // by 4 "clicks" in Z space.  Note that front and back are positive depths.

    Real front, back;
    const Real Zclicks = 4.0 / ((1<<16) - 1);

    _geomvisible = _camera->GetNearFar (volume, Zclicks, front, back);

    if (!_geomvisible) return;

    #if _DEBUG
    {
        double r = back / front;
        if (r > (2<<12))
        {   TraceTag ((tagWarning,
                "!!! Z-buffer resolution too low; far/near = %lg", r));
        }
    }
    #endif

    // If the front and back planes are identical, then we are looking at an
    // infinitely shallow object.  In this case, we need to move out the front
    // and back clip planes so that the object doesn't fall exactly on these
    // planes (and thus get clipped), and also because D3D fails if the front
    // and back planes are identical.  How much to move them out?  To work for
    // all cases, we manipulate the mantissa of the numbers directly.  If we
    // did something like add/subtract one, for example, this would be a no-op
    // if both numbers were very large, or would clobber resolution if they
    // were very small.  The following mantissa delta (8 bits) is just
    // something that works experimentally.

    D3DVALUE d3dFront = D3DVAL (front);
    D3DVALUE d3dBack  = D3DVAL (back);

    if (d3dFront == d3dBack)
    {
        const int delta = 1 << 8;

        d3dFront = MantissaDecrement (d3dFront, delta);
        d3dBack  = MantissaIncrement (d3dBack,  delta);
    }

    TD3D (_Rviewport->SetFront (d3dFront));
    TD3D (_Rviewport->SetBack  (d3dBack));

    // For perspective projection, we seek the viewport coordinates on the
    // front clipping plane where D3D wants them.  Since the target rectangle
    // is given on the image plane (Z=0), we do the following calculation.
    // X and Y for the front plane are scaled by the ratio of the distance
    // between the projection point and the front plane, and the distance
    // between the projection point and the image plane.
    //                                                       Back
    //                                                       Plane
    //                                   Front              ___!---
    //                         Image     Plane      ___.---'   !
    //                         Plane       :___.---'           !
    //                           |  ___.---:                   !
    //                      ___.-|-'       :                   !
    //              ___.---'     |         :                   !
    //      ___.---'             |         :                   !
    //     *---------------------|---------:-------------------!--
    //      """`---.___          |         :                   !
    //     |           `---.___  |         :                   !
    //     |                   `-|-.___    :                   !
    //     |                     |     `---:___                !
    //     |                     |         :   `---.___        !
    //     |                     |         :           `---.___!
    //     |                     |         :                   !---
    //     |<------- Sz -------->|         :                   !
    //     |<------------- Front --------->:                   !
    //     |<---------------------- Back --------------------->!

    if (_camera->Type() == Camera::PERSPECTIVE)
    {
        Real Vscale = front / Sz;

        Sx *= Vscale;
        Sy *= Vscale;
    }

    D3DVALUE minX = D3DVAL(Sx*iview.min.x);
    D3DVALUE minY = D3DVAL(Sy*iview.min.y);
    D3DVALUE maxX = D3DVAL(Sx*iview.max.x);
    D3DVALUE maxY = D3DVAL(Sy*iview.max.y);

    if ((minX >= maxX) || (minY >= maxY))
    {   _geomvisible = false;
        return;
    }

    TD3D (_Rviewport->SetPlane (minX, maxX, minY, maxY));
}

#pragma warning(default:4056)
#pragma optimize ("", on)  // Restore optimization flags to original settings.



/*****************************************************************************
Render the given RM visual object to the current viewport.  Catch cases where
we fail rendering because the target surface was busy (usually due to another
app going fullscreen, e.g. screensavers).
*****************************************************************************/

void GeomRendererRM1::Render (IDirect3DRMFrame *frame)
{
    // Render the visual on the current viewport, and return if the operation
    // succeeded.

    HRESULT render_result = RD3D (_Rviewport->Render(frame));

    if (SUCCEEDED(render_result))
        return;

    // If we failed to render, then check to see if the surface was busy.  If
    // it was, raise a surface-busy exception back to the client.

    DDSURFACEDESC surfdesc;
    surfdesc.dwSize = sizeof (surfdesc);

    HRESULT lock_result = _surface->Lock (NULL, &surfdesc, 0, NULL);

    if (SUCCEEDED (lock_result))
        _surface->Unlock (NULL);

    if(lock_result == DDERR_SURFACELOST)
    {
        _surface->Restore();
        RaiseException_UserError(lock_result, 0);
    }

    if (lock_result == DDERR_SURFACEBUSY)
    {
        RaiseException_UserError(DAERR_VIEW_SURFACE_BUSY,
                                 IDS_ERR_IMG_SURFACE_BUSY);
    }

    // The surface is not busy, so we must have failed for some other reason.
    // Bail out via the standard exception mechanism.

    #if _DEBUG
        CheckReturnImpl (render_result, __FILE__, __LINE__, true);
    #else
        CheckReturnImpl (render_result, true);
    #endif
}



/*****************************************************************************
Submit a D3D RM1 visual for rendering.
*****************************************************************************/

void GeomRendererRM1::Render (RM1VisualGeo *geo)
{
    if (_renderState != RSRendering) return;

    IDirect3DRMVisual *vis = geo->Visual();

    Assert(vis);

    TD3D (_geomFrame->AddVisual (vis));

    // Set the modeling transform.

    D3DRMMATRIX4D d3dmat;
    LoadD3DMatrix (d3dmat, GetTransform());
    TD3D (_geomFrame->AddTransform (D3DRMCOMBINE_REPLACE, d3dmat));

    // Set the material attributes.

    Real opacity = _currAttrState._opacity;
    if (opacity < 0) opacity = 1.0;

    geo->SetMaterialProperties
    (   _currAttrState._emissive,
        (   (!_currAttrState._tdBlend && _currAttrState._texture)
            ?  white : _currAttrState._diffuse
        ),
        _currAttrState._specular,
        _currAttrState._specularExp,
        opacity,
        (IDirect3DRMTexture*) _currAttrState._texture,
        false,
        _id
    );

    geo->SetD3DQuality (g_prefs3D.qualityFlags);
    geo->SetD3DMapping (g_prefs3D.texmapPerspect ? D3DRMMAP_PERSPCORRECT : 0);

    // Render and clean up.

    Render (_geomFrame);

    TD3D (_geomFrame->DeleteVisual (geo->Visual()));
}



/*****************************************************************************
This is a hack for rendering a meshBuilder object using RM1.
*****************************************************************************/

void GeomRendererRM1::RenderMeshBuilderWithDeviceState (
    IDirect3DRMMeshBuilder3 *mb)
{
    // This is only used by DXTransforms, and DXTransforms are only
    // supported on GeomRendererRM3's and later.
    Assert(!"Shouldn't ever be here");
}



/*****************************************************************************
This function adds a given light with a given context to a geometry rendering
device.  NOTE:  All calls to this function must happen after BeginRendering
is called and before any geometry is rendered.
*****************************************************************************/

void GeomRendererRM1::AddLight (LightContext &context, Light &light)
{
    if (_renderState != RSRendering) return;

    LightType type = light.Type();

    // If the light source is an ambient light, then add its contribution to
    // the global ambient light level.

    if (type == Ltype_Ambient)
    {   _ambient_light.AddColor (*context.GetColor());
        return;
    }

    // Get a framed light object, either by re-using an existing one from the
    // framed light pool, or by creating a new one for the pool.

    FramedRM1Light *frlight;

    if (_nextlight != _lightpool.end())
    {   frlight = *_nextlight;
        ++ _nextlight;
        Assert (!frlight->active);   // The light should not be in use.
    }
    else
    {   frlight = NEW FramedRM1Light;
        VECTOR_PUSH_BACK_PTR (_lightpool, frlight);
        _nextlight = _lightpool.end();

        // Attach the frame to the scene frame (since we know we will be using
        // it this frame).

        TD3D (_d3drm->CreateFrame (_scene, &frlight->frame));

        frlight->light = 0;   // Signal for new light object creation.
    }

    // Get the corresponding D3DRM light type.

    D3DRMLIGHTTYPE d3dtype;
    switch (type)
    {   case Ltype_Spot:   d3dtype = D3DRMLIGHT_SPOT;        break;
        case Ltype_Point:  d3dtype = D3DRMLIGHT_POINT;       break;
        default:           d3dtype = D3DRMLIGHT_DIRECTIONAL; break;
    }

    // Get the D3DRM color of the light.

    Color &color = *context.GetColor();
    D3DVALUE Lr = D3DVAL (color.red);
    D3DVALUE Lg = D3DVAL (color.green);
    D3DVALUE Lb = D3DVAL (color.blue);

    // If we're re-using a D3DRM light, then just set the values, otherwise
    // create it here.

    if (frlight->light)
    {   TD3D (frlight->light->SetType (d3dtype));
        TD3D (frlight->light->SetColorRGB (Lr, Lg, Lb));
        TD3D (_scene->AddChild (frlight->frame));
    }
    else
    {   TD3D (_d3drm->CreateLightRGB (d3dtype, Lr,Lg,Lb, &frlight->light));
        TD3D (frlight->frame->AddLight (frlight->light));
        frlight->light->Release();
    }

    // Specify the position and oriention of the light.

    Apu4x4Matrix const xform = context.GetTransform()->Matrix();

    Point3Value  lpos ( xform.m[0][3],  xform.m[1][3],  xform.m[2][3]);
    Vector3Value ldir (-xform.m[0][2], -xform.m[1][2], -xform.m[2][2]);

    D3DVALUE Ux=D3DVAL(0), Uy=D3DVAL(1), Uz=D3DVAL(0);

    if ((ldir.x == 0) && (ldir.y == 1) && (ldir.z == 0))
    {   Ux = D3DVAL(1);
        Uy = D3DVAL(0);
    }

    TD3D (frlight->frame->SetPosition
             (_scene, D3DVAL(lpos.x), D3DVAL(lpos.y), D3DVAL(lpos.z)));

    TD3D (frlight->frame->SetOrientation
           (_scene, D3DVAL(ldir.x), D3DVAL(ldir.y), D3DVAL(ldir.z), Ux,Uy,Uz));

    // Set light attributes for positioned lights

    if ((type == Ltype_Point) || (type == Ltype_Spot))
    {
        // Light Attenuation

        Real a0, a1, a2;
        context.GetAttenuation (a0, a1, a2);

        // D3D does not accept 0 for the constant attenuation, so we clamp it
        // here to a minimum of some small epsilon.

        if (a0 < 1e-6)
            a0 = 1e-6;

        TD3D (frlight->light->SetConstantAttenuation  (D3DVAL(a0)));
        TD3D (frlight->light->SetLinearAttenuation    (D3DVAL(a1)));
        TD3D (frlight->light->SetQuadraticAttenuation (D3DVAL(a2)));

        // Light Range

        Real range = context.GetRange();

        if (range <= 0) range = D3DLIGHT_RANGE_MAX;

        TD3D (frlight->light->SetRange (D3DVAL(range)));
    }

    // Set light attributes for spot lights.

    if (type == Ltype_Spot)
    {
        Real cutoff, fullcone;
        light.GetSpotlightParams (cutoff, fullcone);

        TD3D (frlight->light->SetUmbra    (D3DVAL (fullcone)));
        TD3D (frlight->light->SetPenumbra (D3DVAL (cutoff)));
    }

    frlight->active = true;
}



/*****************************************************************************
This function returns data for a D3DRM texture map, given the corresponding
DirectDraw surface.
*****************************************************************************/

void* GeomRendererRM1::LookupTextureHandle (
    IDirectDrawSurface *surface,
    DWORD               colorKey,
    bool                colorKeyValid,
    bool                dynamic)         // True for Dynamic Textures
{
    Assert (surface);

    IDirect3DRMTexture *rmtexture;

    SurfTexMap::iterator i = _surfTexMap.find(surface);

    // If we find the associated RM texmap data associated with the given
    // surface, then return the found texmap data, otherwise create new data
    // associated with the surface.

    if (i != _surfTexMap.end())
    {
        rmtexture = (*i).second;

        // If the texture is dynamic, inform RM to update it.

        if (dynamic)
            TD3D (rmtexture->Changed (true, false));
    }
    else
    {
        // Set the color key if there is one.

        if (colorKeyValid) {
            DDCOLORKEY key;
            key.dwColorSpaceLowValue = key.dwColorSpaceHighValue = colorKey;
            surface->SetColorKey (DDCKEY_SRCBLT, &key);
        }

        // Create the D3DRM texmap, bundle it up as TexMapData, and store that
        // into the map associated with the given DDraw surface.

        TD3D (_d3drm->CreateTextureFromSurface (surface, &rmtexture));
        _surfTexMap[surface] = rmtexture;
    }

    return rmtexture;
}



/*****************************************************************************
This method is called if a given DirectDraw surface is going away, so that we
can destroy any associated D3D RM texmaps.
*****************************************************************************/

void GeomRendererRM1::SurfaceGoingAway (IDirectDrawSurface *surface)
{
    SurfTexMap::iterator i = _surfTexMap.find (surface);

    if (i != _surfTexMap.end())
    {   (*i).second->Release();
        _surfTexMap.erase (i);
    }
}



/*****************************************************************************
This method renders the texture on the mesh, with the camera point at the
'box' and the pixels dumped into 'destRect' on the curent target surface.
*****************************************************************************/

void GeomRendererRM1::RenderTexMesh (
    void             *texture,
#ifndef BUILD_USING_CRRM
    IDirect3DRMMesh  *mesh,
    long              groupId,
#else
    int               vCount,
    D3DRMVERTEX      *d3dVertArray,
    unsigned         *vIndicies,
    BOOL              doTexture,
#endif
    const Bbox2      &box,
    RECT             *target,
    bool              bDither)
{
#ifdef BUILD_USING_CRRM
    // Create a mesh

    DAComPtr<IDirect3DRMMesh> mesh;

    TD3D (GetD3DRM1()->CreateMesh(&mesh));

    long groupId;

    TD3D (mesh->AddGroup(vCount,    // vertex count
                         1,         // face count
                         vCount,    // verts per face
                         vIndicies,  // indicies
                         &groupId));

    TD3D (mesh->SetVertices(groupId, 0, vCount, d3dVertArray));

    if (doTexture)
    {
        //
        // Set Quality to be unlit flat.  this should provide a speedup
        // but it doesn't because D3DRM still MUST look at the vertex color.
        // I think this is a bug.
        //
        TD3D (mesh->SetGroupQuality(groupId, D3DRMRENDER_UNLITFLAT));
    } else {
        TD3D (mesh->SetGroupQuality(groupId, D3DRMSHADE_GOURAUD|D3DRMLIGHT_OFF|D3DRMFILL_SOLID));
    }
#endif

    if (!SetState(RSRendering)) return;

    // First load the camera/viewing transform into the camera frame.  Note
    // that the Appelles camera is centered at the origin of the image
    // plane, while the D3D RM camera is centered at the projection point.
    // Thus, we need to translate back to the projection point and then get
    // the camera-to-world transform.

    D3DRMMATRIX4D d3dmat;
    LoadD3DMatrix (d3dmat, Translate(0,0,-1));

    TD3D (_camFrame->AddTransform (D3DRMCOMBINE_REPLACE, d3dmat));

    SetupViewport (target);

    TD3D (_Rviewport->SetProjection (D3DRMPROJECT_ORTHOGRAPHIC));
    TD3D (_Rviewport->SetFront (D3DVAL(0.9)));
    TD3D (_Rviewport->SetBack  (D3DVAL(1.1)));
    TD3D (_Rviewport->SetPlane (D3DVAL(box.min.x), D3DVAL(box.max.x),
                                D3DVAL(box.min.y), D3DVAL(box.max.y)));

    // Reset the texture quality if it's changed.

    if (_texQuality != g_prefs3D.texturingQuality)
    {
        _texQuality = g_prefs3D.texturingQuality;
        TD3D (_Rdevice->SetTextureQuality (_texQuality));
    }

    TD3D (mesh->SetGroupTexture (groupId, (IDirect3DRMTexture*)texture));

    // If the special texmesh frame has not been created yet, create it with
    // zbuffering disabled.

    if (!_texMeshFrame)
    {   TD3D (_d3drm->CreateFrame (0, &_texMeshFrame));
        TD3D (_texMeshFrame->SetZbufferMode (D3DRMZBUFFER_DISABLE));
    }

    BOOL bPrevDither;
    bPrevDither = _Rdevice->GetDither ();

    HRESULT hr;
    hr = AD3D(_Rdevice->SetDither (bDither));

    Assert(!FAILED(hr) && "Failed to set dither");

    // Render the texmesh.
    TD3D (_texMeshFrame->AddVisual (mesh));

    Render (_texMeshFrame);

    TD3D (_Rdevice->Update());
    TD3D (_texMeshFrame->DeleteVisual (mesh));

    SetState (RSReady);

    hr = AD3D(_Rdevice->SetDither (bPrevDither));

    Assert(!FAILED(hr) && "Failed to restore dither");
}



/*****************************************************************************
Submit a D3D RM visual geometry as a candidate for picking.  All visuals are
added to the scene frame.  After all visuals are submitted, the GetPick method
selects the closest hit visual and cleans up the tree.
*****************************************************************************/

void GeomRendererRM1::Pick (
    RayIntersectCtx    &context,  // Ray-Intersection Context
    IDirect3DRMVisual  *visual,   // Visual to Pick (Mesh or Visual)
    Transform3         *xform)    // Model-To-World Transform
{
    if (!SetState (RSPicking)) return;

    // Set up the geometry frame.

    TD3D (_geomFrame->AddVisual (visual));

    D3DRMMATRIX4D d3dmat;
    LoadD3DMatrix (d3dmat, xform);

    TD3D (_geomFrame->AddTransform (D3DRMCOMBINE_REPLACE, d3dmat));

    // We've set the viewport to tightly bound the pick ray, since D3DRM
    // doesn't support true ray picking, but can only do window picking.  Here
    // we get the center pixel of the viewport to issue the pick on.

    long FakeScreenX = (_lastrect.left   + _lastrect.right) / 2;
    long FakeScreenY = (_lastrect.bottom + _lastrect.top) / 2;

    IDirect3DRMPickedArray *picklist;

    TD3D (_Rviewport->Pick (FakeScreenX, FakeScreenY, &picklist));

    int numhits = picklist->GetSize();

    TraceTag ((tagPick3Geometry, "Pick [%d,%d], visual %08x, %d hits",
        FakeScreenX, FakeScreenY, visual, numhits));

    Point3Value winner (0, 0, HUGE_VAL);   // Winning Point (Screen Coordinates)

    bool hitflag = false;
    int i;
    IDirect3DRMVisual *winner_visual = 0;
    Real winner_dist = HUGE_VAL;

    HitInfo *hit = NEW HitInfo;

    // For each geometry we hit, compare with the current winner and collect
    // hit information about the winning intersection.

    for (i=0;  i < numhits;  ++i)
    {
        D3DRMPICKDESC      pickdesc;
        IDirect3DRMVisual *visual;

        // Get pick information.

        if (FAILED(AD3D(picklist->GetPick(i, &visual, NULL, &pickdesc))))
            break;

        TraceTag ((tagPick3Geometry, "Pick %d f%d g%d Loc <%lg, %lg, %lg>",
            i, pickdesc.ulFaceIdx, pickdesc.lGroupIdx,
            pickdesc.vPosition.x, pickdesc.vPosition.y, pickdesc.vPosition.z));

        // If the current intersection is closer than the current winner, get
        // data and store.

        if (pickdesc.vPosition.z < winner_dist)
        {
            hitflag = true;
            winner_dist = pickdesc.vPosition.z;

            hit->scoord.Set (pickdesc.vPosition.x,   // Screen Coords
                             pickdesc.vPosition.y,
                             pickdesc.vPosition.z);

            // Store the hit mesh group and face IDs.

            hit->group = pickdesc.lGroupIdx;
            hit->face  = pickdesc.ulFaceIdx;

            RELEASE (winner_visual);
            winner_visual = visual;
            winner_visual->AddRef();
        }

        visual->Release();
    }

    if (hitflag)
    {
        // Get the hit D3D RM mesh from the winning visual.

        winner_visual->QueryInterface (
            IID_IDirect3DRMMesh, (void**) &hit->mesh
        );

        winner_visual->Release();

        hit->lcToWc = xform;

        context.SubmitHit (hit);
    } else
        delete hit;

    int refcount = picklist->Release();
    Assert (refcount == 0);

    TD3D (_geomFrame->DeleteVisual (visual));

    SetState (RSReady);
}



/*****************************************************************************
Convert a point from screen coordinates (given the current viewport) to world
coordinates.
*****************************************************************************/

void GeomRendererRM1::ScreenToWorld (Point3Value &screen, Point3Value &world)
{
    D3DRMVECTOR4D d3d_screen;

    d3d_screen.x = D3DVAL (screen.x);
    d3d_screen.y = D3DVAL (screen.y);
    d3d_screen.z = D3DVAL (screen.z);
    d3d_screen.w = D3DVAL (1);

    D3DVECTOR d3d_world;

    TD3D (_Rviewport->InverseTransform (&d3d_world, &d3d_screen));

    // The viewport's inverse transform takes into account our camera-to-world
    // transform that we specified, so we end up in right-handed coordinates
    // like we want.

    world.Set (d3d_world.x, d3d_world.y, d3d_world.z);
}



/*****************************************************************************
This method returns the D3D RM device interface for the given GeomDDRenderer.
If the SeqNum parameter is not null, then we fill in the ID for this object as
well.  This is used to determine if the RM Device may have changed from the
last query.
*****************************************************************************/

void GeomRendererRM1::GetRMDevice (IUnknown **D3DRMDevice, DWORD *SeqNum)
{
    *D3DRMDevice = (IUnknown*) _Rdevice;
    if (SeqNum) *SeqNum = _id;
}





//////////////////////////////////////////////////////////////////////////////
/////////////////////////////   GeomRendererRM3   ////////////////////////////
//////////////////////////////////////////////////////////////////////////////

GeomRendererRM3::GeomRendererRM3 (void)
    :
    _d3drm        (NULL),
    _surface      (NULL),
    _viewport     (NULL),
    _Rdevice      (NULL),
    _Rviewport    (NULL),
    _scene        (NULL),
    _camFrame     (NULL),
    _geomFrame    (NULL),
    _texMeshFrame (NULL),
    _amblight     (NULL),
    _clippedVisual(NULL),
    _clippedFrame (NULL),
    _shadowScene  (NULL),
    _shadowLights (NULL),
    _shadowGeom   (NULL)
{
    TraceTag ((tagGRenderObj, "Creating GeomRendererRM3[%x]", _id));

    _lastrect.right  =
    _lastrect.left   =
    _lastrect.top    =
    _lastrect.bottom = -1;
}



GeomRendererRM3::~GeomRendererRM3 (void)
{
    TraceTag ((tagGRenderObj, "Destroying GeomRendererRM3[%x]", _id));

    // Release each light in the light pool.

    // Delete each light in the light pool.  For each framed light, the only
    // reference to the light will be the frame, and the only refence to the
    // light frame will be the scene frame.

    _nextlight = _lightpool.begin();

    while (_nextlight != _lightpool.end())
    {   (*_nextlight)->frame->Release();
        delete (*_nextlight);
        ++ _nextlight;
    }

    // Release texture handles

    SurfTexMap::iterator i = _surfTexMap.begin();

    while (i != _surfTexMap.end())
    {   (*i++).second -> Release();
    }

    // Release retained-mode objects.

    RELEASE (_amblight);

    RELEASE (_texMeshFrame);
    RELEASE (_geomFrame);
    RELEASE (_camFrame);
    RELEASE (_scene);
    RELEASE (_shadowGeom);
    RELEASE (_shadowLights);
    RELEASE (_shadowScene);

    RELEASE (_Rviewport);
    RELEASE (_Rdevice);
    RELEASE (_clippedFrame);
    RELEASE (_clippedVisual);

    RELEASE (_d3drm);

    if (_viewport) _viewport->RemoveGeomDev (this);
}



/*****************************************************************************
Initialization of the RM6 geometry rendering class.
*****************************************************************************/

HRESULT GeomRendererRM3::Initialize (
    DirectDrawViewport *viewport,
    DDSurface          *ddsurf)      // Destination DDraw Surface
{
    if (_renderState != RSUninit) return E_FAIL;

    _surface = ddsurf->IDDSurface();

    HRESULT result = NOERROR;    // Error Return Code

    IUnknown            *ddrawX = 0;    // DDraw Object That Created Target Surf
    IDirectDraw         *ddraw1 = 0;    // DD1 Interface on Parent DDraw Object
    IDirectDrawSurface3 *ddsurface = 0; // DDSurf3 Interface on Target Surf

    DWORD targetBitDepth = ddsurf->GetBitDepth();
    if ( targetBitDepth == 8 )
    {
        // We want D3D to always obey our palette without changing it.  To
        // enforce that, we grab the palette from every surface that comes our
        // way, set the D3D palette read-only flag on each entry, and store it
        // back to the surface.  Note that D3D v3 devices have a bug in that
        // they ignore subsequent changes to the palette on the target surface
        // palette.  This bug works in our favor for now, since we only have
        // to set the flags once on initialization.  For a change in palette,
        // the *surface* (not just the rendering device) must be released.

        // Get the palette from the target surface, extract the individual
        // palette entries, set the D3D read-only flag, and then write the
        // entries back to the surface's palette.

        IDirectDrawPalette *palette;
        if (FAILED(AD3D(result=_surface->GetPalette(&palette))))
            goto done;

        PALETTEENTRY entries[256];

        if (FAILED(AD3D(result=palette->GetEntries (0, 0, 256, entries))))
            goto done;

        if (!(entries[0].peFlags & D3DPAL_READONLY)) {
            TraceTag ((tagGRenderObj,
                "GeomRendererRM3::Initialize - making palette readonly."));

            int i;
            for (i=0;  i < 256;  ++i)
                entries[i].peFlags = D3DPAL_READONLY;

            if (FAILED(AD3D(result=palette->SetEntries (0, 0, 256, entries))))
                goto done;
        }

        palette->Release();
    }

    // Get the DirectDraw object responsible for creating the target surface.

    result = AD3D (_surface->QueryInterface
                     (IID_IDirectDrawSurface3, (void**)&ddsurface));
    if (FAILED(result)) goto done;

    if (FAILED(AD3D(result=ddsurface->GetDDInterface ((void**)&ddrawX))))
        goto done;

    result = AD3D(ddrawX->QueryInterface (IID_IDirectDraw, (void**)&ddraw1));
    if (FAILED(result)) goto done;

    // save the surface's dimensions for error-checking later

    DDSURFACEDESC desc;
    ZeroMemory(&desc,sizeof(DDSURFACEDESC));
    desc.dwSize = sizeof(DDSURFACEDESC);
    desc.dwFlags = DDSD_HEIGHT | DDSD_WIDTH;
    if (FAILED(AD3D(result = ddsurface->GetSurfaceDesc(&desc))))
        goto done;
    _targetSurfWidth = desc.dwWidth;
    _targetSurfHeight = desc.dwHeight;

    // Find the available 3D rendering devices for the given DDraw object.

    ChosenD3DDevices *chosenDevs;

    chosenDevs = SelectD3DDevices (ddraw1);

    // Get the main D3D retained-mode object.

    _d3drm = GetD3DRM3();
    _d3drm->AddRef();

    // If the target surface is in system memory, then we have to use a
    // software renderer.  If the surface is in video memory, then we have to
    // use the chosen hardware renderer.

    GUID devguid;

    if (ddsurf->IsSystemMemory())
    {
        TraceTag ((tag3DDevSelect, "Target surface is in system memory."));
	TraceTag ((tag3DDevSelect, "Using 3D Software Renderer"));
	devguid = chosenDevs->software.guid;
	_deviceDesc = chosenDevs->software.desc;
    }
    else
    {
        TraceTag ((tag3DDevSelect, "Target surface is in video memory."));

        devguid = chosenDevs->hardware.guid;
        _deviceDesc = chosenDevs->hardware.desc;

        // The surface is in video memory; ensure that we have a hardware
        // renderer to use.

        if (devguid == GUID_NULL)
        {   TraceTag ((tag3DDevSelect,
                "No HW renderer available for videomem surface."));
            result = E_FAIL;
            goto done;
        }

        // Ensure that the target surfaces bitdepth is supported by the chosen
        // hardware renderer.

        if (!(_deviceDesc.dwDeviceRenderBitDepth
                    & BPPtoDDBD( targetBitDepth )))
        {
            TraceTag ((tag3DDevSelect,
                "3D HW does not support target bitdepth of %d",
                targetBitDepth ));
            result = E_FAIL;
            goto done;
        }

        TraceTag ((tag3DDevSelect, "Using 3D Hardware Renderer"));
    }

    if (devguid == GUID_NULL)
    {   TraceTag ((tag3DDevSelect,"No 3D hardware or software renderer found!"));
        result = E_FAIL;
        goto done;
    }

    // Create the standard renderer here.

    result = AD3D(_d3drm->CreateDeviceFromSurface
		  (&devguid, ddraw1, _surface, 0, &_Rdevice));
    if (FAILED(result)) goto done;

    // Set the rendering preferences.

    TraceTag
    ((  tagGRenderObj, "Current Rendering Preferences:\n"
            "\t%s, %s, %s\n"
            "\tDithering %s,  Texmapping %s,  Perspective Texmap %s\n"
            "\tQuality Flags %08x,  Texture Quality %s\n"
            "\tWorld-Coordinate Lighting %s",
        (g_prefs3D.lightColorMode == D3DCOLOR_RGB) ? "RGB" : "mono",
        (g_prefs3D.fillMode == D3DRMFILL_SOLID) ? "solid"
            : ((g_prefs3D.fillMode == D3DRMFILL_WIREFRAME) ? "wireframe"
                : "points"),
        (g_prefs3D.shadeMode == D3DRMSHADE_FLAT) ? "flat"
            : ((g_prefs3D.shadeMode == D3DRMSHADE_GOURAUD) ? "Gouraud"
                : "Phong"),
        g_prefs3D.dithering ? "ON" : "OFF",
        g_prefs3D.texmapping ? "ON" : "OFF",
        g_prefs3D.texmapPerspect ? "ON" : "OFF",
        g_prefs3D.qualityFlags,
        g_prefs3D.texturingQuality==D3DRMTEXTURE_NEAREST ? "nearest":"bilinear",
        g_prefs3D.worldLighting ? "ON" : "OFF"
    ));

    result = AD3D(_Rdevice->SetDither (g_prefs3D.dithering));
    if (FAILED(result)) goto done;

    _texQuality = g_prefs3D.texturingQuality;
    result = AD3D(_Rdevice->SetTextureQuality (_texQuality));
    if (FAILED(result)) goto done;

    result = AD3D(_Rdevice->SetQuality (g_prefs3D.qualityFlags));
    if (FAILED(result)) goto done;

    // Promise to RM that we won't change the render or light state underneath
    // them (by going directly to D3DIM).
    result = AD3D(_Rdevice->SetStateChangeOptions(D3DRMSTATECHANGE_RENDER,
                            0, D3DRMSTATECHANGE_NONVOLATILE));
    if (FAILED(result)) goto done;

    result = AD3D(_Rdevice->SetStateChangeOptions(D3DRMSTATECHANGE_LIGHT,
                            0, D3DRMSTATECHANGE_NONVOLATILE));
    if (FAILED(result)) goto done;

    // Setup of the render mode.

    DWORD renderFlags;
    renderFlags = D3DRMRENDERMODE_BLENDEDTRANSPARENCY
                | D3DRMRENDERMODE_SORTEDTRANSPARENCY
                | D3DRMRENDERMODE_DISABLESORTEDALPHAZWRITE
                | D3DRMRENDERMODE_VIEWDEPENDENTSPECULAR;

    if (g_prefs3D.worldLighting)
        renderFlags |= D3DRMRENDERMODE_LIGHTINMODELSPACE;

    if (FAILED(AD3D(result = _Rdevice->SetRenderMode (renderFlags))))
        goto done;

    // Create the primary scene frame, the camera frame, and the lights frame.

    if (  FAILED(AD3D(result=_d3drm->CreateFrame (0,&_scene)))
       || FAILED(AD3D(result=_d3drm->CreateFrame (_scene, &_camFrame)))
       || FAILED(AD3D(result=_d3drm->CreateFrame (_scene, &_geomFrame)))
       )
    {
        goto done;
    }

    result = AD3D(_d3drm->CreateLightRGB (D3DRMLIGHT_AMBIENT,0,0,0,&_amblight));
    if (FAILED(result)) goto done;

    if (FAILED(AD3D(result=_scene->AddLight(_amblight))))
        goto done;

    (_viewport = viewport) -> AddGeomDev (this);

    done:

    if (ddraw1)    ddraw1->Release();
    if (ddrawX)    ddrawX->Release();
    if (ddsurface) ddsurface->Release();

    return (SUCCEEDED(result) && SetState(RSReady)) ? NOERROR : E_FAIL;
}



/*****************************************************************************
Renders the given geometry onto the associated DirectDraw surface.
*****************************************************************************/

void GeomRendererRM3::RenderGeometry (
    DirectDrawImageDevice *imgDev,
    RECT                   target,    // Target Rectangle on DDraw Surface
    Geometry              *geometry,  // Geometry to Render
    Camera                *camera,    // Viewing Camera
    const Bbox2           &viewbox)   // Source Region in Camera Coordinates
{
    if (!SetState(RSRendering)) return;

    // The camera pointer is only relevant in a single frame, and while
    // rendering.  It gets reset back to nil to ensure that we don't incur a
    // leak by holding the value across frames.

    Assert (_camera == 0);
    _camera = camera;

    _imageDevice = imgDev;  // Set image dev for this frame

    // Initialize the rendering state and D3D renderer.

    BeginRendering (target, geometry, viewbox);

    // Render the geometry only if it is visible.  The geometry may be
    // completely behind us, for example.  Since shadows aren't bound by
    // the geo's bbox, we want to always render if we're in shadow geometry
    // collection mode.

    if (_geomvisible)
        geometry->Render (*this);
    else
        TraceTag ((tagGRendering, "Geometry is invisible; skipping render"));

    // Clean up after rendering.

    EndRendering ();

    DebugCode (_imageDevice = NULL);
    _camera = NULL;

    SetState (RSReady);
}



/*****************************************************************************
This procedure prepares the 3D DD renderer before traversing the tree.  It is
primarily responsible for initializing the graphics state and setting up D3D
for rendering.
*****************************************************************************/

void GeomRendererRM3::BeginRendering (
    RECT      target,    // Target DDraw Surface Rectangle
    Geometry *geometry,  // Geometry To Render
    const Bbox2 &region)    // Target Region in Camera Coordinates
{
    TraceTag ((tagGRendering, "BeginRendering"));

    // Set up the camera.  If it turns out that the geometry is invisible,
    // then just return.

    SetView (&target, region, geometry->BoundingVol());

    TraceTag ((tagGRendering, "Clearing Z buffer."));

    if (!_geomvisible) return;

    TD3D (_Rviewport->Clear (D3DRMCLEAR_ZBUFFER));

    // Reset the object pools.

    _nextlight = _lightpool.begin();

    // Initialize the geometry state and material attributes.

    _currAttrState.InitToDefaults();

    _overriding_opacity = false;
    _alphaShadows = false;

    _depthLighting = 0;
    _depthOverridingOpacity = 0;
    _depthAlphaShadows = 0;

    // Preprocess the textures in the scene graph.

    if (!_shadowGeom)
        geometry->CollectTextures (*this);

    // Gather the light sources from the geometry.

    _ambient_light.SetRGB (0,0,0);    // Initialize to black

    if (!_shadowGeom) {
        LightContext lcontext (this);
        geometry->CollectLights (lcontext);
    }

    // Since the ambient light is really the accumulation of all ambient lights
    // found in the geometry, we add the total contribution here as a single
    // ambient light.

    TD3D (_amblight->SetColorRGB (
        D3DVALUE (_ambient_light.red),
        D3DVALUE (_ambient_light.green),
        D3DVALUE (_ambient_light.blue)));

    // Reset the texture quality if it's changed.

    if (_texQuality != g_prefs3D.texturingQuality)
    {
        _texQuality = g_prefs3D.texturingQuality;
        TD3D (_Rdevice->SetTextureQuality (_texQuality));
    }
}



/*****************************************************************************
This routine is called after the rendering traversal of the geometry is
completed.
*****************************************************************************/

void GeomRendererRM3::EndRendering (void)
{
    // Ensure that all attributes have been popped.

    Assert (  !_geomvisible ||
        !(_currAttrState._depthEmissive||
          _currAttrState._depthAmbient||
          _currAttrState._depthDiffuse||
          _currAttrState._depthSpecular||
          _currAttrState._depthSpecularExp||
          _currAttrState._depthTexture));

    TraceTag ((tagGRendering, "EndRendering"));

    // Detach all light sources from the scene.

    _nextlight = _lightpool.begin();

    while (_nextlight != _lightpool.end())
    {
        if ((*_nextlight)->active)
        {   TD3D (_scene->DeleteChild ((*_nextlight)->frame));
            (*_nextlight)->active = false;
        }
        ++ _nextlight;
    }

    // Render all the shadows in the scene, if any
    if (_shadowScene && _shadowLights) {

        TraceTag ((tagGRendering, "BeginShadowRendering"));

        // add shadow-producing lights
        TD3D(_scene->AddChild(_shadowLights));;

        // add shadow visuals, render shadow scene
        TD3D(_scene->AddVisual(_shadowScene));
        Render (_scene);

        // clean up
        TD3D(_scene->DeleteVisual(_shadowScene));
        TD3D(_scene->DeleteChild(_shadowLights));

        TraceTag ((tagGRendering, "EndShadowRendering"));
    }
    RELEASE(_shadowScene);
    RELEASE(_shadowLights);

    TD3D (_Rdevice->Update());

    ClearIntraFrameTextureImageCache();
}



/*****************************************************************************
This function sets up the RM and IM viewports given the target rectangle.
*****************************************************************************/

void GeomRendererRM3::SetupViewport (RECT *target)
{
    // If the current target rectangle is the same as the last one, then reset
    // the camera and continue, otherwise we need to re-configure the D3DRM
    // viewport.

    if (!target || (*target == _lastrect))
    {
        TD3D (_Rviewport->SetCamera (_camFrame));
    }
    else
    {
        LONG width  = target->right  - target->left;
        LONG height = target->bottom - target->top;

        // If the viewport already exists, then re-configure and set the
        // updated camera frame.  If the D3DRM viewport does not yet exist,
        // then we create it here.

        if (_Rviewport)
        {
            TD3D (_Rviewport->Configure
                  ((LONG) target->left, (LONG) target->top, width, height));
            TD3D (_Rviewport->SetCamera (_camFrame));
        }
        else
        {
            TD3D (_d3drm->CreateViewport (
                _Rdevice, _camFrame,
                target->left, target->top, width, height, &_Rviewport));
        }

        _lastrect = *target;
    }

    TD3D (_Rviewport->SetUniformScaling (FALSE));
}



/*****************************************************************************
This function sets the D3D viewing projection based on the given camera.
*****************************************************************************/

    // Because of a VC5 bug, we can only force option P (honor float casts)
    // around certain pieces of code.  For example, if you turn on -Op for the
    // whole project, you'll get erroneous complaints about overfloat in
    // static constant assignments.  We need to do strict single-precision
    // arithmetic here before we hand values off to D3D, or we'll choke.

#pragma optimize ("p", on)
#pragma warning(disable:4056)

void GeomRendererRM3::SetView (
    RECT   *target,      // Target Rectangle on Surface
    const Bbox2 &iview,  // Idealized 2D Viewport In The Image Plane
    Bbox3  *volume)      // Volume to View
{
    // First load the camera/viewing transform into the camera frame.  Note
    // that the Appelles camera is centered at the origin of the image plane,
    // while the D3D RM camera is centered at the projection point.  Thus, we
    // need to translate back to the projection point and then get the camera-
    // to-world transform.

    Real Sx, Sy, Sz;
    _camera->GetScale (&Sx, &Sy, &Sz);

    // Clamp the maximum projection point distance to 10^4, since greater
    // distances will clobber Z resolution and make the front and back clip
    // planes take the same values.

    const Real Zclamp = 1e4;

    if (Sz > Zclamp) Sz = Zclamp;

    D3DRMMATRIX4D d3dmat;

    LoadD3DMatrix
        (d3dmat, TimesXformXform (_camera->CameraToWorld(),Translate(0,0,Sz)));

    TD3D (_camFrame->AddTransform (D3DRMCOMBINE_REPLACE, d3dmat));

    if ((target->left >= target->right) ||
        (target->top >= target->bottom) ||
        (target->top < 0) ||
        (target->bottom > _targetSurfHeight) ||
        (target->left < 0) ||
        (target->right > _targetSurfWidth))
    {   _geomvisible = false;
        return;
    }

    SetupViewport (target);

    if (_camera->Type() == Camera::PERSPECTIVE)
    {   TD3D (_Rviewport->SetProjection (D3DRMPROJECT_PERSPECTIVE));
    }
    else
    {   TD3D (_Rviewport->SetProjection (D3DRMPROJECT_ORTHOGRAPHIC));
    }

    // Ensure that the geometry is viewable.  If we're looking at nil geometry,
    // then flag the geometry as invisible and return.

    if (!volume->PositiveFinite())
    {   _geomvisible = false;
        return;
    }

    // Get the near and far planes for the object and camera, and widen them
    // by 4 "clicks" in Z space.  Note that front and back are positive depths.

    Real front, back;
    const Real Zclicks = 4.0 / ((1<<16) - 1);

    _geomvisible = _camera->GetNearFar (volume, Zclicks, front, back);

    if (!_geomvisible) return;

    #if _DEBUG
    {
        double r = back / front;
        if (r > (2<<12))
        {   TraceTag ((tagWarning,
                "!!! Z-buffer resolution too low; far/near = %lg", r));
        }
    }
    #endif

    // If the front and back planes are identical, then we are looking at an
    // infinitely shallow object.  In this case, we need to move out the front
    // and back clip planes so that the object doesn't fall exactly on these
    // planes (and thus get clipped), and also because D3D fails if the front
    // and back planes are identical.  How much to move them out?  To work for
    // all cases, we manipulate the mantissa of the numbers directly.  If we
    // did something like add/subtract one, for example, this would be a no-op
    // if both numbers were very large, or would clobber resolution if they
    // were very small.  The following mantissa delta (8 bits) is just
    // something that works experimentally.

    D3DVALUE d3dFront = D3DVAL (front);
    D3DVALUE d3dBack  = D3DVAL (back);

    if (d3dFront == d3dBack)
    {
        const int delta = 1 << 8;

        d3dFront = MantissaDecrement (d3dFront, delta);
        d3dBack  = MantissaIncrement (d3dBack,  delta);
    }

    TD3D (_Rviewport->SetFront (d3dFront));
    TD3D (_Rviewport->SetBack  (d3dBack));

    // For perspective projection, we seek the viewport coordinates on the
    // front clipping plane where D3D wants them.  Since the target rectangle
    // is given on the image plane (Z=0), we do the following calculation.
    // X and Y for the front plane are scaled by the ratio of the distance
    // between the projection point and the front plane, and the distance
    // between the projection point and the image plane.
    //                                                       Back
    //                                                       Plane
    //                                   Front              ___!---
    //                         Image     Plane      ___.---'   !
    //                         Plane       :___.---'           !
    //                           |  ___.---:                   !
    //                      ___.-|-'       :                   !
    //              ___.---'     |         :                   !
    //      ___.---'             |         :                   !
    //     *---------------------|---------:-------------------!--
    //      """`---.___          |         :                   !
    //     |           `---.___  |         :                   !
    //     |                   `-|-.___    :                   !
    //     |                     |     `---:___                !
    //     |                     |         :   `---.___        !
    //     |                     |         :           `---.___!
    //     |                     |         :                   !---
    //     |<------- Sz -------->|         :                   !
    //     |<------------- Front --------->:                   !
    //     |<---------------------- Back --------------------->!

    if (_camera->Type() == Camera::PERSPECTIVE)
    {
        Real Vscale = front / Sz;

        Sx *= Vscale;
        Sy *= Vscale;
    }

    D3DVALUE minX = D3DVAL(Sx*iview.min.x);
    D3DVALUE minY = D3DVAL(Sy*iview.min.y);
    D3DVALUE maxX = D3DVAL(Sx*iview.max.x);
    D3DVALUE maxY = D3DVAL(Sy*iview.max.y);

    if ((minX >= maxX) || (minY >= maxY))
    {   _geomvisible = false;
        return;
    }

    TD3D (_Rviewport->SetPlane (minX, maxX, minY, maxY));
}

#pragma warning(default:4056)
#pragma optimize ("", on)  // Restore optimization flags to original settings.



/*****************************************************************************
Utility for loading up a frame with a visual and attr state
*****************************************************************************/

void LoadFrameWithGeoAndState (
    IDirect3DRMFrame3 *fr,
    IDirect3DRMVisual *visual,
    CtxAttrState      &state,
    bool               overriding_opacity)
{
    TD3D (fr->AddVisual (visual));

    // Set the modeling transform.

    D3DRMMATRIX4D d3dmat;
    LoadD3DMatrix (d3dmat, state._transform);
    TD3D (fr->AddTransform (D3DRMCOMBINE_REPLACE, d3dmat));

    // Set the material override attributes on the visual before we render it.

    D3DRMMATERIALOVERRIDE material;

    material.dwSize  = sizeof(material);
    material.dwFlags = 0;

    if (state._emissive)
    {   material.dwFlags |= D3DRMMATERIALOVERRIDE_EMISSIVE;
        material.dcEmissive.r = state._emissive->red;
        material.dcEmissive.g = state._emissive->green;
        material.dcEmissive.b = state._emissive->blue;
    }

    // Ensure that we can load diffuse/opacity a component at a time.

    #if (D3DRMMATERIALOVERRIDE_DIFFUSE_RGBONLY|D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAONLY)!=D3DRMMATERIALOVERRIDE_DIFFUSE
        #error "Unexpected material override constants."
    #endif

    // If the composing opacity is 1.0, then we'll just use the underlying
    // opacity, otherwise we modulate the object's opacity by multiplying it
    // through the opacities in the visual.

    if ((state._opacity >= 0) && (overriding_opacity || (state._opacity != 1.)))
    {
        if (!overriding_opacity)
        {   material.dwFlags |= D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAONLY
                             |  D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAMULTIPLY;
        }
        else
        {   material.dwFlags |= D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAONLY;
        }

        material.dcDiffuse.a = state._opacity;
    }

    // Pass along all current attributes.

    if (state._ambient)
    {   material.dwFlags |= D3DRMMATERIALOVERRIDE_AMBIENT;
        material.dcAmbient.r = state._ambient->red;
        material.dcAmbient.g = state._ambient->green;
        material.dcAmbient.b = state._ambient->blue;
    }
    else if (state._diffuse)
    {   material.dwFlags |= D3DRMMATERIALOVERRIDE_AMBIENT;
        material.dcAmbient.r = state._diffuse->red;
        material.dcAmbient.g = state._diffuse->green;
        material.dcAmbient.b = state._diffuse->blue;
    }

    // Set diffuse color to white if we're texmapping and we're not
    // blending diffuse & textures.  We do this because diffuse color is
    // multiplied by texture color to produce the final color.

    if (state._texture && !state._tdBlend)
    {   material.dwFlags |= D3DRMMATERIALOVERRIDE_DIFFUSE_RGBONLY;
        material.dcDiffuse.r = 1.0;
        material.dcDiffuse.g = 1.0;
        material.dcDiffuse.b = 1.0;
    }
    else if (state._diffuse)
    {   material.dwFlags |= D3DRMMATERIALOVERRIDE_DIFFUSE_RGBONLY;
        material.dcDiffuse.r = state._diffuse->red;
        material.dcDiffuse.g = state._diffuse->green;
        material.dcDiffuse.b = state._diffuse->blue;
    }

    if (state._specular)
    {   material.dwFlags |= D3DRMMATERIALOVERRIDE_SPECULAR;
        material.dcSpecular.r = state._specular->red;
        material.dcSpecular.g = state._specular->green;
        material.dcSpecular.b = state._specular->blue;
    }

    if (state._specularExp > 0.0)
    {   material.dwFlags |= D3DRMMATERIALOVERRIDE_POWER;
        material.dvPower = state._specularExp;
    }

    // Set the texture override.  Note that we override if either the
    // texture or the diffuse color is set.  This is because we may have
    // an overriding diffuse color, so we'd want to clobber all default
    // textures to none.

    if (state._texture || state._diffuse)
    {   material.dwFlags |= D3DRMMATERIALOVERRIDE_TEXTURE;
        material.lpD3DRMTex = (IUnknown*)state._texture;
    }

    TD3D (fr->SetMaterialOverride (&material));
}



/*****************************************************************************
Render the given RM visual object to the current viewport.  Catch cases where
we fail rendering because the target surface was busy (usually due to another
app going fullscreen, e.g. screensavers).
*****************************************************************************/

void GeomRendererRM3::Render (IDirect3DRMFrame3 *frame)
{
    // Render the visual on the current viewport, and return if the operation
    // succeeded.

    HRESULT render_result = RD3D (_Rviewport->Render(frame));

    if (SUCCEEDED(render_result))
        return;

    // Most of the time, if we failed to render because the surface was busy,
    // we'll get an invalid device error.  For some reason, trying to render
    // shadows while the surface is busy results in a surface busy error from
    // the render call.  We check for this case here.
    if (render_result == DDERR_SURFACEBUSY)
    {
        TraceTag ((tagGRendering, "Render returns that surface was busy"));
        RaiseException_UserError(DAERR_VIEW_SURFACE_BUSY,
                                 IDS_ERR_IMG_SURFACE_BUSY);
    }


    // If we failed to render, then check to see if the surface was busy.  If
    // it was, raise a surface-busy exception back to the client.

    DDSURFACEDESC surfdesc;
    surfdesc.dwSize = sizeof (surfdesc);

    HRESULT lock_result = _surface->Lock (NULL, &surfdesc, 0, NULL);

    if (SUCCEEDED (lock_result))
        _surface->Unlock (NULL);

    if(lock_result == DDERR_SURFACELOST)
    {
        _surface->Restore();
        RaiseException_UserError(lock_result, 0);
    }

    if (lock_result == DDERR_SURFACEBUSY)
    {
        RaiseException_UserError(DAERR_VIEW_SURFACE_BUSY,
                                 IDS_ERR_IMG_SURFACE_BUSY);
    }

    // The surface is not busy, so we must have failed for some other reason.
    // Bail out via the standard exception mechanism.

    #if _DEBUG
        CheckReturnImpl (render_result, __FILE__, __LINE__, true);
    #else
        CheckReturnImpl (render_result, true);
    #endif
}



/*****************************************************************************
Submit a D3D RM1 visual for rendering.
*****************************************************************************/

void GeomRendererRM3::Render (RM1VisualGeo *geo)
{
    Assert(false && "Should not get here");
}



/*****************************************************************************
This method renders RM3 primitives.
*****************************************************************************/

void GeomRendererRM3::Render (RM3VisualGeo *geo)
{
    if (_renderState != RSRendering) return;

    if (_shadowGeom) {
        IDirect3DRMFrame3 *shadowGeomFrame;
        TD3D(_d3drm->CreateFrame(_shadowGeom,&shadowGeomFrame));

        LoadFrameWithGeoAndState
            (shadowGeomFrame, geo->Visual(), _currAttrState, _overriding_opacity);

        RELEASE(shadowGeomFrame);

    } else {
        LoadFrameWithGeoAndState
            (_geomFrame, geo->Visual(), _currAttrState, _overriding_opacity);

        if (_clippedVisual) {
            Render (_clippedFrame);
        } else {
            Render (_geomFrame);
        }

        TD3D (_geomFrame->DeleteVisual (geo->Visual()));
    }
}



/*****************************************************************************
*****************************************************************************/

void GeomRendererRM3::RenderMeshBuilderWithDeviceState (
    IDirect3DRMMeshBuilder3 *mb)
{
    if (_renderState != RSRendering) return;

    RM3MBuilderGeo *mbGeo = NEW RM3MBuilderGeo (mb, false);

    Render (mbGeo);

    mbGeo->CleanUp();     // Done with the mbuilder geo.
}



/*****************************************************************************
This function adds a given light with a given context to a geometry rendering
device.  NOTE:  All calls to this function must happen after BeginRendering
is called and before any geometry is rendered.
*****************************************************************************/

void GeomRendererRM3::AddLight (LightContext &context, Light &light)
{
    FramedRM3Light  shadowLight;

    if (_renderState != RSRendering) return;

    LightType type = light.Type();

    // If the light source is an ambient light, then add its contribution to
    // the global ambient light level.

    if (type == Ltype_Ambient)
    {   _ambient_light.AddColor (*context.GetColor());
        return;
    }

    // Get a framed light object, either by re-using an existing one from the
    // framed light pool, or by creating a new one for the pool.

    FramedRM3Light *frlight;

    if (!_shadowGeom) {
        if (_nextlight != _lightpool.end())
        {   frlight = *_nextlight;
            ++ _nextlight;
            Assert (!frlight->active);   // The light should not be in use.
        }
        else
        {   frlight = NEW FramedRM3Light;
            VECTOR_PUSH_BACK_PTR (_lightpool, frlight);
            _nextlight = _lightpool.end();

            // Attach the frame to the scene frame (since we know
            // we will be using it this frame).

            TD3D (_d3drm->CreateFrame (_scene, &frlight->frame));

            frlight->light = 0;   // Signal for new light object creation.
        }
    } else {
        if (!_shadowLights) {
            TD3D(_d3drm->CreateFrame(0,&_shadowLights));
        }
        frlight = &shadowLight;
        TD3D (_d3drm->CreateFrame(_shadowLights, &(frlight->frame)));
        frlight->light = 0;
    }

    // Get the corresponding D3DRM light type.

    D3DRMLIGHTTYPE d3dtype;
    switch (type)
    {   case Ltype_Spot:   d3dtype = D3DRMLIGHT_SPOT;        break;
        case Ltype_Point:  d3dtype = D3DRMLIGHT_POINT;       break;
        default:           d3dtype = D3DRMLIGHT_DIRECTIONAL; break;
    }

    // Get the D3DRM color of the light.

    Color &color = *context.GetColor();
    D3DVALUE Lr = D3DVAL (color.red);
    D3DVALUE Lg = D3DVAL (color.green);
    D3DVALUE Lb = D3DVAL (color.blue);

    // If we're re-using a D3DRM light, then just set the values, otherwise
    // create it here.

    if (frlight->light)
    {   TD3D (frlight->light->SetType (d3dtype));
        TD3D (frlight->light->SetColorRGB (Lr, Lg, Lb));
        TD3D (_scene->AddChild (frlight->frame));
    }
    else
    {   TD3D (_d3drm->CreateLightRGB (d3dtype, Lr,Lg,Lb, &frlight->light));
        TD3D (frlight->frame->AddLight (frlight->light));
        frlight->light->Release();
    }

    // Specify the position and oriention of the light.

    Apu4x4Matrix const xform = context.GetTransform()->Matrix();

    Point3Value  lpos ( xform.m[0][3],  xform.m[1][3],  xform.m[2][3]);
    Vector3Value ldir (-xform.m[0][2], -xform.m[1][2], -xform.m[2][2]);

    D3DVALUE Ux=D3DVAL(0), Uy=D3DVAL(1), Uz=D3DVAL(0);

    if ((ldir.x == 0) && (ldir.y == 1) && (ldir.z == 0))
    {   Ux = D3DVAL(1);
        Uy = D3DVAL(0);
    }

    TD3D (frlight->frame->SetPosition
             (_scene, D3DVAL(lpos.x), D3DVAL(lpos.y), D3DVAL(lpos.z)));

    TD3D (frlight->frame->SetOrientation
           (_scene, D3DVAL(ldir.x), D3DVAL(ldir.y), D3DVAL(ldir.z), Ux,Uy,Uz));

    // Set light attributes for positioned lights

    if ((type == Ltype_Point) || (type == Ltype_Spot))
    {
        // Light attenuation is disabled on DX6 since the attenuation model
        // changed to ranged parabolic in DX5.  We'll
        // keep this code for now in hopes that we will regain standard light
        // attenuation in future versions of D3D.

        #if 0
        {
            // Light Attenuation

            Real a0, a1, a2;
            context.GetAttenuation (a0, a1, a2);

            // D3D does not accept 0 for the constant attenuation, so we clamp
            // it here to a minimum of some small epsilon.

            if (a0 < 1e-6)
                a0 = 1e-6;

            TD3D (frlight->light->SetConstantAttenuation  (D3DVAL(a0)));
            TD3D (frlight->light->SetLinearAttenuation    (D3DVAL(a1)));
            TD3D (frlight->light->SetQuadraticAttenuation (D3DVAL(a2)));
        }
        #endif

        // Light Range

        Real range = context.GetRange();

        if (range <= 0) range = D3DLIGHT_RANGE_MAX;

        TD3D (frlight->light->SetRange (D3DVAL(range)));
    }

    // Set light attributes for spot lights.

    if (type == Ltype_Spot)
    {
        Real cutoff, fullcone;
        light.GetSpotlightParams (cutoff, fullcone);

        TD3D (frlight->light->SetUmbra    (D3DVAL (fullcone)));
        TD3D (frlight->light->SetPenumbra (D3DVAL (cutoff)));
    }

    frlight->active = true;

    if (_shadowGeom) {

        // create shadow
        Point3Value planePt = _shadowPlane.Point();
        Vector3Value planeVec = _shadowPlane.Normal();
        IDirect3DRMShadow2 *shadow;
        TD3D(_d3drm->CreateShadow(
                _shadowGeom, frlight->light,
                planePt.x, planePt.y, planePt.z,
                planeVec.x, planeVec.y, planeVec.z,
                &shadow));

        // create frame to hold shadow color and opacity override
        IDirect3DRMFrame3 *shadowFrame;
        TD3D(_d3drm->CreateFrame(_shadowScene,&shadowFrame));
        TD3D(shadowFrame->AddVisual(shadow));

        // set shadow color and opacity override
        D3DRMMATERIALOVERRIDE shadowMat;
        shadowMat.dwSize = sizeof(D3DRMMATERIALOVERRIDE);
        shadowMat.dwFlags = D3DRMMATERIALOVERRIDE_DIFFUSE;
        shadowMat.dcDiffuse.r = _shadowColor.red;
        shadowMat.dcDiffuse.g = _shadowColor.green;
        shadowMat.dcDiffuse.b = _shadowColor.blue;
        shadowMat.dcDiffuse.a = _shadowOpacity;
        TD3D(shadowFrame->SetMaterialOverride(&shadowMat));

        // if it's a true alpha shadow, set that option
        if (_alphaShadows) {
            TD3D(shadow->SetOptions(D3DRMSHADOW_TRUEALPHA));
        }

        // clean up
        RELEASE(shadow);
        RELEASE(shadowFrame);
        RELEASE(frlight->frame);
    }
}


/*****************************************************************************
This function returns data for a D3DRM texture map, given the corresponding
DirectDraw surface.
*****************************************************************************/

void* GeomRendererRM3::LookupTextureHandle (
    IDirectDrawSurface *surface,
    DWORD               colorKey,
    bool                colorKeyValid,
    bool                dynamic)        // True for Dynamic Textures
{
    Assert (surface);

    DebugCode(
        IUnknown *lpDDIUnk = NULL;
        TraceTag((tagDirectDrawObject, "DDRender3 (%x) ::LookupTextureHandle...", this));
        DDObjFromSurface( surface, &lpDDIUnk, true);

        RELEASE( lpDDIUnk );
        );

    IDirect3DRMTexture3 *rmtexture;

    SurfTexMap::iterator i = _surfTexMap.find(surface);

    // If we find the associated RM texmap data associated with the given
    // surface, then return the found texmap data, otherwise create new data
    // associated with the surface.

    if (i != _surfTexMap.end())
    {
        rmtexture = (*i).second;

        // If the texture's dynamic, inform RM to update it.

        if (dynamic)
            TD3D (rmtexture->Changed (D3DRMTEXTURE_CHANGEDPIXELS, 0, 0));
    }
    else
    {
        // Set the color key if there is one.

        if (colorKeyValid) {
            DDCOLORKEY key;
            key.dwColorSpaceLowValue = key.dwColorSpaceHighValue = colorKey;
            surface->SetColorKey (DDCKEY_SRCBLT, &key);
        }

        // Create the D3DRM texmap, bundle it up as TexMapData, and store that
        // into the map associated with the given DDraw surface.

        TD3D (_d3drm->CreateTextureFromSurface (surface, &rmtexture));
        _surfTexMap[surface] = rmtexture;
    }

    return rmtexture;
}



/*****************************************************************************
This method is called if a given DirectDraw surface is going away, so that we
can destroy any associated D3D RM texmaps.
*****************************************************************************/

void GeomRendererRM3::SurfaceGoingAway (IDirectDrawSurface *surface)
{
    SurfTexMap::iterator i = _surfTexMap.find (surface);

    if (i != _surfTexMap.end())
    {   (*i).second->Release();
        _surfTexMap.erase (i);
    }
}



/*****************************************************************************
This method renders the texture on the mesh, with the camera point at the
'box' and the pixels dumped into 'destRect' on the curent target surface.
*****************************************************************************/

void GeomRendererRM3::RenderTexMesh (
    void             *texture,
#ifndef BUILD_USING_CRRM
    IDirect3DRMMesh  *mesh,
    long              groupId,
#else
    int               vCount,
    D3DRMVERTEX      *d3dVertArray,
    unsigned         *vIndicies,
    BOOL              doTexture,
#endif
    const Bbox2      &box,
    RECT             *target,
    bool              bDither)
{
#ifdef BUILD_USING_CRRM
    // Create a meshbuilder

    DAComPtr<IDirect3DRMMeshBuilder3> mesh;

    TD3D (GetD3DRM3()->CreateMeshBuilder(&mesh));

    D3DVECTOR *pV = (D3DVECTOR *) AllocateFromStore(vCount * sizeof(D3DVECTOR));
    D3DVECTOR *pN = (D3DVECTOR *) AllocateFromStore(vCount * sizeof(D3DVECTOR));
    LPDWORD pdwFaceData = (LPDWORD) AllocateFromStore((2 * vCount + 2) * sizeof(DWORD));

    pdwFaceData[0] = vCount;
    pdwFaceData[2 * vCount + 1] = 0;

    for (DWORD i = 0; i < vCount; i++)
    {
        pV[i] = d3dVertArray[i].position;
        pN[i] = d3dVertArray[i].normal;

        pdwFaceData[2*i+1] = vIndicies[i];
        pdwFaceData[2*i+2] = vIndicies[i];
    }

    TD3D (mesh->AddFaces(vCount, pV, vCount, pN, pdwFaceData, NULL));

    for (i = 0; i < vCount; i++)
    {
        TD3D (mesh->SetTextureCoordinates(i,
                                          d3dVertArray[i].tu,
                                          d3dVertArray[i].tv));

        TD3D (mesh->SetVertexColor(i, d3dVertArray[i].color));
    }

    if(doTexture) {
        //
        // Set Quality to be unlit flat.  this should provide a speedup
        // but it doesn't because D3DRM still MUST look at the vertex color.
        // I think this is a bug.
        //
        TD3D (mesh->SetQuality(D3DRMRENDER_UNLITFLAT));
    } else {
        TD3D (mesh->SetQuality(D3DRMSHADE_GOURAUD|D3DRMLIGHT_OFF|D3DRMFILL_SOLID));
    }
#endif

    if (!SetState(RSRendering)) return;

    // First load the camera/viewing transform into the camera frame.  Note
    // that the Appelles camera is centered at the origin of the image
    // plane, while the D3D RM camera is centered at the projection point.
    // Thus, we need to translate back to the projection point and then get
    // the camera-to-world transform.

    D3DRMMATRIX4D d3dmat;
    LoadD3DMatrix (d3dmat, Translate(0,0,1));

    TD3D (_camFrame->AddTransform (D3DRMCOMBINE_REPLACE, d3dmat));

    SetupViewport (target);

    TD3D (_Rviewport->SetProjection (D3DRMPROJECT_ORTHOGRAPHIC));
    TD3D (_Rviewport->SetFront (D3DVAL(0.9)));
    TD3D (_Rviewport->SetBack  (D3DVAL(1.1)));
    TD3D (_Rviewport->SetPlane (D3DVAL(box.min.x), D3DVAL(box.max.x),
                                D3DVAL(box.min.y), D3DVAL(box.max.y)));

    // Reset the texture quality if it's changed.

    if (_texQuality != g_prefs3D.texturingQuality)
    {
        _texQuality = g_prefs3D.texturingQuality;
        TD3D (_Rdevice->SetTextureQuality (_texQuality));
    }

#ifndef BUILD_USING_CRRM
    TD3D (mesh->SetGroupTexture (groupId, (IDirect3DRMTexture*)texture));
#else
    TD3D (mesh->SetTexture ((IDirect3DRMTexture3*)texture));
#endif

    // If the special texmesh frame has not been created yet, create it with
    // zbuffering disabled.

    if (!_texMeshFrame)
    {   TD3D (_d3drm->CreateFrame (0, &_texMeshFrame));
        TD3D (_texMeshFrame->SetZbufferMode (D3DRMZBUFFER_DISABLE));
    }

    BOOL bPrevDither;
    bPrevDither = _Rdevice->GetDither ();

    HRESULT hr;
    hr = AD3D(_Rdevice->SetDither (bDither));

    Assert(!FAILED(hr) && "Failed to set dither");

    // Render the texmesh.

    TD3D (_texMeshFrame->AddVisual (mesh));

    Render (_texMeshFrame);

    TD3D (_Rdevice->Update());
    TD3D (_texMeshFrame->DeleteVisual (mesh));

    SetState (RSReady);

    hr = AD3D(_Rdevice->SetDither (bPrevDither));

    Assert(!FAILED(hr) && "Failed to restore dither");
}



/*****************************************************************************
This method returns the D3D RM device interface for the given GeomDDRenderer.
If the SeqNum parameter is not null, then we fill in the ID for this object as
well.  This is used to determine if the RM Device may have changed from the
last query.
*****************************************************************************/

void GeomRendererRM3::GetRMDevice (IUnknown **D3DRMDevice, DWORD *SeqNum)
{
    _Rdevice -> AddRef();
    *D3DRMDevice = (IUnknown*) _Rdevice;
    if (SeqNum) *SeqNum = _id;
}


/*****************************************************************************
Set a clip plane on a clipped visual
*****************************************************************************/

HRESULT GeomRendererRM3::SetClipPlane(Plane3 *plane, DWORD *planeID)
{
    HRESULT hr = E_FAIL;

    // set up our ddrenderer to accept clip planes,
    //     if not already done
    if (!_clippedVisual) {
        if (SUCCEEDED(AD3D(GetD3DRM3()->CreateClippedVisual(_geomFrame,&_clippedVisual)))) {
            if (SUCCEEDED(AD3D(GetD3DRM3()->CreateFrame(_scene,&_clippedFrame)))) {
                if (FAILED(AD3D(_clippedFrame->AddVisual(_clippedVisual)))) {
                    _clippedFrame->Release();
                    _clippedFrame = NULL;
                    _clippedVisual->Release();
                    _clippedVisual = NULL;
                }
            } else {
                _clippedFrame = NULL;
                _clippedVisual->Release();
                _clippedVisual = NULL;
            }
        } else {
            _clippedVisual = NULL;
        }
    }

    // Set clipping plane on frame.  Note that we want all the stuff on the positive
    // side of the plane to stay, and the stuff on the negative side to be clipped
    // away.  This is the opposite of what D3DRM does, so we invert the plane
    // normal before giving the plane to D3DRM.
    if (_clippedVisual) {
        D3DVECTOR point;
        point.x = plane->Point().x;
        point.y = plane->Point().y;
        point.z = plane->Point().z;
        D3DVECTOR normal;
        normal.x = -plane->Normal().x;
        normal.y = -plane->Normal().y;
        normal.z = -plane->Normal().z;
        hr = AD3D(_clippedVisual->AddPlane(NULL,&point,&normal,0,planeID));
    }

    return hr;
}


/*****************************************************************************
Remove a clip plane from a clipped visual
*****************************************************************************/

void GeomRendererRM3::ClearClipPlane(DWORD planeID)
{
    if (_clippedVisual) {
        TD3D(_clippedVisual->DeletePlane(planeID,0));
    }
}


/*****************************************************************************
Set lighting to desired state
*****************************************************************************/

void GeomRendererRM3::PushLighting(bool lighting)
{
    if (0 == _depthLighting++) {
        D3DRMRENDERQUALITY  qual = _Rdevice->GetQuality();
        if (lighting) {
            qual = (qual & ~D3DRMLIGHT_MASK) | D3DRMLIGHT_ON;
        } else {
            qual = (qual & ~D3DRMLIGHT_MASK) | D3DRMLIGHT_OFF;
        }
        TD3D(_Rdevice->SetQuality(qual));
    }
}


/*****************************************************************************
Restore lighting to default state
*****************************************************************************/

void GeomRendererRM3::PopLighting(void)
{
    if (0 == --_depthLighting) {
        D3DRMRENDERQUALITY qual = _Rdevice->GetQuality();
        qual = (qual & ~D3DRMLIGHT_MASK) | D3DRMLIGHT_ON;
        TD3D(_Rdevice->SetQuality(qual));
    }
}


/*****************************************************************************
Push a new state of overriding opacity.
*****************************************************************************/

void GeomRendererRM3::PushOverridingOpacity (bool override)
{
    if (0 == _depthOverridingOpacity++) {
        _overriding_opacity = override;
    }
}


/*****************************************************************************
Pop the last state for overriding opacity and restore to default if necessary.
*****************************************************************************/

void GeomRendererRM3::PopOverridingOpacity (void)
{
    if (0 == --_depthOverridingOpacity) {
        _overriding_opacity = false;
    }
}


/*****************************************************************************
Put the renderer into shadow mode.  All rendered geometry will now be
collected into _shadowGeom instead of rendered.  Lights will be collected into
_shadowLights instead of added to the main scene.  At EndRendering() time,
all of the shadows will be rendered.
*****************************************************************************/

bool GeomRendererRM3::StartShadowing(Plane3 *shadowPlane)
{
    // make sure we're not already doing shadow geometry collecting
    if (_shadowGeom) {
        return false;
    }

    // create a master shadow scene frame, if needed
    if (!_shadowScene) {
        if (FAILED(_d3drm->CreateFrame(NULL,&_shadowScene))) {
            _shadowScene = NULL;
            return false;
        }
    }

    // create a frame with which to collect geometry
    if (FAILED(_d3drm->CreateFrame(NULL,&_shadowGeom))) {
        _shadowGeom = NULL;
        return false;
    }

    // save pointer to specified shadow plane
    _shadowPlane = *shadowPlane;

    // shadow's color is current state's emissive color
    if (_currAttrState._emissive) {
        _shadowColor = *(_currAttrState._emissive);
    } else {
        _shadowColor.red = _shadowColor.green = _shadowColor.blue = 0.0;
    }

    // shadow's opacity is current state's opacity
    if (_currAttrState._opacity >= 0) {
        _shadowOpacity = _currAttrState._opacity;
    } else {
        _shadowOpacity = 0.5;
    }

    return true;
}


/*****************************************************************************
Put the renderer back into normal rendering mode.  Note that multiple
_shadowGeom objects will be accumulated into _shadowScene until _shadowScene
is rendered and emptied by EndRendering().
*****************************************************************************/

void GeomRendererRM3::StopShadowing(void)
{
    Assert (_shadowGeom);
    RELEASE(_shadowGeom);
}


/*****************************************************************************
Are we shadowing right now?
*****************************************************************************/

bool GeomRendererRM3::IsShadowing(void)
{
    return (_shadowGeom != NULL);
}


/*****************************************************************************
Push a new state of alpha (high-quality) shadows.
*****************************************************************************/

void GeomRendererRM3::PushAlphaShadows(bool alphaShadows)
{
    if (0 == _depthAlphaShadows++) {
        _alphaShadows = alphaShadows;
    }
}


/*****************************************************************************
Pop the last state for alpha shadows and restore to default if necessary.
*****************************************************************************/

void GeomRendererRM3::PopAlphaShadows(void)
{
    if (0 == --_depthAlphaShadows) {
        _alphaShadows = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\meshmaker.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

*******************************************************************************/


#include "headers.h"
#include "privinc/meshmaker.h"
#include "privinc/lighti.h"
#include "privinc/d3dutil.h"
#include "privinc/server.h"     // for TD3D Timers
#include "privinc/rmvisgeo.h"

MeshMaker::MeshMaker(DirectDrawImageDevice *dev, int count)
{
    _countingOnly = (count == 0);

    _expectedCount = count;
    _imgDev = dev;
    
    Assert(_attrStateStack.empty());
    _currAttrState.InitToDefaults();

    SetState(RSReady);

    _numPrims = 0;
}

MeshMaker::~MeshMaker()
{
}

void
MeshMaker::GrabResultBuilder(IDirect3DRMMeshBuilder3 **ppResult)
{
    _resultBuilder->AddRef();
    *ppResult = _resultBuilder;
}

void
MeshMaker::AddLight (LightContext &context, Light &light)
{
    // Just ignore lights.
}

void
DumpVisualWithStateToMeshBuilder(IDirect3DRMMeshBuilder3 *mb,
                                 IDirect3DRMVisual *vis,
                                 CtxAttrState &state)
{
    // Push all state into a frame.  Need to create a mini-hierarchy,
    // because AddFrame doesn't pay attention to transforms (and
    // perhaps other stuff?) on the outer frame, only on the inner
    // frame. 
    IDirect3DRMFrame3 *outerFrame;
    IDirect3DRMFrame3 *innerFrame;

    TD3D(GetD3DRM3()->CreateFrame(NULL, &outerFrame));
    TD3D(GetD3DRM3()->CreateFrame(outerFrame, &innerFrame));

    LoadFrameWithGeoAndState(innerFrame, vis, state);

    // Load frame into meshbuilder
    TD3D(mb->AddFrame(outerFrame));

    RELEASE(outerFrame);
    RELEASE(innerFrame);
}


void
DumpToMeshBuilder(IDirect3DRMMeshBuilder3 *mb,
                  RMVisualGeo *geo,
                  CtxAttrState &state)
{
    DumpVisualWithStateToMeshBuilder(mb, geo->Visual(), state);

    // Label with the source geometry's address
    DWORD_PTR address = (DWORD_PTR)geo;
    TD3D(mb->SetAppData(address));
}

void
MeshMaker::Render(RM1VisualGeo *geo)
{
    RenderHelper(geo);
}

void
MeshMaker::Render (RM3VisualGeo *geo)
{
    RenderHelper(geo);
}

void
MeshMaker::RenderHelper(RMVisualGeo *geo)
{

    if (_countingOnly) {
        _numPrims++;
        return;
    }

    if (_expectedCount == 1) {
        
        Assert(_numPrims == 0);
        Assert(!_resultBuilder);
        
        // Just create and dump into our single mesh builder.
        TD3D(GetD3DRM3()->CreateMeshBuilder(&_resultBuilder));
        DumpToMeshBuilder(_resultBuilder, geo, _currAttrState);
        
    } else {

        // Expecting more than one primitive.

        // Submesh Questions:
        //
        // - Generation IDs:  if I need to track gen ids on a
        // meshbuilder i'm adding to this master, then i'll probably
        // need to propagate these changes, right?  also, if genid is
        // bumped on a submesh, will it be bumped on the master?

        if (!_resultBuilder) {
            TD3D(GetD3DRM3()->CreateMeshBuilder(&_resultBuilder));
        }

        // Create a submesh
        IUnknown *pUnk;
        IDirect3DRMMeshBuilder3 *submesh;
        TD3D(_resultBuilder->CreateSubMesh(&pUnk));
        TD3D(pUnk->QueryInterface(IID_IDirect3DRMMeshBuilder3,
                                  (void **)&submesh));

        DumpToMeshBuilder(submesh, geo, _currAttrState);


        RELEASE(pUnk);
        RELEASE(submesh);
        
    }
    
    _numPrims++;
}
    
void
MeshMaker::RenderMeshBuilderWithDeviceState(IDirect3DRMMeshBuilder3 *mb)
{
    // Will be called when there is a chained DXTransform

    // We shouldn't be here if we're only counting.
    Assert(!_countingOnly);

    if (_expectedCount == 1) {
        
        Assert(_numPrims == 0);
        Assert(!_resultBuilder);

        TD3D(GetD3DRM3()->CreateMeshBuilder(&_resultBuilder));

        DumpVisualWithStateToMeshBuilder(_resultBuilder,
                                         mb,
                                         _currAttrState);
        
    } else {

        // Add in the mb as a submesh of our master builder.
        IUnknown *pUnk;
        IDirect3DRMMeshBuilder3 *submesh;
        TD3D(_resultBuilder->CreateSubMesh(&pUnk));
        TD3D(pUnk->QueryInterface(IID_IDirect3DRMMeshBuilder3,
                                  (void **)&submesh));

        DumpVisualWithStateToMeshBuilder(submesh,
                                         mb,
                                         _currAttrState);
        
        RELEASE(pUnk);
        RELEASE(submesh);
    }

    _numPrims++;
}


void
DumpGeomIntoBuilder(Geometry                 *geo,
                    DirectDrawImageDevice    *dev,
                    IDirect3DRMMeshBuilder3 **ppResult)
{
    int count;

    {
        MeshMaker countingMaker(dev, 0);
        geo->Render(countingMaker);
        count = countingMaker.GetCount();
    }

    if (count < 1) {
            
        // Just create an empty meshbuilder and return.
        TD3D(GetD3DRM3()->CreateMeshBuilder(ppResult));
        
    } else {

        MeshMaker maker(dev, count);
        geo->Render(maker);

        maker.GrabResultBuilder(ppResult);
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\imgdev.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Implementation code for generic image rendering device

*******************************************************************************/

#include "headers.h"
#include "privinc/imgdev.h"



ImageDisplayDev::ImageDisplayDev()
{
    _movieImageFrame = NULL;
    
    // Establish initial attributes.
    ResetContextMembers();
}

ImageDisplayDev::~ImageDisplayDev()
{
}



/*****************************************************************************
NOTE: This method is overidden in DirectDrawImageDevice
*****************************************************************************/

void ImageDisplayDev::RenderImage (Image *img)
{
    // The default method for rendering an image is to simply call the render
    // method on the image with this device as an argument.

    img->Render (*this);
}


bool ImageDisplayDev::UseImageQualityFlags(DWORD dwAllFlags, DWORD dwSetFlags, bool bCurrent) {
    
    DWORD dwIQFlags = GetImageQualityFlags();
    bool bAA = false;
        
    #if _DEBUG
        if(IsTagEnabled(tagAntialiasingOn)) 
            return true;
        if(IsTagEnabled(tagAntialiasingOff))
            return false;
    #endif

    if(dwIQFlags & (dwAllFlags)) {
        if(dwIQFlags & dwSetFlags) {
            bAA = true;
        }
    }
    else {
        bAA = bCurrent;
    }
    return bAA;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\probe.cpp ===
/* -*-C++-*-  */
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

Implementation of operations necessary to implement probe (2D and 3D picking)
*******************************************************************************/

#include "headers.h"

#ifdef BUILD_USING_CRRM
#include <crrm.h>
#endif 

#include "appelles/xform2.h"
#include "appelles/hacks.h"

#include "privinc/imagei.h"
#include "privinc/probe.h"
#include "privinc/vec3i.h"
#include "privinc/server.h"
#include "privinc/vec2i.h"
#include "privinc/xformi.h"
#include "privinc/except.h"
#include "privinc/camerai.h"
#include "privinc/ddrender.h"
#include "privinc/debug.h"
#include "privinc/d3dutil.h"
#include "privinc/server.h"
#include "privinc/viewport.h"
#include "privinc/geometry.h"
#include "privinc/rmvisgeo.h"

///////////////////////  2D Intersection  //////////////////////

PointIntersectCtx::PointIntersectCtx (
    Point2Value *wcPoint,
    bool		 stuffResultsIntoQueue,
    Real		 time,
    Real		 lastPollTime,
    LONG		 userIDSize,
    DWORD_PTR	*outputUserIDs,
    double		*outputHitPointsArray,
    LONG		*pActualHitsPointer)
    :
    _wcPoint(wcPoint),
    _resultsStuffed(stuffResultsIntoQueue)
{
    _time         = time;
    _lastPollTime = lastPollTime;
    _xf           = identityTransform2;
    _imgOnlyXf    = identityTransform2;

    _lcPointValid = FALSE;
    _gotHitYet    = false;
    _insideOcclusionIgnorer = false;

    _userIDSize = userIDSize;
    _outputUserIDs = outputUserIDs;
    _outputHitPointsArray = outputHitPointsArray;
    _pActualHitsPointer = pActualHitsPointer;
}

PointIntersectCtx::~PointIntersectCtx()
{
}

void
PointIntersectCtx::SetTransform(Transform2 *xf)
{
    _xf = xf;
    _lcPointValid = FALSE;
}

Transform2 *
PointIntersectCtx::GetTransform()
{
    return _xf;
}

// Return NULL if lcToWc is not invertible.

Point2Value *
PointIntersectCtx::GetLcPoint()
{
    if (!_lcPointValid) {

        Transform2 *invXf = InverseTransform2(_xf);

        if (invXf) {
            _lcPoint = TransformPoint2Value(invXf, _wcPoint);
        } else {
            _lcPoint = NULL;    // if singular transform
        }

        _lcPointValid = TRUE;
    }

    return _lcPoint;
}

void
PointIntersectCtx::SetLcPoint(Point2Value *pt)
{
    _lcPointValid = true;
    _lcPoint = pt;
}

// Push and restore levels.  These maintain all the results
// accumulation, just reset the wc point and the accumulated xforms.
void
PointIntersectCtx::PushNewLevel(Point2Value *newWcPoint)
{
    _wcPoint = newWcPoint;
    _xf = identityTransform2;
    _imgOnlyXf = identityTransform2;
    _lcPointValid = false;
}


void
PointIntersectCtx::RestoreOldLevel(Point2Value *oldWcPoint,
                                   Transform2 *oldTransform,
                                   Transform2 *oldImageOnlyTransform)
{
    _wcPoint = oldWcPoint;
    _xf = oldTransform;
    _imgOnlyXf = oldImageOnlyTransform;
    _lcPointValid = false;
}


void
PointIntersectCtx::AddEventId(int eventId, bool hasData, GCIUnknown *udata)
{
    HitImageData data(hasData, udata);
    data._eventId  = eventId;
    data._type     = HitImageData::Image;
    data._lcPoint2 = GetLcPoint();
    data._lcToWc2  = GetTransform();

    // Only if non-singular.
    if (data._lcPoint2) {
        BEGIN_LEAK
        _hitImages.push_back(data);
        END_LEAK
    }
}



void PointIntersectCtx::AddHitGeometry (
    int           eventId,    // Pick Event Identifier
    bool          hasData,
    GCIUnknown	 *udata,
    Point3Value  *lcHitPt,    // Local Coord Hit Point
    Vector3Value *lcOffsetI,  // Local Coord Offset X Basis Vector
    Vector3Value *lcOffsetJ,  // Local Coord Offset Y Basis Vector
    Point2Value	 *uvPoint)
{
    // Image and geometry hit event ids share the same namespace, so
    // we don't need to worry about event id collision.  Just create a
    // record with the geometry ID in it, and the intersection point.

    HitImageData data(hasData, udata);

    data._eventId   = eventId;
    data._type      = HitImageData::Geometry;
    data._lcPoint3  = lcHitPt;
    data._lcOffsetI = lcOffsetI;
    data._lcOffsetJ = lcOffsetJ;
    data._uvPoint2 = uvPoint;

    BEGIN_LEAK
    _hitImages.push_back(data);
    END_LEAK
}



vector<HitImageData>&
PointIntersectCtx::GetResultData()
{
    return _hitImages;
}



/****************************************************************************/

RayIntersectCtx::~RayIntersectCtx (void)
{
    if (_pickFrame) _pickFrame->Release();
    if (_winner && _winner->hitVisual) _winner->hitVisual->Release();

    // Clear the current camera from the GeomRenderer object.  Setting it to
    // null across frames will catch value leaks if they occur.

    if (_gRenderer)
        _gRenderer->SetCamera (NULL);
}



/*****************************************************************************
This method sets up the ray-intersection context in preparation for pick-
testing on each 3D primitive.  It handles both the old-style (pre RM6) and the
new style (RM6+ ray pick).
*****************************************************************************/

bool RayIntersectCtx::Init (
    PointIntersectCtx &context2D,
    Camera            *camera,
    Geometry          *geometry)
{
    _context2D = &context2D;
    _camera = camera;

    Point2Value *imagePick = _context2D->GetLcPoint();

    // Bail out if we hit a singular transform.

    if (!imagePick)
    {
        TraceTag ((tagPick3, "Aborting 3D pick traversal; singular xform."));
        return false;
    }

    _wcRay = _camera->GetPickRay (imagePick);

    TraceTag ((tagPick3, "Pick Ray = {%g,%g,%g} -> {%g,%g,%g}",
        _wcRay->Origin().x, _wcRay->Origin().y, _wcRay->Origin().z,
        _wcRay->Direction().x, _wcRay->Direction().y, _wcRay->Direction().z));

    // If the RM3 interface is available, then we can use the ray-pick
    // interface to do picking.  If the current platform doesn't support RM3,
    // then we use the old code which picks through a viewport.

    _rmraypick = (GetD3DRM3() != 0);

    if (_rmraypick)
    {
        if (FAILED(AD3D(GetD3DRM3()->CreateFrame (0, &_pickFrame))))
            return false;
    }
    else
    {
        // In DX3, we have to first get an available 3D renderer to use for a
        // pick engine.  We do this because picking needs a viewport which
        // needs a device which needs a surface.

        _gRenderer = GetCurrentViewport()->GetAnyGeomRenderer();

        if (!_gRenderer || !_gRenderer->PickReady())
        {
            TraceTag ((tagPick3, "Can't find GRenderer for 3D picking."));
            return false;
        }

        // We do picking in a very strange way due to the way that D3D DX3 RM
        // does picking.  D3D takes screen pixel coordinates as the origin of
        // the pick point.  In order to hack around this, we effectively create
        // a fake view that is an extreme tight view, along the pick ray, of
        // the probe point.  Then we take the target surface rectangle of
        // whatever GeomRenderer we find to be the full width of the picking
        // "beam", and probe the center of the viewport.  This technique may
        // fail if the projected geometry image is scaled way way up and the
        // viewport is small, but oh well.

        const Real delta = 1e-4;   // Watch me pull a rabbit out of my hat...

        Bbox2 pickbox (imagePick->x - delta, imagePick->y - delta,
                       imagePick->x + delta, imagePick->y + delta);

        _gRenderer->SetCamera (_camera);
        _gRenderer->SetView (NULL, pickbox, geometry->BoundingVol());
    }

    return true;
}

void RayIntersectCtx::SetLcToWc (Transform3 *xf)
{   _lcToWc = xf;
}

Transform3 *RayIntersectCtx::GetLcToWc (void)
{   return _lcToWc;
}


/*****************************************************************************
Manage the semantics of overriding attribution for the geometry texture-maps.
_texmapLevel is the number of current texmap attributions in the traversal.
*****************************************************************************/

void RayIntersectCtx::SetTexmap (Image *image, bool upsideDown)
{
    if (_texmapLevel++ == 0) {
        _texmap = image;
        _upsideDown = upsideDown;
    }
}


void RayIntersectCtx::EndTexmap (void)
{
    if (--_texmapLevel == 0)
        _texmap = 0;
}



/*****************************************************************************
Push a given integer event ID and current model transform for all geometries
that are subsequently hit.  There may be nested pickables (e.g. a pick event
for a car, plus a pick event for a particular tire on that car).
*****************************************************************************/

void RayIntersectCtx::PushPickableAsCandidate(int eventId,
                                              bool hasData,
                                              GCIUnknown *u)
{
    // Add the geometry, along with the current transform.

    HitGeomData data(hasData, u);

    data._eventId = eventId;
    data._lcToWcTransform = GetLcToWc();

    _candidateData.push_back (data);
}



/*****************************************************************************
Pop the latest candidate event ID data off the candidate data stack.
*****************************************************************************/

void RayIntersectCtx::PopPickableAsCandidate (void)
{
    _candidateData.pop_back();
}



/*****************************************************************************
Submit the given Direct3D Retained-Mode visual for picking.
*****************************************************************************/

void
RayIntersectCtx::SubmitWinner(Real hitDist,
                              Point3Value &pickPoint,
                              float   tu,
                              float   tv,
                              int     faceIndex,
                              IDirect3DRMVisual *hitVisual)
{
    // If we haven't hit anything before, allocate the HitInfo
    // member of the ray-intersection context.

    // We'll pass in a faceIndex of -1 if we are dealing with a picked
    // subgeometry from having picked into a DXTransform.  If that's
    // that case, then be sure that we don't have any previous
    // winners.  If we do, there's a logic error.
    Assert(faceIndex != -1 || !_gotAWinner);

    if (!_gotAWinner) {
        _winner = NEW HitInfo;
        _winner->mesh = NULL;
        _gotAWinner = true;
        _winner->hitVisual = NULL;
    }
    else if (_winner->hitVisual) {
        // Release the previous contender's visual.
        _winner->hitVisual->Release();
        _winner->hitVisual = NULL;
    }

    _winner->wcDistSqrd = hitDist;
    _winner->lcToWc = _lcToWc;
    _winner->texmap = _texmap;
    _winner->wcoord = pickPoint;
    _winner->surfCoord.Set (tu, tv);

    if (_dxxfInputs) {

        _winner->dxxfInputs = _dxxfInputs;
        _winner->dxxfNumInputs = _dxxfNumInputs;
        _winner->dxxfGeometry = _dxxfGeometry;
        _winner->hitFace = faceIndex;

        // hitVisual came from GetPick().  It has an extra
        // reference which we just keep since we need to
        // keep a reference to this guy.
        _winner->hitVisual = hitVisual;
        hitVisual->AddRef();
    }

    // Copy the list of pick event data to the current winner.
    _currentWinnerData = _candidateData;

}

void
RayIntersectCtx::SetPickedSubGeo(Geometry *subGeo, float tu, float tv)
{
    _subgeo = subGeo;
    _subgeoTu = tu;
    _subgeoTv = tv;
}

Geometry *
RayIntersectCtx::GetPickedSubGeo(float *ptu, float *ptv)
{
    *ptu = _subgeoTu;
    *ptv = _subgeoTv;
    return _subgeo;
}

bool
RayIntersectCtx::LookingForSubmesh()
{
    return _subgeo ? true : false;
}

bool
RayIntersectCtx::GotTheSubmesh()
{
    return (_subgeo != NULL) && _gotAWinner;
}


void RayIntersectCtx::Pick (IDirect3DRMVisual *vis)
{
    TraceTag ((tagPick3Geometry, "Picking visual %x", vis));

    if (_rmraypick)
    {

        // For debug checking; assure that there are no visuals left on the
        // pick frame -- it should contain nothing.

        #if _DEBUG
        {
            DWORD nVisuals;
            if (FAILED(_pickFrame->GetVisuals (&nVisuals, NULL)) || nVisuals)
                AssertStr (0, "_pickFrame should be empty, but isn't.");
        }
        #endif

        // Add the visual to our picking frame and set the frames transform to
        // the current local-to-world transform.
        TD3D (_pickFrame->AddVisual (vis));

        D3DRMMATRIX4D d3dmat;
        LoadD3DMatrix (d3dmat, _lcToWc);

        TD3D (_pickFrame->AddTransform (D3DRMCOMBINE_REPLACE, d3dmat));

        // Set up the RM pick ray with our pick ray.

        D3DRMRAY rmPickRay;
        LoadD3DRMRay (rmPickRay, *_wcRay);

        // Issue the pick to RM, and get back the PickArray interface.
#ifndef BUILD_USING_CRRM
        IDirect3DRMPicked2Array *pickArray;

        TD3D (_pickFrame->RayPick (
            NULL, &rmPickRay,
            D3DRMRAYPICK_IGNOREFURTHERPRIMITIVES | D3DRMRAYPICK_INTERPOLATEUV,
            &pickArray
        ));
#else
        ICrRMPickedArray *pickArray;
        LPCRRMFRAME pCrRMFrame;

        TD3D (_pickFrame->QueryInterface(IID_ICrRMFrame, (LPVOID*)&pCrRMFrame));

        TD3D (pCrRMFrame->RayPick (
            NULL, &rmPickRay,
            D3DRMRAYPICK_IGNOREFURTHERPRIMITIVES | D3DRMRAYPICK_INTERPOLATEUV,
            &pickArray
        ));

        pCrRMFrame->Release();
#endif
        // Process the picks.

        DWORD i;
        DWORD nHits = pickArray->GetSize();

        TraceTag ((tagPick3Geometry, "%d hits", nHits));

        for (i=0;  i < nHits;  ++i)
        {
            D3DRMPICKDESC2 pickDesc;
            DAComPtr<IDirect3DRMVisual> hitVisual;

            TD3D (pickArray->GetPick(i, &hitVisual, NULL, &pickDesc));

            Point3Value pickPoint (pickDesc.dvPosition);

            Real hitDist = DistanceSquared(_wcRay->Origin(), pickPoint);

            TraceTag ((tagPick3Geometry,
                "vis %d, distSqrd %g, texmap %x\n"
                "    hit <%g,%g,%g>, uv <%g,%g>",
                i, hitDist, _texmap,
                pickPoint.x,pickPoint.y,pickPoint.z,
                pickDesc.tu, pickDesc.tv));

            if (!_gotAWinner || (hitDist < _winner->wcDistSqrd))
            {
                SubmitWinner(hitDist,
                             pickPoint,
                             pickDesc.tu,
                             pickDesc.tv,
                             pickDesc.ulFaceIdx,
                             hitVisual);
            }
        }

        // Done with picking.  Release the pick array and remove the visual
        // from the pick frame before returning.

        if (pickArray)
            pickArray->Release();

        TD3D (_pickFrame->DeleteVisual (vis));
    }
    else
    {
        // Using old-style viewport picking for pre RM6.

        Assert(vis);
        _gRenderer->Pick (*this, vis, _lcToWc);
    }
}



/*****************************************************************************
This method submits a hit point for consideration to the picking context.  It
selects the nearest submitted point as the picked point.  Note that the point
is submitted in D3D RM screen coordinates.

       --- THIS METHOD IS CALLED ONLY FOR PRE-RM6 PLATFORMS ---

*****************************************************************************/

void RayIntersectCtx::SubmitHit (HitInfo *hit)
{
    // If the new point is farther than the current winner, ignore it.

    if (_gotAWinner && (hit->scoord.z >= _winner->scoord.z)) return;

    // Update the pick point information with the new winner.

    if (_gotAWinner)
        _winner->mesh->Release();
    else
        _gotAWinner = TRUE;

    if (_winner)
        delete _winner;

    _winner = hit;
    _winner->hitVisual = NULL;
    _winner->texmap = _texmap;

    // Also store the world-coordinates of the hit point, and the distance
    // squared from the pick ray origin to the hit point.

    _gRenderer->ScreenToWorld (_winner->scoord, _winner->wcoord);
    _winner->wcDistSqrd = DistanceSquared (_wcRay->Origin(), _winner->wcoord);

    // Copy the list of pick event data to the current winner data.

    _currentWinnerData = _candidateData;
}



/*****************************************************************************
This function returns true if the given world-coordinate hit point is closer
than the current winning pick point.
*****************************************************************************/

bool RayIntersectCtx::CloserThanCurrentHit (Point3Value &wcPoint)
{
    return !_gotAWinner
           || (_winner->wcDistSqrd > DistanceSquared(_wcRay->Origin(),wcPoint));
}

// Helper routine to get texture app data off of a hit visual
DWORD
AppDataFromHitTexture(IDirect3DRMVisual *visual,
                      ULONG              faceIndex)
{
    IDirect3DRMMeshBuilder3 *mb3;

    // This had better succeed, since we know the only
    // place we want texture and submesh info is in
    // dxtransforms, where we submitted an mb3.
    TD3D(visual->QueryInterface(IID_IDirect3DRMMeshBuilder3,
                                (void **)&mb3));

    DWORD result = 0;

    // If a bogus visual is returned, this won't hold, so just be
    // safe.  (RM bug 24501.)
    if (mb3->GetFaceCount() > faceIndex) {

        IDirect3DRMFace2 *face;
        TD3D(mb3->GetFace(faceIndex, &face));

        IDirect3DRMTexture3 *tex;
        TD3D(face->GetTexture(&tex));

        if (tex != NULL) {
            result = tex->GetAppData();
        }

        RELEASE(tex);
        RELEASE(face);
    }

    RELEASE(mb3);

    return result;
}

/*****************************************************************************
This routine is called at the end of a picking traversal, and processes the
data we collected for the neareest pick point.
*****************************************************************************/

bool RayIntersectCtx::ProcessEvents (void)
{
    // If we didn't pick any geometry, then bail out.

    if (!_gotAWinner) return false;

    // Only get the texmap point if we have a mesh registered.

    Point2Value *uvPt;

    // Descend into Texmap if either there is a texmap specified, or
    // if we have dxtransform inputs.
    bool    texmapDescend =
        (_winner->texmap != 0) ||
        (_winner->dxxfNumInputs > 0);

    if (_rmraypick) {

        uvPt = NEW Point2Value(_winner->surfCoord.x,
                               _winner->surfCoord.y);

    } else {

        if (_winner->mesh) {

            uvPt = GetTexmapPoint (*_winner);

            _winner->mesh -> Release();    // Done with picked mesh.
            _winner->mesh = 0;

            TraceTag ((tagPick3Offset, "uv: %f %f", uvPt->x, uvPt->y));

        } else {

            uvPt = NEW Point2Value(0,0);
            texmapDescend = false;

        }
    }

    // If we hit a geometry with an image textured on it, continue the picking
    // descent into the image.
    bool gotOneOnRecursion = false;

    if (texmapDescend)
    {
        Point2Value daImageCoord (uvPt->x, 1 - uvPt->y);

        // Figure out what texture map to descend into
        Image *textureToDescendInto = NULL;
        if (_winner->texmap) {

            // An outer-applied texture always overrides inner-applied ones.
            textureToDescendInto = _winner->texmap;

            if (_upsideDown) {
                daImageCoord.y = 1 - daImageCoord.y;
            }

        } else if (_winner->hitVisual) {

            DWORD imageInputNumber =
                AppDataFromHitTexture(_winner->hitVisual,
                                      _winner->hitFace);

            if (imageInputNumber > 0 &&
                imageInputNumber <= _winner->dxxfNumInputs) {

                int imageInputIndex = imageInputNumber - 1;
                AxAValue val = _winner->dxxfInputs[imageInputIndex];

                if (val->GetTypeInfo() == ImageType) {

                    // This should always be an image, but there's
                    // nothing preventing an errant transform from
                    // returning an index to a non-image input.
                    textureToDescendInto = SAFE_CAST(Image *, val);

                    // We're returned texture coords in the [0,1]
                    // range, and we need to map these back to the
                    // original input image.  Do so by getting the
                    // image's bbox and doing the appropriate
                    // mapping.
                    Bbox2 box = textureToDescendInto->BoundingBox();

                    Real width = box.max.x - box.min.x;
                    Real newX = box.min.x + width * daImageCoord.x;

                    Real height = box.max.y - box.min.y;
                    Real newY = box.min.y + height * daImageCoord.y;

                    daImageCoord.x = newX;
                    daImageCoord.y = newY;

                }
            }
        }

        if (textureToDescendInto) {
            PerformPicking (
                textureToDescendInto,
                &daImageCoord,
                _context2D->ResultsBeingStuffedIntoQueue(),
                _context2D->Time(),
                _context2D->LastPollTime(),
                _context2D->UserIDSize(),
                _context2D->OutputUserIDs(),
                _context2D->OutputHitPointsArray(),
                _context2D->ActualHitsPointer()
                );

        } else if (_winner->hitVisual) {

            // Didn't go into a texture, but we may still have
            // submeshes we need to deal with!!  Get AppData off of
            // the hit visual to find out.

            DWORD_PTR address = _winner->hitVisual->GetAppData();

            if (address) {
                Geometry *hitSubgeo = (Geometry *)address;

                RayIntersectCtx new3DCtx;

                if (new3DCtx.Init(*_context2D,
                                  _camera,
                                  NULL)) {

                    new3DCtx.SetPickedSubGeo(hitSubgeo,
                                             _winner->surfCoord.x,
                                             _winner->surfCoord.y);

                    _winner->dxxfGeometry->RayIntersect(new3DCtx);

                    gotOneOnRecursion = new3DCtx.ProcessEvents();

                    // Just continue on, processing the rest.
                }

            }


        }
    }

    if (_winner->hitVisual) {
        // Don't need any longer.
        _winner->hitVisual->Release();
        _winner->hitVisual = NULL;
    }

    // Now we need to calculate basic vectors with which to generate the
    // local-coordinate offset behaviors for this pick.  Fisrt, get the
    // camera scaling factors.

    Real camScaleX, camScaleY, camScaleZ;
    _camera->GetScale (&camScaleX, &camScaleY, &camScaleZ);

    // Calculate the perspective distortion factor for the given camera-coord
    // hit point.

    Real perspectiveFactor;

    if (_camera->Type() == Camera::ORTHOGRAPHIC)
    {   perspectiveFactor = 1;
    }
    else
    {   // Get the camera coordinates of the winning hit point.

        Point3Value cP = _winner->wcoord;
        Transform3 *wToC = _camera->WorldToCamera();

        if (!wToC) {
            return false;
        }

        cP.Transform (wToC);

        perspectiveFactor = (cP.z + camScaleZ) / camScaleZ;
    }

    // Get the world-coordinate offset basis vectors for the pick offset.
    // These will be used to construct the local-coordinate offset basis
    // vectors.

    Vector3Value wOffsetI ((perspectiveFactor * camScaleX), 0, 0);
    Vector3Value wOffsetJ (0, (perspectiveFactor * camScaleY), 0);

    TraceTag ((tagPick3Offset, "C offset i: %f %f %f",
        wOffsetI.x, wOffsetI.y, wOffsetI.z));
    TraceTag ((tagPick3Offset, "C offset j: %f %f %f",
        wOffsetJ.x, wOffsetJ.y, wOffsetJ.z));

    wOffsetI.Transform (_camera->CameraToWorld());
    wOffsetJ.Transform (_camera->CameraToWorld());

    TraceTag ((tagPick3Offset, "W offset i: %f %f %f",
        wOffsetI.x, wOffsetI.y, wOffsetI.z));
    TraceTag ((tagPick3Offset, "W offset j: %f %f %f",
        wOffsetJ.x, wOffsetJ.y, wOffsetJ.z));

    // Go through the winner data and stuff results into the back of the 2D
    // context that this intersection traversal was invoked from.  Do
    // it backwards so the most-specific gets pushed on first.

    vector<HitGeomData>::reverse_iterator i;

    bool processedAtLeastOne = gotOneOnRecursion;

    for (i=_currentWinnerData.rbegin(); i != _currentWinnerData.rend(); i++) {

        // Record the hit point and the offset basis vectors, all in local
        // coordinates of the winner.  Since we need to get the inverse of
        // the local-to-world transform, skip this hit if the transform is
        // non-invertible.

        Transform3 *wcToLc = InverseTransform3 (i->_lcToWcTransform);

        if (wcToLc) {
            Point3Value  *lcPt      = TransformPoint3 (wcToLc, &_winner->wcoord);
            Vector3Value *lcOffsetI = TransformVec3   (wcToLc, &wOffsetI);
            Vector3Value *lcOffsetJ = TransformVec3   (wcToLc, &wOffsetJ);

            TraceTag ((tagPick3Offset, "L offset i: %f %f %f",
                       lcOffsetI->x, lcOffsetI->y, lcOffsetI->z));
            TraceTag ((tagPick3Offset, "L offset j: %f %f %f",
                       lcOffsetJ->x, lcOffsetJ->y, lcOffsetJ->z));

            _context2D->AddHitGeometry
                (i->_eventId, i->HasUserData(), i->GetUserData(),
                 lcPt, lcOffsetI, lcOffsetJ, uvPt);

            processedAtLeastOne = true;
        }
    }

    delete _winner;
    _winner = 0;

    return processedAtLeastOne;
}




/*****************************************************************************
This function probes the given image at the specified position, and adds the
resulting hit data to the queue for each event ID.  If stuffResults
is FALSE, the queue isn't touched, and the time and lastPollTime are ignored.
*****************************************************************************/

bool PerformPicking (
    Image		*img,           // Image to Probe
    Point2Value	*wcPosition,    // World-Coordinate Image Position
    bool		 stuffResults,  // whether or not to stuff the results in the ctx
    Real		 time,          // Current Time
    Real		 lastPollTime,  // Last Probe Time
    LONG		 s,             // user id size, dft = 0
    DWORD_PTR	*usrIds,        // output user ids, dft = NULL
    double		*points,        // output hit points, dft = NULL
    LONG		*pActualHits)    // actual hits
{

    PointIntersectCtx ctx (wcPosition,
                           stuffResults,
                           time,
                           lastPollTime,
                           s,
                           usrIds,
                           points,
                           pActualHits);

    bool hitSomething = img->DetectHit(ctx) ? true : false;

    TraceTag((tagPick2, "Picking %s at %8.4g, %8.4g on 0x%x",
              hitSomething ? "HIT" : "MISSED",
              wcPosition->x, wcPosition->y, img));

    if (hitSomething && (stuffResults || (usrIds && points))) {

        LONG u;

        if (pActualHits) {
            u = *pActualHits;
        }

        // Stuff the results into the result list.  Go through the
        // list backwards so that for QueryHitPointEx, the most
        // specific hit is inserted first.
        vector<HitImageData>& results = ctx.GetResultData();
        vector<HitImageData>::iterator i;

        for (i = results.begin(); i != results.end(); ++i) {

            if (usrIds && i->HasUserData()) {

                if (u >= s) {
                    u++;
                    continue;
                }

                GCIUnknown *g = i->GetUserData();
                LPUNKNOWN p = g->GetIUnknown();
                usrIds[u] = (DWORD_PTR) p;
                if (p) p->AddRef();

                const int P = 5;

                if (i->_type == HitImageData::Image) {
                    points[u * P] = i->_lcPoint2->x;
                    points[u * P + 1] = i->_lcPoint2->y;
                    points[u * P + 2] = 0.0;
                } else {
                    points[u * P] = i->_lcPoint3->x;
                    points[u * P + 1] = i->_lcPoint3->y;
                    points[u * P + 2] = i->_lcPoint3->z;
                    points[u * P + 3] = i->_uvPoint2->x;
                    points[u * P + 4] = i->_uvPoint2->y;
                }

                u++;

            } else {

                int id = i->_eventId;

                PickQData data;
                data._eventTime = time;
                data._lastPollTime = lastPollTime;
                data._type = i->_type;
                data._wcImagePt = *wcPosition;

                bool singular = false;

                if (i->_type == HitImageData::Image) {
                    data._xCoord  = i->_lcPoint2->x;
                    data._yCoord  = i->_lcPoint2->y;
                    data._wcToLc2 = InverseTransform2(i->_lcToWc2);

                    Assert(data._wcToLc2 && "Didn't think we could both be singular and get a hit.");

                    // ... but just in case
                    if (!data._wcToLc2) {
                        singular = true;
                    }

                    TraceTag((tagPick2Hit,
                              "Pick image at %f id=%d, wc=(%f,%f), lc=(%f,%f)",
                              time, id, wcPosition->x, wcPosition->y,
                              data._xCoord, data._yCoord));

                } else {

                    data._xCoord   =  i->_lcPoint3->x;
                    data._yCoord   =  i->_lcPoint3->y;
                    data._zCoord   =  i->_lcPoint3->z;
                    data._offset3i = *i->_lcOffsetI;
                    data._offset3j = *i->_lcOffsetJ;

                    TraceTag((tagPick3Geometry,
                              "Pick geom at %f id=%d, wc=(%f,%f), lc=(%f,%f,%f)",
                              time, id, wcPosition->x, wcPosition->y,
                              data._xCoord, data._yCoord, data._zCoord));
                }

                if (!singular) {
                    AddToPickQ (id, data);
                }
            }
        }

        if (usrIds && points)
            *pActualHits = u;
    }

    return hitSomething;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\qmididev.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    quartz rendering device for MIDI Sounds

*******************************************************************************/

#include "headers.h"
#include <sys/types.h>
#include <sys/timeb.h>
#include <stdio.h>
#include "privinc/mutex.h"
#include "privinc/util.h"
#include "privinc/storeobj.h"
#include "privinc/debug.h"
#include "privinc/except.h"
#include "privinc/qdev.h"
#include "privinc/path.h"


QuartzMIDIdev::QuartzMIDIdev() : _path(NULL), _filterGraph(NULL)
{
    // Init the path list, it should be cleared (deleted and
    // recreated) before each render.  When a sound finish is
    // detected, it should push the path to this donePathList.
    //donePathList = AVPathListCreate();

    TraceTag((tagSoundDevLife, "QuartzMIDIdev constructor"));
}


QuartzMIDIdev::~QuartzMIDIdev()
{
    TraceTag((tagSoundDevLife, "QuartzMIDIdev destructor"));

    //if(donePathList)
        //AVPathListDelete(donePathList);


    if(_filterGraph) {
        _filterGraph->Stop();
        _filterGraph = NULL;  // no longer have a 'current' MIDI sound
    }

    if(_path) {
        DynamicHeapPusher h(GetSystemHeap());
        AVPathDelete(_path);
    }
}


void QuartzMIDIdev::BeginRendering()
{

    TraceTag((tagSoundRenders, "QuartzMIDIdev::BeginRendering()"));

#ifdef ONEDAY
    // Now clear the list, the sampler should be done with it.

    // AVPathList is not a storeobj obj, not need to push heaps
    AVPathListDelete(donePathList);
    //PushDynamicHeap(GetSystemHeap());
    donePathList = AVPathListCreate();
    //PopDynamicHeap();
#endif
}


void QuartzMIDIdev::EndRendering()
{
    TraceTag((tagSoundRenders, "QuartzMIDIdev::EndRendering()"));
}


void QuartzMIDIdev::StealDevice(QuartzRenderer *newFilterGraph, AVPath path)
{
    Assert(newFilterGraph);

    if(_filterGraph) // dispatch the existing filterGraph
        _filterGraph->Stop();

    _filterGraph   = newFilterGraph;

    // We need to save the path, so allocate it on the system heap
    // TODO: Who's going to delete it?
    {
        DynamicHeapPusher h(GetSystemHeap());

        if (_path)
            AVPathDelete(_path);
        _path = AVPathCopy(path);
    }
}


void QuartzMIDIdev::Stop(MIDIbufferElement *bufferElement)
{
    if(_path) { // possible for the buffer to exist but device not be claimed
        if(AVPathEqual(_path, bufferElement->GetPath())) 
            _filterGraph->Stop();
        else
            Assert(1);  // we weren't playing (this line for debug only)
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\textctx.cpp ===
/*******************************************************************************

Copyright (c) 1996 Microsoft Corporation

Abstract:

    Context for accumlating information and rendering text as bitmaps
    to an image.

*******************************************************************************/

#include "headers.h"
#include "privinc/textctx.h"
#include "privinc/imgdev.h"

// -- Yes, the _WHOLE_ textCtx class is implemented in
// -- privinc/textctx.h.

/*
TextCtx
BitmapTextCtx(ImageDisplayDevImpl& dev,
              Real resolution)
{
    return TextCtx(dev, resolution);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\surfacemanager.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

#include <privinc/SurfaceManager.h>
#include <privinc/viewport.h>

SurfaceManager::SurfaceManager(DirectDrawViewport &ownerVp):
    _owningViewport(ownerVp),
    _doingDestruction(false)
{
}


SurfaceManager::~SurfaceManager()
{
    _doingDestruction = true;

    DeleteAll(_maps);
    DeleteAll(_pools);    
}

void SurfaceManager::
DeleteAll(collection_t &sc)
{
    collection_t::iterator i;

    for(i = sc.begin(); i != sc.end(); i++) {
        delete (*i);
    }
}

SurfacePool *SurfaceManager::
GetSurfacePool(DDPIXELFORMAT *pf)
{
    Assert(pf);
    return (SurfacePool *)Find(_pools, pf);
}

void SurfaceManager::
AddSurfacePool(SurfacePool *sp)
{
    if(sp) _pools.push_back( (SurfaceCollection *)sp);
}

void SurfaceManager::
RemoveSurfacePool(SurfacePool *sp)
{
    collection_t::iterator i;
    
    if(!_doingDestruction &&
       Find(_pools, (void *)sp, i) ) {
        _pools.erase(i);
    }
}

SurfaceMap *SurfaceManager::
GetSurfaceMap(DDPIXELFORMAT *pf)
{
    Assert(pf);
    return (SurfaceMap *)Find(_maps, pf);
}

void SurfaceManager::
AddSurfaceMap(SurfaceMap *sm)
{
    if(sm) _maps.push_back( (SurfaceCollection *)sm);
}
        
void SurfaceManager::
RemoveSurfaceMap(SurfaceMap *sm)
{
    collection_t::iterator i;
    
    if(!_doingDestruction &&
       Find(_maps, (void *)sm, i) ) {
        _maps.erase(i);
    }
}


void *SurfaceManager::
Find(collection_t &sc, DDPIXELFORMAT *pf)
{
    collection_t::iterator i;
    
    // look in stack for matching surface pool

    for(i = sc.begin(); i != sc.end(); i++) {
        if( (*i)->IsSamePixelFormat(pf) ) return (void *)(*i);
    }
    
    return NULL;
}    

bool SurfaceManager::
Find(collection_t &sc, void *ptr, collection_t::iterator &i)
{
    for(i = sc.begin(); i != sc.end(); i++) {
        if( (void *)(*i) == ptr ) return true;
    }
    return false;
}
    
SurfaceCollection::
SurfaceCollection(SurfaceManager &mgr,
                  DDPIXELFORMAT pf) :
    _manager(mgr)
{
    _pixelFormat = pf;
}

SurfaceCollection::
~SurfaceCollection()
{
}    


bool SurfaceCollection::
IsSamePixelFormat(DDPIXELFORMAT *pf)
{
    
    Assert(pf);
    
    return (( pf->dwRGBBitCount == GetDepth() ) &&
            ( pf->dwRBitMask    == GetRedMask() ) &&
            ( pf->dwGBitMask    == GetGreenMask() ) &&
            ( pf->dwBBitMask    == GetBlueMask() ));
}


SurfacePool::
SurfacePool(SurfaceManager &mgr,
            DDPIXELFORMAT &pf) :
         SurfaceCollection(mgr, pf)
{
    GetSurfaceManager().AddSurfacePool(this);
}   

SurfacePool::
~SurfacePool()
{
    {
        CritSectGrabber csg(_critSect);
        deletionNotifiers_t::iterator i;
        for (i = _deletionNotifiers.begin(); i !=
                 _deletionNotifiers.end(); i++) {
            
            (*i)->Advise(this);
            
        }
    }
    
    ReleaseAndEmpty();
    GetSurfaceManager().RemoveSurfacePool(this);
}

void
SurfacePool::RegisterDeletionNotifier(DeletionNotifier *delNotifier)
{
    CritSectGrabber csg(_critSect);
    _deletionNotifiers.insert(delNotifier);
}

void
SurfacePool::UnregisterDeletionNotifier(DeletionNotifier *delNotifier)
{
    CritSectGrabber csg(_critSect);
    
    int result =
        _deletionNotifiers.erase(delNotifier);

    Assert(result == 1);
}

void SurfacePool::
ReleaseAndEmpty()
{
    while(! IsEmpty() ) {
        RELEASE_DDSURF( _pool.back(),
                        "SurfacePool::ReleaseAndEmpty",
                        this );
        _pool.pop_back();
    }
}

void SurfacePool::
ReleaseAndEmpty(int numSurfaces)
{
  if(numSurfaces<0) numSurfaces = 0;

    while(! IsEmpty() && numSurfaces) {
        RELEASE_DDSURF( _pool.back(),
                        "SurfacePool::ReleaseAndEmpty",
                        this );
        _pool.pop_back();
	numSurfaces--;
    }
}

void SurfacePool::
CopyAndEmpty(SurfacePool *srcPool)
{
    // don't consider ref counting, not really necessary 
    Assert(srcPool);
    while(! srcPool->IsEmpty() ) {
        PushBack(srcPool->Back());
        srcPool->PopBack();
    }
}

void SurfacePool::
Erase(DDSurface *ddsurf)
{
    if(Find(ddsurf)) {
        RELEASE_DDSURF(ddsurf, "SurfacePool::Erase", this);
        _pool.erase(_i);
    }
}


bool SurfacePool::
Find(DDSurface *ddsurf)
{
    for(_i = _pool.begin(); _i != _pool.end(); _i++) {
        if( (*_i) == ddsurf ) {
            return true;
        }
    }
    return false;
}
    

// grabs a surface, erases it, and returns a ref to it.
void SurfacePool::
FindAndReleaseSizeCompatibleDDSurf(
    DDSurface *preferredSurf,      // Look for this surf first
    LONG width, LONG height,       // Surface Dimensions
    vidmem_enum vid,               // System or Video Memory
    LPDIRECTDRAWSURFACE surface,   // Specific Surface, or NULL for any
    DDSurface **outSurf)           // Addrefed surface we return
{
    DDSurface *surf = NULL;
    bool inSystemMemory = (vid == notVidmem);

    // borrow MY reference
    surf = GetSizeCompatibleDDSurf(preferredSurf,
                                   width, height, vid,
                                   surface);

    // loose MY reference
    if(surf) {   _pool.erase(_i);   }

    // pretend we just addreffed the client's copy, and
    // released our reference, ok ?

    // return a reference specially for the client
    *outSurf = surf;
}

inline bool
surfMatches(DDSurface *dds,
            LONG width,
            LONG height,
            bool inSysMem,
            LPDIRECTDRAWSURFACE surface)
{
    return
        (!surface || dds->IDDSurface() == surface) &&
        (dds->Width() == width) &&
        (dds->Height() == height) &&
        (dds->IsSystemMemory() == inSysMem);
}

// Returns a copy of my reference.  client is responsible
// for managing that reference responsibly.
DDSurface *SurfacePool::
GetSizeCompatibleDDSurf(
    DDSurface *preferredSurf,
    LONG width, LONG height,       // Surface Dimensions
    vidmem_enum vid,               // System or Video Memory
    LPDIRECTDRAWSURFACE surface)   // Specific Surface, or NULL for any
{
    DDSurface *surf = NULL;
    bool inSystemMemory = (vid == notVidmem);

    // can optimize: ddsurface->width() uses subraction... (not a big
    // deal)

    bool preferredOK = false;
    
    if (preferredSurf) {
        if (surfMatches(preferredSurf,
                        width, height,
                        inSystemMemory,
                        surface)) {

            // Implementation error if the preferredSurf isn't in the
            // pool:
            Assert(Find(preferredSurf));

            // Just mark that the preferred surface is OK... will
            // still need to get an iterator to it and stash that in
            // _i. 
            preferredOK = true;
        }
    }

    // Didn't match a preferredSurf.
    for (_i = _pool.begin(); _i != _pool.end(); _i++) {

        bool gotPreferred = 
            preferredOK && ((*_i) == preferredSurf);

        bool gotMatching =
            surfMatches((*_i),
                        width, height,
                        inSystemMemory,
                        surface);


        if (gotPreferred || gotMatching) {
            surf = *_i;
            break;
        }
    }

    // return a copy of my reference
    return surf;
}

void SurfacePool::
PopSurface(DDSurface **outSurf)
{
    Assert(outSurf);
    
    if(!IsEmpty()) {
        *outSurf = Back();
        PopBack();
    } else {
        *outSurf = NULL;
    }
}

SurfaceMap::SurfaceMap(SurfaceManager &mgr,
                       DDPIXELFORMAT &pf,
                       texture_enum isTx) :
         SurfaceCollection(mgr, pf),
         _isTexture(isTx)
{
    // add self to manager
    GetSurfaceManager().AddSurfaceMap(this);
}

SurfaceMap::~SurfaceMap()
{
    // Destroy all cached surfaces
    if( ! IsEmpty() ) {
        for(_i = _map.begin(); _i != _map.end(); _i++) {
            ReleaseCurrentEntry();
        }
    }
    
    GetSurfaceManager().RemoveSurfaceMap(this);
}
        

DDSurface *SurfaceMap::
LookupSurfaceFromImage(Image *image)
{
    _i = _map.find(image);
    
    if(_i != _map.end()) {
        return (*_i).second;
    }
    return NULL;
}

void SurfaceMap::
StashSurfaceUsingImage(Image *image, DDSurface *surf)
{
    DebugCode( _debugonly_doAsserts( surf ) );
    
    ADDREF_DDSURF(surf,
                  "SurfaceMap::StashSurfaceUsingImage",
                  this);
    _map[image] = surf;
}

void SurfaceMap::
DeleteMapEntry(Image *image)
{
    DDSurfPtr<DDSurface> surf = LookupSurfaceFromImage(image);                        
    if(surf) {
        ReleaseCurrentEntry();
        _map.erase(_i);
    }
}


void SurfaceMap::
DeleteImagesFromMap(bool skipmovies)
{
    SurfaceMap saveMap(GetSurfaceManager(), GetPixelFormat());
    
    for (_i=_map.begin(); _i != _map.end(); _i++)
    {
        if ((*_i).first->CheckImageTypeId(MOVIEIMAGE_VTYPEID) && skipmovies) {
            saveMap.StashSurfaceUsingImage((*_i).first, (*_i).second);
        } else {
            ReleaseCurrentEntry();
        }
    }

    _map.erase(_map.begin(), _map.end());

    for (_i=saveMap._map.begin();  _i != saveMap._map.end();  _i++) {
        this->StashSurfaceUsingImage((*_i).first, (*_i).second);
    }

    // saveMap destructor called here.  releases all surfaces
}

void SurfaceMap::
ReleaseCurrentEntry()
{
    Assert( _i != _map.end() );
    DDSurface *ddSurf = (*_i).second;
    Assert( ddSurf->debugonly_IsDdrawSurf() && "non ddsurf type in _imageTextureSurfaceMap");
    RELEASE_DDSURF(ddSurf,
                   "SurfaceMap::ReleaseCurrentEntry",
                   this);
}


CompositingStack::
CompositingStack(DirectDrawViewport &vp, SurfacePool &sp) :
      SurfacePool(sp.GetSurfaceManager(), sp.GetPixelFormat()),
      _viewport(vp),
      _freeSurfacePool(sp)
{
    #if _DEBUG
    _scratchDDSurface._reason = "_scratchSurface";
    _scratchDDSurface._client = this;
    #endif
}

CompositingStack::~CompositingStack()
{
    // I AM a surfacePool, and am associated with a surfaceManager, so
    // my super class will be destroyed and will do the right thing.
    // I only need to destroy my members that aren't references (for
    // example, I have a reference to _surfacePool.  
}

void CompositingStack::
GetSurfaceFromFreePool(
    DDSurface **outSurf,
    clear_enum   clr,
    INT32 minW, INT32 minH,
    scratch_enum scr,
    vidmem_enum  vid,
    except_enum  exc)
{
    // TODO: for now this delegates to the viewport, but in the
    // future, this class could own ddraw objects and creation.

    // TODO: shouldn't we be getting viewport from my surfacemanager ??

    // This call ends up calling the
    // SurfacePool::FindAndReleaseSizeCompatibleDDSurf() function to
    // do it's work.
    _viewport.GetDDSurfaceForCompositing(
        _freeSurfacePool,
        outSurf,
        minW, minH,
        clr, scr, vid, exc);
}

void CompositingStack::
PushCompositingSurface(
    clear_enum   clr,
    scratch_enum scr,
    vidmem_enum  vid,
    except_enum  exc)
{
    DDSurface *s;
    GetSurfaceFromFreePool(&s, clr, -1, -1, scr, vid, exc);
    PushTargetSurface( s );
    RELEASE_DDSURF(s, "CompositingStack::PushCompositingSurface", this);
}
        
void CompositingStack::
PopTargetSurface()
{
    RELEASE_DDSURF( Back(), "CompositingStack::PopTargetSurface()", this );
    PopBack();
}
    
    

DDSurface *CompositingStack::
ScratchDDSurface(
    clear_enum cl,
    INT32 minW, INT32 minH)
{
    if(!_scratchDDSurface ||
       ((_scratchDDSurface->Width() < minW) ||
        (_scratchDDSurface->Height() < minH))) {

        // TODO: Perhaps this class should manage surface creation too
        // take a ref.
        DDSurfPtr<DDSurface> newScratch;
        GetSurfaceFromFreePool(&newScratch,
                               doClear,
                               minW, minH,
                               scratch);

        // return it and replace it with the new one
        ReplaceAndReturnScratchSurface(newScratch);

        cl = dontClear;
    }
    if(cl == doClear) {
        _viewport.ClearDDSurfaceDefaultAndSetColorKey(_scratchDDSurface);
    }
    return _scratchDDSurface;
}


void CompositingStack::
ReplaceAndReturnScratchSurface(DDSurface *surface)
{
    if(_scratchDDSurface) {
        ReturnSurfaceToFreePool(_scratchDDSurface);
    }
    _scratchDDSurface = surface;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\treefunc.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    treefunc.cpp: Functions which control rendering on subtrees.
                  Most usefull for manipulating retained mode systems.

--*/


#include "headers.h"
#include <privinc/debug.h>
#include <privinc/storeobj.h>

extern "C" 
void StopTree(AxAValueObj *subTree, GenericDevice &dev)
{
    //dev.SetPath(AVPathCreate());  
    
    dev.SetRenderMode(STOP_MODE); // set the device's render mode to stop
    subTree->Render(dev);         // call render on the subTree
    
    // set the device's render mode to default RENDER_MODE
    // so that the existing entry points to render don't need to be
    // changed and set the render mode.
    dev.SetRenderMode(RENDER_MODE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\snddev.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Generic meta-device rendering device for Sounds, and C entrypoints for
    the ML.

*******************************************************************************/

#include "headers.h"
#include "privinc/debug.h"
#include "privinc/dsdev.h"
#include "privinc/util.h"
#include "privinc/except.h"
#include "privinc/storeobj.h"
#include "privinc/miscpref.h"
#include "privinc/bufferl.h"


///////////////  Sound Display  //////////////////////

MetaSoundDevice::MetaSoundDevice(HWND hwnd, Real latentsy) : 
    _fatalAudioState(false)
{
    extern miscPrefType miscPrefs; // registry struct setup in miscpref.cpp

    dsDevice = NULL;

    dsDevice = NEW DirectSoundDev(hwnd, latentsy);

    TraceTag((tagSoundDevLife, "MetaSoundDevice constructor"));
    ResetContext(); // setup the context
}

void
MetaSoundDevice::ResetContext()
{
    // initialize these
    _loopingHasBeenSet = FALSE;  // sound looping
    _currentLooping    = FALSE;  // no looping
    _currentGain       =   1.0;  // max gain
    _currentPan        =   0.0;  // center pan
    _currentRate       =   1.0;  // nominal rate
    _seek              =  -1.0;  // don't seek!

    GenericDevice::ResetContext(); // have to reset our parent's context, too
}


MetaSoundDevice::MetaSoundDevice(MetaSoundDevice *oldMetaDev)
{
    // manualy copy/setup.  XXX is there someway to binary copy?
    // XXX MAKE SURE ALL CHANGES IN MetaSoundDevice ARE REFLECTED HERE!

    dsDevice = oldMetaDev->dsDevice;

    // values to set, get, unset...
    _currentLooping    = oldMetaDev->_currentLooping;
    _loopingHasBeenSet = oldMetaDev->_loopingHasBeenSet;
    _currentGain       = oldMetaDev->_currentGain;
    _currentPan        = oldMetaDev->_currentPan;
}


MetaSoundDevice::~MetaSoundDevice()
{
    TraceTag((tagSoundDevLife, "MetaSoundDevice destructor"));

    dsDevice->RemoveSounds(this); // remove all sounds belonging to this device
    delete dsDevice;
}


void DisplaySound(Sound *snd, MetaSoundDevice *dev)
{
#ifdef _DEBUG
    if(IsTagEnabled(tagSoundStubALL))
        return;
#endif /* _DEBUG */

    TraceTag((tagSoundRenders, "displaySound()"));

    dev->ResetContext(); //reset the metaDev's device context for next rndr

    snd->Render(*dev);   // render sound tree
}


MetaSoundDevice *CreateSoundDevice(HWND hwnd, Real latency)
{
    TraceTag((tagSoundDevLife, "CreateSoundDevice()"));

    return NEW MetaSoundDevice(hwnd, latency);
}


extern void
DestroySoundDirectDev(MetaSoundDevice* impl)
{
    TraceTag((tagSoundDevLife, "DestroySoundDirectDev()"));

    delete impl; // then delete the devices...
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\guids\guids.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    This is the central location of external guid DEFINITIONS that
    for some reason, can't or aren't linked in.

*******************************************************************************/


#include <windows.h>
#define INITGUID
#include <initguid.h>  // needed for precomp headers...

#define IID_IDirectDrawSurface2 DA_IID_IDirectDrawSurface2
#define IID_IDirectDrawSurface DA_IID_IDirectDrawSurface

#include <dxtguid.c>

#define IUSEDDRAW
#include <ddraw.h>
#include <ddrawex.h>
#include <d3d.h>
#include <d3drm.h>
#include <d3drmvis.h>
#include <dxfile.h>

#ifdef BUILD_USING_CRRM
#include <crrm.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\headers.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Precompiled headers for appel.dll
*******************************************************************************/

#ifndef APPEL_HEADERS_HXX
#define APPEL_HEADERS_HXX

/*********** Headers from external dependencies *********/

/* Standard */
#include <math.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#ifndef _NO_CRT
#include <ios.h>
#include <fstream.h>
#include <iostream.h>
#include <ostream.h>
#include <strstrea.h>
#include <istream.h>
#include <ctype.h>
#include <sys/types.h>
#endif
#include <string.h>
#include <malloc.h>
#include <memory.h>
#include <wtypes.h>

// Warning 4786 (identifier was truncated to 255 chars in the browser
// info) can be safely disabled, as it only has to do with generation
// of browsing information.
#pragma warning(disable:4786)

// ATL - needs to be before windows.h
#include "privinc/dxmatl.h"

/* Windows */
#include <windows.h>
#include <windowsx.h>

// Disable some warning when including system files

#pragma warning(disable:4700) // Use of uninitialized variables

/* STL */
#include <algorithm>
#include <functional>
#include <iterator>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <vector>

#define list std::list
#define map std::map
#define multimap std::multimap
#define deque dont_use_deque_use_list_instead
#define stack std::stack
#define less std::less
#define vector std::vector
#define set std::set
#define multiset std::multiset

#pragma warning(default:4700) // Use of uninitialized variables

/* Sweeper */
#include <urlmon.h>
#include <wininet.h>
#include <servprov.h>
#include <docobj.h>
#include <objsafe.h>
#include <commctrl.h>

/* C++ Replace DLL */
#include <dalibc.h>

/**********  Appelles headers *********/
#include "daerror.h"

#include "../../apeldbg/apeldbg.h"
#include "appelles/common.h"
#include "appelles/avrtypes.h"
#include "backend/gc.h"
#include "privinc/storeobj.h"
#include "privinc/except.h"

#include "../../include/guids.h"
#include "../../include/dispids.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\guids\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H


#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\ctx\viewport.cpp ===
/*******************************************************************************
Copyright (c) 1996-1998 Microsoft Corporation.  All rights reserved.

    Implements the DirectDraw viewport class which contains all per window
ddraw information.

*******************************************************************************/

#include "headers.h"

#include <math.h>
#include <ddraw.h>
#include <ddrawex.h>
#include <htmlfilter.h>   // trident stuff

#include "appelles/hacks.h"
#include "appelles/bbox2.h"

#include "privinc/ddutil.h"
#include "privinc/imgdev.h"
#include "privinc/solidImg.h"
#include "privinc/dibimage.h"
#include "privinc/overimg.h"
#include "privinc/xform2i.h"
#include "privinc/bbox2i.h"
#include "appelles/text.h"
#include "privinc/texti.h"
#include "privinc/textctx.h"
#include "privinc/dddevice.h"
#include "privinc/viewport.h"
#include "privinc/ddrender.h"
#include "privinc/geomimg.h"
#include "privinc/debug.h"
#include "privinc/registry.h"
#include "privinc/except.h"
#include "privinc/util.h"
#include "privinc/d3dutil.h"
#include "privinc/resource.h"
#include "privinc/comutil.h"
#include <privinc/SurfaceManager.h>
#include <dxtrans.h>

//---------------------------------------------------------
// Local functions
//---------------------------------------------------------

// globals


bool g_preference_UseVideoMemory = false;

COLORREF g_preference_defaultColorKey = 0;
static HINSTANCE           hInstDDraw       = NULL;
static IDirectDrawFactory *g_surfFact       = NULL;
static CritSect           *DDrawCritSect    = NULL;
static bool                g_ddraw3Avail    = false;
static CritSect           *g_viewportListLock = NULL;

#define SHARE_DDRAW 0
#if SHARE_DDRAW
static IDirectDraw        *g_DirectDraw1    = NULL;
static IDirectDraw2       *g_DirectDraw2    = NULL;
static IDirectDraw3       *g_DirectDraw3    = NULL;
static IDDrawSurface      *g_primarySurface = NULL;
#endif


//
// Given at least one ddraw object, fills in the
// remaining ddraw objects using qi
//
void CompleteDdrawObjectSet(IDirectDraw  **directDraw1,
                            IDirectDraw2 **directDraw2,
                            IDirectDraw3 **directDraw3);


#if _DEBUG
void DrawRect(HDC dc, RECT *rect,
              int r, int g, int b,
              int a1, int a2, int a3)
{
    COLORREF c = RGB(r,g,b);
    HBRUSH brush = CreateSolidBrush(c);
    ::FrameRect(dc, rect, brush);
    DeleteObject(brush);
}

void DrawRect(DDSurface *surf, RECT *rect,
              int r, int g, int b,
              int a1, int a2, int a3)
{
    HDC dc = surf->GetDC("no dc for drawRec");
    COLORREF c = RGB(r,g,b);
    HBRUSH brush = CreateSolidBrush(c);

    HRGN oldrgn = NULL;
    GetClipRgn(dc, oldrgn);

    SelectClipRgn(dc, NULL);
    ::FrameRect(dc, rect, brush);

    SelectClipRgn(dc, oldrgn);
    DeleteObject(brush);
    surf->ReleaseDC("yeehaw");
}

void DrawRect(DDSurface *surf, const Bbox2 &bbox,
              int height, int width, Real res,
              int red, int g, int b)
{
    #define P2R(p,res) (Real(p) / res)

    RECT r;
     r.left = width/2 + P2R(bbox.min.x , res);
     r.right = width/2 + P2R(bbox.max.x , res);

     r.top = height/2 - P2R(bbox.max.y , res);
     r.bottom = height/2 - P2R(bbox.min.y , res);

    HDC dc = surf->GetDC("no dc for drawRec");
    COLORREF c = RGB(red,g,b);
    HBRUSH brush = CreateSolidBrush(c);
    ::FrameRect(dc, &r, brush);
    DeleteObject(brush);
    surf->ReleaseDC("yeehaw");
}
#endif

//---------------------------------------------------------
// Global viewport list management
//---------------------------------------------------------
typedef set< DirectDrawViewport *, less<DirectDrawViewport *> > ViewportSet_t;
ViewportSet_t g_viewportSet;

void GlobalViewportList_Add(DirectDrawViewport *vp)
{
    Assert(vp);
    CritSectGrabber csg(*g_viewportListLock);
    g_viewportSet.insert(vp);
}

void GlobalViewportList_Remove(DirectDrawViewport *vp)
{
    Assert(vp);
    CritSectGrabber csg(*g_viewportListLock);
    g_viewportSet.erase(vp);
}


//---------------------------------------------------------
// Local Helper functions
//---------------------------------------------------------
void CopyOrClearRect(RECT **src, RECT **dest, bool clear = TRUE);

// Includes IfErrorXXXX inline functions
#include "privinc/error.h"


static int LeastSigBit(DWORD dword)
{
    int s;
    for (s = 0; dword && !(dword & 1); s++, dword >>= 1);
    return s;
}

static int MostSigBit(DWORD dword)
{
    int s;
    for (s = 0; dword;  s++, dword >>= 1);
    return s;
}


void LogFontW2A(LPLOGFONTW plfW, LPLOGFONTA plfA)
{
    plfA->lfHeight          = plfW->lfHeight;
    plfA->lfWidth           = plfW->lfWidth;
    plfA->lfEscapement      = plfW->lfEscapement;
    plfA->lfOrientation     = plfW->lfOrientation;
    plfA->lfWeight          = plfW->lfWeight;
    plfA->lfItalic          = plfW->lfItalic;
    plfA->lfUnderline       = plfW->lfUnderline;
    plfA->lfStrikeOut       = plfW->lfStrikeOut;
    plfA->lfCharSet         = plfW->lfCharSet;
    plfA->lfOutPrecision    = plfW->lfOutPrecision;
    plfA->lfClipPrecision   = plfW->lfClipPrecision;
    plfA->lfQuality         = plfW->lfQuality;
    plfA->lfPitchAndFamily  = plfW->lfPitchAndFamily;
    WideCharToMultiByte(CP_ACP, 0, plfW->lfFaceName, LF_FACESIZE, plfA->lfFaceName, LF_FACESIZE, NULL, NULL);
}


void LogFontA2W(LPLOGFONTA plfA, LPLOGFONTW plfW)
{
    plfW->lfHeight          = plfA->lfHeight;
    plfW->lfWidth           = plfA->lfWidth;
    plfW->lfEscapement      = plfA->lfEscapement;
    plfW->lfOrientation     = plfA->lfOrientation;
    plfW->lfWeight          = plfA->lfWeight;
    plfW->lfItalic          = plfA->lfItalic;
    plfW->lfUnderline       = plfA->lfUnderline;
    plfW->lfStrikeOut       = plfA->lfStrikeOut;
    plfW->lfCharSet         = plfA->lfCharSet;
    plfW->lfOutPrecision    = plfA->lfOutPrecision;
    plfW->lfClipPrecision   = plfA->lfClipPrecision;
    plfW->lfQuality         = plfA->lfQuality;
    plfW->lfPitchAndFamily  = plfA->lfPitchAndFamily;
    MultiByteToWideChar(CP_ACP, 0, plfA->lfFaceName, LF_FACESIZE, plfW->lfFaceName, LF_FACESIZE);
}


int CALLBACK MyEnumFontFamProc(const LOGFONTA *plf, 
                               const TEXTMETRIC *ptm,
                               DWORD  dwFontType,
                               LPARAM lparam)
{
    LOGFONTA *plfOut = (LOGFONTA*)lparam;
    if (plfOut==NULL)
        return (int)(E_POINTER);

    memcpy(plfOut, plf, sizeof(LOGFONTA));
    return 0;
} // EnumFontFamCB


int MyEnumFontFamiliesEx(HDC hdcScreen, LPLOGFONTW plfIn, FONTENUMPROCA EnumFontFamProc, LPLOGFONTW plfOut)
{
    LOGFONTA lfInA;
    LOGFONTA lfOutA;

    //Work in ansi so that we can use one code path for both win9x and NT
    LogFontW2A(plfIn, &lfInA);
    int ret = EnumFontFamiliesExA(hdcScreen, &lfInA, EnumFontFamProc, (LPARAM)(&lfOutA), 0);
    plfOut->lfCharSet = lfOutA.lfCharSet;
    MultiByteToWideChar(CP_ACP, 0, lfOutA.lfFaceName, LF_FACESIZE, plfOut->lfFaceName, LF_FACESIZE);

    return ret;
}


// TODO: Do not call functions w/o completely initializing the object

DirectDrawViewport::DirectDrawViewport() :
    _heapIWasCreatedOn(GetHeapOnTopOfStack())
{
    // Clear all member data.


    _onDeathRow = false;
    _usingExternalDdraw = false;
    _opacityCompositionException = false;
    _tmpDev = 0;
    _directDraw  = 0;
    _directDraw1 = 0;
    _directDraw2 = 0;
    _directDraw3 = 0;
    _primSurface = 0;
    _primaryClipper = 0;
    _targetSurfaceClipper = NULL;
    _externalTargetDDSurface = NULL;
    _externalTargetDDSurfaceClipper = NULL;
    _oldExternalTargetDDSurfaceClipper = NULL;
    _finalDDpalette = NULL;
    _halftoneDDpalette = NULL;
    _halftoneHPal = NULL;
    _resolution = 0;
    _width = 0;
    _height = 0;
    _canDisplay = false;
    _canFinalBlit = false;
    _windowResize = 0;
    _deviceInitialized = FALSE;
    _defaultColorKey = 0;
    _currentImageDev = NULL;
    _targetPackage.Reset(false);
    _oldtargetPackage.Reset();

    _retreivedPrimaryPixelFormat = false;
    _targetPixelFormatIsSet = false;

    _surfaceManager = 0;
    _imageSurfaceMap = 0;
    _imageTextureSurfaceMap = 0;
    _imageUpsideDownTextureSurfaceMap = 0;
    _freeCompositingSurfaces = 0;
    _compositingStack = 0;
    _zbufferSurfaces = 0;
   
    _surfMgrSet = false;

    #if _DEBUG
    _externalTargetDDSurface._reason = "_externalTargetDDSurface";
    _externalTargetDDSurface._client = this;
    #endif    

    //
    // Add myself to the global viewport list last
    //
    GlobalViewportList_Add(this);
}

void DirectDrawViewport::
PostConstructorInitialize()
{
    //
    // Get an image renderer to use
    //
    _currentImageDev = PopImageDevice();
    Assert(_currentImageDev);

    // not used
    //_deviceDepth = BitsPerDisplayPixel();
    
    //
    // Get pixel format (needs to happen after we're sure we can
    // create ddraw object
    //
    if (!_retreivedPrimaryPixelFormat) {
        IDirectDrawSurface *primarySurf;
        IDirectDraw2 *ddraw2;
        if( SUCCEEDED( GetDirectDraw(NULL, &ddraw2, NULL) ) ){
            if( SUCCEEDED( GetPrimarySurface(ddraw2, NULL, &primarySurf) )) {
                _primaryPixelFormat.dwSize = sizeof(_primaryPixelFormat);
                if( SUCCEEDED(primarySurf->GetPixelFormat(&_primaryPixelFormat))){
                    _retreivedPrimaryPixelFormat = true;
                }
                primarySurf->Release();
            }
            ddraw2->Release();
        }
    }

    _resolution = ViewerResolution();

    _deviceInitialized = FALSE;

    //
    //
    //
    SetUpDx2D();

    //
    // Assert that NO directdraw objects are created
    //
    Assert( !_directDraw && !_directDraw1 &&
            !_directDraw2 && !_directDraw3 );
    
    InitializeDevice();  // if can init on startup, go for it.
}

void DirectDrawViewport::
SetUpSurfaceManagement( DDPIXELFORMAT &ddpf )
{
    //
    // Set up surface manager
    //
    _surfaceManager = NEW SurfaceManager(*this);
    
    //
    // Set up surface maps: owned by surfaceManager
    //
    _imageSurfaceMap = NEW SurfaceMap(*_surfaceManager, ddpf);
    _imageTextureSurfaceMap = NEW SurfaceMap(*_surfaceManager, ddpf, isTexture);
    _imageUpsideDownTextureSurfaceMap = NEW SurfaceMap(*_surfaceManager, ddpf, isTexture);

    //
    // Set up compositing surfaces pool: owned by surfaceManager
    //
    _freeCompositingSurfaces = NEW SurfacePool(*_surfaceManager, ddpf);

    //
    // Set up compositing stack: owned by surfaceManager too
    //
    _compositingStack = NEW CompositingStack(*this, *_freeCompositingSurfaces);

    //
    // Set up zbuffer surface pools: owned by surfaceManager
    //
    
    // TODO: set up pixel format for the zbuffers
    DDPIXELFORMAT zbuffPf;
    ZeroMemory( &zbuffPf, sizeof( DDPIXELFORMAT ));
    zbuffPf.dwSize = sizeof(DDPIXELFORMAT);
    zbuffPf.dwFlags = DDPF_ZBUFFER;
    zbuffPf.dwRGBBitCount = 16;
    zbuffPf.dwGBitMask = 0xffff;
    _zbufferSurfaces = NEW SurfacePool(*_surfaceManager, zbuffPf);


    #if _DEBUGSURFACE
    // allocate a surfaceTracker
    _debugonly_surfaceTracker = NEW SurfaceTracker();
    #endif

    _surfMgrSet = true;
}

void DirectDrawViewport::
SetUpDx2D()
{
    bool ok = false;
    _ddrval = ::CoCreateInstance( CLSID_DX2D, NULL, CLSCTX_INPROC,
                                  IID_IDX2D, (void **)&_dx2d );

    if( FAILED(_ddrval) ) {
        TraceTag((tagError, "Couldn't find Dx2D: continuing without antialising"));
        _dx2d = NULL;
        _IDXTransformFactory = NULL;
        _IDXSurfaceFactory = NULL;
        ok = true;
    } else {
        //--- Create the transform factory
        _ddrval = ::CoCreateInstance( CLSID_DXTransformFactory,
                                      NULL, CLSCTX_INPROC,
                                      IID_IDXTransformFactory,
                                      (void **)&_IDXTransformFactory );

        if( SUCCEEDED( _ddrval ) ) {
            _ddrval = _IDXTransformFactory->QueryInterface(IID_IDXSurfaceFactory, (void **)&_IDXSurfaceFactory);
            if( SUCCEEDED( _ddrval ) ) {
                _ddrval = _dx2d->SetTransformFactory( _IDXTransformFactory );
                if( SUCCEEDED( _ddrval ) ) {
                    ok = true;
                }
            }
        }
    }

    if( !ok ) {
        // this error isn't good.  what should we raise if we expect
        // to find the transform factory, but we don't ?
        RaiseException_ResourceError();
    }
}

void DirectDrawViewport::
InitializeDevice()
{
    if(_deviceInitialized) return;

    // Check for window size
    UpdateWindowMembers();
    if(Width() <= 0 || Height() <= 0) {
        _deviceInitialized = FALSE;
        // can't do it.
        return;
    }

    Assert(!_deviceInitialized);

    ConstructDdrawMembers();

#if _DEBUG
    if(_targetDescriptor._pixelFormat.dwFlags & DDPF_ZBUFFER) {
        _deviceInitialized = FALSE;

        Assert(FALSE && "Target Surface is a Zbuffer!!!");
        // can't do it.
        return;

    }
#endif

    //
    // Cache some info about pixel format
    //

    if( GetTargetBitDepth() == 8 ) {
        // Paletized
    } else {
        // not paletized

        _targetDescriptor._redShift = (CHAR)LeastSigBit(_targetDescriptor._pixelFormat.dwRBitMask);
        _targetDescriptor._greenShift = (CHAR)LeastSigBit(_targetDescriptor._pixelFormat.dwGBitMask);
        _targetDescriptor._blueShift = (CHAR)LeastSigBit(_targetDescriptor._pixelFormat.dwBBitMask);

        _targetDescriptor._redWidth = (CHAR)MostSigBit(_targetDescriptor._pixelFormat.dwRBitMask
                                                 >> _targetDescriptor._redShift);
        _targetDescriptor._greenWidth = (CHAR)MostSigBit(_targetDescriptor._pixelFormat.dwGBitMask
                                                 >> _targetDescriptor._greenShift);
        _targetDescriptor._blueWidth = (CHAR)MostSigBit(_targetDescriptor._pixelFormat.dwBBitMask
                                                 >> _targetDescriptor._blueShift);

        // Shift a 8bit value right to truncate
        _targetDescriptor._redTrunc   = 8 - _targetDescriptor._redWidth  ;
        _targetDescriptor._greenTrunc = 8 - _targetDescriptor._greenWidth;
        _targetDescriptor._blueTrunc  = 8 - _targetDescriptor._blueWidth ;

        // rgb value range: 0 to (2^n - 1)
        _targetDescriptor._red   = Real((1 << _targetDescriptor._redWidth) - 1);
        _targetDescriptor._green = Real((1 << _targetDescriptor._greenWidth) - 1);
        _targetDescriptor._blue  = Real((1 << _targetDescriptor._blueWidth) - 1);

        TraceTag((tagViewportInformative,
                  "Pixel Format: shift (%d, %d, %d)  width (%d, %d, %d)",
                  _targetDescriptor._redShift,
                  _targetDescriptor._greenShift,
                  _targetDescriptor._blueShift,
                  _targetDescriptor._redWidth,
                  _targetDescriptor._greenWidth,
                  _targetDescriptor._blueWidth));
    }

    _targetDescriptor.isReady = true;

    // MapColorToDWORD uses ddraw
    _defaultColorKey = MapColorToDWORD(g_preference_defaultColorKey);
    // remove alpha bit mask bits from the default color key
    _defaultColorKey &= ~_targetDescriptor._pixelFormat.dwRGBAlphaBitMask;
    
    TraceTag((tagViewportInformative,
              "Default color key is (%d, %d, %d)",
              GetRValue(g_preference_defaultColorKey),
              GetGValue(g_preference_defaultColorKey),
              GetBValue(g_preference_defaultColorKey) ));

    // Perform the initial clear on the viewport
    Clear();
    _deviceInitialized = TRUE;
}

void DirectDrawViewport::
DestroyTargetSurfaces()
{
    if (_compositingStack) {
        _compositingStack->ReleaseAndEmpty();
        _compositingStack->ReleaseScratch();
    }
}

void DirectDrawViewport::
DestroySizeDependentDDMembers()
{
    DestroyTargetSurfaces();
    DestroyCompositingSurfaces();
    DestroyZBufferSurfaces();
    RELEASE(_targetSurfaceClipper);
}


DirectDrawViewport::~DirectDrawViewport()
{
    //TIME_GDI( DeleteObject(_targetPackage._clipRgn) );

    // Destroy all devices on _deviceStack
    while(!_deviceStack.empty()) {
        delete PopImageDevice();
    }
    delete _currentImageDev;

    DestroyTargetSurfaces(); // deletes everything but the external
                             // compositing surface....
    delete _surfaceManager;
    
    //
    // Kill stuff associated with target trident surfaces
    //
    if(_targetPackage._targetDDSurf && _targetPackage.IsDdsurf()) {
        _targetPackage._targetDDSurf->DestroyGeomDevice();
        _targetPackage._targetDDSurf->IDDSurface()->SetClipper(NULL);
        if(_externalTargetDDSurfaceClipper) {
            _externalTargetDDSurfaceClipper->Release();
            _externalTargetDDSurfaceClipper = NULL;
        }
    }

    // As far as I can tell, DDRAW deletes attached clippers,
    // but not attached surfaces.

    FASTRELEASE(_targetSurfaceClipper);
    FASTRELEASE(_halftoneDDpalette);
    FASTRELEASE(_finalDDpalette);
    if(_halftoneHPal) {
        DeleteObject(_halftoneHPal);
    }
    
    //
    // delete targetPackage members
    //
    _targetPackage.Reset(true);

    FASTRELEASE(_primSurface);

    ReleaseIDirectDrawObjects();
    
    TraceTag((tagViewportInformative, ">>> Viewport Destructor <<<"));

    // Remove us from the global viewport list.  atomic
    GlobalViewportList_Remove(this);

    // _dx2d is a DAComPtr
}


void  DirectDrawViewport::
ClearSurface(DDSurface *dds, DWORD color, RECT *rect)
{
    if(!CanDisplay()) return;

    // not really necessary to clear this every frame.
    ZeroMemory(&_bltFx, sizeof(_bltFx));
    _bltFx.dwSize = sizeof(_bltFx);

    _bltFx.dwFillColor = color;

    // Workaround for DX3 bug: ddraw limits the Blt to the size of the primary
    // surface if Clipper is set.  This looks bad when the offscreen surface
    // is bigger than the primary surface.
    // The workaround: Set the Clipper to NULL before the Blt, then set it back
    // to what it was.
    // Begin workaround part 1
    LPDIRECTDRAWCLIPPER currClipp=NULL;
    _ddrval = dds->IDDSurface()->GetClipper( &currClipp );
    if(_ddrval != DD_OK &&
       _ddrval != DDERR_NOCLIPPERATTACHED) {
        IfDDErrorInternal(_ddrval, "Could not get clipper on trident surf");
    }

    if( currClipp ) {
        _ddrval = dds->IDDSurface()->SetClipper(NULL);
        IfDDErrorInternal(_ddrval, "Couldn't set clipper to NULL");
    }
    // End workaround part 1

    TIME_DDRAW(_ddrval = dds->ColorFillBlt(rect, DDBLT_WAIT | DDBLT_COLORFILL, &_bltFx));
    IfDDErrorInternal(_ddrval, "Couldn't clear surface");

    // Begin workaround part 2
    if( currClipp ) {
        _ddrval = dds->IDDSurface()->SetClipper(currClipp);

        // dump our reference.
        currClipp->Release();

        IfDDErrorInternal(_ddrval, "Couldn't set clipper");
    }
    // End workaround part 2
}

void
DirectDrawViewport::UpdateWindowMembers()
{
    #if _DEBUG
    if(!IsWindowless()) {
        Assert(_targetPackage._targetHWND);
        Assert(_targetPackage._prcViewport);
    }
    #endif

    //
    // Use _prcViewport
    //
    LONG  lw=0, lh=0;
    if(_targetPackage._prcViewport) {

        lw = WIDTH(_targetPackage._prcViewport);
        lh = HEIGHT(_targetPackage._prcViewport);
    }
    SetRect(&_clientRect, 0,0,lw,lh);

    SetHeight(lh);  SetWidth(lw);
    UpdateTargetBbox();
    TraceTag((tagViewportInformative, "Updating viewport window size to: %d, %d", Width(), Height()));
}


IDDrawSurface      * DirectDrawViewport::GetMyPrimarySurface()
{
    if( !IsWindowless() ) {
        if (_primSurface == NULL) {
            _ddrval = GetPrimarySurface(_directDraw2, _directDraw3, &_primSurface);
            IfDDErrorInternal(_ddrval, "Could not get primary surface");
        }
    }

    return _primSurface;
}

void DirectDrawViewport::
ReleaseIDirectDrawObjects()
{
    _directDraw = NULL; // XXX: this should be addreffed
    RELEASE( _directDraw1 );
    RELEASE( _directDraw2 );
    RELEASE( _directDraw3 );
}

void
DirectDrawViewport::ConstructDdrawMembers()
{
    //----------------------------------------------------------------------
    // Initialize Window size and client rect
    //----------------------------------------------------------------------
    UpdateWindowMembers();
    if(Height() <=0 || Width() <=0) {
        _canDisplay = false;
        if(!IsWindowless()) return;
    } else {
        _canDisplay = true;
    }

    //----------------------------------------------------------------------
    // Create main DirectDraw object
    //----------------------------------------------------------------------

    if(!_directDraw1 && !_directDraw2 && !_directDraw3) {
        _ddrval = GetDirectDraw( &_directDraw1, &_directDraw2, &_directDraw3 );
        IfDDErrorInternal(_ddrval, "Viewport:ConstructDdrawMembers:: Could not get a DirectDraw object");
    }

    TraceTag((tagViewportInformative,
              "Viewport ddraws:  ddraw1 %x,   ddraw2 %x,   ddraw3 %x\n",
              _directDraw1, _directDraw2, _directDraw3));

    #if SHARE_DDRAW
    #if _DEBUG
    {
        //
        // If one of our objects is the same as the global object,
        // assert that all are the same.  If it's different, assert
        // that all are different
        //
        CritSectGrabber csg(*DDrawCritSect);
        if(_directDraw1 == g_DirectDraw1) {
            Assert(_directDraw2 == g_DirectDraw2);
            if(_directDraw3 && g_DirectDraw3) Assert(_directDraw3 == g_DirectDraw3);
        } else {
            Assert(_directDraw1 != g_DirectDraw1);
            Assert(_directDraw2 != g_DirectDraw2);
            if(_directDraw3 && g_DirectDraw3) Assert(_directDraw3 != g_DirectDraw3);
        }
    }
    #endif
    #endif

    _ddrval = DIRECTDRAW->SetCooperativeLevel( _targetPackage._targetHWND, DDSCL_NORMAL );
    // TEMP
    //_ddrval = DIRECTDRAW->SetCooperativeLevel( NULL, DDSCL_NORMAL );
    IfDDErrorInternal(_ddrval, "Could not set cooperative level");

    //----------------------------------------------------------------------
    // Create the DD primary and target surfaces
    //----------------------------------------------------------------------

    if( !IsWindowless() ) {

        _targetPackage._targetType = target_hwnd;

        // create a clipper for the primary surface
        _ddrval = DIRECTDRAW->CreateClipper( 0, &_primaryClipper, NULL );
        IfDDErrorInternal(_ddrval, "Could not create primary clipper");

        Assert(_targetPackage._targetHWND);

        _ddrval = _primaryClipper->SetHWnd( 0, _targetPackage._targetHWND );
        IfDDErrorInternal(_ddrval, "Could not set hwnd on primary clipper");
    }

    //----------------------------------------------------------------------
    // Create and initialize target surface clipper, palette, and ZBuffer.
    // Push one target surface on _targetSurfaceStack.
    //----------------------------------------------------------------------

    OneTimeDDrawMemberInitialization();

    CreateSizeDependentTargDDMembers();

    //----------------------------------------------------------------------
    // Get the pixel format data from primarySurface
    //----------------------------------------------------------------------
    _targetDescriptor.Reset();
    _targetDescriptor._pixelFormat.dwSize = sizeof(DDPIXELFORMAT);

    _ddrval = _compositingStack->TargetDDSurface()->IDDSurface()->GetPixelFormat(& _targetDescriptor._pixelFormat);
    IfDDErrorInternal(_ddrval, "Could not get pixel format");

#if _DEBUG
    if(_targetDescriptor._pixelFormat.dwFlags & DDPF_ZBUFFER) {
          _deviceInitialized = FALSE;

          Assert(FALSE && "Target Surface has Zbuffer PixFmt!!!");
          // can't do it.
          return;
  
      }
#endif


    DebugCode(
        if(_targetDescriptor._pixelFormat.dwFlags & DDPF_PALETTEINDEXED8) {
            Assert( GetTargetBitDepth() == 8 );
        }
        );

    TraceTag((tagViewportInformative,
              "Device pixel format: depth=%d, R=%x, G=%x, B=%x",
              _targetDescriptor._pixelFormat.dwRGBBitCount,
              _targetDescriptor._pixelFormat.dwRBitMask,
              _targetDescriptor._pixelFormat.dwGBitMask,
              _targetDescriptor._pixelFormat.dwBBitMask));
    
    //----------------------------------------------------------------------
    // Assert if the primary surface does not have a palette attached.
    //----------------------------------------------------------------------
#if _DEBUG
    // TODO: the real assert here should be: are we rendering to
    // primary ?  if so, does it have a palette attached ?  if not,
    // can we decide which one to attach ?
    if(0 ) {
        LPDIRECTDRAWPALETTE pal = NULL;
        if(GetMyPrimarySurface() != NULL) {
            GetMyPrimarySurface()->GetPalette(&pal);
            if(pal == NULL)
                TraceTag((tagError, "primary surface w/o attatched pallete"));
            else
                pal->Release();
        }
    }
#endif
}

//---------------------------------------------------------
// P O P   I M A G E   D E V I C E
//---------------------------------------------------------
DirectDrawImageDevice *
DirectDrawViewport::PopImageDevice()
{
    if(_deviceStack.empty()) {
        _tmpDev = NEW DirectDrawImageDevice(*this);
    } else {
        _tmpDev = _deviceStack.back();
        _deviceStack.pop_back();

        // clear device's context before returning it.
        _tmpDev->ResetContextMembers();
    }
    return _tmpDev;
}

//---------------------------------------------------------
// P U S H   I M A G E   D E V I C E
//---------------------------------------------------------
void
DirectDrawViewport::PushImageDevice(DirectDrawImageDevice *dev)
{
    // Clean up device and return to its place...
    dev->CleanupIntermediateRenderer();
    
    _deviceStack.push_back(dev);
}


//---------------------------------------------------------
// M A K E   L O G I C A L   F O N T
//---------------------------------------------------------
// Based on information in textCtx and the familyName (if any)
// pick and create the most appropriate font, returned as
// a pointer to a logical font structure.
void DirectDrawViewport::
MakeLogicalFont(
    TextCtx &textCtx,
    LPLOGFONTW lf,
    LONG width,
    LONG height)
{
    BYTE win32PitchAndFamily;
    WideString familyName;
    HDC hdcScreen = GetDC(NULL);

    // Zero it out just to be safe
    ZeroMemory(lf,sizeof(LOGFONTW));

    // Initialize to "no-care". We might restrict this later.
    lf->lfCharSet = DEFAULT_CHARSET;

    //Set the facename and character set if it is specified
    familyName = textCtx.GetFontFamily();
    if (familyName && (lstrlenW(familyName) < ARRAY_SIZE(lf->lfFaceName)))
    {
        Assert((lstrlenW(familyName) < ARRAY_SIZE(lf->lfFaceName)) &&
               "familyName string toooo long!");
        StrCpyNW(lf->lfFaceName, familyName, ARRAY_SIZE(lf->lfFaceName));

        // Character set remains no-care. EnumFontFamiliesEx will pick an arbitrary character set from 
        // the ones this face name supports
    }
    else
    {
        // The face name is not specified. Use the current character set of the DC and let EnumFontFamiliesEx
        // pick any facename that supports this character set
        if(hdcScreen)
            lf->lfCharSet = (BYTE) GetTextCharset(hdcScreen);

        // Character set remains no-care.
    }


    //Set the font family if it is specified
    win32PitchAndFamily = FF_DONTCARE;
    switch(textCtx.GetFont()) {
    default:
    case ff_serifProportional:
        win32PitchAndFamily = FF_ROMAN | VARIABLE_PITCH;  //serifProportional
        break;
    case ff_sansSerifProportional:
        win32PitchAndFamily = FF_SWISS | VARIABLE_PITCH;  //sansSerifProportional
        break;
    case ff_monospaced:
        win32PitchAndFamily = FF_MODERN | FIXED_PITCH;  //serif or sans Monospaced
        break;
    }
    lf->lfPitchAndFamily = win32PitchAndFamily;

    // negative height specifies that we want the CHARACTER to be that
    // height, and not the glyph.
    lf->lfHeight         = height;
    lf->lfWidth          = 0;

    lf->lfEscapement     = 0;
    lf->lfOrientation    = 0;

    // If bold is set, use the bold face, otherwise use whatever is
    // specified by the weight (normalized 0 to 1).  Special case 0,
    // since a weight of 0 is interpeted by GDI as FW_REGULAR.
    // Multiply by 1000 and clamp since GDI takes values between 0 and
    // 1000.

    int weight = (int)(textCtx.GetWeight() * 1000.0);
    weight = CLAMP(weight, 1, 1000);
    if (textCtx.GetBold()) {
        weight = FW_BOLD;
    }

    lf->lfWeight         = weight;
    lf->lfItalic         = (UCHAR)textCtx.GetItalic();
    lf->lfUnderline      = (UCHAR)textCtx.GetUnderline();
    lf->lfStrikeOut      = (UCHAR)textCtx.GetStrikethrough();
    lf->lfOutPrecision   = OUT_TT_ONLY_PRECIS;  // Match only TT fonts, even if another family
    lf->lfClipPrecision  = CLIP_DEFAULT_PRECIS; // clipping precision, not used.
//    lf->lfQuality        = DRAFT_QUALITY;       // font quality: only meaningful for raster fonts
    lf->lfQuality        = PROOF_QUALITY;       // font quality: only meaningful for raster fonts
    lf->lfPitchAndFamily = win32PitchAndFamily; // font pitch & family: set above.


    // Now that all fields of interest in the logfont are filled in, choose a font on the system that is closest
    // to lf. Both the input and output of EnumFontFamiliesEx is lf. Our callback simply overwrites lf.
    MyEnumFontFamiliesEx(hdcScreen, lf, MyEnumFontFamProc, lf);

    if (hdcScreen)
        ReleaseDC(NULL,hdcScreen);

    return; //void
}


// If surface exists it releases the surface.
// Creates a new surface of size width/height
// with clipRect for cliplist on surface.
void DirectDrawViewport::ReInitializeSurface(
    LPDDRAWSURFACE *surfPtrPtr,
    DDPIXELFORMAT &pf,
    LPDIRECTDRAWCLIPPER *clipperPtr,
    LONG width,
    LONG height,
    RECT *clipRect,
    vidmem_enum vid,
    except_enum exc)
{
    DDSURFACEDESC       ddsd;
    ZeroMemory(&ddsd, sizeof(ddsd));

    if(*surfPtrPtr) {
        int ret = (*surfPtrPtr)->Release();
        Assert((ret == 0) && "We wanted to release the surface but someone has a ref to it!");
    }

    CreateOffscreenSurface(surfPtrPtr, pf, width, height, vid, exc);

    // Don't do this if there is no clipper or clip rect
    if (*surfPtrPtr && (clipRect && clipperPtr)) {
        // passing a null pointer to CreateClipper is bad
        CreateClipper(clipperPtr);
        
        SetCliplistOnSurface(*surfPtrPtr, clipperPtr, clipRect);
    }
}



void DirectDrawViewport::CreateSizedDDSurface(DDSurface **ppSurf,
                                              DDPIXELFORMAT &pf,
                                              LONG width,
                                              LONG height,
                                              RECT *clipRect,
                                              vidmem_enum vid)
{
    Assert( ppSurf );

    *ppSurf = NULL;             // in case of failure.
    
    DAComPtr<IDDrawSurface> iddSurf;
    ReInitializeSurface( &iddSurf, pf, NULL,
                         width, height, clipRect,
                         vid, noExcept);

    // Just stash away null and get out if failed.
    if( iddSurf ) {
        RECT r = {0,0,width,height};
        NEWDDSURF( ppSurf,
                   iddSurf,
                   NullBbox2,
                   &r,
                   GetResolution(),
                   0, false, // clr key
                   false,    // wrapper ?
                   false,    // texture ?
                   "CreateSizeDDSurface" );
    }
}

void DirectDrawViewport::
CreateClipper(LPDIRECTDRAWCLIPPER *clipperPtr)
{
    if(*clipperPtr) return;

    _ddrval = DIRECTDRAW->CreateClipper( 0, clipperPtr, NULL );
    IfDDErrorInternal(_ddrval, "Could not create clipper");
}

void DirectDrawViewport::
SetCliplistOnSurface(LPDDRAWSURFACE surface,
                     LPDIRECTDRAWCLIPPER *clipper,
                     RECT *rect)
{
    
    if(rect) {
        struct {
            char foo[sizeof(RGNDATA) + sizeof(RECT)];
        } bar;
        RGNDATA *clipList = (RGNDATA *) &bar;
        clipList->rdh.dwSize = sizeof(clipList->rdh);
        clipList->rdh.nCount = 1;
        clipList->rdh.iType = RDH_RECTANGLES;
        clipList->rdh.nRgnSize = sizeof(RECT);
        clipList->rdh.rcBound = *rect;
        memcpy(&(clipList->Buffer), rect, sizeof(RECT));

        if(! (*clipper) ) CreateClipper( clipper );
        // Clear any former cliplists
        _ddrval = (*clipper)->SetClipList(NULL,0);

        _ddrval = (*clipper)->SetClipList(clipList,0);
        IfDDErrorInternal(_ddrval, "Could not SetClipList");

    } // if rect

    Assert(clipper && "clipper is NULL in SetCliplistOnSurface");
    Assert((*clipper) && " *clipper is NULL SetCliplistOnSurface");

    _ddrval = surface->SetClipper( *clipper );
    IfDDErrorInternal(_ddrval, "Could not setClipper on surf");
    
}

HRESULT DirectDrawViewport::MyCreateSurface(LPDDSURFACEDESC lpDesc,
                        LPDIRECTDRAWSURFACE FAR * lplpSurf,
                        IUnknown FAR *pUnk
                        #if _DEBUG
                            , char *why
                        #endif
                        )
{
    if( sysInfo.IsNT() ) {
        // These are the limits Jeff Noyle suggested for nt4, sp3
        if((lpDesc->dwWidth > 2048 || lpDesc->dwHeight > 2048)) {
            *lplpSurf = NULL;
            return E_FAIL;
        }
    }
    
    HRESULT hr = DIRECTDRAW->CreateSurface(lpDesc, lplpSurf, pUnk);
    if(FAILED(hr)) {
        DebugCode(
            printDDError( hr );
            OutputDebugString("Unable to create ddraw surf.  Falling back...");
        );
        return hr;
    }

    // We need to ensure that we can acutally blit on the surface.
    // For this lets make a quick check to see if we are able to bit or not.

    if ((*lplpSurf)->GetBltStatus(DDGBS_CANBLT) == DDERR_SURFACEBUSY) {
        RaiseException_UserError 
            (DAERR_VIEW_SURFACE_BUSY, IDS_ERR_IMG_SURFACE_BUSY);
    }

    TraceTag((tagViewportMemory,
          "-->New ddsurf: %x (%d x %d), ddraw %x. %s",
          *lplpSurf, lpDesc->dwWidth, lpDesc->dwHeight, DIRECTDRAW, why));

    
    if (!(lpDesc->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE || lpDesc->dwFlags & DDSD_ZBUFFERBITDEPTH)) {
        if (lpDesc->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8 ||
            (lpDesc->ddpfPixelFormat.dwSize == 0 && GetTargetBitDepth() == 8)) {
            LPDIRECTDRAWPALETTE pal;
            (*lplpSurf)->GetPalette(&pal);
            // if we have a palette, do not attach another...
            if (pal) {
                Assert(0);
                pal->Release();
            }
            else {
               AttachCurrentPalette(*lplpSurf);
            }
        }
    }

    return hr;
}

void DirectDrawViewport::
CreateOffscreenSurface(LPDDRAWSURFACE *surfPtrPtr,
                       DDPIXELFORMAT &pf,
                       LONG width, LONG height,
                       vidmem_enum vid,
                       except_enum exc)                
{
    DDSURFACEDESC       ddsd;
    ZeroMemory(&ddsd, sizeof(ddsd));

    Assert( &pf != NULL );
    
    ddsd.dwSize = sizeof( ddsd );
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
    ddsd.dwWidth  = width;
    ddsd.dwHeight = height;
    ddsd.dwFlags |= DDSD_PIXELFORMAT;
    ddsd.ddpfPixelFormat = pf;

    // DX3 bug workaround (bug 11166): StretchBlt doesn't always work
    // for hdc's we get from ddraw surfaces.  Need to specify OWNDC
    // in order for it to work.
    ddsd.ddsCaps.dwCaps =
        DDSCAPS_3DDEVICE |
        DDSCAPS_OFFSCREENPLAIN |
#if USING_DX5
        (vid == vidmem ? DDSCAPS_VIDEOMEMORY : DDSCAPS_SYSTEMMEMORY);
#else
        (vid == vidmem ? DDSCAPS_VIDEOMEMORY : DDSCAPS_SYSTEMMEMORY | DDSCAPS_OWNDC);
#endif

    _ddrval = CREATESURF( &ddsd, surfPtrPtr, NULL, "Offscreen");

    if (FAILED(_ddrval)) {
        if (exc == except) {
            IfDDErrorInternal(_ddrval, "Could not create an offsreenPlain surface");
        } else {
            *surfPtrPtr = NULL;
        }
    }
}

void DirectDrawViewport::
CreateSpecialSurface(LPDDRAWSURFACE *surfPtrPtr,
                     LPDDSURFACEDESC ddsd,
                     char *errStr)
{
    // For now only the first compositing surface will every be in video memory,
    // all else resides in system memory.

    ddsd->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

    _ddrval = CREATESURF( ddsd, surfPtrPtr, NULL, "Special" );
    IfDDErrorInternal(_ddrval, errStr);
}



/*****************************************************************************
This procedure attaches a zbuffer surface to the given target as needed.
*****************************************************************************/

HRESULT DirectDrawViewport::AttachZBuffer (DDSurface *target, except_enum exc)
{
    Assert (target);

    // Query to see if the surface already has an attached Z-buffer.  If it
    // doesn't have an attached Z-buffer surface, then we expect the return
    // code DDERR_NOTFOUND.

    DAComPtr<IDDrawSurface> zbuffSurf;

    static DDSCAPS caps = { DDSCAPS_ZBUFFER };
    _ddrval = target->IDDSurface()->GetAttachedSurface (&caps, &zbuffSurf);
    if (FAILED(_ddrval) && (_ddrval != DDERR_NOTFOUND)) {
        if (exc == except)
            IfDDErrorInternal (_ddrval, "GetAttachedSurface(ZBUFFER) failed.");
        else
            return _ddrval;
    }
#if _DEBUG
    // INVARIANT: there MUST be a zbuffer (as a DDSurface) associated with
    // the target AND that zbuffer MUST be in the _zbufferSurface pool

    // check that our datat structures match what ddraw thinks
    DDSurface* targetZBuffer = target->GetZBuffer();
    if ( (zbuffSurf && targetZBuffer) ||
         (!zbuffSurf && !targetZBuffer) ) {
        // now make sure they are the same IDirectDrawSurface
        if(targetZBuffer) {
            Assert( zbuffSurf == target->GetZBuffer()->IDDSurface() );

            // Now it also must be in the ZBuffer pool!
            DDSurface* foo;
            foo = _zbufferSurfaces->GetSizeCompatibleDDSurf(
                    NULL,
                    target->Width(),
                    target->Height(),
                    target->IsSystemMemory() ? notVidmem : vidmem,
                    zbuffSurf);
            
            Assert( foo == targetZBuffer );
        }
    } else {

        // this is actually not bad when you have two controls on one
        // page, they share the same surface, so one control attaches
        // the zbuffer, and the second should just be able to use it.
        #if 0
        // bad... one has a surface, one doesn't
        if( zbuffSurf ) {
            Assert(0 && "target has an IDDSurface attached, but not a DDSurface");
        } else {
            Assert(0 && "target has a DDSurface attached, but not an IDDSurface");
        }
        #endif
    }
#endif

    // if there is already a zbuffer attached, return, we are done.
    if (zbuffSurf)
        return NO_ERROR;

    // Search through our list of DDSurface Zbuffers for entries that match
    // both the surface dimensions, and the found Z-buffer surface (if one
    // exists).

    DDSurfPtr<DDSurface> zbuff =
        _zbufferSurfaces->GetSizeCompatibleDDSurf(
            NULL,
            target->Width(),
            target->Height(),
            target->IsSystemMemory() ? notVidmem : vidmem,
            zbuffSurf
            );


    // If we didn't find a matching DDSurface Z-buffer, we need to create one.

    if(! zbuff ) {

        // If we didn't find a Z-buffer that matches, so we create it here.

        DDSURFACEDESC ddsd;
        ZeroMemory(&ddsd, sizeof(DDSURFACEDESC));

        ddsd.dwSize = sizeof(DDSURFACEDESC);
        ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS | DDSD_ZBUFFERBITDEPTH;
        ddsd.dwHeight = target->Height();
        ddsd.dwWidth =  target->Width();
        ddsd.dwZBufferBitDepth = 16;
        ddsd.ddsCaps.dwCaps = target->IsSystemMemory()
                            ? (DDSCAPS_ZBUFFER | DDSCAPS_SYSTEMMEMORY)
                            : (DDSCAPS_ZBUFFER | DDSCAPS_VIDEOMEMORY);

        _ddrval = CREATESURF(&ddsd, &zbuffSurf, NULL, "ZBuffer");
        
        if (FAILED(_ddrval)) {
            if (exc == except)
                IfDDErrorInternal
                    (_ddrval,"CreateSurface for window Z-buffer failed.");
            else
                return _ddrval;
        }


        // Now that we've got a DirectDraw zbuffer, we need to create a new
        // DDSurface that wraps it.

        RECT rect = {0,0, target->Width(), target->Height() };

        NEWDDSURF(&zbuff,
                  zbuffSurf,
                  NullBbox2, &rect,
                  GetResolution(),
                  0, false,
                  false, false,
                  "ZBuffer");

        // Add the new zbuffer DDSurface to the list of zbuffer objects.
        AddZBufferDDSurface( zbuff );
    }
    #if _DEBUG
      else {
        LONG hz, wz, hs, ws;
        // make sure zbuffer and surface are the same size
        GetSurfaceSize(zbuff->IDDSurface(), &wz, &hz);
        GetSurfaceSize(target->IDDSurface(), &ws, &hs);
        Assert((wz == ws) && (hz == hs) &&
               "AttachZBuffer: zbuffer/target dimensions differ");
    }
    #endif

    // set the zbuffer on the surface
    _ddrval = target->SetZBuffer( zbuff );
    if (FAILED(_ddrval)) {
        if (exc == except)
            IfDDErrorInternal
                (_ddrval, "AddAttachedBuffer failed for Z-buffer.");
        else
            return _ddrval;
    }

    return NO_ERROR;

    // zBuffSurf implicit Release() on exit
    // zbuff DDSurfPtr implicit Release() on exit
}



/*****************************************************************************
This routine attaches the halftone palette to the given surface.  The palette
is needed for D3D rendering or for discrete image conversion.
*****************************************************************************/

void DirectDrawViewport::AttachCurrentPalette (LPDDRAWSURFACE surface, bool bUsingXforms)
{
    if (GetTargetBitDepth() == 8)
    {
        if(bUsingXforms || !AttachFinalPalette(surface))
            SetPaletteOnSurface (surface, GethalftoneDDpalette());
    }
}

bool DirectDrawViewport::AttachFinalPalette(LPDDRAWSURFACE surface)
{
    if(IsNT5Windowed())
    {
        if(!_finalDDpalette) {
            BYTE  rgbytes[ sizeof(LOGPALETTE) + 
                            (255 * sizeof(PALETTEENTRY)) ];
            LOGPALETTE * pLogPal = reinterpret_cast<LOGPALETTE *>(rgbytes);

            memset( &rgbytes[0], 0, sizeof(rgbytes) );
            pLogPal->palVersion = 0x300;
            pLogPal->palNumEntries = 256;

            HDC hdc = GetDC(_targetPackage._targetHWND);
            if(hdc) 
            {
                GetSystemPaletteEntries(hdc,0u,256u,pLogPal->palPalEntry);
                ReleaseDC(_targetPackage._targetHWND,hdc);
                CreateDDPaletteWithEntries(&_finalDDpalette,pLogPal->palPalEntry);
            }
            else 
            {
               return false;
            }
        }
        SetPaletteOnSurface(surface,_finalDDpalette);
 
        return true;
    }
    return false;   // didn't attach the palette.
}



DWORD
DirectDrawViewport::MapColorToDWORD(Color *color)
{
    Assert(_targetDescriptor.isReady && "_targetDescriptor not ready in MapColorToDWORD");

    DWORD retColor = 0;

    if( GetTargetBitDepth() == 8 ) {

        //
        // Use GDI
        //
        COLORREF colorRef = RGB(CHAR(255.0 * color->red),
                                CHAR(255.0 * color->green),
                               CHAR(255.0 * color->blue));
        retColor = (DWORD)GetNearestPaletteIndex(GethalftoneHPal(), colorRef);

    } else {

        //
        // build the color dword
        //
        // NOTE: this mapping is optimal, mapping the 'from' color
        // space evenly into the 'to' color space.
        retColor = _targetDescriptor.GetPixelFormat().dwRGBAlphaBitMask |
            ( LONG((0.999 + _targetDescriptor._red)   * (color->red))   << _targetDescriptor._redShift)   |
            ( LONG((0.999 + _targetDescriptor._green) * (color->green)) << _targetDescriptor._greenShift) |
            ( LONG((0.999 + _targetDescriptor._blue)  * (color->blue))  << _targetDescriptor._blueShift);
    }

    return retColor;
}


DWORD
DirectDrawViewport::MapColorToDWORD(COLORREF colorRef)
{
    Assert(_targetDescriptor.isReady && "_targetDescriptor not ready in MapColorToDWORD");

    DWORD retColor = 0;

    if( GetTargetBitDepth() == 8 ) {
        
        //
        // Use GDI
        //
        
        retColor = (DWORD)GetNearestPaletteIndex(GethalftoneHPal(), colorRef);
        
    } else {

#define R(w) ( ((w) << _targetDescriptor._redShift  ) & _targetDescriptor._pixelFormat.dwRBitMask)
#define G(w) ( ((w) << _targetDescriptor._greenShift) & _targetDescriptor._pixelFormat.dwGBitMask)
#define B(w) ( ((w) << _targetDescriptor._blueShift ) & _targetDescriptor._pixelFormat.dwBBitMask)

       //
       // build the color dword
       //
       retColor = _targetDescriptor._pixelFormat.dwRGBAlphaBitMask |
           R( GetRValue(colorRef) >> _targetDescriptor._redTrunc   ) |
           G( GetGValue(colorRef) >> _targetDescriptor._greenTrunc ) |
           B( GetBValue(colorRef) >> _targetDescriptor._blueTrunc  ) ;

#undef R
#undef G
#undef B
   }

    return retColor;
}


/*
    // Herf claims this takes 10 cycles instead of 50 (ftol()== bad!)
     __asm
    {
    fld x
    fistp ret
    }
    */


inline BYTE contToByte(Real mxRng, Real contVal)
{
    return  (BYTE)(  (mxRng + 0.9999) * contVal );
}

DXSAMPLE MapColorToDXSAMPLE(Color *c, Real opac)
{
    return DXSAMPLE( contToByte( 255.0, opac ),
                     contToByte( 255.0, c->red ),
                     contToByte( 255.0, c->green ),
                     contToByte( 255.0, c->blue ) );
}

/*
// This is the way D3DRM does it
inline BYTE contToByte2(Real mxRng, Real contVal)
{
    return  (BYTE)( mxRng * contVal + 0.5 );
}

// Uncomment if we need it in the future.  probably wont becuase we'll
// be using dx2d fulltime, but just in case
COLORREF MapColorToCOLORREF( Color *c, TargetDescriptor &td )
{
    BYTE r = contToByte( 255.0, c->red);
    BYTE g = contToByte( 255.0, c->green );
    BYTE b = contToByte( 255.0, c->blue ) ;
    COLORREF ref = RGB( r, g, b );
    return ref;
}*/


#if _DEBUG
void RaiseSomeException()
{
    if (IsTagEnabled(tagFail_InternalError)) {
        RaiseException_InternalError("fooo!");
    }
    if (IsTagEnabled(tagFail_InternalErrorCode)) {
        RaiseException_InternalErrorCode(false, "fooo!");
    }
    if (IsTagEnabled(tagFail_UserError)) {
        RaiseException_UserError();
    }
    if (IsTagEnabled(tagFail_UserError1)) {
        RaiseException_UserError(E_FAIL,
                                 IDS_ERR_FILE_NOT_FOUND,
                                 "http://foo!");
    }
    if (IsTagEnabled(tagFail_UserError2)) {
        RaiseException_UserError(
            E_FAIL,
            IDS_ERR_FILE_NOT_FOUND,
            "http://foo!");
    }
    if (IsTagEnabled(tagFail_ResourceError)) {
        RaiseException_ResourceError();
    }
    if (IsTagEnabled(tagFail_ResourceError1)) {
        RaiseException_ResourceError("out of fooo!");
    }
    if (IsTagEnabled(tagFail_ResourceError2)) {
        RaiseException_ResourceError(
            IDS_ERR_FILE_NOT_FOUND, "out of fooo!");
    }
    if (IsTagEnabled(tagFail_StackFault)) {
        RaiseException_StackFault();
    }
    if (IsTagEnabled(tagFail_DividebyZero)) {
        RaiseException_DivideByZero();}
    if (IsTagEnabled(tagFail_OutOfMemory)) {
        RaiseException_OutOfMemory("out of fooomem!", 100);
    }
}
#endif

#if 0
#if _DEBUGMEM
// globals
_CrtMemState diff, oldState, newState;
#endif
#endif

//
// Top level, single threaded rendering function for a view
//
void
DirectDrawViewport::RenderImage(Image *image, DirtyRectState &d)
{
    Assert(_currentImageDev);

    if( _targetPackage._prcClip ) {
        if( (WIDTH(  _targetPackage._prcClip ) == 0) ||
            (HEIGHT( _targetPackage._prcClip ) == 0) ) {
            return;
        }
    }
        
    DirectDrawImageDevice *dev = _currentImageDev;

    dev->SetSurfaceSources(_compositingStack,
                           _freeCompositingSurfaces,
                           _imageSurfaceMap);

    
    //
    // Snapshot heap state
    //
    #if 0
    #if _DEBUGMEM
    _CrtMemCheckpoint(&oldState);
    #endif
    #endif

    // If someone is rendering an image tree without and overlayed
    // node at the top, we need to add one to leverage the overlayed
    // node's rendering logic, and also for correctness.  
    // Specifically, the overlayed node is the only node that can
    // handle opacity, by design.

    // optimization opportunity

    // Ok, here I'm setting the image's opacity on the overlayed
    // node and subtracting it from the image.  This is so that
    // the whole overlayed node gets rendered with alpha ONTO the
    // screen as the final compositing surface!
    Real finalOpacity = image->GetOpacity();

    //
    // Don't render if it's fully clear
    //
    if( ! dev->IsFullyClear( finalOpacity ) ) {
      
      #if 0
      // check surface map sizes
      OutputDebugString("----> IMAGE SURFACE MAP <----");
      if(_imageSurfaceMap) _imageSurfaceMap->Report();
      OutputDebugString("----> COMPOSITING SURFACES <----");
      if(_freeCompositingSurfaces)_freeCompositingSurfaces->Report();
      #endif

        //
        // this line causes flashing because the opacity
        // is effectively lost if this is a regular image (not
        // overlayed), and we're windowed: since the final
        // blit doesn't look at opacity at all.
        // ... but the problem is, taking it out causes
        // curvey windowless to show cyan when it's getting clear
        // because it does alpha blits onto a cleared surface (cyan as
        // the color key) and then does alpha again onto the dest surf
        //
        image->SetOpacity(1.0);
        
        Image *stubImage = NEW OverlayedImage(image, emptyImage);

        BeginRendering( finalOpacity );
        
        if( ! IsTargetViable() ) return;

        dev->BeginRendering(stubImage, finalOpacity);

        //if( ! CanDisplay() ) return;
        
        // Simply display by calling the device's RenderImage() method.
        // The device will then choose the appropriate method on the
        // subclass of Image to call, based upon the type of device
        // it is.  Note that this is trying to simulate double dispatching
        // with a single dispatch language (C++)

        DebugCode(
            RaiseSomeException();
            );

        dev->RenderImage(stubImage);
        
        //
        // Set opacity now, so it has effect on final blit
        // but NOT on any intermediate blits (before final)
        //

        dev->SetOpacity(finalOpacity);
        
        dev->EndRendering(d);
        
        image->SetOpacity(finalOpacity);
        
        dev->SetOpacity(1.0);

    }
    
    #if 0
    #if _DEBUGMEM
    _CrtMemCheckpoint(&newState);
    _CrtMemDifference(&diff, &oldState, &newState);
    _CrtMemDumpStatistics(&diff);
    _CrtMemDumpAllObjectsSince(&oldState);
    #endif
    #endif
}

void
DirectDrawViewport::BeginRendering(Real topLevelOpac)
{
    // make sure device is initialized if it can be
    InitializeDevice();

    if( _targetPackage._composeToTarget ) {
        // Set a global clipRgn on the DC
        //GetClipRgn(_targetPackage._dcFromSurf, _targetPackage._oldClipRgn);
        //SelectClipRgn(_targetPackage._dcFromSurf,  _targetPackage._clipRgn);
    }

    if(!_deviceInitialized) return;

    if(_currentImageDev->IsFullyClear(topLevelOpac)) return;

    // TODO: figure out the windowless control case...
    if( !IsWindowless() ) {
        if(GetMyPrimarySurface()->IsLost() == DDERR_SURFACELOST) {
            TraceTag((tagError, "Surfaces Lost... marking views for destruction"));

            {
                // stops viewport creation or destruction
                CritSectGrabber csg1(*g_viewportListLock);

                // stops anyone from trying to create or
                // release any ddraw resources
                CritSectGrabber csg2(*DDrawCritSect);

                // Turn on when there's a global shared ddraw object again
                #if 0
                    //
                    // release the global primary because it's dependant on bitdepth
                    // Release it first!
                    //
                    TraceTag((tagViewportInformative, ">>>> ReleasePrimarySurface <<<<<"));

                    RELEASE(g_primarySurface);
                    RELEASE(g_DirectDraw1);
                    RELEASE(g_DirectDraw2);
                    RELEASE(g_DirectDraw3);
                #endif

                //
                // All other vidmem surface are most likely lost
                // do the thing and rebuild the
                // universe.  So mark all the viewports for destruction
                //

                set< DirectDrawViewport *, less<DirectDrawViewport *> >::iterator i;
                for (i = g_viewportSet.begin(); i != g_viewportSet.end(); i++) {
                    (*i)->Stop();
                    (*i)->MarkForDestruction();
                }

                // Locks released on scope exit
            }

            // done!
            return;
        }
    } // is windowless


    //
    // Turns off rendering if viewport is empty
    //
    if( IsWindowless() ) {
        if( WIDTH(_targetPackage._prcViewport) <= 0 ||
            HEIGHT(_targetPackage._prcViewport) <= 0) {
            _canDisplay = false;
            _canFinalBlit = false;
        } else {
            _canDisplay = true;
            _canFinalBlit = true;
        }
    }

    if(_windowResize) {

        UpdateWindowMembers();
        TraceTag((tagViewportInformative, "WINMSG: Resize: new viewport dimentions for hwnd=%x (%d,%d)",
                  _targetPackage._targetHWND, Width(), Height()));

        if( !IsWindowless() ) {
            RECT tmpRect;// = {0,0,0,0};
            GetClientRect(_targetPackage._targetHWND, &tmpRect);
            if((WIDTH(&tmpRect) > 0) && (HEIGHT(&tmpRect) > 0)) {
                _canFinalBlit = true;
            } else {
                _canFinalBlit = false;
            }
        }

        // xxx: what if it is windowless, has the viewport been
        // xxx: updated somewhere ?

        if(Width() <= 0 || Height() <= 0) {
            _canDisplay = false;
        } else {
            // XXX: -----------------------------------------------------
            // XXX: the right solution is to have all the image devices
            // XXX: on the stack and just delete them all.  ONE class
            // XXX: must be the owner, it can't be both.
            // Kill all the image devices we own
            while(!_deviceStack.empty()) {
                delete PopImageDevice();
            }
            // XXX: need to delete geom devices inside the DDSurface structs..
            // XXX: delete the surface ? and force them to delete the devices.
            // XXX: -----------------------------------------------------

            //
            // Kills all surfaces: target, scratch, compositing
            //
            DestroySizeDependentDDMembers();

            #if 0
            {
                #if DEBUGMEM
                static _CrtMemState diff, oldState, newState;
                _CrtMemCheckpoint(&oldState);
                #endif

                CreateSizeDependentTargDDMembers();
                DestroySizeDependentDDMembers();

                #if DEBUGMEM
                _CrtMemCheckpoint(&newState);
                _CrtMemDifference(&diff, &oldState, &newState);
                _CrtMemDumpStatistics(&diff);
                _CrtMemDumpAllObjectsSince(&oldState);
                #endif
            }
            #endif

            //
            // Pushes a target surface, creates zbuffer
            // and clipper
            //
            CreateSizeDependentTargDDMembers();

            _canDisplay = true;
        }
        Clear();
        _windowResize = false;
    }


    if(!_canDisplay) return;

    if((_targetPackage.IsDdsurf() ||
        _targetPackage.IsHdc()) &&
       !IsCompositeDirectly() &&
       _canDisplay) {
        Assert(IsWindowless());

        Clear();
    }

    if( _targetPackage._composeToTarget ) {

        //
        // Grab the current clipper on the target surface
        // and save it off, then restore it later (end
        // rendering)
        //
        {
            // nt4 ddraw sp3 workaround
            {
                RECT clipR = *_targetPackage._prcViewport;
                if(_targetPackage._prcClip) {
                    IntersectRect(&clipR, &clipR, _targetPackage._prcClip);
                }

                Assert( _targetPackage._targetDDSurf );
                Assert( _targetPackage._prcViewport );

                // due to an nt4 ddraw bug, we're goign to reset the
                // clip rgn, not the clipper

                // Get current clipper.
                // modify rgn
                // release our reference
                LPDIRECTDRAWCLIPPER currClipp=NULL;
                _ddrval = _targetPackage._targetDDSurf->IDDSurface()->GetClipper( &currClipp );
                if(_ddrval != DD_OK &&
                   _ddrval != DDERR_NOCLIPPERATTACHED) {
                    IfDDErrorInternal(_ddrval, "Could not get clipper on trident surf");
                }

                if( !currClipp ) {

                    // So we create a clipper that everyone's going to
                    // muck with... and when we're done, we'll release
                    // our reference.  an imperfect system I know.
                    // Assert(!_externalTargetDDSurfaceClipper);
                    SetCliplistOnSurface(_targetPackage._targetDDSurf->IDDSurface(),
                                         &_externalTargetDDSurfaceClipper,
                                         &clipR);
                } else {
                    RECT *rect = &clipR;

                    // modify the rect
                    struct {
                        char foo[sizeof(RGNDATA) + sizeof(RECT)];
                    } bar;
                    RGNDATA *clipList = (RGNDATA *) &bar;
                    clipList->rdh.dwSize = sizeof(clipList->rdh);
                    clipList->rdh.nCount = 1;
                    clipList->rdh.iType = RDH_RECTANGLES;
                    clipList->rdh.nRgnSize = sizeof(RECT);
                    clipList->rdh.rcBound = *rect;
                    memcpy(&(clipList->Buffer), rect, sizeof(RECT));

                    // Clear any former cliplists
                    _ddrval = currClipp->SetClipList(NULL,0);

                    // Set clip list on the clipper
                    _ddrval = currClipp->SetClipList(clipList,0);
                    IfDDErrorInternal(_ddrval, "Could not SetClipList");

                    // dump our reference.
                    currClipp->Release();
                }

            } // workaround
        } // clipper stuff scope

        //
        // You know, there should be a better way to do this
        // why aren't we doing alpha directly to the target ??
        // Anyway, this is good for now.
        //
        if(! _currentImageDev->IsFullyOpaque(topLevelOpac)) {
            //
            // top level nontrivial opacity means
            // that we can't compose directly to target
            // like we planned.  so push a target
            // surface ontop of the compositing surface
            // and set a flag
            //
            if(_opacityCompositionException) {
                // make sure a target surface is here
                // and clear it.
                Assert( _compositingStack->Size() == 2 );
                Clear();
            } else {
                Assert( _compositingStack->Size() == 1 );
                _compositingStack->PushCompositingSurface(doClear, notScratch);
                _opacityCompositionException = true;
            }
        } else {
            //
            // Ok, let's check to see if we need to
            // undo something we did last frame...
            //
            if(_opacityCompositionException) {
                //
                // turn this off
                //
                _opacityCompositionException = false;

                Assert( _compositingStack->Size() <= 2);
                Assert( _compositingStack->Size() >= 1);

                if( _compositingStack->Size() == 2) {
                    //
                    // Pop extra comp surface
                    //
                    _compositingStack->ReturnSurfaceToFreePool( _compositingStack->TargetDDSurface() );
                    _compositingStack->PopTargetSurface();
                } else {
                    // the surface must have been released
                    // due to a resize. regardless we're ok.
                }
            } else {
                Assert( _compositingStack->Size() == 1);
            }
        }
    } // if composeToTarget
}

void
DirectDrawViewport::Clear()
{
    if(_targetPackage._composeToTarget &&
       (_externalTargetDDSurface == _compositingStack->TargetDDSurface())) {
        // don't clear it if we're compositing directly to it!
        return;
    } else {
        ClearSurface(_compositingStack->TargetDDSurface(), _defaultColorKey, &_clientRect);
    }
}

#if _DEBUG          

static void
MyDoBits16(LPDDRAWSURFACE surf16,
           LONG width, LONG height)
{

    static int counter = 0;
    counter++;
    counter = counter % 150;
    
    HRESULT hr;
        //
        // Lock (16bpp) ddsurface  (SRC)
        //
        void *srcp;
        long pitch;
        DDSURFACEDESC srcDesc;
        srcDesc.dwSize = sizeof(DDSURFACEDESC);
        hr = surf16->Lock(NULL, &srcDesc, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
        IfDDErrorInternal(hr, "Can't Get ddsurf lock for DoBits16");
        srcp = srcDesc.lpSurface;
        pitch = srcDesc.lPitch;

        WORD *src; 
        for(int i=0; i<height; i++) {
            src = (WORD *) ((BYTE *)srcp + (pitch * i));
        
            for(int j=0; j<width; j++) {
                *src = (WORD) (i * width + j * (counter+1));
                src++;
            }
        }

        surf16->Unlock(srcp);
}

#endif


bool 
DirectDrawViewport::GetPixelFormatFromTargetPackage(targetPackage_t *targetStruct,DDPIXELFORMAT &targPf) 
{
    memset(&targPf, 0, sizeof(targPf));
    targPf.dwSize = sizeof(targPf);
    
    if( targetStruct->GetTargetType() == target_ddsurf ) {

        if( ! targetStruct->GetIDDSurface() ) return false;
        
        //
        // Get pixel format
        //
        if (FAILED(targetStruct->GetIDDSurface()->GetPixelFormat(&targPf))) {
            return false;
        }
        _targetDepth = targPf.dwRGBBitCount;
        
    } else if (targetStruct->GetTargetType() == target_hdc ||
               targetStruct->GetTargetType() == target_hwnd) {

        // TODO: primary format will work on dcs, but we could do
        // better to avoid a color convert.
        
        //
        // Get primary pixel format
        //
        Assert( _retreivedPrimaryPixelFormat );

        targPf = _primaryPixelFormat;
        _targetDepth = targPf.dwRGBBitCount;

    } else {
        Assert(0 && "bad target");
    }
    return true;
}


bool DirectDrawViewport::
SetTargetPackage(targetPackage_t *targetStruct)
{
    // This simply checks to see if we're being asked to render to a
    // ddsurface that is a different bit depth than our target bit depth.  If
    // so, we substitute in a different surface, and, after we're
    // done, we blit to it.
    DDPIXELFORMAT targPf;

    if(!GetPixelFormatFromTargetPackage(targetStruct, targPf))
        return false;

     if( !_targetPixelFormatIsSet ) {
            
        //------------------------------
        // Since DirectDraw does not support
        // 1, 2 or 4-bit per pixel modes, throw a resource error if needed.
        //------------------------------
        if (GetTargetBitDepth() < 8)
            RaiseException_ResourceError (IDS_ERR_IMG_BAD_BITDEPTH, 1 << GetTargetBitDepth());
        // sanity check
        DebugCode(
            if( (GetTargetBitDepth() == 8) ||
                (targPf.dwFlags & DDPF_PALETTEINDEXED8) ) {
                Assert( (GetTargetBitDepth() == 8) &&
                        (targPf.dwFlags & DDPF_PALETTEINDEXED8) );
            }
            );
     
        _targetPixelFormatIsSet = true;

        //
        // This happens once!
        //
        Assert( !_surfaceManager &&
                !_compositingStack &&
                !_freeCompositingSurfaces &&
                !_imageSurfaceMap );
        
        SetUpSurfaceManagement( targPf );
        _currentImageDev->SetSurfaceSources(_compositingStack,
                                            _freeCompositingSurfaces,
                                            _imageSurfaceMap);

    }
/*    DebugCode(
        else {
            // Assert that the format hasn't changed on us!
            if( targetStruct->_targetType == target_ddsurf ) {
                DDPIXELFORMAT pf;
                pf.dwSize = sizeof(pf);
                if (FAILED(targetStruct->GetIDDSurface()->GetPixelFormat(&pf))) {
                    // oh well it's just an assert...
                } else {
                    Assert(_freeCompositingSurfaces->IsSamePixelFormat( &pf ));
                }
            }
        }
        ); // end DebugCode
 */
    bool result = ReallySetTargetPackage(targetStruct);

    return result;
}

bool DirectDrawViewport::
ReallySetTargetPackage(targetPackage_t *targetStruct)
{
    // Check bit depth and if it's 8bpp turn off composite directly to
    // target.
    if (GetTargetBitDepth() == 8) {
        // don't compose directly to target for 8-bit surfaces
        // this is because d3d has sticky palettes
        targetStruct->SetComposeToTarget(false);
    }
    
    // xxx
    // in the future we might want to pay attention to
    // prcInvalid... although there are currently no ctrls
    // that just render to and ibms without going through
    // a dc...

    _canFinalBlit = true;

    _targetPackage._targetType = targetStruct->GetTargetType();

    void *relevantSurf = NULL;
    switch( _targetPackage._targetType ) {

      case target_ddsurf:
        TraceTag((tagViewportInformative, ">>>> SetTargetPackage, target_ddsurf <<<<<\n"));
        relevantSurf = (void *) targetStruct->GetIDDSurface();
        _targetPackage._composeToTarget = targetStruct->GetComposeToTarget();

        {
            #if SHARE_DDRAW
            #if _DEBUG
            {
                // make sure that if we own a ddraw object
                // that it's different than the global object
                CritSectGrabber csg(*DDrawCritSect);
                if(_directDraw1) {
                    Assert(_directDraw1 != g_DirectDraw1);
                }
            }
            #endif
            #endif

            if (!_directDraw1) {
                Assert (!IsInitialized() && "Can't set target ddsurf on"
                        && " an initialized device because it already"
                        && " has a ddraw object");

                IDirectDraw *lpDD = NULL;
                IDirectDrawSurface2 *dds = NULL;
                dds = DDSurf1to2(targetStruct->GetIDDSurface());
                _ddrval = dds->GetDDInterface((void **) &lpDD);
                IfDDErrorInternal(_ddrval, "Can't get DirectDraw object from target surface");
                dds->Release();

                // @@@@@
                _directDraw = _directDraw1 = lpDD;
                _directDraw1->AddRef();
                CompleteDdrawObjectSet(&_directDraw1, &_directDraw2, &_directDraw3);

                // release the qi reference
                lpDD->Release();

                _usingExternalDdraw = true;
            }

            {
            DebugCode(
                IUnknown *lpDDIUnk = NULL;
                TraceTag((tagDirectDrawObject, "Viewport (%x) ::SetTargetPackage...", this));
                DDObjFromSurface( targetStruct->GetIDDSurface(), &lpDDIUnk, true);
                
                Assert( lpDDIUnk );

                IUnknown *currentDD = NULL;
                _directDraw1->QueryInterface(IID_IUnknown, (void **)&currentDD);
                Assert( currentDD );
                          
                Assert((currentDD == lpDDIUnk) &&
                       "Viewport::SetTargetPackage: underlying ddraw object mismatch!");

                RELEASE( currentDD );
                RELEASE( lpDDIUnk );
                );
            }
                
        }
        
        _targetPackage._alreadyOffset = targetStruct->GetAlreadyOffset();

        break;

      case target_hdc:
        relevantSurf = (void *) targetStruct->GetHDC();
        break;

      case target_hwnd:
        relevantSurf = (void *) targetStruct->GetHWND();
        break;

      default:
        Assert(FALSE && "Bad target in SetTargetPackage");
    }

    if(!relevantSurf) {
        _canDisplay = false;
        return false;
    }

    bool viewportChanged = false;
    // TODO: Danny - I added the check for targetStruct->_prcViewport
    // since it was NULL sometimes (under IE3.02) and so we would
    // crash in the below comparison.
    if(_targetPackage._prcViewport &&
       targetStruct->IsValid_ViewportRect()) {
        if( !(::EqualRect(_targetPackage._prcViewport,
                          &targetStruct->GetViewportRect()))){
            viewportChanged = true;
        }
    } else {
        // new viewport means: it's changed!
        viewportChanged = true;
    }


    //
    // if a rectangle is defined in targetStruct, allocate our own
    // and copy it.  If not, deallocate what we have, and set it to NULL
    //
    {
        if( targetStruct->IsValid_ViewportRect() ) {
            if(! _targetPackage._prcViewport ) {
                _targetPackage._prcViewport = NEW RECT;
            }
            *(_targetPackage._prcViewport) = targetStruct->GetViewportRect();
        }

        if( targetStruct->IsValid_ClipRect() ) {
            if(! _targetPackage._prcClip ) {
                _targetPackage._prcClip = NEW RECT;
            }
            *(_targetPackage._prcClip) = targetStruct->GetClipRect();
        } else {
            delete _targetPackage._prcClip;
            _targetPackage._prcClip = NULL;
        }
    

        if( targetStruct->IsValid_InvalidRect() ) {
            if(! _targetPackage._prcInvalid ) {
                _targetPackage._prcInvalid = NEW RECT;
            }
            *(_targetPackage._prcInvalid) = targetStruct->GetInvalidRect();
        } else {
            delete _targetPackage._prcInvalid;
            _targetPackage._prcInvalid = NULL;
        }
    }    


    RECT r, *surfRect = &r;
    LONG h, w;

    //
    // Find the full surface size:  surfRect
    //
    switch( _targetPackage._targetType ) {

      case target_hwnd:
        Assert(targetStruct->GetHWND());

        // target hwnd is retained... so if it's not null
        // it should be the same
        if(!_targetPackage._targetHWND) {
            _targetPackage._targetHWND = targetStruct->GetHWND();
        } else {
            Assert(_targetPackage._targetHWND == targetStruct->GetHWND());
        }


        //
        // override given viewport (if any) with clientRect
        //
        if(!_targetPackage._prcViewport) {
            RECT * r = new RECT;
            //ZeroMemory(r, sizeof(RECT));

            GetClientRect(targetStruct->GetHWND(), r);

            if((WIDTH(r) == 0) || (HEIGHT(r) == 0)) {
                // we can't display at all....
                _canFinalBlit = false;

                //
                // Make sure we have something valid for viewport w/h
                //
                SetRect(r, 0,0, 3,3);
            }

            _targetPackage._prcViewport = r;
        }

        {
            POINT pt={0,0};
            ClientToScreen(targetStruct->GetHWND(), &pt );
            OffsetRect(_targetPackage._prcViewport, pt.x, pt.y);
            _targetPackage._offsetPt = pt;
        }

        // not setting surfRect on ddsurf, not meaningful

        break;

      case target_ddsurf:
        {
            GetSurfaceSize((IDDrawSurface *)relevantSurf, &w, &h);
            SetRect(surfRect, 0, 0, w, h);
        }
        break;

      case target_hdc:
        // Assert(FALSE && "find hdc size or asser that viewport is set");
        // what does size mean for a dc ?
        
        //
        // override given viewport (if any) with clientRect
        //
        if(!_targetPackage._prcViewport) 
        {
            RECT * r = NEW RECT;
            //ZeroMemory(r, sizeof(RECT));

            GetClipBox(targetStruct->GetHDC(), r);

            if((WIDTH(r) == 0) || (HEIGHT(r) == 0)) 
            {
                // we can't display at all....
                _canFinalBlit = false;

                //
                // Make sure we have something valid for viewport w/h
                //
                SetRect(r, 0,0, 3,3);
            }

            _targetPackage._prcViewport = r;
        }
        break;

      default:
        break;
    }

    _targetPackage._offsetPt.x = 0;
    _targetPackage._offsetPt.y = 0;
    if(_targetPackage._prcViewport) {
        _targetPackage._offsetPt.x = _targetPackage._prcViewport->left;
        _targetPackage._offsetPt.y = _targetPackage._prcViewport->top;
    } else {
        _targetPackage._prcViewport = new RECT;
        CopyRect(_targetPackage._prcViewport, surfRect);
        // we're assuming that surf rect offset is 0
        Assert(surfRect->left == 0);
        Assert(surfRect->top == 0);
    }

    Bool newTarget = FALSE;
    if( IsWindowless() ) {

        if( _targetPackage.IsDdsurf() && !_targetPackage._targetDDSurf ) {

            // scope
            {
                // The surface rect is the true size of this surface
                // and differs from the _prcViewport which is where
                // on that surface that we should draw.
                DynamicHeapPusher dhp(_heapIWasCreatedOn);
                NEWDDSURF(&_targetPackage._targetDDSurf,
                          (IDDrawSurface *)relevantSurf,
                          NullBbox2,
                          surfRect,
                          GetResolution(),
                          0, false,
                          true, // wrapper
                          false,
                          "TargetDDSurf wrapper");
                
                // @@@: consider removing the "isWrapper" arg now that
                // we're ref counting surfaces...
                
                viewportChanged = true; // force bbox computation
            }           


            //
            // compose directly to target ?
            //
            if(_targetPackage._composeToTarget) {
                Assert( _targetPackage.IsDdsurf() );
                Assert(!_externalTargetDDSurface);
                //
                // Ok, push this surface on the viewport's
                // targetDDSurface stack
                //
                _externalTargetDDSurface = _targetPackage._targetDDSurf;
                
                // sanity checks...
                Assert(( _compositingStack->Size() == 0 ) &&
                       "Something's on the targetsurface " &&
                       "stack but shouldn't be in SetTargetPackage, composeToTarget");
                Assert(_targetPackage._prcViewport);
            }

            newTarget = TRUE;
            
        } else if(_targetPackage.IsHdc() && !_targetPackage._targetGDISurf ) {

            DynamicHeapPusher dhp(_heapIWasCreatedOn);
            _targetPackage._targetGDISurf = NEW GDISurface( (HDC) relevantSurf );

            viewportChanged = true; // force bbox computation
            newTarget = true;

        }

        //
        // Set genericSurface
        //
        GenericSurface *genericSurface = NULL;
        switch( _targetPackage._targetType ) {
          case target_ddsurf:
            genericSurface = _targetPackage._targetDDSurf;
            break;
            
          case target_hdc:
            genericSurface = _targetPackage._targetGDISurf;
            break;
            
          default:
            break;
        }
        
        bool isDdrawSurf = true;
        if( !_targetPackage.IsDdsurf() ) {
             isDdrawSurf = false;
        }

        // has the surface rectangle changed ?
        // If so we need to recreate all the stuff that depends on it:
        // geometry devices + zbuffers
        bool rectChanged = true;
        if( isDdrawSurf ) {
            if( *surfRect == *(_targetPackage._targetDDSurf->GetSurfRect()) ) {
                rectChanged = false;
            }
        }

        bool surfChanged = false;

        if( relevantSurf != genericSurface->GetSurfacePtr() )  {
            surfChanged = true;
            genericSurface->SetSurfacePtr(relevantSurf);
        }

        if( (rectChanged || surfChanged) && isDdrawSurf) {

            // Not equal: destroy geom dev + zbuffer
            _targetPackage._targetDDSurf->DestroyGeomDevice();

            // zbuffers are shared in in a pool, so get it and
            // erase from surface pool (map)
            DDSurface *targZBuf = NULL;
            targZBuf = _targetPackage._targetDDSurf->GetZBuffer();
            if(targZBuf) {
                _zbufferSurfaces->Erase(targZBuf);
            }
            _targetPackage._targetDDSurf->SetZBuffer(NULL);
            _targetPackage._targetDDSurf->SetSurfRect(surfRect);

        }

        if( viewportChanged && isDdrawSurf ) {
            // calculate a new bbox and set it on the surface!
            RECT *r = _targetPackage._prcViewport;
            Bbox2 newBbox2;

            RectToBbox( WIDTH(r),
                        HEIGHT(r),
                        newBbox2,
                        GetResolution());
            _targetPackage._targetDDSurf->SetBbox(newBbox2);
        }

        // Translate the world by the offset homes!
        if(_targetPackage._composeToTarget) {

            Assert(isDdrawSurf && "Can't compose to target on non ddraw targets!");
            
            if(_targetPackage._offsetPt.x || _targetPackage._offsetPt.y) {
                TraceTag((tagViewportInformative, "VP %x: setting offset (%d,%d)\n",
                          this,_targetPackage._offsetPt.x,
                          _targetPackage._offsetPt.y));
                _currentImageDev->SetOffset(_targetPackage._offsetPt);
            } else {
                // very important!
                // also important not to touch this offset variable in
                // the image device because it can be called to render
                // twice or so, but the state is always and only set
                // by the viewport!
                TraceTag((tagViewportInformative, "VP %x: UNSETTING offset (%d,%d)\n",
                          this,_targetPackage._offsetPt.x,
                          _targetPackage._offsetPt.y));

                _currentImageDev->UnsetOffset();
            }
        }

    } // if IsWindowless


    if(newTarget) {
        _canDisplay = true;
        _windowResize = true;
    } else {
        LONG w = Width(),  h = Height();
        UpdateWindowMembers();  // updates height/width from viewportRect

        // did the width or height change ?
        if((w != Width()) || (h != Height())) {
            _windowResize = TRUE;
        }
        _canDisplay = true;
    }

    //
    // if something new has happened, take advantage
    // of it and initialize everything.
    //
    InitializeDevice();

    return true;
}


void
DirectDrawViewport::EndRendering(DirtyRectState &d)
{
    HDC  hdcDraw        = NULL;
    HPALETTE old_hpal   = NULL;
    
    //
    // Returns clipper on exit of scope
    //
    ClipperReturner cr(_targetPackage._targetDDSurf,
                       _oldExternalTargetDDSurfaceClipper,
                       *this);
    

    if(!CanDisplay()) return;
    if(!_canFinalBlit) return;
    if(_currentImageDev->IsFullyClear()) return;

    RECT                destRect;
    RECT                srcRect;

    // if intermediate surface is lost, forget even trying to
    // rebuild it (not possible), who knows how many images are on it...
    if(_compositingStack->TargetDDSurface()->IDDSurface()->IsLost() == DDERR_SURFACELOST)
        return;

    //
    // todo:  use the intersection of
    // the cliprect and the invalid rect to set a clipper on the
    // target surface
    //
    
    //
    // Figure out destRect offset
    //
    POINT               pt = {0,0};
    if(IsWindowless()) {
        pt = _targetPackage._offsetPt;
    } else {
        Assert(_targetPackage._targetHWND);
        ClientToScreen( _targetPackage._targetHWND, &pt );
    }

    vector<Bbox2> *pBoxes;
    int boxCount = d.GetMergedBoxes(&pBoxes);

#if _DEBUG
    // If tracing dirty rects, force reblit of entire viewport.  This
    // will let us see the rects.
    if (IsTagEnabled(tagDirtyRectsVisuals)) {
        boxCount = 0;
    }
#endif

    if (boxCount >= 1) {

        Bbox2 targBbox = _compositingStack->TargetDDSurface()->Bbox();
        
        for (int i = 0; i < boxCount; i++) {
            
            Bbox2 resultantBox =
                IntersectBbox2Bbox2((*pBoxes)[i], targBbox);

            if (resultantBox == NullBbox2) continue;

            // optimization, convert box to rect
            _currentImageDev->DoDestRectScale(&destRect,
                                              _currentImageDev->GetResolution(),
                                              resultantBox,
                                              NULL);

            /* negative numbers have been appearing here occasionally.
               intersecting with the bounding box of the surface should
               prevent this, but it doesn't.  why ? */

            destRect.left = MAX(destRect.left,0);
            destRect.top = MAX(destRect.top,0);
            srcRect = destRect;

            if (destRect.left != destRect.right &&
                destRect.top != destRect.bottom) {
                  
                BlitToPrimary(&pt,&destRect,&srcRect);

            }
        }
        
    } else {
        
        srcRect = _clientRect;
        destRect = _clientRect;
        BlitToPrimary(&pt,&destRect,&srcRect);
    }

     
    // return all the compositing surfaces
    _compositingStack->ReplaceAndReturnScratchSurface(NULL);
}

void DirectDrawViewport::
DiscreteImageGoingAway(DiscreteImage *image)
{
    if (!IsSurfMgrSet())
        return;
    
    //
    // now we're done using this guy, return all it's resources
    //

    DDSurfPtr<DDSurface> s = _imageSurfaceMap->LookupSurfaceFromImage(image);
    DDSurfPtr<DDSurface> t = _imageTextureSurfaceMap->LookupSurfaceFromImage(image);
    DDSurfPtr<DDSurface> u = _imageUpsideDownTextureSurfaceMap->LookupSurfaceFromImage(image);
    if(t) NotifyGeomDevsOfSurfaceDeath(t->IDDSurface());
    if(u) NotifyGeomDevsOfSurfaceDeath(u->IDDSurface());
    
    _imageSurfaceMap->DeleteMapEntry(image);
    _imageTextureSurfaceMap->DeleteMapEntry(image);
    _imageUpsideDownTextureSurfaceMap->DeleteMapEntry(image);
    
#if DEVELOPER_DEBUG
    if (s && (s->GetRef() != 1))
    {
        TraceTag((tagError,
                  "Surface Leak: refcount = %d",
                  s->GetRef()));
    }
    
    if (t && (t->GetRef() != 1))
    {
        TraceTag((tagError,
                  "Texture Surface Leak: refcount = %d",
                  t->GetRef()));
    }
    
    if (u && (u->GetRef() != 1))
    {
        TraceTag((tagError,
                  "Upsidedown Texture Surface Leak: refcount = %d",
                  u->GetRef()));
    }
#endif    

    // release DDSurface references automatically by smart pointers
}


/* helper function for EndRendering */

void DirectDrawViewport::BlitToPrimary(POINT *pt,RECT *destRect,RECT *srcRect)
{
    if(!CanDisplay()) return;

    // COMPOSITE
    // blit intermediate img to primary.
    Assert(WIDTH(destRect) == WIDTH(srcRect));
    Assert(HEIGHT(destRect) == HEIGHT(srcRect));

    // clip rect starts out as the dest Rect
    RECT destClipRect = *destRect;
    
    if(_targetPackage._prcClip) {

        // clip rect is now the prcClip
        destClipRect = *_targetPackage._prcClip;
        if ((!_targetPackage._composeToTarget) && _targetPackage._targetType == target_ddsurf) {

            RECT clipR = destClipRect;
            
            // offset into non trident coords
            OffsetRect(&clipR, -pt->x, -pt->y);

            //
            // need to clip destRect & srcRect by *pdestClipRect
            // This block of code is copied from ComposeToIDDSurf, we
            // may want to factor the same code into a function later on.
            //
            RECT Clippeddest;
            if (!IntersectRect(&Clippeddest, destRect, &clipR)) {
                    return;
            }
            if (WIDTH(srcRect) != WIDTH(&Clippeddest)) {
                    srcRect->left += (Clippeddest.left - destRect->left);
                    srcRect->right = srcRect->left + WIDTH(&Clippeddest);
            }
            if (HEIGHT(srcRect) != HEIGHT(&Clippeddest)) {
                    srcRect->top += (Clippeddest.top - destRect->top);
                    srcRect->bottom = srcRect->top + HEIGHT(&Clippeddest);
            }
            *destRect = Clippeddest;
        }
    }  else { // if _prcClip

        // ofset the clipRect into dest space using the offset PT
        OffsetRect( &destClipRect, pt->x, pt->y );
    }
    
    // offset destRect into trident coords
    OffsetRect(destRect, pt->x, pt->y);


    switch(_targetPackage._targetType) {

      case target_ddsurf:
        Assert(_targetPackage._targetDDSurf);
        if(_targetPackage._composeToTarget &&
            !_opacityCompositionException) {
            // done...
        } else {
             _currentImageDev->ComposeToIDDSurf(
                 _targetPackage._targetDDSurf,
                 _compositingStack->TargetDDSurface(),
                 *destRect,
                 *srcRect,
                 destClipRect);
        }

    //
    // Do a color conversion blit from a 16bpp target surface to some
    // 8bpp target
    //
    // TESTING PURPOSES ONLY
        #if 0
        {
            // creat an 8bpp surface
            static DDSurface *dest_8bppSurf = NULL;
            DDPIXELFORMAT pf;

            pf.dwSize = sizeof(pf);
            pf.dwFlags = DDPF_PALETTEINDEXED8 | DDPF_RGB;
            pf.dwRGBBitCount = 8;
        
            Assert(destRect->left == 0);
            Assert(destRect->top == 0);
            if( !dest_8bppSurf ) {
                CreateSizedDDSurface(&dest_8bppSurf, &pf,
                                     destRect->right,
                                     destRect->bottom,
                                     NULL, notVidmem);
                SetPaletteOnSurface(dest_8bppSurf->IDDSurface(), GethalftoneDDpalette());
            }

            {
                // convert
                RECT rect = *(_targetPackage._targetDDSurf->GetSurfRect());
                HDC srcDC = _targetPackage._targetDDSurf->GetDC("");
                HDC destDC = dest_8bppSurf->GetDC("");
                
                int ret;
                ret = StretchBlt(destDC,
                                 rect.left,
                                 rect.top,
                                 rect.right - rect.left,
                                 rect.bottom - rect.top,
                                 srcDC,
                                 rect.left,
                                 rect.top,
                                 rect.right - rect.left,
                                 rect.bottom - rect.top,
                                 SRCCOPY);

                Assert( ret ) ;
                dest_8bppSurf->ReleaseDC("");
                _targetPackage._targetDDSurf->ReleaseDC("");
            }
        }
        #endif
        
        break;

      case target_hdc:
        Assert(_targetPackage._targetGDISurf);

        _currentImageDev->ComposeToHDC(_targetPackage._targetGDISurf,
                                       _compositingStack->TargetDDSurface(),
                                       destRect,
                                       srcRect);
        

        break;

      case target_hwnd:

        Assert(GetMyPrimarySurface());
        {
            // Grab the critical section and make sure this is all atomic

            CritSectGrabber csg(*DDrawCritSect);

            _ddrval = GetMyPrimarySurface()->SetClipper(_primaryClipper);
            IfDDErrorInternal(_ddrval,
                              "Could not set clipper on primary surface");

            TIME_DDRAW(_ddrval = GetMyPrimarySurface()->Blt(destRect,
                                                      _compositingStack->TargetDDSurface()->IDDSurface(),
                                                      srcRect,
                                                      DDBLT_WAIT,
                                                      NULL));
        }

        if( _ddrval != DD_OK) {
            if( _ddrval == DDERR_SURFACELOST) {
                TraceTag((tagError, "Primary lost"));
            } else {
                printDDError(_ddrval);
                TraceTag((tagError, "vwprt: %x. PrimaryBlt failed srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                          this, srcRect->left, srcRect->top, srcRect->right,
                          srcRect->bottom, destRect->left, destRect->top,
                          destRect->right, destRect->bottom));
            }
        }

        break;

      default:
        Assert(FALSE && "Invalid target in EndRendering");
    }
}

HPALETTE DirectDrawViewport::GethalftoneHPal()
{
    if (_halftoneHPal == 0)
        CreateHalftonePalettes();
    return _halftoneHPal;
}
LPDIRECTDRAWPALETTE DirectDrawViewport::GethalftoneDDpalette()
{
    if (_halftoneDDpalette == 0)
        CreateHalftonePalettes();
    return _halftoneDDpalette;
}
HPALETTE DirectDrawViewport::CreateHalftonePalettes()
{
    PALETTEENTRY palentries[256];

    HDC hdc = GetDC(NULL);
    if (_halftoneHPal == NULL) {
        _halftoneHPal = ::CreateHalftonePalette(hdc);
        if (_halftoneHPal) {
            ::GetPaletteEntries(_halftoneHPal, 0, 256, palentries);
            int i;
            for (i=0;  i < 256;  ++i)
                palentries[i].peFlags |= D3DPAL_READONLY;
            CreateDDPaletteWithEntries(&_halftoneDDpalette,palentries);
        }
    }
    
    ReleaseDC(NULL, hdc);

    return _halftoneHPal;
}


void DirectDrawViewport::
GetPaletteEntries(HPALETTE hPal, LPPALETTEENTRY palEntries)
{
    if(hPal) {
        ::GetPaletteEntries(hPal, 0, 256, palEntries);
    }
}

void DirectDrawViewport::
CreateDDPaletteWithEntries (
    LPDIRECTDRAWPALETTE *palPtr,
    LPPALETTEENTRY       palEntries)
{
    _ddrval = DIRECTDRAW->CreatePalette(DDPCAPS_8BIT | DDPCAPS_INITIALIZE | DDPCAPS_ALLOW256,
                                        palEntries,
                                        palPtr, NULL);
    IfDDErrorInternal(_ddrval, "Could not create palette with entries");
}

void DirectDrawViewport::
SetPaletteOnSurface(LPDDRAWSURFACE surface, LPDIRECTDRAWPALETTE pal)
{
    _ddrval = surface->SetPalette(NULL);
    if(_ddrval != DD_OK &&
       _ddrval != DDERR_NOPALETTEATTACHED) {
        printDDError(_ddrval);
        RaiseException_InternalError("Couldn't release palette from surface");
    }

    _ddrval = surface->SetPalette(pal);
    IfDDErrorInternal(_ddrval, "Could not set palette on surface");
}

void DirectDrawViewport::
CreateNewCompositingSurface(DDPIXELFORMAT &pf,
                            DDSurface **outSurf,
                            INT32 width, INT32 height,
                            vidmem_enum vid,
                            except_enum exc)
{
    DAComPtr<IDDrawSurface> iddSurf;

    bool nonTargetSize;
    if(width < 0 || height < 0) {
        width = Width();
        height = Height();
        nonTargetSize = false;
    } else {
        nonTargetSize = true;
    }

    Bbox2 surfBbox;
    RECT  surfRect;
    LPDIRECTDRAWCLIPPER lpClip = NULL;
    LPDIRECTDRAWCLIPPER *lplpClip;
    
    if( nonTargetSize ) {
        SetRect(&surfRect, 0,0, width, height);
        RectToBbox(width, height, surfBbox, GetResolution());
        lplpClip = &lpClip;
    } else {
        surfBbox = GetTargetBbox();
        surfRect = _clientRect;
        lplpClip = &_targetSurfaceClipper;
    }
    
    //
    // This create the surface and the
    // clipper if either is NULL using the given surfRect
    //
    ReInitializeSurface(&iddSurf,
                        pf,
                        lplpClip,
                        width, height,
                        &surfRect, vid, exc);

    if( !iddSurf ) {
        *outSurf = NULL;
        if (exc == except) {
            RaiseException_ResourceError("Can't create surface");
        }
        return;
    }

    if( GetTargetBitDepth() == 8 ) {
        //
        // Set palette on surface
        //
        AttachCurrentPalette(iddSurf);
    }

    DynamicHeapPusher dhp(_heapIWasCreatedOn);

    // hand over reference
    NEWDDSURF(outSurf,
              iddSurf,
              surfBbox,
              &surfRect,
              GetResolution(),
              0, false,
              false, false,
              "CompositingSurface");

    // iddSurf ref released on exit

    if( nonTargetSize ) {
        // release our reference, it's attached to the surface
        (*lplpClip)->Release();
    }
}

void DirectDrawViewport::
OneTimeDDrawMemberInitialization()
{

}



/*****************************************************************************\
This routine pushes the first surface for compositing.  This surface is the
last stop before the final target surface.
*****************************************************************************/

void DirectDrawViewport::
PushFirstTargetSurface()
{
    //
    // Determine there's a surface that needs to be
    // pushed on the stack first...
    //
    Assert((_compositingStack->Size() == 0) &&
           "_targetSurfaceSTack should be empty in PushFirstTargetSurface");

    if(_externalTargetDDSurface) {
        // ok, push this guy first.
        _compositingStack->PushTargetSurface(_externalTargetDDSurface);
    } else {

        // If we've got an HWND target, then we should place the first target
        // surface in video memory to enable 3D hardware acceleration if it's
        // available.

        bool videomem = false;

        if (!g_prefs3D.useHW)
        {   TraceTag ((tag3DDevSelect, "3D hardware disabled in registry."));
        }
        else if ( ! _targetPackage.IsHWND() )
        {   TraceTag ((tag3DDevSelect,
                "Target type != HWND; using 3D software renderer."));
        }
        else if (  (_primaryPixelFormat.dwRGBBitCount == 32)
                && (_primaryPixelFormat.dwRGBAlphaBitMask != 0)
                )
        {
            TraceTag ((tag3DDevSelect,
                "Primary surface is 32-bit with alpha; using software."));
        }
        else
        {
            ChosenD3DDevices *devs3d = SelectD3DDevices (DirectDraw1());

            if (devs3d->hardware.guid == GUID_NULL)
            {
                TraceTag ((tag3DDevSelect, "No 3D hardware available."));
            }
            else if (!(devs3d->hardware.desc.dwDeviceRenderBitDepth
                         & BPPtoDDBD(BitsPerDisplayPixel())))
            {
                TraceTag ((tag3DDevSelect,
                    "No 3D hardware support for %d-bit target surface.",
                    BitsPerDisplayPixel()));
            }
            else if (BitsPerDisplayPixel() == 8)
            {
                // Most 3D cards don't support 8-bit acceleration.  Of those
                // that do, many don't properly support textures, so we choose
                // software rendering instead for all 8-bit surfaces.

                TraceTag ((tag3DDevSelect,
                           "Declining HW acceleration for 8-bit surface."));
            }
            else
            {   TraceTag ((tag3DDevSelect,
                    "Creating main surface in video memory."));
                videomem = true;
            }
        }

        // Attempt to create the compositing surface.  If we're trying for a
        // system-memory surface, then throw an exception on failure.  If we're
        // trying for a video-memory surface, then return on failure so we can
        // try again with system memory.

        // this is ugly... find a better way
        #if _DEBUG
        DDSurfPtr<DDSurface> ddsurf("PushFirstTargetSurface", this);
        #else
        DDSurfPtr<DDSurface> ddsurf;
        #endif
        
        _compositingStack->GetSurfaceFromFreePool(
            &ddsurf,
            dontClear,
            -1, -1,
            notScratch,
            videomem ? vidmem : notVidmem,
            videomem ? noExcept : except);
        
        // If we got back a null pointer (failed to create a video-memory
        // surface), or if we couldn't attach a Z-buffer to the video-memory
        // surface up front (probably due to memory constraints), then fall
        // back to system memory.  We don't bother attaching a Z-buffer to
        // system memory surface since memory is much less constrained (and we
        // do this lazily if needed).

        if (!ddsurf || (videomem && FAILED(AttachZBuffer(ddsurf,noExcept)))) {

            TraceTag ((tag3DDevSelect, "Couldn't allocate main "
                       "compositing%s surface in video memory.",
                       ddsurf? "" : " Z-buffer"));

            if (ddsurf) {
                ddsurf.Release();
            }
            
            _compositingStack->GetSurfaceFromFreePool
                (   &ddsurf,
                    dontClear,
                    -1, -1,
                    notScratch,
                    notVidmem,
                    except);
        }
        
        _compositingStack->PushTargetSurface (ddsurf);
    }
}


void DirectDrawViewport::RePrepareTargetSurfaces ()
{
    //
    // Resize means kill all surface & zbuffer & clipper
    //
    DestroyTargetSurfaces();
    if(_targetSurfaceClipper)
       _targetSurfaceClipper->Release();

    //
    // NULL the pointers so they are created again
    //
    _targetSurfaceClipper = NULL;

    //
    // Create the surface and implicitly: the clipper & ZBuffer
    // Push on _targetSurfaceStack
    //
    PushFirstTargetSurface();

    Assert((_compositingStack->Size() == 1) && "Unexpected number of target surfaces in RePrepareTargetSurfaces");
}



//---------------------------------------------------------
//
// Compositing & target surface management
//
void DirectDrawViewport::
GetDDSurfaceForCompositing(
            SurfacePool &pool,
            DDSurface **outSurf,
            INT32 minW, INT32 minH,     
            clear_enum   clr,
            scratch_enum scr,
            vidmem_enum  vid,
            except_enum  exc)
{
    DDSurface* surface = NULL;

    if(minW < 0 || minH < 0) {
        minW = Width();
        minH = Height();
    }
    
    //
    // need to make sure the compositing surface returned is based on
    // current viewport size
    //

    pool.FindAndReleaseSizeCompatibleDDSurf(
        NULL,
        minW,
        minH,
        vid,
        NULL,
        &surface);   // our reference

    if(!surface) {
        // create one
        CreateNewCompositingSurface(pool.GetPixelFormat(),
                                    &surface,
                                    minW, minH,
                                    vid, exc);
    }

    __try {
        if (clr == doClear && surface) {
            ClearDDSurfaceDefaultAndSetColorKey(surface);
        }
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        // NOTE;  if something else fails <non da> we leak this
        // suface... like a div by zero, for example

        // return the surface man!
        pool.AddSurface(surface);
        RETHROW;
    }   

    if(surface) {
        if( scr == scratch ) {
            surface->SetScratchState(DDSurface::scratch_Dest);
        }
    }

    // hand over the reference.
    *outSurf = surface;
}


void DirectDrawViewport::
ColorKeyedCompose(DDSurface *destDDSurf,
                  RECT *destRect,
                  DDSurface *srcDDSurf,
                  RECT *srcRect,
                  DWORD clrKey)
{
    
    Assert( !(clrKey & srcDDSurf->GetPixelFormat().dwRGBAlphaBitMask )  );

    if (!sysInfo.IsWin9x() || (sysInfo.VersionDDraw() > 3)) {
        // We are on NT OR dx5 or above 

        DWORD flags = DDBLT_KEYSRCOVERRIDE | DDBLT_WAIT;

        ZeroMemory(&_bltFx, sizeof(_bltFx));
        _bltFx.dwSize = sizeof(_bltFx);

        _bltFx.ddckSrcColorkey.dwColorSpaceLowValue =
            _bltFx.ddckSrcColorkey.dwColorSpaceHighValue = clrKey;

        DebugCode(
            RECT resRect;
            IntersectRect(&resRect,destRect,srcRect);
            Assert(&resRect != srcRect);
            );

        TIME_DDRAW(_ddrval = destDDSurf->Blt(destRect, srcDDSurf, srcRect, flags, &_bltFx));

        // This is correct, but too risky for the cr1 release.
        //destDDSurf->UnionInterestingRect( destRect );
    
        if(_ddrval != DD_OK) {
            printDDError(_ddrval);
            TraceTag((tagError, "ColorKeyedCompose: failed srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                      srcRect->left, srcRect->top, srcRect->right,srcRect->bottom,
                      destRect->left, destRect->top, destRect->right, destRect->bottom));
            #if _DEBUG
            DDPIXELFORMAT pf1;
            DDPIXELFORMAT pf2;
            destDDSurf->IDDSurface()->GetPixelFormat(&pf1);
            srcDDSurf->IDDSurface()->GetPixelFormat(&pf2);
            #endif
        }
    }
    else {
        // We are on DX3
        destPkg_t pack;
        pack.isSurface = true;
        pack.lpSurface = destDDSurf->IDDSurface();
        GetImageRenderer()->ColorKeyBlit(&pack,srcRect,srcDDSurf->IDDSurface(), 
                                         clrKey, destRect, destRect);
    }
}

void CopyOrClearRect(RECT **src, RECT **dest, bool clear)
{
    if( *src ) {
        if(! (*dest) ) {
            *dest = new RECT;
        }
        CopyRect(*dest, *src);
    } else {
        if(clear) {
            delete *dest;
            *dest = NULL;
        }
    }
}



//----------------------------------------------------------------------------
// Returns the geom device associated with the DDSurface
// creates one if none exists.
//----------------------------------------------------------------------------

GeomRenderer* DirectDrawViewport::GetGeomDevice (DDSurface *ddSurf)
{
    if( !ddSurf ) return NULL;
    
    GeomRenderer *gdev = ddSurf->GeomDevice();

    if (!gdev) {

        // Attach ZBuffer FIRST!
        AttachZBuffer(ddSurf);

        gdev = NewGeomRenderer (this, ddSurf);

        if (gdev)
        {
            TraceTag ((tagViewportMemory,
                "Created new geom device %x on %x\n", gdev, ddSurf));

            ddSurf->SetGeomDevice( gdev );
        }
    }

    return gdev;
}

bool DirectDrawViewport::IsTargetViable()
{
    bool viable = false;

    if( _targetPackage.IsValid() ) {

        viable = true;

        // WORKAROUND: When on Windows NT4SP3 or NT5, certain buggy display drivers
        //             will not allow us to lock the primary surface here.  Since
        //             locking the primary here is a fix for the surface busy errors
        //             that hit us when running screen savers under Win98, and the
        //             screen savers don't matter under NT, then not doing the lock
        //             under NT is OK.
        if (!sysInfo.IsNT()) {
            if( _targetPackage.IsDdsurf() || _targetPackage.IsHWND() ) {

                IDDrawSurface *idds = _targetPackage.IsDdsurf() ?
                    _targetPackage._targetDDSurf->IDDSurface() :
                    GetMyPrimarySurface();

                Assert( idds );

                // To see if the target surface will be free for modification,
                // we blt a pixel to itself and test for success.  In some
                // situations (power management on Win98), the Lock was
                // succeeding even thought the surface failed with
                // SURFACEBBUSY on subsequent operations.  This way we can
                // ensure that we won't throw exceptions deep in our code on
                // every call to View::Render.

                RECT rect;
                rect.left   = 0;
                rect.right  = 1;
                rect.top    = 0;
                rect.bottom = 1;

                HRESULT hr = idds->Blt (&rect, idds, &rect, DDBLT_WAIT, NULL);

                if (FAILED(hr))
                {   viable = false;
                    TraceTag ((tagWarning, "Surface self-blt failed in IsTargetViable."));
                }
            }
        }
    }

    return viable;
}

bool DirectDrawViewport::
TargetsDiffer( targetPackage_t &a,
               targetPackage_t &b )
{
    //
    // if the types are different
    //
    if (a.GetTargetType() != b.GetTargetType())
        return true;

    //
    // if composite to directly to target is different
    //
    if (a.GetComposeToTarget() != b.GetComposeToTarget())
        return true;

    //
    // we know the targets are the same type.
    // So: if the ptr changed, has the bitdepth
    //
    switch( a.GetTargetType() )
      {
        case target_ddsurf:
          // check bit depth

          // TODO: A possible optimization exists here:
          // instead of getting the pixel format every frame, we can
          // cache it.

          // TODO: (bug) there's a smallish bug here that is we don't
          // compare the rgb masks to make sure the pixel format is
          // REALLY the same.
          
          DDPIXELFORMAT pf1; pf1.dwSize = sizeof(DDPIXELFORMAT);
          DDPIXELFORMAT pf2; pf2.dwSize = sizeof(DDPIXELFORMAT);

          if( a.GetIDDSurface() && b.GetIDDSurface() ) {
              if( SUCCEEDED( a.GetIDDSurface()->GetPixelFormat(&pf1) ) &&
                  SUCCEEDED( b.GetIDDSurface()->GetPixelFormat(&pf2) )) 
                {
                    return pf1.dwRGBBitCount != pf2.dwRGBBitCount;
                } else {
                    return true;
                }
          } else {
              return true;
          }
                  
          break;
          
          // for hdc and hwnd: we don't care if the underlying
          // info changes because, in the hwnd case we only get
          // the client rect and out pixel format is independent
          // of the hwnd, and in the dc case we depend on it even
          // less.
          
        default:
          break;
      }
    
    return false;
}

    

//----------------------------------------------------------------------------
// Return the GeomDDRenderer object associated with the target surface.
//----------------------------------------------------------------------------

GeomRenderer* DirectDrawViewport::MainGeomRenderer (void)
{
    if( !_compositingStack ) return NULL;
    
    if( _compositingStack->TargetSurfaceCount() > 0 ) {
        Assert( ! IsBadReadPtr(_compositingStack->TargetDDSurface(),
                               sizeof(DDSurface *) ));
        
        return GetGeomDevice (_compositingStack->TargetDDSurface());
    } else {
        return NULL;
    }
}

GeomRenderer* DirectDrawViewport::GetAnyGeomRenderer()
{
    GeomRenderer *gdev = NULL;
    if( !_geomDevs.empty() ) {
        gdev = _geomDevs.back();
    }
    return gdev;
}


static void
UpdateUserPreferences(PrivatePreferences *prefs,
                      Bool isInitializationTime)
{
    g_preference_defaultColorKey =
        RGB(prefs->_clrKeyR, prefs->_clrKeyG, prefs->_clrKeyB);
}


HRESULT GetDirectDraw(IDirectDraw  **ddraw1,
                      IDirectDraw2 **ddraw2,
                      IDirectDraw3 **ddraw3)
{
    TraceTag((tagViewportInformative, ">>>> GetDirectDraw <<<<<\n"));
    CritSectGrabber csg(*DDrawCritSect);

    HRESULT _ddrval = DD_OK;

    // TEMP TEMP to make each viewport have a separate ddraw object
    IDirectDraw  *directDraw1 = NULL;
    IDirectDraw2 *directDraw2 = NULL;
    IDirectDraw3 *directDraw3 = NULL;

    if(!directDraw1 && !directDraw2 && !directDraw3) {

        if (!g_surfFact) {
            g_ddraw3Avail = false;
            _ddrval = CoCreateInstance(CLSID_DirectDrawFactory,
                                       NULL, CLSCTX_INPROC_SERVER,
                                       IID_IDirectDrawFactory,
                                       (void **) & g_surfFact);
            if(SUCCEEDED(_ddrval)) {

                #if _DEBUG
                {
                    DWORD foo;
                    DWORD sz = GetFileVersionInfoSize("ddrawex.dll", &foo);
                    char *vinfo = new char[sz];
                    if( GetFileVersionInfo("ddrawex.dll", 0, sz, vinfo) ) {
                        VS_FIXEDFILEINFO    *ver=NULL;
                        UINT                cb;
                        if( VerQueryValue(vinfo, "\\", (LPVOID *)&ver, &cb)){
                            if( ver != NULL ) {
                            }
                        }
                    }
                    delete vinfo;
                }
                #endif

                g_ddraw3Avail = true;
            }
        }

        if(g_ddraw3Avail) {
            _ddrval = g_surfFact->CreateDirectDraw(NULL, GetDesktopWindow(), DDSCL_NORMAL, 0, NULL, &directDraw1);
            IfDDErrorInternal(_ddrval, "Could not create DirectDraw object from ddrawex.dll");
            g_surfFact->Release();
            g_surfFact = NULL;
            #if _DEBUG
            OutputDebugString("Using IDirectDraw3 (ddrawex.dll)\n");
            #endif
        } else {

            #if 1
            if (!hInstDDraw) {
                hInstDDraw = LoadLibrary("ddraw.dll");
                if (!hInstDDraw) {
                    Assert(FALSE && "LoadLibrary of ddraw.dll failed");
                    return E_FAIL;
                }
            }

            FARPROC fptr = GetProcAddress(hInstDDraw, "DirectDrawCreate");
            if (!fptr) {
                Assert(FALSE && "GetProcAddress of DirectDrawCreate failed");
                return E_FAIL;
            }

            typedef HRESULT (WINAPI *DDrawCreatorFunc)
                (GUID FAR *lpGuid,
                 LPDIRECTDRAW FAR *lplpDD,
                 IUnknown FAR *pUnkOuter);

            DDrawCreatorFunc creatorFunc = (DDrawCreatorFunc)(fptr);

            _ddrval = (*creatorFunc)(NULL, &directDraw1, NULL);
            IfDDErrorInternal(_ddrval, "Could not create DirectDraw object");
            #else

            _ddrval = CoCreateInstance(CLSID_DirectDraw,
                                       NULL, CLSCTX_INPROC_SERVER,
                                       //NULL, CLSCTX_ALL,
                                       IID_IDirectDraw,
                                       (void **) & directDraw1);
            IfDDErrorInternal(_ddrval, "Could not create DirectDraw object");

            _ddrval = directDraw1->Initialize(NULL);
            IfDDErrorInternal(_ddrval, "Could not Initialize direct draw object");
            #endif

            if (ddraw2) {
                _ddrval = directDraw1->QueryInterface(IID_IDirectDraw2, (void **)&directDraw2);
                IfDDErrorInternal(_ddrval, "Could not QI for a DirectDraw2 object");
            }
        }

        // first time created, set coop level
        _ddrval = directDraw1->SetCooperativeLevel( NULL, DDSCL_NORMAL );
        IfDDErrorInternal(_ddrval, "Could not set cooperative level");

        CompleteDdrawObjectSet(&directDraw1,
                               &directDraw2,
                               g_ddraw3Avail ? &directDraw3 : NULL);

        // first time, don't addref the global object
        if(ddraw1) {
            *ddraw1 = directDraw1;
        }
        if(ddraw2) {
            *ddraw2 = directDraw2;
        }
        if(ddraw3 && g_ddraw3Avail) {
            *ddraw3 = directDraw3;
        }

        return _ddrval;
    }


    Assert((directDraw1 || directDraw3 || directDraw2) && "no ddraw object availabe (1,2 or 3)");

    if(ddraw1) {
        directDraw1->AddRef();
        *ddraw1 = directDraw1;
    }
    if(ddraw2) {
        directDraw2->AddRef();
        *ddraw2 = directDraw2;
    }
    if(ddraw3 && g_ddraw3Avail) {
        directDraw3->AddRef();
        *ddraw3 = directDraw3;
    }
    return _ddrval;
}



IDirectDraw* DirectDrawViewport::DirectDraw1 (void)
{
    if (!_directDraw1) {
        if (_directDraw) {
            _ddrval = _directDraw->QueryInterface (IID_IDirectDraw,
                                                   (void**)&_directDraw1);
            IfDDErrorInternal (_ddrval, "QI for DirectDraw1 failed");
        } else {
            _ddrval = GetDirectDraw (&_directDraw1, NULL, NULL);
            IfDDErrorInternal (_ddrval, "DirectDraw1 create failed");
            _directDraw = _directDraw1;
        }
    }

    return _directDraw1;
}


IDirectDraw2* DirectDrawViewport::DirectDraw2 (void)
{
    if (!_directDraw2) {
        if (_directDraw) {
            _ddrval = _directDraw->QueryInterface (IID_IDirectDraw2,
                                                   (void**)&_directDraw2);
            IfDDErrorInternal (_ddrval, "QI for DirectDraw2 failed");
        } else {
            _ddrval = GetDirectDraw (NULL, &_directDraw2, NULL);
            IfDDErrorInternal (_ddrval, "DirectDraw2 create failed");
            _directDraw = _directDraw2;
        }
    }

    return _directDraw2;
}

#if DDRAW3
IDirectDraw3 *DirectDrawViewport::DirectDraw3 (void)
{
    if (!_directDraw3) {
        if (_directDraw) {
            _ddrval = _directDraw->QueryInterface (IID_IDirectDraw3,
                                                   (void**)&_directDraw3);
            IfDDErrorInternal (_ddrval, "QI for DirectDraw3 failed");
        } else {
            _ddrval = GetDirectDraw (NULL, NULL, &_directDraw3);
            IfDDErrorInternal (_ddrval, "DirectDraw3 create failed");
            _directDraw = _directDraw3;
        }
    }

    return _directDraw3;
}
#endif

bool DirectDrawViewport::GetAlreadyOffset(DDSurface * ddsurf)
{
  return (  _targetPackage._alreadyOffset &&
            ddsurf == _externalTargetDDSurface &&
            GetImageRenderer()->GetOffsetTransform()); 
}


void CompleteDdrawObjectSet(IDirectDraw  **directDraw1,
                            IDirectDraw2 **directDraw2,
                            IDirectDraw3 **directDraw3)
{
    IUnknown *ddraw;

    if (*directDraw1)
        ddraw = *directDraw1;
    else if (*directDraw2)
        ddraw = *directDraw2;
    else if (directDraw3 && *directDraw3)
        ddraw = *directDraw3;
    else
        Assert (!"All null pointers passed to CompleteDdrawObjectSet().");

    HRESULT result;

    if (!*directDraw1) {
        result = ddraw->QueryInterface(IID_IDirectDraw, (void**)directDraw1);
        IfDDErrorInternal (result, "Failed QI for DirectDraw1");
    }

    if (!*directDraw2) {
        result = ddraw->QueryInterface(IID_IDirectDraw2, (void**)directDraw2);
        IfDDErrorInternal (result, "Failed QI for DirectDraw2");
    }

    if (directDraw3 && !*directDraw3) {
        result = ddraw->QueryInterface(IID_IDirectDraw3, (void**)directDraw3);
        IfDDErrorInternal (result, "Failed QI for DirectDraw3");
    }
}



HRESULT GetPrimarySurface (
    IDirectDraw2   *ddraw2,
    IDirectDraw3   *ddraw3,
    IDDrawSurface **primary)
{
    TraceTag((tagViewportInformative, ">>>> GetPrimarySurface <<<<<"));
    CritSectGrabber csg(*DDrawCritSect);

    // per view primary
    // Remove this to have a global shared primary...
    IDDrawSurface *g_primarySurface = NULL;

    HRESULT hr = S_OK;
    Assert((ddraw3 || ddraw2) && "NULL ddraw object in GetPrimarySurface");

    if(!g_primarySurface) {
        // create it!  (once per process)

        DDSURFACEDESC       ddsd;
        ZeroMemory(&ddsd, sizeof(ddsd));

        // Primary surface, this surface is what is always seen !

        ddsd.dwSize = sizeof( ddsd );
        ddsd.dwFlags = DDSD_CAPS;
        ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;

        if(ddraw3) {
            hr = ddraw3->CreateSurface( &ddsd, &g_primarySurface, NULL );
        } else {
            Assert(ddraw2);
            hr = ddraw2->CreateSurface( &ddsd, &g_primarySurface, NULL );
        }

        if(hr != DDERR_NOEXCLUSIVEMODE)
            IfDDErrorInternal(hr, "GetPrimarySurface - CreateSurface Failed.");
        
        // no addref, first reference keeps it.
        *primary = g_primarySurface;
        return hr;
    }

    // The code below is never run because the primary is always created

    // TEMP TEMP
    if(hr != DD_OK) printDDError(hr);


    if(g_primarySurface) g_primarySurface->AddRef();
    *primary = g_primarySurface;
    return hr;
}


void 
RectToBbox(LONG pw, LONG ph, Bbox2 &box, Real res) {
        Real w = Real(pw) / res;
        Real h = Real(ph) / res;
        box.min.Set(-(w*0.5), -(h*0.5));
        box.max.Set( (w*0.5),  (h*0.5));
}


/*****************************************************************************
This function returns the number of bits-per-pixel of the display.
*****************************************************************************/

int BitsPerDisplayPixel (void)
{
    HDC dc  = GetDC (NULL);
    int bpp = GetDeviceCaps (dc, BITSPIXEL) * GetDeviceCaps (dc, PLANES);

    ReleaseDC (NULL, dc);
    return bpp;
}

//--------------------------------------------------
// C r e a t e  V i e w p o r t
//
// Creates the top level viewport
//--------------------------------------------------
DirectDrawViewport *
CreateImageDisplayDevice()
{
    DirectDrawViewport *viewport = NEW DirectDrawViewport();
    viewport->PostConstructorInitialize();  // for exception throwing
                                            // in the constructor
    
    return viewport;
}

void DestroyImageDisplayDevice(DirectDrawViewport* dev)
{
    // Surface tracker is part of the viewport class, we grab it
    // destroy the viewport then delete it so that it can acuratly
    // track all surface allocations and deletions.
    #if _DEBUGSURFACE
    SurfaceTracker *st = dev->Tracker();
    #endif

    delete dev;

    #if _DEBUGSURFACE
    delete st;
    #endif
}


void
InitializeModule_Viewport()
{
    ExtendPreferenceUpdaterList(UpdateUserPreferences);
    if(!DDrawCritSect) DDrawCritSect = new CritSect ;
    if(!g_viewportListLock) g_viewportListLock = new CritSect ;
}

void
DeinitializeModule_Viewport(bool bShutdown)
{
    delete DDrawCritSect;
    DDrawCritSect = NULL;

    delete g_viewportListLock;
    g_viewportListLock = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\avrtypes.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Define ActiveVRML exposed types here.

*******************************************************************************/


#ifndef _AVRTYPES_H
#define _AVRTYPES_H

#include "appelles/common.h"

class DXMTypeInfoImpl;
typedef DXMTypeInfoImpl *DXMTypeInfo;

// Forward declarations
class Camera;
class Color;
class Geometry;
class Image;
class Matte;
class Microphone;
class Montage;
class Path2;
class Point2Value;
class Point3Value;
class Sound;
class Text;
class Transform2;
class Transform3;
class Vector2Value;
class Vector3Value;
class FontFamily;
class FontStyle;
class Bbox2Value;
class Bbox3;
class LineStyle;
class EndStyle;
class JoinStyle;
class DashStyle;
class AxANumber;
class AxAString;
class AxAVariant;
class AxABoolean;
class AxAPair;
class AxAArray;
class AxATrivial;
class AxAEData ;
class Tuple;
class AxALong;

typedef WCHAR * WideString;
typedef long KeyCode;
typedef AxANumber RGBComponent;
typedef AxANumber DoubleValue;
typedef AxANumber RateValue;
typedef AxANumber ScaleRateValue;
typedef AxANumber RateDegreesValue;
typedef AxANumber DegreesValue;
typedef AxANumber PixelValue;
typedef AxANumber PixelYValue;
typedef AxANumber RatePixelYValue;
typedef AxANumber AnimPixelYValue;
typedef AxANumber RatePixelValue;
typedef AxANumber AnimPixelValue;
typedef AxANumber PointValue;
typedef AxANumber AnimPointValue;
typedef AxAString StringValue;
typedef AxAVariant VariantValue;
typedef double PixelDouble;
typedef double PixelYDouble;
typedef double DegreesDouble;

enum DATYPEID {
    AXATRIVIAL_TYPEID,
    CAMERA_TYPEID,
    COLOR_TYPEID,
    GEOMETRY_TYPEID,
    IMAGE_TYPEID,
    MATTE_TYPEID,
    MICROPHONE_TYPEID,
    MONTAGE_TYPEID,
    PATH2_TYPEID,
    POINT2_TYPEID,
    POINT3_TYPEID,
    SOUND_TYPEID,
    TRANSFORM2_TYPEID,
    TRANSFORM3_TYPEID,
    VECTOR2_TYPEID,
    VECTOR3_TYPEID,
    FONTSTYLE_TYPEID,
    BBOX2_TYPEID,
    BBOX3_TYPEID,
    LINESTYLE_TYPEID,
    ENDSTYLE_TYPEID,
    JOINSTYLE_TYPEID,
    DASHSTYLE_TYPEID,
    AXANUMBER_TYPEID,
    AXASTRING_TYPEID,
    AXABOOLEAN_TYPEID,
    AXAPAIR_TYPEID,
    AXAARRAY_TYPEID,
    TUPLE_TYPEID,
    USERDATA_TYPEID,
    AXAEDATA_TYPEID,
    FONTFAMILY_TYPEID,
    TEXT_TYPEID,
    AXALONG_TYPEID,
    AXAVARIANT_TYPEID,
};

// NOTE: if you create a new type, make sure to update values.cpp
// Defined in backend\values.cpp.
extern DXMTypeInfo AxAValueType;
extern DXMTypeInfo BvrType;

extern DXMTypeInfo CameraType;
extern DXMTypeInfo ColorType;
extern DXMTypeInfo GeometryType;
extern DXMTypeInfo ImageType;
extern DXMTypeInfo MatteType;
extern DXMTypeInfo MicrophoneType;
extern DXMTypeInfo MontageType;
extern DXMTypeInfo Path2Type;
extern DXMTypeInfo Point2ValueType;
extern DXMTypeInfo Point3ValueType;
extern DXMTypeInfo SoundType;
extern DXMTypeInfo TextType;
extern DXMTypeInfo Transform2Type;
extern DXMTypeInfo Transform3Type;
extern DXMTypeInfo Vector2ValueType;
extern DXMTypeInfo Vector3ValueType;
extern DXMTypeInfo FontFamilyType;
extern DXMTypeInfo FontStyleType;
extern DXMTypeInfo Bbox2ValueType;
extern DXMTypeInfo Bbox3Type;
extern DXMTypeInfo LineStyleType;
extern DXMTypeInfo EndStyleType;
extern DXMTypeInfo JoinStyleType;
extern DXMTypeInfo DashStyleType;
extern DXMTypeInfo AxANumberType;
extern DXMTypeInfo AxAStringType;
extern DXMTypeInfo AxABooleanType;
extern DXMTypeInfo AxAPairType;
extern DXMTypeInfo AxAArrayType;
extern DXMTypeInfo AxATrivialType;
extern DXMTypeInfo AxAEDataType;
extern DXMTypeInfo TupleType;
extern DXMTypeInfo UserDataType;
extern DXMTypeInfo AxALongType;
extern DXMTypeInfo AxAVariantType;

// Need to make FontFamily a subclass of storeobj
// Font family types
typedef enum {
    ff_serifProportional,
    ff_sansSerifProportional,
    ff_monospaced
} FontFamilyEnum;

DMAPI((DM_TYPE,
       boolean,
       CRBoolean,
       1,
       Boolean,
       C46C1BC1-3C52-11d0-9200-848C1D000000,
       ignore,
       BooleanBvr,
       BooleanBaseBvr,
       CRBoolean,
       AxABoolean *));
DMAPI((DM_TYPE,
       camera,
       CRCamera,
       2,
       Camera,
       C46C1BE2-3C52-11d0-9200-848C1D000000,
       ignore,
       CameraBvr,
       ignore,
       CRCamera,
       Camera *));
DMAPI((DM_TYPE,
       color,
       CRColor,
       3,
       Color,
       C46C1BC6-3C52-11d0-9200-848C1D000000,
       ignore,
       ColorBvr,
       ignore,
       CRColor,
       Color *));
DMAPI2((DM_TYPE2,
        geometry,
        CRGeometry,
        4,
        Geometry,
        C46C1BE0-3C52-11d0-9200-848C1D000000,
        B90E5258-574A-11d1-8E7B-00C04FC29D46,
        GeometryBvr,
        ignore,
        CRGeometry,
        Geometry *));
DMAPI2((DM_TYPE2,
        image,
        CRImage,
        5,
        Image,
        C46C1BD4-3C52-11d0-9200-848C1D000000,
        B90E5259-574A-11d1-8E7B-00C04FC29D46,
        ImageBvr,
        ImageBaseBvr,
        CRImage,
        Image *));
DMAPI((DM_TYPE,
       matte,
       CRMatte,
       6,
       Matte,
       C46C1BD2-3C52-11d0-9200-848C1D000000,
       ignore,
       MatteBvr,
       ignore,
       CRMatte,
       Matte *));
DMAPI((DM_TYPE,
       microphone,
       CRMicrophone,
       7,
       Microphone,
       C46C1BE6-3C52-11d0-9200-848C1D000000,
       ignore,
       MicrophoneBvr,
       ignore,
       CRMicrophone,
       Microphone *));
DMAPI((DM_TYPE,
       montage,
       CRMontage,
       8,
       Montage,
       C46C1BD6-3C52-11d0-9200-848C1D000000,
       ignore,
       MontageBvr,
       ignore,
       CRMontage,
       Montage *));
DMAPI((DM_TYPE,
       number,
       CRNumber,
       9,
       Number,
       9CDE7341-3C20-11d0-A330-00AA00B92C03,
       ignore,
       NumberBvr,
       NumberBaseBvr,
       CRNumber,
       AxANumber *));
DMAPI((DM_TYPE,
       path2,
       CRPath2,
       10,
       Path2,
       C46C1BD0-3C52-11d0-9200-848C1D000000,
       ignore,
       Path2Bvr,
       ignore,
       CRPath2,
       Path2 *));
DMAPI((DM_TYPE,
        point2,
        CRPoint2,
        11,
        Point2,
        C46C1BC8-3C52-11d0-9200-848C1D000000,
        ignore,
        Point2Bvr,
        ignore,
        CRPoint2,
        Point2Value *));
DMAPI((DM_TYPE,
        point3,
        CRPoint3,
        12,
        Point3,
        C46C1BD8-3C52-11d0-9200-848C1D000000,
        ignore,
        Point3Bvr,
        ignore,
        CRPoint3,
        Point3Value *));
DMAPI((DM_TYPE,
       sound,
       CRSound,
       13,
       Sound,
       C46C1BE4-3C52-11d0-9200-848C1D000000,
       ignore,
       SoundBvr,
       ignore,
       CRSound,
       Sound *));
DMAPI((DM_TYPE,
       string,
       CRString,
       14,
       String,
       C46C1BC4-3C52-11d0-9200-848C1D000000,
       ignore,
       StringBvr,
       StringBaseBvr,
       CRString,
       AxAString *));
DMAPI((DM_TYPE,
       transform2,
       CRTransform2,
       15,
       Transform2,
       C46C1BCC-3C52-11d0-9200-848C1D000000,
       ignore,
       Transform2Bvr,
       ignore,
       CRTransform2,
       Transform2 *));
DMAPI((DM_TYPE,
       transform3,
       CRTransform3,
       16,
       Transform3,
       C46C1BDC-3C52-11d0-9200-848C1D000000,
       ignore,
       Transform3Bvr,
       ignore,
       CRTransform3,
       Transform3 *));
DMAPI((DM_TYPE,
        vector2,
        CRVector2,
        17,
        Vector2,
        C46C1BCA-3C52-11d0-9200-848C1D000000,
        ignore,
        Vector2Bvr,
        ignore,
        CRVector2,
        Vector2Value *));
DMAPI((DM_TYPE,
        vector3,
        CRVector3,
        18,
        Vector3,
        C46C1BDA-3C52-11d0-9200-848C1D000000,
        ignore,
        Vector3Bvr,
        ignore,
        CRVector3,
        Vector3Value *));
DMAPI2((DM_TYPE2,
        fontStyle,
        CRFontStyle,
        19,
        FontStyle,
        25B0F91C-D23D-11d0-9B85-00C04FC2F51D,
        960D8EFF-E494-11d1-AB75-00C04FD92B6B,
        FontStyleBvr,
        ignore,
        CRFontStyle,
        FontStyle *));
DMAPI2((DM_TYPE2,
       lineStyle,
       CRLineStyle,
       20,
       LineStyle,
       C46C1BF2-3C52-11d0-9200-848C1D000000,
       5F00F545-DF18-11d1-AB6F-00C04FD92B6B,
       LineStyleBvr,
       ignore,
       CRLineStyle,
       LineStyle *));
DMAPI((DM_TYPE,
       endStyle,
       CREndStyle,
       21,
       EndStyle,
       C46C1BEC-3C52-11d0-9200-848C1D000000,
       ignore,
       EndStyleBvr,
       ignore,
       CREndStyle,
       EndStyle *));
DMAPI((DM_TYPE,
       JoinStyle,
       CRJoinStyle,
       22,
       JoinStyle,
       C46C1BEE-3C52-11d0-9200-848C1D000000,
       ignore,
       JoinStyleBvr,
       ignore,
       CRJoinStyle,
       JoinStyle *));
DMAPI((DM_TYPE,
       dashStyle,
       CRDashStyle,
       23,
       DashStyle,
       C46C1BF0-3C52-11d0-9200-848C1D000000,
       ignore,
       DashStyleBvr,
       ignore,
       CRDashStyle,
       DashStyle *));
DMAPI((DM_TYPE,
       bbox2,
       CRBbox2,
       24,
       Bbox2,
       C46C1BCE-3C52-11d0-9200-848C1D000000,
       ignore,
       Bbox2Bvr,
       ignore,
       CRBbox2,
       Bbox2Value *));
DMAPI((DM_TYPE,
       bbox3,
       CRBbox3,
       25,
       Bbox3,
       C46C1BDE-3C52-11d0-9200-848C1D000000,
       ignore,
       Bbox3Bvr,
       ignore,
       CRBbox3,
       Bbox3 *));
DMAPI((DM_TYPE,
       pair,
       CRPair,
       26,
       Pair,
       C46C1BF4-3C52-11d0-9200-848C1D000000,
       ignore,
       ignore,
       ignore,
       CRPair,
       AxAPair *));
DMAPI2((DM_TYPE2,
        event,
        CREvent,
        27,
        Event,
        50B4791F-4731-11d0-8912-00C04FC2A0CA,
        B90E525A-574A-11d1-8E7B-00C04FC29D46,
        DXMEvent,
        DXMBaseEvent,
        CREvent,
        AxAEData *));
DMAPI2((DM_TYPE2,
        array,
        CRArray,
        28,
        Array,
        D17506C3-6B26-11d0-8914-00C04FC2A0CA,
        2A8F0B06-BE2B-11d1-B219-00C04FC2A0CA,
        ArrayBvr,
        ArrayBaseBvr,
        CRArray,
        AxAArray *));
DMAPI((DM_TYPE,
       tuple,
       CRTuple,
       29,
       Tuple,
       5DFB2651-9668-11d0-B17B-00C04FC2A0CA,
       ignore,
       TupleBvr,
       TupleBaseBvr,
       CRTuple,
       Tuple *));
DMAPI((DM_TYPE,
       userdata,
       CRUserData,
       30,
       UserData,
       AF868304-AB0B-11d0-876A-00C04FC29D46,
       ignore,
       ignore,
       ignore,
       CRUserData,
       UserData));

DM_TYPECONV(double,
            0,
            0,
            double, ignore, ignore, ignore,
            double, ignore, ignore,
            double, ignore, ignore,
            double, ignore, ignore,
            double);
DM_TYPECONV(PixelDouble,
            0,
            0,
            double, ignore, ignore, ignore,
            double, PixelToNum, ignore,
            double, ignore, ignore,
            double, ignore, ignore,
            PixelDouble);
DM_TYPECONV(PixelYDouble,
            0,
            0,
            double, ignore, ignore, ignore,
            double, PixelYToNum, ignore,
            double, ignore, ignore,
            double, ignore, ignore,
            PixelYDouble);
DM_TYPECONV(DegreesDouble,
            0,
            0,
            double, ignore, ignore, ignore,
            double, DegreesToNum, ignore,
            double, ignore, ignore,
            double, ignore, ignore,
            DegreesDouble);
DM_TYPECONV(DoubleValue,
            0,
            0,
            double, DoubleToNumBvr, ignore, ignore,
            double, ignore, error,
            double, ignore, ignore,
            double, ignore, ignore,
            DoubleValue);
DM_TYPECONV(Rate,
            0,
            0,
            CRNumber, GetBvr, ignore, ignore,
            double, RateToNumBvr, error,
            double, ignore, ignore,
            CRNumber, ignore, ignore,
            RateValue);
DM_TYPECONV(ScaleRate,
            0,
            0,
            CRNumber, GetBvr, ignore, ignore,
            double, ScaleRateToNumBvr, error,
            double, ignore, ignore,
            CRNumber, ignore, ignore,
            ScaleRateValue);
DM_TYPECONV(RateDegrees,
            0,
            0,
            CRNumber, GetBvr, ignore, ignore,
            double, RateDegreesToNumBvr, error,
            double, ignore, ignore,
            CRNumber, ignore, ignore,
            RateDegreesValue);
DM_TYPECONV(Degrees,
            0,
            0,
            double, DoubleToNumBvr, ignore, ignore,
            double, DegreesToNum, error,
            double, ignore, ignore,
            double, ignore, ignore,
            DegreesValue);
DM_TYPECONV(Pixels,
            0,
            0,
            double, DoubleToNumBvr, ignore, ignore,
            double, PixelToNum, error,
            double, ignore, ignore,
            double, ignore, ignore,
            PixelValue);
DM_TYPECONV(RatePixels,
            0,
            0,
            CRNumber, GetBvr, ignore, ignore,
            double, RatePixelToNumBvr, error,
            double, ignore, ignore,
            CRNumber, ignore, ignore,
            RatePixelValue);
DM_TYPECONV(AnimPixel,
            1,
            1,
            CRNumber, ignore, ignore, ignore,
            Number, PixelToNumBvr, error,
            NumberBvr, ignore, ignore,
            CRNumber, ignore, ignore,
            AnimPixelValue);
DM_TYPECONV(PixelYs,
            0,
            0,
            double, DoubleToNumBvr, ignore, ignore,
            double, PixelYToNum, error,
            double, ignore, ignore,
            double, ignore, ignore,
            PixelYValue);
DM_TYPECONV(RatePixelYs,
            0,
            0,
            CRNumber, GetBvr, ignore, ignore,
            double, RatePixelYToNumBvr, error,
            double, ignore, ignore,
            CRNumber, ignore, ignore,
            RatePixelYValue);
DM_TYPECONV(AnimPixelY,
            1,
            0,
            CRNumber, ignore, ignore, ignore,
            Number, PixelYToNumBvr, error,
            NumberBvr, ignore, ignore,
            CRNumber, ignore, ignore,
            AnimPixelYValue);
DM_TYPECONV(Points,
            0,
            0,
            double, DoubleToNumBvr, ignore, ignore,
            double, PointToNum, error,
            double, ignore, ignore,
            double, ignore, ignore,
            PointValue);
DM_TYPECONV(AnimPoint,
            1,
            0,
            CRNumber, GetBvr, ignore, ignore,
            Number, PointToNumBvr, error,
            NumberBvr, ignore, ignore,
            CRNumber, ignore, ignore,
            AnimPointValue);
DM_TYPECONV(long,
            0,
            0,
            long, ignore, ignore, ignore,
            long, ignore, ignore,
            int, ignore, ignore,
            long, ignore, ignore,
            long);
DM_TYPECONV(DWORD,
            0,
            0,
            DWORD, ignore, ignore, ignore,
            DWORD, ignore, ignore,
            int, ignore, ignore,
            DWORD, ignore, ignore,
            DWORD);
DM_TYPECONV(short,
            0,
            0,
            short, ignore, ignore, ignore,
            short, ignore, ignore,
            int, ignore, ignore,
            short, ignore, ignore,
            short);
DM_TYPECONV(BYTE,
            0,
            0,
            BYTE, ignore, ignore, ignore,
            BYTE, ignore, ignore,
            byte, ignore, ignore,
            BYTE, ignore, ignore,
            BYTE);
DM_TYPECONV(LongValue,
            0,
            0,
            long, LongToBvr, AxALongToLong, ignore,
            long, ignore, ignore,
            int, ignore, ignore,
            long, ignore, ignore,
            AxALong *);
DM_TYPECONV(RGBComponent,
            0,
            0,
            short, RGBToNumBvr, error, ignore,
            short, ignore, error,
            short, ignore, ignore,
            short, ignore, ignore,
            RGBComponent);
DM_TYPECONV(string,
            0,
            0,
            LPWSTR, ignore, error, ignore,
            BSTR, ignore, StringToBSTR,
            String, ignore, ignore,
            LPWSTR, ignore, error,
            RawString);
DM_TYPECONV(widestring,
            0,
            0,
            LPWSTR, ignore, ignore, ignore,
            BSTR, ignore, WideStringToBSTR,
            String, ignore, ignore,
            LPWSTR, ignore, ignore,
            WideString);
DM_TYPECONV(StringValue,
            0,
            0,
            LPWSTR, LPWSTRToStrBvr, error, ignore,
            BSTR, ignore, error,
            String, ignore, ignore,
            LPWSTR, ignore, error,
            StringValue);

DM_TYPECONV(VariantValue,
            0,
            0,
            VARIANT, VARIANTToVariantBvr, error, ignore,
            VARIANT, ignore, error,
            Variant, ignore, ignore,
            VARIANT, ignore, error,
            VariantValue);

DM_TYPECONV(bstr,
            0,
            0,
            BSTR, ignore, ignore, ignore,
            BSTR, ignore, ignore,
            String, ignore, ignore,
            BSTR, ignore, ignore,
            BSTR);
DM_TYPECONV(realboolean,
            0,
            0,
            bool, ignore, ignore, ignore,
            VARIANT_BOOL, BOOLTobool, boolToBOOL,
            boolean, ignore, ignore,
            bool, ignore, ignore,
            bool);
DM_TYPECONV(BoolValue,
            0,
            0,
            bool, BoolToBvr, error, ignore,
            VARIANT_BOOL, BOOLTobool, error,
            boolean, ignore, ignore,
            bool, ignore, ignore,
            BoolValue);
DM_TYPECONV(untilnotifier,
            0,
            1,
            CRUntilNotifier *, WrapUntilNotifier, error, ignore,
            IDAUntilNotifier *, WrapCRUntilNotifier, error,
            UntilNotifier, new UntilNotifierCB, error,
            CRUntilNotifier *, ignore, error,
            UntilNotifier *);
DM_TYPECONV(UserDataCB,
            0,
            1,
            IUnknown *, ignore, ignore, ignore,
            IUnknown *, ignore, ignore,
            IUnknown, ignore, ignore,
            IUnknown *, ignore, ignore,
            LPUNKNOWN);
DM_TYPECONV(ipickableresult,
            0,
            1,
            CRPickableResult *, ignore, ignore, ignore,
            IDAPickableResult *, WrapCRPickableResult, ignore,
            IDAPickableResult, ignore, ignore,
            CRPickableResult *, ignore, ignore,
            PickableResultPtr);
DM_TYPECONV(unit,
            1,
            0,
            CRBvr, ignore, ignore, ignore,
            Behavior, ignore, ignore,
            Behavior, ignore, ignore,
            CRBvr, ignore, ignore,
            AxATrivial *);
DM_TYPECONV(value,
            1,
            0,
            CRBvr, ignore, ignore, ignore,
            Behavior, ignore, ignore,
            Behavior, ignore, ignore,
            CRBvr, ignore, ignore,
            AxAValue *);
DM_TYPECONV(keycode,
            0,
            0,
            LONG, ignore, ignore, ignore,
            LONG, ignore, ignore,
            int, ViewEventCB.JavaToDXMKey,ignore,
            LONG, ignore, ignore,
            KeyCode);
        
//DM_TYPECONST(AxANumber, DoubleValue);
//DM_TYPECONST(AxAString, StringValue);
//DM_TYPECONST(AxABoolean, BoolValue);

class ImageDisplayDev;

#endif /* _AVRTYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\axapair.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Declare pair primitives

*******************************************************************************/


#ifndef _PAIR_H
#define _PAIR_H

DM_NOELEVPROP(first,
              CRFirst,
              First,
              first,
              PairBvr,
              First,
              p,
              AxAValue *FirstBvr(AxAPair *p)); 

DM_NOELEVPROP(second,
              CRSecond,
              Second,
              second,
              PairBvr,
              Second,
              p,
              AxAValue *SecondBvr(AxAPair *p)); 

#endif /* _PAIR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\arith.h ===
#ifndef _ARITH_H
#define _ARITH_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    This file contains general arithmetic utility functions that take
    and return pointers to reals.

--*/

#include "appelles/common.h"
#include "backend/values.h"

// These are restatements of the operator functions as regular functions, so
// that active functions can be generated from them.

// Binary operators
DM_INFIX(^,
         CRPow,
         Pow,
         pow,
         NumberBvr,
         CRPow,
         NULL,
         AxANumber *RealPower    (AxANumber *a, AxANumber *b));

// Unary functions
DM_FUNC(abs,
        CRAbs,
        Abs,
        abs,
        NumberBvr,
        CRAbs,
        NULL,
        AxANumber *RealAbs     (AxANumber *a));
DM_FUNC(sqrt,
        CRSqrt,
        Sqrt,
        sqrt,
        NumberBvr,
        CRSqrt,
        NULL,
        AxANumber *RealSqrt    (AxANumber *a));
DM_FUNC(floor,
        CRFloor,
        Floor,
        floor,
        NumberBvr,
        CRFloor,
        NULL,
        AxANumber *RealFloor   (AxANumber *a));
DM_FUNC(round,
        CRRound,
        Round,
        round,
        NumberBvr,
        CRRound,
        NULL,
        AxANumber *RealRound   (AxANumber *a));
DM_FUNC(ceiling,
        CRCeiling,
        Ceiling,
        ceiling,
        NumberBvr,
        CRCeiling,
        NULL,
        AxANumber *RealCeiling (AxANumber *a));
DM_FUNC(asin,
        CRAsin,
        Asin,
        asin,
        NumberBvr,
        CRAsin,
        NULL,
        AxANumber *RealAsin    (AxANumber *a));
DM_FUNC(acos,
        CRAcos,
        Acos,
        acos,
        NumberBvr,
        CRAcos,
        NULL,
        AxANumber *RealAcos    (AxANumber *a));
DM_FUNC(atan,
        CRAtan,
        Atan,
        atan,
        NumberBvr,
        CRAtan,
        NULL,
        AxANumber *RealAtan    (AxANumber *a));
DM_FUNC(sin,
        CRSin,
        Sin,
        sin,
        NumberBvr,
        CRSin,
        NULL,
        AxANumber *RealSin     (AxANumber *a));
DM_FUNC(cos,
        CRCos,
        Cos,
        cos,
        NumberBvr,
        CRCos,
        NULL,
        AxANumber *RealCos     (AxANumber *a));
DM_FUNC(tan,
        CRTan,
        Tan,
        tan,
        NumberBvr,
        CRTan,
        NULL,
        AxANumber *RealTan     (AxANumber *a));
DM_FUNC(exp,
        CRExp,
        Exp,
        exp,
        NumberBvr,
        CRExp,
        NULL,
        AxANumber *RealExp     (AxANumber *a));
DM_FUNC(ln,
        CRLn,
        Ln,
        ln,
        NumberBvr,
        CRLn,
        NULL,
        AxANumber *RealLn      (AxANumber *a));
DM_FUNC(log10,
        CRLog10,
        Log10,
        log10,
        NumberBvr,
        CRLog10,
        NULL,
        AxANumber *RealLog10   (AxANumber *a));

DM_FUNC(toDegrees,
        CRToDegrees,
        ToDegrees,
        radiansToDegrees,
        NumberBvr,
        CRToDegrees,
        NULL,
        AxANumber *RealRadToDeg(AxANumber *a));
DM_FUNC(toRadians,
        CRToRadians,
        ToRadians,
        degreesToRadians,
        NumberBvr,
        CRToRadians,
        NULL,
        AxANumber *RealDegToRad(AxANumber *a));

// Binary functions
DM_FUNC(mod,
        CRMod,
        Mod,
        mod,
        NumberBvr,
        CRMod,
        NULL,
        AxANumber *RealModulus(AxANumber *a, AxANumber *b));
DM_FUNC(atan,
        CRAtan2,
        Atan2,
        atan2,
        NumberBvr,
        CRAtan2,
        NULL,
        AxANumber *RealAtan2(AxANumber *a, AxANumber *b));

// Internal functions for implementing randoms, which will go into an
// ActiveVRML "pervasives" module.  Note that this "unit" really
// carries data in it, used internally in pervasiv.axa to pass to the
// next function.
AxAValue PRIVRandomNumSequence(AxANumber *val);

extern AxANumber *PRIVRandomNumSampler(AxAValue seq, AxANumber *dummy);

extern AxAValue RandomNumSequence(double val);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\axachstr.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Interface for the string/char primitive functions

*******************************************************************************/


#ifndef _AXACHSTR_H
#define _AXACHSTR_H

// *************************************
// * string primitives 
// *************************************

DM_INFIX(&,
         CRConcatString,
         ConcatString,
         concat,
         StringBvr,
         CRConcatString,
         NULL,
         AxAString * Concat(AxAString *s1, AxAString *s2));

#endif /* _AXACHSTR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\axaprims.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    AxA Primitives for the elevation tool

*******************************************************************************/


#ifndef _AXAPRIMS_H
#define _AXAPRIMS_H

// Binary operators TODO: Should eventually in arith.h
DM_INFIX(+,
         CRAdd,
         Add,
         add,
         NumberBvr,
         CRAdd,
         NULL,
         AxANumber *RealAdd      (AxANumber *a, AxANumber *b));
DM_INFIX(-,
         CRSub,
         Sub,
         sub,
         NumberBvr,
         CRSub,
         NULL,
         AxANumber *RealSubtract (AxANumber *a, AxANumber *b));
DM_INFIX(*,
         CRMul,
         Mul,
         mul,
         NumberBvr,
         CRMul,
         NULL,
         AxANumber *RealMultiply (AxANumber *a, AxANumber *b));
DM_INFIX(/,
         CRDiv,
         Div,
         div,
         NumberBvr,
         CRDiv,
         NULL,
         AxANumber *RealDivide   (AxANumber *a, AxANumber *b));

DM_INFIX(<,
         CRLT,
         LT,
         lt,
         NumberBvr,
         CRLT,
         NULL,
         AxABoolean *RealLT       (AxANumber *a, AxANumber *b));
DM_INFIX(<=,
         CRLTE,
         LTE,
         lte,
         NumberBvr,
         CRLTE,
         NULL,
         AxABoolean *RealLTE      (AxANumber *a, AxANumber *b));
DM_INFIX(>,
         CRGT,
         GT,
         gt,
         NumberBvr,
         CRGT,
         NULL,
         AxABoolean *RealGT       (AxANumber *a, AxANumber *b));
DM_INFIX(>=,
         CRGTE,
         GTE,
         gte,
         NumberBvr,
         CRGTE,
         NULL,
         AxABoolean *RealGTE      (AxANumber *a, AxANumber *b));
DM_INFIX(==,
         CREQ,
         EQ,
         eq,
         NumberBvr,
         CREQ,
         NULL,
         AxABoolean *RealEQ       (AxANumber *a, AxANumber *b));
DM_INFIX(!=,
         CRNE,
         NE,
         ne,
         NumberBvr,
         CRNE,
         NULL,
         AxABoolean *RealNE       (AxANumber *a, AxANumber *b));

DM_FUNC(~,
        CRNeg,
        Neg,
        neg,
        NumberBvr,
        CRNeg,
        NULL,
        AxANumber *RealNegate  (AxANumber *a));

DM_NOELEV(ignore,
          CRInterpolate,
          InterpolateAnim,
          interpolate,
          NumberBvr,
          CRInterpolate,
          NULL,
          AxANumber *InterpolateBvr(AxANumber *from,
                                    AxANumber *to,
                                    AxANumber *duration));

DM_NOELEV(ignore,
          CRInterpolate,
          Interpolate,
          interpolate,
          NumberBvr,
          CRInterpolate,
          NULL,
          AxANumber *InterpolateBvr(DoubleValue *from,
                                    DoubleValue *to,
                                    DoubleValue *duration));

DM_NOELEV(ignore,
          CRSlowInSlowOut,
          SlowInSlowOutAnim,
          slowInSlowOut,
          NumberBvr,
          CRSlowInSlowOut,
          NULL,
          AxANumber *SlowInSlowOutBvr(AxANumber *from,
                                      AxANumber *to,
                                      AxANumber *duration,
                                      AxANumber *sharpness));

DM_NOELEV(ignore,
          CRSlowInSlowOut,
          SlowInSlowOut,
          slowInSlowOut,
          NumberBvr,
          CRSlowInSlowOut,
          NULL,
          AxANumber *SlowInSlowOutBvr(DoubleValue *from,
                                      DoubleValue *to,
                                      DoubleValue *duration,
                                      DoubleValue *sharpness));

// This is a hack so that the elevator tool would set the MAX_ARGS
// correctly. 
DM_FUNC(ignore,
        ignore,
        ignore,
        ignore,
        ignore,
        ignore,
        NULL,
        AxANumber *Dummy(DoubleValue *from,
                         DoubleValue *to,
                         DoubleValue *duration,
                         DoubleValue *sharpness,
                         DoubleValue *time));
          

extern Bvr MakeRenderedSound(Bvr geom, Bvr mic);

DM_BVRFUNC(render,
           CRRenderSound,
           RenderSound,
           render,
           GeometryBvr,
           RenderSound,
           geom,
           Sound* MakeRenderedSound(Geometry* geom, Microphone* mic));

extern Bvr MakeSoundSource (Bvr snd);

DM_BVRFUNC(soundSource,
           CRSoundSource,
           SoundSource,
           soundSource,
           GeometryBvr,
           CRSoundSource,
           NULL,
           Geometry* MakeSoundSource(Sound* snd));         

extern Bvr SoundMix(Bvr sndLeft, Bvr sndRight);

DM_BVRFUNC(mix,
           CRMix,
           Mix,
           mix,
           SoundBvr,
           CRMix,
           NULL,
           Sound* SoundMix(Sound* left, Sound* right));

DM_FUNC(and,
        CRAnd,
        And,
        and,
        BooleanBvr,
        CRAnd,
        NULL,
        AxABoolean *BoolAnd(AxABoolean *a, AxABoolean *b));

DM_FUNC(or,
        CROr,
        Or,
        or,
        BooleanBvr,
        CROr,
        NULL,
        AxABoolean *BoolOr(AxABoolean *a, AxABoolean *b));

DM_FUNC(not,
        CRNot,
        Not,
        not,
        BooleanBvr,
        CRNot,
        NULL,
        AxABoolean *BoolNot(AxABoolean *a));

extern Bvr IntegralBvr(Bvr b);

DM_BVRFUNC(ignore,
           CRIntegral,
           Integral,
           integral,
           NumberBvr,
           CRIntegral,
           NULL,
           AxANumber *IntegralBvr(AxANumber *b));

extern Bvr DerivBvr(Bvr b);

DM_BVRFUNC(ignore,
           CRDerivative,
           Derivative,
           derivative,
           NumberBvr,
           CRDerivative,
           NULL,
           AxANumber *DerivBvr(AxANumber *b));

extern Bvr IntegralVector2(Bvr v);

DM_BVRFUNC(ignore,
           CRIntegral,
           IntegralVector2,
           integral,
           Vector2Bvr,
           CRIntegral,
           NULL,
           Vector2Value *IntegralVector2(Vector2Value *v));

extern Bvr IntegralVector3(Bvr v);

DM_BVRFUNC(ignore,
           CRIntegral,
           IntegralVector3,
           integral,
           Vector3Bvr,
           CRIntegral,
           NULL,
           Vector3Value *IntegralVector3(Vector3Value *v));

extern Bvr DerivVector2(Bvr v);

DM_BVRFUNC(ignore,
           CRDerivative,
           DerivativeVector2,
           derivative,
           Vector2Bvr,
           CRDerivative,
           NULL,
           Vector2Value *DerivVector2(Vector2Value *v));

extern Bvr DerivVector3(Bvr v);

DM_BVRFUNC(ignore,
           CRDerivative,
           DerivativeVector3,
           derivative,
           Vector3Bvr,
           CRDerivative,
           NULL,
           Vector3Value *DerivVector3(Vector3Value *v));

extern Bvr DerivPoint2(Bvr v);

DM_BVRFUNC(ignore,
           CRDerivative,
           DerivativePoint2,
           derivative,
           Point2Bvr,
           CRDerivative,
           NULL,
           Vector2Value *DerivPoint2(Point2Value *v));

extern Bvr DerivPoint3(Bvr v);

DM_BVRFUNC(ignore,
           CRDerivative,
           DerivativePoint3,
           derivative,
           Point3Bvr,
           CRDerivative,
           NULL,
           Vector3Value *DerivPoint3(Point3Value *v));

extern Bvr KeyStateBvr(Bvr k);

DM_BVRFUNC(ignore, // keyState
           CRKeyState,
           KeyState,
           ignore,
           ignore,
           CRKeyState,
           NULL,
           AxABoolean *KeyStateBvr(AxANumber *n));

DM_NOELEV(ignore,
          CRKeyUp,
          KeyUp,
          keyUp,
          ignore,
          CRKeyUp,
          NULL,
          AxAEData KeyUp(KeyCode));

DM_NOELEV(ignore,
          CRKeyDown,
          KeyDown,
          keyDown,
          ignore,
          CRKeyDown,
          NULL,
          AxAEData KeyDown(KeyCode));

DM_NOELEV(ignore,
          CRCreateNumber,
          DANumber,
          toBvr,
          NumberBvr,
          CRCreateNumber,
          NULL,
          AxANumber *NumToBvr(double num));

DM_NOELEV(ignore,
          CRCreateString,
          DAString,
          toBvr,
          StringBvr,
          CRCreateString,
          NULL,
          AxAString *StringToBvr(WideString str));

DM_NOELEV(ignore,
          CRCreateBoolean,
          DABoolean,
          toBvr,
          BooleanBvr,
          CRCreateBoolean,
          NULL,
          AxABoolean *BoolToBvr(bool num));

DM_NOELEV(ignore,
          CRExtract,
          Extract,
          ignore,
          NumberBvr,
          CRExtract,
          num,
          double ExtractNum(AxANumber num));

DM_NOELEV(ignore,
          CRSeededRandom,
          SeededRandom,
          seededRandom,
          NumberBvr,
          CRSeededRandom,
          NULL,
          AxANumber *SeededRandom(double));

DM_NOELEV(ignore,
          CRExtract,
          Extract,
          ignore,
          StringBvr,
          Extract,
          str,
          WideString ExtractString(AxAString str));

DM_NOELEV(ignore,
          CRExtract,
          Extract,
          ignore,
          BooleanBvr,
          Extract,
          b,
          bool ExtractBool(AxABoolean b));

DM_NOELEV(ignore,
          CRNth,
          NthAnim,
          nth,
          ArrayBvr,
          Nth,
          arr,
          AxATrivial *Nth(AxAArray *arr, AxANumber *index));

DM_FUNC(ignore,
        CRLength,
        Length,
        length,
        ArrayBvr,
        Length,
        arr,
        AxANumber* ArrayLength(AxAArray *arr));

DM_NOELEV(ignore,
          CRNth,
          Nth,
          nth,
          TupleBvr,
          Nth,
          t,
          AxATrivial *Nth(Tuple *t, long index));

DM_NOELEVPROP(ignore,
              CRLength,
              Length,
              length,
              TupleBvr,
              Length,
              t,
              long TupleLength(Tuple *t));

extern Bvr mousePosition;

DM_BVRVAR(mousePosition,
          CRMousePosition,
          MousePosition,
          mousePosition,
          ignore,
          CRMousePosition,
          Point2Value *mousePosition);

extern Bvr leftButtonState;

DM_BVRVAR(leftButtonState,
          CRLeftButtonState,
          LeftButtonState,
          leftButtonState,
          ignore,
          CRLeftButtonState,
          AxABoolean *leftButtonState);

extern Bvr rightButtonState;

DM_BVRVAR(rightButtonState,
          CRRightButtonState,
          RightButtonState,
          rightButtonState,
          ignore,
          CRRightButtonState,
          AxABoolean *rightButtonState);

extern Bvr trueBvr;

DM_BVRVAR(true,
          CRTrue,
          DATrue,
          trueBvr,
          BooleanBvr,
          CRTrue,
          AxABoolean *trueBvr);

extern Bvr falseBvr;

DM_BVRVAR(false,
          CRFalse,
          DAFalse,
          falseBvr,
          BooleanBvr,
          CRFalse,
          AxABoolean *falseBvr);

extern Bvr timeBvr;

DM_BVRVAR(localTime,
          CRLocalTime,
          LocalTime,
          localTime,
          NumberBvr,
          CRLocalTime,
          AxANumber *timeBvr);

extern Bvr globalTimeBvr;

DM_BVRVAR(globalTime,
          CRGlobalTime,
          GlobalTime,
          globalTime,
          NumberBvr,
          CRGlobalTime,
          AxANumber *globalTimeBvr);

extern Bvr pixelBvr;

DM_BVRVAR(pixel,
          CRPixel,
          Pixel,
          pixel,
          NumberBvr,
          CRPixel,
          AxANumber *pixelBvr);

DM_NOELEV(userdata,
          CRCreateUserData,
          UserData,
          ignore,
          ignore,
          CRCreateUserData,
          NULL,
          UserData MakeUserData(LPUNKNOWN data));

DM_NOELEVPROP(getdata,
              CRGetData,
              Data,
              ignore,
              ignore,
              GetData,
              data,
              LPUNKNOWN GetUserData(UserData data));

DM_NOELEV(ignore,
          CRUntilNotify,
          UntilNotify,
          untilNotify,
          DXMEvent,
          CRUntilNotify,
          NULL,
          AxATrivial * JaxaUntil(AxATrivial *b0,
                                 AxAEData *event,
                                 UntilNotifier * notifier));

DM_NOELEV(ignore,
          CRUntil,
          Until,
          until,
          ignore,
          CRUntil,
          NULL,
          AxATrivial * Until3(AxATrivial *b0,
                              AxAEData *event,
                              AxATrivial * b1));

DM_NOELEV(ignore,
          CRUntilEx,
          UntilEx,
          untilEx,
          ignore,
          CRUntilEx,
          NULL,
          AxATrivial * Until(AxATrivial *b0,
                             AxAEData *event));

DM_NOELEV(ignore,
          CRSequence,
          Sequence,
          sequence,
          ignore,
          CRSequence,
          NULL,
          AxATrivial *Sequence(AxATrivial *s1, AxATrivial *s2));

// The C Decl is dummy for the time being.
DM_COMFUN(ignore,
          CRPickable,
          Pickable,
          Pickable,
          img,
          PickableResultPtr PickableImage(Image *img));

DM_COMFUN(ignore,
          CRPickable,
          Pickable,
          Pickable,
          geom,
          PickableResultPtr PickableGeometry(Geometry *geom));

DM_COMFUN(ignore,
          CRPickableOccluded,
          PickableOccluded,
          PickableOccluded,
          img,
          PickableResultPtr PickableOccludedImage(Image *img));

DM_COMFUN(ignore,
          CRPickableOccluded,
          PickableOccluded,
          PickableOccluded,
          geom,
          PickableResultPtr PickableOccludedGeometry(Geometry *geom));

extern Bvr FollowPath(Bvr path2, double duration);

DM_BVRFUNC(ignore,
           CRFollowPath,
           FollowPath,
           followPath,
           Path2Bvr,
           CRFollowPath,
           NULL,
           Transform2 *FollowPath(Path2 *path, double duration));

extern Bvr FollowPathAngle(Bvr path2, double duration);

DM_BVRFUNC(ignore,
           CRFollowPathAngle,
           FollowPathAngle,
           followPathAngle,
           Path2Bvr,
           CRFollowPathAngle,
           NULL,
           Transform2 *FollowPathAngle(Path2 *path, double duration));

extern Bvr FollowPathAngleUpright(Bvr path2, double duration);

DM_BVRFUNC(ignore,
           CRFollowPathAngleUpright,
           FollowPathAngleUpright,
           followPathAngleUpright,
           Path2Bvr,
           CRFollowPathAngleUpright,
           NULL,
           Transform2 *FollowPathAngleUpright(Path2 *path, double duration));

extern Bvr FollowPathEval(Bvr path2, Bvr eval);

DM_BVRFUNC(ignore,
           CRFollowPathEval,
           FollowPathEval,
           followPath,
           Path2Bvr,
           CRFollowPathEval,
           NULL,
           Transform2 *FollowPathEval(Path2 *path, AxANumber *eval));

extern Bvr FollowPathAngleEval(Bvr path2, Bvr eval);

DM_BVRFUNC(ignore,
           CRFollowPathAngleEval,
           FollowPathAngleEval,
           followPathAngle,
           Path2Bvr,
           CRFollowPathAngleEval,
           NULL,
           Transform2 *FollowPathAngleEval(Path2 *path, AxANumber *eval));

extern Bvr FollowPathAngleUprightEval(Bvr path2, Bvr eval);

DM_BVRFUNC(ignore,
           CRFollowPathAngleUprightEval,
           FollowPathAngleUprightEval,
           followPathAngleUpright,
           Path2Bvr,
           CRFollowPathAngleUprightEval,
           NULL,
           Transform2 *FollowPathAngleUprightEval(Path2 *path, AxANumber *eval));

DM_COMFUN(ignore,
          ignore,
          AnimateProperty,
          ignore,
          num,
          AxANumber *FunctionNameDoesntMatter(AxANumber *num,
                                              WideString propertyPath,
                                              WideString scriptingLanguage,
                                              bool invokeAsMethod,
                                              double minUpdateInterval));

DM_COMFUN(ignore,
          ignore,
          AnimateProperty,
          ignore,
          str,
          AxAString *FunctionNameDoesntMatter(AxAString *str,
                                              WideString propertyPath,
                                              WideString scriptingLanguage,
                                              bool invokeAsMethod,
                                              double minUpdateInterval));

DM_COMFUN(ignore,
          ignore,
          AnimateControlPosition,
          ignore,
          pt,
          Point2Value *FunctionNameDoesntMatter(Point2Value *pt,
                                           WideString propertyPath,
                                           WideString scriptingLanguage,
                                           bool invokeAsMethod,
                                           double minUpdateInterval));

DM_COMFUN(ignore,
          ignore,
          AnimateControlPositionPixel,
          ignore,
          pt,
          Point2Value *FunctionNameDoesntMatter(Point2Value *pt,
                                           WideString propertyPath,
                                           WideString scriptingLanguage,
                                           bool invokeAsMethod,
                                           double minUpdateInterval));

DM_COMFUN(ignore,
          ignore,
          ApplyBitmapEffect,
          ignore,
          inputImage,
          Image *FunctionNameDoesntMatter(Image *inputImage,
                                          LPUNKNOWN effectToApply,
                                          AxAEData *firesWhenChanged));


/////////////  OBSOLETED FUNCTIONS


DM_BVRFUNC(ignore,
           CRFollowPath,
           FollowPathAnim,
           ignore,
           Path2Bvr,
           CRFollowPath,
           NULL,
           Transform2 *FollowPathEval(Path2 *obsoleted1,
                                      AxANumber *obsoleted2));

DM_BVRFUNC(ignore,
           CRFollowPathAngle,
           FollowPathAngleAnim,
           ignore,
           Path2Bvr,
           CRFollowPathAngle,
           NULL,
           Transform2 *FollowPathAngleEval(Path2 *obsoleted1,
                                           AxANumber *obsoleted2));

DM_BVRFUNC(ignore,
           CRFollowPathAngleUpright,
           FollowPathAngleUprightAnim,
           ignore,
           Path2Bvr,
           CRFollowPathAngleUpright,
           NULL,
           Transform2 *FollowPathAngleUprightEval(Path2 *obsoleted1,
                                                  AxANumber *obsoleted2));

DMAPI_DECL2((DM_NOELEV2,
             ignore,
             CRAddPickData,
             AddPickData,
             ignore,
             ImageBvr,
             AddPickData,
             img),
            Image *ImageAddId(Image *img, LPUNKNOWN id, bool ignoresOcclusion));

DMAPI_DECL2((DM_NOELEV2,
             ignore,
             CRAddPickData,
             AddPickData,
             ignore,
             GeometryBvr,
             AddPickData,
             geo),
            Geometry *GeometryAddId(Geometry *geo, LPUNKNOWN id, bool ignoresOcclusion));

DMAPI_DECL2((DM_NOELEV2,
             ignore,
             ignore,
             UntilNotifyScript,
             ignore,
             ignore,
             ignore,
             NULL),
            AxATrivial * UntilNotifyScript(AxATrivial *b0,
                                           AxAEData *event,
                                           BSTR scriptlet));
DMAPI_DECL2((DM_NOELEV2,
             ignore,
             CRAddElement,
             AddElement,
             addElement,
             ArrayBvr,
             AddElement,
             arr),
            long ArrayAddElement(AxAArray *arr, AxATrivial *b, DWORD flag));

DMAPI_DECL2((DM_NOELEV2,
             ignore,
             CRRemoveElement,
             RemoveElement,
             removeElement,
             ArrayBvr,
             RemoveElement,
             arr),
            void ArrayRemoveElement(AxAArray *arr, long i));

#endif /* _AXAPRIMS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\bbox2.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    2D rectangular axis-aligned bounding volumes.

*******************************************************************************/

#ifndef _BBOX2_H
#define _BBOX2_H

#include "appelles/common.h"
#include "appelles/valued.h"
#include "appelles/xform2.h"
#include "appelles/vec2.h"



    /********************************/
    /***  Constanct Declarations  ***/
    /********************************/

    // The universe box contains everything.

extern Bbox2Value *nullBbox2;

    // The null box contains nothing.

extern Bbox2Value *universeBbox2;

    // This bbox spans [0,0] to [1,1]
extern Bbox2Value *unitBbox2;

    /*******************************/
    /***  Function Declarations  ***/
    /*******************************/

    // Bounding Box Query

DM_PROP (min,
         CRMin,
         Min,
         getMin,
         Bbox2Bvr,
         Min,
         box,
         Point2Value *MinBbox2(Bbox2Value *box));

DM_PROP (max,
         CRMax,
         Max,
         getMax,
         Bbox2Bvr,
         Max,
         box,
         Point2Value *MaxBbox2(Bbox2Value *box));

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\bbox3.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Functions on 3D bounding boxes

*******************************************************************************/


#ifndef _BBOX3_H
#define _BBOX3_H

#include "appelles/common.h"
#include "appelles/valued.h"
#include "appelles/vec3.h"

DM_PROP (min,
         CRMin,
         Min,
         getMin,
         Bbox3Bvr,
         Min,
         box,
         Point3Value *MinBbox3(Bbox3 *box));

DM_PROP (max,
         CRMax,
         Max,
         getMax,
         Bbox3Bvr,
         Max,
         box,
         Point3Value *MaxBbox3(Bbox3 *box));


#endif /* _BBOX3_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\bspline.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    B-spline animation paths

*******************************************************************************/


#ifndef _BSPLINE_H
#define _BSPLINE_H

#include "backend/values.h"

Bvr ConstructBSplineBvr(int degree,
                        long numPts,
                        Bvr *knots,
                        Bvr *points,
                        Bvr *weights,
                        Bvr evaluator,
                        DXMTypeInfo tinfo);

#endif /* _BSPLINE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\camera.h ===
#ifndef _AV_CAMERA_H
#define _AV_CAMERA_H

/*******************************************************************************
Copyright (c) 1995-96  Microsoft Corporation

    This file contains the declarations for the camera model.  The current
camera model takes only transforms for attribution, which affects the position,
orientation, and focal length of the camera.  All cameras are described as
transformations of a canonical camera.

*******************************************************************************/

#include "appelles/common.h"
#include "appelles/xform.h"

    // The perspective camera takes two values: the distance from the origin
    // of the focal point, and the distance from the origin of the near clip
    // plane.  The camera is sized to make Z=0 appear to be the projection
    // plane, where objects appear actual size.

DM_FUNC (ignore,
         CRPerspectiveCamera,
         PerspectiveCamera,
         perspectiveCamera,
         CameraBvr,
         CRPerspectiveCamera,
         NULL,
         Camera *PerspectiveCamera (DoubleValue *focalDist, DoubleValue *nearClip));


DM_FUNC (perspectiveCamera,
         CRPerspectiveCameraAnim,
         PerspectiveCameraAnim,
         perspectiveCamera,
         CameraBvr,
         CRPerspectiveCameraAnim,
         NULL,
         Camera *PerspectiveCamera (AxANumber *focalDist, AxANumber *nearClip));

    // The parallel camera is located at the origin, gazing down -Z, with
    // the +Y vector pointing up.  It uses parallel projection, and takes as
    // its single parameter the Z of the near clip plane.  Points whose Z
    // coordinate are greater than the nearClip are not visible to this camera.

DM_FUNC (ignore,
         CRParallelCamera,
         ParallelCamera,
         parallelCamera,
         CameraBvr,
         CRParallelCamera,
         NULL,
         Camera *ParallelCamera (DoubleValue *nearClip));

DM_FUNC (parallelCamera,
         CRParallelCameraAnim,
         ParallelCameraAnim,
         parallelCamera,
         CameraBvr,
         CRParallelCameraAnim,
         NULL,
         Camera *ParallelCamera (AxANumber *nearClip));

    // The transformCamera attributer takes a 3D transform and a camera and
    // returns a new camera with the given transform.

DM_FUNC (transform,
         CRTransform,
         Transform,
         transform,
         CameraBvr,
         Transform,
         cam,
         Camera *TransformCamera (Transform3 *xf, Camera *cam));

    // This function takes a camera and a number and returns a camera with the
    // depth clip set to that value.  In other words, the far clip will be set
    // to the near clip plus the depth.

DM_FUNC (ignore,
         CRDepth,
         Depth,
         depth,
         CameraBvr,
         Depth,
         cam,
         Camera *Depth (DoubleValue *depth, Camera *cam));

DM_FUNC (depth,
         CRDepth,
         DepthAnim,
         depth,
         CameraBvr,
         Depth,
         cam,
         Camera *Depth (AxANumber *depth, Camera *cam));

    // This function takes a camera and a number and returns a camera with the
    // depth set so that depth is maximized and a minimum depth resolution of
    // the given units (camera coordinates) is met.  For example, calling this
    // with 1mm will yield a depth clip so that surfaces 1mm apart are
    // guaranteed to appear at different depths when rendered.

DM_FUNC (ignore,
         CRDepthResolution,
         DepthResolution,
         depthResolution,
         CameraBvr,
         DepthResolution,
         cam,
         Camera *DepthResolution (DoubleValue *resolution, Camera *cam));

DM_FUNC (depthResolution,
         CRDepthResolution,
         DepthResolutionAnim,
         depthResolution,
         CameraBvr,
         DepthResolution,
         cam,
         Camera *DepthResolution (AxANumber *resolution, Camera *cam));

    // This function projects a point from 3-space (world coordinates) to
    // 2-space (camera-plane, or image) coordinates.  It is used to find where
    // a given world coordinate will appear in the rendered image.

DM_FUNC (project,
         CRProject,
         Project,
         project,
         Point3Bvr,
         Project,
         pt,
         Point2Value *ProjectPoint (Point3Value *pt, Camera *cam));


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\envelope.h ===
#ifndef _ENVELOPE_H
#define _ENVELOPE_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    This is a general Envelope class implementation with automatic
    reference count.   The envelope class maintains a reference count 
    object.  This object should be a subclass of HasRefCount.

--*/

#include "appelles/animate.h"

// This is a general Envelope class implementation.
// It will do automatic reference count.
// class T has to be a subclass of HasRefCount.
// Usage:  Envelope<...Impl>
//
// TODO: this part should be separated out, and animate.h should share
// the same code.
//
template <class T>
class Envelope
{
  public:
    Envelope() : impl(NULL) {}
    Envelope(HasRefCount* i) { impl = i; }

    //... destructor decr ref count, check for 0 and destroy impl obj ...;
    ~Envelope() { if (impl) RefSubDel(impl); }
    
    //... copy constructor incr ref count ...;
    Envelope(const Envelope& a) { RefCopy(a); }
    
    //... operator= incr ref count ...;
    Envelope& operator=(const Envelope& a)
    {
        if (impl) RefSubDel(impl);
        RefCopy(a);
        return *this;
    }

    // Returns the implementation pointer.
    // This cast should be ok, I think.
    T* GetImpl() { return (T*) impl; }
    
    HasRefCount *impl;
    
  protected:
    void RefCopy(const Envelope& a)
    { 
        impl = a;
        if (impl) impl->Add(1);
    }
};

#endif /* _ENVELOPE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\dispdev.h ===
#ifndef _AP_DISPDEV_H
#define _AP_DISPDEV_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Abstract:
    Image Display Device type with operations.  Use for creating all sorts of
    image display devices.  This also contains the functions that are used to
    update the device, such as window resize.

*******************************************************************************/

#include <windows.h>
#include "appelles/common.h"
#include "appelles/valued.h"

    /****************************/
    /***  Value Declarations  ***/
    /****************************/




    /*******************************/
    /***  Function Declarations  ***/
    /*******************************/

    // Create a DirectDraw display device
class DirectDrawViewport;

extern  DirectDrawViewport *CreateImageDisplayDevice ();
extern  void DestroyImageDisplayDevice(DirectDrawViewport *);

    // Printed representation of display device.

#if _USE_PRINT
extern  ostream& operator<< (ostream& os, ImageDisplayDev dev);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\events.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Events behavior

*******************************************************************************/


#ifndef _APPEVENTS_H
#define _APPEVENTS_H

// TODO: Should factor out and not making separate Make..Bvr functions.  

extern Bvr PredicateEvent(Bvr b);

DM_BVRFUNC(predicate,
           CRPredicate,
           Predicate,
           predicate,
           DXMEvent,
           CRPredicate,
           NULL,
           AxAEData *PredicateEvent(AxABoolean *b));

extern Bvr NotEvent(Bvr event);

DM_BVRFUNC(notEvent,
           CRNotEvent,
           NotEvent,
           notEvent,
           DXMEvent,
           CRNotEvent,
           NULL,
           AxAEData *NotEvent(AxAEData *event));

extern Bvr AndEvent(Bvr e1, Bvr e2);

DM_BVRFUNC(andEvent,
           CRAndEvent,
           AndEvent,
           andEvent,
           DXMEvent,
           CRAndEvent,
           NULL,
           AxAEData *AndEvent(AxAEData *e1, AxAEData *e2));

extern Bvr OrEvent(Bvr e1, Bvr e2);

DM_BVRFUNC(|,
           CROrEvent,
           OrEvent,
           orEvent,
           DXMEvent,
           CROrEvent,
           NULL,
           AxAEData *OrEvent(AxAEData *e1, AxAEData *e2));

extern Bvr ThenEvent(Bvr e1, Bvr e2);

DM_BVRFUNC(thenEvent,
           CRThenEvent,
           ThenEvent,
           thenEvent,
           DXMEvent,
           CRThenEvent,
           NULL,
           AxAEData *ThenEvent(AxAEData *e1, AxAEData *e2));

extern Bvr leftButtonDown;

DM_BVRVAR(leftButtonDown,
          CRLeftButtonDown,
          LeftButtonDown,
          leftButtonDown,
          ignore,
          CRLeftButtonDown,
          AxAEData *leftButtonDown);

extern Bvr leftButtonUp;

DM_BVRVAR(leftButtonUp,
          CRLeftButtonUp,
          LeftButtonUp,
          leftButtonUp,
          ignore,
          CRLeftButtonUp,
          AxAEData *leftButtonUp);

extern Bvr rightButtonDown;

DM_BVRVAR(rightButtonDown,
          CRRightButtonDown,
          RightButtonDown,
          rightButtonDown,
          ignore,
          CRRightButtonDown,
          AxAEData *rightButtonDown);

extern Bvr rightButtonUp;

DM_BVRVAR(rightButtonUp,
          CRRightButtonUp,
          RightButtonUp,
          rightButtonUp,
          ignore,
          CRRightButtonUp,
          AxAEData *rightButtonUp);

extern Bvr alwaysBvr;

DM_BVRVAR(always,
          CRAlways,
          Always,
          always,
          DXMEvent,
          CRAlways,
          AxAEData *alwaysBvr);

extern Bvr neverBvr;

DM_BVRVAR(never,
          CRNever,
          Never,
          never,
          DXMEvent,
          CRNever,
          AxAEData *neverBvr);

extern Bvr TimerEvent(Bvr b);

DM_BVRFUNC(timer,
           CRTimer,
           TimerAnim,
           timer,
           DXMEvent,
           CRTimer,
           NULL,
           AxAEData * TimerEvent(AxANumber *n));

DM_BVRFUNC(timer,
           CRTimer,
           Timer,
           timer,
           DXMEvent,
           CRTimer,
           NULL,
           AxAEData * TimerEvent(DoubleValue *n));

DM_NOELEV(ignore,
          CRNotify,
          Notify,
          notifyEvent,
          DXMEvent,
          Notify,
          event,
          AxAEData * NotifyEvent(AxAEData *event,
                                 UntilNotifier * notifier));

DM_NOELEV(ignore,
          CRSnapshot,
          Snapshot,
          snapshotEvent,
          DXMEvent,
          Snapshot,
          event,
          AxAEData * SnapshotEvent(AxAEData *event,
                                   AxATrivial * b));

DM_NOELEV(ignore,
          CRAppTriggeredEvent,
          AppTriggeredEvent,
          ignore,
          ignore,
          CRAppTriggeredEvent,
          NULL,
          AxAEData * AppTriggeredEvent());

DM_NOELEV(ignore,
          CRAttachData,
          AttachData,
          ignore,
          ignore,
          AttachData,
          event,
          AxAEData * HandleEvent(AxAEData event, AxATrivial * data));

DM_NOELEV(ignore,
          ignore,
          ScriptCallback,
          ignore,
          ignore,
          ignore,
          event,
          AxAEData * ScriptCallback(BSTR scriptlet,
                                    AxAEData *event, BSTR language));


DMAPI_DECL2((DM_NOELEV2,
             ignore,
             ignore,
             NotifyScript,
             ignore,
             ignore,
             ignore,
             event),
            AxAEData * NotifyScriptEvent(AxAEData *event, BSTR scriptlet));

// OBSOLETE: This function, on statics, is obsolete.  The one below,
// that is a method on an event, is the one that should be used.
DM_NOELEV(ignore,
          ignore,
          ScriptCallback,
          ignore,
          ignore,
          ignore,
          NULL,
          AxAEData * ScriptCallback(BSTR obsolete1,
                                    AxAEData *obsolete2,
                                    BSTR obsolete3));

#endif /* _APPEVENTS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\common.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Definitions and declarations commonly needed by Appelles code.
*******************************************************************************/

#ifndef _APCOMMON_H
#define _APCOMMON_H

#define _DART_ 1

#ifndef _NO_CRT
#include <iostream.h>
#endif

#if _DEBUG
#include "../../../apeldbg/apeldbg.h"
#endif

// Point conversions
// 72 pts/ inch * 1/2.54 inch/cm * 100 cm/m
#define POINTS_PER_METER (72.0 * 100.0 / 2.54)
#define METERS_PER_POINT (1.0/POINTS_PER_METER)

// This can be a long time since we should never have this problem but
// we should probably try to detect a deadlock and terminate the
// thread after a long time
#define THREAD_TERMINATION_TIMEOUT_MS 5000

//////////////////// Macros ////////////////////

#ifndef TRUE
    #define TRUE  1
    #define FALSE 0
#endif

#undef  NULL
#define NULL 0

#undef  MIN
#define MIN(a,b)  (((a) < (b)) ? (a) : (b))

#undef  MAX
#define MAX(a,b)  (((a) > (b)) ? (a) : (b))

    // CLAMP(x,a,b) returns the value of x clamped to the range of [a,b].

#define CLAMP(x,a,b)  (((x) < (a)) ? (a) : (((x) > (b)) ? (b) : (x)))

template<class T> inline T clamp (T val, T min, T max)
{   return (val < min) ? min : ((val > max) ? max : val);
}

    // Zero out the memory of a given thing.

#define ZEROMEM(thing)   memset(&(thing),0,sizeof(thing))

#define DLL_EXPORT __declspec( dllexport )
#define DLL_IMPORT __declspec( dllimport )
#define NOTHROW    __declspec( nothrow )

#define DYNAMIC_CAST(type, val) (dynamic_cast< type >(val))

// Safe casting macro that fails in debug mode if the cast is
// invalid.  Optimized for speed in non-debug mode.
#if _DEBUG
#define SAFE_CAST(type, val) (DYNAMIC_CAST( type, val))
#else
#define SAFE_CAST(type, val) (static_cast< type >(val))
#endif

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

//////////////////// Type definitions ////////////////////

// Typedefs for commonly used Appelles types

typedef double        Real;
typedef BOOL          Bool;
typedef char *        RawString;

// This function takes a real number, allocates memory on the current dynamic
// heap, stores the number on the heap, and returns the address at which it was
// stored.  This allows a cheap way to pass real numbers by pointer.

//extern "C" Real *RealToRealPtr(Real val);

class AxABoolean;
class AxANumber;

    /*  Constants  */

const Real pi    = 3.1415926535897932384626434;
const Real root2 = 1.4142135623730950488016887;     // Sqrt(2)
const Real root3 = 1.7320508075688772935274463;     // Sqrt(3)

const Real degToRad = pi / 180.0; // Degrees to Radians Multiplier

    // The following are pointers to constant values.  These are useful
    // for passing to the API entry points.

    // IMPORTANT:  Do not use these values for static initialization!  Since
    // static inizialization order is undefined, these values may not yet have
    // been set when used by other static initializers.  Use the internal
    // (non-pointer) constructors instead for these situations.

    // These are all defined in utils/constant.cpp

extern AxANumber  *zero;        // Pointer to Constant Zero
extern AxANumber  *one;         // Pointer to Constant One
extern AxANumber  *negOne;      // Pointer to Constant -1.0
extern AxABoolean *truePtr;     // Pointer to TRUE
extern AxABoolean *falsePtr;    // Pointer to FALSE

// 0 means not initializing or deinitializing
// 1 means initializing
// -1 means deinitializing

extern int bInitState;

inline bool IsInitializing() { return bInitState == 1; }
inline bool IsDeinitializing() { return bInitState == -1; }

//////////////// Generally useful functions ////////////////

//////// Exceptions ////////

// The following is an abstract class for exception objects that
// will be thrown by the Throw* functions below.  A handler can
// catch an object of this type and look at its message.

class ATL_NO_VTABLE Exception {
  public:
    virtual ~Exception() ;
    virtual char * Message() = 0;

    // By default, exceptions have an unspecified failure.
    virtual HRESULT GetHRESULT() { return E_FAIL; }
};

//////// Debugging ////////

// Similar to printf(fmt, ...).  Outputs to the "debugger"
extern  void DebugPrint(char *format, ...);

//
// Use cdebug as a C++ stream for output to the debug console
//
// Example:
//
//     cdebug << "Passed iteration " << n << endl;
//
#if _USE_PRINT
extern ostream cdebug;
#endif
//////////////////////// Type "Elevation"  /////////////////////

// Define the RBML "elevation" indicators to ignore all but the C part
// for regular CPP processing.  The RBML elevator will pay attention
// to the special names.

// DM_TYPE is solely for the consumption of the Elevator
/* completely ignore */
#define DM_TYPE(rbName, \
                COMName, classguid, ifguid, \
                javaName, javaBaseClass, \
                CPPAPIName, \
                cName)
#define DM_TYPECONV(rbName, isBvr, needAddRef, \
                    RawAPIName, RawToC, CToRaw, CToRawFold, \
                    COMName, COMToRaw, RawToCOM, \
                    javaName, javaToCOM, COMTojava, \
                    CPPAPIName, CPPToRaw, RawToCPP, \
                    cName)
#define DM_TYPECONST(name, constname)

#define DM_CONST(rbName, RawName, COMName, jName, jClass, CPPName, cDecl) extern cDecl

#define DM_BVRVAR(rbName, RawName, COMName, jName, jClass, CPPName, cDecl)

#define DM_FUNC(rbName, RawName, COMName, jName, jClass, CPPName, thisArg, cDecl)  extern cDecl

#define DM_PROP(rbName, RawName, COMName, jName, jClass, CPPName, thisArg, cDecl)  extern cDecl

#define DM_INFIX(rbOperator, RawName, COMName, jName, jClass, CPPName, thisArg, cDecl) extern cDecl

#define DM_FUNCFOLD(rbName, RawName, COMName, jName, jClass, CPPName, thisArg, cDecl) extern cDecl
                    
// These take a single argument and return the appropriate type
#define DM_BVRFUNC(rbName, RawName, COMName, jName, jClass, CPPName, thisArg, cDecl)
    
// do not declare it - the prototype will not be correct
#define DM_NOELEV(rbName, RawName, COMName, jName, jClass, CPPName, thisArg, cDecl) 
#define DM_NOELEVPROP(rbName, RawName, COMName, jName, jClass, CPPName, thisArg, cDecl) 

#define DM_COMFUN(rbName, RawName, COMName, CPPName, thisArg, cDecl) 

//
// These are compound argument types
//

// Use this on arguments which are a array types.  For example a
// array of point2s would be DM_ARRAYARG(Point2Value *, AxAArray *)
#define DM_ARRAYARG(type,oper) oper
#define DM_SAFEARRAYARG(type,oper) oper

//
// New API functions
//
    
#define DMAPI(args)
#define DMAPI_DECL(args, cdecl) extern cdecl

#define DMAPI2(args)
#define DMAPI_DECL2(args, cdecl) extern cdecl

//////////////// Compiler directives ////////////////

///// Disabled warnings ////

// Warning 4114 (same type qualifier used more than once) is sometimes
// incorrectly generated.  See PSS ID Q138752.
#pragma warning(disable:4114)

// Warning 4786 (identifier was truncated to 255 chars in the browser
// info) can be safely disabled, as it only has to do with generation
// of browsing information.
#pragma warning(disable:4786)

// Warning 4355 (warning about using this pointer in constructor)
// should not be an error since it is quite common.
#pragma warning(disable:4355)

////////  Inclusion of common types  //////////////

#include "avrtypes.h"
#include "privinc/resource.h"
                    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\color.h ===
#ifndef _AP_COLOR_H
#define _AP_COLOR_H

/*******************************************************************************
Copyright (c) 1995-96  Microsoft Corporation

    Color values (RGB, HSL).

*******************************************************************************/


#include "common.h"


    // Value Generators

DM_FUNC (colorRgb,
         CRColorRgb,
         ColorRgbAnim,
         colorRgb,
         ColorBvr,
         ColorRgb,
         NULL,
         Color *RgbColor  (AxANumber *red, AxANumber *green, AxANumber *blue));
DM_FUNC (colorRgb,
         CRColorRgb,
         ColorRgb,
         colorRgb,
         ColorBvr,
         CRColorRgb,
         NULL,
         Color *RgbColor  (DoubleValue *red, DoubleValue *green, DoubleValue *blue));
DM_FUNC (colorRgb255,
         CRColorRgb255,
         ColorRgb255,
         colorRgb255,
         ColorBvr,
         CRColorRgb255,
         NULL,
         Color *RgbColor  (RGBComponent * red,
                           RGBComponent * green,
                           RGBComponent * blue));
DM_FUNC (colorHsl,
         CRColorHsl,
         ColorHsl,
         colorHsl,
         ColorBvr,
         CRColorHsl,
         NULL,
         Color *HslColor  (DoubleValue *hue, DoubleValue *saturation, DoubleValue *lum));

DM_FUNC (colorHsl,
         CRColorHsl,
         ColorHslAnim,
         colorHsl,
         ColorBvr,
         CRColorHsl,
         NULL,
         Color *HslColor  (AxANumber *hue, AxANumber *saturation, AxANumber *lum));

    // Accessors

DM_PROP (redOf,
         CRGetRed,
         Red,
         getRed,
         ColorBvr,
         GetRed,
         color,
         AxANumber *RedComponent   (Color *color));
DM_PROP (greenOf,
         CRGetGreen,
         Green,
         getGreen,
         ColorBvr,
         GetGreen,
         color,
         AxANumber *GreenComponent (Color *color));
DM_PROP (blueOf,
         CRGetBlue,
         Blue,
         getBlue,
         ColorBvr,
         GetBlue,
         color,
         AxANumber *BlueComponent  (Color *color));

DM_PROP (hueOf,
         CRGetHue,
         Hue,
         getHue,
         ColorBvr,
         GetHue,
         color,
         AxANumber *HueComponent        (Color *color));
DM_PROP (saturationOf,
         CRGetSaturation,
         Saturation,
         getSaturation,
         ColorBvr,
         GetSaturation,
         color,
         AxANumber *SaturationComponent (Color *color));
DM_PROP (lightnessOf,
         CRGetLightness,
         Lightness,
         getLightness,
         ColorBvr,
         GetLightness,
         color,
         AxANumber *LuminanceComponent  (Color *color));


// Constant Declarations

DM_CONST (red, CRRed, Red, red, ColorBvr, CRRed, Color * red);
DM_CONST (green, CRGreen, Green, green, ColorBvr, CRGreen, Color * green);
DM_CONST (blue, CRBlue, Blue, blue, ColorBvr, CRBlue, Color * blue);
DM_CONST (cyan, CRCyan, Cyan, cyan, ColorBvr, CRCyan, Color * cyan);
DM_CONST (magenta, CRMagenta, Magenta, magenta, ColorBvr, CRMagenta, Color * magenta);
DM_CONST (yellow, CRYellow, Yellow, yellow, ColorBvr, CRYellow, Color * yellow);
DM_CONST (black, CRBlack, Black, black, ColorBvr, CRBlack, Color * black);
DM_CONST (white, CRWhite, White, white, ColorBvr, CRWhite, Color * white);
DM_CONST (aqua, CRAqua, Aqua, aqua, ColorBvr, CRAqua, Color * aqua);
DM_CONST (fuchsia, CRFuchsia, Fuchsia, fuchsia, ColorBvr, CRFuchsia, Color *fuchsia);  
DM_CONST (gray, CRGray, Gray, gray, ColorBvr, CRGray, Color *gray);     
DM_CONST (lime, CRLime, Lime, lime, ColorBvr, CRLime, Color *lime);   
DM_CONST (maroon, CRMaroon, Maroon, maroon, ColorBvr, CRMaroon, Color *maroon);
DM_CONST (navy, CRNavy, Navy, navy, ColorBvr, CRNavy, Color *navy);
DM_CONST (olive, CROlive, Olive, olive, ColorBvr, CROlive, Color *olive);
DM_CONST (purple, CRPurple, Purple, purple, ColorBvr, CRPurple, Color *purple);
DM_CONST (silver, CRSilver, Silver, silver, ColorBvr, CRSilver, Color *silver);
DM_CONST (teal, CRTeal, Teal, teal, ColorBvr, CRTeal, Color *teal);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\gattr.h ===
#ifndef _AP_GATTR_H
#define _AP_GATTR_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Declares attributers that can be applied to geometry.

*******************************************************************************/

#include "appelles/valued.h"
#include "appelles/geom.h"
#include "appelles/color.h" 
#include "appelles/xform.h"

    /*****************************/
    /**  Attribution Functions  **/
    /*****************************/

    // Create an undetectable geometry

DM_FUNC(undetectable,
        CRUndetectable,
        Undetectable,
        undetectable,
        GeometryBvr,
        Undetectable,
        geo,
        Geometry *UndetectableGeometry(Geometry *geo));



    // Overriding Attributes:  For this class of attributes, A(B(X)) is
    // equivalent to A(X).

DM_FUNC(emissiveColor,
        CREmissiveColor,
        EmissiveColor,
        ignore,
        GeometryBvr,
        EmissiveColor,
        geo,
        Geometry *applyEmissiveColor (Color *col, Geometry *geo));


DM_FUNC(diffuseColor,
        CRDiffuseColor,
        DiffuseColor,
        diffuseColor,
        GeometryBvr,
        DiffuseColor,
        geo,
        Geometry *applyDiffuseColor (Color *col, Geometry *geo));


DM_FUNC(specularColor,
        CRSpecularColor,
        SpecularColor,
        ignore,
        GeometryBvr,
        SpecularColor,
        geo,
        Geometry *applySpecularColor (Color *col, Geometry *geo));


DM_FUNC(specularExponent,
        CRSpecularExponent,
        SpecularExponent,
        ignore,
        GeometryBvr,
        SpecularExponent,
        geo,
        Geometry *applySpecularExponent (DoubleValue *power, Geometry *geo));



DM_FUNC(specularExponent,
        CRSpecularExponentAnim,
        SpecularExponentAnim,
        ignore,
        GeometryBvr,
        SpecularExponentAnim,
        geo,
        Geometry *applySpecularExponent (AxANumber *power, Geometry *geo));

DM_FUNC(texture,
        CRTexture,
        Texture,
        texture,
        GeometryBvr,
        Texture,
        geo,
        Geometry *applyTextureMap(Image *texture, Geometry *geo));


// This function applies the texture as a VRML texture, which maps
// differently than AxA textures do.
Geometry *applyVrmlTextureMap(Image *, Geometry *);

    // Composing Attributes:  For these attributes, A(B(X)) results in C(X),
    // where C := do B, then A.

DM_FUNC(opacity,
        CROpacity,
        Opacity,
        opacity,
        GeometryBvr,
        Opacity,
        geom,
        Geometry *applyOpacityLevel (DoubleValue *level, Geometry *geom));

DM_FUNC(opacity,
        CROpacity,
        OpacityAnim,
        opacity,
        GeometryBvr,
        Opacity,
        geom,
        Geometry *applyOpacityLevel (AxANumber *level, Geometry *geom));


DM_FUNC(transform,
        CRTransform,
        Transform,
        transform,
        GeometryBvr,
        Transform,
        geo,
        Geometry *applyTransform (Transform3 *xf, Geometry *geo));

// Functions for Version 2.

DMAPI_DECL2((DM_FUNC2,
             shadow,
             CRShadow,
             Shadow,
             shadow,
             GeometryBvr,
             Shadow,
             geoToShadow),
            Geometry *ShadowGeometry (Geometry		*geoToShadow,
                                      Geometry		*geoContainingLights,
                                      Point3Value	*planePoint,
                                      Vector3Value      *planeNormal));
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\hacks.h ===
#ifndef _AV_HACKS_H
#define _AV_HACKS_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Some temporary hacks, some longer lasting, private, stuff that
    doesn't really have another home.

*******************************************************************************/

#include "appelles/common.h"
#include "appelles/avrtypes.h"

#include "appelles/image.h"
#include "appelles/geom.h"


extern double ViewerResolution();

extern Point2Value *PRIV_ViewerUpperRight (AxANumber *);
extern AxANumber *PRIV_ViewerResolution (AxANumber *);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\geom.h ===
#pragma once
#ifndef _AV_GEOM_H
#define _AV_GEOM_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Operations and primitives for the Geometry *type.

*******************************************************************************/

    /***  Constants  ***/

extern Geometry *emptyGeometry;


    /***  Geometry Aggregation  ***/

Geometry *PlusGeomGeom (Geometry *g1, Geometry *g2);
Geometry *UnionArray (DM_ARRAYARG(Geometry*, AxAArray*) imgs);
Geometry *UnionArray (DM_SAFEARRAYARG(Geometry*, AxAArray*) imgs);


    /***  Geometry Property Queries  ***/

Bbox3* GeomBoundingBox (Geometry *geo);


    /***  Attributors  ***/

Geometry *BlendTextureDiffuse (Geometry *geometry, AxABoolean *blended);
Geometry *applyAmbientColor   (Color *color, Geometry *geo);
Geometry *applyD3DRMTexture   (Geometry *geo, LPUNKNOWN rmTex);
Geometry *applyModelClip      (Point3Value *plantPt, Vector3Value *planeNorm, Geometry*);
Geometry *applyLighting       (AxABoolean *lighting, Geometry *geo);
Geometry *applyTextureImage   (Image *texture, Geometry *geo);
Geometry* OverridingOpacity   (Geometry *geo, bool override);
Geometry* AlphaShadows        (Geometry *geo, bool alphaShadows);
Geometry* Billboard           (Geometry *geo, Vector3Value *axis);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\image.h ===
#ifndef _IMAGE_H
#define _IMAGE_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Image *type with operations.

--*/

#include "appelles/valued.h"
#include "appelles/geom.h"
#include "appelles/dispdev.h"
#include "appelles/camera.h"
#include "appelles/xform2.h"
#include "appelles/bbox2.h"
#include "appelles/matte.h"
#include "backend/values.h"


// forward
class DirectDrawViewport;

    /**********************/
    /***  Constructors  ***/
    /**********************/

// The empty image.
DM_CONST(emptyImage,
         CREmptyImage,
         EmptyImage,
         emptyImage,
         ImageBvr,
         CREmptyImage,
         Image * emptyImage);

DM_CONST(detectableEmptyImage,
         CRDetectableEmptyImage,
         DetectableEmptyImage,
         detectableEmptyImage,
         ImageBvr,
         DetectableEmptyImage,
         Image *detectableEmptyImage);

// Project a geometry onto an image, given a camera defining the view.
// The geometry is projected onto the unit square [0,0] -> [1,1], and
// everything outside of this region is guaranteed to be transparent.
DM_FUNC(render,
        CRRender,
        Render,
        render,
        GeometryBvr,
        Render,
        geo,
        Image *RenderImage(Geometry *geo, Camera *cam));


Image *RenderTextToImage(Text *text);

// A single-colored, unbounded image.  Useful for overlaying rendered
// geometry atop to give a different colored background.
DM_FUNC(solidColorImage,
        CRSolidColorImage,
        SolidColorImage,
        solidColorImage,
        ImageBvr,
        CRSolidColorImage,
        NULL,
        Image *SolidColorImage(Color *col));

//
// Gradient Construction Utilities
//
DM_FUNC(ignore,
        CRGradientPolygon,
        GradientPolygonEx,
        gradientPolygon,
        ImageBvr,
        CRGradientPolygon,
        NULL,
        Image *GradientPolygon(DM_ARRAYARG(Point2Value*, AxAArray*) points,
                               DM_ARRAYARG(Color*, AxAArray*) colors));

DM_FUNC(ignore,
        CRGradientPolygon,
        GradientPolygon,
        ignore,
        ignore,
        CRGradientPolygon,
        NULL,
        Image *GradientPolygon(DM_SAFEARRAYARG(Point2Value*, AxAArray*) points,
                               DM_SAFEARRAYARG(Color*, AxAArray*) colors));


DM_FUNC(ignore,
        CRRadialGradientPolygon,
        RadialGradientPolygonEx,
        radialGradientPolygon,
        ImageBvr,
        CRRadialGradientPolygon,
        NULL,           
        Image *RadialGradientPolygon(Color *inner, Color *outer,
                                     DM_ARRAYARG(Point2Value*, AxAArray*) points,
                                     DoubleValue *fallOff));
                                
DM_FUNC(ignore,
        CRRadialGradientPolygon,
        RadialGradientPolygon,
        ignore,
        ignore,
        CRRadialGradientPolygon,
        NULL,           
        Image *RadialGradientPolygon(Color *inner, Color *outer,
                                     DM_SAFEARRAYARG(Point2Value*, AxAArray*) points,
                                     DoubleValue *fallOff));
                                
DM_FUNC(ignore,
        CRRadialGradientPolygon,
        RadialGradientPolygonAnimEx,
        radialGradientPolygon,
        ImageBvr,
        CRRadialGradientPolygon,
        NULL,           
        Image *RadialGradientPolygon(Color *inner, Color *outer,
                                     DM_ARRAYARG(Point2Value*, AxAArray*) points,
                                     AxANumber *fallOff));

DM_FUNC(ignore,
        CRRadialGradientPolygon,
        RadialGradientPolygonAnim,
        ignore,
        ignore,
        CRRadialGradientPolygon,
        NULL,           
        Image *RadialGradientPolygon(Color *inner, Color *outer,
                                     DM_SAFEARRAYARG(Point2Value*, AxAArray*) points,
                                     AxANumber *fallOff));

DM_FUNC(gradientSquare,
        CRGradientSquare,
        GradientSquare,
        gradientSquare,
        ImageBvr,
        CRGradientSquare,
        NULL,
        Image *GradientSquare(Color *lowerLeft,
                              Color *upperLeft,
                              Color *upperRight,
                              Color *lowerRight));

DM_FUNC(radialGradientSquare,
        CRRadialGradientSquare,
        RadialGradientSquare,
        radialGradientSquare,
        ImageBvr,
        CRRadialGradientSquare,
        NULL,
        Image *RadialGradientSquare(Color *inner, Color *outer, DoubleValue *fallOff));

DM_FUNC(radialGradientSquare,
        CRRadialGradientSquare,
        RadialGradientSquareAnim,
        radialGradientSquare,
        ImageBvr,
        CRRadialGradientSquare,
        NULL,
        Image *RadialGradientSquare(Color *inner, Color *outer, AxANumber *fallOff));
                              
DM_FUNC(radialGradientRegularPoly,
        CRRadialGradientRegularPoly,
        RadialGradientRegularPoly,
        radialGradientRegularPoly,
        ImageBvr,
        CRRadialGradientRegularPoly,
        NULL,
        Image *RadialGradientRegularPoly(Color *inner, Color *outer,                               
                               DoubleValue *numEdges, DoubleValue *fallOff));

DM_FUNC(radialGradientRegularPoly,
        CRRadialGradientRegularPoly,
        RadialGradientRegularPolyAnim,
        radialGradientRegularPoly,
        ImageBvr,
        CRRadialGradientRegularPoly,
        NULL,
        Image *RadialGradientRegularPoly(Color *inner, Color *outer,                               
                               AxANumber *numEdges, AxANumber *fallOff));

DM_FUNC(gradientHorizontal,
        CRGradientHorizontal,
        GradientHorizontal,
        gradientHorizontal,
        ImageBvr,
        CRGradientHorizontal,
        NULL,
        Image *GradientHorizontal(Color *start, Color *stop, DoubleValue *fallOff));

DM_FUNC(gradientHorizontal,
        CRGradientHorizontal,
        GradientHorizontalAnim,
        gradientHorizontal,
        ImageBvr,
        CRGradientHorizontal,
        NULL,
        Image *GradientHorizontal(Color *start, Color *stop, AxANumber *fallOff));

// 
// Hatch Construction Utilities
//
DM_FUNC(hatchHorizontal,
        CRHatchHorizontal,
        HatchHorizontal,
        hatchHorizontal,
        ImageBvr,
        CRHatchHorizontal,
        NULL,
        Image *HatchHorizontal(Color *lineClr, PixelValue *spacing));

DM_FUNC(hatchHorizontal,
        CRHatchHorizontal,
        HatchHorizontalAnim,
        hatchHorizontal,
        ImageBvr,
        CRHatchHorizontal,
        NULL,
        Image *HatchHorizontal(Color *lineClr, AnimPixelValue *spacing));

DM_FUNC(hatchVertical,
        CRHatchVertical,
        HatchVertical,
        hatchVertical,
        ImageBvr,
        CRHatchVertical,
        NULL,
        Image *HatchVertical(Color *lineClr, PixelValue *spacing));

DM_FUNC(hatchVertical,
        CRHatchVertical,
        HatchVerticalAnim,
        hatchVertical,
        ImageBvr,
        CRHatchVertical,
        NULL,
        Image *HatchVertical(Color *lineClr, AnimPixelValue *spacing));

DM_FUNC(hatchForwardDiagonal,
        CRHatchForwardDiagonal,
        HatchForwardDiagonal,
        hatchForwardDiagonal,
        ImageBvr,
        CRHatchForwardDiagonal,
        NULL,
        Image *HatchForwardDiagonal(Color *lineClr, PixelValue *spacing));

DM_FUNC(hatchForwardDiagonal,
        CRHatchForwardDiagonal,
        HatchForwardDiagonalAnim,
        hatchForwardDiagonal,
        ImageBvr,
        CRHatchForwardDiagonal,
        NULL,
        Image *HatchForwardDiagonal(Color *lineClr, AnimPixelValue *spacing));

DM_FUNC(hatchBackwardDiagonal,
        CRHatchBackwardDiagonal,
        HatchBackwardDiagonal,
        hatchBackwardDiagonal,
        ImageBvr,
        CRHatchBackwardDiagonal,
        NULL,
        Image *HatchBackwardDiagonal(Color *lineClr, PixelValue *spacing));

DM_FUNC(hatchBackwardDiagonal,
        CRHatchBackwardDiagonal,
        HatchBackwardDiagonalAnim,
        hatchBackwardDiagonal,
        ImageBvr,
        CRHatchBackwardDiagonal,
        NULL,
        Image *HatchBackwardDiagonal(Color *lineClr, AnimPixelValue *spacing));

DM_FUNC(hatchCross,
        CRHatchCross,
        HatchCross,
        hatchCross,
        ImageBvr,
        CRHatchCross,
        NULL,
        Image *HatchCross(Color *lineClr, PixelValue *spacing));

DM_FUNC(hatchCross,
        CRHatchCross,
        HatchCrossAnim,
        hatchCross,
        ImageBvr,
        CRHatchCross,
        NULL,
        Image *HatchCross(Color *lineClr, AnimPixelValue *spacing));

DM_FUNC(hatchDiagonalCross,
        CRHatchDiagonalCross,
        HatchDiagonalCross,
        hatchDiagonalCross,
        ImageBvr,
        CRHatchDiagonalCross,
        NULL,
        Image *HatchDiagonalCross(Color *lineClr, PixelValue *spacing));

DM_FUNC(hatchDiagonalCross,
        CRHatchDiagonalCross,
        HatchDiagonalCrossAnim,
        hatchDiagonalCross,
        ImageBvr,
        CRHatchDiagonalCross,
        NULL,
        Image *HatchDiagonalCross(Color *lineClr, AnimPixelValue *spacing));

// See the note "$/appelles/docs/design/notes/coord sys for image
// algebra.doc" for an explanation of the resolution arguments here.
//   Image *JpegImage(const char *file, Real *resolution);
//   Image *GifImage(const char *file, Real *resolution);

    /********************/
    /***  Aggregates  ***/
    /********************/

// The next function overlays two images, and is the key for combining
// multiple images into composites.
DM_INFIX(over,
         CROverlay,
         Overlay,
         overlay,
         ImageBvr,
         CROverlay,
         NULL,
         Image *Overlay(Image *top, Image *bottom));

DM_INFIX(ignore,
         CROverlay,
         OverlayArrayEx,
         overlayArray,
         ImageBvr,
         CROverlay,
         NULL,
         Image *OverlayArray(DM_ARRAYARG(Image*, AxAArray*) imgs));

DM_INFIX(ignore,
         CROverlay,
         OverlayArray,
         ignore,
         ignore,
         CROverlay,
         NULL,
         Image *OverlayArray(DM_SAFEARRAYARG(Image*, AxAArray*) imgs));


    /********************/
    /***  Operations  ***/
    /********************/

// Extract bounding box of image.  The bounding box of an image is a
// screen-aligned region outside of which everything is transparent.
extern AxAValue ImageBboxExternal(Image *image);

// The following returns points with -1, 0 or 1 in the coordinates
// depending on whether the corresponding coordinate of the bbox is
// infinite.  -1 means -inf, 1 means +inf, 0 means non-infinite.
extern AxAValue IsImageBboxInfinite(Image *image);

// TODO: rename to ImageBoundingBox
DM_PROP(ignore,
        CRBoundingBox,
        BoundingBox,
        boundingBox,
        ImageBvr,
        BoundingBox,
        image,
        Bbox2Value *BoundingBox(Image *image));

// Output to a display device
class DirtyRectState;
void RenderImageOnDevice(
    DirectDrawViewport *dev,
    Image *image,
    DirtyRectState &d);

#if _USE_PRINT
// Print to a stream.
extern ostream& operator<< (ostream &os,  Image &image);
#endif

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
////                                                          ////
////                     Attributed Images                    ////
////                                                          ////
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////

// An image "cropper".  Takes the current image and crops it to the
// box specified by the given points, making everything outside of
// this region transparent.
DM_FUNC(crop,
        CRCrop,
        Crop,
        crop,
        ImageBvr,
        Crop,
        image,
        Image *CropImage(Point2Value *min, Point2Value *max, Image *image));


// Create a new image from the transform of the old one that this is
// applied to.
// Note that multiple applications of this attribute accumulate.
DM_FUNC(transform,
        CRTransform,
        Transform,
        transform,
        ImageBvr,
        Transform,
        image,
        Image *TransformImage(Transform2 *xf, Image *image));


// Create a new image multiplying this opacity into the old images
// opacity.  Opacity of 0.9 means that the image is 90% opaque (10%
// transparent).  Multiple applications accumulate multiplicatively.
DM_FUNC(opacity,
        CROpacity,
        OpacityAnim,
        opacity,
        ImageBvr,
        Opacity,
        image,
        Image *OpaqueImage(AxANumber *opacity, Image *image));

DM_FUNC(opacity,
        CROpacity,
        Opacity,
        opacity,
        ImageBvr,
        Opacity,
        image,
        Image *OpaqueImage(DoubleValue *opacity, Image *image));


// Make the entire detectability channel of an image FALSE
DM_FUNC(undetectable,
        CRUndetectable,
        Undetectable,
        undetectable,
        ImageBvr,
        Undetectable,
        image,
        Image *UndetectableImage(Image *image));


// Create an infinitly tiled image using the bounding box of the image
// to define the original.
DM_FUNC(tile,
        CRTile,
        Tile,
        tile,
        ImageBvr,
        Tile,
        image,
        Image *TileImage(Image *image));

// Clip an image to the given matte.
DM_FUNC(clip,
        CRClip,
        Clip,
        clip,
        ImageBvr,
        Clip,
        image,
        Image *ClipImage(Matte *m, Image *image));

DM_FUNC(mapToUnitSquare,
        CRMapToUnitSquare,
        MapToUnitSquare,
        mapToUnitSquare,
        ImageBvr,
        MapToUnitSquare,
        image,
        Image *MapToUnitSquare(Image *image));

DM_FUNC(ignore,
        CRClipPolygonImage,
        ClipPolygonImageEx,
        clipPolygon,
        ImageBvr,
        ClipPolygonImage,
        image,
        Image *ClipPolygon(DM_ARRAYARG(Point2Value*, AxAArray*) points,
                           Image* image));

DM_FUNC(ignore,
        CRClipPolygonImage,
        ClipPolygonImage,
        ignore,
        ignore,
        ClipPolygonImage,
        image,
        Image *ClipPolygon(DM_SAFEARRAYARG(Point2Value*, AxAArray*) points,
                           Image* image));


DMAPI_DECL2((DM_NOELEV2,
             ignore,
             CRRenderResolution,
             RenderResolution,
             renderResolution,
             ignore,
             RenderResolution,
             img),
            Image * RenderResolution(Image *img, long width, long height));

DMAPI_DECL2((DM_NOELEV2,
             ignore,
             CRImageQuality,
             ImageQuality,
             imageQuality,
             ignore,
             ImageQuality,
             img),
            Image * ImageQuality(Image *img, DWORD dwQualityFlags));


DMAPI_DECL2((DM_FUNC2,
             colorKey,
             CRColorKey,
             ColorKey,
             colorKey,
             ImageBvr,
             ColorKey,
             image),
            Image *ConstructColorKeyedImage(Image *image, Color *colorKey));



// Given a ddraw surface, return an image
struct IDirectDrawSurface;
extern Image *ConstructDirectDrawSurfaceImage(IDirectDrawSurface *);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\matte.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Matte types and operations

*******************************************************************************/


#ifndef _MATTE_H
#define _MATTE_H

#include "appelles/common.h"

DM_CONST(opaqueMatte,
         CROpaqueMatte,
         OpaqueMatte,
         opaqueMatte,
         MatteBvr,
         CROpaqueMatte,
         Matte *opaqueMatte);
DM_CONST(clearMatte,
         CRClearMatte,
         ClearMatte,
         clearMatte,
         MatteBvr,
         CRClearMatte,
         Matte *clearMatte);

DM_INFIX(union,
         CRUnionMatte,
         UnionMatte,
         union,
         MatteBvr,
         CRUnionMatte,
         NULL,
         Matte *UnionMatte(Matte *m1, Matte *m2));

DM_INFIX(intersect,
         CRIntersectMatte,
         IntersectMatte,
         intersect,
         MatteBvr,
         CRIntersectMatte,
         NULL,
         Matte *IntersectMatte(Matte *m1, Matte *m2));

DM_INFIX(difference,
         CRDifferenceMatte,
         DifferenceMatte,
         difference,
         MatteBvr,
         CRDifferenceMatte,
         NULL,
         Matte *SubtractMatte(Matte *m1, Matte *m2));

DM_FUNC(transform,
        CRTransform,
        Transform,
        transform,
        MatteBvr,
        Transform,
        m,
        Matte *TransformMatte(Transform2 *xf, Matte *m));

DM_FUNC(fillMatte,
        CRFillMatte,
        FillMatte,
        fillMatte,
        MatteBvr,
        CRFillMatte,
        NULL,
        Matte *RegionFromPath(Path2 *p));

DM_FUNC(textMatte,
        CRTextMatte,
        TextMatte,
        textMatte,
        MatteBvr,
        CRTextMatte,
        NULL,
        Matte *TextMatteConstructor(AxAString *str, FontStyle *fs));

Matte *OriginalTextMatte(Text *txt);


#endif /* _MATTE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\memdebug.h ===
#ifndef _MEMDEBUG_H
#define _MEMDEBUG_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Memory leak check package.

    Usage:
      include "appelles/memdebug.h" in the implementation file.

      Declare a new memory list:   APD_MEMLIST(yourList);

      In the constructor:          APD_MEMADD(yourList);

      In the virtual destructor:   APD_MEMDEL(yourList);

      APD_MEMCHECK

      To see if mem list empty:    ADP_MEMLEAK(yourList)

      To traverse mem list:        APD_MEMDUMP(yourList, void (*fp)(void*))

--*/

#ifdef APD_MEMCHECK

#include <stddef.h>
#include "appelles/common.h"

class DMemList;

extern  void DAddMemList(void* p, DMemList*& lst);

extern  void DDelMemList(void* p, DMemList*& lst);

extern  void DDumpMemList(DMemList*& lst, void (*fp)(void*));

extern  int DIsMemListEmpty(DMemList*& lst);

#define APD_MEMLIST(name) static DMemList* name;

#define APD_MEMADD(lst)   DAddMemList((void*) this, lst)
#define APD_MEMDEL(lst)   DDelMemList((void*) this, lst)
#define APD_MEMDUMP(lst,fp)   DDumpMemList(lst, fp)
#define APD_MEMLEAK(lst)  DIsMemListEmpty(lst)

#else

#define APD_MEMADD(lst)
#define APD_MEMDEL(lst)
#define APD_MEMDUMP(lst,fp)
#define APD_MEMLEAK(lst)
#define APD_MEMLIST(name)


#endif

#endif /* _MEMDEBUG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\linestyl.h ===
#ifndef _LINESTYL_H
#define _LINESTYL_H


/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    LineStyle type and operations

-------------------------------------*/

#include <appelles/common.h>

//
// LINE STYLE
//
DM_CONST(defaultLineStyle,
         CRDefaultLineStyle,
         DefaultLineStyle,
         defaultLineStyle,
         LineStyleBvr,
         CRDefaultLineStyle,
         LineStyle *defaultLineStyle);

DM_CONST(emptyLineStyle,
         CREmptyLineStyle,
         EmptyLineStyle,
         emptyLineStyle,
         LineStyleBvr,
         CREmptyLineStyle,
         LineStyle *emptyLineStyle);

DM_FUNC(lineEndStyle,
        CREnd,
        End,
        end,
        LineStyleBvr,
        End,
        lsty,
        LineStyle *LineEndStyle(EndStyle *sty, LineStyle *lsty));

DM_FUNC(lineJoinStyle,
        CRJoin,
        Join,
        join,
        LineStyleBvr,
        Join,
        lsty,
        LineStyle *LineJoinStyle(JoinStyle *sty, LineStyle *lsty));

DM_FUNC(lineDashStyle,
        CRDash,
        Dash,
        dash,
        LineStyleBvr,
        Dash,
        lsty,
        LineStyle *LineDashStyle(DashStyle *sty, LineStyle *lsty));

// Terrible hack here.  We use Thickness as the COM type, since there
// is a problem with JCOMGEN if we use Width.  Since "width"
// (lowercase) is used elsewhere in IDL that we import, JCOMGEN
// interprets "Width" as "width", and doesn't allow us to use the
// capitalized version.  Thus, for the COM stuff, use Thickness
// instead.  Uggh. This is raided as qbugs 7184

DM_FUNC(linewidth,
        CRWidth,
        WidthAnim,
        width,
        LineStyleBvr,
        Width,
        lsty,
        LineStyle *LineWidthStyle(AnimPointValue *sty, LineStyle *lsty));

DM_FUNC(linewidth,
        CRWidth,
        width,
        width,
        LineStyleBvr,
        Width,
        lsty,
        LineStyle *LineWidthStyle(PointValue *sty, LineStyle *lsty));

DM_FUNC(lineAntialiasing,
        CRAntiAliasing,
        AntiAliasing,
        lineAntialiasing,
        LineStyleBvr,
        AntiAliasing,
        lsty,
        LineStyle *LineAntiAliasing(DoubleValue *aaStyle, LineStyle *lsty));

DM_FUNC(lineDetailStyle,
        CRDetail,
        Detail,
        detail,
        LineStyleBvr,
        Detail,
        lsty,
        LineStyle *LineDetailStyle(LineStyle *lsty));

DM_FUNC(lineColor,
        CRLineColor,
        Color,
        color,
        LineStyleBvr,
        Color,
        lsty,
        LineStyle *LineColor(Color *clr, LineStyle *lsty));

//
// Join STYLE
//
DM_CONST(joinStyleBevel,
         CRJoinStyleBevel,
         JoinStyleBevel,
         joinStyleBevel,
         JoinStyleBvr,
         CRJoinStyleBevel,
         JoinStyle *joinStyleBevel);
DM_CONST(joinStyleRound,
         CRJoinStyleRound,
         JoinStyleRound,
         joinStyleRound,
         JoinStyleBvr,
         CRJoinStyleRound,
         JoinStyle *joinStyleRound);
DM_CONST(joinStyleMiter,
         CRJoinStyleMiter,
         JoinStyleMiter,
         joinStyleMiter,
         JoinStyleBvr,
         CRJoinStyleMiter,
         JoinStyle *joinStyleMiter);

//
// END STYLE
//
DM_CONST(endStyleFlat,
         CREndStyleFlat,
         EndStyleFlat,
         endStyleFlat,
         EndStyleBvr,
         CREndStyleFlat,
         EndStyle *endStyleFlat);
DM_CONST(endStyleSquare,
         CREndStyleSquare,
         EndStyleSquare,
         endStyleSquare,
         EndStyleBvr,
         CREndStyleSquare,
         EndStyle *endStyleSquare);
DM_CONST(endStyleRound,
         CREndStyleRound,
         EndStyleRound,
         endStyleRound,
         EndStyleBvr,
         CREndStyleRound,
         EndStyle *endStyleRound);

//
// DASH STYLE
//
DM_CONST(dashStyleSolid,
         CRDashStyleSolid,
         DashStyleSolid,
         dashStyleSolid,
         DashStyleBvr,
         CRDashStyleSolid,
         DashStyle *dashStyleSolid);
DM_CONST(dashStyleDashed,
         CRDashStyleDashed,
         DashStyleDashed,
         dashStyleDashed,
         DashStyleBvr,
         CRDashStyleDashed,
         DashStyle *dashStyleDashed);

//
// Methods off of IDA2LineStyle
//

DMAPI_DECL2((DM_NOELEV2,
             ignore,
             CRDashEx,
             DashStyle,
             dashStyle,
             ignore,
             DashStyle,
             ls),
            LineStyle *ConstructLineStyleDashStyle(LineStyle *ls, DWORD ds_enum));

DMAPI_DECL2((DM_FUNC2,
             miterLimit,
             CRMiterLimit,
             MiterLimit,
             miterLimit,
             LineStyleBvr,
             MiterLimit,
             ls),
            LineStyle *ConstructLineStyleMiterLimit(LineStyle *ls, DoubleValue *mtrlim));

DMAPI_DECL2((DM_FUNC2,
             miterLimit,
             CRMiterLimit,
             MiterLimitAnim,
             miterLimit,
             LineStyleBvr,
             MiterLimit,
             ls),
            LineStyle *ConstructLineStyleMiterLimit(LineStyle *ls, AxANumber *mtrlim));

DMAPI_DECL2((DM_NOELEV2,
             ignore,
             CRJoinEx,
             JoinStyle,
             joinStyle,
             ignore,
             JoinStyle,
             ls),
            LineStyle *ConstructLineStyleJoinStyle(LineStyle *ls, DWORD js_enum));

DMAPI_DECL2((DM_NOELEV2,
             ignore,
             CREndEx,
             EndStyle,
             endStyle,
             ignore,
             EndStyle,
             ls),
            LineStyle *ConstructLineStyleEndStyle(LineStyle *ls, DWORD es_enum));            

#endif /* _LINESTYL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\montage.h ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    The abstract Montage *type.  A montage can be constructed in two
    ways.  First, by giving an Image *and a depth value (between 0 and
    1, where 0 corresponds to 'front' and 1 to 'back'), or by
    combining two montages.  This allows layered images with explicit
    depths.

    Finally, a Montage *can be 'rendered', producing an image with all
    the layered images depths resolved, and overlaying occuring in the
    correct order to produce the final image.

    Note that

      Overlay(im1, im2) <==> Render(ImageMontage(im1, 0),
                                    ImageMontage(im2, 1))


*******************************************************************************/


#ifndef _MONTAGE_H
#define _MONTAGE_H

#include "appelles/image.h"


DM_CONST(emptyMontage,
         CREmptyMontage,
         EmptyMontage,
         emptyMontage,
         MontageBvr,
         CREmptyMontage,
         Montage *emptyMontage);

// Build a simple montage out of an image and a depth
DM_FUNC(imageMontage,
        CRImageMontage,
        ImageMontage,
        imageMontage,
        MontageBvr,
        CRImageMontage,
        NULL,
        Montage *ImageMontage(Image *im, DoubleValue *depth));

DM_FUNC(imageMontage,
        CRImageMontageAnim,
        ImageMontageAnim,
        imageMontage,
        MontageBvr,
        CRImageMontageAnim,
        NULL,
        Montage *ImageMontage(Image *im, AxANumber *depth));


// Combine two montages
DM_INFIX(union,
         CRUnionMontage,
         UnionMontage,
         union,
         MontageBvr,
         CRUnionMontage,
         NULL,
         Montage *UnionMontageMontage(Montage *m1, Montage *m2));


// Render a montage into an image, by looking at all the associated
// depth values.
DM_FUNC(render,
        CRRender,
        Render,
        render,
        MontageBvr,
        Render,
        m,
        Image *Render(Montage *m));


// Printer
#if _USE_PRINT
extern ostream& operator<<(ostream& os,  Montage &m);
#endif

#endif /* _MONTAGE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\mic.h ===
#ifndef _MIC_H
#define _MIC_H

/*++
********************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Abstract:
    Defines the microphone type and operations.

********************************************************************************
--*/

#include "appelles/common.h"
#include "appelles/valued.h"
#include "appelles/xform.h"


    // Microphone *placed at the origin, all else is default.

DM_CONST(defaultMicrophone,
         CRDefaultMicrophone,
         DefaultMicrophone,
         defaultMicrophone,
         MicrophoneBvr,
         CRDefaultMicrophone,
         Microphone *defaultMicrophone);

    // TODO:  Have another constructor that takes interesting, relevant
    //        parameters. 
    //
    // NOTE:  For future microphones with a directional component, ensure that
    //        the canonical direction is -Z, to be consistent with cameras and
    //        lights.

    // Transform a microphone in space, yielding a new microphone. 

DM_FUNC(transform,
        CRTransform,
        Transform,
        transform,
        MicrophoneBvr,
        Transform,
        mic,
        Microphone *TransformMicrophone(Transform3 *xf, Microphone *mic));


    // Printing

#if _USE_PRINT
extern ostream& operator<< (ostream&,  const Microphone &);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\light.h ===
#pragma once
#ifndef _AV_LIGHT_H
#define _AV_LIGHT_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    This is the header file for embedded lights.  These functions create lights
as geometry, and can thus be used to embed lights into geometry.  Lights with
position components (positional & spot lights) are instanced at the origin, and
those with directional components (directional & spot lights) point in the -Z
direction (as do cameras and microphones).
*******************************************************************************/


    /**************************/
    /*** Light Constructors ***/
    /**************************/

    // The ambient light is independent of the material, position or
    // orientation of an object.  Multiple ambient lights are combined.

extern Geometry *ambientLight;

    // A directional light hits all surfaces from a fixed direction.

extern Geometry *directionalLight;

    // Point lights shine from a given location, and emit light in all
    // directions.

extern Geometry *pointLight;

    // Spotlights have a position and a direction.  In addition, the
    // contribution of illumination falls off as the illuminated point moves
    // away from the spotlight axis.

Geometry *SpotLight (AxANumber *fullcone, AxANumber *cutoff);
Geometry *SpotLight (AxANumber *fullcone, DoubleValue *cutoff);


    /************************/
    /*** Light Attributes ***/
    /************************/

    // This attributer specifies the color of all lights contained in the
    // geometry.  It is an overriding attribute.  Thus,
    //     applyLightColor (red, applyLightColor (green, light))
    // yields a red light.

Geometry *applyLightColor (Color *color, Geometry *geom);

    // This attributer specifies the color of all lights contained in the
    // geometry.  It is an overriding attribute.  Thus,
    //     applyLightColor (red, applyLightColor (green, light))
    // yields a red light.

    // This light attributer specifies the range of all lights contained in the
    // given geometry.  It is an overriding attribute.  The distance units are
    // interpreted in world coordinates.
    // TODO: Make a method on Geometry, rather than in statics.

Geometry *applyLightRange (AxANumber *range, Geometry *geom);
Geometry *applyLightRange (DoubleValue *range, Geometry *geom);

    // This attribute specifies the way that light intensity diminishes as
    // as distance increases between the light source and the illuminated
    // surface.  The attenuation equation is
    //     1 / (constant + linear*distance + quadratic*distance*distance).
    // Light attenuation is an overriding attribute, just as light color.

Geometry *applyLightAttenuation (AxANumber *constant,
                                 AxANumber *linear,
                                 AxANumber *quadratic, Geometry *geom);

Geometry *applyLightAttenuation (DoubleValue *constant,
                                 DoubleValue *linear,
                                 DoubleValue *quadratic,
                                 Geometry *geom);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\path2.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Path2 types and operations

*******************************************************************************/


#ifndef _PATH2_H
#define _PATH2_H

#include "appelles/common.h"

DM_INFIX(&,
         CRConcat,
         Concat,
         concat,
         Path2Bvr,
         CRConcat,
         NULL,
         Path2 *ConcatenatePath2(Path2 *p1, Path2 *p2));

DM_INFIX(ignore,
         CRConcat,
         ConcatArrayEx,
         concatArray,
         Path2Bvr,
         CRConcat,
         NULL,
         Path2 *Concat2Array(DM_ARRAYARG(Path2*, AxAArray*) paths));

DM_INFIX(ignore,
         CRConcat,
         ConcatArray,
         ignore,
         ignore,
         CRConcat,
         NULL,
         Path2 *Concat2Array(DM_SAFEARRAYARG(Path2*, AxAArray*) paths));

DM_FUNC(transform,
        CRTransform,
        Transform,
        transform,
        Path2Bvr,
        Transform,
        p,
        Path2 *TransformPath2(Transform2 *xf, Path2 *p));

DM_FUNC(boundingBox,
        CRBoundingBox,
        BoundingBox,
        boundingBox,
        Path2Bvr,
        BoundingBox,
        p,
        Bbox2Value *BoundingBoxPath(LineStyle *style, Path2 *p));

DM_FUNC(fill,
        CRFill,
        Fill,
        fill,
        Path2Bvr,
        Fill,
        p,
        Image *PathFill(LineStyle *border, Image *fill, Path2 *p));

DM_FUNC(draw,
        CRDraw,
        Draw,
        draw,
        Path2Bvr,
        Draw,
        p,
        Image *DrawPath(LineStyle *border, Path2 *p));

DM_FUNC(close,
        CRClose,
        Close,
        close,
        Path2Bvr,
        Close,
        p,
        Path2 *ClosePath2(Path2 *p));

// Make them available to COM/Java??
extern Point2Value *Point2AtPath2(Path2 *path, AxANumber *num0to1);

extern Transform2 *Path2Transform(Path2 *path, AxANumber *num0to1);

// Polyline needs to be done specially, since it takes an array...
DM_FUNC(line,
        CRLine,
        Line,
        line,
        Path2Bvr,
        CRLine,
        NULL,
        Path2 *Line2(Point2Value *p1, Point2Value *p2));

DM_FUNC(ray,
        CRRay,
        Ray,
        ray,
        Path2Bvr,
        CRRay,
        NULL,
        Path2 *RelativeLine2(Point2Value *pt));

Path2 *OriginalTextPath(Text *tx);

// Defined in fontstyl.cpp

DM_FUNC(stringPath,
        CRStringPath,
        StringPathAnim,
        stringPath,
        Path2Bvr,
        CRStringPath,
        NULL,
        Path2 *TextPath2Constructor(AxAString *str, FontStyle *fs));

DM_FUNC(stringPath,
        CRStringPath,
        StringPath,
        stringPath,
        Path2Bvr,
        CRStringPath,
        NULL,
        Path2 *TextPath2Constructor(StringValue *str, FontStyle *fs));

DM_FUNC(polyline,
        CRPolyline,
        PolylineEx,
        polyline,
        Path2Bvr,
        CRPolyline,
        NULL,
        Path2 *PolyLine2(DM_ARRAYARG(Point2Value *,AxAArray *) points));

DM_FUNC(polyline,
        CRPolyline,
        Polyline,
        ignore,
        ignore,
        CRPolyline,
        NULL,
        Path2 *PolyLine2(DM_SAFEARRAYARG(Point2Value *,AxAArray *) points));

DM_FUNC(polydrawPath,
        CRPolydrawPath,
        PolydrawPathEx,
        polydrawPath,
        Path2Bvr,
        CRPolydrawPath,
        NULL,
        Path2 *PolydrawPath2(DM_ARRAYARG(Point2Value *,AxAArray *) points,
                             DM_ARRAYARG(AxANumber *, AxAArray *) codes));

DM_FUNC(polydrawPath,
        CRPolydrawPath,
        PolydrawPath,
        ignore,
        ignore,
        CRPolydrawPath,
        NULL,
        Path2 *PolydrawPath2(DM_SAFEARRAYARG(Point2Value *,AxAArray *) points,
                             DM_SAFEARRAYARG(AxANumber *, AxAArray *) codes));

DM_FUNC(arc,
        CRArcRadians,
        ArcRadians,
        arc,
        Path2Bvr,
        CRArcRadians,
        NULL,
        Path2 *ArcVal(DoubleValue *startAngle, DoubleValue *endAngle, PixelValue *arcWidth, PixelValue *arcHeight));

DM_FUNC(arc,
        CRArcRadians,
        ArcRadiansAnim,
        arc,
        Path2Bvr,
        CRArcRadians,
        NULL,
        Path2 *ArcVal(AxANumber *startAngle, AxANumber *endAngle, AnimPixelValue *arcWidth, AnimPixelValue *arcHeight));

DM_FUNC(arc,
        CRArc,
        ArcDegrees,
        arcDegrees,
        Path2Bvr,
        CRArc,
        NULL,
        Path2 *ArcVal(DegreesValue *startAngle, DegreesValue *endAngle, PixelValue *arcWidth, PixelValue *arcHeight));

DM_FUNC(pie,
        CRPieRadians,
        PieRadians,
        pie,
        Path2Bvr,
        CRPieRadians,
        NULL,
        Path2 *PieVal(DoubleValue *startAngle, DoubleValue *endAngle, PixelValue *arcWidth, PixelValue *arcHeight));

DM_FUNC(pie,
        CRPieRadians,
        PieRadiansAnim,
        pie,
        Path2Bvr,
        CRPieRadians,
        NULL,
        Path2 *PieVal(AxANumber *startAngle, AxANumber *endAngle, AnimPixelValue *arcWidth, AnimPixelValue *arcHeight));

DM_FUNC(pie,
        CRPie,
        PieDegrees,
        pieDegrees,
        Path2Bvr,
        CRPie,
        NULL,
        Path2 *PieVal(DegreesValue *startAngle, DegreesValue *endAngle, PixelValue *arcWidth, PixelValue *arcHeight));

DM_FUNC(oval,
        CROval,
        Oval,
        oval,
        Path2Bvr,
        CROval,
        NULL,
        Path2 *OvalVal(PixelValue *width, PixelValue *height));

DM_FUNC(oval,
        CROval,
        OvalAnim,
        oval,
        Path2Bvr,
        CROval,
        NULL,
        Path2 *OvalVal(AnimPixelValue *width, AnimPixelValue *height));

DM_FUNC(rect,
        CRRect,
        Rect,
        rect,
        Path2Bvr,
        CRRect,
        NULL,
        Path2 *RectangleVal(PixelValue *width, PixelValue *height));

DM_FUNC(rect,
        CRRect,
        RectAnim,
        rect,
        Path2Bvr,
        CRRect,
        NULL,
        Path2 *RectangleVal(AnimPixelValue *width, AnimPixelValue *height));

DM_FUNC(roundRect,
        CRRoundRect,
        RoundRect,
        roundRect,
        Path2Bvr,
        CRRoundRect,
        NULL,
        Path2 *RoundRectVal(PixelValue *width,
                            PixelValue *height,
                            PixelValue *cornerArcWidth,
                            PixelValue *cornerArcHeight));

DM_FUNC(roundRect,
        CRRoundRect,
        RoundRectAnim,
        roundRect,
        Path2Bvr,
        CRRoundRect,
        NULL,
        Path2 *RoundRectVal(AnimPixelValue *width,
                            AnimPixelValue *height,
                            AnimPixelValue *cornerArcWidth,
                            AnimPixelValue *cornerArcHeight));

DM_FUNC(cubicBSplinePath,
        CRCubicBSplinePath,
        CubicBSplinePathEx,
        cubicBSplinePath,
        Path2Bvr,
        CRCubicBSplinePath,
        NULL,
        Path2 *CubicBSplinePath(DM_ARRAYARG(Point2Value *,AxAArray *) points,
                                DM_ARRAYARG(AxANumber*, AxAArray *) knots));

DM_FUNC(cubicBSplinePath,
        CRCubicBSplinePath,
        CubicBSplinePath,
        ignore,
        ignore,
        CRCubicBSplinePath,
        NULL,
        Path2 *CubicBSplinePath(DM_SAFEARRAYARG(Point2Value *,AxAArray *) points,
                                DM_SAFEARRAYARG(AxANumber*, AxAArray *) knots));

// This is an OBSOLETED function, kept in for compatability purposes.
DM_FUNC(textPath,
        CRTextPath,
        TextPath,
        textPath,
        Path2Bvr,
        CRTextPath,
        NULL,
        Path2 *TextPath2Constructor(AxAString *obsolete1, FontStyle *obsolete2));

#if ONLY_IF_DOING_EXTRUSION

D_MAPI_DECL2 ((DM_FUNC2,
              extrude,
              CRExtrude,
              Extrude,
              extrude,
              Path2Bvr,
              Extrude,
              path),
             Geometry *extrudePath (DoubleValue *extrusionDepth,
                                    BYTE         textureSetting,
                                    BYTE         bevelType,
                                    DoubleValue *frontBevelDepth,
                                    DoubleValue *backBevelDepth,
                                    DoubleValue *frontBevelAmt,
                                    DoubleValue *backBevelAmt,
                                    Path2       *path));
/*****
D_MAPI_DECL2 ((DM_FUNC2,
              extrude,
              CRExtrude,
              ExtrudeAnim,
              extrude,
              Path2Bvr,
              Extrude,
              path),
             Geometry *extrudePath (AxANumber  *extrusionDepth,
                                    BYTE        textureSetting,
                                    BYTE        bevelType,
                                    AxANumber  *frontBevelDepth,
                                    AxANumber  *backBevelDepth,
                                    AxANumber  *frontBevelAmt,
                                    AxANumber  *backBevelAmt,
                                    Path2      *path));
                                    ***/
#endif ONLY_IF_DOING_EXTRUSION


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\quat.h ===
#ifndef _QUAT_H
#define _QUAT_H

#ifdef QUATERNIONS_REMOVED_FOR_NOW

/*++
******************************************************************************

Copyright (c) 1995-96  Microsoft Corporation

Revision:

******************************************************************************
--*/

#include <appelles/common.h>
#include <appelles/valued.h>
#include <appelles/vec3.h>


RB_CONST(identityQuaternion, Quaternion *);

                                // Creation functions
RB_FUNC(AVNameHere, Quaternion *AngleAxisQuaternion(Real *theta, Vector3Value *axis));

                                // Interpolator
//RB_FUNC(AVNameHere, Quaternion *Interp (Quaternion *a, Quaternion *b, Real *alpha));
//old: (interp, InterpQuaternion, Quaternion *Interp (Quaternion *a, Quaternion *b, Real alpha));


// A bunch of operators

                                // Composition:
                                // Rotate Theta_b around Axis_b
                                // Then rotate theta_a around
                                // axis_a.
//RB_FUNC(AVNameHere, Quaternion *operator* (Quaternion *a, Quaternion *b));
//old: (*, TimesQuaternion, Quaternion *operator* (Quaternion *a, Quaternion *b));

                                // Negation:
                                // Opposite angle & axis
//RB_FUNC(AVNameHere, Quaternion *operator- (Quaternion *q));
//old: (-, MinusQuaternion, Quaternion *operator- (Quaternion *q));

                                // Same rotation, opposite axis
RB_FUNC(AVNameHere, Quaternion *Conjugate (Quaternion *q));

                                // Return the UNORMALIZED axis!
RB_FUNC(AVNameHere, Vector3Value *AxisComponent(Quaternion *q)); 

                                // Return the angle component
RB_FUNC(AVNameHere, Real *AngleComponent(Quaternion *q));

#endif QUATERNIONS_REMOVED_FOR_NOW

#endif  // _QUAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\valued.h ===
#ifndef _VALUED_H
#define _VALUED_H

#define BVR_OVERLOAD(rbml, cname, cdecl) extern __declspec ( dllexport ) cdecl
#define ACTIVEEXTERN /* nothing */

#endif /* VALUED_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\statics.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Adds static methods - ALWAYS ADD TO THE END OF THIS FILE UNLESS
    YOU CHANGE THE GUID

*******************************************************************************/


#ifndef _STATICS_H
#define _STATICS_H

extern Bvr viewFrameRateBvr;

DMAPI_DECL2((DM_BVRVAR,
             ignore,
             CRViewFrameRate,
             ViewFrameRate,
             viewFrameRate,
             NumberBvr,
             CRViewFrameRate,
             AxANumber *viewFrameRateBvr),
            Bvr viewFrameRateBvr);

DMAPI_DECL2 ((DM_FUNC2,
              unionMontageArray,
              CRUnionMontageArray,
              UnionMontageArrayEx,
              unionMontageArray,
              MontageBvr,
              CRUnionMontageArray,
              NULL),
             Montage *UnionMontage(DM_ARRAYARG(Montage*, AxAArray*) mtgs));

DMAPI_DECL2 ((DM_FUNC2,
              unionMontageArray,
              CRUnionMontageArray,
              UnionMontageArray,
              ignore,
              ignore,
              CRUnionMontageArray,
              NULL),
             Montage *UnionMontage(DM_SAFEARRAYARG(Montage*, AxAArray*) mtgs));

DMAPI2((DM_COMAPI2,
        ignore,
        [propget] HRESULT ModifiableBehaviorFlags([out, retval] DWORD * dwFlags)));

DMAPI2((DM_COMAPI2,
        ignore,
        [propput] HRESULT ModifiableBehaviorFlags([in] DWORD dwFlags)));

DMAPI2((DM_CONST2,
        emptyColor,
        CREmptyColor,
        EmptyColor,
        emptyColor,
        ColorBvr,
        CREmptyColor,
        Color * emptyColor));

#endif /* _STATICS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\text.h ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Text type

*******************************************************************************/


#ifndef _TEXT_H
#define _TEXT_H

#include "appelles/common.h"
#include "appelles/valued.h"
#include "appelles/image.h"

///////////  String functionality /////////

// Generate a string from a number, with 'precision' places after the
// decimal point shown.
DM_FUNC(toString,
        CRToString,
        ToStringAnim,
        toString,
        NumberBvr,
        ToString,
        num,
        AxAString * NumberString(AxANumber *num, AxANumber *precision));

DM_FUNC(toString,
        CRToString,
        ToString,
        toString,
        NumberBvr,
        ToString,
        num,
        AxAString * NumberString(AxANumber *num, DoubleValue *precision));


///////////  Font functionality /////////

// Constructors
extern FontFamily *serifProportional;
extern FontFamily *sansSerifProportional;
extern FontFamily *monospaced;

///////////  Text functionality /////////

// Functions

Text *TextFontFromString(AxAString *fontStr, Text *txt);
Text *SimpleText(AxAString * str);

Text *TextColor(Color *c, Text *t);
Text *TextFont(FontFamily *font, int size, Text *txt);
Text *TextBold(Text *t);
Text *TextItalic(Text *t);
Text *TextUnderline(Text *t);
Text *TextStrikethrough(Text *t);
Text *TextWeight(Real size, Text *t);
Text *TextAntiAliased(Real antiAlias, Text *t);
Text *TextFixedText(Text *t);
Text *TextTransformCharacter(Transform2 *xf, Text *t);

// RenderTextToImage is declared in image.h


// TODO: Remove all of the TextBvr related stuff and FontFamily stuff
// too.

DM_CONST(defaultFont,
         CRDefaultFont,
         DefaultFont,
         defaultFont,
         FontStyleBvr,
         CRDefaultFont,
         FontStyle *defaultFont);

DM_FUNC(font,
        CRFont,
        FontAnim,
        font,
        FontStyleBvr,
        CRFont,
        NULL,
        FontStyle *Font(AxAString *str, AxANumber *size, Color *col));

DM_FUNC(font,
        CRFont,
        Font,
        font,
        FontStyleBvr,
        CRFont,
        NULL,
        FontStyle *Font(StringValue *str, DoubleValue *size, Color *col));

DM_FUNC(stringImage,
        CRStringImage,
        StringImageAnim,
        stringImage,
        FontStyleBvr,
        CRStringImage,
        NULL,
        Image *ImageFromStringAndFontStyle(AxAString *str, FontStyle *fs));

DM_FUNC(stringImage,
        CRStringImage,
        StringImage,
        stringImage,
        FontStyleBvr,
        CRStringImage,
        NULL,
        Image *ImageFromStringAndFontStyle(StringValue *str, FontStyle *fs));

DM_FUNC(bold,
        CRBold,
        Bold,
        bold,
        FontStyleBvr,
        Bold,
        fs,
        FontStyle *FontStyleBold(FontStyle *fs));

DM_FUNC(italic,
        CRItalic,
        Italic,
        italic,
        FontStyleBvr,
        Italic,
        fs,
        FontStyle *FontStyleItalic(FontStyle *fs));

DM_FUNC(underline,
        CRUnderline,
        Underline,
        underline,
        FontStyleBvr,
        Underline,
        fs,
        FontStyle *FontStyleUnderline(FontStyle *fs));

DM_FUNC(strikethrough,
        CRStrikethrough,
        Strikethrough,
        strikethrough,
        FontStyleBvr,
        Strikethrough,
        fs,
        FontStyle *FontStyleStrikethrough(FontStyle *fs));

DM_FUNC(textAntialiasing,
        CRAntiAliasing,
        AntiAliasing,
        textAntialiasing,
        FontStyleBvr,
        AntiAliasing,
        fs,
        FontStyle *FontStyleAntiAliasing(DoubleValue *aaStyle, FontStyle *fs));

DM_FUNC(color,
        CRTextColor,
        Color,
        color,
        FontStyleBvr,
        Color,
        fs,
        FontStyle *FontStyleColor(FontStyle *fs, Color *col));

DM_FUNC(family,
        CRFamily,
        FamilyAnim,
        family,
        FontStyleBvr,
        Family,
        fs,
        FontStyle *FontStyleFace(FontStyle *fs, AxAString *face));

DM_FUNC(family,
        CRFamily,
        Family,
        family,
        FontStyleBvr,
        Family,
        fs,
        FontStyle *FontStyleFace(FontStyle *fs, StringValue *face));

DM_FUNC(size,
        CRSize,
        SizeAnim,
        size,
        FontStyleBvr,
        Size,
        fs,
        FontStyle *FontStyleSize(FontStyle *fs, AxANumber *size));

DM_FUNC(size,
        CRSize,
        Size,
        size,
        FontStyleBvr,
        Size,
        fs,
        FontStyle *FontStyleSize(FontStyle *fs, DoubleValue *size));

DM_FUNC(weight,
        CRWeight,
        Weight,
        weight,
        FontStyleBvr,
        Weight,
        fs,
        FontStyle *FontStyleWeight(FontStyle *fs, DoubleValue *weight));

DM_FUNC(weight,
        CRWeight,
        WeightAnim,
        weight,
        FontStyleBvr,
        Weight,
        fs,
        FontStyle *FontStyleWeight(FontStyle *fs, AxANumber *weight));

//////////////////// O B S O L E T E D  /////////////////

DM_FUNC(textImage,
        CRTextImage,
        TextImageAnim,
        textImage,
        FontStyleBvr,
        CRTextImage,
        NULL,
        Image *ImageFromStringAndFontStyle(AxAString *obsoleted1,
                                           FontStyle *obsoleted2));

DM_FUNC(textImage,
        CRTextImage,
        TextImage,
        textImage,
        FontStyleBvr,
        CRTextImage,
        NULL,
        Image *ImageFromStringAndFontStyle(StringValue *obsoleted1,
                                           FontStyle *obsoleted2));

//////////////////// O B S O L E T E D  /////////////////


// FontStyle transform characters.

DMAPI_DECL2((DM_FUNC2,
             transformCharacters,
             CRTransformCharacters,
             TransformCharacters,
             transformCharacters,
             FontStyleBvr,
             TransformCharacters,
             style),
            FontStyle *FontStyleTransformCharacters(FontStyle *style, Transform2 *transform));

#endif /* TEXT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\sound.h ===
#ifndef _SOUND_H
#define _SOUND_H


/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Sound types and operations

*******************************************************************************/

#include "appelles/common.h"
#include "appelles/valued.h"
#include "appelles/geom.h"
#include "appelles/mic.h"
#include <windows.h>


///////////////////  Sound  /////////////////////////

// Constants
DM_CONST(silence,
         CRSilence,
         Silence,
         silence,
         SoundBvr,
         CRSilence,
         Sound *silence);

extern Sound *Mix(Sound *snd1, Sound *snd2);

#if _USE_PRINT
// Printing function.
extern ostream& operator<<(ostream&,  const Sound &);
#endif

DM_FUNC(ignore,
        CRMix,
        MixArrayEx,
        mixArray,
        SoundBvr,
        CRMix,
        NULL,
        Sound *MixArray(DM_ARRAYARG(Sound *, AxAArray*) snds));

DM_FUNC(ignore,
        CRMix,
        MixArray,
        ignore,
        ignore,
        CRMix,
        NULL,
        Sound *MixArray(DM_SAFEARRAYARG(Sound *, AxAArray*) snds));


// These two should be dealt with via time transformation, but they 
// currently are not.

    
DM_NOELEV(phase,
          CRPhase,
          PhaseAnim,
          phase,
          SoundBvr,
          Phase,
          snd,
          Sound *ApplyPhase(AxANumber *phaseAmt, Sound *snd));

DM_NOELEV(phase,
          CRPhase,
          Phase,
          phase,
          SoundBvr,
          Phase,
          snd,
          Sound *ApplyPhase(DoubleValue *phaseAmt, Sound *snd));

DM_NOELEV(rate,
          CRRate,
          RateAnim,
          rate,
          SoundBvr,
          Rate,
          snd,
          Sound *ApplyPitchShift(AxANumber *pitchShift, Sound *snd));

DM_NOELEV(rate,
          CRRate,
          Rate,
          rate,
          SoundBvr,
          Rate,
          snd,
          Sound *ApplyPitchShift(DoubleValue *pitchShift, Sound *snd));

DM_NOELEV(pan,
          CRPan,
          PanAnim,
          pan,
          SoundBvr,
          Pan,
          snd,
          Sound *ApplyPan(AxANumber *panAmt, Sound *snd));

DM_NOELEV(pan,
          CRPan,
          Pan,
          pan,
          SoundBvr,
          Pan,
          snd,
          Sound *ApplyPan(DoubleValue *panAmt, Sound *snd));

DM_NOELEV(gain,
          CRGain,
          GainAnim,
          gain,
          SoundBvr,
          Gain,
          snd,
          Sound *ApplyGain(AxANumber *gainAmt, Sound *snd));

DM_NOELEV(gain,
          CRGain,
          Gain,
          gain,
          SoundBvr,
          Gain,
          snd,
          Sound *ApplyGain(DoubleValue *gainAmt, Sound *snd));

DM_NOELEV(loop,
          CRLoop,
          Loop,
          loop,
          SoundBvr,
          Loop,
          snd,
          Sound *ApplyLooping(Sound *snd));

extern Bvr sinSynth;

DM_BVRVAR(sinSynth, 
          CRSinSynth, 
          SinSynth,
          sinSynth,
          SoundBvr, 
          CRSinSynth,
          Sound *sinSynth);


// Make a geometry out of a sound, placing the sound at the origin.
Geometry *SoundSource(Sound *snd);

// Search the geometry for sounds to render, given a geometry to extract sounds
// from, and a positioned microphone.
Sound *RenderSound (Geometry *geo, Microphone *mic);

#endif /* _SOUND_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\readobj.h ===
#ifndef _READOBJ_H
#define _READOBJ_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Import geometry from a file in Wavefront .obj format

--*/

#include "appelles/geom.h"
#include <appelles/image.h>
#include <appelles/sound.h>
#include <fstream.h>
#include "privinc/importgeo.h"

/*
 * Note: There appears to be a bug in VC++ istream::seekg()
 * that doesn't reset eof.  As a workaround, open your file
 * twice and pass in two streams.  I am going to fix this
 * as soon as I work it out with the compiler people.
 */

/*
 * Returns geometry of Wavefront .obj format file.  Caller
 * should open and close the stream.
 */
Geometry *ReadWavefrontObjFile(fstream& in, fstream& in2);

/*
 * Same as ReadWavefrontObjFile above, except that geometry
 * will be uniformly scaled and translated to fit entirely within
 * the bounding box given as a parameter.  A common value for the
 * container is unitCubeBbox.
 */
Geometry *ReadWavefrontObjFile(fstream& in, fstream& in2, Bbox3 *containing_bbox);

/*
 * This version of ReadVRML only takes a filename, and reads what it
 * can.  NOTE: *** This is also a special caching version that retains
 * pointers to all the geometries that it's read, and when given the file
 * name of something already read, it just returns the already read one.
 * This is to get around the fact that RBML currently doesn't do dynamic
 * constant folding, and this is a critical case of dynamic constant
 * folding to have initially, so the file isn't re-read every
 * frame. **********
 *
 */

Geometry *ReadVrmlForImport(char *pathname);

Geometry *ReadXFileForImport (char *path, bool v1Compatible, TextureWrapInfo *);

Sound *ReadWavFileWithLength(char *pathname, Real *length);

Sound *ReadMIDIfileForImport(char *pathname);

Sound *ReadStreamForImport(char *pathname);

Sound *ReadQuartzForImport(char *pathname);


// XXX this is temporary until we have sounds embedded in images
Sound *VReadQuartzStreamForImport(char *pathname);

Sound *ReadQuartzSoundFileWithLength(char *pathname, Real *length);

Image **ReadDibForImport(RawString urlPath,
                         RawString cachePath,
                         IStream * pstream,
                         bool useColorKey,
                         BYTE ckRed,
                         BYTE ckGreen,
                         BYTE ckBlue,
                         int *count,
                         int **delays,
                         int *loop);

Image *PluginDecoderImage(char *urlPath,
                          char *cachePath,
                          IStream *fileStream,
                          bool useColorKey,
                          BYTE ckRed,
                          BYTE ckGreen,
                          BYTE ckBlue);

#endif /* _READOBJ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\vec2.h ===
#ifndef _VEC2_H
#define _VEC2_H

/*++

Copyright (c) 1995-96  Microsoft Corporation

Abstract:
    2D vectors and points

--*/

#include "appelles/common.h"

    /*******************/
    /***  Constants  ***/
    /*******************/


// (1, 0)
DM_CONST(xVector2,
         CRXVector2,
         XVector2,
         xVector2,
         Vector2Bvr,
         CRXVector2,
         Vector2Value *xVector2);

// (0, 1)
DM_CONST(yVector2,
         CRYVector2,
         YVector2,
         yVector2,
         Vector2Bvr,
         CRYVector2,
         Vector2Value *yVector2);

// (0, 0)
DM_CONST(zeroVector2,
         CRZeroVector2,
         ZeroVector2,
         zeroVector2,
         Vector2Bvr,
         CRZeroVector2,
         Vector2Value *zeroVector2);          

// (0, 0)
DM_CONST(origin2,
         CROrigin2,
         Origin2,
         origin2,
         Point2Bvr,
         CROrigin2,
         Point2Value *origin2);        


    /*******************************/
    /***  Coordinate Conversion  ***/
    /*******************************/

    // Rectangular Coordinates

DM_FUNC(vector2,
        CRCreateVector2,
        Vector2Anim,
        vector2,
        Vector2Bvr,
        CRCreateVector2,
        NULL,
        Vector2Value *XyVector2 (AnimPixelValue *x, AnimPixelYValue *y));

DM_FUNC(vector2,
        CRCreateVector2,
        Vector2,
        vector2,
        Vector2Bvr,
        CRCreateVector2,
        NULL,
        Vector2Value *XyVector2 (PixelValue *x, PixelYValue *y));

DM_FUNC(point2,
        CRCreatePoint2,
        Point2Anim,
        point2,
        Point2Bvr,
        CRCreatePoint2,
        NULL,
        Point2Value *XyPoint2  (AnimPixelValue *x, AnimPixelYValue *y));

DM_FUNCFOLD(point2,
            CRCreatePoint2,
            Point2,
            point2,
            Point2Bvr,
            CRCreatePoint2,
            NULL,
            Point2Value *MakePoint2  (PixelValue *x, PixelYValue *y));

    // Polar Coordinates.
    // Angle theta is expressed in radians, and goes counter-clockwise from +X.

DM_FUNC(vector2Polar,
        CRVector2Polar,
        Vector2PolarAnim,
        vector2Polar,
        Vector2Bvr,
        CRVector2Polar,
        NULL,
        Vector2Value *PolarVector2 (AxANumber *theta,
                               AnimPixelValue *radius));

DM_FUNC(vector2Polar,
        CRVector2Polar,
        Vector2Polar,
        vector2Polar,
        Vector2Bvr,
        CRVector2Polar,
        NULL,
        Vector2Value *PolarVector2 (DoubleValue *theta,
                               PixelValue *radius));

DM_FUNC(vector2PolarDegrees,
        CRVector2Polar,
        Vector2PolarDegrees,
        vector2PolarDegrees,
        Vector2Bvr,
        CRVector2Polar,
        NULL,
        Vector2Value *PolarVector2 (DegreesValue *theta, PixelValue *radius));

DM_FUNC(point2Polar,
        CRPoint2Polar,
        Point2PolarAnim,
        point2Polar,
        Point2Bvr,
        CRPoint2Polar,
        NULL,
        Point2Value *PolarPoint2  (AxANumber *theta, AnimPixelValue *radius));

DM_FUNC(point2Polar,
        CRPoint2Polar,
        Point2Polar,
        point2Polar,
        Point2Bvr,
        CRPoint2Polar,
        NULL,
        Point2Value *PolarPoint2  (DoubleValue *theta, PixelValue *radius));



    /*******************************/
    /***  Operations on Vectors  ***/
    /*******************************/

DM_PROP(length,
        CRLength,
        Length,
        length,
        Vector2Bvr,
        Length,
        v,
        AxANumber *LengthVector2(Vector2Value *v));

DM_PROP(lengthSquared,
        CRLengthSquared,
        LengthSquared,
        lengthSquared,
        Vector2Bvr,
        LengthSquared,
        v,
        AxANumber *LengthSquaredVector2(Vector2Value *v));


// Returns a unit-length vector
DM_FUNC(normalize,
        CRNormalize,
        Normalize,
        normalize,
        Vector2Bvr,
        Normalize,
        v,
        Vector2Value *NormalVector2(Vector2Value *v));

DM_FUNC(dot,
        CRDot,
        DotVector2,
        dot,
        Vector2Bvr,
        CRDot,
        NULL,
        AxANumber *DotVector2Vector2(Vector2Value *v, Vector2Value *u));


DM_INFIX(~,
         CRNeg,
         NegVector2,
         neg,
         Vector2Bvr,
         CRNeg,
         NULL,
         Vector2Value *NegateVector2(Vector2Value *v));

DM_INFIX(*,
         CRMul,
         MulAnim,
         mul,
         Vector2Bvr,
         Mul,
         v,
         Vector2Value *ScaleVector2Real(Vector2Value *v, AxANumber *scalar));

DM_INFIX(*,
         CRMul,
         Mul,
         mul,
         Vector2Bvr,
         Mul,
         v,
         Vector2Value *ScaleVector2Real(Vector2Value *v, DoubleValue *scalar));

DM_INFIX(/,
         CRDiv,
         DivAnim,
         div,
         Vector2Bvr,
         Div,
         v,
         Vector2Value *DivideVector2Real(Vector2Value *v, AxANumber *scalar));

DM_INFIX(/,
         CRDiv,
         Div,
         div,
         Vector2Bvr,
         Div,
         v,
         Vector2Value *DivideVector2Real(Vector2Value *v, DoubleValue *scalar));

DM_INFIX(-,
         CRSub,
         SubVector2,
         sub,
         Vector2Bvr,
         CRSub,
         NULL,
         Vector2Value *MinusVector2Vector2(Vector2Value *v1, Vector2Value *v2));

DM_INFIX(+,
         CRAdd,
         AddVector2,
         add,
         Vector2Bvr,
         CRAdd,
         NULL,
         Vector2Value *PlusVector2Vector2(Vector2Value *v1, Vector2Value *v2));

extern AxANumber *AngleBetween(Vector2Value *v, Vector2Value *u); // TODO: not in spec

// Right handed cross, TODO: not in spec
extern Real CrossVector2Vector2(Vector2Value *a, Vector2Value *b);

#if _USE_PRINT
extern ostream& operator<< (ostream& os,  Vector2Value &v);
#endif


    /******************************/
    /***  Operations on Points  ***/
    /******************************/

DM_INFIX(+,
         CRAdd,
         AddPoint2Vector,
         add,
         Point2Bvr,
         CRAdd,
         NULL,
         Point2Value *PlusPoint2Vector2(Point2Value *p, Vector2Value *v));

DM_INFIX(-,
         CRSub,
         SubPoint2Vector,
         sub,
         Point2Bvr,
         CRSub,
         NULL,
         Point2Value *MinusPoint2Vector2(Point2Value *p, Vector2Value *v));

DM_INFIX(-,
         CRSub,
         SubPoint2,
         sub,
         Point2Bvr,
         CRSub,
         NULL,
         Vector2Value *MinusPoint2Point2(Point2Value *p1, Point2Value *p2));

DM_FUNC(distance,
        CRDistance,
        DistancePoint2,
        distance,
        Point2Bvr,
        CRDistance,
        NULL,
        AxANumber *DistancePoint2Point2(Point2Value *p, Point2Value *q));

DM_FUNC(distanceSquared,
        CRDistanceSquared,
        DistanceSquaredPoint2,
        distanceSquared,
        Point2Bvr,
        CRDistanceSquared,
        NULL,
        AxANumber *DistanceSquaredPoint2Point2(Point2Value *p, Point2Value *q));


#if _USE_PRINT
extern ostream& operator<< (ostream& os,  Point2Value &p);
#endif

    /********************/
    /***  Extractors  ***/
    /********************/

DM_PROP(x,
        CRGetX,
        X,
        getX,
        Vector2Bvr,
        GetX,
        v,
        AxANumber *XCoordVector2(Vector2Value *v));

DM_PROP(y,
        CRGetY,
        Y,
        getY,
        Vector2Bvr,
        GetY,
        v,
        AxANumber *YCoordVector2(Vector2Value *v));

DM_PROP(polarCoordAngle,
        CRPolarCoordAngle,
        PolarCoordAngle,
        getPolarCoordAngle,
        Vector2Bvr,
        PolarCoordAngle,
        v,
        AxANumber *ThetaCoordVector2(Vector2Value *v));

DM_PROP(polarCoordLength,
        CRPolarCoordLength,
        PolarCoordLength,
        getPolarCoordLength,
        Vector2Bvr,
        PolarCoordLength,
        v,
        AxANumber *RhoCoordVector2(Vector2Value *v));


DM_PROP(x,
        CRGetX,
        X,
        getX,
        Point2Bvr,
        GetX,
        v,
        AxANumber *XCoordPoint2(Point2Value *v));

DM_PROP(y,
        CRGetY,
        Y,
        getY,
        Point2Bvr,
        GetY,
        v,
        AxANumber *YCoordPoint2(Point2Value *v));

DM_PROP(polarCoordAngle,
        CRPolarCoordAngle,
        PolarCoordAngle,
        getPolarCoordAngle,
        Point2Bvr,
        PolarCoordAngle,
        v,
        AxANumber *ThetaCoordPoint2(Point2Value *v));

DM_PROP(polarCoordLength,
        CRPolarCoordLength,
        PolarCoordLength,
        getPolarCoordLength,
        Point2Bvr,
        PolarCoordLength,
        v,
        AxANumber *RhoCoordPoint2(Point2Value *v));

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\vec3.h ===
#ifndef _VEC3_H
#define _VEC3_H

/*++
******************************************************************************
Copyright (c) 1995-96  Microsoft Corporation

Abstract:
    3D vectors

******************************************************************************
--*/

#include "appelles/common.h"

    /*******************/
    /***  Constants  ***/
    /*******************/

DM_CONST(xVector3,
         CRXVector3,
         XVector3,
         xVector3,
         Vector3Bvr,
         CRXVector3,
         Vector3Value *xVector3);         // (1, 0, 0)
DM_CONST(yVector3,
         CRYVector3,
         YVector3,
         yVector3,
         Vector3Bvr,
         CRYVector3,
         Vector3Value *yVector3);         // (0, 1, 0)
DM_CONST(zVector3,
         CRZVector3,
         ZVector3,
         zVector3,
         Vector3Bvr,
         CRZVector3,
         Vector3Value *zVector3);         // (0, 0, 1)
DM_CONST(zeroVector3,
         CRZeroVector3,
         ZeroVector3,
         zeroVector3,
         Vector3Bvr,
         CRZeroVector3,
         Vector3Value *zeroVector3);          // (0, 0, 0)

DM_CONST(origin3,
         CROrigin3,
         Origin3,
         origin3,
         Point3Bvr,
         CROrigin3,
         Point3Value *origin3);        // (0, 0, 0)


    /*******************************/
    /***  Coordinate Conversion  ***/
    /*******************************/

    // Rectangular Coordinates

DM_FUNC(vector3,
        CRCreateVector3,
        Vector3Anim,
        vector3,
        Vector3Bvr,
        CRCreateVector3,
        NULL,
        Vector3Value *XyzVector3(AnimPixelValue *x, AnimPixelYValue *y, AnimPixelValue *z));

DM_FUNC(vector3,
        CRCreateVector3,
        Vector3,
        vector3,
        Vector3Bvr,
        CRCreateVector3,
        NULL,
        Vector3Value *XyzVector3(PixelValue *x, PixelYValue *y, PixelValue *z));

DM_FUNC(point3,
        CRCreatePoint3,
        Point3Anim,
        point3,
        Point3Bvr,
        CRCreatePoint3,
        NULL,
        Point3Value *XyzPoint3(AnimPixelValue *x, AnimPixelYValue *y, AnimPixelValue *z));

DM_FUNC(point3,
        CRCreatePoint3,
        Point3,
        point3,
        Point3Bvr,
        CRCreatePoint3,
        NULL,
        Point3Value *XyzPoint3(PixelValue *x, PixelYValue *y, PixelValue *z));


    // Spherical Coordinates
    //
    // Azimuth rotates counter-clockwise about the +Y ray starting at +Z.
    // Elevation rotates up from the XZ plane towards +Y.
    // Radius is the distance from the origin.

DM_FUNC(vector3Spherical,
        CRVector3Spherical,
        Vector3SphericalAnim,
        vector3Spherical,
        Vector3Bvr,
        CRVector3Spherical,
        NULL,
        Vector3Value *SphericalVector3
            (AxANumber *xyAngle, AxANumber *yzAngle, AnimPixelValue *radius));

DM_FUNC(vector3Spherical,
        CRVector3Spherical,
        Vector3Spherical,
        vector3Spherical,
        Vector3Bvr,
        CRVector3Spherical,
        NULL,
        Vector3Value *SphericalVector3
            (DoubleValue *xyAngle, DoubleValue *yzAngle, PixelValue *radius));


DM_FUNC(point3Spherical,
        CRPoint3Spherical,
        Point3SphericalAnim,
        point3Spherical,
        Point3Bvr,
        CRPoint3Spherical,
        NULL,
        Point3Value *SphericalPoint3
            (AxANumber *zxAngle, AxANumber *xyAngle, AnimPixelValue *radius));

DM_FUNC(point3Spherical,
        CRPoint3Spherical,
        Point3Spherical,
        point3Spherical,
        Point3Bvr,
        CRPoint3Spherical,
        NULL,
        Point3Value *SphericalPoint3
            (DoubleValue *zxAngle, DoubleValue *xyAngle, PixelValue *radius));


    /*******************************/
    /***  Operations On Vectors  ***/
    /*******************************/

DM_PROP(length,
        CRLength,
        Length,
        length,
        Vector3Bvr,
        Length,
        v,
        AxANumber *LengthVector3(Vector3Value *v));

DM_PROP(lengthSquared,
        CRLengthSquared,
        LengthSquared,
        lengthSquared,
        Vector3Bvr,
        LengthSquared,
        v,
        AxANumber *LengthSquaredVector3(Vector3Value *v));


// Returns a unit-length vector
DM_FUNC(normalize,
        CRNormalize,
        Normalize,
        normalize,
        Vector3Bvr,
        Normalize,
        v,
        Vector3Value *NormalVector3(Vector3Value *v));

DM_FUNC(dot,
        CRDot,
        DotVector3,
        dot,
        Vector3Bvr,
        CRDot,
        NULL,
        AxANumber *DotVector3Vector3(Vector3Value *v, Vector3Value *u));

DM_FUNC(cross,
        CRCross,
        CrossVector3,
        cross,
        Vector3Bvr,
        CRCross,
        NULL,
        Vector3Value *CrossVector3Vector3(Vector3Value *v, Vector3Value *u));


DM_INFIX(~,
         CRNeg,
         NegVector3,
         neg,
         Vector3Bvr,
         CRNeg,
         NULL,
         Vector3Value *NegateVector3(Vector3Value *v));

DM_INFIX(*,
         CRMul,
         MulAnim,
         mul,
         Vector3Bvr,
         Mul,
         v,
         Vector3Value *ScaleRealVector3(AxANumber *scalar, Vector3Value *v));

DM_INFIX(*,
         CRMul,
         Mul,
         mul,
         Vector3Bvr,
         Mul,
         v,
         Vector3Value *ScaleRealVector3(DoubleValue *scalar, Vector3Value *v));

DM_INFIX(/,
         CRDiv,
         DivAnim,
         div,
         Vector3Bvr,
         Div,
         v,
         Vector3Value *DivideVector3Real(Vector3Value *v, AxANumber *scalar));

DM_INFIX(/,
         CRDiv,
         Div,
         div,
         Vector3Bvr,
         Div,
         v,
         Vector3Value *DivideVector3Real(Vector3Value *v, DoubleValue *scalar));

DM_INFIX(-,
         CRSub,
         SubVector3,
         sub,
         Vector3Bvr,
         CRSub,
         NULL,
         Vector3Value *MinusVector3Vector3(Vector3Value *v1, Vector3Value *v2));

DM_INFIX(+,
         CRAdd,
         AddVector3,
         add,
         Vector3Bvr,
         CRAdd,
         NULL,
         Vector3Value *PlusVector3Vector3(Vector3Value *v1, Vector3Value *v2));


extern AxANumber *AngleBetween(Vector3Value *v, Vector3Value *u); // TODO: not in spec

#if _USE_PRINT
extern ostream& operator<< (ostream& os,  Vector3Value &v);
#endif


    /******************************/
    /***  Operations On Points  ***/
    /******************************/


DM_INFIX(+,
         CRAdd,
         AddPoint3Vector,
         add,
         Point3Bvr,
         CRAdd,
         NULL,
         Point3Value *PlusPoint3Vector3(Point3Value *p, Vector3Value *v));

DM_INFIX(-,
         CRSub,
         SubPoint3Vector,
         sub,
         Point3Bvr,
         CRSub,
         NULL,
         Point3Value *MinusPoint3Vector3(Point3Value *p, Vector3Value *v));

DM_INFIX(-,
         CRSub,
         SubPoint3,
         sub,
         Point3Bvr,
         CRSub,
         NULL,
         Vector3Value *MinusPoint3Point3(Point3Value *p1, Point3Value *p2));


DM_FUNC(distance,
        CRDistance,
        DistancePoint3,
        distance,
        Point3Bvr,
        CRDistance,
        NULL,
        AxANumber *DistancePoint3Point3(Point3Value *p, Point3Value *q));

DM_FUNC(distanceSquared,
        CRDistanceSquared,
        DistanceSquaredPoint3,
        distanceSquared,
        Point3Bvr,
        CRDistanceSquared,
        NULL,
        AxANumber *DistanceSquaredPoint3Point3(Point3Value *p, Point3Value *q));


#if _USE_PRINT
extern ostream& operator<< (ostream& os,  Point3Value &p);
#endif


    /*******************/
    /***  Accessors  ***/
    /*******************/

DM_PROP(x,
        CRGetX,
        X,
        getX,
        Vector3Bvr,
        GetX,
        v,
        AxANumber *XCoordVector3(Vector3Value *v));

DM_PROP(y,
        CRGetY,
        Y,
        getY,
        Vector3Bvr,
        GetY,
        v,
        AxANumber *YCoordVector3(Vector3Value *v));

DM_PROP(z,
        CRGetZ,
        Z,
        getZ,
        Vector3Bvr,
        GetZ,
        v,
        AxANumber *ZCoordVector3(Vector3Value *v));

DM_PROP(sphericalCoordXYAngle,
        CRSphericalCoordXYAngle,
        SphericalCoordXYAngle,
        getSphericalCoordXYAngle,
        Vector3Bvr,
        SphericalCoordXYAngle,
        v,
        AxANumber *ThetaCoordVector3(Vector3Value *v));

DM_PROP(sphericalCoordYZAngle,
        CRSphericalCoordYZAngle,
        SphericalCoordYZAngle,
        getSphericalCoordYZAngle,
        Vector3Bvr,
        SphericalCoordYZAngle,
        v,
        AxANumber *PhiCoordVector3(Vector3Value *v));

DM_PROP(sphericalCoordLength,
        CRSphericalCoordLength,
        SphericalCoordLength,
        getSphericalCoordLength,
        Vector3Bvr,
        SphericalCoordLength,
        v,
        AxANumber *RhoCoordVector3(Vector3Value *v));


DM_PROP(x,
        CRGetX,
        X,
        getX,
        Point3Bvr,
        GetX,
        v,
        AxANumber *XCoordPoint3(Point3Value *v));

DM_PROP(y,
        CRGetY,
        Y,
        getY,
        Point3Bvr,
        GetY,
        v,
        AxANumber *YCoordPoint3(Point3Value *v));

DM_PROP(z,
        CRGetZ,
        Z,
        getZ,
        Point3Bvr,
        GetZ,
        v,
        AxANumber *ZCoordPoint3(Point3Value *v));

DM_PROP(sphericalCoordXYAngle,
        CRSphericalCoordXYAngle,
        SphericalCoordXYAngle,
        getSphericalCoordXYAngle,
        Point3Bvr,
        SphericalCoordXYAngle,
        v,
        AxANumber *ThetaCoordPoint3(Point3Value *v));

DM_PROP(sphericalCoordYZAngle,
        CRSphericalCoordYZAngle,
        SphericalCoordYZAngle,
        getSphericalCoordYZAngle,
        Point3Bvr,
        SphericalCoordYZAngle,
        v,
        AxANumber *PhiCoordPoint3(Point3Value *v));

DM_PROP(sphericalCoordLength,
        CRSphericalCoordLength,
        SphericalCoordLength,
        getSphericalCoordLength,
        Point3Bvr,
        SphericalCoordLength,
        v,
        AxANumber *RhoCoordPoint3(Point3Value *v));

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\xform2.h ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    2D affine transforms

--*/

#ifndef _XFORM2_H
#define _XFORM2_H

#include "appelles/common.h"
#include "appelles/valued.h"
#include "appelles/vec2.h"


DM_CONST(identityTransform2,
         CRIdentityTransform2,
         IdentityTransform2,
         identityTransform2,
         Transform2Bvr,
         CRIdentityTransform2,
         Transform2 *identityTransform2);


    // Translation

DM_FUNC(translate,
        CRTranslate2,
        Translate2Anim,
        translate,
        Transform2Bvr,
        CRTranslate2,
        NULL,
        Transform2 *TranslateRealReal (AnimPixelValue *Tx,
                                       AnimPixelYValue *Ty));

DM_FUNC(translate,
        CRTranslate2,
        Translate2,
        translate,
        Transform2Bvr,
        CRTranslate2,
        NULL,
        Transform2 *TranslateRealReal (PixelValue *Tx,
                                       PixelYValue *Ty));

DM_FUNC(translate,
        CRTranslate2,
        Translate2Rate,
        translateRate,
        Transform2Bvr,
        CRTranslate2,
        NULL,
        Transform2 *TranslateRealReal (RatePixelValue *Tx, RatePixelYValue *Ty));

DM_FUNC(translate,
        CRTranslate2,
        Translate2Vector,
        translate,
        Transform2Bvr,
        CRTranslate2,
        NULL,
        Transform2 *TranslateVector2Value (Vector2Value *delta));

DM_FUNC(translate,
        CRTranslate2,
        Translate2Point,
        translate,
        Transform2Bvr,
        CRTranslate2,
        NULL,
        Transform2 *Translate2PointValue(Point2Value *pos));

    // Scaling

DM_FUNC(scale,
        CRScale2,
        Scale2Anim,
        scale,
        Transform2Bvr,
        CRScale2,
        NULL,
        Transform2 *ScaleRealReal (AxANumber *x, AxANumber *y));

DM_FUNC(scale,
        CRScale2,
        Scale2,
        scale,
        Transform2Bvr,
        CRScale2,
        NULL,
        Transform2 *ScaleRealReal (DoubleValue *x, DoubleValue *y));

DM_FUNC(scale,
        CRScale2,
        Scale2Rate,
        scaleRate,
        Transform2Bvr,
        CRScale2,
        NULL,
        Transform2 *ScaleRealReal (ScaleRateValue *x, ScaleRateValue *y));

// This function is OBSOLETE.  Maintained for compatability.
DM_FUNC(ignore,
        CRScale2,
        Scale2Vector2,
        ignore,
        Transform2Bvr,
        CRScale2,
        NULL,
        Transform2 *ScaleVector2Value (Vector2Value *obsoleteMethod));

DM_FUNC(scale,
        CRScale2,
        Scale2Vector,
        scale,
        Transform2Bvr,
        CRScale2,
        NULL,
        Transform2 *ScaleVector2Value (Vector2Value *scale_vec));

// Need to disambiguate from Scale(AxANumber) that returns a 3D transform. 

DM_FUNC(scale2,
        CRScale2Uniform,
        Scale2UniformAnim,
        scale2,
        Transform2Bvr,
        CRScale2Uniform,
        NULL,
        Transform2 *Scale2 (AxANumber *uniform_scale));


DM_FUNC(scale2,
        CRScale2Uniform,
        Scale2Uniform,
        scale2,
        Transform2Bvr,
        CRScale2Uniform,
        NULL,
        Transform2 *Scale2 (DoubleValue *uniform_scale));

DM_FUNC(scale2,
        CRScale2Uniform,
        Scale2UniformRate,
        scale2Rate,
        Transform2Bvr,
        CRScale2Uniform,
        NULL,
        Transform2 *Scale2 (RateValue *uniform_scale));


    // Rotation around an axis, similar to OpenGL

DM_FUNC(rotate,
        CRRotate2,
        Rotate2Anim,
        rotate,
        Transform2Bvr,
        CRRotate2,
        NULL,
        Transform2 *RotateReal(AxANumber *angle));

DM_FUNC(rotate,
        CRRotate2,
        Rotate2,
        rotate,
        Transform2Bvr,
        CRRotate2,
        NULL,
        Transform2 *RotateReal(DoubleValue *angle));

DM_FUNC(rotate,
        CRRotate2,
        Rotate2Rate,
        rotateRate,
        Transform2Bvr,
        CRRotate2,
        NULL,
        Transform2 *RotateReal(RateValue *angle));

DM_FUNC(rotateDegrees,
        CRRotate2Degrees,
        Rotate2Degrees,
        rotateDegrees,
        Transform2Bvr,
        CRRotate2Degrees,
        NULL,
        Transform2 *RotateReal(DegreesValue *angle));

DM_FUNC(rotateRateDegrees,
        CRRotate2,
        Rotate2RateDegrees,
        rotateRateDegrees,
        Transform2Bvr,
        CRRotate2,
        NULL,
        Transform2 *RotateReal(RateDegreesValue *angle));


    // Shear transformation

DM_FUNC(xShear,
        CRXShear2,
        XShear2Anim,
        xShear,
        Transform2Bvr,
        CRXShear2,
        NULL,
        Transform2 *XShear2 (AxANumber *));

DM_FUNC(xShear,
        CRXShear2,
        XShear2,
        xShear,
        Transform2Bvr,
        CRXShear2,
        NULL,
        Transform2 *XShear2 (DoubleValue *));

DM_FUNC(xShear,
        CRXShear2,
        XShear2Rate,
        xShearRate,
        Transform2Bvr,
        CRXShear2,
        NULL,
        Transform2 *XShear2 (RateValue *));

DM_FUNC(yShear,
        CRYShear2,
        YShear2Anim,
        yShear,
        Transform2Bvr,
        CRYShear2,
        NULL,
        Transform2 *YShear2 (AxANumber *));

DM_FUNC(yShear,
        CRYShear2,
        YShear2,
        yShear,
        Transform2Bvr,
        CRYShear2,
        NULL,
        Transform2 *YShear2 (DoubleValue *));

DM_FUNC(yShear,
        CRYShear2,
        YShear2Rate,
        yShearRate,
        Transform2Bvr,
        CRYShear2,
        NULL,
        Transform2 *YShear2 (RateValue *));


    // 2x3 affine matrix transformation.  This follows the
    // pre-multiply conventions 
    // (point is a column vector) in Foley & van Dam, 2nd ed.  This
    // means that (a13,a23) in a 2x3 is the translation component. 

DM_FUNC(transform3x2,
        CRTransform3x2,
        Transform3x2AnimEx,
        transform3x2,
        Transform2Bvr,
        CRTransform3x2,
        NULL,
        Transform2 *MatrixTransform(DM_ARRAYARG(AxANumber*, AxAArray*) m));
DM_FUNC(transform3x2,
        CRTransform3x2,
        Transform3x2Anim,
        ignore,
        ignore,
        CRTransform3x2,
        NULL,
        Transform2 *MatrixTransform(DM_SAFEARRAYARG(AxANumber*, AxAArray*) m));


    // Transform composition (*), and composition with inverse (/)

DM_INFIX(o,
         CRCompose2,
         Compose2,
         compose,
         Transform2Bvr,
         CRCompose2,
         NULL,
         Transform2 *TimesTransform2Transform2(Transform2 *a, Transform2 *b));

DM_INFIX(ignore,
         CRCompose2,
         Compose2ArrayEx,
         compose2Array,
         Transform2Bvr,
         CRCompose2,
         NULL,
         Transform2 *Compose2Array(DM_ARRAYARG(Transform2*, AxAArray*) xfs));

DM_INFIX(ignore,
         CRCompose2,
         Compose2Array,
         ignore,
         ignore,
         CRCompose2,
         NULL,
         Transform2 *Compose2Array(DM_SAFEARRAYARG(Transform2*, AxAArray*) xfs));

    // Transformation of points and vectors

DM_FUNC(transform,
        CRTransform,
        Transform,
        transform,
        Point2Bvr,
        Transform,
        pt,
        Point2Value *TransformPoint2Value(Transform2 *xf, Point2Value *pt));

DM_FUNC(transform,
        CRTransform,
        Transform,
        transform,
        Vector2Bvr,
        Transform,
        vec,
        Vector2Value *TransformVector2Value(Transform2 *xf, Vector2Value *vec));


    // Invert transformation

DM_FUNC(inverse,
        CRInverse,
        Inverse,
        inverse,
        Transform2Bvr,
        Inverse,
        theXf,
        Transform2 *InverseTransform2 (Transform2 *theXf));


    // Is Singular

DM_PROP(isSingular,
        CRIsSingular,
        IsSingular,
        isSingular,
        Transform2Bvr,
        IsSingular,
        theXf,
        AxABoolean *IsSingularTransform2 (Transform2 *theXf));


// This function takes a 3D (non-perspective) transform, and returns a 2D
// transform that mimics an orthographic view using the 3D transform.  In
// other words, it allows one to apply a virtual 3D transform to a 2D object.

DM_FUNC(parallelTransform2,
        CRParallelTransform2,
        ParallelTransform2,
        parallelTransform2,
        Transform3Bvr,
        ParallelTransform2,
        xf,
        Transform2 *ParallelTransform2(Transform3 *xf));

#if _USE_PRINT
extern ostream& operator<<(ostream& os,  Transform2 &xf);
#endif

extern void 
TransformPointsToGDISpace(Transform2 *a,
                          Point2Value **srcPts, 
                          POINT *gdiPts,
                          int numPts,
                          int width,
                          int height,
                          Real resolution);

#endif /* _XFORM2_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\aamidi.h ===
#ifndef _AAMIDI_H
#define _AAMIDI_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Private include file for defining sounds.
*******************************************************************************/


#include "appelles/sound.h"

#include "privinc/storeobj.h"
#include "privinc/geomi.h"
#include "privinc/path.h"
#include "privinc/helpds.h"
#include "privinc/helpaa.h"
#include "privinc/dsdev.h"
#include "privinc/snddev.h"
#include "privinc/midi.h"
#include "msimusic.h"

class myMessageHandler:public IAANotifySink
{
  private:
    UINT    m_cRef;
    // CWnd    *m_pCurrentClass, *m_pLastClass;  MFC stuff?

  public:
    myMessageHandler();
    ~myMessageHandler();

    // IUnknown Methods 
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // IAANotifySink methods
    STDMETHOD(OnEmbellishment) (THIS_ DWORD dwTime, AACommands embellishment, 
        AAFlags flags);
    STDMETHOD(OnGroove) (THIS_ DWORD dwTime, AACommands groove, AAFlags flags);
    STDMETHOD(OnMetronome) (THIS_ DWORD dwTime, 
        unsigned short nMeasure, unsigned short nBeat);
    STDMETHOD(OnMIDIInput) (THIS_ long lMIDIEvent, long lMusicTime);
    STDMETHOD(OnNextSection) (THIS_ DWORD dwTime, IAASection FAR *pSection,
        AAFlags flags);
    STDMETHOD(OnNotePlayed) (THIS_ AAEVENT FAR *pEvent);
    STDMETHOD(OnSectionEnded) (THIS_ DWORD dwTime, IAASection FAR *pSection,
        AAFlags flags, DWORD lEndTime);
    STDMETHOD(OnSectionChanged) (THIS_ DWORD dwTime, IAASection FAR *pSection,
        AAFlags flags);
    STDMETHOD(OnSectionStarted) (THIS_ DWORD dwTime, IAASection FAR *pSection,
        AAFlags flags);
    STDMETHOD(OnSongEnded) (THIS_ DWORD dwTime, IAASong FAR *pSong, 
        AAFlags flags, DWORD lEndTime);
    STDMETHOD(OnSongStarted) (THIS_ DWORD dwTime, IAASong FAR *pSong,
        AAFlags flags);
    STDMETHOD(OnMotifEnded) (THIS_ DWORD dwTime, IAAMotif *pMotif,
        AAFlags flags);
    STDMETHOD(OnMotifStarted) (THIS_ DWORD dwTime, IAAMotif *pMotif,
        AAFlags flags);
    STDMETHOD(OnMotifStoped) (THIS_ DWORD dwTime);
    STDMETHOD(OnUserEvent) (THIS_ DWORD dwTime, DWORD lParaml, DWORD lParam2);
    STDMETHOD(OnMusicStopped) (THIS_ DWORD dwTime);
};


class aaMIDIsound : public MIDIsound, myMessageHandler {
  public:
    aaMIDIsound();
    ~aaMIDIsound();
    virtual void Open(char *fileName);
#if _USE_PRINT
    ostream& Print(ostream& s) { return s << "MIDI"; }
#endif

    virtual bool RenderAvailable(MetaSoundDevice *);
    virtual void RenderNewBuffer(BufferElement *bufferElement,
                  MetaSoundDevice *metaDev);
    virtual void RenderAttributes(MetaSoundDevice *, BufferElement *,
                  double rate, bool doSeek, double seek);
    virtual void RenderStartAtLocation(MetaSoundDevice *,
        BufferElement *bufferElement, double phase, Bool looping);
    virtual Bool RenderPhaseLessThanLength(double phase);
    virtual void RenderStop(MetaSoundDevice *, BufferElement *);
    virtual void RenderSamples(MetaSoundDevice *, BufferElement *) {}
    virtual void RenderSetMute(MetaSoundDevice *, BufferElement *); 
    virtual Bool RenderCheckComplete(MetaSoundDevice *, BufferElement *);
    virtual void RenderCleanupBuffer(MetaSoundDevice *, BufferElement *);
    virtual double GetLength();

    //Message Handler methods
    //STDMETHODIMP OnSectionEnded(LPAASECTION pSection, AAFlags flags,
        //long lEndTime);
    STDMETHOD(OnSectionEnded) (THIS_ DWORD dwTime, IAASection FAR *pSection,
        AAFlags flags, DWORD lEndTime);

  protected:
    char       *fileName;
    Bool        _started;
    Bool        _ended;
    Bool        _looping;
    IAASection *_section; // AudioActive Section
};


#endif /* _AAMIDI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\include\appelles\xform.h ===
#ifndef _APXFORM_H
#define _APXFORM_H

/*******************************************************************************
Copyright (c) 1995-96  Microsoft Corporation

    3D affine and perspective transformations

*******************************************************************************/

#include "appelles/common.h"
#include "appelles/valued.h"
#include "appelles/vec3.h"
#include "appelles/quat.h"


// Identity Transform

DM_CONST(identityTransform3,
         CRIdentityTransform3,
         IdentityTransform3,
         identityTransform3,
         Transform3Bvr,
         CRIdentityTransform3,
         Transform3 *identityTransform3);

// Translation

DM_FUNC(translate,
        CRTranslate3,
        Translate3Anim,
        translate,
        Transform3Bvr,
        CRTranslate3,
        NULL,
        Transform3 *TranslateReal3 (AnimPixelValue* tx,
                                    AnimPixelYValue* ty,
                                    AnimPixelValue* tz));
DM_FUNCFOLD(translate,
        CRTranslate3,
        Translate3,
        translate,
        Transform3Bvr,
        CRTranslate3,
        NULL,
        Transform3 *Translate(PixelDouble tx,
                              PixelYDouble ty,
                              PixelDouble tz));

DM_FUNC(translate,
        CRTranslate3,
        Translate3Rate,
        translateRate,
        Transform3Bvr,
        CRTranslate3,
        NULL,
        Transform3 *TranslateReal3 (RatePixelValue *tx,
                                    RatePixelYValue *ty,
                                    RatePixelValue *tz));

DM_FUNC(translate,
        CRTranslate3,
        Translate3Vector,
        translate,
        Transform3Bvr,
        CRTranslate3,
        NULL,
        Transform3 *TranslateVector3 (Vector3Value *delta));

DM_FUNC(translate,
        CRTranslate3,
        Translate3Point,
        translate,
        Transform3Bvr,
        CRTranslate3,
        NULL,
        Transform3 *TranslatePoint3 (Point3Value *new_origin));


// Scaling

DM_FUNC(scale,
        CRScale3,
        Scale3Anim,
        scale,
        Transform3Bvr,
        CRScale3,
        NULL,
        Transform3 *ScaleReal3   (AxANumber *x, AxANumber *y, AxANumber *z));

DM_FUNCFOLD(scale,
        CRScale3,
        Scale3,
        scale,
        Transform3Bvr,
        CRScale3,
        NULL,
        Transform3 *Scale (double x, double y, double z));

DM_FUNC(scale,
        CRScale3,
        Scale3Rate,
        scaleRate,
        Transform3Bvr,
        CRScale3,
        NULL,
        Transform3 *ScaleReal3   (ScaleRateValue *x, ScaleRateValue *y, ScaleRateValue *z));

DM_FUNC(scale,
        CRScale3,
        Scale3Vector,
        scale,
        Transform3Bvr,
        CRScale3,
        NULL,
        Transform3 *ScaleVector3 (Vector3Value *scale_vec));

DM_FUNC(scale3,
        CRScale3Uniform,
        Scale3UniformAnim,
        scale3,
        Transform3Bvr,
        CRScale3Uniform,
        NULL,
        Transform3 *Scale3UniformNumber (AxANumber *uniform_scale));

DM_FUNCFOLD(scale3,
        CRScale3Uniform,
        Scale3Uniform,
        scale3,
        Transform3Bvr,
        CRScale3Uniform,
        NULL,
        Transform3 *Scale3UniformDouble (double uniform_scale));
DM_FUNC(scale3,
        CRScale3Uniform,
        Scale3UniformRate,
        scale3Rate,
        Transform3Bvr,
        CRScale3Uniform,
        NULL,
        Transform3 *Scale3UniformNumber (ScaleRateValue *uniform_scale));


// Rotation around an axis, similar to OpenGL

DM_FUNC(rotate,
        CRRotate3,
        Rotate3Anim,
        rotate,
        Transform3Bvr,
        CRRotate3,
        NULL,
        Transform3 *RotateAxisReal (Vector3Value *axis, AxANumber *angle));

// Code review: do we need a different one for the Java version?
// What if axis is time-varying?

DM_FUNCFOLD(rotate,
        CRRotate3,
        Rotate3,
        rotate,
        Transform3Bvr,
        CRRotate3,
        NULL,
        Transform3 *RotateAxis (Vector3Value *axis, double angle));

DM_FUNC(rotate,
        CRRotate3,
        Rotate3Rate,
        rotateRate,
        Transform3Bvr,
        CRRotate3,
        NULL,
        Transform3 *RotateAxisReal (Vector3Value *axis, RateValue *angle));

// same question here.

DM_FUNCFOLD(rotateDegrees,
        CRRotate3,
        Rotate3Degrees,
        rotateDegrees,
        Transform3Bvr,
        CRRotate3,
        NULL,
        Transform3 *RotateAxis (Vector3Value *axis, DegreesDouble *angle));

DM_FUNC(rotate,
        CRRotate3,
        Rotate3RateDegrees,
        rotateRateDegrees,
        Transform3Bvr,
        CRRotate3,
        NULL,
        Transform3 *RotateAxisReal (Vector3Value *axis, RateDegreesValue *angle));

                                
// Transformation of points and vectors

DM_FUNC(transform,
        CRTransform,
        Transform,
        transform,
        Vector3Bvr,
        Transform,
        vec,
        Vector3Value *TransformVec3 (Transform3 *xf, Vector3Value *vec));

DM_FUNC(transform,
        CRTransform,
        Transform,
        transform,
        Point3Bvr,
        Transform,
        pt,
        Point3Value *TransformPoint3(Transform3 *xf, Point3Value *pt));

// Shear transformation

DM_FUNC(xShear,
        CRXShear3,
        XShear3Anim,
        xShear,
        Transform3Bvr,
        CRXShear3,
        NULL,
        Transform3 *XShear3Number (AxANumber *a, AxANumber *b));

DM_FUNCFOLD(xShear,
        CRXShear3,
        XShear3,
        xShear,
        Transform3Bvr,
        CRXShear3,
        NULL,
        Transform3 *XShear3Double (double a, double b));

DM_FUNC(xShear,
        CRXShear3,
        XShear3Rate,
        xShearRate,
        Transform3Bvr,
        CRXShear3,
        NULL,
        Transform3 *XShear3Number (RateValue *a, RateValue *b));

DM_FUNC(yShear,
        CRYShear3,
        YShear3Anim,
        yShear,
        Transform3Bvr,
        CRYShear3,
        NULL,
        Transform3 *YShear3Number (AxANumber *c, AxANumber *d));

DM_FUNCFOLD(yShear,
        CRYShear3,
        YShear3,
        yShear,
        Transform3Bvr,
        CRYShear3,
        NULL,
        Transform3 *YShear3Double (double c, double d));

DM_FUNC(yShear,
        CRYShear3,
        YShear3Rate,
        yShearRate,
        Transform3Bvr,
        CRYShear3,
        NULL,
        Transform3 *YShear3Number (RateValue *c, RateValue *d));

DM_FUNC(zShear,
        CRZShear3,
        ZShear3Anim,
        zShear,
        Transform3Bvr,
        CRZShear3,
        NULL,
        Transform3 *ZShear3Number (AxANumber *e, AxANumber *f));

DM_FUNCFOLD(zShear,
        CRZShear3,
        ZShear3,
        zShear,
        Transform3Bvr,
        CRZShear3,
        NULL,
        Transform3 *ZShear3Double (double e, double f));

DM_FUNC(zShear,
        CRZShear3,
        ZShear3Rate,
        zShearRate,
        Transform3Bvr,
        CRZShear3,
        NULL,
        Transform3 *ZShear3Number (RateValue *e, RateValue *f));


// 4x4 matrix transformation.  This follows the pre-multiply conventions
// (point is a column vector) in Foley & van Dam, 2nd ed.  This means that
// (a14,a24,a34) in a 4x4 is the translation component. 

DM_FUNC(transform4x4,
        CRTransform4x4,
        Transform4x4AnimEx,
        transform4x4,
        Transform3Bvr,
        CRTransform4x4,
        NULL,
        Transform3 *MatrixTransform4x4(DM_ARRAYARG(AxANumber*, AxAArray*) m));

DM_FUNC(transform4x4,
        CRTransform4x4,
        Transform4x4Anim,
        ignore,
        ignore,
        CRTransform4x4,
        NULL,
        Transform3 *MatrixTransform4x4(DM_SAFEARRAYARG(AxANumber*, AxAArray*) m));

// TODO: Get rid of this
extern Transform3 *PRIVMatrixTransform4x4 (
    AxANumber *a00,   AxANumber *a01,   AxANumber *a02,   AxANumber *a03,
    AxANumber *a10,   AxANumber *a11,   AxANumber *a12,   AxANumber *a13,
    AxANumber *a20,   AxANumber *a21,   AxANumber *a22,   AxANumber *a23,
    AxANumber *a30,   AxANumber *a31,   AxANumber *a32,   AxANumber *a33);

// Multiplication and concatenation follow "pre-multiply" conventions:
// x transformed by (A * B) is the same as A applied to the result of
// transforming x by B, i.e., A(B(x)).

DM_INFIX(o,
         CRCompose3,
         Compose3,
         compose,
         Transform3Bvr,
         CRCompose3,
         NULL,
         Transform3* TimesXformXform (Transform3 *a, Transform3 *b));

DM_INFIX(ignore,
         CRCompose3,
         Compose3ArrayEx,
         compose3Array,
         Transform3Bvr,
         CRCompose3,
         NULL,
         Transform3 *Compose3Array(DM_ARRAYARG(Transform3*, AxAArray*) xfs));

DM_INFIX(ignore,
         CRCompose3,
         Compose3Array,
         ignore,
         ignore,
         CRCompose3,
         NULL,
         Transform3 *Compose3Array(DM_SAFEARRAYARG(Transform3*, AxAArray*) xfs));

// Invert transformation

DM_FUNC(inverse,
        CRInverse,
        Inverse,
        inverse,
        Transform3Bvr,
        Inverse,
        xform,
        Transform3 *InverseTransform3 (Transform3 *xform));


// Singularity test

DM_PROP(isSingular,
        CRIsSingular,
        IsSingular,
        isSingular,
        Transform3Bvr,
        IsSingular,
        xform,
        AxABoolean *IsSingularTransform3 (Transform3 *xform));



    /**********************************************/
    /***  Position/Orientation Transformations  ***/
    /**********************************************/

// These functions define location/orientation transforms that will be useful
// for cameras, lights and objects.  The object should be located at the
// origin, looking toward -Z, with +Y up.

// LookAtFrom() places the object at the 'from' point, looking at the 'to' 
// point, with the 'up' vector pointing up.

DM_FUNC(lookAtFrom,
        CRLookAtFrom,
        LookAtFrom,
        lookAtFrom,
        Transform3Bvr,
        CRLookAtFrom,
        NULL,
        Transform3 *LookAtFrom (Point3Value *to, Point3Value *from, Vector3Value *up));

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\backend.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    General header for the backend.

*******************************************************************************/


#ifndef _BACKEND_H
#define _BACKEND_H

typedef double Time;

class BvrBase;
typedef BvrBase *Bvr;

class PerfBase;
typedef PerfBase *Perf;

class TimeXformImpl;
typedef TimeXformImpl* TimeXform;

class TimeSubstitutionImpl;
typedef TimeSubstitutionImpl *TimeSubstitution;

TimeSubstitution CopyTimeSubstitution(TimeSubstitution t);

class AxAValueObj;
typedef AxAValueObj *AxAValue;

// Not all classes need to be added here.  Only the classes which will
// need to be queried.  All others should return UNKNOWN_BTYPEID to
// indicate that they are not part of the enumeration

enum BVRTYPEID {
    UNKNOWN_BTYPEID = 0,
    PRIMAPPLY_BTYPEID,
    SWITCH_BTYPEID,
    UNTIL_BTYPEID,
    CONST_BTYPEID,
    PAIR_BTYPEID,
    SWITCHER_BTYPEID,
    TUPLE_BTYPEID,
    ARRAY_BTYPEID,
    SOUND_BTYPEID,
};

class GCFuncObjImpl;
typedef GCFuncObjImpl *GCFuncObj;

class GCInfo;
typedef GCInfo *GCList;

class GCObj;

class GCRootsImpl;
typedef GCRootsImpl *GCRoots;

#if DEVELOPER_DEBUG
void DumpGCRoots(GCRoots roots);
#endif

// This is for controlling access to the GC and for ensuring all
// objects are well formed before doing a GC

// Use GCL_CREATE to ensure that create operations and adding to the
// roots in atomic

// Use GCL_MODIFY when modifying a behaviors children or parent

// Use GCL_COLLECT before performing garbage collection
// This is really an internal flag and should not be used w/o knowing
// the internals of the GC.

enum GCLockAccess {
    GCL_CREATE,
    GCL_MODIFY,
    GCL_COLLECT
};

// Acquire an access lock of the given type
void AcquireGCLock(GCLockAccess access);
// Release a previously acquired lock
void ReleaseGCLock(GCLockAccess access);
// Get status of a lock - returns the number of locks
int GetGCLockStatus(GCLockAccess access);
#ifdef DEVELOPER_DEBUG
bool IsGCLockAcquired(DWORD tid);
#endif

// Use to handle exceptions
class GCLockGrabber
{
  public:
    GCLockGrabber(GCLockAccess access) : _access(access)
    { AcquireGCLock(_access); }
    ~GCLockGrabber()
    { ReleaseGCLock(_access); }
  protected:
    GCLockAccess _access;
};


#define GC_BEGIN(access) { GCLockGrabber __gclg(access);
#define GC_END(access) }

#define GC_CREATE_BEGIN GC_BEGIN(GCL_CREATE)
#define GC_CREATE_END GC_END(GCL_CREATE)
    
#define GC_MODIFY_BEGIN GC_BEGIN(GCL_MODIFY)
#define GC_MODIFY_END GC_END(GCL_MODIFY)
    
#define GC_COLLECT_BEGIN GC_BEGIN(GCL_COLLECT)
#define GC_COLLECT_END GC_END(GCL_COLLECT)

// This can be called multiple times to ensure the garbage collector
// thread has been created

void StartCollector();
void StopCollector();

#endif /* _BACKEND_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\bbox3i.h ===
#ifndef _BBOX3I_H
#define _BBOX3I_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    3D bounding box abstract class
*******************************************************************************/

#include "privinc/vec3i.h"
#include "appelles/bbox3.h"


class Bbox3 : public AxAValueObj
{
  public:

    Point3Value min;
    Point3Value max;

    Bbox3 (void);     // Initializes to nullBbox3

    Bbox3 (Point3Value &pmin, Point3Value &pmax);
    Bbox3 (Real xmin, Real ymin, Real zmin, Real xmax, Real ymax, Real zmax);
    Bbox3 (struct _D3DRMBOX &d3dbox);

           bool operator== (Bbox3 &other);
    inline bool operator!= (Bbox3 &other) { return !(*this == other); }

    // Return whether the bbox is finite or not.  This is true if all
    // coordinates of the min and max points are finite.  Note that this means
    // that a null bbox3 is not finite.

    bool Finite (void);

    // Return whether the bbox is non-negative in each dimension.

    bool Positive (void);

    inline bool PositiveFinite (void) { return Positive() && Finite(); }

    // Test the bbox against a plane defined by a point and a normal vector

    ClipCode Clip(Plane3 &plane);

    // Augment the box to include the given point or box.

    void Augment (Real x, Real y, Real z);
    void Augment (Point3Value &p);
    void Augment (Bbox3 &box);

    // Return the point of intersection of the ray with the bounding box.  If
    // there is no intersection, this function returns null.

    Point3Value *Intersection (Ray3*);

    Point3Value *Center (void);

    void GetPoints(Point3Value *pts);

    virtual DXMTypeInfo GetTypeInfo() { return Bbox3Type; }
};

    // Bounding Box Values

extern Bbox3 *universeBbox3;   // Contains all points, boxes
extern Bbox3 *nullBbox3;       // Contains no points, boxes

    // Get the bounding box of two bounding boxes.

Bbox3 *Union (Bbox3 &b1, Bbox3 &b2);
Bbox3 *Intersection (Bbox3 &b1, Bbox3 &b2);

    // Transform a bounding box and return the screen aligned bounding box
    // that surrounds the result.

Bbox3 *TransformBbox3 (Transform3 *xf, Bbox3 *box);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\basic.h ===
#ifndef _APPINC_BASIC_H
#define _APPINC_BASIC_H

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

/*******************************************************************************
Copyright (c) 1995_96 Microsoft Corporation
*******************************************************************************/

#include <float.h>
#include "privinc/util.h"

class AxANumber : public AxAValueObj
{
  public:

    AxANumber(void) : _num(0.0) {}

    // Ensure that the given value is a valid number.

    AxANumber(double n) { SetNum (n); }

    double GetNum() { return _num; }

    void SetNum (double n)
    {
        if (!_isnan(n))
            _num = n;
        else
        {   _num = 0;
            TraceTag ((tagWarning, "AxANumber: NaN converted to 0."));
        }
    }

    #if _USE_PRINT
        virtual ostream& Print(ostream& os) { return os << _num; }
    #endif

    virtual DXMTypeInfo GetTypeInfo() { return AxANumberType; }

  private:
    double _num;
};

inline AxANumber * RealToNumber(Real val)
{ return NEW AxANumber(val) ; }

inline Real NumberToReal(AxANumber * num)
{ return num->GetNum() ; }

class AxALong : public AxAValueObj
{
  public:
    AxALong(long f) : _long(f) {}
    AxALong() : _long(0) {}

    long GetLong() { return _long; }
    void   SetLong(long num) { _long = num; }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _long; }
#endif

    virtual DXMTypeInfo GetTypeInfo() { return AxALongType; }

  private:
    long _long;
};

inline AxALong * LongToAxALong(long val)
{ return NEW AxALong(val) ; }

inline long AxALongToLong(AxALong * num)
{ return num->GetLong() ; }

class AxABoolean : public AxAValueObj
{
  public:
    AxABoolean(bool b) : _boolean(b) {}
    AxABoolean(BOOL b) : _boolean(b!=0) {}

    bool GetBool() { return _boolean; }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _boolean; }
#endif

    virtual DXMTypeInfo GetTypeInfo() { return AxABooleanType; }

  private:
    bool _boolean;
};

inline AxABoolean *BOOLToAxABoolean(bool val)
{ return NEW AxABoolean (val) ; }

inline bool AxABooleanToBOOL(AxABoolean *b)
{ return b->GetBool(); }

class AxAString : public AxAValueObj
{
  public:
    AxAString(WideString s, bool bCopy = true)
    : _str(NULL) {
        if (bCopy)
            _str = CopyStringFromStore(s);
        else
            _str = s;
    }

    AxAString(RawString s)
    : _str(NULL) {
        _str = CopyRawString(s);
    }

    ~AxAString() {
        FreeStringFromStore(_str);
    }
    
    WideString GetStr() { return _str; }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _str; }
#endif

    virtual DXMTypeInfo GetTypeInfo() { return AxAStringType; }

  private:
    WideString _str;
};

inline AxAString * CharPtrToString(WideString val, bool bCopy = true)
{ return NEW AxAString(val,bCopy) ; }

inline AxAString * CharPtrToString(RawString val)
{ return NEW AxAString(val) ; }

inline WideString StringToCharPtr(AxAString * val)
{ return val->GetStr() ; }

extern AxAValue Trivial();

class AxAVariant : public AxAValueObj
{
  public:
    AxAVariant(VARIANT& v) : _v(v)
    {
        // Better not be transient heap, or variant won't go away. 
        Assert(!GetHeapOnTopOfStack().IsTransientHeap());
    }
    
    virtual DXMTypeInfo GetTypeInfo() { return AxAValueType; }

    VARIANT& GetVariant() { return _v; }

  protected:
    CComVariant _v;
};

class AxAPair : public AxAValueObj
{
  public:
    AxAPair(AxAValue a, AxAValue b) : _left(a), _right(b) {}

    AxAValue Left() { return _left; }
    AxAValue Right() { return _right; }

#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "(" << _left << ", " << _right << ")"; }
#endif

    virtual void DoKids(GCFuncObj proc);

    virtual DXMTypeInfo GetTypeInfo() { return AxAPairType; }
    virtual VALTYPEID GetValTypeId() { return PAIR_VTYPEID; }

  private:
    AxAValue _left;
    AxAValue _right;
};

class AxAPrimOp : public AxAValueObj
{
  public:
    AxAPrimOp(void *primfun,
              int nargs,
              char * name,
              DXMTypeInfo type,
              int polymorphicArgument = 0)
         : _primfun (primfun),
           _nargs(nargs),
           _name(name),
           _type(type),
           _polymorphicArg(polymorphicArgument) {}
    void * GetPrimFun () { return _primfun ; }
    int GetNumArgs () { return _nargs ; }
    char *GetName () { return _name; }
    int GetPolymorphicArg () { return _polymorphicArg; }
    virtual DXMTypeInfo GetTypeInfo () { return _type ; }
    void DoKids(GCFuncObj proc);
    virtual AxAValue Apply (int nargs, AxAValue cargs[]);
    virtual VALTYPEID GetValTypeId() { return PRIMOP_VTYPEID; }
  protected:
    void * _primfun ;
    int _nargs ;
    char * _name ;
    int _polymorphicArg;
    DXMTypeInfo _type;
};

AxAPrimOp * 
ValPrimOp(void* primfun,
          int nargs,
          char * name,
          DXMTypeInfo type,
          int polymorphicArgument = 0);

class FixedArray : public StoreObj {
  public:
    FixedArray(long sz, GCBase **a = NULL);
    ~FixedArray();
    virtual void DoKids(GCFuncObj proc);
    GCBase*& operator[](long i);
    long Length() { return _sz; }

#if _USE_PRINT
    virtual ostream& Print(ostream& os);
#endif
  protected:
    long _sz;
    GCBase **_arr;
};

class AxAArray : public AxAValueObj
{
  public:
    AxAArray(AxAValue *vals, long n, DXMTypeInfo typeinfo, 
             bool copy = true, bool changeable = true); 

    ~AxAArray();

    AxAValue operator[](long i) { 
        Assert(i>=0 && i<_sz);
        return _vals[i]; 
    }

    long Length() { return _sz; }
    virtual VALTYPEID GetValTypeId() { return ARRAY_VTYPEID; }
    bool Changeable() { return _changeable; }
    virtual DXMTypeInfo GetTypeInfo() { return _typeinfo; }

    virtual void DoKids(GCFuncObj proc);

#if _USE_PRINT
    virtual ostream& Print(ostream& os);
#endif

  protected:
    long _sz;
    AxAValue *_vals;
    DXMTypeInfo _typeinfo;
    bool _changeable;
} ;

// Remove NULLs from array
AxAArray *PackArray(AxAArray *inputArray);

// TODO: clean it up later
AxAArray * MakeValueArray(AxAValue * vals, long num, DXMTypeInfo ti);

#endif /* _APPINC_BASIC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\aadev.h ===
#ifndef _AADEV_H
#define _AADEV_H


/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    DirectSound device interface.

*******************************************************************************/

#include <msimusic.h>
#include "privinc/path.h"
#include "privinc/snddev.h"
#include "privinc/helpaa.h"

class AAengine; // XXX why isn't this being picked up from helpaa.h?

class AudioActiveDev : public GenericDevice{
  public:
    friend SoundDisplayEffect;

    Bool _aactiveAvailable;

    AudioActiveDev();
    ~AudioActiveDev();

    // TODO: Remove it 
    AVPathList GetDonePathList() { return donePathList; }

    // render methods
    void RenderSound(Sound *snd);
    void RenderSound(Sound *lsnd, Sound *rsnd);
    void BeginRendering();
    void EndRendering();

    // XXX these should be protected!
    IAAEngine     *_engine;    // their engine (only passed to new AAengine())!
    AAengine      *_aaEngine;  // this is OUR engine class

  protected:

    // path stuff
    AVPath         path;
    AVPathList     donePathList;

    // values to set, get, unset...
};
#endif /* _AADEV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\bground.h ===
#ifndef _BGROUND_H
#define _BGROUND_H

/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Class which manages background streaming rendering

*******************************************************************************/

#include "privinc/mutex.h"

class LeafSound;
class DSstreamingBufferElement;

class SynthListElement : public AxAThrowingAllocatorClass {
  public:
    SynthListElement(LeafSound * snd,
                     DSstreamingBufferElement *buf);
    SynthListElement() {}; // needed for stl?
    ~SynthListElement();

    // Synth info
    LeafSound       *_sound;         // sound itself

    DSstreamingBufferElement   *_bufferElement;
    bool             _marked;        // this element marked for deletion?
    unsigned         _devKey;        // a key to correlate sounds with devices
};


class BackGround {
  public:
    BackGround() {}
    ~BackGround() {}
    static void ShutdownThread();
    static bool CreateThread();

    void AddSound(LeafSound *sound,
                  MetaSoundDevice *,
                  DSstreamingBufferElement *);
    void RemoveSounds(unsigned devKey);
    static void Configure();
    static void UnConfigure();

    void SetParams(DSstreamingBufferElement *ds,
                   double rate, bool doSeek, double seek, bool loop);
    
    // these are public since they are shared with the thread
    // XXX should they the thread be a friend?
    static bool    _done;           // used to kill thread
    static vector<SynthListElement *> *_synthList;
    static Mutex     *_synthListLock;
    static HANDLE    _terminationHandle;


  protected:
    // thread info
    static CritSect *_cs;
    static DWORD     _threadID;
    static HANDLE    _threadHandle;
};

#endif /* _BGROUND_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\cachdimg.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

*******************************************************************************/

#ifndef _CACHDIMG_H
#define _CACHDIMG_H

#include "privinc/imagei.h"
#include "privinc/DiscImg.h"
#include "privinc/DDSurf.h"
#include "privinc/dddevice.h"


static const int savingsThreshold = 2;

//
// For now this class is associated with only ONE device
//
class CachedImage : public DiscreteImage {
  public:
    CachedImage(Image *underlyingImage,
                bool   usedAsTexture);
    ~CachedImage();
    void CleanUp();

    Bool NeedColorKeySetForMe() { return TRUE; }
    
    void InitializeWithDevice(ImageDisplayDev *dev, Real res);

    void InitIntoDDSurface(DDSurface *ddSurf,
                           ImageDisplayDev *dev);

    Bool DetectHit(PointIntersectCtx & ctx);

    void Render(GenericDevice& dev);

#if _USE_PRINT
    ostream &Print(ostream& os) { return os << "Cached Image"; }
#endif

    virtual void DoKids(GCFuncObj proc);
    
    virtual VALTYPEID GetValTypeId() { return CACHEDIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == CachedImage::GetValTypeId() ||
                DiscreteImage::CheckImageTypeId(type));
    }

    unsigned long   _nominalHeight;
    unsigned long   _nominalWidth;
    
  private:
    Image          *_image;
    bool            _usedAsTexture;
};
    
    
#endif /* _CACHDIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\camerai.h ===
#ifndef _AV_CAMERAI_H
#define _AV_CAMERAI_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    This file contains the definitions of the camera implementation.
*******************************************************************************/

#include "appelles/common.h"
#include "privinc/vecutil.h"
#include "privinc/bbox2i.h"
#include "privinc/bbox3i.h"
#include "privinc/xformi.h"



/*****************************************************************************
The camera class encapsulates the transformation from world to normalized-
device coordinates.  The full transform pipe goes as follows:

        Modeling Coordinates (right-handed)
        World Coordinates (right-handed)
        Camera Coordinates (left- or right-handed)
        NDC Coordinates (left- or right-handed, [-1,-1,0] to [1,1,1])

On RM3, we need to be in left-handed coordinates, so the camera has a twist
going from world to camera coordinates.  On RM6, we operate in native
right-hand mode.
*****************************************************************************/

class Camera : public AxAValueObj
{
  public:

    enum CameraType { PERSPECTIVE, ORTHOGRAPHIC };

    // Create a canonical camera, given the camera type.  An initial camera has
    // image plane at Z=0, gazing toward -Z, with +Y pointing up, and may be
    // either a perspective or an orthographic camera.

    Camera (CameraType camtype = PERSPECTIVE);

    // Create a copy of a camera.

    Camera (Camera*);

    // Create a camera from the transformation of another camera.  The new
    // camera inherits the camera type of the initial camera.

    Camera (Transform3 *xform, Camera *cam);

    // Set the depth of the camera.

    void SetDepth           (Real depth) { _depth = depth; _depthRes = 0; }
    void SetDepthResolution (Real res)   { _depthRes = res; }

    // Camera Queries

    Transform3 *Basis (void) { return _basis; }
    CameraType  Type  (void) { return _type; }

    // These two methods get the transform that goes from camera coordinates
    // to world coordinates, and the reverse, respectively.  Note that camera
    // coordinates are left-handed on RM3, and right-handed on RM6.

    Transform3 *CameraToWorld (void);
    Transform3 *WorldToCamera (void);

    // This function returns the near and far clipping planes for a given
    // volume in world coordinates.  The planes are padded out by 'depthpad'
    // clicks in the Z-buffer dynamic range.  Returns whether or not
    // successful. 

    bool GetNearFar (Bbox3 *wcVolume, Real depthpad, Real &Znear, Real &Zfar);

    // These methods get the camera's perspective projection point in world and
    // camera coordinates.  World coordinates are right-handed, and camera
    // coordinates are left-handed or right-handed.

    Point3Value WCProjPoint (void);   // Projection Point / World Coordinates
    Point3Value CCProjPoint (void);   // Projection Point / Camera Coordinates

    // Cameras can be stretched in width, height and length.  This method
    // returns the scale factors; each of the addresses may be nil.

    void GetScale (Real *x, Real *y, Real *z);

    // This function returns a ray from the point on the image plane into the
    // visible space.  The returned ray originates on the image plane, and is
    // not necessarily unit length.

    Ray3 *GetPickRay (Point2Value *imagePoint);

    // Return the projection of the world coordinate point onto the camera's
    // image plane (at Z=0).

    Point2Value *Project (Point3Value *world_coordinate_point);

#if _USE_PRINT
    ostream &Print (ostream &os) const { return os << "Camera"; }
#endif

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_basis);
        (*proc)(_camToWorld);
        (*proc)(_worldToCam);
    }

    virtual DXMTypeInfo GetTypeInfo() { return ::CameraType; }

    virtual AxAValue ExtendedAttrib(char *attrib, VARIANT& val);
    
  private:

    Transform3 *_basis;       // The camera basis.
    Transform3 *_camToWorld;  // LH-Camera to RH-World Transform
    Transform3 *_worldToCam;  // RH-World to LH-Camera Transform

    Point3Value _wcProjPoint; // Camera Projection Point in World Coords
    Point3Value _ccProjPoint; // Camera Projection Point in Cam Coords

    Vector3Value _scale;           // Camera Scaling Vector

    DynamicHeap &_heap;       // Heap the Camera was Created On

    CameraType  _type;        // Perspective or Orthographic

    Real _depth;              // Visible Depth
    Real _depthRes;           // Depth Resolution
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\colorkeyedimage.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _COLORKEYEDIMAGE_H
#define _COLORKEYEDIMAGE_H

#include <privinc/imagei.h>
#include <privinc/colori.h>

class ColorKeyedImage : public AttributedImage {

  public:

    ColorKeyedImage(Image *underlyingImage, Color *clrKey);

    void Render(GenericDevice& dev);

    void DoKids(GCFuncObj proc);

    inline Color *GetColorKey() { return _colorKey; }

    #if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "(ColorKeyedImage @ " << (void *)this << ")";
    }   
    #endif
  protected:

    Color *_colorKey;
};


#endif /* _COLORKEYEDIMAGE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\bufferl.h ===
#ifndef _BUFFERL_H
#define _BUFFERL_H
/*******************************************************************************

Copyright (c) 1997 Microsoft Corporation

Abstract: BufferList code to manage sound value's information on the device

*******************************************************************************/

#include "headers.h"
#include "privinc/debug.h"
#include "privinc/helpds.h"
#include "privinc/helpq.h"
#include "privinc/stream.h"
#include "privinc/mutex.h"

// forward decls
class BufferElement;

typedef map  < AxAValueObj *, BufferElement *, less<AxAValueObj *> > SoundList;
typedef list < BufferElement * > Blist;


#define RETIREMENT 100  // manditory retirement age
class BufferElement : public AxAThrowingAllocatorClass {
  public:
    BufferElement();
    void Init();                                   // initialize the members
    virtual ~BufferElement();
    void SetThreaded(bool state) { _threaded = state; }
    bool GetThreaded() { return(_threaded); }
    void SetKillFlag(bool state) { _kill = state; }
    bool GetKillFlag() { return(_kill); }
    
    void SetFile(CComPtr<IStream> istream) { _captiveFile = istream; }
    CComPtr<IStream> RemoveFile();
    bool SyncStart() { return(_syncStart); }
    void SetSyncStart() { _syncStart = true; }

    void SetIntendToMute(bool state) { _intendToMute = state; }
    bool GetIntendToMute() { return(_intendToMute); }

    bool             _valid;         // keeping the buffer only for cloning?
    bool             _playing;       // has the sound buffer been Played yet?
    bool             _marked;        // should we delete this element

    void  SetNonAging()  { _age = -1;    } // this is the dawning...
    int   GetAge()       { return(_age); }
    bool  IncrementAge() { return((_age++ > RETIREMENT)?true:false); }

  protected:
    bool             _threaded;      // set if buffer rendered on background thread
    bool             _kill;          // set if buffer should be killed on background thread

    CComPtr<IStream> _captiveFile;   // hold file handle for urlmon downloads
    bool             _syncStart;     // should the sound start be sync'd?
    

  private:
    bool             _intendToMute;
    int              _age;           // used to purge old values from caches
};

class DSbufferElement : public BufferElement {
  public:
    DSbufferElement() {} // XXX why is this needed?

    DSbufferElement(DirectSoundProxy *dsProxy) : _dsProxy(dsProxy) {}
    
    virtual ~DSbufferElement();
    DirectSoundProxy *GetDSproxy() { return _dsProxy; }
    void SetDSproxy(DirectSoundProxy *dsProxy);

  protected:
    DirectSoundProxy *_dsProxy;
};


class DSstreamingBufferElement : public DSbufferElement {
  public:
    DSstreamingBufferElement(DSstreamingBuffer *dsBuffer,
                             DirectSoundProxy *dsProxy = NULL)
    : DSbufferElement(dsProxy), _dsBuffer(dsBuffer),
      _rate(1.0), _doSeek(false), _loop(false) {}
    
    
    virtual ~DSstreamingBufferElement();

    // TODO: make this pure virtual
    virtual void RenderSamples() {}
    
    DSstreamingBuffer *GetStreamingBuffer() { return(_dsBuffer); }
    void SetStreamingBuffer(DSstreamingBuffer *sb) { _dsBuffer = sb; }

    void SetParams(double rate, bool doSeek, double seek, bool loop);

    double GetRate() { return _rate; }
    
    bool GetSeek(double& seek) {
        seek = _seek;
        return _doSeek;
    }
    
    bool GetLooping() { return _loop; }

  protected:
    DSstreamingBuffer *_dsBuffer;   // ptr to DSbuffer object
    double _rate, _seek;
    bool _doSeek;
    bool _loop;
};

class SynthBufferElement : public DSstreamingBufferElement {
  public:
    SynthBufferElement(DSstreamingBuffer *sbuffer,
                       DirectSoundProxy *dsProxy,
                       double sf, double offset, int sampleRate);

    // NOTE: in stream.cpp
    // TODO: why need a bufferElement, buffer maybe good enough
    virtual void RenderSamples();

  private:
    double _delta;            // the increment to next value to synth
    double _value;            // the next value to take sine of

    double _sinFrequency;     // freq of desired sin wave to synth
    int    _outputFrequency;  // primary buffer output frequency
};

class StreamQuartzPCM;

class QuartzBufferElement : public DSstreamingBufferElement {
  public:
    QuartzBufferElement(StreamQuartzPCM *snd,
                        QuartzAudioReader *qAudioReader, 
                        DSstreamingBuffer *sbuffer,
                        DirectSoundProxy *dsProxy = NULL)
    : DSstreamingBufferElement(sbuffer, dsProxy),
      _quartzAudioReader(qAudioReader), _snd(snd) {}
    virtual ~QuartzBufferElement();
    QuartzAudioReader *GetQuartzAudioReader() { return(_quartzAudioReader); }

    // XXX are these two still needed now that Fallback is a method?
    void FreeAudioReader();
    void SetAudioReader(QuartzAudioReader *quartzAudioReader);
    QuartzAudioReader *FallbackAudio();

    void RenderSamples();

  private:
    QuartzAudioReader *_quartzAudioReader;
    StreamQuartzPCM   *_snd;
};


class QuartzVideoBufferElement : public BufferElement {
  public:
    QuartzVideoBufferElement(QuartzVideoReader *qVideoReader)
    : _quartzVideoReader(qVideoReader), _started(false) {}
    virtual ~QuartzVideoBufferElement();
    QuartzVideoReader *GetQuartzVideoReader() { return(_quartzVideoReader); }

    // XXX are these two still needed now that Fallback is a method?
    void FreeVideoReader();
    //void SetVideoReader(QuartzVideoReader *quartzVideoReader);
    QuartzVideoReader *FallbackVideo(bool seekable, DDSurface *surf);

    void FirstTimeSeek(double time);

  private:
    QuartzVideoReader *_quartzVideoReader;
    bool _started;
};

/* this is intended to be kept in the view for buffers/devices instantiated
   before the devices officialy exist!  (initialy this is used for amstreaming)
*/
class SoundBufferCache {
  public:
    SoundBufferCache() {}
    virtual ~SoundBufferCache();
    void AddBuffer(AxAValueObj *value, BufferElement *element);
    void FlushCache(bool grab=true);       // remove all buffers from cache
    void RemoveBuffer(AxAValueObj *value); // remove buffer
    void DeleteBuffer(AxAValueObj *value); // remove buffer + delete contents
    BufferElement *GetBuffer(AxAValueObj *value); // return buffer else NULL
    void ReapElderly();                    // age buffers removing the oldest 
#if _DEBUG
    void PrintCache();
#endif

  private:
    SoundList _sounds;
    CritSect  _soundListMutex;
};

#endif _BUFFERL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\colori.h ===
#ifndef _AP_COLORI_H
#define _AP_COLORI_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Private implementation class for Color.

*******************************************************************************/

#include "d3dtypes.h"
#include "appelles/color.h"

class Color : public AxAValueObj
{
  public:

    // Construct a new color given the RGB values.

    Color (Real r, Real g, Real b) : red(r), green(g), blue(b) {}
    Color (void)                   : red(0), green(0), blue(0) {}

    Color (D3DCOLOR d3dcolor)
    :   red   (RGBA_GETRED  (d3dcolor) / 255.0),
        green (RGBA_GETGREEN(d3dcolor) / 255.0),
        blue  (RGBA_GETBLUE (d3dcolor) / 255.0)
    {}

    // Set the color to the given RGB values.

    void SetRGB (Real r, Real g, Real b);

    // Set the color according to the D3D color.

    void SetD3D (D3DCOLOR);

    // Add the color RGB values to this color. 

    void AddColor (Color&);

    // Return the NTSC intensity of a color.

    Real Intensity (void);

    // Compare with another color type.

    bool operator== (const Color &other) const;
    inline bool operator!= (const Color &other) const
        { return !(*this == other) ; }

    // Data Values

    Real red;
    Real green;
    Real blue;

    virtual DXMTypeInfo GetTypeInfo() { return ColorType; }
};


#if _USE_PRINT
extern ostream& operator<< (ostream& os,  Color &color);
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\bbox2i.h ===
#ifndef _BBOX2I_H
#define _BBOX2I_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    2D bounding Box abstract class

*******************************************************************************/

#include "privinc/vec2i.h"
#include "appelles/bbox2.h"


#undef min
#undef max

class Bbox2 {

  public:

    Point2 min;
    Point2 max;

    Bbox2(void)
    {
        min.Set(HUGE_VAL, HUGE_VAL);
        max.Set(-HUGE_VAL, -HUGE_VAL);
    }

    Bbox2(const Real xmin, const Real ymin, const Real xmax, const Real ymax)
    {
        min.Set(xmin, ymin);
        max.Set(xmax, ymax);
    }

    Bbox2(const Point2 &pmin, const Point2 &pmax) :
        min(pmin), max(pmax) {}

    inline void Set(const Real xmin, const Real ymin, const Real xmax, const Real ymax)
    {
        min.Set(xmin, ymin);
        max.Set(xmax, ymax);
    }

    inline void Augment(const Real x, const Real y)
    {
        if (min.x > x) min.x = x;
        if (min.y > y) min.y = y;
        if (max.x < x) max.x = x;
        if (max.y < y) max.y = y;
    }

    inline void Augment(const Point2 &p)
    {
        if (min.x > p.x)  min.x = p.x;
        if (min.y > p.y)  min.y = p.y;
        if (max.x < p.x)  max.x = p.x;
        if (max.y < p.y)  max.y = p.y;
    }

    inline const bool Contains(const Real x, const Real y) const
    {
        return (min.x <= x) && (min.y <= y)
            && (max.x >= x) && (max.y >= y);
    }

    inline const bool Contains(const Point2 &p) const
    {
        return (min.x <= p.x) && (min.y <= p.y)
            && (max.x >= p.x) && (max.y >= p.y);
    }

    // In the general case box1 contains box2 if its mins are less than box2 mins,
    // and its maxs are greater than box2 maxes.  Note that the universe contains
    // all bounding boxes (including the null box), all bounding boxes contain the
    // null box, and the null box contains only the null box.
    inline const bool Contains(const Bbox2 &box) const
    {
        return (min.x <= box.min.x) && (min.y <= box.min.y)
            && (max.x >= box.max.x) && (max.y >= box.max.y);
    }

    inline const bool IsValid() const
    {
        return (min.x <= max.x) &&
               (min.y <= max.y);    
    }

    inline const bool operator==(const Bbox2 &other) const
    {
        return ((min == other.min) && (max == other.max));
    }

    inline const bool operator!=(const Bbox2 &other) const
    { 
        return !((min == other.min) && (max == other.max)); 
    }

    inline const Real Width (void)  const 
    { 
        return max.x - min.x; 
    }

    inline const Real Height (void) const 
    { 
        return max.y - min.y; 
    }

    inline const Real Area (void) const
    {
        double r;

        // make sure the box isn't the null bounding box
        if (IsValid()) { 
            r = Width() * Height(); 
        } else { 
            r = 0.0; 
        }

        return r;
    }

    // This function returns the point at the center of the bounding box.  The origin
    // is the center of the universe.  I don't think it makes sense, but as far as
    // this function is implemented, the origin is also the center of null.
    const Point2 Center(void) const;

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "Bbox2(" << min << "," << max << ")";
    }
#endif

};

#if _USE_PRINT
inline ostream& operator<< (ostream& os, const Bbox2& B)
{   
    return os << "<" << B.min << ", " << B.max << ">";
}
#endif



// Bounding Box Tests
const Bbox2 IntersectBbox2Bbox2(const Bbox2 &b1, const Bbox2 &b2);
const Bbox2 UnionBbox2Bbox2(const Bbox2 &b1, const Bbox2 &b2);

// Return the screen-aligned bbox surrounding the transformed bbox.
const Bbox2 TransformBbox2(Transform2 *xform, const Bbox2 &box);

// constants
const Bbox2 UniverseBbox2(-HUGE_VAL, -HUGE_VAL, HUGE_VAL,  HUGE_VAL);
const Bbox2 NullBbox2( HUGE_VAL,  HUGE_VAL, -HUGE_VAL, -HUGE_VAL);
const Bbox2 UnitBbox2(0,0, 1,1);


class Bbox2Value : public AxAValueObj {

  public:

    Point2 min;
    Point2 max;

    Bbox2Value(void)
    {   
        min.Set ( HUGE_VAL,  HUGE_VAL);
        max.Set (-HUGE_VAL, -HUGE_VAL);
    }

    Bbox2Value(const Real xmin, const Real ymin,
               const Real xmax, const Real ymax)
    {   
        min.Set (xmin,  ymin);
        max.Set (xmax, ymax);
    }

    // Augment the box to include the given point.
    inline void Augment (const Point2 &p)
    {
        if (min.x > p.x)  min.x = p.x;
        if (min.y > p.y)  min.y = p.y;
        if (max.x < p.x)  max.x = p.x;
        if (max.y < p.y)  max.y = p.y;
    }

    inline const bool operator==(const Bbox2Value &other) const
    {
        return ((min == other.min) && (max == other.max));
    }

    inline const bool IsValid (void) const
    {
        return (min.x <= max.x) &&
               (min.y <= max.y);    
    }

    inline const Real Width (void)  const 
    { 
        return max.x - min.x; 
    }

    inline const Real Height (void) const 
    { 
        return max.y - min.y; 
    }

    inline const Real Area (void) const
    {   
        double r;

        // make sure the box isn't the null bounding box
        if (IsValid()) { 
            r = Width() * Height(); 
        } else { 
            r = 0.0; 
        }

        return r;
    }

    virtual DXMTypeInfo GetTypeInfo() { return Bbox2ValueType; }

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "Bbox2Value(" << min << "," << max << ")";
    }
#endif

};

Bbox2Value* IntersectBbox2Bbox2(Bbox2Value *b1, Bbox2Value *b2);
Bbox2Value* TransformBbox2(Transform2 *xform, Bbox2Value *box);

inline const Bbox2 Demote(const Bbox2Value &b)
{
    return Bbox2(b.min, b.max);
}

inline Bbox2Value* Promote(const Bbox2 &b)
{
    return NEW Bbox2Value(b.min.x, b.min.y, b.max.x, b.max.y);
}



#if BOUNDINGBOX_TIGHTER
/*******************************************************************************

Bbox2Ctx is used to calculate a tighter bounding box.

There are still cases where the tighter bounding box isn't the tightest
axis aligned bounding box.  These are:
1) TextImage - We should get the points of the text outline, transform them,
               then calculate the bounding box.  One optimization is to only
               transform the points that lie on the convex hull of the
               text image.
2) TextMatte - same as above.
3) TextPath2 - same as above.
4) CroppedImage - If we're cropping a PathBasedMatte, this may involve
                  calculating the intersection of the line segments in the
                  path with the cropping box.  Or we'll have to render
                  the image to find the tightest box.
5) LineImage - Wide lines with flat end cap or shear/rotate transforms.
               We currently add half line width to min and max of the box
               for non-detailed lines.  The tighter
6) PolyBezierPath2 - The bounding box of the bezier control points isn't
                     very tight.
7) SubtractedMatte - We don't take into account the subtraction when we
                     calculate the box.
8) Transparent gif???

*******************************************************************************/
class Bbox2Ctx {
  public:
    Bbox2Ctx(void)                  { _xf = identityTransform2; }
    Bbox2Ctx(Bbox2Ctx &bbctx, Transform2 *xf)
    {
        _xf = TimesTransform2Transform2(bbctx._xf, xf);
    }
    Transform2 *GetTransform()      { return _xf; }

  private:
    Transform2  *_xf;
};
#endif // BOUNDINGBOX_TIGHTER

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\cloud.h ===
#ifndef _CLOUD_H
#define _CLOUD_H


/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    Implements Cloud class which maintains a set of n
    points that tightly bound something.
    The whole class is implemented here for now.

-------------------------------------*/

#include "privinc/vec3i.h"
#include "privinc/storeobj.h"

#define MAX_PTS  8

///////////////////////////////////////////////////
//          C L O U D   C L A S S
///////////////////////////////////////////////////

class Cloud : public AxAValueObj
{
  public:
    Cloud();
    ~Cloud() {}

    // These return the min/max axis aligned point
    // from from the extent of the bounding cloud.
    Point3Value FindMinPointCoord();
    Point3Value FindMaxPointCoord();

    // Transforms the cloud using 'xform'
    void Transform(Transform3 *xform);
    
    // Combines this cloud with the given cloud to 
    // form one cloud the "tightly" fits both.
    // Currently this is an axis aligned 'cloud'
    void Augment(Cloud &cloud);

    // Fills the point array with all combinations of
    // the coordinates of the given points.
    // Right now, this forms an axis aligned cube from
    // the in-most pt (min) and the outermost (max)
    // NOTE: this implies 8 points in the cloud and hence
    //       will need to be changed for any bigger clouds.
    void EnumerateThesePlease(Point3Value &min, Point3Value &max);

    // TODO: Not a type in avrtypes.h??
    virtual DXMTypeInfo GetTypeInfo() { return AxATrivialType; }

  private:

    // Same as above, but will clear current points
    void ForceEnumerateThesePlease(Point3Value &min, Point3Value &max);

    // Same as above, but with min/max exploded
    void EnumerateThesePlease(Real minx, Real miny, Real minz,
                              Real maxx, Real maxy, Real maxz);

    // Adds a point to the cloud
    void AddPoint(Point3Value &p);

    // Copies itself into a target cloud
    void CopyInto(Cloud *target);

    // These reset max/min to be -INF/INF
    void ResetMax();
    void ResetMin();

    // Returns max allowed in cloud: currently 8
    int GetMaxPts() {return MAX_PTS;}
    
    // Used to determine the state of the cloud
    Bool _nullCloud;

    // for future optimizations
    Bool _minCurrent;
    Bool _maxCurrent;

    // point count
    int _numPts;

    // Array of points that define the cloud
    Point3Value _pointArray[MAX_PTS];

    // these are used to cache the min/max points
    Point3Value _minPt,
           _maxPt;
};

#undef MAX_PTS

#endif /* _CLOUD_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\curves.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

General curves and surfaces utilities.
*******************************************************************************/

#ifndef _DA_CURVES_H
#define _DA_CURVES_H

#include "privinc/util.h"



/*****************************************************************************
This function evaluates a Bezier curve of arbitrary degree of a list of
generic elements.  Typically the parameter t should lie in the range [0,1].
Each element type must have the functions ElementAdd() and ElementScale()
defined for them (see above).
*****************************************************************************/

template <class Element>
Element EvaluateBezier (
    int      degree,    // Degree of Curve
    Element *e,         // Array of degree+1 Elements
    Real     t)         // Real-Valued Evaluator
{
    int  c    = 1;      // Combinations, or Degree-Choose-i
    Real s    = 1 - t;
    Real tpow = t;      // Powers Of t

    Element result = s * e[0];

    for (int i=1;  i < degree;  ++i)
    {
        c *= degree + 1 - i;    // NOTE: The order of these two statements
        c /= i;                 //       is important!

        // Equivalent of: result = s * (result + (tpow * c * e[i]));

        result = s * (result + ((tpow * c) * e[i]));

        tpow *= t;
    }

    return (result + (tpow * e[degree]));
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\comutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _COMUTIL_H
#define _COMUTIL_H

#include "debug.h"
#include "mutex.h"

template <class T>
class DAComPtr
{
  public:
    typedef T _PtrClass;
    DAComPtr() { p = NULL; }
    DAComPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            p->AddRef();
    }
    DAComPtr(const DAComPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            p->AddRef();
    }
    ~DAComPtr() {
        if (p) p->Release();
    }
    void Release() {
        if (p) p->Release();
        p = NULL;
    }
    operator T*() { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the p member explicitly.
    T** operator&() { Assert(p == NULL); return &p; }
    T* operator->() { Assert(p != NULL); return p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const DAComPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            lp->AddRef();

        if (p)
            p->Release();

        p = lp;

        return lp;
    }
};

template <class T, const IID * iid>
class DAAptComPtr
{
  public:
    DAAptComPtr() : _pbase(NULL) {}
    DAAptComPtr(T* lp, bool baddref = true)
    : _pbase(NULL)
    {
        Assign(lp, baddref);
    }
    DAAptComPtr(const DAAptComPtr<T,iid>& lp)
    : _pbase(NULL)
    {
        Copy(lp);
    }
    
    ~DAAptComPtr() {
        Release();
    }

    void Release() { RELEASE(_pbase); }
    
    operator T*()
    { return GetPtr(); }

    T& operator*()
    { Assert(_pbase != NULL); return *GetPtr(); }

    T* operator->()
    { Assert(_pbase != NULL); return GetPtr(); }

    T* operator=(T* lp)
    { Assign(lp); return GetPtr(); }

    DAAptComPtr<T,iid> & operator=(const DAAptComPtr<T,iid>& lp)
    { Copy(lp); return *this; }

    bool operator!() const
    { return (_pbase == NULL); }

    operator bool() const
    { return (_pbase != NULL); }

  protected:
    class DAAptComPtrBase
    {
      public:
        DAAptComPtrBase(T* p, bool bAddRef)
        : _cref(1), _stream(NULL) {
            Assert (p);
            
            THR(CoMarshalInterThreadInterfaceInStream(*iid,
                                                      p,
                                                      &_stream));

            // Ignore failure since we may never need the stream
            // Report the error when we need the stream
            
            if (bAddRef) {
                // dont add to map if we do not addref...
                _imap[GetCurrentThreadId()] = p;
                p->AddRef();
            }

        }
        
        ~DAAptComPtrBase() {
            T* p = GetPtr(false);
            int n = _imap.size();
            
            if (p) {
                while (n--) p->Release();
            }

            if (_stream) _stream->Release();
            _stream = NULL;
        }
        
        long AddRef() {
            return InterlockedIncrement(&_cref);
        }
        long Release() {
            long l = InterlockedDecrement(&_cref);
            if (l == 0) delete this;
            return l;
        }

        T* GetPtr(bool bReMarshal = true) {
            CritSectGrabber csg(_cs);

            // See if we can find an interface for the current thread
            InterfaceMap::iterator i = _imap.find(GetCurrentThreadId());

            T* p = NULL;
            
            if (i != _imap.end()) {
                p = (*i).second;
            }
            else {

                // if we have no ref count, don't marshal the interface, just return null
                if(_cref) {

                    // If we do not have a stream we cannot do anything
                    // TODO: Need a better error message here
                    if (_stream != NULL) {
            
                        HRESULT hr = THR(CoGetInterfaceAndReleaseStream(_stream,
                                                                        *iid,
                                                                        (void**) &p));
            
                        // Mark the stream as invalid
                        _stream = NULL;
            
                        if (SUCCEEDED(hr)) {
        
                            // Store the new interface point to ensure it will get
                            // released
            
                            _imap[GetCurrentThreadId()] = p;

                            // If we need to remarshal use the pointer we just got
            
                            if (bReMarshal) {
                                THR(CoMarshalInterThreadInterfaceInStream(*iid,
                                                                          p,
                                                                          &_stream));
                            // Ignore failure until the next time since we may not
                            // need the stream again
                            }
                        }
                    }
                }
            }
           
            return p;
        }
        
      protected:
        long _cref;
        IStream * _stream;
        typedef map< DWORD, T * , less<DWORD> > InterfaceMap;
        InterfaceMap _imap;
        CritSect _cs;
    };

    DAAptComPtrBase * _pbase;

    void Assign(T* lp, bool baddref = true) {
        Release();
        if (lp) {
            _pbase = new DAAptComPtrBase(lp, baddref);
        }
    }

    void Copy(const DAAptComPtr<T,iid>& lp) {
        Release();
        _pbase = lp._pbase;
        if (_pbase) _pbase->AddRef();
    }

    T* GetPtr() {
        T* p = NULL;
        if (_pbase != NULL) {
        
            p = _pbase->GetPtr();
        }

        return p;
    }
};

#define DAAPTCOMPTR(i) DAAptComPtr<i,&IID_##i>

template <class T, const IID * iid>
class DAAptComPtrMT : public DAAptComPtr<T,iid>
{
  public:
    DAAptComPtrMT(const DAAptComPtrMT<T,iid>& lp)
    {
        Copy(lp);
    }
    
    void Release() {
        CritSectGrabber csg(_cs);
        RELEASE(_pbase);
    }
    
    operator T*() {
        CritSectGrabber csg(_cs);
        return GetPtr();
    }

    T& operator*() {
        CritSectGrabber csg(_cs);
        Assert(_pbase != NULL);
        return *GetPtr();
    }

    T* operator->() {
        CritSectGrabber csg(_cs);
        Assert(_pbase != NULL);
        return GetPtr();
    }

    T* operator=(T* lp) {
        CritSectGrabber csg(_cs);
        Assign(lp);
        return GetPtr();
    }

    DAAptComPtrMT<T,iid> & operator=(const DAAptComPtr<T,iid>& lp) {
        CritSectGrabber csg(_cs);
        Copy(lp);
        return *this;
    }

    DAAptComPtrMT<T,iid> & operator=(const DAAptComPtrMT<T,iid>& lp) {
        Copy(lp);
        return *this;
    }

    bool operator!() const {
        CritSectGrabber csg(_cs);
        return (_pbase == NULL);
    }

    operator bool() const {
        CritSectGrabber csg(_cs);
        return (_pbase != NULL);
    }
  protected:
    CritSect _cs;

    void Copy(const DAAptComPtrMT<T,iid>& lp) {
        Release();

        DAAptComPtrBase * p;
        
        // Never have both locks at the same time otherwise we can get
        // deadlock
        
        {
            CritSectGrabber csg(lp._cs);
            p = lp._pbase;
            if (p) p->AddRef();
        }
            
        CritSectGrabber csg(_cs);
        
        _pbase = p;
    }

};

#define DAAPTCOMPTRMT(i) DAAptComPtrMT<i,&IID_##i>


////// VARIANT related utilities

// Defined in utils/privpref.cpp
HRESULT GetVariantBool(VARIANT& v, Bool *b);
HRESULT GetVariantInt(VARIANT& v, int *i);
HRESULT GetVariantDouble(VARIANT& v, double *dbl);

// Macros that aid in implementing preferences methods
#define EXTRACT_BOOL(v, pb) \
   hr = THR(GetVariantBool(v, pb)); \
   if (FAILED(hr)) { \
       return hr;    \
   }

#define EXTRACT_INT(v, pi) \
   hr = THR(GetVariantInt(v, pi)); \
   if (FAILED(hr)) { \
       return hr;    \
   }

#define EXTRACT_DOUBLE(v, pDbl) \
   hr = THR(GetVariantDouble(v, pDbl)); \
   if (FAILED(hr)) { \
       return hr;    \
   }

#define INJECT_BOOL(b, pV) \
   V_VT(pV) = VT_BOOL; \
   V_BOOL(pV) = b ? 0xFFFF : 0x0000;

#define INJECT_INT(i, pV) \
   V_VT(pV) = VT_I4; \
   V_I4(pV) = i;

#define INJECT_DOUBLE(dbl, pV) \
   V_VT(pV) = VT_R8; \
   V_R8(pV) = dbl;

#define INT_ENTRY(fixedPrefName, varName) \
    if (0 == lstrcmp(prefName, fixedPrefName)) { \
        if (puttingPref) { \
            EXTRACT_INT(*pV, &i); \
            varName = i; \
        } else { \
            INJECT_INT(varName, pV); \
        } \
        return S_OK; \
    } \

#define DOUBLE_ENTRY(fixedPrefName, varName) \
    if (0 == lstrcmp(prefName, fixedPrefName)) { \
        if (puttingPref) { \
            EXTRACT_DOUBLE(*pV, &dbl); \
            varName = dbl; \
        } else { \
            INJECT_DOUBLE(varName, pV); \
        } \
        return S_OK; \
    } \
    
#define BOOL_ENTRY(fixedPrefName, varName) \
    if (0 == lstrcmp(prefName, fixedPrefName)) { \
        if (puttingPref) { \
            EXTRACT_BOOL(*pV, &b); \
            varName = b; \
        } else { \
            INJECT_BOOL(varName, pV); \
        } \
        return S_OK; \
    } \


#define SAFERELEASE(p) (IsBadReadPtr((p), sizeof(p))?0:(p)->Release())

#endif /* _COMUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\cropdimg.h ===
#ifndef _CROPDIMG_H
#define _CROPDIMG_H


/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    Cropped Image class header

-------------------------------------*/

#include "privinc/imagei.h"
#include "privinc/bbox2i.h"

class CroppedImage : public AttributedImage {
  public:

    CroppedImage(const Bbox2 &box, Image *img) :
          _croppingBox(box), AttributedImage(img) {}

    void Render(GenericDevice& dev);

    inline const Bbox2 BoundingBox(void) 
    { 
        return IntersectBbox2Bbox2(_croppingBox, _image->BoundingBox()); 
    }

    Real DisjointBBoxAreas(DisjointCalcParam &param);
    
    void _CollectDirtyRects(DirtyRectCtx &ctx);
    
#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        //!!!BBOX: This still may not be the tightest box of the image.

        Bbox2Ctx bbctxIdentity;
        Bbox2 bbox = IntersectBbox2Bbox2(_croppingBox, _image->BoundingBoxTighter(bbctxIdentity));

        Transform2 *xf = bbctx.GetTransform();
        return TransformBbox2(xf, bbox);
    }
#endif  // BOUNDINGBOX_TIGHTER

#if _USE_PRINT
    // Print a representation to a stream.
    ostream& Print(ostream& os) {
        return os << "CroppedImage" << "<bounding box>" << _image;
    }

#endif
    const Bbox2 OperateOn(const Bbox2 &box) {
        return IntersectBbox2Bbox2(_croppingBox, box);
    }

    Bool  DetectHit(PointIntersectCtx& ctx);

    const Bbox2& GetBox(void) { return _croppingBox; }

    virtual VALTYPEID GetValTypeId() { return CROPPEDIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == CroppedImage::GetValTypeId() ||
                AttributedImage::CheckImageTypeId(type));
    }

    virtual void DoKids(GCFuncObj proc) { 
        AttributedImage::DoKids(proc);
    }
  protected:
    Bbox2 _croppingBox;
};


#endif /* _CROPDIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\d3dutil.h ===
#pragma once
#ifndef _D3DUTIL_H
#define _D3DUTIL_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Direct3D Utility Functions
*******************************************************************************/

#include "d3d.h"
#include "d3drm.h"
#include "privinc/hresinfo.h"
#include "privinc/debug.h"
#include "privinc/importgeo.h"


    // Referenced Structures

class Vector3Value;
class Point3Value;
class Ray3;
class Transform3;
class Color;


    // Wrappers for calls to D3D.  These macros provide for call tracing,
    // result checking, and call timing.

#if _DEBUG

    // This function prints out a trace of all calls to D3D.

    inline void TraceD3DCall (char *string)
    {
        TraceTag ((tagD3DCallTrace, string));
    }

    // The TD3D macro provides for debug tracing of calls to D3D, times
    // the call, and throws an exception if the result indicates failure.

    #define TD3D(x)\
        do{ \
            TraceD3DCall ("D3D: " #x); \
            TIME_D3D (CheckReturnCode((x),__FILE__,__LINE__,true)); \
        }while(0)

    // The AD3D call operates equivalently to the TD3D macro, but just reports
    // an assertion failure rather than throwing an exception.

    #define AD3D(x) \
    (   (TraceD3DCall ("D3D: " #x)), \
        CheckReturnCode(TIME_D3D(x),__FILE__,__LINE__) \
    )

    // The RD3D call just passes on the result without checking for failure.
    // This is used when failure is reasonable under normal conditions.

    #define RD3D(x)  ((TraceD3DCall("D3D: " #x)), TIME_D3D(x))

#else
    #define TD3D(statement) CheckReturnCode(TIME_D3D(statement),true)
    #define AD3D(statement) CheckReturnCode(TIME_D3D(statement))
    #define RD3D(statement) TIME_D3D(statement)
#endif


    // These functions fetch handles to shared global D3D objects.

IDirect3DRM*  GetD3DRM1 (void);
IDirect3DRM3* GetD3DRM3 (void);

    // Conversion Between D3D Objects and DA Objects

void        LoadD3DMatrix (D3DRMMATRIX4D &d3dmat, Transform3 *xf);
Transform3 *GetTransform3 (D3DRMMATRIX4D &d3dmat);

void LoadD3DVec (D3DVECTOR &d3dvec, Vector3Value &V);
void LoadD3DVec (D3DVECTOR &d3dvec, Point3Value &P);
void LoadD3DRMRay (D3DRMRAY &d3dray, Ray3 &ray);

    // Get a Direct3D Color Value from Color*

D3DCOLOR GetD3DColor (Color *color, Real alpha);

    // The following structures are used to hold the information about the
    // chosen 3D software and hardware rendering devices.

struct D3DDeviceInfo
{   D3DDEVICEDESC desc;    // D3D Device Description
    GUID          guid;    // Associated GUID
};

struct ChosenD3DDevices
{   D3DDeviceInfo software;
    D3DDeviceInfo hardware;
};

    // Choose the preferred D3D rendering devices.

ChosenD3DDevices *SelectD3DDevices (IDirectDraw *ddraw);

    // This structure is filled in by the UpdateUserPreferences function,
    // and contains the 3D preference settings fetched from the registry.

enum MMX_Use_Flags {
    MMX_Standard   = (1<<0),   // Standard (Reported) MMX Rasterizer
    MMX_Special    = (1<<1),   // Special DX6 MMX Rasterizer for Chrome
    MMX_SpecialAll = (1<<2)    // MMX Special; All Bit Depths
};

struct Prefs3D
{   D3DCOLORMODEL       lightColorMode;   // [Lighting] Mono / RGB
    D3DRMFILLMODE       fillMode;         // Solid / Wireframe / Points
    D3DRMSHADEMODE      shadeMode;        // Flat / Gouraud / Phong
    D3DRMRENDERQUALITY  qualityFlags;     // D3D RM Render Quality Flags
    D3DRMTEXTUREQUALITY texturingQuality; // D3D RM texture quality
    unsigned int        useMMX;           // Use MMX Software Rendering
    bool                dithering;        // Use Dithering
    bool                texmapping;       // Do Texture Mapping
    bool                texmapPerspect;   // Do Perspective-Correct Texmapping
    bool                useHW;            // Use 3D Hardware
    bool                worldLighting;    // World-Coordinate Lighting
};

    // Shared Globals

extern HINSTANCE  hInstD3D;     // D3D Instance
extern Prefs3D    g_prefs3D;    // 3D Preferences
extern bool       ntsp3;        // Running NT Service Pack 3


    // class that manages D3DRM texture wrap objects

class RMTextureWrap {

public:
    RMTextureWrap(void);
    RMTextureWrap(TextureWrapInfo *info,Bbox3 *bbox = NULL);
    ~RMTextureWrap(void);
    void Init(TextureWrapInfo *info,Bbox3 *bbox = NULL);
    HRESULT Apply(IDirect3DRMVisual *vis);
    HRESULT ApplyToFrame(IDirect3DRMFrame3 *pFrame);
    bool WrapU(void);
    bool WrapV(void);

private:
    IDirect3DRMWrap *_wrapObj;
    bool             _wrapU;
    bool             _wrapV;
};

HRESULT SetRMFrame3TextureTopology (IDirect3DRMFrame3*, bool wrapU, bool wrapV);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\dagdi.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#ifndef _DAGDI_H
#define _DAGDI_H


#include "privinc/server.h"  // GetCurrentTimers
#include "privinc/util.h"
#include "privinc/comutil.h"
#include "privinc/ddsurf.h"
#include "privinc/xform2i.h"
#include "privinc/gradImg.h"
#include <dxtrans.h>


// forward decl
class TargetDescriptor;
class CDX2DXForm;


class DAFont {

  public:

    DAFont(HFONT gdiFont) :
     _gdiFont(gdiFont)
    {}

    inline HFONT    GetHFONT() { return _gdiFont; }
    
  private:
    HFONT    _gdiFont;
};    

class DAColor
{
  public:

    DAColor( DAColor &c ) {
        _dxSample = c._dxSample;
        _colorRef = c._colorRef;
    }
    
    DAColor( Color *c, Real opacity, TargetDescriptor &td);

    DXSAMPLE GetDXSAMPLE() { return _dxSample; }
    COLORREF GetCOLORREF() { return _colorRef; }

  private:
    DXSAMPLE _dxSample;
    COLORREF _colorRef;
};


class Pen {
  public:

    Pen(DAColor &dac) :
       _daColor(dac),
       _style(PS_COSMETIC)
    {
        SetWidth( 1.0 );
        SetMiterLimit( -1 );
    }

    Pen(DWORD dwPenStyle, float fWidth,  DAColor &dac) :
        _daColor(dac),
        _style(dwPenStyle)
    {
        SetWidth( fWidth );
        if( IsCosmeticPen() ) {
            SetWidth( 1.0 );
        }
        SetMiterLimit( -1 );
    }
    
    inline BOOL IsGeometricPen() { return GetStyle() & PS_GEOMETRIC; }
    inline BOOL IsCosmeticPen() { return !IsGeometricPen(); }

    inline void SetColor(DAColor &dac) {  _daColor = dac;  }
    inline void AddStyle(DWORD s) { _style |= s; }
    inline void SetStyle(DWORD s) { _style = s; }
    inline void SetWidth(float fw) { _fWidth = fw; }
    inline void SetMiterLimit(float l) { _miterLimit = l; }

    inline DXSAMPLE GetDxColor() { return _daColor.GetDXSAMPLE(); }
    inline COLORREF GetColorRef() { return _daColor.GetCOLORREF(); }
    inline DWORD    GetStyle() { return _style; }
    inline DWORD    GetWidth() { return (DWORD)_fWidth; }
    inline float    GetfWidth() { return _fWidth; }
    inline float    GetMiterLimit() { return _miterLimit; }

    inline bool     DoMiterLimit() { return _miterLimit > 0; }

    /*
      // plug in if it buys us something. see comments in dagdi.cpp
    bool IsSamePen( const DXPEN &pen ) {
        return
            (pen.Color == GetDxColor()) &&
            (pen.Width == GetfWidth())  &&
            (pen.Style == GetStyle());
    }
    */
    
  private:
    DAColor  _daColor;
    float    _fWidth;
    DWORD    _style;
    float    _miterLimit;
};


class Region {
  public:

    enum regionType_enum {
        rect,
        gdi,
        polygon
    };

    Region(regionType_enum r) :
        _regionType(r)
    {}

    inline regionType_enum GetType() { return _regionType; }

  private:
    regionType_enum _regionType;    
};

class RectRegion : public Region {
  public:

    RectRegion(RECT *r) :
       Region(Region::rect),
       _isSet(false)
    {
        if(r) {
            SetRect(r);
        }
    }
        

    void  Intersect(RECT *rect)
    {
        Assert(rect);
        if(_isSet) {
            IntersectRect(&_rect, &_rect, rect);
        } else {
            SetRect(rect);          
        }
    }

    void  SetRect(RECT *rect)
    {
        Assert(rect);
        _isSet = true;
        _rect = *rect;
    }
    
    RECT *GetRectPtr() {
        if(_isSet) {
            return &_rect;
        } else {
            return NULL;
        }
    }
    
  private:
    RECT _rect;
    bool _isSet;
};

class GdiRegion : public Region {
  public:

    GdiRegion(HRGN rgn) :
       Region(Region::gdi),
       _rgn(rgn)
    {
        _myRegion = false;
    }

    ~GdiRegion() {
        if(_myRegion) {
            TIME_GDI(::DeleteObject(HGDIOBJ(_rgn)));
        }
    }
            
    void  Intersect(RECT *rect)
    {
        Assert(rect);
        HRGN rgn;
        TIME_GDI(rgn = ::CreateRectRgnIndirect( rect ));
        if(!_rgn) {
            _rgn = rgn;
            _myRegion = true;
        } else {
            TIME_GDI(::CombineRgn(_rgn, _rgn, rgn, RGN_AND) );
            TIME_GDI(::DeleteObject(HGDIOBJ(rgn)));
        }
    }

    HRGN GetHRGN() { return _rgn; }
    
  private:
    HRGN _rgn;
    bool _myRegion;
};

class PolygonRegion : public Region {
  public:

    PolygonRegion() :
        Region(Region::polygon)
    {
    }

    PolygonRegion(POINT *gdiPts, int numPts) : 
        Region(Region::polygon)
    {
        Init(gdiPts, numPts);
    }
    
    void Init(POINT *gdiPts, int numPts)
    {
        _gdiPts = gdiPts;
        _numPts = numPts;
        Assert(_gdiPts);
        Assert(_numPts > 0  && "strange... empy PolygonRegion class");
    }

    void Init(TextPoints *txtPts,
              DWORD vw,
              DWORD vh,
              Real res,
              Transform2 *xf)
    {
        _gdiPts = NULL;
        _txtPts = txtPts;
        _viewportWidth = vw;
        _viewportHeight = vh;
        _resolution = res;
        _xform = xf;
        _numPts = txtPts->_count;

        Assert(_txtPts);
        Assert(_numPts > 0  && "strange... empy PolygonRegion class");
    }

    inline POINT *GetGdiPts() { return _gdiPts; }
    inline int    GetNumPts() { return _numPts; }
    inline TextPoints *GetTextPts() { return _txtPts; }
    inline Transform2 *GetTransform() { return _xform; }
    inline void GetWHRes(DWORD *pVW, DWORD *pVH, Real *pRes) {
        *pVW = _viewportWidth;
        *pVH = _viewportHeight;
        *pRes = _resolution;
    }

  private:
    POINT *_gdiPts;
    int    _numPts;
    DWORD  _viewportWidth;
    DWORD  _viewportHeight;
    Real   _resolution;
    TextPoints *_txtPts;
    Transform2 *_xform;
    
};
        
class Brush {
  public:

    enum brushType_enum {
        invalid,
        solid,
        texture,
        radialGradient,
        linearGradient
    };

    Brush(brushType_enum b):
        _brushType(b)
    {}

    inline brushType_enum GetType() { return _brushType; }

  protected:
    brushType_enum  _brushType;
};

class SolidBrush : public Brush {
  public:

    SolidBrush(DAColor dac) :
        _daColor(dac),
        Brush(Brush::solid)
    {}   

    inline DXSAMPLE GetDxColor() { return _daColor.GetDXSAMPLE(); }
    inline COLORREF GetColorRef() { return _daColor.GetCOLORREF(); }

  private:
    DAColor  _daColor;
};

class TextureBrush : public Brush {
  public:

    TextureBrush(DDSurface &surf, int x, int y) :
        Brush(Brush::texture),
        _surface(surf),
        _offsetX(x),
        _offsetY(y)
    {}   
    
    DDSurface &GetSurface() {return _surface;}
    
    inline int OffsetX() { return _offsetX; }
    inline int OffsetY() { return _offsetY; }
    
  private:
    DDSurface &_surface;
    int _offsetX, _offsetY;
};

class MulticolorGradientBrush : public Brush {
  public:

    MulticolorGradientBrush(
        Real *offsets,
        Real *colors,
        DWORD count,
        Real opacity,
        Transform2 *gradXf,
        MulticolorGradientImage::gradientType type) :
    Brush(Brush::invalid),
    _offsets(offsets),
    _colors(colors),
    _count(count),
    _opacity(opacity),
    _gradXf(gradXf)
    {
        switch( type )
          {
            case MulticolorGradientImage::radial:
              _brushType = radialGradient;
              break;
            case MulticolorGradientImage::linear:
              _brushType = linearGradient;
              break;
            default:
              Assert(!"Error gradient type");
          }
    }
    
    Real *_offsets;
    Real *_colors;
    DWORD _count;
    Real  _opacity;
    Transform2 *_gradXf;
};

class DAGDI {

  public:

     DAGDI(DirectDrawViewport *vp);
    ~DAGDI();

    void SetAntialiasing(bool b) { _antialiased = b; }
    bool DoAntiAliasing() {
        #if _DEBUG
        if( IsTagEnabled( tagAntialiasingOn ) ) {
            return GetDx2d() && true;
        }
        #endif
        return  GetDx2d() && _antialiased; 
    }
    void SetDx2d( IDX2D *dx2d,  IDXSurfaceFactory *sf);
    IDX2D  *GetDx2d() {
        #if _DEBUG
        if( IsTagEnabled( tagAntialiasingOff ) ) {
            return NULL;
        }
        #endif
        return _dx2d;
    }
    
    inline void SetPen(Pen *pen) { Assert(!_pen); _pen = pen; }
    inline void SetFont(DAFont *font) { Assert(!_font); _font = font; }
    inline void SetBrush(Brush *brush) { Assert(!_brush); _brush = brush; }
    inline void SetClipRegion(Region *rgn) { Assert(!_clipRegion); _clipRegion = rgn; }

    inline Pen *GetPen() { return _pen; }
    inline DAFont *GetFont() { return _font; }
    inline Brush *GetBrush() { return _brush; }
    inline Region *GetClipRegion() { return _clipRegion; }

    inline void SetDDSurface(DDSurface *destSurf) {
        _destDDSurf = destSurf;
    }

    inline DDSurface *GetDDSurface() { return _destDDSurf; }
    
    inline Transform2 *GetSuperScaleTransform() {
        // This should probably be cached.
#if DEBUG
        if(IsTagEnabled(tagAAScaleOff)) {
            return identityTransform2;
        }
#endif
        if( GetSuperScaleMode() == true ) {
            return ScaleRR(GetSuperScaleFactor(),GetSuperScaleFactor());
        } else {
            return identityTransform2;
        }
    }

    
    inline void SetSuperScaleFactor(double scale) { _scaleFactor = scale; }
    inline double GetSuperScaleFactor() { return _scaleFactor; }

    inline void SetSuperScaleMode(bool scOn) { _scaleOn = scOn; }
    inline bool GetSuperScaleMode() { return _scaleOn; }

    void SetOffset( POINT &pt );
    bool DoOffset() { return _doOffset; }

    void SetSampleResolution( int sr ) {
        Assert( (sr == 1) ||
                (sr == 2) ||
                (sr == 4) ||
                (sr == 8) ||
                (sr == 16));
        
        _sampleResolution = sr;
    }
    int GetSampleResolution() { return _sampleResolution; }
    
    int GetAdjustedResolution();

    void ClearState();

    // ---------------------------------------------
    // BLITTING FUNCTION
    // ---------------------------------------------
    HRESULT Blt( DDSurface *srcDDSurf, RECT &srcRect, RECT &destRect );

    // ---------------------------------------------
    // FILLING AND DRAWING: PolyDraw... does everything
    // ---------------------------------------------
    void PolyDraw(PolygonRegion *drawRegion, BYTE *codes);
    void PolyDraw_GDIOnly(HDC hdc, POINT *gdiPts, BYTE *codes, ULONG numPts);
    inline void PolyDraw_GDIOnly(HDC hdc, PolygonRegion *drawRegion, BYTE *codes)   {
        PolyDraw_GDIOnly(hdc, drawRegion->GetGdiPts(), codes, drawRegion->GetNumPts());
    }

    // ---------------------------------------------
    // FILLING functions.  Fill region, fill polygon
    // ---------------------------------------------

    // give a dc and an HRGN it... fills it with the selected brush
    void FillRegion(HDC dc, GdiRegion *gdiRegion);

    //
    // Fills a polygon (outlined by 'pts') with the selected brush
    // right now this is strictly a color
    //
    void Polygon(PolygonRegion *polygon);


    // ---------------------------------------------
    //  LINE drawing functions.  beziers, polylines, strokes, etc...
    // ---------------------------------------------

    enum whatStyle_enum {
        doLine,
        doBezier,
        doStroke
    };
    
    inline void Polyline(PolygonRegion *line)
    {
        GenericLine(NULL, line, doLine);
    }
        
    inline void PolyBezier(PolygonRegion *bez)
    {
        GenericLine(NULL, bez, doBezier);
    }

    inline void StrokePath(HDC dc, bool &bReleasedDC)
    {
        _bReleasedDC = false; // reset the flag.
        GenericLine(dc, NULL, doStroke);
        bReleasedDC = _bReleasedDC;
    }

    inline void SetViewportSize(int width,int height)
    {
        _width  = width;
        _height = height;
    }    

    void GenericLine(HDC dc,
                     PolygonRegion *outline,
                     whatStyle_enum whatStyle);
    

    // ---------------------------------------------
    //  TEXT drawing functions
    // ---------------------------------------------
    void TextOut(int x, int y, float xf, float yf, WCHAR *str, ULONG strlen);

    // ---------------------------------------------
    //  AA only: Stroke and/or Fill
    // ---------------------------------------------
    void StrokeOrFillPath_AAOnly( HDC destDC, bool &releasedDC );

  private:

    bool _antialiased;
    bool _bReleasedDC;
    
    // DA Gdi members
    Pen *_pen;
    Brush *_brush;
    DAFont *_font;
    Region *_clipRegion;
    int _width,_height;
    double _scaleFactor;

  private:


    HPEN     _GetEmptyHPEN() {
        if (!_emptyGdiPen) {
            TIME_GDI( _emptyGdiPen = (HPEN)::GetStockObject(NULL_PEN) );
        }       
        return _emptyGdiPen;
    }

    class SelectCtx {
      public:
        inline SelectCtx(Pen     *p,
                         Brush   *b,
                         Region  *c)
        {
            ::ZeroMemory(this, sizeof(class SelectCtx));
            pen = p;
            brush = b;
            clipRegion = c;
            oldMiterLimit = -1;
            oldSampleRes = -1;
        }

        Pen     *pen;
        Brush   *brush;
        Region  *clipRegion;
        
        HGDIOBJ oldPen;
        HBRUSH  oldBrush;
        HRGN    newRgn;
        float   oldMiterLimit;
        
        bool    destroyHPEN;
        bool    destroyHBRUSH;
        bool    destroyHRGN;

        inline void    AccumFlag(DWORD f) { _dwFlags |= f; }
        inline DWORD   GetFlags() { return _dwFlags; }
        DWORD   _dwFlags;

        int     oldSampleRes;
    };
        
    // Sets a transform into dx2d based on the given rects
    void _SetScaleTransformIntoDx2d( RECT &srcRect, RECT &destRect,
                                     POINT *outOffset );
    void _MeterToPixelTransform(Transform2 *xf,
                                DWORD pixelWidth,
                                DWORD pixelHeight,
                                Real  resolution,
                                DX2DXFORM &outXf);

    // CACHED STUFF FOR PERF
    DWORD _pixelWidth;
    DWORD _pixelHeight;
    Real _resolution;
    Transform2 *_n2g;

    // CACHED PEN FOR PERF
    DXPEN _dxpen;    
    
    void SetSurfaceFromDDSurf(DDSurface *ddsurf);
    
    void _SetMulticolorGradientBrush(MulticolorGradientBrush *);

    // for win95 only, identical to NT's polydraw
    void _Win95PolyDraw(HDC dc,
                        POINT *pts,
                        BYTE *types,
                        int count);
    
    void _SelectIntoDC(HDC dc, SelectCtx *ctx);
    void _UnSelectFromDC(HDC dc, SelectCtx *ctx);

    void _SelectIntoDx2d(SelectCtx *ctx);
    void _UnSelectFromDx2d(SelectCtx *ctx);

    bool _Dx2d_GdiToDxf_Select(DXFPOINT **pdxfPts, PolygonRegion *polygon);
    void _Dx2d_GdiToDxf_UnSelect(DXFPOINT *dxfPts);

    void _GenericLine_Gdi(HDC dc,
                          PolygonRegion *outline,
                          whatStyle_enum whatStyle);
    
    void _GenericLine_Dx2d(HDC dc,
                           PolygonRegion *outline,
                           whatStyle_enum whatStyle);

    #if _DEBUG
    bool _debugonly_CanLockSurface( DDSurface *dds );
    #endif
    
    // These guys wrap calls to AAPolyDraw
    HRESULT _Dx2d_StrokeOrFillPath(HDC hDC, DWORD dwFlags);
    HRESULT _Dx2d_PolyLine(DXFPOINT *dxfPts, ULONG numPts, DWORD dwFlags);
    HRESULT _Dx2d_PolyBezier(DXFPOINT *dxfPts, ULONG numPts, DWORD dwFlags);
    HRESULT _Dx2d_FilledPolygon(HDC dc, DXFPOINT *dxfPts, ULONG numPts, DWORD dwFlags);

    void _TextOut_Gdi(HDC hdc, int x, int y, WCHAR *str, ULONG strLen);
    void _TextOut_Dx2d(float x, float y, WCHAR *str, ULONG strLen);

    HDC  _GetDC();
    void _ReleaseDC();
    
    DAComPtr<IDX2D>  _dx2d;
    DAComPtr<IDXSurfaceFactory> _IDXSurfaceFactory;
    
    DDSurface *_GetDDSurface() { return _destDDSurf; }
    DDSurfPtr<DDSurface> _destDDSurf;

    DAComPtr<IDXSurface> _previouslySetDXSurface;
    DAComPtr<IDirectDrawSurface> _previouslySetIDirectDrawSurface;

    HRESULT _hr;
    HPEN    _emptyGdiPen;

    bool    _scaleOn;
    bool    _doOffset;

    POINT   _pixOffset;

    int     _sampleResolution;

    DirectDrawViewport  *_viewport;
};
  

#endif /* _DAGDI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\dastllist.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _DASTLLIST_H
#define _DASTLLIST_H

#include<privinc/DaStlUtility.h>

_DASTL_NAMESPACE_BEGIN
#pragma auto_inline(off)

template<class T>
class list {

  protected:

    struct _Node;
    friend struct _Node;
    struct _Node {
        _Node *_Next;
        _Node *_Prev;
        T      _Value;
    };
    typedef _Node *_Nodeptr;

    struct _Acc;
    friend struct _Acc;
    struct _Acc {
        typedef _Nodeptr & _Nodepref;
        typedef T & _Vref;
        // TODO: inline these guys ???
        static _Nodepref _Next(_Nodeptr _P)  {return ((_Nodepref)(*_P)._Next); }
        static _Nodepref _Prev(_Nodeptr _P)  {return ((_Nodepref)(*_P)._Prev); }
        static _Vref _Value(_Nodeptr _P)     {return ((_Vref)(*_P)._Value); }
    };
  public:
    typedef list<T> _Myt;
    typedef T * Tptr;
    typedef T & Tref;
    typedef int difference_type;
    
    // CLASS iterator
    class iterator;
    friend class iterator;
    class iterator {
      public:

        inline iterator()      {}
        inline iterator(_Nodeptr _P) : _Ptr(_P) {}
        
        inline Tref operator*() const {
            return (_Acc::_Value(_Ptr));
        }

        inline Tptr operator->() const {
            return (&**this);
        }
        
        inline iterator& operator++() {
            _Ptr = _Acc::_Next(_Ptr);
            return (*this);
        }

        // TODO: inline this?
        iterator operator++(int) {
            iterator _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        inline iterator& operator--()  {
            _Ptr = _Acc::_Prev(_Ptr);
            return (*this);
        }

        iterator operator--(int) {
            iterator _Tmp = *this;
            --*this;
            return (_Tmp);
        }

        inline bool operator==(const iterator& _X) const {
            return (_Ptr == _X._Ptr);
        }
        
        inline bool operator!=(const iterator& _X) const {
            return (!(*this == _X));
        }
        
        inline _Nodeptr _Mynode() const {
            return (_Ptr);
        }
        
      protected:
        _Nodeptr _Ptr;
    };

    typedef reverse_bidirectional_iterator<iterator, T, Tref, Tptr>  reverse_iterator;

    explicit list() : _Head(_Buynode()), _Size(0) {}
    explicit list(size_t _N, const T& _V = T()) : _Head(_Buynode()), _Size(0) {
        insert(begin(), _N, _V);
    }

    ~list() {
        erase(begin(), end());
        _Freenode(_Head);
        _Head = 0, _Size = 0; // not necessary
    }
    
    inline iterator begin()    {return (iterator(_Acc::_Next(_Head))); }
    inline iterator end()    {return (iterator(_Head)); }

    inline reverse_iterator rbegin() {return (reverse_iterator(end())); }
    inline reverse_iterator rend()  {return  (reverse_iterator(begin())); }

    inline size_t size() const   {return (_Size); }
    inline bool empty() const   {return (size() == 0); }

    inline Tref front()    {return (*begin()); }
    inline Tref back()    {return (*(--end())); }

    inline void push_front(const T& _X)    {insert(begin(), _X); }
    inline void pop_front()    {erase(begin()); }
    inline void push_back(const T& _X)    {insert(end(), _X); }
    inline void pop_back()    {erase(--end()); }

    iterator insert(iterator _P, const T& _X = T())
    {
        _Nodeptr _S = _P._Mynode();
        _Acc::_Prev(_S) = _Buynode(_S, _Acc::_Prev(_S));
        _S = _Acc::_Prev(_S);
        _Acc::_Next(_Acc::_Prev(_S)) = _S;

        #if 0
        // what's this for ??
        allocator.construct(&_Acc::_Value(_S), _X);
        #else
        _Acc::_Value(_S) = _X;
        #endif

        ++_Size;
        return (iterator(_S));
    }
    
    void insert(iterator _P, size_t _M, const T& _X)
    {
        for (; 0 < _M; --_M)
            insert(_P, _X);
    }
    
    void insert(iterator _P, const T *_F, const T *_L)
    {
        for (; _F != _L; ++_F)
            insert(_P, *_F);
    }
    
    void insert(iterator _P, iterator _F, iterator _L)
    {
        for (; _F != _L; ++_F)
            insert(_P, *_F);
    }
    
    iterator erase(iterator _P)
    {
        _Nodeptr _S = (_P++)._Mynode();
        _Acc::_Next(_Acc::_Prev(_S)) = _Acc::_Next(_S);
        _Acc::_Prev(_Acc::_Next(_S)) = _Acc::_Prev(_S);
        //allocator.destroy(&_Acc::_Value(_S));
        _Freenode(_S);
        --_Size;
        return (_P);
    }
    
    iterator erase(iterator _F, iterator _L)
    {
        while (_F != _L)
            erase(_F++);
        return (_F);
    }
    
    void clear()    {erase(begin(), end()); }

    void splice(iterator _P, _Myt& _X)
    {
        if (!_X.empty()) {
            _Splice(_P, _X, _X.begin(), _X.end());
            _Size += _X._Size;
            _X._Size = 0;
        }
    }
    
    void splice(iterator _P, _Myt& _X, iterator _F)
    {
        iterator _L = _F;
        if (_P != _F && _P != ++_L)  {
            _Splice(_P, _X, _F, _L);
            ++_Size;
            --_X._Size;
        }
    }
    
    void splice(iterator _P, _Myt& _X, iterator _F, iterator _L)
    {
        if (_F != _L)  {
            if (&_X != this) {
                difference_type _N = 0;
                _Distance(_F, _L, _N);
                _Size += _N;
                _X._Size -= _N;
            }
            _Splice(_P, _X, _F, _L);
        }
    }
    
    void remove(const T& _V)
    {
        iterator _L = end();
        for (iterator _F = begin(); _F != _L; )
            if (*_F == _V)
                erase(_F++);
            else
                ++_F;
    }

    #if 0
    typedef binder2nd<not_equal_to<T> > _Pr1;
    void remove_if(_Pr1 _Pr)
    {
        iterator _L = end();
        for (iterator _F = begin(); _F != _L; )
            if (_Pr(*_F))
                erase(_F++);
            else
                ++_F;
    }
    #endif

  protected:
    _Nodeptr _Buynode(_Nodeptr _Narg = 0, _Nodeptr _Parg = 0)
    {
        //_Nodeptr _S = (_Nodeptr)allocator._Charalloc(1 * sizeof(_Node));

        _Nodeptr _S = (_Nodeptr) malloc(1 * sizeof(_Node));
        _Acc::_Next(_S) = _Narg != 0 ? _Narg : _S;
        _Acc::_Prev(_S) = _Parg != 0 ? _Parg : _S;
        return (_S);
    }

    inline void _Freenode(_Nodeptr _S)  { free(_S); }

    void _Splice(iterator _P, _Myt& _X, iterator _F, iterator _L)
    {
        _Acc::_Next(_Acc::_Prev(_L._Mynode())) = _P._Mynode();
        _Acc::_Next(_Acc::_Prev(_F._Mynode())) = _L._Mynode();
        _Acc::_Next(_Acc::_Prev(_P._Mynode())) = _F._Mynode();
        _Nodeptr _S = _Acc::_Prev(_P._Mynode());
        _Acc::_Prev(_P._Mynode()) = _Acc::_Prev(_L._Mynode());
        _Acc::_Prev(_L._Mynode()) = _Acc::_Prev(_F._Mynode());
        _Acc::_Prev(_F._Mynode()) = _S;
    }

    void _Distance(iterator _F, iterator _L, difference_type& _N) {
        for (; _F != _L; ++_F)  ++_N;
    }
    
    _Nodeptr _Head;
    LONG _Size;
};  // list


#pragma auto_inline(on)
_DASTL_NAMESPACE_END

#endif /* _DASTLLIST_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\dastlvector.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

*******************************************************************************/
#ifndef _DASTLVECTOR_H
#define _DASTLVECTOR_H


#include<privinc/DaStlUtility.h>


_DASTL_NAMESPACE_BEGIN
#pragma auto_inline(off)


#define DEFAULT_VECTOR_SIZE 4

                // TEMPLATE FUNCTION _Destroy
#define _DESTRUCTOR(ty, ptr)    (ptr)->~ty()

template<class _Ty>
inline void _Destroy(_Ty _FARQ *_P)  { (_P)->~_Ty(); }
inline void _Destroy(char _FARQ *_P)   {}
inline void _Destroy(wchar_t _FARQ *_P) {}

template<class _T1, class _T2>
inline  void _Construct(_T1 _FARQ *_P, const _T2& _V)
        {new ((void _FARQ *)_P) _T1(_V); }

template<class T> class vector {

  public:

    typedef T * iterator;
    typedef T * Tptr;
    typedef T & reference;
    typedef reverse_iterator<iterator, T>  reverse_iterator;
    typedef vector<T> myType;
    
    vector()           { _Construct(DEFAULT_VECTOR_SIZE); }
    vector(ULONG size, T fillVal = T()) { _Construct(size); _Fill(fillVal, size); }

    ~vector() { clear(); free( _array );}

//    ~vector() { clear(); delete [] _array ;}
//    ~vector() { clear(); GlobalFree(_array); }

    void push_back(T e) {
        DebugCode( _Assertions() );

        if(_end == _arrayEnd)  _Realloc();

        (*_end) = e;
        _end++;

        DebugCode( _debugArraySize++ );
        DebugCode( _Assertions() );
    }

    inline void pop_back() {
        DebugCode( _Assertions() );
        DebugCode(_debugArraySize--);
        _end--;

        _Destroy(_end);
        
        DebugCode( _Assertions() );
    }

    inline reference back()     {
        DebugCode( _Assertions() );
        Assert( !empty() );
        return *(_end-1);
    }        

    inline reference front()     {
        DebugCode( _Assertions() );
        Assert( !empty() );
        return *(_begin);
    }        

    void   clear() {
        DebugCode( _Assertions() );
        _DestroyToEnd(_begin);
        _begin = _end = &(_array[0]);
        DebugCode( _debugArraySize=0 );
        DebugCode( _Assertions() );
    }
    inline bool   empty() { DebugCode( _Assertions() );  return _begin == _end; }
    inline int    size()  { DebugCode( _Assertions() );  return _end - _begin; }
    
    inline iterator begin() { return _begin; }
    inline iterator end()   { return _end; }    

    inline reverse_iterator rbegin() { return reverse_iterator(end()); }
    inline reverse_iterator rend() { return reverse_iterator(begin()); }

    inline reference operator [](DWORD index) {
        DebugCode( _Assertions() );
        Assert( 0 <= index  &&  index < size() );
        return _array[index];
    }

    myType & operator =(myType & Src)
    {
        if(this == &Src) {
            // nothing
        } else {
            clear();  // empty me and destroy everthing
            myType::iterator i;

            // copy Src to me
            for(i=Src.begin(); i!=Src.end(); i++) {
                push_back(*i);
            }
            // NOTE: if the Src array is much smaller than this array
            // we could be wasting memory.  an easy optimization would
            // be to resize my allocated array to be real small again
            // or to just memcpy Src._array after freeing mine
        }
        return (*this);
    }
        
    ULONG capacity() { return _arrayEnd - _begin; }

  private:

    #if _DEBUG
    void _Assertions() {
        Assert( _debugArraySize <= _debugCapacity );
        Assert( 0 <= _debugArraySize );
        Assert( _begin < _arrayEnd );
        Assert( _begin <= _end );
        Assert( _end <= _arrayEnd );
        Assert( (_end - _begin) == _debugArraySize );
        Assert( (_arrayEnd - _begin) == _debugCapacity );
    }
    #endif
        
    void _Construct(ULONG size) {
        _array = (T *) malloc(size * sizeof(T));
        //_array = NEW T[size];
        //_array = (T *)GlobalAlloc(GMEM_FIXED, size * sizeof(T));
        _InitIndicies(0, size);
        DebugCode(_debugCapacity = size );
        DebugCode(_debugArraySize = 0 );
        DebugCode( memset( (void *)_begin, 0xab, size * sizeof(T)) );
    }

    // Detroys from _Start to _end.  Caller responsible for updating
    // _end properly
    void _DestroyToEnd(iterator _Start) {
        DebugCode( _Assertions() );
        for (; _Start != _end; ++_Start)
            _Destroy(_Start);
        DebugCode( _Assertions() );
    }
    void _Fill(T val, ULONG copies) {
        DebugCode( _Assertions() );
        DebugCode( _debugCapacity >= copies );
        for(_end=_begin; copies; _end++, copies--) {
            (*_end) = val;
            DebugCode( _debugArraySize++ );
        }
        DebugCode( _Assertions() );
    }
    void _Realloc() {
        Assert( size() > 0);
        int s = size();
        int newCap = 2 * capacity();
        
        // TODO: fail if _array == NULL
        //_array = (T *)realloc(_array, newCap * sizeof(T));
        void *temp = (void *)realloc(_array, newCap * sizeof(T));
        if (temp != NULL)
            _array = (T *)temp;
        else
        {
            free (_array);
           _array = NULL;
        }

        /*
        T *tmp = NEW T[newCap];
        memcpy((void *)tmp, (void *)_array, (newCap /2) *sizeof(T));
        delete [] _array;
        _array = tmp;
        */
        //_array = (T *)GlobalReAlloc(_array, newCap * sizeof(T), GMEM_MOVEABLE);
        
        _InitIndicies(s, newCap);

        DebugCode( _debugCapacity = newCap );
        DebugCode( _Assertions() );
    }

    void _InitIndicies(int current, int arrayCapacity) {
        _begin = &(_array[0]);
        _end   = _begin + current;
        _arrayEnd = _begin + arrayCapacity;
    }

    DebugCode( int _debugArraySize );
    DebugCode( int _debugCapacity );
    
    iterator _begin, _end, _arrayEnd;
    T *_array;
    
};  // vector

#if 0
                // TEMPLATE CLASS vector
template<class _Ty >
class vector
{
  public:
    typedef vector<_Ty> _Myt;
    typedef size_t size_type;
    typedef _Ty * _Tptr;
    typedef _Ty & reference;
    typedef _Ty value_type;
    typedef _Tptr iterator;
    typedef reverse_iterator<iterator, value_type, reference, _Tptr> reverse_iterator;

    explicit vector() : _First(0), _Last(0), _End(0) {}
    explicit vector(size_type _N, const _Ty& _V = _Ty())
    {
        //_First = allocator.allocate(_N, (void *)0);
        _First = (_Ty *) operator new(_N * sizeof( _Ty ));
        _Ufill(_First, _N, _V);
        _Last = _First + _N;
        _End = _Last;
    }
    #if 0
    vector(const _Myt& _X)
    {
        _First = allocator.allocate(_X.size(), (void *)0);
        _Last = _Ucopy(_X.begin(), _X.end(), _First);
        _End = _Last;
    }
    #endif
    typedef iterator _It;
    vector(_It _F, _It _L)  : _First(0), _Last(0), _End(0)
    {
        insert(begin(), _F, _L);
    }

    ~vector()
    {
        _Destroy(_First, _Last);
        //allocator.deallocate(_First, _End - _First);
        delete _First;
        _First = 0, _Last = 0, _End = 0;
    }

    size_type capacity()  {return (_First == 0 ? 0 : _End - _First); }
    iterator begin()   {return (_First); }
    iterator end()    {return (_Last); }
    reverse_iterator rbegin()    {return (reverse_iterator(end())); }
    reverse_iterator rend()    {return (reverse_iterator(begin())); }
    size_type size() const    {return (_First == 0 ? 0 : _Last - _First); }
    size_type max_size() const    {return (allocator.max_size()); }
    bool empty() const    {return (size() == 0); }
    reference operator[](size_type _P)    {return (*(begin() + _P)); }
    reference front()    {return (*begin()); }
    reference back()    {return (*(end() - 1)); }
    //void push_back(const _Ty& _X)    {insert(end(), _X); }
    void push_back(const _Ty& _X)    { }
    //void pop_back()    {erase(end() - 1); }
    void pop_back()    { _Destroy(end() - 1, end()); _Last--; }
    void clear()    {
        _Destroy(_First, _Last);
        _First = _Last = 0;
    }

  protected:
    void _Destroy(iterator _F, iterator _L)    {
        for (; _F != _L; ++_F)    { (_F)->~_Ty(); } }//_Destroy(_F); }
    void _Ufill(iterator _F, size_type _N, const _Ty &_X)
    {
        for (; 0 < _N; --_N, ++_F) _Construct(_F, _X);
    }
    iterator _First, _Last, _End;
};
#endif // stl's impl.

#pragma auto_inline(on)
_DASTL_NAMESPACE_END

#endif /* _DASTLVECTOR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\dastlutility.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/
#ifndef _DASTLUTILITY_H
#define _DASTLUTILITY_H


#define _DASTL_NAMESPACE_BEGIN  namespace DaStl {
#define _DASTL_NAMESPACE_END }



_DASTL_NAMESPACE_BEGIN
#pragma auto_inline(off)

                // TEMPLATE FUNCTION find
template<class _II, class _Ty>
_II find(_II _F, _II _L, const _Ty& _V)
{
    for (; _F != _L; ++_F) {
        if (*_F == _V)  break;
    }
    return (_F);
}

                // TEMPLATE FUNCTION iter_swap
template<class _FI1, class _FI2>
void iter_swap(_FI1 _X, _FI2 _Y) {
    _Iter_swap(_X, _Y, &(*_X));
}

template<class _FI1, class _FI2, class _Ty>
void _Iter_swap(_FI1 _X, _FI2 _Y, _Ty *)
{
    _Ty _Tmp = *_X;
    *_X = *_Y;
    *_Y = _Tmp;
}

                // TEMPLATE FUNCTION partition
template<class _BI, class _Pr>
_BI partition(_BI _F, _BI _L, _Pr _P)
{
    for (; ; ++_F) {
        for (; _F != _L && _P(*_F); ++_F)
            ;
        if (_F == _L)
            break;
        for (; _F != --_L && !_P(*_L); )
            ;
        if (_F == _L)
            break;
        iter_swap(_F, _L);
    }
    return (_F);
}


                // TEMPLATE CLASS reverse_iterator
template<class _RI,
         class _Ty,
         class _Rt = _Ty&,
         class _Pt = _Ty*,
         class _D  = int>
class reverse_iterator {
  public:
    typedef reverse_iterator<_RI, _Ty, _Rt, _Pt, _D> _Myt;
    typedef _RI iter_type;
    typedef _Rt reference_type;
    typedef _Pt pointer_type;
    reverse_iterator()              {}
    inline explicit reverse_iterator(_RI _X)  : current(_X) {}
    inline _RI base() const   {return (current); }
    inline _Rt operator*() const  {return (*(current - 1)); }
    inline _Pt operator->() const  {return (&**this); }
    
    inline _Myt& operator++()  {
        --current;
        return (*this);
    }
    inline _Myt operator++(int)  {
        _Myt _Tmp = *this;
        --current;
        return (_Tmp);
    }
    inline _Myt& operator--()  {
        ++current;
        return (*this);
    }
    inline _Myt operator--(int)  {
        _Myt _Tmp = *this;
        ++current;
        return (_Tmp);
    }
    inline _Myt& operator+=(_D _N)  {
        current -= _N;
        return (*this);
    }
    inline _Myt operator+(_D _N) const  {return (_Myt(current - _N)); }
    inline _Myt& operator-=(_D _N)  {
        current += _N;
        return (*this);
    }
    inline _Myt operator-(_D _N) const {return (_Myt(current + _N)); }
    inline _Rt operator[](_D _N) const {return (*(*this + _N)); }

    inline bool operator==(_Myt IT) { return base() == IT.base(); }
    inline bool operator!=(_Myt IT) { return base() != IT.base(); }

  protected:
    _RI current;
};

                // TEMPLATE CLASS reverse_bidirectional_iterator
template<class _BI,
         class _Ty,
         class _Rt = _Ty&,
         class _Pt = _Ty *>
class reverse_bidirectional_iterator
{
  public:
    typedef reverse_bidirectional_iterator<_BI, _Ty, _Rt, _Pt> _Myt;
    typedef _BI iter_type;
    typedef _Rt reference_type;
    typedef _Pt pointer_type;
    reverse_bidirectional_iterator()    {}
    explicit reverse_bidirectional_iterator(_BI _X) : current(_X) {}

    inline _BI base() const    {return (current); }
    inline _Rt operator*() const    {
        _BI _Tmp = current;
        return (*--_Tmp);
    }
    
    inline _Pt operator->() const    {return (&**this); }

    inline _Myt& operator++() {
        --current;
        return (*this);
    }
    
    inline _Myt operator++(int)  {
        _Myt _Tmp = *this;
        --current;
        return (_Tmp);
    }
    
    inline _Myt& operator--() {
        ++current;
        return (*this);
    }
    
    inline _Myt operator--(int) {
        _Myt _Tmp = *this;
        ++current;
        return (_Tmp);
    }
    
    inline bool operator==(const reverse_bidirectional_iterator& _X) const {
        return (base() == _X.base());
    }
    
    inline bool operator!=(const reverse_bidirectional_iterator& _X) const {
        // try this for size...
        //return (base() != _X.base()));
        return (!(*this == _X));
    }
        
  protected:
    _BI current;
};

#pragma auto_inline(on)
_DASTL_NAMESPACE_END

#endif /* _DASTLUTILITY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\dastream.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _DASTREAM_H
#define _DASTREAM_H

#include "privinc/except.h"

class ATL_NO_VTABLE dastream : public AxAThrowingAllocatorClass
{
  public:
    virtual ~dastream() {}
    
    virtual ULONG read (void *pv, ULONG cb) = 0;
    // If bWriteAll is TRUE then this will ensure that all the bytes
    // are written unless an error occurs
    virtual ULONG write (void *pv, ULONG cb, bool bWriteAll = TRUE) = 0;

    enum DASEEK {
        DASEEK_SET = 0,
        DASEEK_CUR = 1,
        DASEEK_END = 2
    } ;

    virtual ULONG seek (LONG offset, DASEEK origin) = 0;
};

class daolestream : public dastream
{
  public:
    daolestream() {}
    daolestream(IStream * istream)
    : _stream(istream)
    {}

    IStream * GetStream() { return _stream; }
    void SetStream(IStream * istream) { _stream = istream; }
    
    virtual ULONG read (void *pv, ULONG cb);
    virtual ULONG write (void *pv, ULONG cb, bool bWriteAll = TRUE);
    virtual ULONG seek (LONG offset, DASEEK origin);
  protected:
    CComPtr<IStream> _stream;
};

class dawin32stream : public dastream
{
  public:
    dawin32stream() : _handle(NULL) {}
    dawin32stream(HANDLE handle)
    : _handle(handle)
    {}

    HANDLE GetHandle() { return _handle; }
    void SetHandle(HANDLE handle) { _handle = handle; }
    
    virtual ULONG read (void *pv, ULONG cb);
    virtual ULONG write (void *pv, ULONG cb, bool bWriteAll = TRUE);
    virtual ULONG seek (LONG offset, DASEEK origin);
  protected:
    HANDLE _handle;
};

class dafstream : public dawin32stream
{
  public:
    dafstream() : _mode(0) {}
    dafstream(char * file, int mode) : _mode(0) { open(file,mode); }
    ~dafstream() { close(); }

    void open(char * file, int mode);
    void close();
    
    bool IsOpen() { return _handle != NULL; }
    
    enum damode {
        damode_read     = 0x01,
        damode_write    = 0x02,
        damode_nocreate = 0x04,
        damode_trunc    = 0x08,
        damode_noreplace= 0x10,
        damode_noshare  = 0x20,
    };
  protected:
    int _mode;
};

class dastrstream : public dastream
{
  public:
    dastrstream(char * str) : _pdata(NULL) { init(str,lstrlen(str)); }
    dastrstream(void * pv, ULONG cb) : _pdata(NULL) { init(pv,cb); }
    dastrstream(ULONG cb) : _pdata(NULL) { init(NULL,cb); }
    ~dastrstream() { if (_pdata) delete [] _pdata; }

    char * GetPtr() { return _pdata; }
    ULONG GetCurPos() { return _curpos; }
    ULONG GetSize() { return _size; }

    virtual ULONG read (void *pv, ULONG cb);
    virtual ULONG write (void *pv, ULONG cb, bool bWriteAll = TRUE);
    virtual ULONG seek (LONG offset, DASEEK origin);
  protected:
    void init(void * pv, ULONG cb);
    char * _pdata;
    ULONG _curpos;
    ULONG _size;
};

#endif /* _DASTREAM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\ddrender.h ===
#pragma once
#ifndef _DDRENDER_H
#define _DDRENDER_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Declarations for the GeomRenderer class.  This object renders 3D geometry
onto a DirectDraw surface.

*******************************************************************************/

#include <ddraw.h>
#include <d3d.h>
#include <d3drm.h>
#include <dxtrans.h>

#include "appelles/common.h"

#include "privinc/ddutil.h"
#include "privinc/colori.h"
#include "privinc/vec3i.h"
#include "privinc/bbox2i.h"


    // Forward Declarations For This Header

struct DDSurface;
class  DirectDrawImageDevice;
class  DirectDrawViewport;
class  Light;
class  LightContext;
enum   LightType;
class  RayIntersectCtx;
class  RM1VisualGeo;
class  RM3VisualGeo;
class  RMVisualGeo;


struct FramedRM1Light
{
    IDirect3DRMFrame *frame;   // Light Frame
    IDirect3DRMLight *light;   // Light Object
    bool active;               // True if Light Active (Attached to Scene)
};


struct FramedRM3Light
{
    IDirect3DRMFrame3 *frame;  // Light Frame
    IDirect3DRMLight  *light;  // Light Object
    bool active;               // True if Light Active (Attached to Scene)
};


class CtxAttrState
{
  public:
    void InitToDefaults();

    Transform3 *_transform; // Current Modeling Transform

    // Material Attributes
    Color *_emissive;    // Emitted Color, "Glow"
    Color *_ambient;     // Ambient Color
    Color *_diffuse;     // Diffuse Color
    Color *_specular;    // Specular (Gloss) Highlight Color
    Real   _specularExp; // Specular Exponent (Shininess)
    Real   _opacity;     // Opacity (0=invisible, 1=opaque)

    bool _tdBlend;       // Blend Texmaps and Diffuse Color

    Image *_texmap;      // Image to Use as Texture Map
    void  *_texture;     // D3DRM Texture

    short _depthEmissive;          // These depth counts are used to manage
    short _depthAmbient;           // outer-overriding attributes, and to
    short _depthDiffuse;           // determine which attribute is in a non-
    short _depthSpecular;          // default state.
    short _depthSpecularExp;
    short _depthTexture;
    short _depthTDBlend;
};


class PreTransformedImageBundle {
  public:
    int  width;
    int  height;
    long preTransformedImageId;

    bool operator<(const PreTransformedImageBundle &b) const;
    bool operator==(const PreTransformedImageBundle &b) const;
};



class ATL_NO_VTABLE GeomRenderer : public GenericDevice
{
  public:

    GeomRenderer (void);
    ~GeomRenderer (void);


        /************************/
        /* Pure Virtual Methods */
        /************************/

    // The Initialize() function returns the D3D or DDraw HRESULT of the
    // initialization error, or NOERROR if all initialized successfully.

    virtual HRESULT Initialize (
        DirectDrawViewport *viewport,
        DDSurface          *ddsurf) = 0;

    virtual void RenderGeometry (
        DirectDrawImageDevice *imgDev,
        RECT      target_region,  // Target Region on Rendering Surface
        Geometry *geometry,       // Geometry To Render
        Camera   *camera,         // Viewing Camera
        const Bbox2 &region) = 0;    // Source Region in Camera Coords

    virtual void Pick (
        RayIntersectCtx   &context,   // Ray-Intersection Context
        IDirect3DRMVisual *visual,    // Visual or Mesh to Pick
        Transform3        *xform)     // Model-To-World Transform
    {
    }

    // Given a surface and a colorkey, this function returns the associated
    // D3DRM texmap data.

    virtual void* LookupTextureHandle (
        IDirectDrawSurface *surface,         // DDraw Surface
        DWORD               colorKey,        // Transparency Color-Key
        bool                colorKeyValid,   // If ColorKey Valid
        bool                dynamic) = 0;    // Dynamic Texture Flag

    // Do I have a texture handle for this surface ?
    // if so, release the handle and delete the entry

    virtual void SurfaceGoingAway (IDirectDrawSurface *surface) = 0;

    // This method adds a light for rendering.  Note that it must be called
    // between BeginRendering and EndRendering().

    virtual void AddLight (LightContext &context, Light &light) = 0;

    // The following methods submit a geometric primitive for rendering with
    // the current attribute state.

    virtual void Render (RM1VisualGeo *geo) = 0;
    virtual void Render (RM3VisualGeo *geo) = 0;

    // Convert from coordinates to world coordinates.

    virtual void ScreenToWorld (Point3Value &screen, Point3Value &world)
    {
    }

    virtual void RenderTexMesh (void *texture,
#ifndef BUILD_USING_CRRM
                                IDirect3DRMMesh  *mesh,
                                long              groupId,
#else
                                int vCount,
                                D3DRMVERTEX *d3dVertArray,
                                unsigned *vIndicies,
                                BOOL doTexture,
#endif
                                const Bbox2 &box,
                                RECT *destRect,
                                bool bDither) = 0;

    // SetView takes the given camera and sets the orienting and projection
    // transforms for the image viewport and volume.

    virtual void SetView
        (RECT *target, const Bbox2 &viewport, Bbox3 *volume) = 0;

    virtual void GetRMDevice (IUnknown **D3DRMDevice, DWORD *SeqNum) = 0;

    virtual void RenderMeshBuilderWithDeviceState
                     (IDirect3DRMMeshBuilder3 *mb) = 0;

    // This method denotes when the geometry is ready to be used as a picking
    // engine.  This applies only to GeomRendererRM1 objects.

    virtual bool PickReady (void) { return false; }

    virtual DirectDrawImageDevice& GetImageDevice (void) = 0;

    // Only of use to the MeshMaker subclass
    virtual bool CountingPrimitivesOnly_DoIncrement() { return false; }
    virtual bool IsMeshmaker() { return false; }


        /************************/
        /* Attribute Management */
        /************************/

    Transform3 *GetTransform (void);
    void        SetTransform (Transform3 *xf);

    void PushEmissive (Color*);
    void PopEmissive  (void);

    void PushAmbient (Color*);
    void PopAmbient  (void);

    void PushDiffuse (Color*);
    void PopDiffuse  (void);

    void PushSpecular (Color*);
    void PopSpecular  (void);

    void PushSpecularExp (Real);
    void PopSpecularExp  (void);

    Real GetOpacity (void);
    void SetOpacity (Real opacity);

    void PushTexture (void*);
    void PopTexture (void);

    void PushTexDiffBlend (bool);
    void PopTexDiffBlend (void);

    void PushAttrState(void);
    void PopAttrState(void);

    void GetAttrState(CtxAttrState *st);
    void SetAttrState(CtxAttrState *st);

    virtual HRESULT SetClipPlane(Plane3 *plane, DWORD *planeID)
    {
        return E_NOTIMPL;
    }

    virtual void ClearClipPlane(DWORD planeID) {}

    virtual void PushLighting (bool) {}
    virtual void PopLighting (void) {}

    virtual void PushOverridingOpacity (bool) {}
    virtual void PopOverridingOpacity (void) {}

    virtual bool StartShadowing(Plane3 *shadowPlane) { return false; }
    virtual void StopShadowing(void) { }

    virtual bool IsShadowing(void) { return false; }

    virtual void PushAlphaShadows(bool alphaShadows) { }
    virtual void PopAlphaShadows(void) { }

    /*******************************/
    /* Other Common Public Methods */
    /*******************************/

    DeviceType GetDeviceType() { return(GEOMETRY_DEVICE); }

    // This method is called by geometry who, while experiencing pre-rendering
    // traversal need to cache the texture handle.

    virtual void* DeriveTextureHandle (
        Image                 *image,
        bool                   applyAsVrmlTexture,
        bool                   oldStyle,
        DirectDrawImageDevice *imageDevice = NULL);

    virtual void SetDoImageSizedTextures(bool a) { _doImageSizedTextures = a; }
    virtual bool GetDoImageSizedTextures() { return _doImageSizedTextures; }

    bool ReadyToRender() { return _renderState == RSReady; }

    // Return the camera currently in use.

    Camera *CurrentCamera (void);
    void    SetCamera (Camera*);


  protected:

    enum RenderState { RSUninit, RSScram, RSReady, RSRendering, RSPicking };

    /***********************/
    /** Private Functions **/
    /***********************/

    void ClearIntraFrameTextureImageCache (void);

    void AddToIntraFrameTextureImageCache
        (int width, int height, long origImageId, Image *finalImage, bool upsideDown);

    Image *LookupInIntraFrameTextureImageCache
        (int width, int height, long origImageId, bool upsideDown);

    bool SetState (RenderState);


    /******************/
    /** Private Data **/
    /******************/

    static long _id_next;  // ID Generator
           long _id;       // Per-Object Unique Identifier

    RenderState _renderState;   // Current State of Renderer

    DirectDrawImageDevice *_imageDevice;  // Per-Frame Image Device
    D3DDEVICEDESC          _deviceDesc;   // D3D Device Description
    D3DRMTEXTUREQUALITY    _texQuality;   // Current Texture Quality

    // We need to have access to all the elements on the "stack", thus we make
    // it a vector<>.

    vector<CtxAttrState> _attrStateStack;
    CtxAttrState         _currAttrState;

    typedef map<PreTransformedImageBundle, Image *,
            less<PreTransformedImageBundle> > imageMap_t;

    imageMap_t _intraFrameTextureImageCache;
    imageMap_t _intraFrameTextureImageCacheUpsideDown;

    // Flags

    bool _doImageSizedTextures;

    // Dimensions of the Target Surface

    DWORD _targetSurfWidth;
    DWORD _targetSurfHeight;

    Camera *_camera;  // Currently In-Use Camera
};



// GeomRenderer Methods

inline Camera* GeomRenderer::CurrentCamera (void)
{
    return _camera;
}

inline void GeomRenderer::SetCamera (Camera *camera)
{
    _camera = camera;
}



/*****************************************************************************
This class implements 3D rendering specific to RM3 (on DX3)
*****************************************************************************/

class GeomRendererRM1 : public GeomRenderer
{
  public:

    GeomRendererRM1 (void);
    ~GeomRendererRM1 (void);

    virtual HRESULT Initialize
        (DirectDrawViewport*, DDSurface*);

    virtual void RenderGeometry
        (DirectDrawImageDevice *, RECT, Geometry*, Camera*, const Bbox2 &);

    virtual void Pick (RayIntersectCtx&, IDirect3DRMVisual*, Transform3*);

    virtual void* LookupTextureHandle (
        IDirectDrawSurface *surface,         // DDraw Surface
        DWORD               colorKey,        // Transparency Color-Key
        bool                colorKeyValid,   // If ColorKey Valid
        bool                dynamic);        // Dynamic Texture Flag

    virtual void SurfaceGoingAway (IDirectDrawSurface *surface);

    virtual void AddLight (LightContext &context, Light &light);

    virtual void Render (RM1VisualGeo *geo);

    virtual void Render (RM3VisualGeo *geo) {
        Assert (!"Attempt to render RM3 primitive with RM1 renderer.");
    }

    virtual void ScreenToWorld (Point3Value &screen, Point3Value &world);

    virtual void RenderTexMesh (void *texture,
#ifndef BUILD_USING_CRRM
                                IDirect3DRMMesh  *mesh,
                                long              groupId,
#else
                                int vCount,
                                D3DRMVERTEX *d3dVertArray,
                                unsigned *vIndicies,
                                BOOL doTexture,
#endif
                                const Bbox2 &box,
                                RECT *destRect,
                                bool bDither);

    virtual void SetView (RECT*, const Bbox2 &, Bbox3*);

    virtual void GetRMDevice (IUnknown **D3DRMDevice, DWORD *SeqNum);

    virtual void RenderMeshBuilderWithDeviceState (IDirect3DRMMeshBuilder3*);

    virtual bool PickReady (void) {
        return _pickReady;
    }

    virtual DirectDrawImageDevice& GetImageDevice (void) {
        return *_imageDevice;
    }

    //BUGBUG: High quality rotations cause a crash in RM on NT4 but not on NT5 or Win98. 
    //We suspect that the RM in DX3 is the culprit. As a temporary patch to meet the IE5 deadline,
    //we'll disallow high quality rotations if we are using RM1. We do this by overriding the 
    //implementation from the base class as follows --SumedhB 12/15/98    
    void SetDoImageSizedTextures(bool a) { }
    bool GetDoImageSizedTextures() { return false; }

  private:

    /***********************/
    /** Private Functions **/
    /***********************/

    void BeginRendering (
        RECT      target,     // Target DDraw Surface Rectangle
        Geometry *geometry,   // Geometry To Render
        const Bbox2 &region);    // Target Region in Camera Coordinates

    void EndRendering (void);

        // Viewport setup for both the IM and RM viewports.

    void SetupViewport (RECT *target);

        // Render the given RM visual object to the current viewport.

    void Render (IDirect3DRMFrame*);


    /****************/
    /* Private Data */
    /****************/

    IDirect3D   *_d3d;         // Main D3D Object
    IDirect3DRM *_d3drm;       // Main D3D Retained-Mode Object

    IDirect3DRMDevice   *_Rdevice;     // Retained-Mode Rendering Device
    IDirect3DRMViewport *_Rviewport;   // RM Viewport
    IDirect3DDevice     *_Idevice;     // D3D Immediate-Mode Device
    IDirect3DViewport   *_Iviewport;   // D3D IM Viewport
    D3DVIEWPORT          _Iviewdata;   // IM Viewport Data
    RECT                 _lastrect;    // Prior Target Rectangle

    DirectDrawViewport  *_viewport;    // Owning Viewport
    IDirectDrawSurface  *_surface;     // Destination DDraw Surface


        // RM Frames

    IDirect3DRMFrame *_scene;          // Main Scene Frame
    IDirect3DRMFrame *_camFrame;       // Retained-Mode Camera Frame
    IDirect3DRMFrame *_geomFrame;      // Standard Geometry Object Frame
    IDirect3DRMFrame *_texMeshFrame;   // Un-Zbuffered Geometry Frame

    IDirect3DRMLight *_amblight;       // Total Ambient Light for Scene
    Color             _ambient_light;  // Ambient Light Level

        // The light pool holds FramedLight objects, which are used up during
        // a render pass as lights are encountered.  The pool grows as
        // necessary to accomodate all lights in a given render.

    vector<FramedRM1Light*>           _lightpool;
    vector<FramedRM1Light*>::iterator _nextlight;

        // Surface-RMTexture Association

    typedef map<IDirectDrawSurface*, IDirect3DRMTexture*,
                less<IDirectDrawSurface*> > SurfTexMap;

    SurfTexMap _surfTexMap;

        // Flags

    bool _geomvisible;   // True if Geometry Can Be Seen
    bool _pickReady;     // Ready for Picking
};



/*****************************************************************************
This class implements 3D rendering specific to RM6 (on DX5).
*****************************************************************************/

class GeomRendererRM3 : public GeomRenderer
{
  public:

    GeomRendererRM3 (void);
    ~GeomRendererRM3 (void);

    virtual HRESULT Initialize
        (DirectDrawViewport*, DDSurface*);

    virtual void RenderGeometry
        (DirectDrawImageDevice *, RECT, Geometry*, Camera*, const Bbox2 &);

    virtual void* LookupTextureHandle (
        IDirectDrawSurface *surface,         // DDraw Surface
        DWORD               colorKey,        // Transparency Color-Key
        bool                colorKeyValid,   // If ColorKey Valid
        bool                dynamic);        // Dynamic Texture Flag

    virtual void SurfaceGoingAway (IDirectDrawSurface *surface);

    virtual void AddLight (LightContext &context, Light &light);

    virtual void Render (RM1VisualGeo *geo);
    virtual void Render (RM3VisualGeo *geo);

    virtual void RenderTexMesh (void *texture,
#ifndef BUILD_USING_CRRM
                                IDirect3DRMMesh  *mesh,
                                long              groupId,
#else
                                int vCount,
                                D3DRMVERTEX *d3dVertArray,
                                unsigned *vIndicies,
                                BOOL doTexture,
#endif
                                const Bbox2 &box,
                                RECT *destRect,
                                bool bDither);

    virtual void SetView (RECT*, const Bbox2 &, Bbox3*);

    virtual void GetRMDevice (IUnknown **D3DRMDevice, DWORD *SeqNum);

    virtual void RenderMeshBuilderWithDeviceState (IDirect3DRMMeshBuilder3*);

    virtual DirectDrawImageDevice& GetImageDevice (void) {
        return *_imageDevice;
    }

    virtual HRESULT SetClipPlane(Plane3 *plane, DWORD *planeID);
    virtual void ClearClipPlane(DWORD planeID);

    virtual void PushLighting (bool);
    virtual void PopLighting (void);

    virtual void PushOverridingOpacity (bool);
    virtual void PopOverridingOpacity (void);

    virtual bool StartShadowing(Plane3 *shadowPlane);
    virtual void StopShadowing(void);
    virtual bool IsShadowing(void);

    virtual void PushAlphaShadows(bool alphaShadows);
    virtual void PopAlphaShadows(void);


  private:

    /***********************/
    /** Private Functions **/
    /***********************/

    void BeginRendering (
        RECT      target,     // Target DDraw Surface Rectangle
        Geometry *geometry,   // Geometry To Render
        const Bbox2 &region);    // Target Region in Camera Coordinates

    void EndRendering (void);

        // Viewport setup for both the IM and RM viewports.

    void SetupViewport (RECT *target);

        // Render the given RM visual object to the current viewport.

    void Render (IDirect3DRMFrame3*);


    /****************/
    /* Private Data */
    /****************/

    IDirect3DRM3 *_d3drm;       // Main D3D Retained-Mode Object

    IDirect3DRMDevice3   *_Rdevice;     // Retained-Mode Rendering Device
    IDirect3DRMViewport2 *_Rviewport;   // RM Viewport
    RECT                  _lastrect;    // Prior Target Rectangle

    DirectDrawViewport   *_viewport;    // Owning Viewport
    IDirectDrawSurface   *_surface;     // Destination DDraw Surface

    IDirect3DRMClippedVisual *_clippedVisual; // Clipped Visual
    IDirect3DRMFrame3        *_clippedFrame;  // clipped frame

    Plane3 _shadowPlane;    // Shadow plane
    Color  _shadowColor;    // Color of shadow
    Real   _shadowOpacity;  // Opacity of shadow


        // RM Frames

    IDirect3DRMFrame3 *_scene;          // Main Scene Frame
    IDirect3DRMFrame3 *_camFrame;       // Retained-Mode Camera Frame
    IDirect3DRMFrame3 *_geomFrame;      // Standard Geometry Object Frame
    IDirect3DRMFrame3 *_texMeshFrame;   // Un-Zbuffered Geometry Frame
    IDirect3DRMFrame3 *_shadowScene;    // shadow scene frame
    IDirect3DRMFrame3 *_shadowGeom;     // holds geometry casting a shadow
    IDirect3DRMFrame3 *_shadowLights;   // holds lights producing shadows

    IDirect3DRMLight *_amblight;       // Total Ambient Light for Scene
    Color             _ambient_light;  // Ambient Light Level

        // The light pool holds FramedLight objects, which are used up during
        // a render pass as lights are encountered.  The pool grows as
        // necessary to accomodate all lights in a given render.

    vector<FramedRM3Light*>           _lightpool;
    vector<FramedRM3Light*>::iterator _nextlight;

        // Surface-RMTexture Association

    typedef map<IDirectDrawSurface*, IDirect3DRMTexture3*,
                less<IDirectDrawSurface*> > SurfTexMap;

    SurfTexMap _surfTexMap;

        // Flags

    bool _geomvisible;         // True if Geometry Can Be Seen
    bool _overriding_opacity;  // Opacity Overrides Rather Than Multiplies
    bool _alphaShadows;        // attribute for turning on high-quality shadows

        // Overriding Attribute Stack Depths

    short _depthLighting;
    short _depthOverridingOpacity;
    short _depthAlphaShadows;
};


    // This function creates and initializes a GeomRenderer object (either
    // RM1 or RM3 as appropriate).  This function returns null if it could not
    // allocate and initialize the object.

GeomRenderer* NewGeomRenderer (
    DirectDrawViewport *viewport,  // Owning Viewport
    DDSurface          *ddsurf);   // Destination DDraw Surface

    // Utility for loading up a frame with a visual and attribute state.

void LoadFrameWithGeoAndState (
    IDirect3DRMFrame3*, IDirect3DRMVisual*, CtxAttrState&,
    bool overriding_opacity = false);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\dddevice.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Declares the DirectDrawImageDevice class

*******************************************************************************/

#ifndef _DDDEVICE_H
#define _DDDEVICE_H

#include "headers.h"

#include <math.h>
#include <ddraw.h>
#include <dxtrans.h>

#include <appelles/hacks.h>
#include <appelles/bbox2.h>
#include <privinc/texti.h>

#include <privinc/ddutil.h>
#include <privinc/imgdev.h>
#include <privinc/solidImg.h>
#include <privinc/DiscImg.h>
#include <privinc/xform2i.h>
#include <privinc/bbox2i.h>
#include <privinc/textctx.h>
#include <privinc/ddrender.h>
#include <privinc/geomimg.h>
#include <privinc/viewport.h>
#include <privinc/error.h>
#include <privinc/server.h>
#include <privinc/polygon.h>
#include <privinc/matteimg.h>
#include <privinc/movieimg.h>
#include <privinc/ddsImg.h>
#include <privinc/drect.h>


void GdiBlit(GenericSurface *destSurf,
             GenericSurface *srcSurf,
             RECT *destRect,
             RECT *srcRect,
             HRGN clipRgn = NULL,
             RECT *clipRect = NULL);

enum DoBboxFlags_t {
    invalid,
    do_xform,
    do_crop,
    do_all
};

#define WIDTH(rect) ((rect)->right - (rect)->left)
#define HEIGHT(rect) ((rect)->bottom - (rect)->top)
#define FASTPIX2METER(p, res) ( Real(p) / (res) )


#if _DEBUG
extern void PrintRect(RECT *rect, char *str);
#else
#define PrintRect(a,b)
#endif


#define DEFAULT_TEXTURE_WIDTH    256
#define DEFAULT_TEXTURE_HEIGHT   256

class ProjectedGeomImage;
class MulticolorGradientImage;

// ----------------------------------------------------------------------
// Encapsulates renderString options for safety
// ----------------------------------------------------------------------
class RenderStringTargetCtx {
  public:
    RenderStringTargetCtx(DDSurface *dds) :
          _targDC(NULL),
          _targDDSurf(dds)
    {}

    RenderStringTargetCtx(HDC dc) :
          _targDC(dc),
          _targDDSurf(NULL)
    {}

    HDC GetTargetDC() { return _targDC; }
    DDSurface *GetTargetDDSurf() { return _targDDSurf; }
    
  private:
    DDSurface *_targDDSurf;
    HDC        _targDC;
};

typedef struct {
    Bool isSurface;
    union {
        void *lpBits;
        LPDDRAWSURFACE lpSurface;
    };
    long lPitch;
} destPkg_t;


class GeomRenderer;
class OverlayedImage;
class LineImage;

// WARNING: this is a bug prone assumption (implemented, as always
// under insane conditions) the creator of this class promises to
// create the _pts, _types, and _glyphmetrics on the dataHeap that's
// passed in because this class DEALLOCATES them from that heap! ok ?
class TextPoints : public AxAThrowingAllocatorClass {
  public:
    TextPoints(DynamicHeap &dataHeap, bool doDealloc) :
        _dataHeap(dataHeap)
    {
        _Clear();
        _doDealloc = doDealloc;
    }

    
    ~TextPoints() {
        if( _doDealloc ) {
            StoreDeallocate(_dataHeap, _types);
            StoreDeallocate(_dataHeap, _pts);
            StoreDeallocate(_dataHeap, _glyphMetrics);
        }
    }

    void _Clear()
    {
        _doDealloc = false;
        _normScale = 0.0;
        _count = 0;
        _types = NULL;
        _pts = NULL;
        _minPt.x = _minPt.y = 0;
        _maxPt.x = _maxPt.y = 0;
        _minxIndex = _minyIndex = 0;
        _maxxIndex = _maxyIndex = 0;
        _centerPt.x = _centerPt.y = 0.0;
        _glyphMetrics = NULL;
        _strLen = 0;
    }
    
    bool _doDealloc;
    Real _normScale;
    int _count;
    BYTE *_types;
    DXFPOINT *_pts;
    POINT _minPt;
    POINT _maxPt;
    ULONG _minxIndex, _minyIndex;
    ULONG _maxxIndex, _maxyIndex;
    Point2Value _centerPt;

    typedef struct {
        GLYPHMETRICS gm;
        Real  gmBlackBoxX; 
        Real  gmBlackBoxY;
        Real  gmptGlyphOriginX;
        Real  gmptGlyphOriginY;
        Real  gmCellIncX; 
        Real  gmCellIncY;
    } DAGLYPHMETRICS;

    // these two are related.  if _glyphMetrics is null, don't expect
    // _strLen to be viable.
    int  _strLen;
    DAGLYPHMETRICS *_glyphMetrics;

    DynamicHeap    &_dataHeap;
};

class TextCtx;
class TextPtsCacheEntry;

#define TEXTPTSCACHESIZE 25

/*****************************************************************************
This class pushes target surfaces associated with a given viewport, and pops
the surfaces on destruction.
*****************************************************************************/

class TargetSurfacePusher
{
  public:

    TargetSurfacePusher (CompositingStack &cs)
        : _stack(cs), _pushCount(0) {}

    ~TargetSurfacePusher (void)
    {   while (_pushCount--) _stack.PopTargetSurface();
    }

    void Push (DDSurface *surface)
    {   _stack.PushTargetSurface (surface);
        ++ _pushCount;
    }

  private:
    CompositingStack   &_stack;
    unsigned int        _pushCount;
};

////////////////////////////////////////////////////////////
//
// class:  D I R E C T   D R A W   I M A G E   D E V I C E
//
////////////////////////////////////////////////////////////
// Note: this class is implemented for SINGLE threaded use

// class MovieImagePerf;

class DirectDrawImageDevice : public ImageDisplayDev {
    friend class DirectDrawViewport;
    friend class GeomRenderer;
    friend class OverlayedImage;
    friend class PluginDecoderImageClass;
    friend class ApplyDXTransformImage;
    friend class ApplyDXTransformBvrImpl;
    friend class ApplyDXTransformGeometry;

  public:

    DirectDrawImageDevice(DirectDrawViewport &viewport);
    virtual ~DirectDrawImageDevice();

    void InitializeDevice();
    
    // Beginning and ending of rendering an image often mean
    // operations
    void BeginRendering(Image *img, Real opacity);
    void EndRendering(DirtyRectState &d);

    // Cleanup common to top level and intermediate image devices. 
    void CleanupIntermediateRenderer();

    //
    // Sets targetstack, surfacepool and surfacemap
    // from which the device gets surfaces for compositing
    // and associates surfaces with images.
    //
    void SetSurfaceSources(CompositingStack *cs,
                           SurfacePool *sp,
                           SurfaceMap *sm)
    {
        SetCompositingStack(cs);
        SetSurfacePool(sp);
        SetSurfaceMap(sm);
    }

    void SetOffset(POINT pixOffsetPt);
    POINT GetOffset() { return _pixOffsetPt; };
    void UnsetOffset();
    bool ShouldDoOffset(DDSurface *surf)
    {
        return  _doOffset && (surf ==_viewport._externalTargetDDSurface);
    }
    
    bool IsCompositeDirectly()  {   return _viewport.IsCompositeDirectly();  }
    
    // If _doOffset is set (by the viewport) and
    // our target surface is the _externalTargetDDSurface then
    // we need to offset the rectangle by the given pixel offset
    //
    void DoCompositeOffset(DDSurface *surf, RECT *rect) {
        if(ShouldDoOffset(surf)) {
            Assert(IsCompositeDirectly());
            OffsetRect(rect, _pixOffsetPt.x, _pixOffsetPt.y);
        }
    }

    // same as above, exept for HRGN
    void DoCompositeOffset(DDSurface *surf, HRGN rgn) {
        if(ShouldDoOffset(surf)) {
            Assert(IsCompositeDirectly());
            OffsetRgn(rgn, _pixOffsetPt.x, _pixOffsetPt.y);
        }
    }

    // same as above, exept for BBox2
    const Bbox2 DoCompositeOffset(DDSurface *surf, const Bbox2 &box2) {
        if(ShouldDoOffset(surf)) {
            Assert(IsCompositeDirectly());
            return(TransformBbox2(_offsetXf, box2));
        }
        return(box2);
    }

    //
    // If _doOffset is set (by the viewport) and
    // our target surface is the _externalTargetDDSurface then
    // we need to add a translation (_tx,_ty) to the given transform
    //
    Transform2 *DoCompositeOffset(DDSurface *surf, Transform2 *origXf) {
        if(ShouldDoOffset(surf)) {
            Assert(_viewport._targetPackage._composeToTarget);
            Assert( _offsetXf );
            origXf = TimesTransform2Transform2( _offsetXf, origXf);
        }
        return origXf;
    }

    // sets an offset in DAGDI
    void DoCompositeOffset(DDSurface *surf, DAGDI &myGDI);

    //
    // Sets the target rendering information.
    // See imgdev.h for struct.
    //
    bool SetTargetPackage(targetPackage_t *targetPackage) {
        return _viewport.SetTargetPackage(targetPackage);
    }

    void ComposeToIDDSurf(DDSurface *destDDSurf,
                          DDSurface *srcDDSurf,
                          RECT destRect,
                          RECT srcRect,
                          RECT destClipRect);
    
    void ComposeToHDC(GDISurface *destGDISurf,
                      DDSurface *srcDDSurf,
                      RECT *destRect,
                      RECT *srcRect);

    TextPoints *GetTextPointsCache(TextCtx *ctx, WideString str);
    void SetTextPointsCache(TextCtx *ctx, WideString str, TextPoints *txtPts);
    
    Image *CanCacheImage(Image *image,
                         Image **pImageCacheBase,
                         const CacheParam &p);
    
    Bool   CanDisplay() {
        return _deviceInitialized && _viewport.CanDisplay();
    }
    Bool   IsInitialized() { return _deviceInitialized; }

    DirectDrawViewport *GetViewport() { return &_viewport; }
    
    //
    // 2d Primitives
    //
    HDC GetDCForMatteCallBack(Image *image, DDSurface *srcDDSurf, DDSurface *destDDSurf);
    void RenderMatteImage(MatteImage *matteImage,
                          Matte *matte,
                          Image *srcImage);

    // not public
  private:
    void _RenderMatteImageAAClip(DAGDI &myGDI,
                                 RECT &clipRect,
                                 HDC destDC,
                                 DDSurface *destDDSurf,
                                 RECT &destRect,
                                 DDSurface *srcDDSurf,
                                 RECT &srcRect,
                                 bool &releasedDC,
                                 const POINT &offsetPt);

  public:

    void TransformPointsToGDISpace(Transform2   *xform,
                                   Point2Value **srcPts,
                                   POINT        *gdiPts,
                                   int           numPts);

    void TransformPointsToGDISpace(Transform2 *xform,
                                   Point2     *srcPts,
                                   POINT      *gdiPts,
                                   int         numPts);

    // Scales the given pixel width
    void _ScalePenWidth( Transform2 *xf, Real inWidth,
                         Real *outRealW );
    
    // renders a line by dispatching to the other renderLine
    // after doing some thinking about attribs
    void RenderLine(Path2 *path,
                    LineStyle *style);

    // does the hard work, dispatched from RenderLine(a,b,c) above.
    void RenderLine(Path2 *path, 
                    LineStyle *style, 
                    DDSurface *finalTargetDDSurf,
                    DDSurface *opacDDSurf);

    bool DetectHitOnBezier( Path2 *bzp,
                            PointIntersectCtx& ctx,
                            LineStyle *style );
                    

    //
    // Dispatches the render call to the image with
    // a pointer to the device.
    //
    void RenderImage(Image *img);

    void RenderDiscreteImage(DiscreteImage *);
    void RenderDiscreteImageComplex(DiscreteImage *image,
                                    DDSurface *srcDDSurf,
                                    DDSurface *destDDSurf);

    struct {
        IDDrawSurface *_surf32;
        LONG _width, _height;
    } _scratchSurf32Struct;
    bool _resetDefaultColorKey;

    void RenderDirectDrawSurfaceImage(DirectDrawSurfaceImage *ddsimg);

    void RenderSolidColorImage(SolidColorImageClass& img);
    HRESULT RenderSolidColorMSHTML(DDSurface *ddSurf,SolidColorImageClass& img, RECT *destRect);
    void RenderProjectedGeomImage(
        ProjectedGeomImage *img,
        Geometry *geo,
        Camera *cam);
    void RenderMovieImage(MovieImage     *movieImage, 
                          Real            time,
                          MovieImagePerf *perf, 
                          bool            forceFallback,
                          DDSurface      *forceDDSurf = NULL);
    void RenderGradientImage(GradientImage *img,
                             int numPts,
                             Point2Value **pts,
                             Color **clrs);
    void RenderMulticolorGradientImage(
        MulticolorGradientImage *gradImg,
        int numOffsets,
        double offsets[],
        Color **clrs);
    void RenderColorKeyedImage(ColorKeyedImage *);

    // -- End: image value rendering calls.

    

    void SmartRender(Image *image, int attrib);
    void RenderComplexTransformCrop(DDSurface *srcDDSurf,
                                    DDSurface *destDDSurf,
                                    BoundingPolygon &destPolygon,
                                    DiscreteImage *image=NULL);

    void RenderSimpleTransformCrop(DDSurface *srcDDSurf,
                                   DDSurface *destDDSurf,
                                   bool useSrcSurfClrKey = true);
        
    void Render3DPolygon(DDSurface *srcDDSurf,
                         DDSurface *destDDSurf,
                         BoundingPolygon *destPolygon,
                         DiscreteImage *image,
                         Color **clrs,
                         bool bUseFirstColor);

    //
    // Utility functions for Images to get information
    //
    DDSurface *LookupSurfaceFromDiscreteImage(DiscreteImage *image,
                                              bool bForCaching = false,
                                              Image **pImageKeyToUse = NULL,
                                              bool bAlphaSurface = false);

    // Given an hdc, font and str, it returns all the
    // points, the types array, number of points,
    // the hiight of the text, the center (Real),
    // the min and max pts (int bbox basically).
    void GetTextPoints(
        HDC hDC,
        HFONT font,
        WideString str,  
        POINT **points,   // out
        TextPoints& txtPts,
        UINT bUnderline,
        UINT bStrikeout,
        bool doGlyphMetrics
        );

    // Render a string using according to the current text context.
    void RenderText(TextCtx& textCtx,
                    WideString str,
                    Image *textImg);



    //////////////////// DYNAMIC TEXT ////////////////////

    // Get text bbox
    virtual const Bbox2 DeriveDynamicTextBbox(TextCtx& textCtx, WideString str, bool bCharBox);    

    // Renders a string on a dc or on an image
    // and overrides the transform if there is one.
    // Calls to render normal text string or render individual
    // characters depending on textCtx <the helper methods are below>
    void RenderDynamicTextOrCharacter(
        TextCtx& textCtx, 
        WideString str, 
        Image *textImg,
        Transform2 *overridingXf,
        textRenderStyle textStyle,
        RenderStringTargetCtx *targetCtx,
        DAGDI &myGDI);

  private:
    // these two are internal helpers

    // Renders DynamicText strings 
    void _RenderDynamicText(TextCtx& textCtx, 
                           WideString str, 
                           Image *textImg,
                           Transform2 *overridingXf,
                           textRenderStyle textStyle,
                           RenderStringTargetCtx *targetCtx,
                           DAGDI &myGDI);
    
    // Renders DynamicText strings, but allows for individually
    // transformed characters within that string
    void _RenderDynamicTextCharacter(TextCtx& textCtx, 
                                    WideString str, 
                                    Image *textImg,
                                    Transform2 *overridingXf,
                                    textRenderStyle textStyle,
                                    RenderStringTargetCtx *targetCtx,
                                    DAGDI &myGDI);
  public:

    
    void RenderDynamicTextOnDC(TextCtx& textCtx,
                               WideString str,
                               HDC dc,
                               Transform2 *xform) {
        RenderStringTargetCtx ctx(dc);
        RenderDynamicTextOrCharacter(textCtx,
                                     str,
                                     NULL,
                                     xform,
                                     textRenderStyle_invalid,
                                     &ctx,
                                     *GetDaGdi());
    }

    // helper should be used for caching
    void GenerateTextPoints(
        // IN
        TextCtx& textCtx, 
        WideString str, 
        DDSurface *targDDSurf,
        HDC optionalDC,
        bool doGlyphMetrics,
        
        // OUT
        TextPoints& txtPts);
    
    //////////////////// STATIC TEXT ////////////////////

    // Clients of RenderStaticTextOnDC must do there own cropping
    // wince it no longer does it.
    void RenderStaticTextOnDC(TextCtx& textCtx,
                              WideString str,
                              HDC dc,
                              Transform2 *xform);

    void RenderStaticText(TextCtx& textCtx, 
                          WideString str, 
                          Image *textImg,
                          DDSurface *targDDSurf,
                          DAGDI &myGDI);
    
    virtual const Bbox2 DeriveStaticTextBbox(TextCtx& textCtx, WideString str);


    
    // Renders tiled image using tileSrcImage
    // see imgdev.h for more detail.
    void RenderTiledImage(
        const Point2 &min,
        const Point2 &max,
        Image *tileSrcImage);

    // Renders the given image, from the given region,
    // to a surface, in the returned outRect.
    DDSurface *RenderImageForTexture(
        Image * image,
        int pixelsWide,
        int pixelsHigh,
        DWORD *colorKey,
        bool *clrKeyIsValid,
        bool &old_static_image,
        bool doFitToDimensions,
        SurfacePool *srcPool,
        SurfacePool *dstPool,
        DDSurface   *preferredSurf,
        bool        *pChosenSurfFromPool,    // out
        DDSurface  **pDropSurfHereWithRefCount, // out
        bool         upsideDown         
        );


    int GetWidth() { return _viewport.Width(); }
    int GetHeight() { return _viewport.Height(); }

    // Return resolution, in pixels per meter.
    Real GetResolution() { return _viewport.GetResolution(); }

    inline DirectDrawViewport* Viewport() { return &_viewport; }

    Transform2 *GetOffsetTransform() { return _offsetXf; };

    void WindowResizeEvent(int width, int height){
        _viewport.WindowResizeEvent(width, height); }

    // -- GDI Specific
    // XXX both of these should disappear soon unless they're useful for the new 2d prims
    HRGN CreateRegion(int numPts, Point2Value **pts, Transform2 *xform);
    void CreateRegion(HDC dc, int numPts, Point2Value **pts, Transform2 *xform);

    Bool DetectHit(HRGN region, Point2Value *pt);

    // -- used by GeomRenderer --

    void BeginEnumTextureFormats();
    void EndEnumTextureFormats();
    void EnumTextureFormats(LPDDSURFACEDESC desc);

    void RenderImageOnDDSurface(Image *image,
                                DDSurface *ddSurf,
                                Real opacity=1.0,
                                Bool pushClipper = TRUE,
                                bool inheritContext = false,
                                DirectDrawImageDevice **usedDev = NULL);

#if _USE_PRINT
    ostream& Print(ostream& os) const {
        return os << "(DirectDraw Device)";
    }

#endif
    HDC RenderGetDC(char *errStr) {
        return _compositingStack->TargetDDSurface()->GetDC(errStr);
    }

    void RenderReleaseDC(char *errStr) {
        _compositingStack->TargetDDSurface()->ReleaseDC(errStr);
    }

    /* returns true if any dimension of the matrix is being
       scaled by x or more */

    Bool IsScale(double x) {
        Real m[6];
        _xform->GetMatrix(m);
        return (fabs(m[0]) >= x  || fabs(m[1]) >= x ||
                fabs(m[3]) >= x || fabs(m[4]) >= x);
    }
    
    void DestroyTextureSurfaces (void);

    void DoDestRectScale(
        RECT *destRect,
        Real destRes,
        const Bbox2 &box,
        DDSurface *destSurf=NULL);

    DAGDI *GetDaGdi() { return _daGdi; }

  protected:
    DDSurface *NewSurfaceHelper();
    
  private:

    DAGDI *_daGdi;

    // Helper function
    Transform2 *CenterAndScaleRegion( const Bbox2 &regionBox, DWORD pixelW, DWORD pixelH );
    
    void SmartDestRect(RECT *destRect,
                       Real destRes,
                       const Bbox2 &box,
                       DDSurface *destSurf,
                       RECT *srcRect=NULL);
        

    Bool DoSrcRect(
        RECT *srcRect,
        const Bbox2 &box,
        Real srcRes,
        LONG srcWidth,
        LONG srcHeight);

    const Bbox2 DoBoundingBox(const Bbox2 &firstBox, DoBboxFlags_t flags = do_all);
    void DoBoundingPolygon(BoundingPolygon &polygon,
                           bool doInclusiveCrop = false,
                           DoBboxFlags_t flags = do_all);

    //----------------------------------------
    // Texture Management
    //----------------------------------------
    void PrepareD3DTextureSurface(
        LPDDRAWSURFACE *surf,
        RECT *rect,
        DDPIXELFORMAT &pf,
        DDSURFACEDESC *desc=NULL,
        bool attachClipper=true);

    // Return new texture surface, addref'd
    void GetTextureDDSurface(DDSurface *preferredSurf,
                             SurfacePool *srcPool,
                             SurfacePool *destPool,
                             DWORD prefWidth,
                             DWORD prefHeight,
                             vidmem_enum vid,
                             bool usePreferedDimensions,
                             DDSurface **pResult);
                                   

    void       ReturnTextureSurfaces(SurfacePool *toPool,
                                     SurfacePool *fromPool);

    // Reformats the src surface to be of the same format as the destination surface.
    // destSurf will be srcSurf with the new format (i.e.: different bit depth)
    Bool ReformatSurface(
        LPDDRAWSURFACE destSurf, LONG destWidth, LONG destHeight,
        LPDDRAWSURFACE srcSurf, LONG srcWidth, LONG srcHeight,
        DDSURFACEDESC *srcDesc);

    void ColorKeyBlit(destPkg_t *destPkg,
                      RECT *srcRect,
                      LPDDRAWSURFACE srcSurf, 
                      DWORD clrKey,
                      RECT *clipRect,
                      RECT *destRect);

    void Get32Surf(IDDrawSurface **surf32,
                   LONG width, LONG height);
                   
    
    //
    // Does alpha blitting from the srcSurface to the destination surface
    // within the given rectangle and the of the give opacity
    // .. the dest rectangle can be offset by xOffset,y...
    //
    void AlphaBlit(destPkg_t *destPkg,
                   RECT *srcRect,
                   LPDDRAWSURFACE srcSurf,
                   Real opacity,
                   Bool doClrKey,
                   DWORD clrKey,
                   RECT *clipRect=NULL,
                   RECT *destRect=NULL);


    //
    // Does alpha blitting using the 'src' word and the destination surface
    // within the given rectangle and the of the give opacity
    //
    void AlphaBlit(LPDDRAWSURFACE destSurf,
                   RECT *rect,
                   Real opacity,
                   DWORD src);

    //
    // Does alpha blending given the two pixels & two opacities
    //
    inline WORD BlendWORD(WORD dest, int destOpac, WORD src, int opac,
                          DWORD redShift, DWORD greenShift, DWORD blueShift,
                          WORD redMask, WORD greenMask, WORD blueMask,
                          WORD redBlueMask);


    //
    // Does alpha blending given the two pixels & two opacities
    //
    inline DWORD BlendDWORD(DWORD dest, int destOpac, DWORD src, int opac,
                            DWORD redShift, DWORD greenShift, DWORD blueShift,
                            DWORD redMask, DWORD greenMask, DWORD blueMask,
                            DWORD redBlueMask);

    //
    // Alpha blend a premultiplied word
    //
    inline WORD BlendPremulWORD(WORD dest, int destOpac, WORD src,
                                DWORD redShift, DWORD greenShift, DWORD blueShift,
                                WORD redMask, WORD greenMask, WORD blueMask,
                                WORD redBlueMask);

    //
    // Alpha blend a premultiplied double word
    //
    inline DWORD BlendPremulDWORD(DWORD dest, int destOpac, DWORD src,
                                  DWORD redShift, DWORD greenShift, DWORD blueShift,
                                  DWORD redMask, DWORD greenMask, DWORD blueMask,
                                  DWORD redBlueMask);

    #if 0
    //
    // Final alpha composite utils
    //
    Real GetFinalOpacity() { return _finalOpacity; }
    void SetFinalOpacity(Real op) { _finalOpacity = op; }
    Real _finalOpacity;
    #endif
    
    // Decomposes matrix into its components.  NULL args signify
    // disinterest in that part of the matrix.
    // FUTURE: add rotation angle, translation, & shears.
    // Note: scale, shear, rotate must be performed in a certain order
    void     DecomposeMatrix(Transform2 *xform, Real *xScale, Real *yScale, Real *rot);

    Bool IsComplexTransform() {
        Real m[6];
        _xform->GetMatrix(m);
        return (m[1] != 0  ||  m[3] !=0);
    }
    Bool IsFlipTranslateTransform() {
        Real m[6];
        _xform->GetMatrix(m);
        return (m[1] == 0  &&  m[3] == 0) &&
            fabs(m[0])==1 && fabs(m[4])==1;
    }
    bool IsNegScaleTransform() {
        Real m[6];
        GetTransform()->GetMatrix(m);
        return (m[0] < 0) || (m[4] < 0);
    }

    typedef struct {
        Bool isEnumerating;
        Bool descIsSet;
        Bool sizeIsSet;
        Bool useDeviceFormat;
        Bool isValid;
        DDSURFACEDESC ddsd;
    } _textureContext_t;

    _textureContext_t  _textureContext;

    // Scratch texture surfaces that aren't associated
    // with any specific image, but are needed for holding
    // images. recycled every frame.  per image device
    // (that's why they're not in viewport.cpp
    SurfaceManager *_textureSurfaceManager;
    SurfacePool *_usedTextureSurfacePool;
    SurfacePool *_intraFrameUsedTextureSurfacePool;
    SurfacePool *_freeTextureSurfacePool;

    SurfacePool *_surfacePool;
    SurfaceMap  *_surfaceMap;
    SurfaceMap  *_intraFrameTextureSurfaceMap;
    SurfaceMap  *_intraFrameUpsideDownTextureSurfaceMap;
    
    CompositingStack *_compositingStack;

    inline SurfacePool *GetSurfacePool() { return _surfacePool; }
    inline SurfaceMap  *GetSurfaceMap() { return _surfaceMap; }
    inline CompositingStack *GetCompositingStack() { return _compositingStack; }

    void SetSurfacePool(SurfacePool *sp) { _surfacePool = sp; }
    void SetSurfaceMap(SurfaceMap *sm) {  _surfaceMap = sm; }
    void SetCompositingStack(CompositingStack *cs) {  _compositingStack = cs; }

    //
    // This pointer is set to a texture surface when
    // some leaf's rendering can handle complex
    // transforms and does so to a texture capable surface
    //
    DDSurface *_currentScratchDDTexture;

    //
    // These members hold texture info for the intermediate
    // texture surface.  This surface will be color converted
    // blit to a surface conforming to one of D3D's prefered
    // texture formats.  Note that this surface may never be
    // used if the device format is identical to the required
    // texture format.
    //
    LPDIRECTDRAWCLIPPER _textureClipper;        // Clipper on texture surface
    DDSurface          *_textureDDZBuffer;        // Zbuffer for rendering geom on txtr

    LONG _textureWidth,    _textureHeight;
    RECT _textureRect;

    LPDIRECTDRAWCLIPPER _tileClipper;           // Clipper that tileImage uses

    // Temp font holder
    LOGFONTW      _logicalFont;

    // scratch pen
    HPEN         _pen;
    
    DirectDrawViewport &_viewport;
    Bool                _deviceInitialized;
    
    //
    // Memory management
    //
    void *AllocateFromMyStore(size_t size)
    { return StoreAllocate(*_scratchHeap, size); }

    DynamicHeap * _scratchHeap;

    HRESULT  _ddrval;
    DDBLTFX _bltFx;
    unsigned int _randSeed;

    TextPtsCacheEntry *_textPtsCache[TEXTPTSCACHESIZE];
    int _textPtsCacheIndex;

    // global offset for images.  motivated by compositeDirectlyToTarget
    Real _tx;   Real _ty;
    Transform2 *_offsetXf;
    bool _doOffset;
    POINT _pixOffsetPt;

    // Antialiasing related member vars
    bool _renderForAntiAliasing;

    bool _alreadyDisabledDirtyRects;
};


// --------------------------------------------------
// Local helper classes
// --------------------------------------------------

// This class knows how to release a DC.
// Used when grabbing a DC.
// Guaranteed to release the DC exactly ONCE.
// Can be forced to release

class DCReleaser {

  public:
    DCReleaser(DDSurface *dds, char *str)
    : _surf(dds),
      _str(str)
    {
        Assert(_str);
    }
    
    ~DCReleaser() {   Release();  }

    void Release() {
        if(_surf) {
            _surf->ReleaseDC(_str);
            _surf = NULL;
        }
    }

    DDSurface *_surf;
    char *_str;
};


// This class knows how to release a GDI object.
class GDI_Deleter {

  public:
    GDI_Deleter(HGDIOBJ hobj) : _hobj(hobj) {}

    ~GDI_Deleter() {
        DeleteObject(_hobj);
    }

  protected:
    HGDIOBJ _hobj;
};


// This class knows how to release a GDI object.
class ObjectSelector {

  public:
    ObjectSelector(HDC dc, HGDIOBJ newObj) :
    _newObj(newObj), _dc(dc) {
        Assert(_dc && "NULL dc in ObjectSelector");
        Assert(_newObj && "NULL newObj in ObjectSelector");
        TIME_GDI( _oldObj = (HGDIOBJ)SelectObject(_dc, _newObj) );
    }

    ~ObjectSelector() { Release(); }

    void Release() {
        if(_oldObj) {
            HGDIOBJ f;
            TIME_GDI( f = (HGDIOBJ)SelectObject(_dc, _oldObj) );
            Assert(f == _newObj && "bad scoping of ObjectSelector");
            TIME_GDI( DeleteObject(_newObj) );
            _oldObj = NULL;
        }
    }
        
    bool Success() { return _oldObj != NULL; }

  protected:
    HGDIOBJ _newObj;
    HGDIOBJ _oldObj;
    HDC _dc;
};


// This class knows how to reset a heap
class HeapReseter {

  public:
    HeapReseter(DynamicHeap &heap) : _heap(heap) {}

    ~HeapReseter() {
        //printf("reseting imgdev heap!\n"); fflush(stdout);
        ResetDynamicHeap(_heap);
    }

  protected:
    DynamicHeap &_heap;
};



class CompositingSurfaceReturner {
  public:
    CompositingSurfaceReturner(CompositingStack *cs,
                               DDSurface *ddSurf,
                               bool ownRef)
    {
        _stack = cs;
        _ddSurf = ddSurf;
        _ownRef = ownRef;
    }
    ~CompositingSurfaceReturner() {
        if(_ownRef && _ddSurf) {
            _stack->ReturnSurfaceToFreePool(_ddSurf);
            RELEASE_DDSURF(_ddSurf, "~CompositingSurfaceReturner", this);
        }
    }
    CompositingStack *_stack;
    DDSurface *_ddSurf;
    bool _ownRef;
};


//---------------------------------------------------------
// Local helper functions
//---------------------------------------------------------
static LONG CeilingPowerOf2(LONG num);
Real Pix2Real(LONG pixel, Real res);
Real Round(Real x);
extern LONG Real2Pix(Real imgCoord, Real res);

void ComputeLeftRightProj(Transform2 *charXf,
                          TextPoints::DAGLYPHMETRICS &daGm,
                          Real *leftProj,
                          Real *rightProj);

// Global Variables

extern bool g_preference_UseVideoMemory;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\dmusic.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\ddsurf.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _DDSURF_H
#define _DDSURF_H

#include "ddraw.h"

#include "privinc/ddutil.h"
#include "privinc/bbox2i.h"
#include "privinc/error.h"
#include "privinc/ddrender.h"
#include "privinc/debug.h"
#include "privinc/imgdev.h"
#include "privinc/comutil.h"


// forward decls
class GeomRenderer;
enum targetEnum;
class SurfacePool;

// Given a DDSurface, returns an IDXSurface
HRESULT CreateFromDDSurface(
    IDXSurfaceFactory *sf,
    DDSurface *dds,
    const GUID *pFormatID,
    IDXSurface **outDXSurf );

#if _DEBUG
#define NEWDDSURF(outdds, surf, box, rect, res, clrk1, clrk2, a, b, str) \
DDSurface::CreateSurface(outdds, surf, box, rect, res, clrk1, clrk2, a, b, str);
#else
#define NEWDDSURF(outdds, surf, box, rect, res, clrk1, clrk2, a, b, str) \
DDSurface::CreateSurface(outdds, surf, box, rect, res, clrk1, clrk2, a, b);
#endif



#if _DEBUG

#define ADDREF_DDSURF(ddsurf, reason, clientPtr) \
        (ddsurf)->AddRef((ddsurf), reason, clientPtr, __FILE__, __LINE__);

#define RELEASE_DDSURF(ddsurf, reason, clientPtr) \
        (ddsurf)->Release((ddsurf), reason, clientPtr, __FILE__, __LINE__);

#else

#define ADDREF_DDSURF(ddsurf, reason, clientPtr) \
        (ddsurf)->AddRef((ddsurf));

#define RELEASE_DDSURF(ddsurf, reason, clientPtr) \
        (ddsurf)->Release((ddsurf));

#endif


#if _DEBUG
#define INIT {_reason="<>"; _client=NULL;}
#else
#define INIT
#endif

template <class T>
class DDSurfPtr
{
  public:
    typedef T _PtrClass;
    DDSurfPtr() { p = NULL; INIT }
    DDSurfPtr(T* lp)
    {
        INIT
        p = lp;
        if (p != NULL) {
            #if _DEBUG
            ADDREF_DDSURF(p, _reason, _client);
            #else
            ADDREF_DDSURF(p, NULL, NULL);
            #endif
        }
    }
    // for DDSurface auto addref/release tracking...
    #if _DEBUG
    DDSurfPtr(T* lp, char *reason, void *client)
    {
        _reason = reason;
        _client = client;

        p = lp;
        if (p != NULL) {
            ADDREF_DDSURF(p, _reason, _client);
        }
    }
    DDSurfPtr(char *reason, void *client)
    {
        _reason = reason;
        _client = client;
        p = NULL;
    }
    #endif

    ~DDSurfPtr() {
        if (p) {
            RELEASE_DDSURF(p, _reason, _client);
        }
    }
    void Release() {
        if (p) {
            RELEASE_DDSURF(p, _reason, _client);
        }
        p = NULL;
    }

    operator T*() { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the p member explicitly.
    T** operator&() { Assert(p == NULL); return &p; }
    T* operator->() { Assert(p != NULL); return p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const DDSurfPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;

    #if _DEBUG
    char *_reason;
    void *_client;
    #endif
  protected:
    T* Assign(T* lp) {
        if (lp != NULL) {
            ADDREF_DDSURF(lp, _reason, _client);
        }
        if (p) {
            RELEASE_DDSURF(p, _reason, _client);
        }

        p = lp;

        return lp;
    }
};

#if _DEBUG
#define DEBUG_ARG1(x)   ,x
#define DEBUG_ARG4(a, b, c, d)   ,a,b,c,d
#else
#define DEBUG_ARG1(x)
#define DEBUG_ARG4(a, b, c, d)
#endif

class GenericSurface : public AxAThrowingAllocatorClass {
  public:
    GenericSurface();

    virtual ~GenericSurface() {}

    inline static void AddRef(GenericSurface *ddsurf
                              DEBUG_ARG4(char *reason,
                                         void *clientPtr,
                                         char *file,
                                         int   line))
    {
        ddsurf->_ref++;

        // print out loads of info if needed...
        TraceTag((tagDDSurfaceRef,
                  "+++surf(%x, new ref:%d): purpose:%s context:%s  by: %x in %s, line %d",
                  ddsurf, ddsurf->_ref, ddsurf->_explanation, reason, clientPtr, file, line));
    }

    inline static void Release(GenericSurface *ddsurf
                               DEBUG_ARG4(char *reason,
                                          void *clientPtr,
                                          char *file,
                                          int   line))
    {
        // print out loads of info if needed...
        TraceTag((tagDDSurfaceRef,
                  "---surf(%x, new ref:%d) purpose:%s context: %s  by: %x in %s, line %d",
                  ddsurf, ddsurf->_ref-1, ddsurf->_explanation, reason, clientPtr, file, line));

        Assert(ddsurf->_ref > 0);
        if( --(ddsurf->_ref) == 0) {
            delete ddsurf;
        }
    }

    #if _DEBUG
    char         *_explanation;
    #endif

    inline int GetRef() { return _ref; }

    enum surfaceTypeEnum {
        invalidSurface,
        gdiSurface,
        ddrawSurface
    };

    virtual void SetSurfacePtr(void *surface) = 0;
    virtual void *GetSurfacePtr() = 0;
    virtual HDC GetDC(char *errStr) = 0;
    virtual void ReleaseDC(char *errStr) = 0;

    virtual RECT *GetSurfRect(void) = 0;

    #if DEVELOPER_DEBUG
    bool debugonly_IsDdrawSurf() { return _surfaceType == ddrawSurface; }
    #endif

  protected:

    surfaceTypeEnum _surfaceType;

    virtual void SetSurfaceType(surfaceTypeEnum type) {
        _surfaceType = type;
    }

    int _ref;
};

class GDISurface : public GenericSurface {
  public:

    GDISurface(HDC target) {
        SetSurfacePtr((void *)target);
        SetSurfaceType(GenericSurface::gdiSurface);
    }

    void SetSurfacePtr(void *surface) {
        _targetDC = (HDC)surface;
    }
    void *GetSurfacePtr() { return (void *)_targetDC; }

    HDC GetDC(char *) {

        Assert(_targetDC);
        return _targetDC;
    }

    void ReleaseDC(char *errStr) {}

    RECT *GetSurfRect(void);

  private:
    HDC _targetDC;
    RECT _surfRect;
};


struct DDSurface : public GenericSurface {

    friend class SurfacePool;

    enum scratchStateEnum {
        scratch_Invalid,
        scratch_Dest,
        scratch_Src
    };

    //
    // Static member that instantiates a DDSurface class
    //
    inline static void CreateSurface(DDSurface **outDDSurf,
                                     IDDrawSurface *surface,
                                     const Bbox2 &box,
                                     RECT *rect,
                                     Real res,
                                     DWORD colorKey,
                                     bool colorKeyIsValid,
                                     bool isWrapper,
                                     bool isTexture
                                     DEBUG_ARG1( char *explanation ))
    {
        Assert(outDDSurf);
        *outDDSurf = NEW DDSurface(surface, box, rect, res,
                                   colorKey, colorKeyIsValid,
                                   isWrapper, isTexture
                                   DEBUG_ARG1(explanation));
    }



    DDSurface(IDDrawSurface *surface,
              const Bbox2 &box,
              RECT *rect,
              Real res,
              DWORD colorKey,
              bool colorKeyIsValid,
              bool isWrapper,
              bool isTexture
              DEBUG_ARG1( char *explanation ));

    virtual ~DDSurface();

    // Blits using the underlying direct draw surface.  raw blit
    HRESULT Blt (RECT *destRect,
                 IDDrawSurface *rawSrcSurf,
                 RECT *srcRect,
                 DWORD dwFlags,
                       DDBLTFX *bltFx)
    {
        if( IsScratchSurface() ) {
            SetScratchState( scratch_Dest );
        }
        HRESULT result =
            IDDSurface()->Blt(destRect, rawSrcSurf, srcRect, dwFlags, bltFx);

        if( result == DDERR_SURFACEBUSY ) {
            RaiseException_UserError
                (DAERR_VIEW_SURFACE_BUSY, IDS_ERR_IMG_SURFACE_BUSY);
        }

        return result;
    }

    // blitter in terms of DDSurface.  uses raw Blt(....) above
    inline HRESULT Blt(RECT *destRect,
                       DDSurface *srcDDSurf,
                       RECT *srcRect,
                       DWORD dwFlags,
                       DDBLTFX *bltFx)
    {

        Assert(srcDDSurf);

        if( srcDDSurf->IsScratchSurface() ) {
            srcDDSurf->SetScratchState( scratch_Src );
        }
        return this->Blt(destRect, srcDDSurf->IDDSurface(), srcRect, dwFlags, bltFx);
    }

    HRESULT MirrorUpDown(void);

    // color fill blitter.  in terms of raw Blt(...) above
    inline HRESULT ColorFillBlt(RECT *destRect,
                                DWORD dwFlags,
                                DDBLTFX *bltFx)
    {
        return this->Blt(destRect, (IDDrawSurface*)NULL, NULL, dwFlags, bltFx);
    }

    inline void _ReleaseDerivativeSurfaces() {
        _ddsurf_iunk.Release();
        _IDXSurface.Release();
    }

    inline void SetSurfacePtr(void *surface) {
        // implicit addref
        _capsReady = false;
        _ddsurf = (IDDrawSurface *)surface;
        _ReleaseDerivativeSurfaces();
        _UpdateSurfCaps();
    }
    inline void *GetSurfacePtr() {  return (void *)IDDSurface();  }

    LPDDRAWSURFACE IDDSurface_IUnk() {
        if( !_ddsurf_iunk ) {
            _ddrval = IDDSurface()->QueryInterface(IID_IUnknown, (void **) &_ddsurf_iunk);
            Assert(_ddrval == S_OK && "QI for IUnknown failed in ddsurf");
        }
        return _ddsurf_iunk;
    }

    inline LPDDRAWSURFACE IDDSurface() {

        Assert( debugonly_IsDdrawSurf() );

        return _ddsurf;
    }

    IDXSurface *GetIDXSurface(IDXSurfaceFactory *sf)
    {
        Assert(sf);
        _MakeSureIDXSurface(sf);
        return _IDXSurface;
    }
    bool HasIDXSurface() { return _IDXSurface.p != NULL; }
    void SetIDXSurface( IDXSurface *idxs )
    {
        Assert( _IDXSurface.p == NULL );
        _IDXSurface = idxs;
    }

    inline void SetSurface(IDDrawSurface *surf) {
        _capsReady = false;
        _ddsurf = surf;
        _ReleaseDerivativeSurfaces();
        _UpdateSurfCaps();
    }
    inline LPDDRAWSURFACE ConvertedSurface() {
        return _2ndSurface;
    }
    inline void SetConvertedSurface(LPDDRAWSURFACE s) {
        _2ndSurface = s;
    }

    // NOTE: these zbuffers are shared among multiple
    // surfaces
    inline DDSurface *GetZBuffer() {  return _zbuffer;  }

    HRESULT SetZBuffer(DDSurface *zb);

    HDC GetDC(char *errStr);
    void ReleaseDC(char *errStr);
    void _hack_ReleaseDCIfYouHaveOne();

    #if _DEBUG
    bool _debugonly_IsDCReleased() {
        return (_dcRef==0 && !_dc);
    }
    #endif

    inline void SetIsTextureSurf(bool val) {
        _isTextureSurf = val;
    }
    inline bool IsTextureSurf() {  return _isTextureSurf; }

    inline void SetGeomDevice (GeomRenderer *gdev) {
        _associatedGeomDev = gdev;
    }
    inline GeomRenderer *GeomDevice() {
        return _associatedGeomDev;
    }
    void DestroyGeomDevice();

    inline RECT *GetSurfRect(void) {        return &_surfRect;   }
    inline void SetSurfRect(RECT *rect) {        CopyRect(&_surfRect, rect);    }

    inline RECT *GetInterestingSurfRect() {        return &_interestingRect;    }
    inline void SetInterestingSurfRect(RECT *rect) {

        IntersectRect(&_interestingRect, &_surfRect, rect);
        #if _DEBUG
        RECT foo;
        IntersectRect(&foo, rect, &_surfRect);
        /*
        if(! EqualRect(&foo, rect)) {
            TraceTag((tagViewportInformative,
                      "given rect lies outside surfRect"
                      "in DDSurface::SetInterestingSurfRect()"));
        }
        */
        #endif
    }
    void UnionInterestingRect(RECT *rect);
    void ClearInterestingRect() { SetRect(&_interestingRect,0,0,0,0);}

    HRGN GetClipRgn();

    inline const Bbox2& Bbox()
    {
        return _bbox;
    }

    void SetBbox(const Bbox2 &b)
    {
        _bbox = b;
    }

    void SetBbox(Real minx, Real miny, Real maxx, Real maxy) {
        _bbox.min.Set(minx, miny);
        _bbox.max.Set(maxx, maxy);
    }
    void SetBboxFromSurfaceDimensions(
        const Real res,
        const bool center);

    void UnSetColorKey();
    void SetColorKey(DWORD key);

    inline DWORD ColorKey() {

        Assert(_colorKeyIsValid && "DDSurface::ColorKey() called when key invalid");
        return _colorKey;
    }
    inline bool ColorKeyIsValid() {        return _colorKeyIsValid;    }

    inline Real Resolution() {        return _res;    }
    inline LONG Width() {        return _surfRect.right - _surfRect.left;    }
    inline LONG Height() {        return _surfRect.bottom - _surfRect.top;    }

    inline void SetTimeStamp(Real time) {        _timeStamp = time;    }
    inline Real GetTimeStamp() {        return _timeStamp;    }
    inline bool IsSystemMemory() {   return _systemMemorySurface;    }
    inline bool IsZBuffer() {        return _isZBufferSurface;    }

    inline void SetScratchState(scratchStateEnum st) {        _scratchState = st;    }
    inline scratchStateEnum GetScratchState() {        return _scratchState;    }
    inline bool IsScratchSurface() {        return _scratchState != scratch_Invalid;    }

    inline DWORD GetBitDepth() {

        Assert(_capsReady);

        Assert( ((_pixelFormat.dwFlags & DDPF_PALETTEINDEXED8) &&
                 (_pixelFormat.dwRGBBitCount == 8 )) ||
                (!(_pixelFormat.dwFlags & DDPF_PALETTEINDEXED8) &&
                 !(_pixelFormat.dwRGBBitCount == 8 )) );

        return _pixelFormat.dwRGBBitCount;
    }


    inline DDPIXELFORMAT &GetPixelFormat() {  return _pixelFormat; }

    #if _DEBUG
    void Report() {
        TraceTag((tagDDSurfaceLeak,
                  "%x: %s (ref:%d): %s memory. size=(%d,%d)",
                  this,
                  _explanation,
                  _ref,
                  IsSystemMemory() ? "system" : "video",
                  Width(), Height()));
    }

    #endif

  private:

    void _Init(
        IDDrawSurface *surface,
        const Bbox2 &box,
        RECT *rect,
        Real res,
        DWORD colorKey,
        bool colorKeyIsValid,
        bool isWrapper,
        bool isTexture);

    void _UpdateSurfCaps (void);

    void _MakeSureIDXSurface(IDXSurfaceFactory *sf);

    void SetTargetHDC(HDC dc) { _targetDC = dc; }

    int _dcRef;

    // Source (main) surface
    HDC _targetDC;
    DAComPtr<IDDrawSurface> _ddsurf;
    DAComPtr<IDDrawSurface> _ddsurf_iunk; // IUnknown intfc
    DAComPtr<IDXSurface>    _IDXSurface;

    // Converted (2ndary) surface
    DAComPtr<IDDrawSurface> _2ndSurface;

    // ZBuffer surface
    DDSurfPtr<DDSurface> _zbuffer;

    HDC _dc;  // current dc
    HRESULT _ddrval;
    bool _isWrapper;
    GeomRenderer *_associatedGeomDev;

    bool _isTextureSurf;
    Bbox2 _bbox;
    RECT _surfRect;
    RECT _interestingRect;
    Real _res;
    DWORD _colorKey;
    bool _colorKeyIsValid;
    bool _systemMemorySurface;
    bool _isZBufferSurface;
    Real _timeStamp;
    scratchStateEnum _scratchState;

    DDPIXELFORMAT _pixelFormat;

    bool _capsReady;
};

#endif /* _DDSURF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\ddutil.h ===
#pragma once
#ifndef _DDUTIL_H
#define _DDUTIL_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    DirectDraw utility routines and functions.
*******************************************************************************/

//
// These typedef abstracts away the current IDirectDrawSurface
// interface we're using (1, 2, or 3)
//

/*
  typedef IDirectDrawSurface2 *LPDDRAWSURFACE;
typedef IDirectDrawSurface2 IDDrawSurface;
*/

typedef IDirectDrawSurface *LPDDRAWSURFACE;
typedef IDirectDrawSurface IDDrawSurface;

HRESULT DDCopyBitmap (IDDrawSurface*,HBITMAP, int x,int y, int dx,int dy);
DWORD   DDColorMatch (IDDrawSurface*, COLORREF);

LARGE_INTEGER GetFileVersion(LPSTR szPath);

#if DEVELOPER_DEBUG
    void hresult( HRESULT );
    VOID    reallyPrintDDError (HRESULT, const char *, int);
    #define printDDError(err)  reallyPrintDDError(err, __FILE__, __LINE__);
    void PalCRCs (PALETTEENTRY [], unsigned int &total, unsigned int &color);
    void DDObjFromSurface(
        IDirectDrawSurface *lpdds,
        IUnknown **lplpDD,
        bool doTrace,
        bool forceTrace = false);

    struct DDSurface;
    void showme(DDSurface *surf);    
    void showme2(IDirectDrawSurface *surf);    
    void showmerect(IDirectDrawSurface *surf,
                    RECT *r,
                    POINT offset);
#else
    VOID    reallyPrintDDError (HRESULT);
    #define printDDError(err)  reallyPrintDDError(err);
#endif

int     BPPtoDDBD (int bitsPerPixel); // XXX: DDRAW provides this function!
void    GetSurfaceSize(IDDrawSurface *surf,
                       LONG *width,
                       LONG *height);

IDirectDrawSurface  *DDSurf2to1(IDirectDrawSurface2 *dds);
IDirectDrawSurface2 *DDSurf1to2(IDirectDrawSurface  *dds);

// General conversion function that takes the source surface and
// copies to the destination surface.  This assumes that the two of
// are differing bit depths.  If they're not, it works anyhow.  If the
// writeToAlphaChannel flag is set, and the destination surface is 32
// bits, then we write in an 0xff to the alpha channel for the pixels
// that don't match the color key (if color key is specified) or all
// pixels (if color key isn't specified).
void
PixelFormatConvert(IDirectDrawSurface *srcSurf,
                   IDirectDrawSurface *dstSurf,
                   LONG width,
                   LONG height,
                   DWORD *sourceColorKey, // NULL if no color key
                   bool writeAlphaChannel);


/*****************************************************************************
Hacked workaround for Permedia cards, which have a primary pixel format
with alpha per pixel.  If we're in 16-bit, then we need to set the alpha
bits to opaque before using the surface as a texture.  For some reason,
an analogous hack for 32-bit surfaces has no effect on Permedia hardware
rendering, so we rely on hardware being disabled for such a scenario.
*****************************************************************************/
void SetSurfaceAlphaBitsToOpaque(IDirectDrawSurface *imsurf,
                                 DWORD colorKey,
                                 bool keyIsValid);


/////  Not-necessarily DDraw utilities.

#define INVALID_COLORKEY 0xFFFFFFFF

HBITMAP *UtilLoadImage(LPCSTR szFileName,
                       IStream * pstream,
                       int dx, int dy,
                       COLORREF **colorKeys, 
                       int *numBitmaps, 
                       int **delays,
                       int *loop);


// Convert a DA Point to a discrete integer based point assuming that
// we have an image centered about the DA origin, and that the pixel
// width and height are as given.
void CenteredImagePoint2ToPOINT(Point2Value	*point, // in
                                LONG		 width, // in
                                LONG		 height, // in
                                POINT		*pPOINT); // out

void CenteredImagePOINTToPoint2(POINT		*pPOINT, // in
                                LONG		 width, // in
                                LONG		 height, // in
                                Image		*referenceImg, // in
                                Point2Value	*pPoint2); // out

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\ddsimg.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

*******************************************************************************/


#ifndef _DDSIMG_H
#define _DDSIMG_H

#include <privinc/ddsurf.h>
#include <privinc/discImg.h>
#include <privinc/comutil.h>
#include <appelles/hacks.h>  // viewerres

class DirectDrawSurfaceImage : public DiscreteImage {

  public:
    DirectDrawSurfaceImage(IDDrawSurface *iddSurf,
                           bool holdReference);

    DirectDrawSurfaceImage(IDDrawSurface *iddSurf,
                           IDXSurface *idxSurf,
                           bool holdReference);
    
    ~DirectDrawSurfaceImage();
    virtual void CleanUp();

    void Render(GenericDevice& dev);

    void InitIntoDDSurface(DDSurface *ddSurf,
                           ImageDisplayDev *dev);

    void GetIDDrawSurface(IDDrawSurface **outSurf);
    void GetIDXSurface(IDXSurface **outSurf);

    #if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "(IDirectDrawSurfaceImage@ " << (void *)this << ")";
    }
    #endif

    // DetectHit: in base class


    virtual VALTYPEID GetValTypeId() { return DIRECTDRAWSURFACEIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == DirectDrawSurfaceImage::GetValTypeId() ||
                DiscreteImage::CheckImageTypeId(type));
    }
    
  private:

    void _InitSurfaces(IDDrawSurface *iddSurf,
                       IDXSurface    *idxSurf);
    
    void _Init( bool holdReference );
    
    // derivative surfaces
    IDDrawSurface          *_iddSurf;
    IDXSurface             *_idxSurf;
    
    bool                    _holdReference;

    #if DEVELOPER_DEBUG
    bool _surfacesSet;
    #endif
};

Image *ConstructDirectDrawSurfaceImageWithoutReference(IDDrawSurface *idds);
Image *ConstructDirectDrawSurfaceImageWithoutReference(IDDrawSurface *idds, IDXSurface *idxs);


#endif /* _DDSIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\debug.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Declarations and definitions for debugging.

*******************************************************************************/

#if !defined(_AP_DEBUG_H) && ((_DEBUG != 0) || (_MEMORY_TRACKING !=0))
#define _AP_DEBUG_H


    /*** Tag Declarations & Definitions ***/

#if DEFINE_TAGS
    #define TAGDECL(tag,owner,desc)   DeclareTag(tag,owner,desc)
#else
    #define TAGDECL(tag,owner,desc)   extern TAG tag
#endif 

TAGDECL (tagAntialiasingOn, "2D", "Turn Anti-Alising ON (override)");
TAGDECL (tagAntialiasingOff,"2D", "Turn Anti-Alising OFF (override)");
TAGDECL (tagAAScaleOff,     "2D", "Turn Off Scale for Anti-Alising");

TAGDECL (tagGRenderObj,     "3D", "GeomRenderer Objects");
TAGDECL (tagGRendering,     "3D", "Rendering Trace");
TAGDECL (tagGTextureInfo,   "3D", "Texture Informative");
TAGDECL (tagForceTexUpd,    "3D", "Force Texture Update");
TAGDECL (tag3DDevSelect,    "3D", "Device Selection");
TAGDECL (tagD3DCallTrace,   "3D", "D3D Call Trace");

TAGDECL (tagAPIEntry, "API",  "C Entry");
TAGDECL (tagCOMEntry, "API",  "COM Entry");

TAGDECL (tagNetIO, "CNetIO", "CNetIO Methods");

TAGDECL (tagCOMCallback, "COMCallback", "COMCallback Methods");

TAGDECL (tagControlLifecycle, "Control", "Lifecycle");

TAGDECL (tagDDSurfaceRef,  "DDSurface", "Surfaces: Ref count tracing");
TAGDECL (tagDDSurfaceLeak, "DDSurface", "Surfaces: Leak reporting");

TAGDECL (tagDibImageInformative, "DibImage", "Informative Messages");

TAGDECL (tagDirectDrawObject, "DirectDraw", "IDirectDraw Object tracing");

TAGDECL (tagDiscreteImageInformative, "DiscreteImage", "Informative Messages");

TAGDECL (tagEngNoSRender,      "Engine", "Turn Off Top-Level Smart Render");
TAGDECL (tagNoApplyFolding,    "Engine", "Turn Off Apply Creation Constant Fold");
TAGDECL (tagNoTimeXformFolding,"Engine", "Turn Off TimeXform Constant Fold");
TAGDECL (tagAppTrigger,        "Engine", "AppTriggerEvent Trace");
TAGDECL (tagSwitcher,          "Engine", "Switcher Trace");
TAGDECL (tagPureFunc,          "Engine", "Disable Pure Function Detection");
TAGDECL (tagDCFold,            "Engine", "Turn Off Dynamic Constant Folding");
TAGDECL (tagDCFoldTrace,       "Engine", "Turn On Trace on Dynamic Constant Folding");
TAGDECL (tagDCFoldTrace2,      "Engine", "Turn On Per Sample Trace on Dynamic Constant Folding");
TAGDECL (tagOldTimeXform,      "Engine", "Turn on old TimeXform semantics");
TAGDECL (tagCycleCheck,        "Engine", "Cycle Checking");

TAGDECL (tagFail_InternalError, "Error failures", "Fail: InternalError");
TAGDECL (tagFail_InternalErrorCode, "Error failures", "Fail: InternalErrorCode");
TAGDECL (tagFail_UserError, "Error failures", "Fail: UserError");
TAGDECL (tagFail_UserError1, "Error failures", "Fail: UserError RESID");
TAGDECL (tagFail_UserError2, "Error failures", "Fail: UserError HR RESID");
TAGDECL (tagFail_ResourceError, "Error failures", "Fail: ResourceError");
TAGDECL (tagFail_ResourceError1, "Error failures", "Fail: ResourceError str");
TAGDECL (tagFail_ResourceError2, "Error failures", "Fail: ResourceError RESID");
TAGDECL (tagFail_StackFault, "Error failures", "Fail: StackFault");
TAGDECL (tagFail_DividebyZero, "Error failures", "Fail: DivideByZero");
TAGDECL (tagFail_OutOfMemory, "Error failures", "Fail: OutOfMemory");

TAGDECL (tagDXTransforms, "DXTransforms", "General");
TAGDECL (tagDXTransformsImg0, "DXTransforms", "Disp Img 0");
TAGDECL (tagDXTransformsImg1, "DXTransforms", "Disp Img 1");
TAGDECL (tagDXTransformsImgOut, "DXTransforms", "Disp Img Out");

TAGDECL (tagGCStat,   "GC", "Statistics");
TAGDECL (tagGCDebug,  "GC", "Debug: No Reuse Of Free Objs");
TAGDECL (tagGCMedia,  "GC", "Trace GC Static Value - Media");
TAGDECL (tagGCStress, "GC", "Doing GC all every 100ms");

TAGDECL (tagImageDecode, "Image Decode", "Image Decode Filters");

TAGDECL (tagImageDeviceInformative,  "ImageDevice", "Informative Messages");
TAGDECL (tagImageDeviceOptimization, "ImageDevice", "Optimization Messages");
TAGDECL (tagImageDeviceAlgebra,      "ImageDevice", "Algebra Messages");
TAGDECL (tagImageDeviceAlpha,        "ImageDevice", "Alpha Messages");
TAGDECL (tagImageDeviceQualityScaleOff, "ImageDevice", "Turn off Quality Scale (GDI)");

TAGDECL (tagImport,              "Import", "General Importation Status");
TAGDECL (tagReadVrml,            "Import", "VRML - General Status");
TAGDECL (tagReadVrmlFaceIndices, "Import", "VRML - Face Indices");
TAGDECL (tagReadX,               "Import", "X File Importation");

TAGDECL (tagMathMatrixInvalid, "Math", "Break on Invalid Matrices");

TAGDECL (tagCacheOpt, "Optimizations", "Report on caching constant images");
TAGDECL (tagDirtyRectsVisuals ,"Optimizations", "Dirty rects - Visual trace");
TAGDECL (tagCachedImagesVisuals ,"Optimizations", "Cached images - Visual trace");

TAGDECL (tagPickOptOff,    "Picking", "Disable Picking Optimizations");
TAGDECL (tagPick2,         "Picking", "2D Images");
TAGDECL (tagPick2Hit,      "Picking", "2D Stuff result & image hit");
TAGDECL (tagPick3,         "Picking", "3D General");
TAGDECL (tagPick3Geometry, "Picking", "3D Geometry");
TAGDECL (tagPick3Bbox,     "Picking", "3D Bbox Testing");
TAGDECL (tagPick3Offset,   "Picking", "3D Local Coord Offset");

TAGDECL (tagServerCtx,  "Server", "Context");
TAGDECL (tagServerView, "Server", "View");

TAGDECL (tagSoundDevLife, "Sound", "Device Life");
TAGDECL (tagSoundDebug,   "Sound", "Current Debug");
TAGDECL (tagSoundErrors,  "Sound", "Errors");
TAGDECL (tagSoundLoads,   "Sound", "Media File Reading");
TAGDECL (tagSoundRenders, "Sound", "Renders");
TAGDECL (tagSoundReaper1, "Sound", "Reaper Events");
TAGDECL (tagSoundReaper2, "Sound", "Reaper Operation");
TAGDECL (tagSoundStats,   "Sound", "Dsound Statistics");
TAGDECL (tagSoundDSound,  "Sound", "Dsound Details");
TAGDECL (tagSoundStubALL, "Sound", "Return in Display");
TAGDECL (tagSoundStop,    "Sound", "Stop Sound");
TAGDECL (tagMovieStall,   "Sound", "stub out movie Stall()");
TAGDECL (tagAVmodeDebug,  "Sound", "output avmode messages");
TAGDECL (tagAMStreamLeak, "Sound", "output amstream create/releases");

TAGDECL (tagSplineEval, "Splines", "Evaluation");

TAGDECL (tagTextPtsCache,    "Text", "Text Points Cache Info");
TAGDECL (tagTextBoxes,       "Text", "Text Box Outlines");

TAGDECL (tagTransientHeapDynamic,  "TransientHeap", "Dynamic Status");
TAGDECL (tagTransientHeapLifetime, "TransientHeap", "Lifetime Status");

TAGDECL (tagViewportInformative, "Viewport", "Informative Messages");
TAGDECL (tagViewportMemory,      "Viewport", "viewport: Memory tracing");

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\dibimage.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Header for DibImage, containing a DIB-style bitmap.
*******************************************************************************/

#ifndef _DIBIMAGE_H
#define _DIBIMAGE_H

#include "ddraw.h"

#include "privinc/imagei.h"
#include "privinc/DiscImg.h"
#include "privinc/vec2i.h"
#include "privinc/ddutil.h"

class DirectDrawViewport;

class DibImageClass : public DiscreteImage {
  public:
    DibImageClass(HBITMAP hbm, 
                  COLORREF colorKey=INVALID_COLORKEY, 
                  Real resolution=-1);
    
    virtual ~DibImageClass() { CleanUp(); }
    virtual void CleanUp();

    void Render(GenericDevice& dev) {
        Assert(!_noDib && "No dib in DibImageClass::Render()");

        DiscreteImage::Render(dev);
    }
        
    Bool  DetectHit(PointIntersectCtx& ctx);

    void InitIntoDDSurface(DDSurface *ddSurf,
                           ImageDisplayDev *dev);
    
    bool ValidColorKey(LPDDRAWSURFACE surface, DWORD *colorKey) {
        if(_colorRef != INVALID_COLORKEY) {
            *colorKey = DDColorMatch(surface, _colorRef);
            return TRUE;
        } else {
            *colorKey = INVALID_COLORKEY;  // xxx: won't work for argb
            return FALSE;
        }
    }
           
    virtual bool HasSecondaryColorKey() { return _2ndCkValid; }
    virtual void SetSecondaryColorKey(DWORD ck) {
        _2ndCkValid = true;
        _2ndClrKey = ck;
    }
    
#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "(BitmapImage @ " << (void *)this << ")";
    }   
#endif

    virtual VALTYPEID GetValTypeId() { return DIBIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == DibImageClass::GetValTypeId() ||
                DiscreteImage::CheckImageTypeId(type));
    }
  protected:

    // TODO:  Unclear if this stuff is appropriate for rendering
    // through non-GDI renderers like DirectDraw.  If not, we may need
    // to have some sort of multiple dispatching representation.
    
    HBITMAP             _hbm;
    COLORREF            _colorRef;

    // These are for Direct Draw
    Bool                _noDib;
  private:
    void ConstructWithHBM();

    bool  _2ndCkValid;
    DWORD _2ndClrKey;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\dispdevi.h ===
#ifndef _DISPDEVI_H
#define _DISPDEVI_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Specify generic picture display device class and operations.

--*/

#include "appelles/dispdev.h"
#include "appelles/common.h"
#include "privinc/storeobj.h"
#include "privinc/drect.h"
#include "privinc/gendev.h"      // DeviceType

////////////////////////////////////////////////////////////////////
//
//  Generic display device class, meant to display either image or
//  geometry. 
//
////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE DisplayDev : public GenericDevice {
  public:
    virtual ~DisplayDev() {}

    // Beginning and ending of rendering an image often mean
    // operations
    virtual void BeginRendering(Image *img, Real opacity) = 0;
    virtual void EndRendering(DirtyRectState &d) = 0;

    DeviceType GetDeviceType() { return(IMAGE_DEVICE); }
    
    // Use these to retrieve the dimensions of the device
    virtual int GetWidth()  = 0;
    virtual int GetHeight() = 0;

#if _USE_PRINT
    virtual ostream& Print(ostream& os) const = 0;
#endif
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\drect.h ===
/*******************************************************************************

Copyright (c) 1996 Microsoft Corporation

Abstract:

     Header file for dirty rectangle implementation.

*******************************************************************************/

#ifndef _DRECT_H
#define _DRECT_H

#include "privinc/bbox2i.h"

class ImageWithBox {
  public:
    ImageWithBox() {
        // Default constructor needed for compiling under NT5 because
        // of usage in STL vectors.  Don't ever expect to use it. 
        Assert(!"Shouldn't be here.");
    }
    
    ImageWithBox(Image *img,
                 Bbox2& boxToCopy)
    {
        _image  = img;
        _box    = boxToCopy;
    }

    inline int operator==(ImageWithBox &m) {
        return (_image == m._image) && (_box == m._box);
    }

    Image *_image;
    Bbox2  _box; 
};

class BboxList {
  public:
    BboxList();
    ~BboxList();
    void Add(const Bbox2 box);
    void Add(ImageWithBox &ib);
    void Clear();

#if _DEBUG
    void Dump();
#endif  

    int             _count;
    vector<Bbox2>   _boxes;
};


class ConstImageList {
  public:
    ConstImageList();
    ~ConstImageList();
    void Add(Image *img, Bbox2& boxToCopy);
    void Clear();

#if _DEBUG
    void Dump();
#endif  

    int                   _count;
    vector<ImageWithBox>  _images;
};

// Traversal context
class DirtyRectCtx {
  public:
    DirtyRectCtx(BboxList        &dirtyRects,
                 int              lastSampleId,
                 ConstImageList  &constImages,
                 Bbox2&           targetBox);
    
    void AddDirtyRect(const Bbox2 rect);

    void AddToConstantImageList(Image *img,
                                Bbox2& boxToCopy);

    // fold in new box, return the old one.
    void   AccumulateClipBox(const Bbox2 clipBox);
    void   SetClipBox(const Bbox2 clipBox);
    Bbox2  GetClipBox();

    Transform2      *_accumXform;
    bool             _processEverything;
    int              _lastSampleId;
    BboxList&        _dirtyRects;
    ConstImageList&  _constImages;

  protected:
    Bbox2           _accumulatedClipBox;
    
};

// State maintained with the view.
class DirtyRectState {
  public:
    DirtyRectState();
    void Clear();
    void Swap();
    void CalculateDirtyRects(Image *theImage,
                             int lastSampleId,
                             Bbox2& targetBox);
    void ComputeMergedBoxes();
    Image *RewriteAsCrops(Image *origImage);

    int GetMergedBoxes(vector<Bbox2> **ppBbox2PtrList);

    Image *Process(Image *theImage,
                   int lastSampleId,
                   Bbox2 targetBox);

#if _DEBUG
    void Dump();
#endif  

  protected:
    void MergeDiffConstImages();

    bool           _drectsAisOld;
    bool           _lastMergedToOne;
    bool           _thisMergedToOne;
    Bbox2          _mergedBox;
    BboxList       _drectsA;
    BboxList       _drectsB;
    ConstImageList _constImagesA;
    ConstImageList _constImagesB;
    BboxList       _mergedBoxes;
};


#endif /* _DRECT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\dsdev.h ===
#ifndef _DSDEV_H
#define _DSDEV_H


/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    DirectSound device interface.

*******************************************************************************/
#include <privinc/soundi.h>
#include <privinc/snddev.h>
#include <privinc/bground.h>

class DSprimaryBuffer;
class DirectSoundProxy;
class DSstaticBuffer;

typedef map<Sound*, DSstaticBuffer*, less<Sound*> > DSMasterBufferList;
typedef map<Sound*, CComPtr<IStream>, less<Sound*> >
StreamFileList;

DirectSoundProxy *CreateProxy(DirectSoundDev *dsDev);

class DirectSoundProxy : public AxAThrowingAllocatorClass {
  public:
    ~DirectSoundProxy();
    static void Configure();   // called ONCE (by initModule) to setup
    static void UnConfigure(); // called ONCE (by DeinitModule) to tear down
    static DirectSoundProxy *CreateProxy(HWND hwnd);
    DSprimaryBuffer *GetPrimaryBuffer() { return(_primaryBuffer); }

    // expose the LPDIRECTSOUND interface!
    HRESULT CreateSoundBuffer(LPDSBUFFERDESC,
        LPLPDIRECTSOUNDBUFFER, IUnknown FAR *);
    HRESULT GetCaps(LPDSCAPS);
    HRESULT DuplicateSoundBuffer(LPDIRECTSOUNDBUFFER, LPLPDIRECTSOUNDBUFFER);
    HRESULT SetCooperativeLevel(HWND, DWORD);
    HRESULT Compact();
    HRESULT GetSpeakerConfig(LPDWORD);
    HRESULT SetSpeakerConfig(DWORD);
    HRESULT Initialize(GUID *);

  private:
    static void CreateCom(HWND hwnd);
    void DestroyCom();

    static        CritSect *_mutex;
    static             int  _refCount;
    static    IDirectSound *_lpDirectSound;
    static DSprimaryBuffer *_primaryBuffer;  // keep so we may query format
    static       HINSTANCE  _hinst;          // library handle
};

class DSstreamingBufferElement;

class DirectSoundDev : public GenericDevice{
  public:
    friend SoundDisplayEffect;

    static void Configure();   // called ONCE (by initModule) to setup
    static void UnConfigure(); // called ONCE (by DeinitModule) to tear down
    DirectSoundDev(HWND hwnd, Real latentsy);
    ~DirectSoundDev();
    HWND GetHWND() { return(_hwnd); }
    void SetAvailability(bool available) { _dsoundAvailable = available; }
    void AddSound(LeafSound *sound, MetaSoundDevice *, DSstreamingBufferElement *);
    void RemoveSounds(MetaSoundDevice *devkey);
    void SetParams(DSstreamingBufferElement *ds,
                   double rate, bool doSeek, double seek, bool loop);

    DSstaticBuffer *GetDSMasterBuffer(Sound *snd);
    void RemoveDSMasterBuffer(Sound *snd);
    void AddDSMasterBuffer(Sound *snd, DSstaticBuffer *dsMasterBuffer);
    bool ReapElderlyMasterBuffers();

    void RemoveStreamFile(Sound *snd);
    void AddStreamFile(Sound *snd, CComPtr<IStream> istream);
    
    DeviceType GetDeviceType() { return(SOUND_DEVICE); }

    int              _latentsy;
    int              _jitter;
    int              _nap;             // length of time to nap between renders

    // render methods
    void RenderSound(Sound *snd);
    void BeginRendering();
    void EndRendering();
    
    bool               _dsoundAvailable; // keep track of resource

  protected:
    HWND             _hwnd;

  private:
    static BackGround      *_backGround;      // background synth renderer

    DSMasterBufferList     _dsMasterBufferList;
    StreamFileList         _streamList;
    CritSect               _dsMasterCS;
};

#endif /* _DSDEV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\dxxf.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    DirectAnimation support for DXTransforms

*******************************************************************************/


#ifndef _DXXF_H
#define _DXXF_H

#include <dxtrans.h>

Bvr ConstructDXTransformApplier(IDXTransform *theXf,
                                IDispatch *theXfAsDispatch,
                                LONG numInputs,
                                Bvr *inputs,
                                Bvr  evaluator);

HRESULT DXXFAddBehaviorPropertyToDXTransformApplier(BSTR property,
                                                    Bvr  bvrToAdd,
                                                    Bvr  bvrToAddTo);

#endif /* _DXXF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\discimg.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

     The Discrete Image class represents a constant image whose scope
     is much more than one frame and whose bits are cached in a
     surface kept by the device and are associate with the discrete image.

*******************************************************************************/


#ifndef _DISCIMG_H
#define _DISCIMG_H

#include "privinc/ddutil.h"
#include "privinc/probe.h"
#include "privinc/bbox2i.h"
#include "privinc/imagei.h"
#include "privinc/imgdev.h"

struct DDSurface;
class Transform2;
class Bbox2;
class DirectDrawImageDevice;

class DiscreteImage : public Image {
  public:
    DiscreteImage() : _myHeap(GetHeapOnTopOfStack())  {
        _bboxReady = FALSE;
        _membersReady = FALSE;
        _resolution = -1;
        _width = _height = -1;
        _dev = NULL;
    }
    virtual ~DiscreteImage() {}
    
    virtual void Render(GenericDevice& dev) {
        //Assert( (_dev!=NULL) && "NULL _dev in DiscreteImage render");
        //Assert( (&dev == (GenericDevice *)_dev) &&  "Can only use DicreteImage with ONE dev");
        
        ImageDisplayDev &idev = (ImageDisplayDev &)dev;
        idev.RenderDiscreteImage(this);
    }

    const Bbox2 BoundingBox(void);

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        Transform2 *xf = bbctx.GetTransform();
        return TransformBbox2(xf, BoundingBox());
    }
#endif  // BOUNDINGBOX_TIGHTER

    Bool DetectHit(PointIntersectCtx& ctx) {
        Point2Value *lcPt = ctx.GetLcPoint();

        if (!lcPt) return FALSE; // singular transform
        
        return BoundingBox().Contains(Demote(*lcPt));
    }

    RECT *GetRectPtr() {
        Assert(_membersReady && "GetRectPtr called when members not ready");
        return &_rect;
    }
    
    const Bbox2 OperateOn(const Bbox2 &box) { return box; }

    virtual LONG GetPixelWidth() {
        Assert(_membersReady && "GetPixelWidth called when members not ready");
        return _width;
    }
    virtual LONG GetPixelHeight() {
        Assert(_membersReady && "GetPixelHeight called when members not ready");
        return _height;
    }

    Real  GetResolution() {
        Assert(_resolution>0 && "Invalid _resolution in DiscreteImage::GetResolution()");
        return _resolution;
    }

    virtual Bool NeedColorKeySetForMe() { return FALSE; }

    virtual bool ValidColorKey(LPDDRAWSURFACE surface,
                               DWORD *colorKey) {
        return FALSE;
    }

    virtual bool HasSecondaryColorKey() { return false; }
    virtual void SetSecondaryColorKey(DWORD ck) {}
    
    virtual void InitializeWithDevice(ImageDisplayDev *dev, Real res) {
        _dev = (DirectDrawImageDevice *)dev;
        if(_resolution < 0) _resolution = res;
    }

    virtual void InitIntoDDSurface(DDSurface *ddSurf,
                                   ImageDisplayDev *dev) = 0;

    virtual void GetIDDrawSurface(IDDrawSurface **os) { *os = NULL; }

    virtual DiscreteImage *IsPurelyTransformedDiscrete(Transform2 **theXform) {
        *theXform = identityTransform2;
        return this;
    }

    void DoKids(GCFuncObj proc) {
        Image::DoKids(proc);
    }

    virtual VALTYPEID GetValTypeId() { return DISCRETEIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == DiscreteImage::GetValTypeId() ||
                Image::CheckImageTypeId(type));
    }
  protected:

    DirectDrawImageDevice *GetMyImageRenderer() { return _dev; }

    // these all might need to go into the DDSurface class...
    Bbox2               _bbox;             // in meters
    Real                _resolution;       // in pixels per meter

    LONG                _width, _height;
    RECT                _rect;

    Bool                _bboxReady;
    Bool                _membersReady;
    
    DynamicHeap        &_myHeap;

    DirectDrawImageDevice *_dev;
};

#endif /* _DISCIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\dxmatl.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _DXMATL_H
#define _DXMATL_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#if DEBUG || _MEMORY_TRACKING
#include "../../apeldbg/apeldbg.h"
#endif

#ifndef _DEBUGMEM
// Need this for _ASSERTE macro so we can specify no debug crt

#define _ATL_NO_DEBUG_CRT 1

#if _DEBUG //|| _MEMORY_TRACKING - this commenting is temporary (ref: BUG#15391)
#undef _ASSERTE
#define _ASSERTE(expr) \
        do { if (!(expr) && AssertImpl(__FILE__, __LINE__, #expr))\
             F3DebugBreak(); } while (0)
#else
#define _ASSERTE(expr) ((void)0)
#endif
#endif


#define _ATL_STATIC_REGISTRY 1

#ifdef _DEBUG

extern TAG tagATL;

inline void _cdecl AtlTrace2(LPCTSTR fmt, ...) {
    va_list args;
    va_start(args, fmt) ;
    if (TaggedTraceListEx (tagATL, 0, (char *)fmt, args)) {
        F3DebugBreak();
    }
}
#define ATLTRACE            AtlTrace2
#endif

#include <atlbase.h>

// We are overriding these methods so we can hook them and do some
// stuff ourselves.
class DACComModule : public CComModule
{
  public:
    LONG Lock();
    LONG Unlock();

#if DEVELOPER_DEBUG
    void AddComPtr(void *ptr, const char * name);
    void RemoveComPtr(void *ptr);

    void DumpObjectList();
#endif
};

//#define _ATL_APARTMENT_THREADED
// THIS MUST BE CALLED _Module - all the ATL header files depend on it
extern DACComModule _Module;


#undef  min
#define min(a,b)  (((a) < (b)) ? (a) : (b))

#undef  max
#define max(a,b)  (((a) > (b)) ? (a) : (b))

#include <atlcom.h>
#include <atlctl.h>

#if _DEBUG
#include <typeinfo.h>
#endif

// COPIED FROM ATLCOM.H

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
class ModuleReleaser
{
  public:
    ModuleReleaser() {
        _Module.Lock();
    }

    ~ModuleReleaser() {
        _Module.Unlock();
    }
};

template <class Base>
class DAComObject 
    : public ModuleReleaser,
      public Base
{
  public:
    typedef Base _BaseClass;
    DAComObject(void* = NULL)
    {
#if DEVELOPER_DEBUG
#if _DEBUG
        _Module.AddComPtr(this, GetName());
#else
        _Module.AddComPtr(this, NULL);
#endif
#endif
    }
    // Set refcount to 1 to protect destruction
    ~DAComObject()
    {
#if DEVELOPER_DEBUG
        _Module.RemoveComPtr(this);
#endif
        m_dwRef = 1L;
        FinalRelease();
    }
    //If InternalAddRef or InteralRelease is undefined then your class
    //doesn't derive from CComObjectRoot
    STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
    STDMETHOD_(ULONG, Release)()
    {
        ULONG l = InternalRelease();
        if (l == 0)
            delete this;
        return l;
    }
    //if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
    {return _InternalQueryInterface(iid, ppvObject);}
    static HRESULT WINAPI CreateInstance(DAComObject<Base>** pp);
};

template <class Base>
HRESULT WINAPI DAComObject<Base>::CreateInstance(DAComObject<Base>** pp)
{
    _ASSERTE(pp != NULL);
    HRESULT hRes = E_OUTOFMEMORY;
    DAComObject<Base>* p = NULL;
    ATLTRY((p = new DAComObject<Base>()));
    if (p != NULL) {
        p->SetVoid(NULL);
        p->InternalFinalConstructAddRef();
        hRes = p->FinalConstruct();
        p->InternalFinalConstructRelease();
        if (hRes != S_OK) {
            delete p;
            p = NULL;
        }
    }
    *pp = p;
    return hRes;
}

#define DA_DECLARE_NOT_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
#define DA_DECLARE_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComCreator< CComAggObject< x > > > _CreatorClass;
// END OF COPIED CODE

// Just to make things more uniform
#define RELEASE(x) if (x) { (x)->Release(); (x) = NULL; }

#endif /* _DXMATL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\error.h ===
#ifndef _ERROR_H
#define _ERROR_H

/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    This file is included for common
    inlined error functions

-------------------------------------*/
#include <ddraw.h>
#include "privinc/except.h"
#include "privinc/debug.h"
#include "privinc/ddutil.h"


#if _DEBUG

#define IfDDErrorInternal(ddrval,str) IfDDErrorInternalImpl(ddrval,str)
#define IfErrorInternal(cond,str) IfErrorInternalImpl(cond,str)

#else

#define IfDDErrorInternal(ddrval,str) IfDDErrorInternalImpl(ddrval)
#define IfErrorInternal(cond,str) IfErrorInternalImpl(cond)

#endif

inline void IfDDErrorInternalImpl(HRESULT ddrval DEBUGARG1(char *str))
{
    if (ddrval != DD_OK) {

        if (ddrval == DDERR_SURFACEBUSY || 
            ddrval == DDERR_CANTCREATEDC)
        {   RaiseException_UserError
                (DAERR_VIEW_SURFACE_BUSY, IDS_ERR_IMG_SURFACE_BUSY);
        }

        TraceTag((tagError, "Internal DDraw exception: %s", str)); 
        DebugCode(hresult(ddrval));
        RaiseException_UserError(E_FAIL, IDS_ERR_IMG_SURFACE_BUSY);
    }
}


inline void IfErrorInternalImpl(Bool cond DEBUGARG1(char *str))
{
    if(cond) {
        TraceTag((tagError, "Internal exception: %s", str)); 
        RaiseException_InternalError(DEBUGARG(str));
    }
}


#endif /* _ERROR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\fileutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    General file utilities

*******************************************************************************/

#ifndef _FILEUTIL_H
#define _FILEUTIL_H

// Decompress GZipped files, from the input file to the output file
// (output file will be newly created).  Return TRUE or FALSE.  Note
// that this only succeeds if GZIP used the "DEFLATE" compression
// style, which it doesn't always do.  The outfile name is a temporary
// filename that's created by the routine.  Need to pass in a big
// enough buffer to hold the name (1024 should do it).

BOOL MSDecompress(LPSTR pszInFile, LPSTR pszOutFile);

#endif /* _FILEUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\gendev.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Generic Device

*******************************************************************************/


#ifndef _GENDEV_H
#define _GENDEV_H

#include "except.h"

enum DeviceType {
    SOUND_DEVICE,
    IMAGE_DEVICE,
    GEOMETRY_DEVICE
};


// forward decls
class DynamicHeap;
extern DynamicHeap &GetHeapOnTopOfStack();

class GenericDevice : public AxAThrowingAllocatorClass {
  public:
    GenericDevice() {}

    virtual ~GenericDevice() {}

    // query defaults to false except for audio devices which overload it
    // XXX  Maybe we should return an enum one day?
    //virtual bool SoundDevice() { return FALSE; }
    virtual DeviceType GetDeviceType() = 0;

    void ResetContext() {
    }
};


#endif /* _GENDEV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\geometry.h ===
#ifndef _GEOMETRY_H
#define _GEOMETRY_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Definitions and declarations for geometric utility functions.

*******************************************************************************/

#include "d3drmdef.h"

    // Referenced Structures

class Point3Value;
class Vector3Value;
class HitInfo;

    // This function, given three triangle vertices and a point P guaranteed to
    // be inside the triangle, returns the barycentric coordinates of that
    // point with respect to the vertices.

void GetContainedBarycentricCoords
    (    Point3Value vertices[3],     // Triangle Vertices Containing P
         Point3Value P,
         Real barycoords[3]);


/*****************************************************************************
This routine starts with a facet defined by a triangle fan about the first
vertex, and a point P on the face.  It determines which triangle in the face
contains the point P, and returns the three vertex positions and vertex
surface coordinates in the triPos[] and triUV[] arguments, respectively.
*****************************************************************************/

int GetFacetTriangle (
    Point3Value   P,           // Point In Facet
    unsigned int  N,           // Number of Facet Vertices
    D3DRMVERTEX  *fVerts,      // Facet Vertices
    Point3Value   triPos[3],
    Point2Value  *triUV);		// Containing-Triangle Surface Coordinates

void GetTriFanBaryCoords(
    Point3Value   P,           // Point In Facet
    unsigned int  N,           // Number of Facet Vertices
    D3DRMVERTEX  *fVerts,      // Facet Vertices
    Real          barycoords[3],
    int          *index);

// Get the image coordinates of the picked texture map.

Point2Value *GetTexmapPoint (HitInfo &hit);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\frontend.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Frontend Declarations

*******************************************************************************/


#ifndef _FRONTEND_H
#define _FRONTEND_H

class ExpImpl ;
typedef ExpImpl * Exp ;

class IncludeImpl ;
typedef IncludeImpl * Include ;

class AstImpl ;
typedef AstImpl * Ast ;

class TypeExpImpl ;
typedef TypeExpImpl * TypeExp ;

class AxAModuleImpl;
typedef AxAModuleImpl *AxAModule;

// Identifiers

typedef char * Ident;
#define IDEQ(s1, s2) (s1 == s2)
#define IdentToStr(id) ((char *) id)

Ident MakeIdent(char *str);

class idcmp {
public: 
  bool operator() (const char *x,const char *y) const
          { return(strcmp(x,y) < 0); }
};
 
typedef set <char *,idcmp> IdSet ;

typedef list <char *> IdList;

extern Ident underscoreId ;

struct LocInfoImpl : public StoreObj
{
    LocInfoImpl(char * url,
                DWORD startline,
                DWORD startcol,
                DWORD endline,
                DWORD endcol)
    : _url(url),
      _startLine(startline),
      _startCol(startcol),
      _endLine(endline),
      _endCol(endcol)
    {}
    
    ostream& Print(ostream& os) ;
    
    friend ostream& operator<<(ostream& os, LocInfoImpl & loc)
    { return loc.Print(os) ; }
    
    char * _url ;
    DWORD _startLine ;
    DWORD _startCol ;
    DWORD _endLine ;
    DWORD _endCol ;
} ;

typedef LocInfoImpl * LocInfo ;

// This can handle a NULL locinfo
ostream& operator<<(ostream& os, LocInfo locinfo);

TypeExp ParseTypeExp (char * typeString) ;

// Module functions

enum SourceType {
    ST_STRING  = 0,
    ST_FILE    = 1,
    ST_URL     = 2,
    ST_STREAM  = 3,
} ;

struct Source
{
    SourceType sourceType ;
    char * name ;
    void * src ;
} ;

AxAModule EmptyAxAModule() ;
AxAModule AxALoadURL (AxAModule module, char * url) ;
AxAModule AxALoadFile (AxAModule module, char * filename) ;
AxAModule AxALoadString (AxAModule module, char * name, char * str) ;
AxAModule AxALoadStream (AxAModule module, char * name, istream & stream) ;
AxAModule AxALoad (AxAModule module, Source & src) ;
TypeExp AxAGetTypeExp (AxAModule module, Ident id) ;
IR AxAGetIR (AxAModule module, Ident id) ;
IR AxAMakeExp (AxAModule module, IR exp) ;
void AxAAddOverloads (AxAModule mod) ;

// If the callback returns non-zero the function returns the same
// value 
typedef HRESULT (* AxAEnumModuleCB)(AxAModule module, LPVOID userdata) ;

// Enumerates all loaded modules - the current one is always first
HRESULT AxAEnumModule (AxAModule module,
                    AxAEnumModuleCB cb,
                    LPVOID userdata) ;

// If the callback returns non-zero the function returns the same
// value 
typedef HRESULT (* AxAEnumEnvCB)(char * name,
                                 Ident id,
                                 TypeExp typeexp,
                                 IR ir,
                                 LPVOID userdata) ;

HRESULT AxAEnumEnv (AxAModule module,
                    AxAEnumEnvCB cb,
                    LPVOID userdata) ;

ostream& operator<<(ostream& os, AxAModule mod);

// Type functions

// If both are NULL this returns TRUE
BOOL EqualTypes (TypeExp t1, TypeExp t2) ;
ostream& operator<<(ostream& os, TypeExp typeexp);

// This returns only the toplevel type and does not traverse 
// type operators
char * GetSimpleTypeString(TypeExp typeexp);

#endif /* _FRONTEND_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\except.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Exception hierarchy

*******************************************************************************/


#ifndef _EXCEPT_H
#define _EXCEPT_H

#include "appelles/common.h"
#include <stdarg.h>

// useful defines...
#if _DEBUG    
#define DEBUGARG(x) x
#define DEBUGARG1(x) ,x
#define DEBUGARG2(a,b) a,b
#else
#define DEBUGARG(x)
#define DEBUGARG1(x)
#define DEBUGARG2(a,b)
#endif

//////////////////////////////////////////////////////////////////////
////   SEH DEFINES
//////////////////////////////////////////////////////////////////////

typedef DWORD daExc;

#define      _EXC_CODES_BASE                  0xE0000000

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// IF YOU ADD AN EXCEPTION BELOW YOU MUST UPDATE THE
// _EXC_CODES_END DEFINE
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

const daExc  EXCEPTION_DANIM_INTERNAL=        _EXC_CODES_BASE + 0x0;
const daExc  EXCEPTION_DANIM_USER=            _EXC_CODES_BASE + 0x1;
const daExc  EXCEPTION_DANIM_RESOURCE=        _EXC_CODES_BASE + 0x2;
const daExc  EXCEPTION_DANIM_OUTOFMEMORY=     _EXC_CODES_BASE + 0x3;
const daExc  EXCEPTION_DANIM_DIVIDE_BY_ZERO=  _EXC_CODES_BASE + 0x4;
const daExc  EXCEPTION_DANIM_STACK_FAULT=     _EXC_CODES_BASE + 0x5;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// IF YOU ADD AN EXCEPTION ABOVE YOU MUST UPDATE THE
// _EXC_CODES_END DEFINE
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#define      _EXC_CODES_END                   _EXC_CODES_BASE + 0x5



#define EXCEPTION(t) (GetExceptionCode() == t ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )
#define RETHROW  RaiseException( GetExceptionCode(),0,0,0 )
#define HANDLE_ANY_DA_EXCEPTION ( \
  GetExceptionCode() == EXCEPTION_STACK_OVERFLOW ?  \
  EXCEPTION_CONTINUE_SEARCH : \
  _HandleAnyDaException( GetExceptionCode() ) )

DWORD _HandleAnyDaException( DWORD );


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


/**************************   Exception Raising functions  ****************/
// Internal
#if _DEBUG
#define RaiseException_InternalError(str)  _RaiseException_InternalError(str)
#define RaiseException_InternalErrorCode(code, str) _RaiseException_InternalErrorCode(code, str)
#else
#define RaiseException_InternalError(str)  _RaiseException_InternalError()
#define RaiseException_InternalErrorCode(code, str) _RaiseException_InternalErrorCode(code)
#endif

void _RaiseException_InternalError(DEBUGARG(char *m));
void _RaiseException_InternalErrorCode(HRESULT code DEBUGARG1(char *m));

// User
void RaiseException_UserError();
void RaiseException_UserError(HRESULT result, int resid, ...);

// Resource
void RaiseException_ResourceError();
void RaiseException_ResourceError(char *m);
void RaiseException_ResourceError(int resid, ...);

// Surface Cache 
void RaiseException_SurfaceCacheError(char *m);

// Hardware
void RaiseException_StackFault();
void RaiseException_DivideByZero();

// Memory
#if _DEBUG
#define RaiseException_OutOfMemory(msg, size) _RaiseException_OutOfMemory(msg, size)
#else
#define RaiseException_OutOfMemory(msg, size) _RaiseException_OutOfMemory()
#endif

void _RaiseException_OutOfMemory(DEBUGARG2(char *msg, int size));

/////////////////////// Functions /////////////////////////

/*********************   Memory Allocators   ************************/

/*** Usage

  Here's the deal.  In general, we want to be able to call "new"
  without having to check the return value, and be confident in its
  success, or, otherwise, it will raise an exception.

  The problem with overriding the global new handler to do this is
  that some legacy code may count on NULL being returned, yet we would
  throw an exception, not giving a chance to the code that checks the
  return value.

  Here is how we resolve this problem:

  Note that there are these classes of objects that you allocate: 
  
  - AxAValue's -- on our own transient heap, caller can ignore result
    of "new" 
  - GCObj -- overrides new and delete for free list, call can ignore
    result. 
  - Other AxA objects that we define... we can derive these for our
    own class that overrides "new" to make it throw.  This class is
    AxAThrowingClass, as defined below.  Caller can ignore this result
    as well.
  - External classes that we don't originally provide (don't derive
    from AxAThrowingClass, or primitive types (like char, int).  These
    need to use the following special macros that behave just like
    "new" does, but they throw an ExcOutOfMemory exception if they
    fail.  Here are some examples:
    
       char *c = THROWING_ARRAY_ALLOCATOR(char, 50);
       WeirdExternalClass *w = THROWING_ALLOCATOR(WeirdExternalClass);

  Finally, legacy or inherited code can just go on calling "new" and
  checking the return type as they normally would.

  So, all of the above boils down to the following rules for our
  development methodology:

  * If you see a call to "new", and the return value is not checked to
    be sure it's not NULL, then the object being allocated had better:
       - derive from AxAValue
       - derive from GCObj
       - derive from AxAThrowingClass
    if it doesn't, then the code is bogus.

  * If you want to allocate an object that isn't one of the three
    classes above, and don't want to check the return type, then you
    had better use the THROWING_ALLOCATOR or THROWING_ARRAY_ALLOCATOR
    macros.
    
***/

// Derive classes from this class that should throw an exception when
// they cannot be allocated because the free store is exhausted.
class AxAThrowingAllocatorClass {
  public:
#if _DEBUGMEM     
    void *operator new(size_t s, int block, char *filename, int line );
#endif    

    void *operator new(size_t s);
    void *operator new(size_t s, void *ptr);
};

// Throws an out of memory exception if the ptr is NULL, else returns
// ptr. 
extern void *ThrowIfFailed(void *ptr);

#define THROWING_ALLOCATOR(type) \
  (type *)(ThrowIfFailed((void *)(NEW type)))
  
#define THROWING_ARRAY_ALLOCATOR(type, num) \
  (type *)(ThrowIfFailed((void *)(NEW type[num])))

/*********************   Resource Grabbers   ************************/

// There are no common classes for resource grabbers.  See
// dddevice.cpp, and look for DCReleaser.  This is the model to
// follow, and there is no need for any other levels.

/*********************   Resource Grabbers   ************************/

// Thread local storage of error codes - once error is reported the
// error should be clear so the memory is freed
      
HRESULT DAGetLastError();
LPCWSTR DAGetLastErrorString();
void DAClearLastError();
void DASetLastError(HRESULT reason, LPCWSTR msg);
inline void DASetLastError(HRESULT reason, LPCSTR msg)
{ USES_CONVERSION; DASetLastError(reason, A2W(msg)); }
void DASetLastError(HRESULT reason, int resid, ...);

#endif /* _EXCEPT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\helpm.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\geomi.h ===
#pragma once
#ifndef _GEOMI_H
#define _GEOMI_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Abstract implementation class for the Geometry *type

*******************************************************************************/

#include "appelles/geom.h"
#include "appelles/sound.h"
#include "privinc/storeobj.h"
#include "privinc/vec3i.h"
#include "privinc/bbox3i.h"


    // Forward Declarations

class GeomRenderer;
class LightContext;
class SoundTraversalContext;
class RayIntersectCtx;
class FramesWithMaterials;

    // Geometry Flags

    // When adding new flags, update GEOFLAG_ALL as well.

const int GEOFLAG_CONTAINS_EXTERNALLY_UPDATED_ELT = (1L << 0);
const int GEOFLAG_CONTAINS_OPACITY                = (1L << 1);
const int GEOFLAG_CONTAINS_LIGHTS                 = (1L << 2);

const int GEOFLAG_ALL                             = (1L << 3) - 1;


class ATL_NO_VTABLE Geometry : public AxAValueObj
{
  public:

    Geometry ();
    virtual ~Geometry() {}  // Needed to ensure proper hierachical destruction.

    // Collect all light sources in a geometry.
    virtual void CollectLights (LightContext &context) = 0;

    // Collect all sound sources in a geometry.
    virtual void  CollectSounds (SoundTraversalContext &context) = 0;

    // Pre derive all textures in scene graph to cached in
    // texturedGeometry classes
    virtual void  CollectTextures(GeomRenderer &device) = 0;

    // Using the ray in the context, intersect with the geometry, side
    // effecting the context as appropriate.
    virtual void  RayIntersect (RayIntersectCtx &context) = 0;

    // Produces a printed representation on the debugger.
    #if _USE_PRINT
        virtual ostream& Print(ostream& os) = 0;
    #endif

    // extract the bounding volume of the object.  By default, this is
    // the "all encompassing" bounding volume, that says nothing about
    // the true bounds of the geometry.  Subclasses that do things
    // differently will supply different bounding volumes.
    virtual Bbox3 *BoundingVol() = 0;

    // TODO: Because we don't have multiple dispatching, we may need
    // to add more methods here later as we come up with more
    // operations.  Or we may want to adopt multiple dispatching to
    // make the system more extensible for the addition of operations.

    virtual DXMTypeInfo GetTypeInfo() { return GeometryType; }

    virtual AxAValue ExtendedAttrib(char *attrib, VARIANT& val);

    VALTYPEID GetValTypeId() { return GEOMETRY_VTYPEID; }

    void SetCreationID(long t) { _creationID = t; }
    long GetCreationID() { return _creationID; }

    DWORD GetFlags (void);

  protected:
    DWORD _flags;
    long  _creationID;
};


inline DWORD Geometry::GetFlags (void)
{
    return _flags;
}


    // Print a representation of a representation to the debugger.

#if _USE_PRINT
    ostream& operator<< (ostream& os,  Geometry &geometry);
#endif

    // Wrap a bounding volume around a geometry.

Geometry *BoundedGeometry (Bbox3 *bvol, Geometry *geom);



/*****************************************************************************
This class can be subclassed to specify attribution data for a particular
geometry.  This superclass encompasses, for example, material, light and sound
attribution.
*****************************************************************************/

class AttributedGeom : public Geometry
{
  public:

    AttributedGeom (Geometry *geometry);

    // The Render() method may be invoked for several different reasons,
    // including sound start, sound stop, and 3D rendering.
    void Render (GenericDevice& device);

    // This method is used to do 3D rendering on the attributed geometry.
    virtual void Render3D (GeomRenderer&);

    // The default behavior for sound-rendering the attributed geometry is to
    // ignore the attribute and just render the geometry.  This case will be
    // used, for example, if color attributes are applied to the geometry.
    void CollectSounds (SoundTraversalContext &context);

    // The default case to collect the lights from the geometry is to ignore
    // the attribute and collect the lights from the geometry.  This should
    // happen when the attribute does not affect lights in any way (e.g.
    // specular color, or pitch).
    void CollectLights (LightContext &context);

    // Default is to collect textures in member geometry
    void  CollectTextures(GeomRenderer &device) {
        _geometry->CollectTextures(device);
    }

    // The default case for performing ray intersection simply ignores
    // the attribute and proceeds on the geometry.  This is
    // overridden by some attributes.
    void RayIntersect (RayIntersectCtx &context);

    // The default action for the BoundingVol method is to ignore the attribute
    // and just get the bounding volume of the geometry.  This applies for
    // attributes like diffuse color or pitch.
    virtual Bbox3 *BoundingVol (void);

    AxAValue _Cache(CacheParam &p);

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_geometry);
    }

  protected:

    Geometry *_geometry;     // The attributed geometry.
};



/*****************************************************************************
This structure is used to encapsulate the data needed to construct a TriMesh.
Note that only one of the float/Bvr pairs for each vertex property should be
non-null.
*****************************************************************************/

class TriMeshData
{
  public:

    TriMeshData (void)
        : numTris(0), numIndices(0), indices(NULL),
          numPos(0),  vPosFloat(NULL),  vPosPoint3(NULL),
          numNorm(0), vNormFloat(NULL), vNormVector3(NULL),
          numUV(0),   vUVFloat(NULL),   vUVPoint2(NULL)
    {
    }

    int    numTris;        // Number of Triangles in Mesh

    int    numIndices;     // Number of Triangle Vertex Indices
    int   *indices;        // Triangle Vertex Indices

    int    numPos;         // Number of Vertex Positions
    float *vPosFloat;      // Vertex Positions (array of Float Triple)
    Bvr   *vPosPoint3;     // Vertex Positions (array of Point3)

    int    numNorm;        // Number of Vertex Normals
    float *vNormFloat;     // Vertex Normals (array of Float Triple)
    Bvr   *vNormVector3;   // Vertex Normals (array of Vector3)

    int    numUV;          // Number of Vertex Surface Coords
    float *vUVFloat;       // Vertex Surface Coords (array of Float Tuple)
    Bvr   *vUVPoint2;      // Vertex Surface Coords (array of Point2)
};

Bvr TriMeshBvr (TriMeshData&);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\heaper.h ===
#ifndef _HEAPER_H
#define _HEAPER_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

__*/

#include <privinc/storeobj.h>

// This class is a sort of container for dynamic heaps (see storage.h)
// and it's primary use it to allow automatic destruction and construction
// of heaps (heap references actually) on the stack.  Before, if
// you allocate a heap and some function you call throws an exception
// your heap will not be deallocated.  But if you heap lives on the
// stack as an automatic variable, an exception unravels the stack
// and calls the destructor on your heap.
// It is the user's responsibility to ensure that the heap
// stack is consistent upon exit (i.e.: the heap is popped
// off)

class Heaper {

  public:
    Heaper(DynamicHeap *_heap, Bool del=FALSE) : heap(_heap), deleteOnExit(del) {}
    ~Heaper() { 
        if(heap != NULL)
            if(deleteOnExit==TRUE) delete heap; 
            else heap->Reset(TRUE);
    }

  private:               
    DynamicHeap *heap;
    Bool deleteOnExit;
};

#endif /* _HEAPER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\geomimg.h ===
#ifndef _GEOMIMG_H
#define _GEOMIMG_H


/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

Projected Geometry Image class declaration

-------------------------------------*/

#include <appelles/geom.h>
#include <privinc/geomi.h>

//////////////  Image from projected geometry  ////////////////////

class ProjectedGeomImage : public Image {
  public:

    ProjectedGeomImage(Geometry *g, Camera *cam);

    virtual void Render(GenericDevice& dev);

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        Transform2 *xf = bbctx.GetTransform();
        return TransformBbox2(xf, BoundingBox());
    }
#endif  // BOUNDINGBOX_TIGHTER

    const Bbox2 BoundingBox(void);
    
    // identity operation
    const Bbox2 OperateOn(const Bbox2 &box) { return box; }

    Bool  DetectHit(PointIntersectCtx& ctx);

#if _USE_PRINT
    ostream& Print (ostream &os) {
        return os << "ProjectedGeomImage (" << _geo << ", <TODO: CAMERA>)";
    }
#endif

    int Savings(CacheParam& p);

    virtual VALTYPEID GetValTypeId() { return PROJECTEDGEOMIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == ProjectedGeomImage::GetValTypeId() ||
                Image::CheckImageTypeId(type));
    }

    virtual void DoKids(GCFuncObj proc);

    AxAValue _Cache(CacheParam &p);
    
  protected:
    Geometry *_geo;
    Camera   *_camera;
    Bbox2     _bbox;
    bool      _bboxIsSet;
};


#endif /* _GEOMIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\gradimg.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _GRADIMG_H
#define _GRADIMG_H

extern Image *NewMulticolorGradientImage(int num, double *offsets, Color **clrs);

class MulticolorGradientImage : public Image {
  public:
    enum gradientType {
        radial,
        linear
    };
    
    friend Image *NewMulticolorGradientImage(
        int numOffsets,
        double *offsets,
        Color **clrs,
        MulticolorGradientImage::gradientType type);

  protected:
    ~MulticolorGradientImage() {
        DeallocateFromStore(_offsets);
        DeallocateFromStore(_clrs);
    }

    MulticolorGradientImage() {
        _flags |= IMGFLAG_CONTAINS_GRADIENT;
    }

    void PostConstructorInitialize(int num, double *offsets, Color **clrs)
    {
        _numOffsets = num;
        _offsets = offsets;
        _clrs = clrs;

        //Real extent = _offsets[_numOffsets-1];
        // TODO: hm... should this be universe bbox2 ??
        // if so, return universeBbox2 from BoundingBox(){}
        //_bbox = NEW Bbox2(-extent, -extent, extent, extent);
    }
    
  public:

    void Render(GenericDevice& dev) {
        ImageDisplayDev &idev = SAFE_CAST(ImageDisplayDev &, dev);
        idev.RenderMulticolorGradientImage(this, _numOffsets, _offsets, _clrs);
    }

    const Bbox2 BoundingBox(void) {
        //return _bbox;
        return UniverseBbox2;
    }

    #if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        //return _bbox;
        return UniverseBbox2;
    }
    #endif  // BOUNDINGBOX_TIGHTER

    const Bbox2 OperateOn(const Bbox2 &box) {
        return box;
    }

    Bool  DetectHit(PointIntersectCtx& ctx) {
        return TRUE;  // we're infinite extent!
    }

    int Savings(CacheParam& p) { return 2; }
    
    #if _USE_PRINT
    ostream& Print(ostream& os) { return os << "MulticolorGradientImage"; }
    #endif
    
    virtual void DoKids(GCFuncObj proc) {
        Image::DoKids(proc);
        for (int i=0; i<_numOffsets; i++) {
            (*proc)(_clrs[i]);
        }
    }

    // OK, I'm cheating here.  what *should* happen is the image
    // device gets passed down, the leaf ASKS the image device if IT
    // can render the leaf image clipped natively!
    virtual bool CanClipNatively() { return true; }


    virtual gradientType GetType()=0;
    
  private:
    //Bbox2 _bbox;
    int _numOffsets;
    Color **_clrs;
    double *_offsets;
};


class RadialMulticolorGradientImage : public MulticolorGradientImage {

    friend Image *NewMulticolorGradientImage(
        int numOffsets,
        double *offsets,
        Color **clrs,
        MulticolorGradientImage::gradientType type);
    
  private:
    RadialMulticolorGradientImage() {}
    
  public:
    gradientType GetType() { return MulticolorGradientImage::radial; }
};

class LinearMulticolorGradientImage : public MulticolorGradientImage {

    friend Image *NewMulticolorGradientImage(
        int numOffsets,
        double *offsets,
        Color **clrs,
        MulticolorGradientImage::gradientType type);

  private:
    LinearMulticolorGradientImage() {}

  public:
    gradientType GetType() { return MulticolorGradientImage::linear; }
};


#endif /* _GRADIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\helpaa.h ===
/**********************************************************************
AudioActive helped functions
**********************************************************************/
#ifndef _HELPAA_H
#define _HELPAA_H

#include <wtypes.h>
#include <msimusic.h>
#include "privinc/aadev.h"

// signature for fns we need to loadLibrary...
typedef HRESULT (WINAPI *SimpleInitFn) 
    (IAAEngine **engine, IAANotifySink *notifySink, IAALoader *loader);
typedef HRESULT (WINAPI *LoadSectionFn)
    (IAAEngine *engine, LPCTSTR pszFileName, IAASection **section);
typedef void (WINAPI *SetAAdebugFn) (WORD debugLevel);
typedef HRESULT (WINAPI *PanicFn) (IAAEngine *engine);

class AAengine {
  public:
    AAengine();
    ~AAengine();
    void SetRate(double rate);
    void SetGain(double gain);
    void Stop();
    void Pause();    // stop the realTime object
    void Resume();   // start/resume the realTime object
    void RegisterSink(IAANotifySink *sink);
    void LoadSectionFile(char *fileName, IAASection **section);
    void PlaySection(IAASection *section);
    void AllNotesOff();

  private:
    HINSTANCE       _aaLibrary;   // handle to aactive dll

    IAARealTime    *_realTime;
    //IClock       *_clock;
    IAAMIDIOut     *_MIDIout;
    // AudioActiveDev *_aadev;    // keep this around so we may return the eng
    IAAEngine      *_engine;
    double          _currentRate; // current rate being used
    Bool            _paused;      // determine playing but paused state rate(0)

    // fn pointers for msimusic entrypoints
    SimpleInitFn    _simpleInit;
    LoadSectionFn   _loadSectionFile;
    SetAAdebugFn    _setAAdebug;
    PanicFn         _panic;

    void SimpleInit();
    void LoadDLL(); // cause the msimusic dll to be loaded
};

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

// helper functions
void stopAAengine(IAAEngine *engine, AAFlags mode);
void registerAAsink(IAAEngine *realTime, IAANotifySink *sink);
void playAAsection(IAAEngine *engine, IAASection *section);
void setAArelTempo(IAARealTime *realTime, double tempo);
void setAArelVolume(IAARealTime *realTime, double volume);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */


#endif /* _HELPAA_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\helps.h ===
#ifndef _HELPS_H
#define _HELPS_H

#include <wtypes.h>
#include <math.h>
#include "privinc/util.h"

inline unsigned int
SecondsToBytes(Real seconds, int sampleRate,
               int numChannels, int bytesPerSample);

inline Real
FramesToSeconds(int frames, int sampleRate);


inline Real
BytesToSeconds(unsigned int bytes, int sampleRate,
               int numChannels, int bytesPerSample);

inline unsigned int
BytesToFrames(unsigned int bytes, int numChannels, int bytesPerSample);

inline unsigned int
SamplesToBytes(unsigned int samples, int numChannels, int bytesPerSample);

inline unsigned int
FramesToBytes(unsigned int frames, int numChannels, int bytesPerSample);

double LinearTodB(double linear);

double DBToLinear(double db);

class Pan {
  public:
    Pan(Pan *pan) : _direction(pan->GetDirection()),
        _dBmagnitude(pan->GetdBmagnitude()) {}
    Pan(double linearPan=0.0) { SetLinear(linearPan); }
    Pan(double dBmagnitude, int rightDirection) : _dBmagnitude(dBmagnitude),
        _direction(rightDirection) {}

    void SetPan(Pan *pan) { _direction   = pan->GetDirection();
                            _dBmagnitude = pan->GetdBmagnitude(); }

    int GetDirection() { return(_direction); }
    double GetdBmagnitude() { return(_dBmagnitude); }
    double GetLinear() 
        { return(_direction * -1.0 * (pow(10, _dBmagnitude/20.0) - 1.0)); }
    void SetLinear(double linearPan);
    void Add(Pan *pan) { SetLinear(pan->GetLinear() + GetLinear()); }

    void GetLRGain(double gainDb, double& lgainDb, double& rgainDb);

    // cheaper for reset than SetLinear(0.0)
    void SetMagnitude(double dBmagnitude, int rightDirection) {
        _dBmagnitude = dBmagnitude;
        _direction = rightDirection;
    }
    
  private:
    double _dBmagnitude;
    int    _direction;     // 1 if right facing, -1 if left
};

void
PanGainToLRGain(double pan, double gain,
                double& lgain, double& rgain);

void
SetPanGain(double lgainDb, double rgainDb, Pan& pan, double& gainDb);

#endif /* _HELPS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\helpq.h ===
#ifndef _HELPQ_H
#define _HELPQ_H

#include <windows.h>
#include <objbase.h>
#include <strmif.h>
#include "control.h"
#include <evcode.h>
#include <uuids.h>
#include "privinc/pcm.h"
#include "privinc/util.h"
#include "ddraw.h"
#include <amstream.h>
#include "privinc/hresinfo.h"
#include "privinc/mutex.h"
#include "privinc/ddsurf.h"
#include "ddraw.h"

typedef enum { MEDIASTREAM, ASTREAM, VSTREAM, AVSTREAM } StreamType;

// Use TDSOUND for checking DirectSound error return codes.
#if _DEBUG
    #define TQUARTZ(x) CheckReturnCode( x, __FILE__, __LINE__, true)
#else
    #define TQUARTZ(x) CheckReturnCode (x, true)
#endif

// handles the lone MIDI case where we allow amstream to render instead of
// deliver audio and video bits
class QuartzRenderer : public AxAThrowingAllocatorClass {
  public:
    QuartzRenderer();
    ~QuartzRenderer() { CleanUp(); }
    void Open(char *fileName);
    void CleanUp();
    void Play();
    void Pause();
    void Seek();
    void Stop();
    void SetRate(double rate);
    void SetGain(double gain);
    void SetPan(double  pan, int direction);
    double GetLength();
    bool QueryDone();
    void Position(double seconds);

  protected:
    int dBToQuartzdB(double dB);

  private:
    IGraphBuilder   *_MIDIgraph;     // pointer to the quartz MIDI graph
    IBasicAudio     *_audioControl;  // used to control the rate, pan, etc.
    IMediaControl   *_mediaControl;  // used to control start/stop, etc.
    IMediaPosition  *_mediaPosition; // used to set rate/phase
    HANDLE          *_oaEvent;
    IMediaEventEx   *_mediaEvent;
    TimeClass        _time;          // handy for time conversions

    bool             _rate0paused;   // have we paused for rate 0 emulation
    bool             _playing;       // are we requested to be playing
};


// class which knows how to instantiate an amstream multimedia stream!
class QuartzMediaStream : public AxAThrowingAllocatorClass {
  public:
    QuartzMediaStream();
    virtual ~QuartzMediaStream() { CleanUp(); }
    virtual bool SafeToContinue()      = 0;

  protected:
    void CleanUp();
    IAMMultiMediaStream *_multiMediaStream;
    IAMClockAdjust      *_clockAdjust;
};


// contains the stuff common to audio and video quartz readers
class QuartzReader : public AxAThrowingAllocatorClass {
  public:
    QuartzReader(char *url, StreamType streamType);
    virtual ~QuartzReader() { CleanUp(); }
    virtual void Release();
    virtual void CleanUp();
    double  GetDuration();
    bool    IsInitialized() { return(_initialized); }
    bool    IsDeleteable()  { return(_deleteable);  }
    void    SetDeleteable(bool deleteable) { _deleteable= deleteable; }
    PCM     pcm;
    void    AddReadTime(double addition)   { _secondsRead+=addition;  }
    double  GetSecondsRead()               { return(_secondsRead);    }
    virtual bool SafeToContinue() { return(true); }
            bool Stall();  // self resetting!
            void SetStall();
    virtual void Disable() = 0;
    char    *GetURL()          { return(_url);                                 }
    WCHAR   *GetQURL()         { return(_qURL);                                }
    long    GetNextFrame()     { return(_nextFrame);                           }
    StreamType GetStreamType() { return(_streamType);                          }
    void    Run()              { _multiMediaStream->SetState(STREAMSTATE_RUN); }
    bool    QueryPlaying();

    virtual bool AlreadySeekedInSameTick() { return false; }
    virtual void SetTickID(DWORD id) {}

  protected:
    IAMMultiMediaStream *_multiMediaStream; // don't delete, we are sharing it!
    IAMClockAdjust      *_clockAdjust;      // don't delete, we are sharing it!
    IMediaStream        *_mediaStream;
    bool                 _initialized;
    bool                 _deleteable;
    double               _secondsRead;
    bool                 _stall;    // set if a read stalls
    Mutex                _readerMutex;
    char                *_url;
    WCHAR               *_qURL;
    long                 _nextFrame;
    StreamType           _streamType;
};


// knows how to read audio out of amstream
class QuartzAudioReader : public QuartzReader {
  public:
    QuartzAudioReader(char *url, StreamType streamType);
    virtual ~QuartzAudioReader() { CleanUp(); }
    virtual void     Release();
    virtual int      ReadFrames(int numSamples, unsigned char *buffer, 
        bool blocking=false);
    void     SeekFrames(long frames);
    bool     AudioInitReader(IAMMultiMediaStream *_multiMediaStream,
                             IAMClockAdjust *_clockAdjust);
    bool     Completed() { return(_completed); }
    virtual void Disable();

    virtual void InitializeStream() {}

  protected:
    void     CleanUp();

  private:
    IAudioData          *_audioData;
    IAudioMediaStream   *_audioStream;
    IAudioStreamSample  *_audioSample;
    bool                 _completed;
};


class AVquartzAudioReader : public QuartzAudioReader
{
  public:
    AVquartzAudioReader(char *url, StreamType streamType) : 
        QuartzAudioReader(url, streamType) {}
    virtual int      ReadFrames(int numSamples, unsigned char *buffer, 
        bool blocking=false);
};


// knows how to read video out of amstream
class QuartzVideoReader : public QuartzReader {
  public:
    QuartzVideoReader(char *url, StreamType streamType);
    ~QuartzVideoReader() { CleanUp(); }
    bool   VideoSetupReader(IAMMultiMediaStream *multiMediaStream,
                            IAMClockAdjust      *clockAdjust, 
                            DDSurface           *surface, 
                            bool                 mode);
    virtual void Release();
    virtual void Disable();

    void Seek(double time);

    long GetHeight() { return _height; } // prefered pixel dimensions
    long GetWidth()  { return _width;  }
    virtual HRESULT     GetFrame(double time, IDirectDrawSurface **ppSurface);
    virtual bool        SafeToContinue() { return(true);          }

  protected:
    void UpdateTimes(bool bJustSeeked, STREAM_TIME SeekTime);
    void CleanUp(); // releases all com objects

    void                     VideoInitReader(DDPIXELFORMAT pixelFormat);

  private:
    IDirectDrawMediaStream  *_ddrawStream;
    long                     _height, _width;
    bool                     _async;
    bool                     _seekable;
    HRESULT                  _hrCompStatus;
    IDirectDrawSurface      *_ddrawSurface;

    bool                     _curSampleValid;
    STREAM_TIME              _curSampleStart;
    STREAM_TIME              _curSampleEnd;

    IDirectDrawStreamSample *_ddrawSample;
    DDSurfPtr<DDSurface>     _surface;
};


class AVquartzVideoReader : public QuartzVideoReader
{
  public:
    AVquartzVideoReader(char *url, StreamType streamType) : 
        QuartzVideoReader(url, streamType) {}
    virtual HRESULT GetFrame(double time, IDirectDrawSurface **ppSurface);
};


class QuartzAVstream : public QuartzMediaStream,
    public AVquartzAudioReader, public AVquartzVideoReader {
  public:
    virtual void    Release();
    virtual bool    SafeToContinue();
    virtual int     ReadFrames(int numSamples, unsigned char *buffer, 
        bool blocking=false);
    virtual HRESULT GetFrame(double time, IDirectDrawSurface **ppSurface);

    // XXX really should pass in latentcy with a default!
    QuartzAVstream(char *url);
    virtual ~QuartzAVstream() { CleanUp(); }
    bool GetAudioValid(){return(_audioValid);}
    bool GetVideoValid(){return(_videoValid);}

#if _DEBUGMEM
    void *operator new(size_t s, int blockType, char * szFileName, int nLine) {
        return(QuartzMediaStream::operator new(s, blockType, szFileName, nLine)); 
    }
#else
    void *operator new(size_t s) { return(QuartzMediaStream::operator new(s)); }
#endif

    // need to init the video first before priming sound buffer
    // for SetPixelFormat
    virtual void InitializeStream();

    // this is to ensure we only seek once per tick
    virtual bool AlreadySeekedInSameTick();
    virtual void SetTickID(DWORD id);

  private:
    void CleanUp(); // releases all com objects
    Mutex _avMutex;
    DWORD _tickID, _seeked;
    bool  _audioValid, _videoValid;
};


class QuartzAudioStream : public QuartzMediaStream, public QuartzAudioReader {
  public:
    // XXX really should pass in latentcy with a default!
                   QuartzAudioStream(char *url);
    virtual       ~QuartzAudioStream();
    virtual void   Release();
    virtual bool   SafeToContinue() { return(true); } // XXX obsolete
    virtual int    ReadFrames(int numSamples, unsigned char *buffer, 
                       bool blocking);
#if _DEBUGMEM
    void *operator new(size_t s, int blockType, char * szFileName, int nLine) {
        return(QuartzMediaStream::operator new(s, blockType, szFileName, nLine)); 
    }
#else
    void *operator new(size_t s) { return(QuartzMediaStream::operator new(s)); }
#endif

  private:
    void CleanUp(); // releases all com objects
};


class QuartzVideoStream : public QuartzMediaStream, public QuartzVideoReader {
  public:
    QuartzVideoStream(char *url, bool seekable = false) :
        QuartzVideoReader(url, VSTREAM), QuartzMediaStream(), _ddraw(NULL)
        { Initialize(url, NULL, seekable); }

    QuartzVideoStream(char *url, DDSurface *surface, bool seekable = false) :
        QuartzVideoReader(url, VSTREAM), QuartzMediaStream(), _ddraw(NULL)
        { Initialize(url, surface, seekable); }

    virtual ~QuartzVideoStream() { CleanUp(); }
    virtual void   Release();
    virtual bool   SafeToContinue() { return(true); }

#if _DEBUGMEM
    void *operator new(size_t s, int blockType, char * szFileName, int nLine) {
        return(QuartzMediaStream::operator new(s, blockType, szFileName, nLine)); 
    }
#else
    void *operator new(size_t s) { return(QuartzMediaStream::operator new(s)); }
#endif

  private:
    void Initialize(char *url, DDSurface *surface, bool seekable);
    IDirectDraw *_ddraw;
    void CleanUp(); // releases all com objects
};

bool QuartzAVmodeSupport(); // check for post 4.0.1 amstream support of clockadjust

#endif /* _HELPQ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\hresinfo.h ===
#ifndef _HRESINFO_H
#define _HRESINFO_H
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Convert HRESULT to English error string.  Only used in DEBUG builds

*******************************************************************************/

#include "winerror.h"

#if DEVELOPER_DEBUG 

        // Error Information Structure

    struct HresultInfo
    {   HRESULT  hresult;       // HRESULT Value
        char    *hresult_str;   // HRESULT Macro As String
        char    *explanation;   // Explanation String
    };

        // Error Information Query

    HresultInfo *GetHresultInfo (HRESULT code);

#endif

    // HRESULT standard check routine.  If HRESULT indicates error, this
    // function decodes the value and throws an exception if except is true
    // or just dumps the result to the debug output stream if except is false.

#if _DEBUG

    HRESULT CheckReturnImpl (HRESULT, char *file, int line, bool except);

    inline HRESULT CheckReturnCode (HRESULT H, char *F, int L, bool E=false)
    {   if (FAILED(H)) CheckReturnImpl (H,F,L,E);
        return H;
    }

#else

    HRESULT CheckReturnImpl (HRESULT, bool except);

    inline HRESULT CheckReturnCode (HRESULT H, bool E=false)
    {   if (FAILED(H)) CheckReturnImpl (H,E);
        return H;
    }

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\helpds.h ===
#ifndef _HELPDS_H
#define _HELPDS_H

#include <wtypes.h>
#include <dsound.h>
#include "privinc/mutex.h"
#include "privinc/hresinfo.h"
#include "privinc/dsdev.h"
#include "privinc/pcm.h"
#include "privinc/util.h"    // TIME_DSOUND
#include "privinc/server.h"  // GetCurrentTimers
#include "privinc/htimer.h"  // TimeStamp


// Use TDSOUND for checking DirectSound error return codes.
#if _DEBUG
    #define TDSOUND(x) TIME_DSOUND (CheckReturnCode(x,__FILE__,__LINE__,true))
#else
    #define TDSOUND(x) TIME_DSOUND (CheckReturnCode (x,true))
#endif

class DirectSoundProxy;

class DSbuffer : public AxAThrowingAllocatorClass {
  public:
    PCM pcm;
    DSbuffer() {initialize();}
    virtual ~DSbuffer();
    void initialize();  // NOTE: must be called after wavSampleRate is set!
    void updateStats();

    void writeBytes(void *buffer, int bytes);
    void writeFrames(void *buffer, int frameCount) {
        writeBytes(buffer, pcm.FramesToBytes(frameCount)); }

    void writeSilentBytes(int byteCount);
    void writeSilentFrames(int frameCount){
        writeSilentBytes(pcm.FramesToBytes(frameCount)); }

    // queries
    int bytesFree();
    int framesFree() { return(pcm.BytesToFrames(bytesFree())); }

    //int isPlaying(){return(playing);}
    int isPlaying();
    Real getMediaTime();
    int getSampleRate() { return(pcm.GetFrameRate()); }
    IDirectSoundBuffer *getBuffer() { return(_dsBuffer); }
    int TotalFrames() { return(pcm.GetNumberFrames()); }

    // controls
    void SetGain(double gain);
    void SetPan(double pan, int direction);
    void setPitchShift(int frequency);
    virtual void setPtr(int bytePosition);
    void play(int loop);
    void stop();

    static int _minDSfreq;
    static int _maxDSfreq;
    static int _minDSpan;
    static int _maxDSpan;
    static int _minDSgain;
    static int _maxDSgain;

    // misc
#if _DEBUG
    void printBufferCapabilities();
#endif

    IDirectSoundBuffer *_dsBuffer; // the sound's dsBuffer (2ndry, or duplicate)
    static int canonicalSampleRate;
    static int canonicalSampleBytes;

    BOOL  _allocated;              // has the buffer been allocated
    BOOL   playing;                // has the sound buffer been Played yet?
    BOOL   duplicate;              // secondary buffer or a duplicate
    BOOL  _paused;                 // this is needed to dissambiguate ended
    int   _loopMode;               // so we know what loopmode to restore
    int   _flushing;               // how many frames flushed in flush mode

    DWORD  tail;  // XXX move this to the streaming buffer!

    int    outputFrequency;

    int    _currentAttenuation;
    int    _currentFrequency;
    double _currentPan;

  protected:
    void CreateDirectSoundBuffer(DirectSoundProxy *dsProxy, bool primary);
    void CopyToDSbuffer(void *frames, int tail, int numBytes); 
    void ClearDSbuffer(int numBytes, char value);
    int  dBToDSounddB(double dB);

  private:
    void FillDSbuffer(int tail, int numBytes, char value);

    // buffer statistics (used to keep track of the media time)
    Bool     _firstStat;
    int      _lastHead;           // position of the head ptr on the last poll
    LONGLONG _bytesConsumed;      // frames consumed by dsound so far
    Mutex    _byteCountLock;      // mutex protecting the stats!
};


class DSstreamingBuffer : public DSbuffer {
  public:
    DSstreamingBuffer(DirectSoundProxy *dsProxy, PCM *pcm);
};


class DSprimaryBuffer : public DSbuffer {
  public:
    DSprimaryBuffer(HWND hwnd, DirectSoundProxy *dsProxy);
};


class DSstaticBuffer : public DSbuffer {
  public:
    // standard
    DSstaticBuffer(DirectSoundProxy *dsProxy, PCM *pcm, unsigned char *bufr);

    // duplicate
    DSstaticBuffer(DirectSoundProxy *dsProxy, IDirectSoundBuffer *dsBuffer);

    DirectSoundProxy *GetDSProxy() { return _dsProxy; }

    virtual void setPtr(int bytePosition);

    void   ResetTimeStamp() { _timeStamp.Reset(); }
    double GetAge()         { return(_timeStamp.GetAge()); }
    
  private:
    DirectSoundProxy *_dsProxy;
    TimeStamp         _timeStamp; // not initialized till first use
};


extern "C" {

// helper functions

// XXX move this to the device class dsdev!
#if _DEBUG
void printDScapabilities(DirectSoundProxy *dsProxy);
#endif


void
DSbufferCapabilities(DirectSoundProxy *dsProxy, int *channels,
    int *sampleBytes,  int *sampleRate);

}   //extern "C"


#endif /* _HELPDS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\htimer.h ===
#ifndef _HTIMER_H
#define _HTIMER_H

/*-------------------------------------

Copyright (c) 1996-98 Microsoft Corporation

Abstract:

    HiresTimer Class

-------------------------------------*/

#include "privinc/util.h" // GetPerfTimeCount, Tick2Sec

class ATL_NO_VTABLE HiresTimer : public AxAThrowingAllocatorClass
{
  public:
    HiresTimer() {}
    virtual ~HiresTimer() {}
    virtual double GetTime()      = 0;
    virtual double GetFrequency() = 0;
    virtual void   Reset()        = 0;
};


HiresTimer& CreateHiresTimer();


class TimeStamp
{
  public:
    TimeStamp() : _timeStamp(-1.0) {} // initialy set to 'illegal value'
    void   Reset();          // resets timestamp to present time
    double GetTimeStamp();
    double GetAge();

  private:
    //double GetCurrentTime() { return(Tick2Sec(GetPerfTickCount())); }
    double GetCurrentTime() { return(GetLastSampleTime()); }
    double _timeStamp;
};

#endif /* _HTIMER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\importgeo.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

Abstract:

    header containing classes needed for geometry importation

Revision:

--*/

#ifndef _IMPORTGEO_H_
#define _IMPORTGEO_H_

#include "privinc/vec2i.h"
#include "privinc/vec3i.h"

//-------------------------------------------
// info needed to apply texture wraps 
// to imported geometry 
//-------------------------------------------
class TextureWrapInfo {
  public:
    LONG            type;
    Point3Value     origin;
    Vector3Value    z,
                    y;
    Point2          texOrigin;
    Vector2         texScale;
    bool            relative;
    bool            wrapU;
    bool            wrapV;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\imagei.h ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Specify generic image class and operations.

--*/

#ifndef _IMAGEI_H
#define _IMAGEI_H

#include "appelles/image.h"
#include "privinc/storeobj.h"
#include "privinc/except.h"
#include "privinc/vec2i.h"
#include "privinc/bbox2i.h"


// forward decls
class ImageDisplayDev;
class PointIntersectCtx;
class DiscreteImage;
class Bbox2Ctx;

////////////////////////////
//     The Image type     //
////////////////////////////

class DisjointCalcParam;
class DirtyRectCtx;

// Image flags
#define IMGFLAG_CONTAINS_OVERLAY                      (1L << 0)
#define IMGFLAG_CONTAINS_DESIRED_RENDERING_RESOLUTION (1L << 1)
#define IMGFLAG_CONTAINS_PICK_DATA                    (1L << 2)
#define IMGFLAG_CONTAINS_EXTERNALLY_UPDATED_ELT       (1L << 3)
#define IMGFLAG_CONTAINS_OPACITY                      (1L << 4)
#define IMGFLAG_CONTAINS_UNRENDERABLE_WITH_BOX        (1L << 5)
#define IMGFLAG_IS_RENDERABLE                         (1L << 6)
// HACK!!  This one is pretty hacky... used because caching gradient
// images (when used as textures) is faulty, so we want to find out if
// the image contains a gradient until we can fix this problem.
#define IMGFLAG_CONTAINS_GRADIENT                     (1L << 7)


// Without multiple dispatching, this class will need to be extended
// with methods to render on different types of devices.
class ATL_NO_VTABLE Image : public AxAValueObj {
  public:

    class TraversalContext
    {
      public:
        TraversalContext() {
            Reset();
        }
        void Reset() {
            _other = _solidMatte = _line = false;
        }

        void SetContainsOther() { _other = true; }
        void SetContainsSolidMatte() { _solidMatte = true; }
        void SetContainsLine() { _line = true; }

        bool ContainsOther() { return _other; }
        bool ContainsLine() { return _line; }
        bool ContainsSolidMatte() { return _solidMatte; }
        
        bool _other;
        bool _solidMatte;
        bool _line;
    };
    
    Image();

    // Extract a bounding box from this image, outside of which
    // everything is transparent.
    virtual const Bbox2 BoundingBox(void) = 0;

    virtual const Bbox2 _BoundingBox() { return NullBbox2; }

    // Return the areas of all the individual bboxes of the image.
    // Note this is different than the area of the bbox of the image
    // itself.  That is, for (a over b), we want area(a) + area(b),
    // and not area(a over b).  The default method just calls bbox and
    // gets area on it.  Overlay's override.
    virtual Real DisjointBBoxAreas(DisjointCalcParam &param);

    // Collect up dirty rectangles in the tree.

    // This is the method that users and implementations should call, but
    // shouldn't implement.  Note that it's a static so people won't
    // override it.
    static void CollectDirtyRects(Image *img, DirtyRectCtx &ctx);

    #if BOUNDINGBOX_TIGHTER
        virtual const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) = 0;
    #endif  // BOUNDINGBOX_TIGHTER

    // apply whatever to a bbox
    virtual const Bbox2 OperateOn(const Bbox2 &box) = 0;

    // Process an image for hit detection
    virtual Bool  DetectHit(PointIntersectCtx& ctx) = 0;

    virtual void DoKids(GCFuncObj proc);

    // Is this either a pure bitmap or a transformed bitmap.  This is
    // needed for some texture mapping optimizations.  If it is a pure
    // or transformed bitmap, the return value will be that bitmap,
    // else NULL.  If it is a pure bitmap, theXform will be filled
    // with NULL, else if it is a transformed bitmap, it will be
    // filled with the transform applied to the bitmap.
    virtual DiscreteImage *IsPurelyTransformedDiscrete(Transform2 **theXform) {
        return NULL;
    }

    // OK, I'm cheating here.  what *should* happen is the image
    // device gets passed down, the leaf ASKS the image device if IT
    // can render the leaf image clipped natively!
    virtual bool CanClipNatively() { return false; }
    
    // Print a representation to a stream.

    #if _USE_PRINT
        virtual ostream& Print(ostream& os) = 0;
    #endif

    virtual Bool GetColor(Color **color) { return FALSE; }

    // Some images are logical images that aren't renderable...
    Bool IsRenderable() {
        return _flags & IMGFLAG_IS_RENDERABLE;
    }

    // each image has an opacity... opacities float up.
    Real GetOpacity() { return _opacity; }
    void SetOpacity(Real op) { _opacity = op; }

    virtual int Savings(CacheParam& p) { return 0; }
    virtual AxAValue _Cache(CacheParam &p);

    virtual DXMTypeInfo GetTypeInfo() { return ImageType; }

    virtual AxAValue ExtendedAttrib(char *attrib, VARIANT& val);
    
    virtual VALTYPEID GetValTypeId() { return IMAGE_VTYPEID; }

    virtual bool CheckImageTypeId(VALTYPEID type) {
        return type == Image::GetValTypeId();
    }

    virtual bool ContainsOcclusionIgnorer() {
        return false;
    }

    void SetCreationID(long t) { _creationID = t; }
    long GetCreationID() { return _creationID; }

    void SetOldestConstituentID(long t) { _oldestConstituentSampleId = t; }
    long GetOldestConstituentID() { return _oldestConstituentSampleId; }

    DWORD GetFlags() { return _flags; }

    Image *GetCachedImage() { return _cachedImage; }
    void   SetCachedImage(Image *im) { _cachedImage = im; }

    void ExtractRenderResolution(short *width,
                                 short *height,
                                 bool   negOne);

    inline long Id(void) { return _id; }

    virtual void Traverse(TraversalContext &ctx) {
        ctx.SetContainsOther();
    }
    
  protected:

    static long _id_next;  // ID Generator
           long _id;       // Per-Image Unique Identifier

    // This should never be called directly, but it is what subclasses
    // should implement;
    virtual void _CollectDirtyRects(DirtyRectCtx &ctx);

    void SetIsRenderable(Bool r) {
        if (r) {
            _flags |= IMGFLAG_IS_RENDERABLE;
        } else {
            _flags &= ~IMGFLAG_IS_RENDERABLE;
        }
    }

    Real  _opacity;
    DWORD _flags;
    long  _creationID;
    long  _oldestConstituentSampleId;

    unsigned short _desiredRenderingWidth;
    unsigned short _desiredRenderingHeight;

    Image *_cachedImage;
};


//////////////  UNRenderable Image ////////////////////
class UnrenderableImage : public Image {
  public:
    // setting opacity to 0 guarantees this won't be
    // rendered.
    UnrenderableImage() {
        SetIsRenderable(FALSE);
    }

    // Has no bounding box
    virtual const Bbox2 BoundingBox(void) { return NullBbox2; }
#if BOUNDINGBOX_TIGHTER
    virtual const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) { return NullBbox2; }
#endif  // BOUNDINGBOX_TIGHTER

    virtual const Bbox2 OperateOn(const Bbox2 &box) { return box; }

    // This image is never hit
    virtual Bool  DetectHit(PointIntersectCtx& ctx) { return FALSE; }

    virtual void Render(GenericDevice& dev) {}

#if _USE_PRINT
    virtual ostream& Print(ostream& os) = 0;
#endif

    // important to leave this here because it overrides base class's
    // definition and NOT setting something in the context is important
    virtual void Traverse(TraversalContext &ctx) {}
};


//////////////  Attributed Image *////////////////////

// Attributed images always consist of an image and some
// attribution information.  Thus, methods can have default bvr that
// can be overridden.

class AttributedImage : public Image {
  public:
    AttributedImage(Image *image);
    virtual void Render(GenericDevice& dev);

    // ---
    // These methods all delegate to the image.  They can all be
    // overridden in subclasses.
    // ---

    // Extract a bounding box from this image, outside of which
    // everything is transparent.
    virtual const Bbox2 BoundingBox(void);
    virtual Real DisjointBBoxAreas(DisjointCalcParam &param);
    void _CollectDirtyRects(DirtyRectCtx &ctx);

#if BOUNDINGBOX_TIGHTER
    virtual const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx);
#endif  // BOUNDINGBOX_TIGHTER

    // Process an image for hit detection
    virtual Bool   DetectHit(PointIntersectCtx& ctx);

    virtual int Savings(CacheParam& p);
    virtual AxAValue _Cache(CacheParam &p);

    // This, by default, just returns the box.  Certain classes will
    // override.
    const Bbox2 OperateOn(const Bbox2 &box);

    virtual void DoKids(GCFuncObj proc);

    bool ContainsOcclusionIgnorer();

    inline Image *GetUnderlyingImage() { return _image; }


    virtual bool CanClipNatively() {
        return _image->CanClipNatively();
    }

    virtual void Traverse(TraversalContext &ctx) {
        _image->Traverse(ctx);
    }

  protected:
    Image *_image;
};

//
// O P A Q U E   I M A G E   C L A S S
//
class OpaqueImageClass : public AttributedImage {
  public:

    OpaqueImageClass(Real o, Image *img)
        : AttributedImage(img) {
            //
            // Our opacity is the composition of the underlying
            // image's opacity and the given opacity
            //
            SetOpacity( o * img->GetOpacity() );

            _flags |= IMGFLAG_CONTAINS_OPACITY;

        }

    //
    // the logic for opaque rendering is implemented in OverlayedImage
    // because we need the opacity value to float to the top (up to an
    // overlay branch) since it should be the last opearation performed
    // when compositing images and since opacity is implicitly a tertiary
    // operations: (opacity, image1, image2) where image1 is partly
    // transparent and lets you see image2 which is underneath.
    //
    // this method is implemented in the superclass
    //virtual void Render(GenericDevice& dev)

#if _USE_PRINT
    // Print a representation to a stream.
    ostream& Print(ostream& os) {
        return os << "OpaqueImageClass" << _opacity << _image;
    }
#endif

    int Savings(CacheParam& p) { return 0; }   /* never cache opaque images */

    virtual VALTYPEID GetValTypeId() { return OPAQUEIMAGE_VTYPEID; }

    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == OpaqueImageClass::GetValTypeId() ||
                AttributedImage::CheckImageTypeId(type));
    }
};

Image *LineImageConstructor(LineStyle *style, Path2 *path);

// This calls _BoundingBox if cached is false, set cached, stashed the
// bbox points into cachedBox.  It returns a new Bbox2 of the same
// value of cachedBox.
// TODO: This is temp until we deal with the sharing issues later
const Bbox2 CacheImageBbox2(Image *img, bool& cached, Bbox2 &cachedBox);

Image *CacheHelper(Image *imgToCache, CacheParam &p);


// These are the internal versions of functions that build objects, that take
// lightweight types instead of the heavy AxAValue-based types coming from the
// behavior layer.

Image *CreateCropImage(const Point2 &, const Point2 &, Image *);


#endif /* _IMAGEI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\ipc.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _IPC_H
#define _IPC_H

#define DAT_TERMINATE 0xffffffff

extern UINT DAMessageId;

#pragma warning(disable:4200)  

class DAIPCWorker :
    public AxAThrowingAllocatorClass
{
  public:
    DAIPCWorker() : _hwnd(NULL) {}
    ~DAIPCWorker() { DetachFromThread(); }
    
    bool AttachToThread();
    void DetachFromThread();

    bool IsAttached() { return _hwnd != NULL; }
    
    bool SendAsyncMsg(DWORD dwMsg, DWORD dwNum = 0, ...) {
        va_list args;
        va_start(args, dwNum);

        return SendMsg(dwMsg, 0, dwNum, args);
    }
    
    bool SendSyncMsg(DWORD dwMsg,
                     DWORD dwTimeout = INFINITE,
                     DWORD dwNum = 0, ...) {
        va_list args;
        va_start(args, dwNum);

        return SendMsg(dwMsg, dwTimeout, dwNum, args);
    }

    ULONG AddRef() { return InterlockedIncrement(&m_cRef); }
    ULONG Release() {
        ULONG ul = InterlockedDecrement(&m_cRef) ;
        if (ul == 0) delete this;
        return ul;
    }
  protected:
    long m_cRef;
    HWND _hwnd;
    DWORD _dwThreadId;
    class DAIPCPacket {
      public:
        DAIPCPacket() : _cRef(1) {}
        ~DAIPCPacket() { if (_hSync) CloseHandle(_hSync); }
        
        ULONG AddRef() { return InterlockedIncrement(&_cRef); }
        ULONG Release() {
            LONG l = InterlockedDecrement(&_cRef) ;
            Assert (l >= 0);
            
            if (l == 0) delete this;
            return (ULONG) l;
        }

        bool Init(DWORD dwMsg, bool sync = false) {
            Assert (_dwMsg == 0);
            
            _dwMsg = dwMsg;

            Assert (_hSync == NULL);
            
            if (!sync) return true;
            
            _hSync = CreateEvent(NULL,TRUE,FALSE,NULL);

            return (_hSync != NULL);
        }

        void *operator new(size_t s, DWORD dwNumParams)
        {
            DWORD size = s + (sizeof(DWORD) * dwNumParams);
            
            DAIPCPacket * p = (DAIPCPacket *) ThrowIfFailed(malloc(size));
            if (p) {
                ZeroMemory(p,size);
                p->_dwNum = dwNumParams;
            }

            return p;
        }

        void *operator new(size_t s) { return operator new(s,0); }
        
        void  operator delete(void *p) { free(p); }

        // Accessors
        DWORD GetMsg() { return _dwMsg; }
        HANDLE GetSync() { return _hSync; }
        DWORD GetNumParam() { return _dwNum; }
        DWORD_PTR * GetParams() { return _dwParams; }
        DWORD_PTR & GetParam(int i) { Assert (i < _dwNum); return _dwParams[i]; }

        DWORD_PTR & operator[](int i) { return GetParam(i); }
        bool IsSync() { return _hSync != NULL; }
      protected:
        LONG       _cRef;        // The reference count
        DWORD      _dwMsg;       // The message to send
        HANDLE     _hSync;       // If non-null the event to signal on completion
        DWORD      _dwNum;       // The number of parameters
        DWORD_PTR  _dwParams[];  // The parameter array

    };

    // This is the main function for processing messages
    // override this to change how messages are dispatched or to
    // process messages before they are dispatched
    
    virtual bool IPCProc (HWND hwnd,
                          UINT msg,
                          WPARAM wParam,
                          LPARAM lParam,
                          LRESULT & res);

    // The main message processing routine.  Each class should
    // override this and process messages as needed
    virtual void ProcessMsg(DWORD dwMsg,
                            DWORD dwNumParams,
                            DWORD_PTR dwParams[]) {}

    // This will ensure the packet is deleted
    bool SendPacket(DAIPCPacket & packet,
                    DWORD dwTimeout);
    bool SendMsg(DWORD dwMsg,
                 DWORD dwTimeout,
                 DWORD dwNum,
                 va_list args);
    
    DAIPCPacket * MakePacket(DWORD dwMsg,
                             bool bSync,
                             DWORD dwNum,
                             va_list args);
#if DEVELOPER_DEBUG
    virtual char * GetName() { return "DAIPCWorker"; }
#endif

  public:
    static LRESULT CALLBACK WindowProc (HWND   hwnd,
                                        UINT   msg,
                                        WPARAM wParam,
                                        LPARAM lParam);
};

class DAThread :
    public DAIPCWorker
{
  public:
    DAThread();
    ~DAThread();

    // Returns true if successful
    bool Start();

    // Return true if the process terminated w/o being forced
    bool Stop() { return Terminate(false); }
    void Kill() { Terminate(true); }
    
    bool Terminate(bool bKill);

    bool IsStarted() { return IsAttached(); }
  protected:
    HANDLE _hThread;                // The thread handle
    DWORD _dwThreadId;              // The thread id

    // We need to ensure the message queue is created before we can
    // communicate with the thread (since one is not created until a
    // PeekMessage is done from the new thread).  This is freed as
    // soon as the thread signals is and so is only temporary.
    
    HANDLE _hMsgQEvent;

    // This is set to true to indicate that the worker is currently
    // handling a work request which may take some time but will
    // immediately check for termination when complete.
    
    bool _bDoingWork;
    
    // The entry point for the worker thread
    virtual int workerRoutine();

    virtual bool InitThread();
    virtual bool DeinitThread();

    static int DAWorker(DAThread * t) { Assert(t); return t->workerRoutine(); }

#if DEVELOPER_DEBUG
    virtual char * GetName() { return "DAThread"; }
#endif
    static bool AddRefDLL();
    static void ReleaseDLL();
};

extern DAThread * GetCurrentDAThread();

#pragma warning(default:4200)  

#endif /* _IPC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\linei.h ===
#ifndef _LINEI_H
#define _LINEI_H


/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

-------------------------------------*/

#include <appelles/linestyl.h>
#include <privinc/colori.h>
#include "dartapi.h"
/*
This is now defined in  src/prims/dartapipost.h

typedef enum  {
    es_Round  = PS_ENDCAP_ROUND,  // 0x00000000
    es_Square = PS_ENDCAP_SQUARE, // 0x00000100
    es_Flat   = PS_ENDCAP_FLAT    // 0x00000200
    } EndStyleEnum;

typedef enum  {
    js_Round = PS_JOIN_ROUND,  // 0x00000000
    js_Bevel = PS_JOIN_BEVEL,  // 0x00001000
    js_Miter = PS_JOIN_MITER   // 0x00002000
    } JoinStyleEnum;

typedef enum  {
    ds_Solid        = PS_SOLID,     // 0
    ds_Dashed       = PS_DASH,      // 1
    ds_Dot          = PS_DOT,       // 2
    ds_Dashdot      = PS_DASHDOT,   // 3
    ds_Dashdotdot   = PS_DASHDOTDOT,// 4
    ds_Null         = PS_NULL,      // 5
} DashStyleEnum;
*/

#if 0
/* Pen Styles */
#define PS_SOLID            0
#define PS_DASH             1       /* -------  */
#define PS_DOT              2       /* .......  */
#define PS_DASHDOT          3       /* _._._._  */
#define PS_DASHDOTDOT       4       /* _.._.._  */
#define PS_NULL             5
#define PS_INSIDEFRAME      6
#define PS_USERSTYLE        7
#define PS_ALTERNATE        8
#define PS_STYLE_MASK       0x0000000F
#endif

#define STYLE_CLASS(_type_)  \
class _type_##Style : public AxAValueObj { \
  public:                                 \
    _type_##Style(_type_##StyleEnum style) : _style(style) {}    \
    _type_##StyleEnum _style;                                     \
\
    virtual DXMTypeInfo GetTypeInfo() { return _type_##StyleType; }\
};

STYLE_CLASS(End)

STYLE_CLASS(Join)

STYLE_CLASS(Dash)


class LineStyle : public AxAValueObj {
  public:

    LineStyle() {}

    virtual DashStyleEnum GetDashStyle() { return ds_Solid; }
    virtual EndStyleEnum GetEndStyle()  { return es_Flat; }
    virtual JoinStyleEnum GetJoinStyle() { return js_Bevel; }
    virtual bool       GetVisible()   { return true; }

    virtual Real      Width() {
        Assert(FALSE && "LineStyle::Width should never be called on defaultLineStyle!");
        // Should never be used since default line style is detail,
        // just return a canonical value.
        return 1.0;
    }
    virtual Color     *GetColor()   { return black; }

    // By default, the line style is detail (one pixel wide)
    virtual bool      Detail() { return true; }

    // by default: no antialiasing.
    virtual bool      GetAntiAlias() { return false; }

    virtual float     GetMiterLimit() {
        return -1;
    }
    
    // TODO: Not a type in avrtypes.h??
    virtual DXMTypeInfo GetTypeInfo() { return LineStyleType; }
};

class AttributedLineStyle : public LineStyle {
  public:
    AttributedLineStyle(LineStyle *lineStyle) : _lineStyle(lineStyle) {}

    virtual DashStyleEnum GetDashStyle() { return _lineStyle->GetDashStyle(); }
    virtual EndStyleEnum  GetEndStyle()  { return _lineStyle->GetEndStyle(); }
    virtual JoinStyleEnum GetJoinStyle() { return _lineStyle->GetJoinStyle(); }
    virtual Real       Width() { return _lineStyle->Width(); }
    virtual bool       Detail() { return _lineStyle->Detail(); }
    virtual Color     *GetColor() { return _lineStyle->GetColor(); }
    virtual bool       GetVisible() { return _lineStyle->GetVisible(); }
    virtual bool       GetAntiAlias() { return _lineStyle->GetAntiAlias(); }
    virtual float      GetMiterLimit() { return _lineStyle->GetMiterLimit(); }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_lineStyle);
    }

    LineStyle *_lineStyle;
};


#define LINE_TYPE_CLASS(_type_) \
class Line##_type_##StyleClass : public AttributedLineStyle {                   \
  public:                                                                       \
    Line##_type_##StyleClass( _type_##StyleEnum theStyle, LineStyle *lineStyle)    \
        : _theStyle(theStyle), AttributedLineStyle(lineStyle) {}                \
    _type_##StyleEnum Get##_type_##Style()  { return _theStyle; }                  \
  protected:                                                                    \
    _type_##StyleEnum _theStyle;                                                   \
};

LINE_TYPE_CLASS(End)

LINE_TYPE_CLASS(Join)

LINE_TYPE_CLASS(Dash)

    
class LineWidthStyleClass : public AttributedLineStyle {
  public:
    LineWidthStyleClass(Real width, bool detail, LineStyle *lineStyle)
        : AttributedLineStyle(lineStyle), _width(width), _detail(detail) {}

    Real      Width() { return _width; }
    bool      Detail() { return _detail; }

  protected:
    Real _width;
    bool _detail;
};

class LineColorStyleClass : public AttributedLineStyle {
  public:
    LineColorStyleClass(Color *color, LineStyle *lineStyle)
        : AttributedLineStyle(lineStyle), _color(color) {}

    Color     *GetColor() { return _color; }

    virtual void DoKids(GCFuncObj proc) {
        AttributedLineStyle::DoKids(proc);
        (*proc)(_color);
    }

  protected:
    Color   *_color;
};

class LineAntiAliasedStyleClass : public AttributedLineStyle {
  public:
    LineAntiAliasedStyleClass(bool antiAlias, LineStyle *lineStyle)
        : AttributedLineStyle(lineStyle), _antiAlias(antiAlias) {}

    bool GetAntiAlias() { return _antiAlias; }

  protected:
    bool _antiAlias;
};

class LineMiterLimitClass : public AttributedLineStyle {
  public:
    LineMiterLimitClass(float limit, LineStyle *lineStyle)
        : AttributedLineStyle(lineStyle), _limit(limit) {}

    float GetMiterLimit() { return _limit; }

  protected:
    float _limit;
};


class EmptyLineStyle : public AttributedLineStyle {
  public:
      EmptyLineStyle() : AttributedLineStyle(NEW LineStyle()) {};
    virtual bool GetVisible()   { return false; }
};

#endif /* _LINEI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\matteimg.h ===
#ifndef _MATTEIMG_H
#define _MATTEIMG_H


/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

-------------------------------------*/

#include "privinc/imagei.h"
#include "privinc/mattei.h"

class MatteImage : public AttributedImage {
  public:
    MatteImage(Matte *matte, Image *imgToStencil);

    void   Render(GenericDevice& dev);

    inline const Bbox2 BoundingBox(void) {
        return _box;
    }

    Real DisjointBBoxAreas(DisjointCalcParam &param);
        
    void _CollectDirtyRects(DirtyRectCtx &ctx);
    
#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return IntersectBbox2Bbox2(_matte->BoundingBoxTighter(bbctx), _image->BoundingBoxTighter(bbctx));
    }
#endif  // BOUNDINGBOX_TIGHTER

    Bool   DetectHit(PointIntersectCtx& ctx);

    Bool RenderWithCallBack(
        callBackPtr_t callBack,
        void *callBackCtx,
        HRGN *regionPtr,
        Transform2 *xform,
        bool justDoPath);
    
    int  Savings(CacheParam &p);
    
    virtual void DoKids(GCFuncObj proc) { 
        AttributedImage::DoKids(proc);
        (*proc)(_matte); 
    }

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "MatteImage(" << _matte << "," << _box << ")";
    }
#endif

    virtual void Traverse(TraversalContext &ctx) {
        if( _image->CheckImageTypeId(SOLIDCOLORIMAGE_VTYPEID) )
            ctx.SetContainsSolidMatte();
        else 
            ctx.SetContainsOther();
    }
    
  protected:
    Matte  *_matte;
    Bbox2   _box;
};


#endif /* _MATTEIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\mattei.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Mattes

*******************************************************************************/


#ifndef _MATTEI_H
#define _MATTEI_H

#include "include/appelles/matte.h"
#include "privinc/storeobj.h"
#include "privinc/util.h"
#include "privinc/server.h"

typedef HDC (*callBackPtr_t)(void *);

class MatteCtx;
class BoundingPolygon;


////////////////////////////////////////////////////////
//////////// Matte class
////////////////////////////////////////////////////////

class ATL_NO_VTABLE Matte : public AxAValueObj {
  public:

    // Note that for mattes, the presence of stuff implies "clear"
    // rather than "opaque".  That is, if we union two mattes, the
    // result is the same or more "clear" than the parts.  If we
    // intersect them, the result is the same or less "clear" (or, the
    // same or more "opaque"). 
    
    enum MatteType {

        // fully opaque or clear mattes
        fullyOpaque,
        fullyClear,

        // non-trivially shaped, 'hard' mattes, meaning all alpha
        // values are either 0 or 1.
        nonTrivialHardMatte,
        
        // add more when we add more alpha alternatives
    };

    // TODO: We may want to separate out type classification from HRGN
    // generation, especially when we add alphas and not all mattes
    // will be representable via HRGNs.
    MatteType   GenerateHRGN(HDC dc,
                             callBackPtr_t devCallBack,
                             void *devCtxPtr,
                             Transform2 *initXform,
                             HRGN *rgnOut,             // Output
                             bool justDoPath
                             );

    MatteType   GenerateHRGN(MatteCtx &inCtx,
                             HRGN *hrgnOut);

    virtual void Accumulate(MatteCtx& ctx) = 0;

    virtual const Bbox2 BoundingBox(void) = 0;
#if BOUNDINGBOX_TIGHTER
    virtual const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) = 0;
#endif  // BOUNDINGBOX_TIGHTER

    // Return TRUE (and fill in parameters) if we can pull out points
    // for a single polygon or polybezier.  By default, assume we
    // cannot, and return false.
    virtual Bool ExtractAsSingleContour(
        Transform2 *initXform,
        int *numPts,            // out
        POINT **gdiPts,          // out
        Bool *isPolyline        // out (true = polyline, false = polybezier)
        ) {

        return FALSE;
    }

//    virtual void BoundingPgon(BoundingPolygon &pgon) = 0;

    virtual Path2 *IsPathRepresentableMatte() { return NULL; }
    
    virtual DXMTypeInfo GetTypeInfo() { return ::MatteType; }
};

//////////////////////  Matte Accumulation Ctx  //////////////////////////

class MatteCtx {
    friend class Matte;
  public:

    MatteCtx(HDC dc,
             callBackPtr_t devCallBack,
             void *devCtxPtr,
             Transform2 *initXform,
             bool justDoPath) {
        Init();
        _dc = dc;
        _devCallBack = devCallBack;
        _devCtxPtr = devCtxPtr;
        _xf = initXform;
        _justDoPath = justDoPath;

        // The maximum extent value is the following magic number.  This is
        // empircally the largest we can set it to without introducing various
        // artifacts on Win95.  WinNT seems to behave differently and can
        // accomodate a larger value, for what it's worth.

        const int max = 0x3FFF;
        
        TIME_GDI (_bigRegion = CreateRectRgn(-max, -max, max, max));
    }

    ~MatteCtx() {
        if(_bigRegion) DeleteObject(_bigRegion);
    }

    // Subtract the provided rgn from the one we're accumulating. 
    void        SubtractHRGN(HRGN r1) {
        
        Assert( !_justDoPath );
        
        int ret;

        Assert(_anyAccumulated != FALSE);

        switch (_accumulatedType) {
            
          case Matte::fullyOpaque:
            // Subtracting "clearness" from an opaque matte just
            // leaves it opaque, so don't do anything.
            break;

          case Matte::fullyClear:

            // Subtracting "clearness" from a clear matte will
            // involves inverting what we're subtracting: invert r1

            // fully clear means _hrgn is NULL.  create it.
            TIME_GDI (_hrgn = CreateRectRgn(-1,-1,1,1));
            
            Assert(_hrgn && "_hrgn NULL in SubtractMatte");
            Assert(_bigRegion && "_bigRegion NULL in SubtractMatte");
            Assert(r1 && "r1 NULL in SubtractMatte");

            TIME_GDI (ret = CombineRgn(_hrgn, _bigRegion, r1, RGN_DIFF));
            if (ret == ERROR) {
                    RaiseException_InternalError("Region intersection failed: subtract fullyClear");
            }
                
            _accumulatedType = Matte::nonTrivialHardMatte;

            break;

          case Matte::nonTrivialHardMatte:
            Assert(_hrgn != NULL);

            // Subtract r1 from _hrgn and leave result in _hrgn.
            {
                int ret;
                TIME_GDI (ret = CombineRgn(_hrgn, _hrgn, r1, RGN_DIFF));
                if( ret == ERROR) {
                    RaiseException_InternalError("Region intersection failed: subtract nonTrivial");
                } else if( ret == NULLREGION ) {
                    _accumulatedType = Matte::fullyOpaque;
                    TIME_GDI (if(_hrgn) DeleteObject(_hrgn));
                    _hrgn = NULL;
                }
            }     
            break;

          default:
            Assert(FALSE && "Not all cases dealt with");
            break;
        }

        //
        // In all cases, we should dump r1
        //
        DeleteObject(r1);
    }
    
    void        AddHRGN(HRGN r1, 
                        Matte::MatteType mType) {
        
        if (_anyAccumulated == FALSE) {

            Assert(!_hrgn);

            // nothing is accumulated, copy incoming type
            switch(mType) {
              case Matte::fullyOpaque:
              case Matte::fullyClear:
                break;

              case Matte::nonTrivialHardMatte:
                _hrgn = r1;
                break;
              default:
                Assert(FALSE && "Not all cases dealt with");
                break;
            }
            _accumulatedType = mType;
            _anyAccumulated = TRUE;
            
        } else {

            int ret;
            switch (_accumulatedType) {

              case Matte::fullyOpaque:

                Assert(!_hrgn &&
                       "_hrgn NOT NULL in AddHRGN opaque");

                // Adding anything to an opaque matte just
                // makes it the thing we're adding.
                _accumulatedType = mType;
                if(mType == Matte::nonTrivialHardMatte) {
                    _hrgn = r1;
                } 
                break;

              case Matte::fullyClear:

                Assert((_hrgn == NULL) && 
                       "_hrgn NOT NULL in AddHRGN clear");

                // Adding anything to a clear matte just leaves it
                // clear 
                TIME_GDI (DeleteObject(r1));
                break;

              case Matte::nonTrivialHardMatte:
                Assert(_hrgn != NULL);

                switch(mType) {
                  case Matte::fullyClear:
                    // clear everything
                    AddInfinitelyClearRegion();
                    break;
                  case Matte::fullyOpaque:
                    // no op
                    break;
                  case Matte::nonTrivialHardMatte:
                    // Add r1 to _hrgn and leave result in _hrgn.
                    TIME_GDI (ret = CombineRgn(_hrgn, _hrgn, r1, RGN_OR));
                    if (ret == ERROR ) {
                        RaiseException_InternalError("Region union failed");
                    }
                    break;
                }

                TIME_GDI (DeleteObject(r1));
                break;

              default:
                Assert(FALSE && "Not all cases dealt with");
                break;
            }       
        }
    }

    // Take the two regions, intersect them, add the result in.  Note
    // that this destructively modifies provided regions.
    void        IntersectAndAddHRGNS(HRGN r1, HRGN r2) {

        Assert( !_justDoPath );
            
        //
        // Combine intersection into r1 and add if
        // and add if not an empty region
        //
        int ret;
        TIME_GDI (ret = CombineRgn(r1, r1, r2, RGN_AND));
        Matte::MatteType accumType;

        if (ret == ERROR) {
            RaiseException_InternalError("Region intersection failed: regular");
        } else if (ret == NULLREGION) {
            accumType = Matte::fullyOpaque;
        } else {
            //
            // reasonable region
            //
            accumType = Matte::nonTrivialHardMatte;
        }

        AddHRGN(r1, accumType);
        DeleteObject(r2);
    }
    
    void        AddInfinitelyClearRegion() {
        // Just clear out existing HRGN, and make fullyClear.

        TIME_GDI (if(_hrgn) DeleteObject(_hrgn));
        _hrgn = NULL;
        _accumulatedType = Matte::fullyClear;
        _anyAccumulated = TRUE;
    }


    void        AddHalfClearRegion() {
        // Just clear out existing HRGN, and make fullyClear.
        Assert(FALSE && "HalfMatte not implemented!");

        TIME_GDI (if(_hrgn) DeleteObject(_hrgn));
        _hrgn = NULL;
        _accumulatedType = Matte::fullyClear;
    }

    
    void             SetTransform(Transform2 *xf) { _xf = xf; }
    Transform2      *GetTransform() { return _xf; }

    HDC              GetDC() { 
        if(!_dc) {
            Assert(_devCtxPtr && "_devCtxPtr NOT set in GetDC in MatteCtx");
            Assert(_devCallBack && "_devCallBack NOT set in GetDC in MatteCtx");
            _dc = _devCallBack(_devCtxPtr); 
        }
        return _dc;
    }

    HRGN             GetHRGN() { return _hrgn; }

    Matte::MatteType GetMatteType() { 
        return _anyAccumulated ? _accumulatedType : Matte::fullyOpaque;
    }

    callBackPtr_t    GetCallBack() { return _devCallBack; }
    void            *GetCallBackCtx() { return _devCtxPtr; }

    bool             JustDoPath() { return _justDoPath; }
  protected:
    void Init() {
        _xf = NULL;
        _devCallBack = NULL;
        _devCtxPtr = NULL;
        _dc = NULL;
        _hrgn = NULL;
        _anyAccumulated = FALSE;
        _justDoPath = false;
    }

    Transform2        *_xf;
    callBackPtr_t      _devCallBack;
    void              *_devCtxPtr;
    HDC                _dc;
    HRGN               _hrgn;
    bool               _justDoPath;
    HRGN               _bigRegion;
    HRGN               _fooRgn;
    Bool               _anyAccumulated;
    Matte::MatteType   _accumulatedType;
};

#endif /* _MATTEI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\imgdev.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Generic device for rendering images.

*******************************************************************************/

#ifndef _IMGDEV_H
#define _IMGDEV_H

#include "privinc/dispdevi.h"
#include "privinc/debug.h"
#include "appelles/bbox2.h"
#include "privinc/imagei.h"
#include "privinc/drect.h"
#include <htmlfilter.h> // trident stuff.  IBitmapSurface
#include "ddraw.h"

// doesn't set x to NULL
#define FASTRELEASE(x) if(x) x->Release();

//
// Rendering target structure
//
enum targetEnum { target_invalid,
                  target_ddsurf,
                  target_hwnd,
                  target_hdc };
                                    

class targetPackage_t
{
    friend class View;
    
  public:

    IDirectDrawSurface *GetIDDSurface() { return _ddsurf; }
    HDC                 GetHDC() { return _hdc; }
    HWND                GetHWND() { return _hwnd; }
    HDC                 GetParentHDC() { return _parentHDC; }

    targetEnum          GetTargetType() { return _targetType; }
    
    void  SetIDDSurface(IDirectDrawSurface *dds,
                        HDC parentHDC = NULL)
    {
        _targetType = target_ddsurf;
        _ddsurf = dds;
        _parentHDC = parentHDC;
    }

    void SetHDC(HDC hdc) {
        _targetType = target_hdc;
        _hdc = hdc;
    }

    void SetHWND( HWND hwnd ) {
        _targetType = target_hwnd;
        _hwnd = hwnd;
    }

    bool IsValid() { return _targetType != target_invalid; }
    bool IsHWND() { return _targetType == target_hwnd; }
    bool IsHDC() { return _targetType == target_hdc; }
    bool IsDdsurf() { return _targetType == target_ddsurf; }
    
    void Reset()
    {
        _ddsurf.Release();
        _hdc = NULL;
        _hwnd = NULL;
        _parentHDC = NULL;
        _targetType = target_invalid;
        _composeToTarget = false;
        _alreadyOffset = false;

        _isValid_ViewportRect = false;
        _isValid_ClipRect = false;
        _isValid_InvalidRect = false;

        _isValid_rawViewportRect = false;
        _isValid_rawClipRect = false;
        _isValid_rawInvalidRect = false;
        
        ::FillMemory((void *)&_rawViewportRect, sizeof(RECT), 0xff);
        ::FillMemory((void *)&_rawClipRect, sizeof(RECT), 0xff);
        ::FillMemory((void *)&_rawInvalidRect, sizeof(RECT), 0xff);
    }

    void Copy( targetPackage_t &src )
    {
        // can't do a memcopy because ddsurf is a reference class and
        // the = operator does work.
        _ddsurf = src._ddsurf;
        _hdc =    src._hdc;
        _hwnd =   src._hwnd;
        _parentHDC = src._parentHDC;
        
        _targetType = src.GetTargetType();

        _composeToTarget      = src.GetComposeToTarget();
        _alreadyOffset        = src.GetAlreadyOffset();

        _viewportRect         = src.GetViewportRect();
        _clipRect             = src.GetClipRect();
        _invalidRect          = src.GetInvalidRect();

        _isValid_ViewportRect = src.IsValid_ViewportRect();
        _isValid_ClipRect     = src.IsValid_ClipRect();
        _isValid_InvalidRect  = src.IsValid_InvalidRect();

        _rawViewportRect      = src._GetRawViewportRect();
        _rawClipRect          = src._GetRawClipRect();
        _rawInvalidRect       = src._GetRawInvalidRect();

        _isValid_rawViewportRect = src._IsValid_RawViewportRect();
        _isValid_rawClipRect     = src._IsValid_RawClipRect();
        _isValid_rawInvalidRect  = src._IsValid_RawInvalidRect();
    }

    bool IsValid_ViewportRect() { return _isValid_ViewportRect; }
    bool IsValid_ClipRect()     { return _isValid_ClipRect; }
    bool IsValid_InvalidRect()  { return _isValid_InvalidRect; }

    const RECT &GetViewportRect() { return _viewportRect; }
    const RECT &GetClipRect() { return _clipRect; }
    const RECT &GetInvalidRect() { return _invalidRect; }
    
    bool GetComposeToTarget() { return _composeToTarget; }
    void SetComposeToTarget( bool c ) { _composeToTarget = c; }

    bool GetAlreadyOffset()  { return _alreadyOffset; }
    void SetAlreadyOffset() { _alreadyOffset = true; }

    void SetViewportRect(const RECT &r) {
        _viewportRect = r;
        _isValid_ViewportRect = true;
    }
    void SetClipRect(const RECT &r)     {
        _clipRect = r;
        _isValid_ClipRect = true;
    }
    void SetInvalidRect(const RECT &r)  {
        _invalidRect = r;
        _isValid_InvalidRect = true;
    }

    void SetRawViewportRect(const RECT &r) {
        _rawViewportRect = r;
        _isValid_rawViewportRect = true;
        _isValid_ViewportRect = false;
    }
    void SetRawClipRect(const RECT &r) {
        _rawClipRect = r;
        _isValid_rawClipRect = true;
        _isValid_ClipRect = false;
    }
    void SetRawInvalidRect(const RECT &r) {
        _rawInvalidRect = r;
        _isValid_rawInvalidRect = true;
        _isValid_InvalidRect = false;
    }

    
  private:

    CComPtr<IDirectDrawSurface> _ddsurf;
    HDC                _hdc;
    HWND               _hwnd;
    HDC                _parentHDC;
    
    targetEnum         _targetType;


    const RECT &_GetRawViewportRect() { return _rawViewportRect; }
    const RECT &_GetRawClipRect() { return _rawClipRect; }
    const RECT &_GetRawInvalidRect() { return _rawInvalidRect; }
    
    bool _IsValid_RawViewportRect() { return _isValid_rawViewportRect; }
    bool _IsValid_RawClipRect()     { return _isValid_rawClipRect; }
    bool _IsValid_RawInvalidRect()  { return _isValid_rawInvalidRect; }

    
    // These are 'raw' which means that they are in terms of the
    // parentDC or the surface and may (or may not) need to be
    // reinterpreted into the non-raw counterparts (_viewportRect)
    // which need to be guaranteed to be in device coords of the
    // target
    
    RECT _rawViewportRect;
    RECT _rawClipRect;    
    RECT _rawInvalidRect; 

    bool _isValid_rawViewportRect;
    bool _isValid_rawClipRect;
    bool _isValid_rawInvalidRect;

    
    // These are the final rects, if the hese rects are 'valid', then
    // they are guaranteed to be in device coordinates
    
    RECT _viewportRect;// viewport rect:  relative to target surface
    RECT _clipRect;    // clip rect:  relative to target surface
    RECT _invalidRect; // invalid rect: relative to target surface.                    

    bool _isValid_ViewportRect;
    bool _isValid_ClipRect;
    bool _isValid_InvalidRect;

    bool _composeToTarget;  // paint to target directly, or backbuffer?
    bool _alreadyOffset;

};  // targetPackage_t class

////////////////////////////////////////////////////////////////////
//
//  Image rendering device
//
////////////////////////////////////////////////////////////////////

// ----------------------------------------
// forward decls
// ----------------------------------------
class TextCtx;            
class SolidColorImageClass;
class DiscreteImage;
class ProjectedGeomImage;
class MovieImage;
class MovieImageFrame;
class GradientImage;
class ColorKeyedImage;
class DirectDrawSurfaceImage;
struct IDirectDrawSurface;
struct DDSurface;
class MovieImagePerf;
class MulticolorGradientImage;
class Path2;
class CacheParam;

#define NUM_ATTRIBS          4

#define ATTRIB_XFORM_SIMPLE  0
#define ATTRIB_XFORM_COMPLEX 1
#define ATTRIB_CROP          2
#define ATTRIB_OPAC          3

#define ATTRIB_STRING(attrib)  (attrib==ATTRIB_XFORM_COMPLEX ? "ATTRIB_XFORM_COMPLEX" : (attrib==ATTRIB_XFORM_SIMPLE ? "ATTRIB_XFORM_SIMPLE" : (attrib==ATTRIB_CROP ? "ATTRIB_CROP" : (attrib==ATTRIB_OPAC ? "ATTRIB_OPAC" : "UNKNOWN ATTRIB!"))))

class ATL_NO_VTABLE ImageDisplayDev : public DisplayDev {
  public:

    ImageDisplayDev();
    virtual ~ImageDisplayDev();

    virtual void BeginRendering(Image *img, Real opacity) {}
    virtual void EndRendering(DirtyRectState &d) {}

    virtual void WindowResizeEvent(int width, int height) = 0;

    virtual Image *CanCacheImage(Image  *image,
                                 Image **pImageCacheBase,
                                 const CacheParam &p) = 0;
    
    virtual Bool CanDisplay() = 0;
    
    virtual bool SetTargetPackage(targetPackage_t *targetPackage) = 0;
        
    virtual void RenderImage(Image *img);

    // compositing render based on attrib
    virtual void SmartRender(Image *image, int attrib) = 0;

    // Subclasses implement this method to render the specified 
    // dicrete image with the currently accumulated attributes
    virtual void RenderDiscreteImage(DiscreteImage *image) = 0;

    virtual void RenderDirectDrawSurfaceImage(DirectDrawSurfaceImage *ddsimg) = 0;
    
    // Render a solid colored, infinite image
    virtual void RenderSolidColorImage(SolidColorImageClass& img) = 0;

    // Render a string onto the image according to the current text
    // context.
    virtual void RenderText(TextCtx& textCtx, 
                            WideString str,
                            Image *textImg) = 0;
    
    // Render a tiled image based on image tile derived from
    // min/max delimiters applied to 'image'.  This uses the
    // 'imageToTile' as a place holder for efficiency.
    // The calling class keeps this opaque pointer, this class
    // manages and creates it.
    virtual void RenderTiledImage(const Point2& min, 
                                  const Point2& max, 
                                  Image *tileSrcImage) = 0;


    // Render an image using geo and cam and all the
    // current transforms as well as whatever infor
    // 'img' can provide.
    virtual void RenderProjectedGeomImage(ProjectedGeomImage *img,
                                          Geometry *geo,
                                          Camera *cam) = 0; 

    virtual void RenderMovieImage(MovieImage     *movieImage,
                                  Real            time,
                                  MovieImagePerf *perf,
                                  bool            forceFallback,
                                  DDSurface      *targDDSurf = NULL) = 0;

    void StashMovieImageFrame(MovieImageFrame *f)
    { _movieImageFrame = f; }

    MovieImageFrame *GetMovieImageFrame()
    { return _movieImageFrame; }
    
    virtual void RenderGradientImage(GradientImage *img,
                                     int numPts,
                                     Point2Value **pts,
                                     Color **clrs) = 0;
    virtual void RenderMulticolorGradientImage(
        MulticolorGradientImage *gradImg,
        int numOffsets,
        double offsets[],
        Color **clrs) = 0;

    virtual void RenderColorKeyedImage(ColorKeyedImage *)=0;
    
    // -- Device Specific Calls --
    // -- May want to move into viewport --

    // Use these to retrieve the dimensions (in pixels) of the device
    virtual int GetWidth() = 0;
    virtual int GetHeight() = 0;

    // Return resolution, in pixels per meter.
    virtual Real GetResolution() = 0;

    // -- Context Accumulation Calls --

    void       PushCroppedImage(Image *image) {
        _cropRef++;
        _imageQueue.push_back(image);
    }
    void       PopCroppedImage() {
        _cropRef--;
        _imageQueue.pop_back();
    }
    Bool       IsCropped() { return _cropRef > 0;  }

    // -- Clipping --
    
    inline void   SetClippingPath(Path2 *path, Transform2 *cpxf) {
        _clippingPath = path;
        _clippingPathXf = cpxf;
    }
    inline void   GetClippingPath(Path2 **path, Transform2 **cpxf) {
        Assert( path && cpxf );
        *path = _clippingPath;
        *cpxf = _clippingPathXf;
    }
        
    
    

    void       PushTransform2Image(Image *image) {
        BEGIN_LEAK
        _imageQueue.push_back(image);
        END_LEAK
    }
    void       PopTransform2Image() {
        _imageQueue.pop_back();
    }

    
    // ----------------------------
    // Attributor state members
    // ----------------------------    
    Bool GetDealtWithAttrib(int attrib) {
        Assert( (attrib >=0) && (attrib<_numAttribs) &&
                "Bad attrib index");
        Assert(((_attributorStateArray[attrib] == TRUE) ||
                (_attributorStateArray[attrib] == FALSE)) &&
               "Trying to get bad val for attrib");
        return _attributorStateArray[attrib];
    }
    
    void SetDealtWithAttrib(int attrib, Bool val) {
        TraceTag((tagImageDeviceAlgebra, 
                  "SetDealtWithAttrib: %s=%d",
                  ATTRIB_STRING(attrib), val));
        Assert( ((val == TRUE) || (val == FALSE)) && "Bad val passed to SetDealtWithAttrib");
        _attributorStateArray[attrib] = val;
    }

    Bool AllAttributorsTrue() {
        Bool ret = TRUE;
        for(int i=0; i < _numAttribs; i++) {
            ret = ret && _attributorStateArray[i];
        }
        return ret;
    }


    // ----------------------------
    // Context accessing functions.
    // ----------------------------
    
    // Opacity accessor
    Real  GetOpacity()       { return _opacity; }
    void  SetOpacity(Real o) { _opacity = o; }

    // Image quality accessors
    DWORD GetImageQualityFlags() { return _imgQualFlags; }
    void  SetImageQualityFlags(DWORD flags) { _imgQualFlags = flags; }
    bool  UseImageQualityFlags(DWORD dwAllFlags, 
                               DWORD dwSetFlags, bool bCurrent);

    void  GetRenderResolution(long *outWidth,
                              long *outHeight) {
        *outWidth = _imgRenderResolutionWidth;
        *outHeight = _imgRenderResolutionHeight;
    }
    void  SetRenderResolution(long inWidth,
                              long inHeight) {
        _imgRenderResolutionWidth = inWidth;
        _imgRenderResolutionHeight = inHeight;
    }

    void  SetSampleResolution(int s) { _sampleResolution = s; }
    int   GetSampleResolution() { return _sampleResolution; }

    //
    // Alpha blend util functions
    //
    Bool IsFullyClear() { return _opacity < _minOpacity; }
    Bool IsFullyOpaque() { return _opacity >= _maxOpacity; }
    Bool IsTransparent() { return !IsFullyClear() && !IsFullyOpaque(); }

    Bool IsFullyClear(Real o) { return o < _minOpacity; }
    Bool IsFullyOpaque(Real o) { return o >= _maxOpacity; }
    Bool IsTransparent(Real o) { return !IsFullyClear(o) && !IsFullyOpaque(o); }


    Transform2 *GetTransform() { return _xform; }
    void       SetTransform(Transform2 *xf) { _xform = xf; }

    // Color keys
    bool ColorKeyIsSet() { return _colorKeyIsSet; }
    void UnsetColorKey() { _colorKeyIsSet = false; }
    void SetColorKey(Color *key) { 
        _colorKey = key; 
        _colorKeyIsSet = true;
    }
    Color *GetColorKey() { return _colorKey; }
    
    void ResetAttributors() {
        for(int i=0; i<_numAttribs; i++) {
            SetDealtWithAttrib(i, TRUE);
        }
    }

    void ResetContextMembers() {
        _numAttribs = NUM_ATTRIBS;
        _cropRef = 0;
        _boundingBox = UniverseBbox2;
        _clippingPath = NULL;
        _clippingPathXf = NULL;
        _opacity = 1.0;
        _xform = identityTransform2;
        _colorKeyIsSet  = FALSE;
        _colorKey = NULL;
        _imageQueue.erase(_imageQueue.begin(),_imageQueue.end());
        _imgQualFlags = 0;
        _imgRenderResolutionWidth = -1;
        _imgRenderResolutionHeight = -1;
        SetSampleResolution(-1);
        ResetAttributors();
    }

    void InheritContextMembers( ImageDisplayDev *srcDev )
    {
        Assert( srcDev );
        
        _numAttribs = srcDev->_numAttribs;
        _cropRef =    srcDev->_cropRef;
        _boundingBox = srcDev->_boundingBox;
        
        SetOpacity( srcDev->_opacity );
        _minOpacity = srcDev->_minOpacity;
        _maxOpacity = srcDev->_maxOpacity;
        
        SetTransform( srcDev->_xform );
        _colorKeyIsSet  = srcDev->_colorKeyIsSet;
        _colorKey = srcDev->_colorKey;
        
        _imageQueue.erase(_imageQueue.begin(),_imageQueue.end());
        // copy constructor
        _imageQueue = srcDev->_imageQueue;

        SetImageQualityFlags( srcDev->GetImageQualityFlags() );
        SetSampleResolution( srcDev->GetSampleResolution() );
        
        long w,h;
        srcDev->GetRenderResolution( &w, &h );
        SetRenderResolution( w, h );

        InheritAttributorStateArray( srcDev );
    }
    
    void InheritAttributorStateArray( ImageDisplayDev *srcDev )
    {
        CopyMemory( _attributorStateArray,
                    srcDev->_attributorStateArray,
                    NUM_ATTRIBS * sizeof(int) );
    }   

  protected:

    int           _numAttribs;
    int           _attributorStateArray[NUM_ATTRIBS];

    int           _cropRef;
    Bbox2         _boundingBox;

    Path2        *_clippingPath;
    Transform2   *_clippingPathXf;
    
    // temp val for rendering
    MovieImageFrame *_movieImageFrame;

    //
    // Alpha blending data members
    //
    Real          _opacity;
    Real          _minOpacity;
    Real          _maxOpacity;

    Transform2   *_xform;
    bool          _colorKeyIsSet;
    Color        *_colorKey;

    DWORD          _imgQualFlags;
    long           _imgRenderResolutionWidth;
    long           _imgRenderResolutionHeight;
    int            _sampleResolution;
    
    list<Image*> _imageQueue;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\lighti.h ===
#pragma once
#ifndef _AV_LIGHTI_H
#define _AV_LIGHTI_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Private include file for defining lights and light traversal context.

*******************************************************************************/

#include "appelles/color.h"
#include "appelles/light.h"

#include "privinc/geomi.h"
#include "privinc/bbox3i.h"


    // This enumeration indicates the type of light source.

enum LightType
{
    Ltype_Ambient,
    Ltype_Directional,
    Ltype_Point,
    Ltype_Spot,
    Ltype_MAX
};


    // The light context class maintains traversal context while gathering
    // lights from the geometry tree.

class Light;
class GeomRenderer;

typedef void (LightCallback)(LightContext&, Light&, void*);

class LightContext
{
  public:

    LightContext (GeomRenderer *rdev);
    LightContext (LightCallback *callback, void *callback_data);

    // Set/Query functions for light attributes.

    void        SetTransform (Transform3 *transform);
    Transform3 *GetTransform (void);

    void   PushColor (Color*);
    void   PopColor  (void);
    Color *GetColor  (void);

    void PushRange (Real);
    void PopRange  (void);
    Real GetRange  (void);

    void PushAttenuation (Real a0, Real a1, Real a2);
    void PopAttenuation  (void);
    void GetAttenuation  (Real &a0, Real &a1, Real &a2);

    void AddLight (Light &light);

    GeomRenderer* Renderer (void);

  private:

    void Initialize (GeomRenderer*, LightCallback*, void*);

    GeomRenderer     *_rdev;        // Rendering Device

    short _depthAtten;   // Attribute Depth Counters
    short _depthColor;
    short _depthRange;

    Transform3 *_transform;                 // Current Accumulated Transform
    Color      *_color;                     // Light Color
    Real        _range;                     // Light Range in World Coords
    Real        _atten0, _atten1, _atten2;  // Light Attenuation

    LightCallback *_callback;               // Light Collection Callback
    void          *_callback_data;
};

inline GeomRenderer* LightContext::Renderer (void)
{
    return _rdev;
}



    // The light superclass specifies the trivial default values for most
    // traversal methods.  Specific types of lights subclass from this and
    // define the data & methods particular to their type.

class Light : public Geometry
{
  public:

    // This constructor creates a light of the given type.  Spotlights should
    // use the constructor that takes the spotlight parameters.

    Light (LightType type)
        : _type(type), _cutoff(1), _fullcone(1) {}

    // This creates a light and initializes the spotlight parameters.

    Light (LightType type, Real fullcone, Real cutoff)
    :   _type(type),
        _fullcone(fullcone), _cutoff(cutoff)
    {}

    // Lights have no sound, no volume, can't be rendered or picked.

    void   Render          (GenericDevice& dev)   {}
    void   CollectSounds   (SoundTraversalContext &context) {}
    void   CollectTextures (GeomRenderer &device) {}
    Bbox3 *BoundingVol     (void)  { return nullBbox3; }
    void   RayIntersect    (RayIntersectCtx &context) {}

    // When a light is collected, it adds itself to the context.

    void CollectLights (LightContext &context) { context.AddLight (*this); }

    // This function returns the type of light source.

    LightType Type (void) { return _type; }

    // This function gets the spotlight parameters.

    void GetSpotlightParams (Real &cutoff, Real &fullcone)
        { cutoff = _cutoff; fullcone = _fullcone; }

    #if _USE_PRINT
        ostream &Print (ostream &os);
    #endif

    VALTYPEID GetValTypeId() { return LIGHTGEOM_VTYPEID; }

  private:

    LightType  _type;   // Light Source Type

    // Spotlight Parameters

    Real _cutoff;      // Angle of Light Cutoff (Radians)
    Real _fullcone;    // Cone Angle of Full Intensity Illumination
};


    // This function constructs spotlights with Real values.

Geometry *SpotLight (Real fullcone, Real cutoff);

    // Light Attributers

Geometry *applyLightAttenuation (Real A0, Real A1, Real A2, Geometry*);
Geometry *applyLightRange (Real range, Geometry *geometry);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\mici.h ===
#ifndef _MICI_H
#define _MICI_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Microphone *implementation class

--*/

#include "appelles/mic.h"

class ATL_NO_VTABLE Microphone : public AxAValueObj {
  public:
    // For now, just identify the microphone with a transform.  Will
    // want to add other stuff.
    virtual Transform3 *GetTransform() const = 0;
#if _USE_PRINT
    virtual ostream& Print(ostream& os) const = 0;
#endif

    virtual DXMTypeInfo GetTypeInfo() { return MicrophoneType; }
};

#endif /* _MICI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\matutil.h ===
#ifndef _MATUTIL_H
#define _MATUTIL_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Utility for 4x4 transformation matrices.  These are pre-multiply
transformation matrices:  Ax=y.  Unlike OpenGL, it is indexed in the standard
way, i.e. the translation component is (a(0,3), a(1,3), a(2,3)).  Conversion
functions are supplied for OpenGL compatibility.

*******************************************************************************/

#include "privinc/vecutil.h"
#include "privinc/vec3i.h"


typedef Real Apu4x4MatrixArray_t[4][4];


class Apu4x4Matrix
{
  public:
    enum form_e           // special form of transformation
    {
        UNINITIALIZED_E,
        IDENTITY_E,       // identity
        TRANSLATE_E,      // 3 x 1
        UPPER_3X3_E,      // 3 x 3
        AFFINE_E,         // 3 x 4
        PERSPECTIVE_E,    // 4 x 4
        END_OF_FORM_E
    };

    // An array of matrix form types resulting from multiplication.

    static const form_e MultiplyReturnTypes[END_OF_FORM_E][END_OF_FORM_E];

    // An array of strings for each of the matrix form types.

    static const char * const form_s [END_OF_FORM_E];

    // The actual matrix array.

    Apu4x4MatrixArray_t m;
    form_e form;
    bool is_rigid;              // true if special orthogonal
    bool pixelMode;

    // Member Functions

    // These methods return the transform origin and basis vectors.

    Point3Value  Origin (void) const;
    Vector3Value BasisX (void) const;
    Vector3Value BasisY (void) const;
    Vector3Value BasisZ (void) const;

    Real *operator[] (int i) { return m[i]; }
    const Real *operator[] (int i) const { return m[i]; }

    void SetIdentity();
    void SetType (void);       // Autoset Matrix Type

    void PostTranslate (Real x, Real y, Real z);
    void PostScale     (Real x, Real y, Real z);

    // These transform an ApuVector3 interpreted as either a point or
    // a vector.  The interpretation as a vector ignores the
    // translational component of the transformation.

    void ApplyAsPoint (const ApuVector3& x, ApuVector3& result) const;
    void ApplyAsVector (const ApuVector3& x, ApuVector3& result) const;

    // Transform the given plane.  NOTE: This method will return true
    // if the matrix is not invertable.

    bool TransformPlane (Real A, Real B, Real C, Real D, Real result[4]) const;

    // Returns the determinant of the matrix.

    Real Determinant (void) const;

    // Returns whether the matrix is orthogonal or not.

    bool Orthogonal (void) const;

    #if _USE_PRINT
        ostream& Print (ostream& os) const;
    #endif
};


inline Vector3Value Apu4x4Matrix::BasisX (void) const
{
    return Vector3Value (m[0][0], m[1][0], m[2][0]);
}


inline Vector3Value Apu4x4Matrix::BasisY (void) const
{
    return Vector3Value (m[0][1], m[1][1], m[2][1]);
}


inline Vector3Value Apu4x4Matrix::BasisZ (void) const
{
    return Vector3Value (m[0][2], m[1][2], m[2][2]);
}


inline Point3Value Apu4x4Matrix::Origin (void) const
{
    return Point3Value (m[0][3], m[1][3], m[2][3]);
}


    // Equality Operators Between Transforms

bool operator== (const Apu4x4Matrix &lhs, const Apu4x4Matrix &rhs);

inline bool operator!= (const Apu4x4Matrix &lhs, const Apu4x4Matrix &rhs)
{
    return !(lhs == rhs);
}





extern const Apu4x4Matrix apuIdentityMatrix;


void ApuTranslate (Real Dx, Real Dy, Real Dz, bool pixelMode, Apu4x4Matrix& result);

void ApuScale (Real Sx, Real Sy, Real Sz, Apu4x4Matrix& result);

void ApuRotate (Real angle, Real Ax, Real Ay, Real Az, Apu4x4Matrix& result);

void ApuRotateX (Real angle, Apu4x4Matrix& result);
void ApuRotateY (Real angle, Apu4x4Matrix& result);
void ApuRotateZ (Real angle, Apu4x4Matrix& result);

void ApuShear (Real,Real, Real,Real, Real,Real, Apu4x4Matrix& result);

void ApuMultiply
    (const Apu4x4Matrix& a, const Apu4x4Matrix& b, Apu4x4Matrix& result);

// Return false if not invertible
bool ApuInverse
    (const Apu4x4Matrix& m, Apu4x4Matrix& result);

void ApuTranspose
    (const Apu4x4Matrix& m, Apu4x4Matrix& result, int order=4);

Real ApuDeterminant (const Apu4x4Matrix& m);

bool ApuIsSingular (const Apu4x4Matrix& m);

// Validity checking for matrices

bool Valid (const Apu4x4Matrix&);
void CheckMatrix (const Apu4x4Matrix&, char *filename, int line);

#if _DEBUG
    #define CHECK_MATRIX(m) CheckMatrix(m,__FILE__,__LINE__)
#else
    #define CHECK_MATRIX(m) // Nothing if not in debug
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\miscpref.h ===
#ifndef _MISCPREFS_H
#define _MISCPREFS_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Misc Prefs structure
*******************************************************************************/

typedef struct {
// misc

// audio
   bool _synchronize;        // use servo and phase to sync
   bool _disableAudio;       // force dsound audio to be dissabled
   int  _frameRate;          // number of frames per second
   int  _sampleBytes;        // number of bytes per sample
#ifdef REGISTRY_MIDI
   bool _qMIDI;              // use quartz MIDI audioActive MIDI
#endif
} miscPrefType;

#endif /* _MISCPREFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\meshmaker.h ===
#pragma once
#ifndef _MESHMAKER_H
#define _MESHMAKER_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    For constructing a meshbuilder out of a constant geometry subgraph

*******************************************************************************/

#include "privinc/ddrender.h"
#include "privinc/comutil.h"

class MeshMaker : public GeomRenderer {
  public:

    MeshMaker(DirectDrawImageDevice *dev, int count);
    ~MeshMaker();

    void GrabResultBuilder(IDirect3DRMMeshBuilder3 **ppResult);
    int  GetCount() { return _numPrims; }
    void RenderHelper(RMVisualGeo *geo);


    HRESULT Initialize (
        DirectDrawViewport *viewport,
        DDSurface          *ddsurf)
    {
        Assert(!"Don't expect to be here");
        return E_FAIL;
    }

    void RenderGeometry (
        DirectDrawImageDevice *imgDev,
        RECT      target_region,  // Target Region on Rendering Surface
        Geometry *geometry,       // Geometry To Render
        Camera   *camera,         // Viewing Camera
        const Bbox2 &region)    // Source Region in Camera Coords
    {
        Assert(!"Don't expect to be here");
    }

    void* LookupTextureHandle (IDirectDrawSurface*, DWORD, bool, bool)
    {
        Assert (!"Don't expect to be here");
        return NULL;
    }

    void SurfaceGoingAway (IDirectDrawSurface *surface) {
        Assert(!"Don't expect to be here");
    }

    void AddLight (LightContext &context, Light &light);

    // The following methods submit a geometric primitive for rendering with
    // the current attribute state.

    void Render (RM1VisualGeo *geo);
    void Render (RM3VisualGeo *geo);

    void RenderTexMesh (void *texture,
#ifndef BUILD_USING_CRRM
                        IDirect3DRMMesh  *mesh,
                        long              groupId,
#else
                        int vCount,
                        D3DRMVERTEX *d3dVertArray,
                        unsigned *vIndicies,
                        BOOL doTexture,
#endif
                        const Bbox2 &box,
                        RECT *destRect,
                        bool bDither) {
        Assert(!"Don't expect to be here");
    }

    // SetView takes the given camera and sets the orienting and projection
    // transforms for the image viewport and volume.

    void SetView(RECT *target, const Bbox2 &viewport, Bbox3 *volume) {
        Assert(!"Don't expect to be here");
    }

    void GetRMDevice (IUnknown **D3DRMDevice, DWORD *SeqNum) {
        Assert(!"Don't expect to be here");
    }

    void RenderMeshBuilderWithDeviceState(IDirect3DRMMeshBuilder3 *mb);

    bool PickReady (void) {
        Assert(!"Don't expect to be here");
        return false;
    }

    DirectDrawImageDevice& GetImageDevice (void) {
        return *_imgDev;
    }

    // If we're counting, increment our count and return true, else
    // return false.
    bool CountingPrimitivesOnly_DoIncrement() {
        if (_countingOnly) {
            _numPrims++;
        }
        return _countingOnly;
    }

    bool IsMeshmaker() { return true; }

  protected:
    // Member data
    DAComPtr<IDirect3DRMMeshBuilder3> _resultBuilder;
    DirectDrawImageDevice            *_imgDev;
    int                               _numPrims;
    int                               _expectedCount;
    bool                              _countingOnly;
};

void
DumpGeomIntoBuilder(Geometry *geo,
                    DirectDrawImageDevice *dev,
                    IDirect3DRMMeshBuilder3 **ppResult);

#endif /* _MESHMAKER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\midi.h ===
#ifndef _MIDI_H
#define _MIDI_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Defines the MIDI base class
*******************************************************************************/


#include "appelles/sound.h"

#include "privinc/storeobj.h"
#include "privinc/geomi.h"
#include "privinc/path.h"
#include "privinc/helpds.h"
#include "privinc/dsdev.h"
#include "privinc/snddev.h"


class MIDIsound : public LeafSound {
  public:
    //MIDIsound();
    virtual ~MIDIsound() {}
    virtual void Open(char * fileName) = 0;
#if _USE_PRINT
    virtual ostream& Print(ostream& s) { return s << "MIDI"; }
#endif

    virtual bool RenderAvailable(MetaSoundDevice *)                      = 0;
    virtual void RenderNewBuffer(MetaSoundDevice *)                      = 0;
    virtual void RenderAttributes(MetaSoundDevice *, BufferElement *,
        double rate, bool doSeek, double seek)                           = 0;
    virtual void RenderStartAtLocation(MetaSoundDevice *,
        BufferElement *bufferElement, double phase, Bool looping)        = 0;
    virtual void RenderStop(MetaSoundDevice *, BufferElement *)          = 0;
    virtual void RenderSamples(MetaSoundDevice *, BufferElement *) {}
    virtual void RenderSetMute(MetaSoundDevice *, BufferElement *)       = 0;
    virtual Bool RenderCheckComplete(MetaSoundDevice *, BufferElement *) = 0;
    virtual void RenderCleanupBuffer(MetaSoundDevice *, BufferElement *) = 0;
    virtual double GetLength()                                           = 0;

  protected:
    char       *fileName;
    Bool        _started;
    Bool        _ended;
    Bool        _looping;
};


#endif /* _MIDI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\mutex.h ===
#ifndef _MUTEX_H
#define _MUTEX_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    A simple mutex abstraction for use in Appelles.  This supports a
    Grab() method as well as a Release() method.  Additionally, there
    is another class whose constructor grabs a mutex, and whose
    destructor automatically releases it, thus freeing the programmer
    from having to remember to release the mutex, as well as allowing
    exceptions that are thrown to result in a release of the mutex,
    due to stack unwinding.


--*/

#include "appelles/common.h"

/////////////////////////  Mutexes  //////////////////////

// Simple encapsulation of a mutex with Grab and Release operations.
// The constructor creates the mutex, and the destructor destroys it.
// Grab() is a blocking function that acquires the mutex when it is
// available.  Release() releases the mutex.  An exception is thrown
// if Release() is called by a thread that doesn't own the mutex.
class Mutex {
  public:
    Mutex();
    ~Mutex();
    void Grab();
    void Release();

  protected:
    void *mutex;                // opaque pointer to actual mutex
};

// Use this class in a lexical scope that requires grabbing of a
// mutex, doing some processing, and then releasing it.  Grab by
// creating one of these objects with the desired mutex.  Exiting the
// scope implicitly will release it.
// The dontGrab parameter is here because we don't have conditional
// scope.
class MutexGrabber {
  public:
    MutexGrabber(Mutex& mutex, Bool grabIt = TRUE);
    ~MutexGrabber();

  protected:
    Mutex& mutex;
    Bool grabbed;
};

/////////////////////////  CriticalSections  //////////////////////

// This is exactly like mutex except it uses the faster critical sections

class CritSect {
  public:
    CritSect();
    ~CritSect();
    void Grab();
    void Release();

  protected:
    CRITICAL_SECTION _cs;
};

// Same as MutexGrabber

class CritSectGrabber {
  public:
    CritSectGrabber(CritSect& cs, Bool grabIt = TRUE);
    ~CritSectGrabber();

  protected:
    CritSect& _cs;
    Bool grabbed;
};

/////////////////////////  Semaphores  //////////////////////

// Simple encapsulation of a semaphore object.  Initialize with the
// semaphore's maximum count, and grab and release can specify a
// number of times to grab or release the semaphore.  Upon
// initialization, the semaphore starts out with the maximum count.
// See general documentation on semaphores to understand what these
// mean.
class Semaphore {
  public:
    Semaphore(int initialCount = 1, int maxCount = 1);
    ~Semaphore();
    void Decrement(int times = 1);

    // This returns the count *after* the increment took place. 
    int  Increment(int times = 1);

#if _DEBUG
    int _count;
    int _maxCount;
#endif
    
  protected:
    void *_semaphore;
    
};

class SemaphoreGrabber {
  public:
    SemaphoreGrabber(Semaphore& s, int times) : _s(s),_times(times) {
        _s.Decrement(_times);
    }
    ~SemaphoreGrabber() {
        _s.Increment(_times);
    }

  protected:
    Semaphore & _s;
    int _times;
};

/////////////////////////  Events  //////////////////////
// Simple encapsulation of an event object.

class Win32Event
{
  public:
    Win32Event(bool bManualReset = FALSE,bool bInitState = FALSE);
    ~Win32Event();

    void Signal() { SetEvent(_hEvent); }
    void Reset() { ResetEvent(_hEvent); }
    void Wait();

    bool IsManual() { return _bManual;}
  protected:
    HANDLE _hEvent;
    bool _bManual;
};

class EventGrabber
{
  public:
    EventGrabber(Win32Event & event)
    : _e(event) { _e.Wait(); }
    ~EventGrabber()
    { if (!_e.IsManual()) _e.Signal(); }
  protected:
    Win32Event & _e;
};

#endif /* _MUTEX_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\opt.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    General header for optimizations done in the engine

*******************************************************************************/

#ifndef _ENGINEOPT_H
#define _ENGINEOPT_H

#include "server/view.h"

#define CONSTANT_FOLD_OPT 2
#define CACHE_IMAGE_OPT   4
#define DRECT_OPT         8

extern BOOL engineOptimization;

#define REGISTRYENGINEOPT(opttype) (engineOptimization==1 || (engineOptimization & opttype))

// BUGBUG: neither of these macros checks if GetCurrentView/Prefs returns NULL

#define PERVIEW_DRECTS_ON  (REGISTRYENGINEOPT(DRECT_OPT) && GetCurrentView().GetPreferences()._dirtyRectsOn)
#define PERVIEW_BITMAPCACHING_ON  (REGISTRYENGINEOPT(CACHE_IMAGE_OPT) && GetCurrentView().GetPreferences()._BitmapCachingOn)

class RewriteOptimizationParam {
  public:
    int _dummy;
};

class DisjointCalcParam {
  public:
    Transform2 *_accumXform;
    Bbox2      _accumulatedClipBox;

    void CalcNewParamFromBox(const Bbox2 &box, DisjointCalcParam *outParam)
    {
        Bbox2 xfdBox = TransformBbox2(_accumXform, box);
        Bbox2 newBox = IntersectBbox2Bbox2(_accumulatedClipBox,
                                            xfdBox);
        outParam->_accumXform = _accumXform;
        outParam->_accumulatedClipBox = newBox;
    }
};

class CacheParam {
  public:
    CacheParam() :
        _isTexture(false),
        _pCacheToReuse(NULL),
        _cacheWithAlpha(false)
    {}

    ImageDisplayDev *_idev;
    AxAValue        *_pCacheToReuse;
    bool             _isTexture;
    bool             _cacheWithAlpha;
};

// For things to work, these should all be negative
#define PERF_CREATION_ID_FULLY_CONSTANT   -222
#define PERF_CREATION_ID_BUILT_EACH_FRAME -333

// This should be less than PERF_CREATION_ID_FULLY_CONSTANT.
#define PERF_CREATION_INITIAL_LAST_SAMPLE_ID -444

#endif  /* _ENGINEOPT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\movieimg.h ===
#ifndef _MOVIEIMG_H
#define _MOVIEIMG_H


/*-------------------------------------
Copyright (c) 1996 Microsoft Corporation

Abstract:

Projected Geometry Image class declaration
-------------------------------------*/

#include "privinc/imgdev.h"
#include "privinc/imagei.h"
#include "privinc/dibimage.h"
#include "privinc/storeobj.h"
#include "privinc/bbox2i.h"
#include "privinc/helpq.h"
#include "privinc/bufferl.h"
#include "backend/moviebvr.h"

class MovieImageFrame; // forward decl

//////////////  Image from Movie  ////////////////////
class MovieImage : public DiscreteImage {
  public:
    MovieImage(QuartzVideoReader *videoReader, Real res);
    virtual ~MovieImage() { CleanUp(); }
    virtual void CleanUp();
        
    virtual void Render(GenericDevice& dev) {
        Assert(FALSE && "Shouldn't be rendering on MovieImage");
    }

    Real GetLength() { return _length; }

    void InitIntoDDSurface(DDSurface *ddSurf,
                           ImageDisplayDev *dev)
    {
        if(!_dev)
            dev = _dev;
        else if(_dev != dev)
            RaiseException_UserError(E_FAIL, IDS_ERR_IMG_MULTI_MOVIE);
    }
    
    char *GetURL() { return(_url); }

#if _USE_PRINT
    ostream& Print (ostream &os) { return os << "MovieImage" ; }
#endif

    virtual VALTYPEID GetValTypeId() { return MOVIEIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == MovieImage::GetValTypeId() ||
                DiscreteImage::CheckImageTypeId(type));
    }

  protected:
    ImageDisplayDev    *_dev;
    Real                _length;

  private:
    char               *_url;
};

class MovieImagePerf;

// the MovieImageFrame subclasses from a DiscreteImage.
// This image subclasses from DiscreteImage
// so that we get discrete image optimizations
// This class is intended to last one frame.  it's an
// instance of the movie: (movie X time)
class MovieImageFrame : public DiscreteImage {
  public:
    MovieImageFrame(Real time, MovieImagePerf *p);

    Real GetTime() { return _time; }
    MovieImage *GetMovieImage() {  return _movieImage; }
    void InitIntoDDSurface(DDSurface *, ImageDisplayDev *) { Assert(FALSE); }
    void Render(GenericDevice& _dev);
    virtual void DoKids(GCFuncObj proc);
    MovieImagePerf *GetPerf() { return _perf; }
    
    virtual VALTYPEID GetValTypeId() { return MOVIEIMAGEFRAME_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == MovieImageFrame::GetValTypeId() ||
                DiscreteImage::CheckImageTypeId(type));
    }

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "MovieImageFrame(" << _time << ")" ;
    }
#endif

  private:
    MovieImage *_movieImage;
    Real        _time;
    MovieImagePerf *_perf;
};

#endif /* _MOVIEIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\overimg.h ===
#ifndef _OVERIMG_H
#define _OVERIMG_H


/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

-------------------------------------*/

#include "privinc/imagei.h"
#include "privinc/bbox2i.h"

class OverlayedImage : public Image {
    friend class DirectDrawImageDevice;

  public:

    OverlayedImage(Image *top, Image *bottom);

    void SetTopBottom(Image *top, Image *bottom) {
        _top = top; 
        _bottom = bottom;
    }

    Image *Top() { return _top; }
    Image *Bottom() { return _bottom; }

    // Rendering an overlayed image uses a painter's algorithm:
    // Render the bottom first, then the top.
    void Render(GenericDevice& _dev);

    // This function will be used by Render(), and by the
    // OverlayArrayImage::Render method as well, thus it's broken out
    // into a static method.
    static void OverlayPairRender(Image *top,
                                  Image *bottom,
                                  GenericDevice& dev);

    const Bbox2 _BoundingBox();

    const Bbox2 BoundingBox() {
        return CacheImageBbox2(this, _cached, _cachedBbox);
    }

    Real DisjointBBoxAreas(DisjointCalcParam &param);
    
    void _CollectDirtyRects(DirtyRectCtx &ctx);

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return UnionBbox2Bbox2(_top->BoundingBoxTighter(bbctx),
                               _bottom->BoundingBoxTighter(bbctx));
    }
#endif  // BOUNDINGBOX_TIGHTER

    const Bbox2 OperateOn(const Bbox2 &box) {
        return IntersectBbox2Bbox2(box, BoundingBox());
    }

    Bool  DetectHit(PointIntersectCtx& ctx);

#if _USE_PRINT
    ostream& Print (ostream &os) {
        return os << "Overlay(" << _top << ", " << _bottom << ")";
    }
#endif

    int  Savings(CacheParam& p);
    
    /* treat caching for overlays specially */
    AxAValue _Cache(CacheParam &p);  

    virtual VALTYPEID GetValTypeId() { return OVERLAYEDIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == OverlayedImage::GetValTypeId() ||
                Image::CheckImageTypeId(type));
    }

    virtual void DoKids(GCFuncObj proc);

    bool ContainsOcclusionIgnorer() {
        return _containsOcclusionIgnorer;
    }

    virtual void Traverse(TraversalContext &ctx) {
        _bottom->Traverse(ctx);
        _top->Traverse(ctx);
    }
    
  protected:

    static void DoOpacity(Image *image, ImageDisplayDev &dev);
    Image *_top;
    Image *_bottom;
    bool  _cached;
    Bbox2 _cachedBbox;
    Real  _cachedDisjointArea;
    bool  _containsOcclusionIgnorer;
};

Bool DetectHitOnOverlaidArray(PointIntersectCtx& ctx,
                              LONG               numImages,
                              Image            **images,
                              bool               containsOcclusionIgnorer);

#endif /* _OVERIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\path.h ===
#ifndef _PATH_H
#define _PATH_H

/*******************************************************************************

Copyright (c) 1996 Microsoft Corporation

Abstract:

    Static tree path class

    We need to form addresses based on ID'd nodes in the performance tree.
    "C" wrappers are provided so methods may be accessed from ML.

    NOTE:  This is a brute force first pass implementation
*******************************************************************************/

class AVPathImpl;
typedef AVPathImpl* AVPath;

const int SNAPSHOT_NODE = 0; // identifies a path as resulting from snapshot
const int RUNONCE_NODE = -1; // identifies a path as resulting from runOnce

AVPath AVPathCreate();
void AVPathDelete(AVPath);
void AVPathPush(int, AVPath);
void AVPathPop(AVPath);
int AVPathEqual(AVPath, AVPath);
AVPath AVPathCopy(AVPath);
void AVPathPrint(AVPath);
void AVPathPrintString(AVPath, char *);
char* AVPathPrintString2(AVPath);
int AVPathContainsPostfix(AVPath, AVPath postfix);
bool AVPathContains(AVPath, int value);
AVPath AVPathCopyFromLast(AVPath, int);

class AVPathListImpl;
typedef AVPathListImpl* AVPathList;

AVPathList AVPathListCreate();
void AVPathListDelete(AVPathList);
void AVPathListPush(AVPath, AVPathList);
int AVPathListFind(AVPath, AVPathList);
AVPathList AVEmptyPathList();
int AVPathListIsEmpty(AVPathList);

#endif /* _PATH_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\pervasiv.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _PERVASIV_H
#define _PERVASIV_H

extern BOOL InInit ;

#endif /* _PERVASIV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\pcm.h ===
#ifndef _PCM_H
#define _PCM_H


/**********************************************************************
The PCM class is intended to be a base class which other classes will
derive from to have PCM 'smarts'

In this way we define the math and meaning of terms only once and never
have the problems with inconsistancies which plague this type of code!
**********************************************************************/
class TimeClass {
  public:
    TimeClass() : _numSeconds(0) {}

    // queries
    virtual double GetNumberSeconds() { return(_numSeconds); }
    virtual void SetNumberSeconds(double seconds) { _numSeconds = seconds; }

    LONGLONG SecondsToQuartzTime(double seconds)
        { return((LONGLONG)(seconds * 10000000.0)); }
    double QuartzTimeToSeconds(LONGLONG qTime)
        { return((double)qTime / 10000000.0); }

  private:
    double _numSeconds;
};

class PCM : public TimeClass {
  public:
    PCM() : _sampleByteWidth(0), _numChannels(0), _frameRate(0), _numBytes(0) {}

    // conversions
    long BytesToFrames(long bytes)
        { return(bytes / _sampleByteWidth / _numChannels); }
    double BytesToSeconds(long bytes)
        { return((double)bytes / _frameRate / _sampleByteWidth /  _numChannels); }

    long FramesToBytes(long frames)
        { return(frames * _sampleByteWidth * _numChannels); }
    double FramesToSeconds(long frames)
        { return((double)frames / _frameRate); }
    LONGLONG FramesToQuartzTime(long frames)
        { return(SecondsToQuartzTime(FramesToSeconds(frames))); }

    long SecondsToFrames(double seconds)
        { return(long)(seconds * _frameRate); }
    long SecondsToBytes(double seconds)
        { return(long)(seconds * _frameRate * _sampleByteWidth * _numChannels); }


    // duration setting
    void SetNumberFrames(long frames) { _numBytes = FramesToBytes(frames); }
    void SetNumberBytes( long  bytes) { _numBytes = bytes; }
    void SetNumberSeconds(double seconds) 
        { _numBytes = SecondsToBytes(seconds); }

    // format setting (do we need individual calls in case things change?)
    void SetPCMformat(int bw, int nc, int fr)
    { _sampleByteWidth = bw; _numChannels = nc; _frameRate = fr; }

    void SetPCMformat(WAVEFORMATEX format) {
        _numChannels     = format.nChannels;
        _frameRate       = format.nSamplesPerSec;
        _sampleByteWidth = format.wBitsPerSample/8;
    }

    void SetPCMformat(PCM *pcm) {
        // for now copy fields, but maybe it can be better done with assignment
        Assert(pcm);

        _numChannels     = pcm->GetNumberChannels();
        _frameRate       = pcm->GetFrameRate();
        _sampleByteWidth = pcm->GetSampleByteWidth();
        _numBytes        = pcm->GetNumberBytes();
    }

    /* void SetWaveFormat(WAVEFORMATEX *pcmwf) {
	memset(pcmwf, 0, sizeof(WAVEFORMATEX));
	pcmwf->wFormatTag     = WAVE_FORMAT_PCM;
	pcmwf->nChannels      = GetNumberChannels();
	pcmwf->nSamplesPerSec = GetFrameRate(); //they realy mean frames!
	pcmwf->nBlockAlign    = FramesToBytes(1);
	pcmwf->nAvgBytesPerSec= SecondsToBytes(1.0);
	pcmwf->wBitsPerSample = GetSampleByteWidth() * 8;
    }*/



    // queries
    int    GetSampleByteWidth() { return(_sampleByteWidth); }
    int    GetNumberChannels()     { return(_numChannels); }
    int    GetFrameRate()       { return(_frameRate); }
    int    GetNumberBytes()     { return(_numBytes); }
    int    GetNumberFrames()    { return(BytesToFrames(_numBytes)); }
    double GetNumberSeconds()   { return(BytesToSeconds(_numBytes)); }

  private:
    int _sampleByteWidth;
    int _numChannels;
    int _frameRate;
    int _numBytes;
};


#endif /* _PCM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\path2i.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    2D paths

*******************************************************************************/


#ifndef _PATH2I_H
#define _PATH2I_H

#include "include/appelles/path2.h"
#include "privinc/storeobj.h"
#include "privinc/probe.h"

class Path2Ctx;
class LineStyle;
class BoundingPolygon;
class PathInfo;
class TransformedPath2;
class TextPath2;
class DAGDI;

class ATL_NO_VTABLE Path2 : public AxAValueObj {
  public:

    // Accumulate a path into the DC for either filling or drawing.  If this is
    // called to fill a path, the forRegion parameter should be set to true.

    void AccumPathIntoDC (HDC hdc, Transform2 *initXform, bool forRegion=false);

    void RenderToDaGdi (DAGDI *daGdi,
                        Transform2 *initXform,
                        DWORD w,
                        DWORD h,
                        Real res,
                        bool forRegion=false);

    // Return the first/last point of the path, in the local coordinate
    // system of the path.  Needed for path concatenation.
    virtual Point2Value *FirstPoint() = 0;
    virtual Point2Value *LastPoint() = 0;

    // Gathers the lengths of the component subpaths and stores accumulated
    // information in a context list.  NOTE:  HDC of Path2Ctx will be nil.

    virtual void GatherLengths (Path2Ctx&) = 0;

    // Returns the point along the path at the normalized [0,1] parameter.

    virtual Point2Value *Sample (PathInfo& pathinfo, Real num0to1) = 0;

    // Accumulate the path into the specified ctx.  Note that this
    // also has the responsibility of setting ctx._lastPoint to the
    // world coordinates of the last point.
    virtual void Accumulate(Path2Ctx& ctx) = 0;

    // Return TRUE (and fill in parameters) if we can pull out points
    // for a single polygon or polybezier.  By default, assume we
    // cannot, and return false.
    virtual Bool ExtractAsSingleContour(
        Transform2 *initXform,
        int *numPts,            // out
        POINT **gdiPts,         // out
        Bool *isPolyline        // out (true = polyline, false = polybezier)
        ) {

        return FALSE;
    }

    virtual const Bbox2 BoundingBox (void) = 0;
#if BOUNDINGBOX_TIGHTER
    virtual const Bbox2 BoundingBoxTighter (Bbox2Ctx &bbctx) = 0;
#endif  // BOUNDINGBOX_TIGHTER
    virtual Bool DetectHit(PointIntersectCtx& ctx, LineStyle *style) = 0;

    virtual DXMTypeInfo GetTypeInfo() { return Path2Type; }

    virtual AxAValue ExtendedAttrib(char *attrib, VARIANT& val);

    virtual Bool IsClosed() { return false; }

    // Return NULL if the path is something other than a transformed
    // path, otherwise return the TransformedPath
    virtual TransformedPath2 *IsTransformedPath() {
        return NULL;
    }

    virtual TextPath2 *IsTextPath() {
        return NULL;
    }

    virtual int Savings(CacheParam& p) { return 0; }

    virtual bool CanRenderNatively() {
        return false;  // subclass must implement if it can be
                       // rendered natively
    }
};

class TextPath2 : public Path2
{
  public:
    TextPath2(Text *text, bool restartClip);
    Point2Value *FirstPoint();
    Point2Value *LastPoint();
    void GatherLengths (Path2Ctx &context);

    Point2Value *Sample (PathInfo &pathinfo, Real distance);

    void Accumulate(Path2Ctx& ctx);

    const Bbox2 BoundingBox (void);

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter (Bbox2Ctx &bbctx);
#endif  // BOUNDINGBOX_TIGHTER

    Bool DetectHit(PointIntersectCtx& ctx, LineStyle *style);

    virtual void DoKids(GCFuncObj proc);

    virtual TextPath2 *IsTextPath() { return this; }

    Text *GetText() { return _text; }
    bool  GetRestartClip() { return _restartClip; }

    virtual int Savings(CacheParam& p) { return 3; }

  protected:
    Text *_text;
    bool  _restartClip;
};

class TransformedPath2 : public Path2
{
  public:
    TransformedPath2(Transform2 *xf, Path2 *p);

    Point2Value *FirstPoint();
    Point2Value *LastPoint();

    void GatherLengths (Path2Ctx &context);

    Point2Value *Sample (PathInfo &pathinfo, Real distance);

    // Standard push, accumulate, process, and pop...
    void Accumulate(Path2Ctx& ctx);

    // Just apply the transform...
    Bool ExtractAsSingleContour(Transform2 *initXform,
                                int *numPts,            
                                POINT **gdiPts,          
                                Bool *isPolyline);

    const Bbox2 BoundingBox (void);

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter (Bbox2Ctx &bbctx);
#endif  // BOUNDINGBOX_TIGHTER

    Bool DetectHit(PointIntersectCtx& ctx, LineStyle *style);

    virtual void DoKids(GCFuncObj proc);

    virtual Bool IsClosed();

    virtual TransformedPath2 *IsTransformedPath() {
        return this;
    }

    virtual bool CanRenderNatively() {
        return _p->CanRenderNatively();
    }

    Transform2 *GetXf() { return _xf; }
    Path2      *GetPath() { return _p; }

    virtual int Savings(CacheParam& p) { return _p->Savings(p); }

  protected:
    Transform2 *_xf;
    Path2      *_p;
};


// exposed so that we don't have to expose all
// the path2xxxx classes in a header
Path2 *InternalPolyLine2(int numPts, Point2 *pts);

Path2 *Line2(const Point2 &, const Point2 &);

#endif /* _PATH2I_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\privpref.h ===
#pragma once
#ifndef _PRIVPREFS_H
#define _PRIVPREFS_H

/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Internal preferences class

*******************************************************************************/

#include <d3d.h>
#include <d3drm.h>

class PrivatePreferences
{
  public:
    PrivatePreferences();

    void Propagate();

    HRESULT PutPreference(char *prefName, VARIANT v);
    HRESULT GetPreference(char *prefName, VARIANT *pV);

    BOOL                _overrideMode;     // true == override app prefs

    BOOL                _rgbMode;          // true == RGB
    int                 _fillMode;         // Solid / Wireframe / Points
    int                 _shadeMode;        // Flat / Gouraud / Phong
    BOOL                _dithering;        // Disabled / Enabled
    BOOL                _texmapPerspect;   // [Perspective Texmapping] Off / On
    BOOL                _texmapping;       // [Texmapping] Off / On
    int                 _texturingQuality; // D3D RM texture quality
    BOOL                _useHW;            // Use 3D Hardware
    unsigned int        _useMMX;           // Use MMX 3D Software Rendering
    BOOL                _worldLighting;    // Light in World Coordinates

    int                 _clrKeyR;          // color key for transparency
    int                 _clrKeyG;
    int                 _clrKeyB;

    int                 _gcStat;
    BOOL                _jitterStat;
    BOOL                _heapSizeStat;
    BOOL                _dxStat;
    int                 _engineOptimization;
    double              _minFrameDuration;
    BOOL                _spritify;         // temp controls retained mode sound

    BOOL                _volatileRenderingSurface;
    
    // Optimizations
    BOOL                _dirtyRectsOn;
    BOOL                _dynamicConstancyAnalysisOn;
    BOOL                _BitmapCachingOn;

  protected:
    HRESULT DoPreference(char *prefName,
                         BOOL toPut,
                         VARIANT *pV);
};

#endif /* _PRIVPREFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\qmidi.h ===
#ifndef _QMIDI_H
#define _QMIDI_H

/*******************************************************************************
Copyright (c) 1997 Microsoft Corporation

    Private include file for defining quartz MIDI sounds.
*******************************************************************************/

#include "appelles/sound.h"

#include "privinc/storeobj.h"
#include "privinc/helpq.h"

class qMIDIsound : public LeafSound {
  public:
    qMIDIsound();
    ~qMIDIsound();
    virtual void Open(char *fileName);

#if _USE_PRINT
    ostream& Print(ostream& s) { return s << "MIDI"; }
#endif

    virtual bool   RenderAvailable(MetaSoundDevice *);
    double GetLength();

    virtual SoundInstance *CreateSoundInstance(TimeXform tt);

    QuartzRenderer *GetMIDI() { return _filterGraph; }
    
    static double       _RATE_EPSILON; // change needed to bother quartz

  protected:
    QuartzRenderer     *_filterGraph;
};

#endif /* _QMIDI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\qdev.h ===
#ifndef _QDEV_H
#define _QDEV_H


/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    DirectSound device interface.

*******************************************************************************/

//#include <windows.h>
#include "privinc/path.h"
#include "privinc/snddev.h"
#include "privinc/helpq.h"
#include "privinc/bufferl.h"
#include "privinc/gendev.h"    // DeviceType

class QuartzMIDIdev : public GenericDevice{
  public:
    friend SoundDisplayEffect;

    QuartzMIDIdev();
    ~QuartzMIDIdev();

    DeviceType GetDeviceType()   { return(SOUND_DEVICE); }

    // TODO: Remove it 
    AVPathList GetDonePathList() { return(donePathList); }

    // render methods
    void RenderSound(Sound *snd);
    void RenderSound(Sound *lsnd, Sound *rsnd);
    void BeginRendering();
    void EndRendering();

    // XXX for now; eventually we will have a structure relating many sounds...
    QuartzRenderer *_filterGraph;
    AVPath _path;                // bufferElement path which owns device 

    void StealDevice(QuartzRenderer *filterGraph, AVPath bufferPath);
    void Stop(MIDIbufferElement *);

  protected:
    // path stuff
    AVPathList          donePathList;


    // values to set, get, unset...
};

#endif /* _QDEV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\probe.h ===
#pragma once
#ifndef _PROBE_H
#define _PROBE_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Data types necessary for implementation of 2D and 3D probe.

*******************************************************************************/

#include "appelles/xform.h"
#include "appelles/xform2.h"
#include "appelles/vec2.h"
#include "appelles/image.h"
#include "privinc/imagei.h"
#include "appelles/geom.h"
#include "privinc/geomi.h"
#include "privinc/except.h"
#include "privinc/vec2i.h"

class RMVisualGeo;
struct IDirect3DRMVisual;
struct IDirect3DRMMesh;
struct IDirect3DRMFrame3;



/*****************************************************************************
The HitImageData class stores picking information for images and geometries.
*****************************************************************************/

class HitImageData : public AxAThrowingAllocatorClass {
  public:

    HitImageData() : _hasUserId(false), _userId(NULL) {}

    HitImageData(bool flag, GCIUnknown *id)
    : _hasUserId(flag), _userId(id) { }

    bool HasUserData() { return _hasUserId; }
    GCIUnknown *GetUserData() { return _userId; }

    BOOL operator<(const HitImageData &hi) const {
        return this < &hi ;
    }

    BOOL operator==(const HitImageData &hi) const {
        return this == &hi ;
    }

    typedef enum PickedType {
        Image,
        Geometry
    };

    int          _eventId;
    PickedType   _type;         // geo or image.
    Point2Value *_lcPoint2;     // only fill in one point
    Point3Value *_lcPoint3;

    // Note: the two below are inconsistent because in the 3D case, we happen
    // to have the wcToLc available, which is what we'll ultimately need, so we
    // just stash that.  In the 2D case, we don't, and we don't know if this
    // will be the winner, so we don't calculate it.

    Transform2  *_lcToWc2;      // only fill in one transform

    Vector3Value *_lcOffsetI;    // Pick Local Coord Offset Basis X Vector
    Vector3Value *_lcOffsetJ;    // Pick Local Coord Offset Basis Y Vector
    Point2Value  *_uvPoint2;     // UV point for geom hit

  private:
    bool  _hasUserId;
    GCIUnknown *_userId;
};



/*****************************************************************************
The PointIntersectCtx manages the 2D context for picking.  It maintains the
local-to-world and worl-to-local transforms of the images, and the hit
information as it traverses up the hierarchy.
*****************************************************************************/

class PointIntersectCtx : public AxAThrowingAllocatorClass
{
  public:
    PointIntersectCtx (Point2Value *wcPoint,
                       bool stuffResultsIntoQueue,
                       Real time,
                       Real lastPollTime,
                       LONG  userIDSize,
                       DWORD_PTR *outputUserIDs,
                       double *outputHitPointsArray,
                       LONG *pActualHitsPointer);

    ~PointIntersectCtx();

    void        SetTransform(Transform2 *xf);
    Transform2 *GetTransform();

    // These calls are for accumulating transforms from images only.
    // These are transforms that affect the rendered result.  The
    // other transform (above) is the totall accumulated transform
    // that affects the result, but may not include transforms that
    // affect components of the image like pen width.
    // For example, let's say you have a scaled image, then a scaled
    // path, then a bezier path.  To pick that path you need to know
    // the pen width.  However, the pen width is NOT affected by the
    // scaled path, see ?  it's only affected by image level
    // trnasforms.
    inline void        SetImageOnlyTransform( Transform2 *xf ) {
        _imgOnlyXf = xf;
    }
    inline Transform2 *GetImageOnlyTransform( ) { return _imgOnlyXf; }

    Point2Value *GetLcPoint();
    void         SetLcPoint(Point2Value *pt);
    Point2Value *GetWcPoint() { return _wcPoint; }

    // For recursive invocation.  Caller is responsible for collecting
    // and keeping state data (wc point and transform).  (This is a
    // reasonable request as long as there is only one caller -- else
    // we should move this functionality into this class so that it
    // can just be in one place.)
    void        PushNewLevel(Point2Value *newWcPoint);
    void        RestoreOldLevel(Point2Value *oldWcPoint,
                                Transform2 *oldTransform,
                                Transform2 *oldImageOnlyTransform);

    Real Time (void)         { return _time; }
    Real LastPollTime (void) { return _lastPollTime; }
    bool ResultsBeingStuffedIntoQueue (void) { return _resultsStuffed; }

    LONG    UserIDSize() { return _userIDSize; }
    DWORD_PTR  *OutputUserIDs() { return _outputUserIDs; }
    double *OutputHitPointsArray() { return _outputHitPointsArray; }
    LONG   *ActualHitsPointer() { return _pActualHitsPointer; }

    bool HaveWeGottenAHitYet(void) { return _gotHitYet; }
    void GotAHit(void) { _gotHitYet = true; }

    bool GetInsideOcclusionIgnorer() { return _insideOcclusionIgnorer; }
    void SetInsideOcclusionIgnorer(bool b) {
        _insideOcclusionIgnorer = b;
    }

    // Call when we hit an image with an event id.
    void AddEventId(int id, bool hasData, GCIUnknown *data);

    // Call when we hit an geometry.
    void AddHitGeometry
        (int id, bool hasData, GCIUnknown *udata, Point3Value *lcHitPt,
         Vector3Value *lcOffsetI, Vector3Value *lcOffsetJ, Point2Value *uvPt);

    //  get the hit image data
    vector<HitImageData>& GetResultData();

  protected:

    Point2Value	*_wcPoint;        // Image World Coordinates
    Real		 _time;           // Current Pick Time
    Real		 _lastPollTime;   // Last Pick Time
    bool		 _resultsStuffed;    // established when constructed.

    LONG		 _userIDSize;
    DWORD_PTR	*_outputUserIDs;
    double		*_outputHitPointsArray;
    LONG		*_pActualHitsPointer;

    bool		 _gotHitYet;
    bool		 _insideOcclusionIgnorer;

    Transform2	*_xf;
    Transform2	*_imgOnlyXf;

    Point2Value *_lcPoint;              // Image Local Coordinates
    Bool		 _lcPointValid;

    vector<HitImageData> _hitImages;
};



/*****************************************************************************
The data maintained for a geometry that is hit are all the "pickable geometry"
containers that led up to it, along with the transform under which they were
encountered.
*****************************************************************************/

class HitGeomData : public AxAThrowingAllocatorClass
{
  public:
    HitGeomData() : _hasUserId(false), _userId(NULL) { }

    HitGeomData(bool flag, GCIUnknown *id)
    : _hasUserId(flag), _userId(id) { }

    bool HasUserData() { return _hasUserId; }
    GCIUnknown *GetUserData() { return _userId; }

    int           _eventId;
    Transform3   *_lcToWcTransform;

    BOOL operator<(const HitGeomData &hg) const {
        return this < &hg ;
    }

    BOOL operator==(const HitGeomData &hg) const {
        return this == &hg ;
    }

  private:
    bool _hasUserId;
    GCIUnknown  *_userId;
};



/*****************************************************************************
This class manages the hit information for a particular D3D mesh.  Besides the
'wcHit' member, these fields are used to get the surface coordinates of the
object for texmap picking.
*****************************************************************************/

class HitInfo : public AxAThrowingAllocatorClass
{
  public:

    HitInfo (void)
        : lcToWc(0), texmap(0), hitVisual(0), dxxfInputs(0), mesh(0)
    {
    }

    // Fields Common to Both Picking Methods

    Transform3 *lcToWc;      // Geometry Modeling Coords to World Coords
    Image      *texmap;      // Winner's Texture Mapped Image
    Real        wcDistSqrd;  // Squared World Distance to Hit Point
    Point3Value wcoord;      // World Coordinates of Hit

    // Fields for RM6+ Picking

    Point2Value surfCoord;   // Surface Coordinate of Pick Point

    // For picking into dxtransforms
    IDirect3DRMVisual *hitVisual;
    int                hitFace;
    AxAValue          *dxxfInputs;
    int                dxxfNumInputs;
    Geometry          *dxxfGeometry;

    // Fields for old-style (pre RM6) Picking

    Point3Value      scoord;      // Screen Coords of Hit
    IDirect3DRMMesh *mesh;        // Hit D3D Mesh
    LONG             group;       // Group Index of Hit D3D RM Mesh
    ULONG            face;        // Face Index Of Hit D3D RM Mesh
};



/*****************************************************************************
For 3D picking via a pick ray; this maintains the coordinate transforms and
the hit information.
*****************************************************************************/

class GeomRenderer;

class RayIntersectCtx : public AxAThrowingAllocatorClass
{
  public:

    RayIntersectCtx (void)
        :
        _gRenderer (NULL),
        _winner (NULL),
        _texmap (0),
        _texmapLevel (0),
        _gotAWinner (false),
        _lcToWc (identityTransform3),
        _pickFrame (NULL),
        _dxxfNumInputs(0),
        _dxxfInputs(NULL),
        _dxxfGeometry(NULL),
        _subgeo(NULL),
        _upsideDown(false)
    { }

    ~RayIntersectCtx (void);

    // The Init() method returns false if initialization failed.

    bool Init (PointIntersectCtx&, Camera*, Geometry*);

    // These methods set/query the local-to-world transform for geometries.

    void         SetLcToWc (Transform3 *xf);
    Transform3  *GetLcToWc (void);

    // These two functions control the attribution of geometries for texture-
    // mapping.  The probe traverser calls SetTexture with each new texmap
    // attribution, descends into the geometry, and then calls EndTexmap() to
    // end the scope of the current texture.  These two functions
    // automatically manage the semantics of overriding attribution.

    void SetTexmap (Image *texture, bool upsideDown);
    void EndTexmap (void);

    // Control whether or not we're interested in texture and submesh
    // information.
    void SetDXTransformInputs(int numInputs,
                              AxAValue *inputs,
                              Geometry *dxxfGeo) {
        _dxxfNumInputs = numInputs;
        _dxxfInputs = inputs;
        _dxxfGeometry = dxxfGeo;
    }

    // Return the world-coordinate pick ray.

    Ray3 *WCPickRay (void) const;

    // These methods manage the candidate stack.

    void PushPickableAsCandidate (int eventId, bool hasData, GCIUnknown *data);
    void PopPickableAsCandidate (void);

    // Submit hit information to the ray-intersection context.  This also
    // copies the candidate data into the winner data if the hit is closer
    // than any prior hit.

    void SubmitHit (HitInfo *hit);

    // Return true if the given world-coordinate point is closer than the
    // current pick winner.

    bool CloserThanCurrentHit (Point3Value &wcPoint);

    // Process the events, and return whether or not any geometry was hit.

    bool ProcessEvents (void);

    // Submit a hit test on a Direct3D RM visual.

    void Pick (IDirect3DRMVisual *vis);

    void SubmitWinner(Real hitDist,
                      Point3Value &pickPoint,
                      float   tu,
                      float   tv,
                      int     faceIndex,
                      IDirect3DRMVisual *hitVisual);

    void SetPickedSubGeo(Geometry *subGeo, float tu, float tv);

    Geometry *GetPickedSubGeo(float *ptu, float *ptv);

    bool LookingForSubmesh();
    bool GotTheSubmesh();

    Camera *GetCamera (void) const;    // Query the Current Camera

  protected:

    // Flags
    bool _gotAWinner;   // True if We Currently Have a Valid Hit
    bool _rmraypick;    // True if Using RM Ray Picking (RM6+)
    bool _upsideDown;

    Camera     *_camera;       // Camera Used for Projected Geometry
    Ray3       *_wcRay;        // World-Coordinate Pick Ray
    Transform3 *_lcToWc;       // Local-To-World Transform
    Image      *_texmap;       // Current Geometry Texture Map
    int         _texmapLevel;  // Current Levels of Texture Mapping
    HitInfo    *_winner;       // Winner Hit Information

    int        _dxxfNumInputs;
    AxAValue  *_dxxfInputs;
    Geometry  *_dxxfGeometry;
    float      _subgeoTu, _subgeoTv;
    Geometry  *_subgeo;

    // NOTE: One we can always count on RM6, we can change _winner to be an
    //       instance of HitInfo, rather than a pointer to one.

    PointIntersectCtx   *_context2D;         // 2D Picking Context

    vector<HitGeomData> _candidateData;      // Hit Data: Candiate Hit Point
    vector<HitGeomData> _currentWinnerData;

    // Variables for Old-Style Picking

    GeomRenderer *_gRenderer;   // Renderer Object Hijacked for Picking

    // Variables for RM Ray-Picking

    IDirect3DRMFrame3* _pickFrame;  // Frame for RM Ray Picking
};


inline Camera* RayIntersectCtx::GetCamera (void) const
{
    return _camera;
}


inline Ray3* RayIntersectCtx::WCPickRay (void) const
{
    return _wcRay;
}


bool PerformPicking (Image *img,
                     Point2Value *wcPos,
                     bool stuffResults,
                     Real time,
                     Real lastPollTime,
                     LONG size = 0,
                     DWORD_PTR *userIds = NULL,
                     double *points = NULL,
                     LONG *actualHits = NULL);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\quati.h ===
#ifndef _QUATI_H
#define _QUATI_H

/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:



Revision:



--*/

#ifdef QUATERNIONS_REMOVED_FOR_NOW

#include "appelles/common.h"
#include "appelles/valued.h"
#include <appelles/vec3.h>

class Quaternion : public AxAValueObj
{
 public:
    // Note: in order for transformations based on quaternions to work, u must
    // be a unit vector.
    Quaternion(Real cc, Vector3Value *uu) : 
       heapCreatedOn(GetHeapOnTopOfStack()), angleCalc(FALSE), c(cc) 
       { u = uu; }

    // This takes the quaternion components c and u as well as what they mean graphically: angle + axis.
    Quaternion(Real cc, Vector3Value *uu, Real angl, Vector3Value *axi) : 
       heapCreatedOn(GetHeapOnTopOfStack()), c(cc), angle(angl), angleCalc(TRUE) 
       { u = uu; axis = axi; }

    Real C() { return c; }
    Vector3Value *U() { return u; }

    Real Angle() { 
        if(!angleCalc)        {
            angle = 2*acos(c);
            angleCalc = TRUE;
        }
        return angle;
    }
    
    Vector3Value *Axis() {
        if (!angleCalc) {
            PushDynamicHeap(heapCreatedOn);
            axis = u/sin(Angle()/2.0);
            PopDynamicHeap();
            angleCalc = TRUE;
        }
        return axis;
    }

 private:
    Real c;                        // Real component
    Vector3Value *u;               // Imaginary (actualy a 3D vector) component

    Real angle;                        // Cache theta. Useful for extraction of composed Quaternions
    Vector3Value *axis;                // Cache axis of rotation.  Same as theta. NOT NORMALIZED!

    DynamicHeap& heapCreatedOn;
    Bool angleCalc;                // For lazy eval of angle and axis.
};

#endif QUATERNIONS_REMOVED_FOR_NOW

#endif                          // _QUATI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\polygon.h ===
#ifndef _POLYGON_H
#define _POLYGON_H


/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    bounding Polygon header

-------------------------------------*/

#include "appelles/xform2.h"

//
// Helper function to create and initialize a BoundingPolygon
//
class BoundingPolygon;
BoundingPolygon *NewBoundingPolygon(const Bbox2 &box=NullBbox2);

class BoundingPolygon : public AxAValueObj {

    friend BoundingPolygon *NewBoundingPolygon(const Bbox2 &box);
    
  private:
    // can only be constructed through helper function
    BoundingPolygon();
    void PostConstructorInitialize(void);

  public:
    ~BoundingPolygon();
    void SetBox(const Bbox2 &box);

    void Crop(const Bbox2 &box);
    void Transform(Transform2 *xform);

    // returns number of verts in polygon.
    // copied to vert array iff number >= 3
    int  GetPointArray(Point2Value **vertArray,
                       Bool clockwise=FALSE,
                       bool * pbReversed=NULL);
    
    int GetPointCount() { return _vertexCount; }

    const Bbox2 BoundingBox();

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx);
#endif  // BOUNDINGBOX_TIGHTER

    void AddToPolygon(BoundingPolygon &pgon);
    void AddToPolygon(int numPts, Point2Value **pts);

    Bool PtInPolygon(Point2Value *pt);

    virtual void DoKids(GCFuncObj proc);
    
    // TODO: Not a type in avrtypes.h??
    virtual DXMTypeInfo GetTypeInfo() { return AxATrivialType; }

    #if _DEBUG
    void BoundingPolygon::_debugOnly_Print();
    #endif

  private:
    void TestAndAdd(Real axis,
                    Real ax, Real ay,
                    Real bx, Real by,
                    Bool aOut,
                    Bool bOut,
                    Bool XY,
                    Point2Value *b,
                    list<Point2Value *> *vertList);

    void ForceTransform();

    int _vertexCount;
    Transform2 *_accumXform;
    Bool _xfDirty;

    list<Point2Value *> *_vertList;
};


#endif /* _POLYGON_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\resource.h ===
/*******************************************************************************
Copyright (c) 1996-1998 Microsoft Corporation.  All rights reserved.

    Direct Animation Resources.  To add new messages, define the constant ID
    here, and add the English description to src/appel/rsrc/danim.rc.

*******************************************************************************/


#ifndef _RESOURCE_H
#define _RESOURCE_H

#define IDR_PERVASIVES             10

/* .X File Resources For VRML reading */
#define IDR_XFILE_SPHERE           13
#define IDR_XFILE_CONE_BODY        14
#define IDR_XFILE_CONE_BOTTOM      15
#define IDR_XFILE_CYLINDER_TOP     16
#define IDR_XFILE_CYLINDER_BOTTOM  17
#define IDR_XFILE_CYLINDER_BODY    18
#define IDR_XFILE_CUBE_TOP         20
#define IDR_XFILE_CUBE_BOTTOM      21
#define IDR_XFILE_CUBE_FRONT       22
#define IDR_XFILE_CUBE_BACK        23
#define IDR_XFILE_CUBE_LEFT        24
#define IDR_XFILE_CUBE_RIGHT       25

#define IDR_DXACTRL                101
#define IDR_DXACTRL_WINDOWED       102

#define IDB_DXACTRL                111
#define IDB_DXACTRL_WINDOWED       112

#define ERROR_BASE                200
#define STATUS_BASE              1200

#define IDS_OPENING_FILE      (STATUS_BASE + 0)
#define IDS_DOWNLOAD_FILE     (STATUS_BASE + 1)
#define IDS_DOWNLOAD_PCT_FILE (STATUS_BASE + 2)

// Define the error messages - separate by module
// Save the first section for general errors

#define SRV_ERROR_BASE        (ERROR_BASE + 100) // Server
#define BE_ERROR_BASE         (ERROR_BASE + 200) // Back End
#define GEO_ERROR_BASE        (ERROR_BASE + 300) // Geometry values & operations
#define IMG_ERROR_BASE        (ERROR_BASE + 400) // Image values & operations
#define SND_ERROR_BASE        (ERROR_BASE + 500) // Sound values & operations
#define SPLINE_ERROR_BASE     (ERROR_BASE + 600) // Spline values & operations
#define MISCVAL_ERROR_BASE    (ERROR_BASE + 700) // Misc values & operations
#define EXTEND_ERROR_BASE     (ERROR_BASE + 800) // Extensibility operations


////////////  General errors


#define IDS_ERR_FILE_NOT_FOUND         (ERROR_BASE + 0)   /* %1 - URL */
#define IDS_ERR_INVERT_SINGULAR_MATRIX (ERROR_BASE + 1)   /* No params */
#define IDS_ERR_STACK_FAULT            (ERROR_BASE + 2)   /* No params */
#define IDS_ERR_DIVIDE_BY_ZERO         (ERROR_BASE + 3)   /* No params */
#define IDS_ERR_OUT_OF_MEMORY          (ERROR_BASE + 4)   /* No params */

#ifdef _DEBUG
#define IDS_ERR_OUT_OF_MEMORY_DBG      (ERROR_BASE + 5)   /* %1 - Amount of memory, %2 - msg */
#endif

#define IDS_ERR_ABORT                  (ERROR_BASE + 6)   /* No params */
#define IDS_ERR_INVALIDARG             (ERROR_BASE + 7)   /* No params */
#define IDS_ERR_CORRUPT_FILE           (ERROR_BASE + 8)   /* %1 - URL */
#define IDS_ERR_OPEN_FILE_FAILED       (ERROR_BASE + 9)   /* %1 - Filename */
#define IDS_ERR_INTERNAL_ERROR         (ERROR_BASE + 10)  /* No params */
#define IDS_ERR_MATRIX_NUM_ELEMENTS    (ERROR_BASE + 11)  /* No params */
#define IDS_ERR_ZERO_ELEMENTS_IN_ARRAY (ERROR_BASE + 12)  /* No params */
#define IDS_ERR_TYPE_MISMATCH          (ERROR_BASE + 13)  /* No params */
#define IDS_ERR_NO_DECODER             (ERROR_BASE + 14)  /* %1 - filename*/
#define IDS_ERR_DECODER_FAILED         (ERROR_BASE + 15)  /* %1 - filename*/
#define IDS_ERR_UNKNOWN_MIME_TYPE      (ERROR_BASE + 16)  /* %1 - filename*/
#define IDS_ERR_ACCESS_DENIED          (ERROR_BASE + 17)  /* %1 - URL */
#define IDS_ERR_SHARING_VIOLATION      (ERROR_BASE + 18)  /* %1 - URL */
#define IDS_ERR_NOT_READY              (ERROR_BASE + 19)  /* No params */
#define IDS_ERR_REGISTRY_ERROR         (ERROR_BASE + 20)  /* No params */
#define IDS_ERR_NOT_IMPLEMENTED        (ERROR_BASE + 21)
#define IDS_ERR_PRE_DX3                (ERROR_BASE + 22)

#define IDS_RENDER_ERROR               (ERROR_BASE + 23) /*Unexpected render error*/
#define IDS_TICK_ERROR                 (ERROR_BASE + 24) /*Unexpected tick error*/
#define IDS_UNEXPECTED_ERROR           (ERROR_BASE + 25) /*Unexpected error*/
#define IDS_DISPLAYCHANGE_ERROR        (ERROR_BASE + 26) /*Unexpected error*/
////////////  Geometry section errors


#define IDS_ERR_GEO_UNABLE_TO_UNZIP        (GEO_ERROR_BASE + 0) /* %1 - filename */

#if INCLUDE_VRML
    #define IDS_ERR_GEO_VRML_READ_ERR        (GEO_ERROR_BASE +1)/*%1=filename*/
    #define IDS_ERR_GEO_VRML_NO_VERTICES     (GEO_ERROR_BASE +2)/*No params*/
    #define IDS_ERR_GEO_VRML_INSUFF_NRM_INDS (GEO_ERROR_BASE +3)/*No params*/
    #define IDS_ERR_GEO_VRML_TXT_CRD_MISMTCH (GEO_ERROR_BASE +4)/*No params*/
    #define IDS_ERR_GEO_VRML_TC_OUT_OF_RANGE (GEO_ERROR_BASE +5)/*No params*/
    #define IDS_ERR_GEO_VRML_INSUFF_MAT_INDS (GEO_ERROR_BASE +6)/*No params*/
#else
    #define IDS_ERR_GEO_VRML_NOT_SUPPORTED   (GEO_ERROR_BASE +1)/*No params*/
#endif

#define IDS_ERR_GEO_CREATE_D3DRM       (GEO_ERROR_BASE + 7) /* No params */
#define IDS_ERR_GEO_AT_FROM_COINCIDENT (GEO_ERROR_BASE + 8) /* No params */
#define IDS_ERR_GEO_PARALLEL_UP        (GEO_ERROR_BASE + 9) /* No params */
#define IDS_ERR_GEO_SINGULAR_CAMERA    (GEO_ERROR_BASE +10) /* No params */
#define IDS_ERR_GEO_CAMERA_FOCAL_DIST  (GEO_ERROR_BASE +11) /* No params */
#define IDS_ERR_GEO_BAD_RMTEXTURE      (GEO_ERROR_BASE +12) /* No params */

#define IDS_ERR_GEO_TMESH_MIN_INDICES  (GEO_ERROR_BASE +13)
#define IDS_ERR_GEO_TMESH_MIN_POS      (GEO_ERROR_BASE +14) /* %1=nPos,  %2=nTris, %3=nPos expected */
#define IDS_ERR_GEO_TMESH_MIN_NORM     (GEO_ERROR_BASE +15) /* %1=nNorm, %2=nTris, %3=nNorm expected */
#define IDS_ERR_GEO_TMESH_MIN_UV       (GEO_ERROR_BASE +16) /* %1=nUV,   %2=nTris, %3=nUV expected */
#define IDS_ERR_GEO_TMESH_OOB_PINDEX   (GEO_ERROR_BASE +17) /* index */
#define IDS_ERR_GEO_TMESH_OOB_NINDEX   (GEO_ERROR_BASE +18) /* index */
#define IDS_ERR_GEO_TMESH_OOB_UINDEX   (GEO_ERROR_BASE +19) /* index */
#define IDS_ERR_GEO_TMESH_BAD_PINDEX   (GEO_ERROR_BASE +20) /* index */
#define IDS_ERR_GEO_TMESH_BAD_NINDEX   (GEO_ERROR_BASE +21) /* index */
#define IDS_ERR_GEO_TMESH_BAD_UINDEX   (GEO_ERROR_BASE +22) /* index */
#define IDS_ERR_GEO_TMESH_BAD_INDICES  (GEO_ERROR_BASE +23)

////////////  Image section errors

#define IDS_ERR_IMG_BAD_BITDEPTH        (IMG_ERROR_BASE + 0) /* %1 - bit depth */
#define IDS_ERR_IMG_OPACITY_DEPTH       (IMG_ERROR_BASE + 1)  /* no params */
#define IDS_ERR_IMG_BMAPEFF_GET_FMT_CNT (IMG_ERROR_BASE + 2)  /* no params */
#define IDS_ERR_IMG_BMAPEFF_GET_FMTS    (IMG_ERROR_BASE + 3)  /* no params */
#define IDS_ERR_IMG_NOT_ENOUGH_PTS_2    (IMG_ERROR_BASE + 4)  /* no params */
#define IDS_ERR_IMG_NOT_ENOUGH_PTS_3    (IMG_ERROR_BASE + 5)  /* no params */
#define IDS_ERR_IMG_NOT_ENOUGH_PTS_4    (IMG_ERROR_BASE + 6)  /* no params */
#define IDS_ERR_IMG_ARRAY_MISMATCH      (IMG_ERROR_BASE + 7)  /* no params */
#define IDS_ERR_IMG_MULTI_MOVIE         (IMG_ERROR_BASE + 8)  /* no params */
#define IDS_ERR_IMG_INVALID_LINESTYLE   (IMG_ERROR_BASE + 9)  /* no params */
#define IDS_ERR_IMG_SURFACE_BUSY        (IMG_ERROR_BASE + 10) /* no params */
#define IDS_ERR_IMG_BAD_DXTRANSF_USE    (IMG_ERROR_BASE + 11) /* no params */

////////////  Sound section errors

#define IDS_ERR_SND_LOADSECTION_FAIL       (SND_ERROR_BASE + 0) /* %1 - filename */

////////////  Server section errors

#define IDS_ERR_SRV_INVALID_ASSOC          (SRV_ERROR_BASE + 0)  /* %1 - extension */
#define IDS_ERR_SRV_INVALID_RUNBVRID       (SRV_ERROR_BASE + 1)  /* %1 - id */
#define IDS_ERR_SRV_BAD_SCRIPTING_LANG     (SRV_ERROR_BASE + 2) /*no param*/
#define IDS_ERR_SRV_SCRIPT_STRING_TOO_LONG (SRV_ERROR_BASE + 3) /*%1-len*/
#define IDS_ERR_SRV_RENDER_NOT_REENTRANT   (SRV_ERROR_BASE + 4) /*no param*/
#define IDS_ERR_SRV_CONST_REQUIRED         (SRV_ERROR_BASE + 5) /*no param*/
#define IDS_ERR_SRV_INVALID_DEVICE         (SRV_ERROR_BASE + 6) /*no param*/
#define IDS_ERR_SRV_VIEW_TARGET_NOT_SET    (SRV_ERROR_BASE + 7) /*no param*/

////////////  Backend section errors

#define IDS_ERR_BE_TYPE_MISMATCH   (BE_ERROR_BASE + 0) /* %1 - str, %2 - type1 , %3 - type2 */
#define IDS_ERR_BE_BAD_INDEX       (BE_ERROR_BASE + 1) /* %1 - prefix, %2 - maxsize, %3 - index */
#define IDS_ERR_BE_TUPLE_LENGTH    (BE_ERROR_BASE + 2) /* no param */
#define IDS_ERR_BE_ALREADY_INIT    (BE_ERROR_BASE + 3) /* no param */
#define IDS_ERR_BE_WRONG_TRIGGER   (BE_ERROR_BASE + 4) /* no param */
#define IDS_ERR_BE_PERF_USERDATA   (BE_ERROR_BASE + 5) /* no param */
#define IDS_ERR_BE_TRANS_CONST_BVR (BE_ERROR_BASE + 6) /* no param */
#define IDS_ERR_BE_TRANS_GONE      (BE_ERROR_BASE + 7) /* no param */
#define IDS_ERR_BE_FINALIZED_SW    (BE_ERROR_BASE + 8) /* no param */
#define IDS_ERR_BE_BAD_SWITCH      (BE_ERROR_BASE + 9) /* no param */
#define IDS_ERR_BE_UNINITIALIZED_BVR    (BE_ERROR_BASE +  10) /* no param */
#define IDS_ERR_BE_NUM_EXTRACT     (BE_ERROR_BASE + 11) /* no param */
#define IDS_ERR_BE_STR_EXTRACT     (BE_ERROR_BASE + 12) /* no param */
#define IDS_ERR_BE_BOOL_EXTRACT    (BE_ERROR_BASE + 13) /* no param */
#define IDS_ERR_BE_UNTILNOTIFY     (BE_ERROR_BASE + 14) /* no param */
#define IDS_ERR_BE_BADHOOKRETURN   (BE_ERROR_BASE + 15) /* no param */
#define IDS_ERR_BE_IMPORTFAILURE   (BE_ERROR_BASE + 16) /* %1 - string descrip*/
#define IDS_ERR_BE_CYCLIC_BVR      (BE_ERROR_BASE + 17) /* no param */
#define IDS_ERR_BE_NON_CONST_DURATION      (BE_ERROR_BASE + 18) /* no param */

#define IDS_ERR_BE_ARRAY_ADD      (BE_ERROR_BASE + 19) /* no param */
#define IDS_ERR_BE_ARRAY_REM      (BE_ERROR_BASE + 20) /* no param */
#define IDS_ERR_BE_ARRAY_FLAG     (BE_ERROR_BASE + 21) /* no param */
#define IDS_ERR_BE_ARRAY_ADD_TYPE (BE_ERROR_BASE + 22) /* no param */

// %1 degree, %2 knots, %3 points
#define IDS_ERR_SPLINE_KNOT_COUNT          (SPLINE_ERROR_BASE + 0) /* no param */
#define IDS_ERR_SPLINE_KNOT_MONOTONICITY   (SPLINE_ERROR_BASE + 1) /* no param */
#define IDS_ERR_SPLINE_BAD_DEGREE          (SPLINE_ERROR_BASE + 2) /* no param */
#define IDS_ERR_SPLINE_MISMATCHED_WEIGHTS  (SPLINE_ERROR_BASE + 3) /* no param */

#define IDS_ERR_MISCVAL_BAD_EXTRUDE     (MISCVAL_ERROR_BASE + 0) /* no params */

#define IDS_ERR_EXTEND_DXTRANSFORM_FAILED      (EXTEND_ERROR_BASE + 0) /* no param */
#define IDS_ERR_EXTEND_DXTRANSFORM_NEED_DX6    (EXTEND_ERROR_BASE + 1) /* no param */
#define IDS_ERR_EXTEND_DXTRANSFORM_FAILED_LOAD (EXTEND_ERROR_BASE + 2) /* %1 - clsid */
#define IDS_ERR_EXTEND_DXTRANSFORM_CLSID_FAIL  (EXTEND_ERROR_BASE + 3) /* no param */

#define RESID_TYPELIB           1

#endif /* _RESOURCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\registry.h ===
/*******************************************************************************
Copyright (c) 1995_96 Microsoft Corporation

    Support for server preferences stored in the registry.
*******************************************************************************/

#ifndef _REGISTRY_H
#define _REGISTRY_H

#include "privinc/privpref.h"

class RegistryEntry {
  public:
    RegistryEntry();
    RegistryEntry(char *subdirectory, char *item);

  protected:
    void SetEntry(char *subdirectory, char *item);
    bool Open(HKEY *phk);       // return TRUE if this is newly created
    void Close(HKEY hk);

    char *_subdirectory;
    char *_item;
};

class IntRegistryEntry : public RegistryEntry {
  public:
    IntRegistryEntry();
    IntRegistryEntry(char *subdir,
                     char *item,
                     int initialValue   // set to this if key doesn't exist
                     );

    void SetEntry(char *subdir, char *item);

    int  GetValue();

  protected:
    int _defaultVal;
};


typedef void (*UpdaterFuncType)(PrivatePreferences *, Bool);

// Extend the global list of preference updater functions.
extern void ExtendPreferenceUpdaterList(UpdaterFuncType updaterFunc);

// Update all the user preferences.
extern void UpdateAllUserPreferences(PrivatePreferences *prefs,
                                     Bool isInitializationTime);

// Startup a thread in which the property sheet is displayed.  When
// the sheet is exited, the property sheet is destroyed, and the
// thread terminated.
extern void DisplayPropertySheet(HINSTANCE inst, HWND hwnd);

///////////////// Preference strings for registry items

// Engine preference strings
#define PREF_ENGINE_MAX_FPS             "Max FPS"
#define PREF_ENGINE_OVERRIDE_APP_PREFS  "Override Application Preferences"
#define PREF_ENGINE_OPTIMIZATIONS_ON    "Optimizations On"
#define PREF_ENGINE_RETAINEDMODE        "Enable Retained-Mode Extensions"

// 3D preference strings
#define PREF_3D_DITHER_ENABLE    "Dither Enable"
#define PREF_3D_FILL_MODE        "Fill Mode"
#define PREF_3D_LIGHT_ENABLE     "Light Enable"
#define PREF_3D_PERSP_CORRECT    "Perspective Correct Texturing"
#define PREF_3D_RGB_LIGHTING     "RGB Lighting"
#define PREF_3D_SHADE_MODE       "Shade Mode"
#define PREF_3D_TEXTURE_ENABLE   "Texture Enable"
#define PREF_3D_TEXTURE_QUALITY  "Texture Quality"
#define PREF_3D_USEHW            "Enable 3D Hardware Acceleration"
#define PREF_3D_USEMMX           "Use MMX"
#define PREF_3D_VIEWDEPSPEC      "View Dependent Specular"
#define PREF_3D_SORTEDALPHA      "Sorted Transparency"
#define PREF_3D_WORLDLIGHTING    "World-Coordinate Lighting"

// 2D preference strings
#define PREF_2D_COLOR_KEY_RED    "ColorKey Red (0-255)"
#define PREF_2D_COLOR_KEY_GREEN  "ColorKey Green (0-255)"
#define PREF_2D_COLOR_KEY_BLUE   "ColorKey Blue (0-255)"

// Audio preference strings
#define PREF_AUDIO_SW_SYNTH      "Use software synth"
#define PREF_AUDIO_SYNCHRONIZE   "Synchronize via rate and phase"
#define PREF_AUDIO_QMIDI         "Use Quartz MIDI"
#define PREF_AUDIO_FRAMERATE     "Frame Rate"
#define PREF_AUDIO_SAMPLE_BYTES  "Bytes per sample"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\rmvisgeo.h ===
#pragma once
#ifndef _RMVISGEO_H
#define _RMVISGEO_H

/*******************************************************************************
Copyright (c) 1996-1998 Microsoft Corporation.  All rights reserved.

    Building a geometry out of a D3D retained mode visual.
*******************************************************************************/

#include <dxtrans.h>
#include <d3drmvis.h>
#include "privinc/bbox3i.h"
#include "privinc/probe.h"
#include "privinc/colori.h"
#include "privinc/matutil.h"
#include "privinc/d3dutil.h"
#include "privinc/ddrender.h"
#include "privinc/importgeo.h"


    // Class Declarations

class GeomRenderer;
class Transform2;


class AttrState
{ public:
    Color emissive;
    Color diffuse;
    Color specular;
    Real  specularExp;
    Real  opacity;

    IDirect3DRMTexture *texture;

    bool shadowMode;
};



/*****************************************************************************
The MeshInfo class contains information about a given mesh, including the
group and vertex information.  Note that this class does not AddRef() the
given mesh -- it is the responsibility of the caller to handle that.
*****************************************************************************/

class MeshInfo : public AxAValueObj
{
  public:
    MeshInfo();
    ~MeshInfo (void) {
        CleanUp();
    }

    void CleanUp (void);

    void SetMesh (IDirect3DRMMesh* mesh);

    bool IsEmpty (void) const;

    void SetMaterialProperties (
        Color *emissive, Color *diffuse, Color *specular,
        Real specularExp, Real opacity, IDirect3DRMTexture *texture,
        bool shadowmode, int renderDevID);

    IDirect3DRMMesh* GetMesh (void) const;

    Bbox3 GetBox (void);

    void SetD3DQuality (D3DRMRENDERQUALITY);
    void SetD3DMapping (D3DRMMAPPING);

    // Create a meshbuilder from the mesh and cache for subsequent calls.

    IDirect3DRMMeshBuilder* GetMeshBuilder (void);

    // TODO: Not a type in avrtypes.h??

    virtual DXMTypeInfo GetTypeInfo() {
        return AxATrivialType;
    }

  protected:
    IDirect3DRMMesh* _mesh;
    int              _numGroups;

    // Flags

    int  _opacityBugWorkaroundID;

    AttrState  _overrideAttrs;  // Override Attribute Values
    AttrState *_defaultAttrs;   // Default Attr Values For All Mesh Groups

    IDirect3DRMMeshBuilder* _optionalBuilder;
};


    // This method returns true if the mesh has not yet been initialized, or
    // if the meshInfo object has been cleaned up.

inline bool MeshInfo::IsEmpty (void) const
{
    return (_mesh == NULL);
}

    // This method returns the contained RM mesh object.

inline IDirect3DRMMesh* MeshInfo::GetMesh (void) const
{
    return _mesh;
}



/*****************************************************************************
This is the superclass for all D3DRM primitives.  In encompasses both DX3 and
DX6 type objects.
*****************************************************************************/

class ATL_NO_VTABLE RMVisualGeo : public Geometry
{
  public:

    RMVisualGeo (void);

    // The following methods are no-ops for RMVisualGeo's

    void CollectSounds   (SoundTraversalContext &context) {};
    void CollectLights   (LightContext &context) {};
    void CollectTextures (GeomRenderer &device)  {};

    // The GenericDevice render method calls the real Render method.

    void Render (GenericDevice& dev);

    virtual void Render (GeomRenderer &geomRenderer) = 0;


    void RayIntersect (RayIntersectCtx &context);

    virtual void CleanUp (void) = 0;

    virtual IDirect3DRMVisual *Visual (void) = 0;

    virtual Bbox3 *BoundingVol (void) = 0;

    VALTYPEID GetValTypeId() { return RMVISUALGEOM_VTYPEID; }

    class RMVisGeoDeleter : public DynamicHeap::DynamicDeleter
    {
      public:
        RMVisGeoDeleter (RMVisualGeo *obj) : _obj(obj) {}

        void DoTheDeletion (void) {
            _obj->CleanUp();
        }

        RMVisualGeo *_obj;
    };
};



/*****************************************************************************
This class is a superclass for the frame and mesh object classes.
*****************************************************************************/

class ATL_NO_VTABLE RM1VisualGeo : public RMVisualGeo
{
  public:

    // By default, the Render method passes this object to the device's Render
    // method.

    void Render (GeomRenderer &geomRenderer) {
        geomRenderer.Render (this);
    }

    // New virtual function to apply material properties

    virtual void SetMaterialProperties (
        Color *emissive, Color *diffuse, Color *specular,
        Real specularExp, Real opacity, IDirect3DRMTexture *texture,
        bool shadowmode, int renderDevID) = 0;

    virtual void SetD3DMapping (D3DRMMAPPING mapping) = 0;
    virtual void SetD3DQuality (D3DRMRENDERQUALITY quality) = 0;

    Bbox3 *BoundingVol (void) {
        return NEW Bbox3 (_bbox);
    }

  protected:

    Bbox3 _bbox;
};




/*****************************************************************************
The RM1MeshGeo class contains information about a single D3DRM mesh
object.  Note that there's an implicit mesh AddRef for the lifetime of this
class.  Users of this class should Release() the given mesh if they are done
using it after construction of this object.
*****************************************************************************/

class RM1MeshGeo : public RM1VisualGeo
{
  public:

    RM1MeshGeo (IDirect3DRMMesh *mesh, bool trackGenIDs = false);

    ~RM1MeshGeo() {
        CleanUp();
    }

    void CleanUp (void);

    void Render (GeomRenderer &geomRenderer);

    void SetMaterialProperties (
        Color *emissive, Color *diffuse, Color *specular,
        Real specularExp, Real opacity, IDirect3DRMTexture *texture,
        bool shadowmode, int renderDevID);

    void SetD3DQuality (D3DRMRENDERQUALITY quality);
    void SetD3DMapping (D3DRMMAPPING mapping);

    IDirect3DRMVisual *Visual (void) {
        return _meshInfo.GetMesh();
    }

    void MeshGeometryChanged (void);

    #if _USE_PRINT
        ostream& Print (ostream& os) {
            return os << "RM1MeshGeo[" << (void*)(this) << "]";
        }
    #endif

  protected:
    MeshInfo       _meshInfo;
    IDXBaseObject *_baseObj;     // don't keep a reference
};



/*****************************************************************************
The RM1FrameGeo class contains information about a D3DRM frame hierarchy.  It
takes the root frame pointer, and a list of meshes contained in the frame
hierarchy.  NOTE:  The meshes in the list are not AddRef'ed; it is assumed
that they each have a reference from withing the given frame hierarchy.  Users
of this class should Release() the frame (and meshes, if AddRef'ed
individually) if they are done using it after constructing this class.
*****************************************************************************/

class RM1FrameGeo : public RM1VisualGeo
{
  public:

    RM1FrameGeo (
        IDirect3DRMFrame* frame,
        vector<IDirect3DRMMesh*> *internalMeshes,
        Bbox3 *bbox);

    ~RM1FrameGeo() {
        CleanUp();
    }

    void CleanUp (void);

    void SetMaterialProperties (
        Color *emissive, Color *diffuse, Color *specular,
        Real specularExp, Real opacity, IDirect3DRMTexture *texture,
        bool shadowmode, int renderDevID);

    void SetD3DQuality (D3DRMRENDERQUALITY quality);
    void SetD3DMapping (D3DRMMAPPING mapping);

    IDirect3DRMVisual *Visual (void) {
        return _frame;
    }

    virtual void DoKids(GCFuncObj proc);

    #if _USE_PRINT
        ostream& Print (ostream& os) {
            return os << "RM1FrameGeo[" << (void*)(this) << "]";
        }
    #endif

  protected:
    IDirect3DRMFrame *_frame;
    int               _numMeshes;
    MeshInfo        **_meshes;
};



/*****************************************************************************
This class is a superclass for all RM3 interface (RM6) geometries.
*****************************************************************************/

class ATL_NO_VTABLE RM3VisualGeo : public RMVisualGeo
{
  public:

    // By default, the Render method passes this object to the device's Render
    // method.

    void Render (GeomRenderer &geomRenderer) {
        geomRenderer.Render (this);
    }
};



/*****************************************************************************
This class wraps a D3DRMMeshBuilder3 object.
*****************************************************************************/

class RM3MBuilderGeo : public RM3VisualGeo
{
  public:

    RM3MBuilderGeo (IDirect3DRMMeshBuilder3*, bool trackGenIDs);
    RM3MBuilderGeo (IDirect3DRMMesh *);

    // Reset meshbuilder to the contents of the given mesh.

    void Reset (IDirect3DRMMesh*);

    ~RM3MBuilderGeo() {
        CleanUp();
    }

    void CleanUp (void);

    void Render (GeomRenderer &geomRenderer);

    inline IDirect3DRMVisual *Visual (void) {
        return _mbuilder;
    }

    inline Bbox3* BoundingVol (void) {
        return NEW Bbox3 (_bbox);
    }

    #if _USE_PRINT
        ostream& Print (ostream& os) {
            return os << "RM3MBuilderGeo[" << (void*)(this) << "]";
        }
    #endif

    void TextureWrap(TextureWrapInfo *wrapInfo);

    void Optimize (void);

  protected:

    void SetBbox (void);    // Auto-set Meshbuilder Bounding Box

    IDirect3DRMMeshBuilder3 *_mbuilder;  // Wrapped MeshBuilder Object
    IDXBaseObject           *_baseObj;   // For Tracking Generation ID's
    Bbox3                    _bbox;
};



/*****************************************************************************
This class wraps a static (non-animate) D3DRMFrame3 object.
*****************************************************************************/

class RM3FrameGeo : public RM3VisualGeo
{
  public:

    RM3FrameGeo (IDirect3DRMFrame3 *frame);

    ~RM3FrameGeo() {
        CleanUp();
    }

    void CleanUp (void);

    IDirect3DRMVisual *Visual (void) {
        return _frame;
    }

    Bbox3* BoundingVol (void) {
        return NEW Bbox3 (_bbox);
    }

    #if _USE_PRINT
        ostream& Print (ostream& os) {
            return os << "RM3FrameGeo[" << (void*)(this) << "]";
        }
    #endif

    void TextureWrap (TextureWrapInfo *info);

  protected:

    IDirect3DRMFrame3 *_frame;    // Frame Hierarcy
    Bbox3              _bbox;     // Static Cached Bounding Box
};



/*****************************************************************************
This class manages a progressive mesh object.
*****************************************************************************/

class RM3PMeshGeo : public RM3VisualGeo
{
  public:

    RM3PMeshGeo (IDirect3DRMProgressiveMesh *pmesh);

    ~RM3PMeshGeo() {
        CleanUp();
    }

    void CleanUp (void);

    IDirect3DRMVisual *Visual (void) {
        return _pmesh;
    }

    Bbox3* BoundingVol (void) {
        return NEW Bbox3 (_bbox);
    }

    #if _USE_PRINT
        ostream& Print (ostream& os) {
            return os << "RM3PMeshGeo[" << (void*)(this) << "]";
        }
    #endif

  protected:

    IDirect3DRMProgressiveMesh *_pmesh;    // Progressive Mesh

    Bbox3 _bbox;   // The bounding box will always be the largest bounding box
                   // of all possible refinements of the pmesh.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\snddev.h ===
#ifndef _SNDDEV_H
#define _SNDDEV_H


/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    General sound device interface.

*******************************************************************************/

#include "privinc/util.h"
#include "gendev.h"

class DirectSoundDev;

class MetaSoundDevice : public GenericDevice {
  public:
    MetaSoundDevice(HWND hwnd, Real latentsy); // primary constuctor
    MetaSoundDevice(MetaSoundDevice *);        // used to clone existing object
    ~MetaSoundDevice();
    void ResetContext();

    DeviceType GetDeviceType() { return SOUND_DEVICE; }

    Bool GetLooping() { return _currentLooping; }
    void SetLooping() {
        _currentLooping    = TRUE;
        _loopingHasBeenSet = TRUE;
    }
    void UnsetLooping() {
        _currentLooping    = FALSE;
        _loopingHasBeenSet = FALSE;
    }
    Bool IsLoopingSet() { return _loopingHasBeenSet; } // XXX Not needed anymore

    void SetGain(Real r) { _currentGain = r; }
    Real GetGain() { return _currentGain; }

    void SetPan(Real p) { _currentPan = p; }
    Real GetPan() { return _currentPan; }

    void SetRate(Real r) { _currentRate = r; }
    Real GetRate() { return _currentRate; }

    // XXX eventualy might want to move these to protected/use mthd to access
    DirectSoundDev *dsDevice;

    bool AudioDead()    { return(_fatalAudioState); }
    void SetAudioDead() { _fatalAudioState = true;  }

    //_seekMutex
    double     _seek;              // the seek position

  protected:

    // values to set, get, unset...
    double     _currentGain;
    double     _currentPan;
    double     _currentRate;
    bool       _currentLooping;
    bool       _loopingHasBeenSet;
    bool       _fatalAudioState;
};


class SoundDisplayEffect;

MetaSoundDevice *CreateSoundDevice(HWND hwnd, Real latentsy);
void DestroySoundDirectDev(MetaSoundDevice * impl);

void DisplaySound (Sound *snd, MetaSoundDevice *dev);

#endif /* _SNDDEV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\scores.h ===
#ifndef _SCORES_H
#define _SCORES_H

/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Header file for score.  Score is an object that has a Start method
    which takes global time, alpha data and produces a behavior that
    returns beta type.

--*/

#include "appelles/envelope.h"

typedef struct _Unit {
    void* dummy;
}* Unit;

RB_CONST(Unit unit);

typedef TimeType TimeG;

// Unfortunately C++ doesn't support template-based typedef.
// Handler is the generalized case for Scores

// Define the handler implementation first.

template<class A, class B>
class ATL_NO_VTABLE HandlerImpl : public HasRefCount
{
  public:
    virtual B Handle(TimeG, A) = 0;

    virtual void Init(HandlerImpl<A, B>*)
    { RaiseException_InternalError("Handler can only be initialized once."); }
};

// This is used to promote constant to constant handler.
// A constant handler ignores the input data and always
// returns the constant.

template<class A, class B>
class ConstHandlerImpl : public HandlerImpl<A, B>
{
  public:
    ConstHandlerImpl(const B i) : data(i) {}
        
    virtual B Handle(TimeG, A) { return data; }

  private:
    B data;
};

template<class A, class B>
class InitHandlerImpl : public HandlerImpl<A, B>
{
  public:
    InitHandlerImpl() : impl(NULL) {}
    
    virtual B Handle(TimeG t, A data)
    {
        if (!impl)
            RaiseException_InternalError("Handler not initialized.");

        return impl->Handle(t, data);
    }
        
    virtual void Init(HandlerImpl<A, B>* i)
    {
        if (impl)
            RaiseException_InternalError("Handler can only be initialized once.");
        else
        {
            // no need to RefSubDel, since impl == NULL
            impl = i;

            impl->Add(1);
        }
    }

  private:
    HandlerImpl<A, B>* impl;
};

// Handler is an envelope.

template<class A, class B>
class Handler : public Envelope< HandlerImpl<A, B> >
{
  public:
    Handler() {}

    Handler(HandlerImpl<A, B>* i) : Envelope< HandlerImpl<A, B> >(i) {}

    Handler(const B i)
        : Envelope< HandlerImpl<A, B> >(new ConstHandlerImpl<A, B>(i)) {}

    B Handle(TimeG t, A data) { return GetImpl()->Handle(t, data); }

    void Init(Handler<A, B> h) { GetImpl()->Init(h.GetImpl()); }
};

// What really needs is template typedef.
//#define Score(A, B) Handler<A, Bvr<B> >

template<class A, class B>
class Score : public Handler< A, Bvr<B> >
{
  public:
    Score(char* n = NULL)
        : name(n), Handler< A, Bvr<B> >
            (new InitHandlerImpl<A, Bvr<B> >()) {}
    
    Score(HandlerImpl< A, Bvr<B> > *i) : Handler< A, Bvr<B> >(i) {}

    Score(Bvr<B> b)
        : Handler< A, Bvr<B> >(new ConstHandlerImpl<A, Bvr<B> >(b)) {}
    
    Score(const B i) : Handler< A, Bvr<B> >(i) {}

    char* GetName() { return name; }
    
  private:
    char* name;
};

template<class A>
class EventTimeHandlerImpl : public HandlerImpl< A, Bvr<TimeG> >
{
  public:
    virtual Bvr<TimeG> Handle(TimeG t, A) { return t; }
};

template<class A, class B>
class CondScoreImpl : public HandlerImpl< A, Bvr<B> >
{
  public:
    CondScoreImpl(Score<A, Bool> b, Score<A, B> i, Score<A, B> e)
        : bScore(b), iScore(i), eScore(e) {}
    
    virtual Bvr<B> Handle(TimeG t, A data)
    {
        return new CondBvrImpl<B>(bScore.Handle(t, data),
                                  iScore.Handle(t, data),
                                  eScore.Handle(t, data));
    }

  private:
    Score<A, Bool> bScore;
    Score<A, B> iScore;
    Score<A, B> eScore;
};

template<class A, class B>
inline
Score<A, B> Cond(Score<A, Bool> b, Score<A, B> iScore, Score<A, B> eScore)
{ return new CondScoreImpl<A, B>(b, iScore, eScore); }

// Don't know why this is not working...
template<class A>
class EventTime : public Score<A, TimeG>
{
  public:
    EventTime() : Score<A, TimeG>(new EventTimeHandlerImpl<A>()) {}
};

template<class A, class B>
class SnapshotHandlerImpl : public HandlerImpl<A, Bvr<B> >
{
  public:
    SnapshotHandlerImpl(Score<A, B> s) : score(s) {}
    
    virtual Bvr<B> Handle(TimeG t, A data)
    {
        EvalParam tparam(t);
        
        return score.Handle(t, data).Eval(tparam);
    }

  private:
    Score<A, B> score;
};

template<class A, class B>
Handler<A, B>
Snapshot(Score<A, B> s)
{ return new SnapshotHandlerImpl<A, B>(s); }

#endif /* _SCORES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\server.h ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _SERVER_H
#define _SERVER_H

#include "storeobj.h"
#include "privinc/backend.h"
#include "privinc/probe.h"
#include "privinc/mutex.h"
#include "privinc/util.h"
#include "backend/preference.h"
#include <dxtrans.h>

class EventQ ;
class PickQ ;
class DirectDrawImageDevice ;
class DirectSoundDev ;
class MetaSoundDevice ;
class ViewPreferences ;

// ====================================
// These are all thread specific calls
// ====================================

HWND GetCurrentSampleWindow() ;

DynamicHeap & GetCurrentSampleHeap() ;
DynamicHeap & GetGCHeap() ;
DynamicHeap & GetTmpHeap();
DynamicHeap & GetViewRBHeap();

DirectDrawImageDevice * GetImageRendererFromViewport(DirectDrawViewport *);
DirectDrawViewport    * GetCurrentViewport( bool dontCreateOne = false );
MetaSoundDevice       * GetCurrentSoundDevice();
DirectSoundDev        * GetCurrentDSoundDevice();

#if PERFORMANCE_REPORTING
GlobalTimers & GetCurrentTimers();
#endif  // PERFORMANCE_REPORTING

// This is used by the pick queue to approximate the pick function.
Time GetLastSampleTime();

void ReportErrorHelper(HRESULT hr, LPCWSTR szErrorText);
void SetStatusTextHelper(char * szStatus);
void ReportGCHelper(bool bStarting);

bool GetCurrentServiceProvider (IServiceProvider **);

void FreeSoundBufferCache();

// ====================================
// GC Related APIs
// ====================================

GCList GetCurrentGCList() ;
GCRoots GetCurrentGCRoots() ;

// ====================================
// Global functions
// ====================================

void ViewNotifyImportComplete(Bvr bvr, bool bDying);

// ====================================
// EventQ APIs
// ====================================

enum AXAEventId {
    AXAE_MOUSE_MOVE,
    AXAE_MOUSE_BUTTON,
    AXAE_KEY,
    AXAE_FOCUS,
    AXAE_APP_TRIGGER,
} ;

class AXAWindEvent {
  public:
    AXAWindEvent(AXAEventId id,
                 Time when,
                 DWORD x, DWORD y,
                 BYTE modifiers,
                 DWORD data,
                 BOOL bState)
    : id(id),
      when(when),
      x(x), y(y),
      modifiers(modifiers),
      data(data),
      bState(bState) {}

    AXAEventId id;
    Time when;
    DWORD_PTR x;
    DWORD y;
    BYTE modifiers;
    DWORD data;
    BOOL bState;

    bool operator<(const AXAWindEvent &t) const {
        return this < &t ;
    }

    bool operator>(const AXAWindEvent &t) const {
        return this > &t ;
    }

    bool operator!=(const AXAWindEvent &t) const {
        return !(*this == t) ;
    }

    bool operator==(const AXAWindEvent &t) const {
        return (memcmp (this, &t, sizeof(*this)) != 0) ;
    }

    // For STL
    AXAWindEvent () {}
};

AXAWindEvent* AXAEventOccurredAfter(Time when,
                                    AXAEventId id,
                                    DWORD data,
                                    BOOL bState,
                                    BYTE modReq,
                                    BYTE modOpt);

BOOL AXAEventGetState(Time when,
                      AXAEventId id,
                      DWORD data,
                      BYTE mod);

void AXAGetMousePos(Time when, DWORD & x, DWORD & y);

BOOL AXAWindowSizeChanged() ;

// ====================================
// PickQ APIs
// ====================================

// We want to answer the question: at time t, is the cursor over the
// object with a specific id?  Currently we only do polling and record
// the time points where pick is true.  What we want is a continuous
// function.  TODO: Until we have a better approach, like if we can
// tell the cursor just leave the object, I'm using a _lastPollTime
// field to determine if the cursor is still on the pick object. 

struct PickQData {
    Time                      _eventTime;
    Time                      _lastPollTime;
    HitImageData::PickedType  _type;
    Point2Value               _wcImagePt;     // World Coord Image Pick Point
    Real                      _xCoord;
    Real                      _yCoord;
    Real                      _zCoord;
    Transform2               *_wcToLc2;
    Vector3Value              _offset3i;      // Local Coord 3D Pick Offset I
    Vector3Value              _offset3j;      // Local Coord 3D Pick Offset J

    bool operator==(const PickQData & pd) const {
        return (memcmp (this, &pd, sizeof(*this)) != 0) ;
    }

    bool operator!=(const PickQData &pd) const {
        return !(*this == pd) ;
    }

    bool operator<(const PickQData &pd) const {
        return this < &pd ;
    }

    bool operator>(const PickQData &pd) const {
        return this > &pd ;
    }

};

// Converts pixel point to image world coordinate
Point2Value* PixelPos2wcPos (short x, short y);
BOOL CheckForPickEvent(int id, Time time, PickQData & result) ;
// This will copy the pick data
void AddToPickQ (int id, PickQData & data) ;

// ====================================
// Globals
// ====================================

extern HINSTANCE hInst ;

// =============================
// For Backend, these operate on current view
// =============================

class CRView;

void ViewEventHappened();

void TriggerEvent(DWORD eventId, Bvr data, bool bAllViews);
void RunViewBvrs(Time startGlobalTime, TimeXform tt);

CRView *ViewAddPickEvent();
void ViewDecPickEvent(CRView*);

class DiscreteImage;
class DirectDrawImageDevice;

void DiscreteImageGoingAway(DiscreteImage *img,
                            DirectDrawViewport *vprt = NULL);
void SoundGoingAway(Sound *sound);

// Get last sample time (in terms of view global) of the current
// view.   Plus the system times of last sample and current sample
bool ViewLastSampledTime(DWORD& lastSystemTime,
                         DWORD& currentSystemTime,
                         Time & t0);

double ViewGetFrameRate();
double ViewGetTimeDelta();

unsigned int ViewGetSampleID();

#endif /* _SERVER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\sndfile.h ===
#ifndef _SNDFILE_H
#define _SNDFILE_H


class ATL_NO_VTABLE SndFile {
  public:
    //SndFile(): 
        //_fileNumChannels(0),
        //_fileSampleRate(0),
        //_fileBytesPerSample(0),
        //_fileNumSampleBytes(0),
        //_fileLengthSeconds(0),
        //_fileNumFrames(0)
    //{}

    virtual ~SndFile() {}
    virtual int  Read(void *buffer, int numBytes)         = 0;
    virtual int  ReadFrames(void *buffer, int numFrames)  = 0;
    virtual void SeekFrames(long frameOffset, int whence) = 0;

    // temporary methods (these will be replaced by a parameter list)
    virtual int GetByteCount()      {return(_fileNumSampleBytes);}
    virtual int GetFrameCount()     {return(_fileNumFrames);}
    virtual int GetBytesPerSample() {return(_fileBytesPerSample);}
    virtual int GetNumChannels()    {return(_fileNumChannels);}
    virtual int GetSampleRate()     {return((int)_fileSampleRate);}
    virtual double GetLength() {
        return((double)_fileNumSampleBytes / 
               (double)(_fileSampleRate*_fileNumChannels)); }

    // Hacks
    //FileType(char *string);

  protected:
    char  *_fileName;

    // the 'file' parameters (how samples are stored in the file)
    int    _fileNumChannels;
    double _fileSampleRate;
    int    _fileBytesPerSample;
    int    _fileNumSampleBytes;  // number of bytes of audio data in file
    double _fileLengthSeconds;
    int    _fileNumFrames;       // number of frames in the file

    // the 'com' parameters (used to determine the api sample format)
};


class WaveSoundFile : public SndFile {
  public:
    WaveSoundFile(char *fileName);
    ~WaveSoundFile();
    int Read(void *buffer, int numBytes) 
        { return(mmioRead(_fileHandle, (char*)buffer, numBytes)); }

    int ReadFrames(void *buffer, int numFrames) 
        {
        int actualBytes = mmioRead(_fileHandle, (char*)buffer, 
            numFrames * _fileBytesPerSample * _fileNumChannels);

        return(actualBytes / _fileBytesPerSample / _fileNumChannels);
        }

    void SeekFrames(long frameOffset, int whence);


  private:
    HMMIO _fileHandle;
    long  _dataBlockLocation;    // byte count in .wav file where datablock is
    long  _eoDataBlockLocation;  // byte count in file where datablock ends
};

extern SndFile *CreateSoundFile(char *fileName);

#endif /* _SNDFILE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\spritethread.h ===
#ifndef _SPRITETHREAD_H
#define _SPRITETHREAD_H

/*******************************************************************************

Copyright (c) 1997 Microsoft Corporation

Abstract:

    Class which manages sprite thread

*******************************************************************************/

#include "privinc/mutex.h"
#include "privinc/snddev.h"
#include "backend/sprite.h"


class SpriteThread {
  public:
    SpriteThread(MetaSoundDevice *metaDev, RMImpl *updateTree);
    ~SpriteThread();

    // XXX these should probably be private one day...
    bool             _done;
    RMImpl          *_updateTree;
    MetaSoundDevice *_metaDev;

  private:
    DWORD            _threadID;
    HANDLE           _threadHandle;
    //CritSect *_cs;
};

#endif /* _SPRITETHREAD_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\solidimg.h ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implements SolidImage, inifinte single color image.

*******************************************************************************/

#ifndef _SOLIDIMG_H
#define _SOLIDIMG_H

#include <privinc/imagei.h>
#include <privinc/colori.h>
#include <privinc/imgdev.h>

class ImageDisplayDev;

class SolidColorImageClass : public Image {
  public:

    SolidColorImageClass(Color *color) : 
         _color(color), Image() {}

    void Render(GenericDevice& _dev)    { 
        ImageDisplayDev &dev = (ImageDisplayDev &)_dev;
        dev.RenderSolidColorImage(*this); 
    }

    const Bbox2 BoundingBox(void) {
        return UniverseBbox2; 
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return UniverseBbox2; 
    }
#endif  // BOUNDINGBOX_TIGHTER

#if _USE_PRINT
    // Print a representation to a stream.
    ostream& Print(ostream& os) {
        return os << "SolidColorImageClass" << "<bounding box>" << *_color;
    }
#endif

    const Bbox2 OperateOn(const Bbox2 &box) {
        return box;
    }

    Bool DetectHit(PointIntersectCtx& ctx) {
        // A solid color image, being infinite, is always detected. 
        return TRUE;
    }

    Color *GetColor() {
        return _color;
    }

    Bool GetColor(Color **color) {
        *color = _color;
        return TRUE;
    }

    virtual VALTYPEID GetValTypeId() { return SOLIDCOLORIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == SolidColorImageClass::GetValTypeId() ||
                Image::CheckImageTypeId(type));
    }

    virtual void DoKids(GCFuncObj proc);

  protected:  
    Color *_color;
};


#endif /* _SOLIDIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\soundi.h ===
#ifndef _SOUNDI_H
#define _SOUNDI_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Private include file for defining sounds.
*******************************************************************************/

#include <dsound.h>

#include "appelles/sound.h"

#include "privinc/storeobj.h"
#include "privinc/helpds.h"
#include "privinc/dsdev.h"
#include "privinc/snddev.h"
#include "privinc/pcm.h"

// Setup the statics
#define CANONICALFRAMERATE   22050 // reasonably hifi (would preffer 44.1K|48K)
#define CANONICALSAMPLEBYTES     2 // 16bit sound is critical to dynamic range!

class BufferElement;
class SoundDisplayDev;             // forward declaration

class Sound : public AxAValueObj {
  public:
    Sound() {}
    virtual ~Sound() {} // allow objects derived from Sound to have destructors
    virtual DXMTypeInfo  GetTypeInfo()             { return SoundType;     }
    virtual VALTYPEID    GetValTypeId()            { return SOUND_VTYPEID; }

    virtual AxAValueObj *Snapshot() { return silence; }
    
    static double _minAttenuation;
    static double _maxAttenuation;
};


// all the info we need to construct or reconstruct a sound
class SoundContext : public AxAThrowingAllocatorClass {
  public:
    SoundContext() : _looping(false) {}
    ~SoundContext() {}
    bool GetLooping() { return(_looping); }
    void SetLooping(bool looping) { _looping = looping; }
    char *GetFileName() { return(_fileName); }

  protected:

  private:
    bool  _looping;
    char *_fileName;
    // double _time;  // do we need to keep track of the time
};

class SoundInstance;
class ATL_NO_VTABLE LeafSound : public Sound {
  public:
    ~LeafSound();

    // pure virtual? methods the generic render may call
    virtual bool   RenderAvailable(MetaSoundDevice *) = 0;

    virtual SoundInstance *CreateSoundInstance(TimeXform tt) = 0;
};


class LeafDirectSound : public LeafSound {
  public:
    virtual bool RenderAvailable(MetaSoundDevice *metaDev);
    PCM _pcm;          // dsound sounds are PCM sounds!
};


// The sound data is used to hold the relevant attributes of a sound
// after it's been pulled out of a geometry hierarchy.
class SoundData
{
  public:
    Transform3 *_transform;  // Accumulated Modeling Transform
    Sound *_sound;      // sound

    BOOL operator<(const SoundData &sd) const {
        return (this < &sd) ;
    }

    BOOL operator==(const SoundData &sd) const {
        return (this == &sd) ;
    }
};


// The sound context class maintains traversal context while gathering
// sounds from the geometry tree.
class SoundTraversalContext
{
  public:
    SoundTraversalContext();

    void  setTransform (Transform3 *transform) { _currxform = transform; }
    Transform3 *getTransform (void) { return _currxform; }

    void addSound (Transform3 *transform, Sound *sound);
    vector<SoundData> _soundlist; // List of Collected Sounds

  private:
    Transform3 *_currxform;       // Current Accumulated Transform

};


class StaticWaveSound : public LeafDirectSound {
  public:
    StaticWaveSound(unsigned char *origSamples, PCM *pcm);
    ~StaticWaveSound();

    virtual SoundInstance *CreateSoundInstance(TimeXform tt);

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "(static wave sound)";
    }
#endif

  protected:
    unsigned char      *_samples;
};

#endif /* _SOUNDI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\stlsubst.h ===
#ifndef _STLSUBST_H
#define _STLSUBST_H

/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

  Substitute for certain STL functions on void* containers.  This
  allows us to avoid code bloat introduced by frequent STL template
  expansion.  Rule is that individual functions that are large in size
  should have helper functions here.  Additionally, there are macros
  that ensure the typed-value is the same size as the untyped value.

*******************************************************************************/

// Push a void* element onto the back of a void* vector.
extern void VectorPushBackPtr(vector<void*>& vec,
                              void *newElt);

// Push a void* element onto a void* stack.
extern void StackVectorPushPtr(stack<void* >& vec,
                               void *newElt);

#if _DEBUG

// Just use typesafe operations.  Will cause code-bloat, but that's OK
// for debug.
#define VECTOR_PUSH_BACK_PTR(vec, newElt) \
  Assert(sizeof(newElt) == sizeof(void*)); \
  BEGIN_LEAK               \
  (vec).push_back(newElt); \
  END_LEAK

#define STACK_VECTOR_PUSH_PTR(stk, newElt) \
  Assert(sizeof(newElt) == sizeof(void*)); \
  BEGIN_LEAK              \
  (stk).push(newElt);   \
  END_LEAK

#else  /* !_DEBUG */

#define VECTOR_PUSH_BACK_PTR(vec, newElt) \
  (vec).push_back(newElt)

#define STACK_VECTOR_PUSH_PTR(stk, newElt) \
  (stk).push(newElt)

#endif /* DEBUG */

#endif /* _STLSUBST_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\stquartz.h ===
#ifndef _STQUARTZ_H_
#define _STQUARTZ_H_

#include "privinc/helpds.h"
#include "privinc/helpq.h"
#include "privinc/pcm.h"

class StreamQuartzPCM : public LeafDirectSound {
  public:
    StreamQuartzPCM(char *fileName);
    ~StreamQuartzPCM();

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "StreamQuartzPCM";
    }
#endif

    virtual SoundInstance *CreateSoundInstance(TimeXform tt);

    const double GetLatency() { return _latency; }
    char *GetFileName() { return _fileName; }
    unsigned char *GetBuffer() { return _buffer; }
    void SetBuffer(unsigned char *b) { _buffer = b; }

  private:
    const double   _latency;
    char          *_fileName;
    unsigned char *_buffer;    // shuttle buffer
};

#endif /* _STQUARTZ_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\storeobj.h ===
#ifndef _STOREOBJ_H
#define _STOREOBJ_H

/*++

Copyright (c) 1995-96  Microsoft Corporation

Abstract:

    Memory management for static value implementation classes.  Such
    classes derive from StoreObj, which redefine new and delete to
    allocate from dynamic heaps.

--*/

#include "appelles/common.h"
#include "gendev.h"
#include "backend.h"
#include "backend/gc.h"
#include <memory.h>


// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 ) 

class DynamicHeap;
class DirectDrawImageDevice;

class ATL_NO_VTABLE StoreObj : public GCBase {
  public:
    StoreObj();
    
  #if _DEBUGMEM
    void *operator new(size_t s, int blockType, char * szFileName, int nLine);
  #else
    void *operator new(size_t s);
  #endif // _DEBUGMEM
    void  operator delete(void *ptr);
};

// Allocate memory from the current store.  This will throw an
// exception if memory can't be allocated, so don't worry about
// checking the return value.
#if _DEBUGMEM
#define AllocateFromStore(size) AllocateFromStoreFn(size, __FILE__, __LINE__, NULL)
extern void *AllocateFromStoreFn(size_t size,
                                 char * szFileName,
                                 int nLine,
                                 DynamicHeap **ppHeap); // output
#else
#define AllocateFromStore(size) AllocateFromStoreFn(size, NULL)

extern void *AllocateFromStoreFn(size_t size,
                                 DynamicHeap **ppHeap); // output

#endif  // _DEBUGMEM

// Deallocate memory that was allocated on the current store.  Results
// are undefined if the memory was allocated on a different store.
extern void DeallocateFromStore(void *ptr);

//////////// Dynamic Heaps /////////////

//   "Dynamic Heaps" allow the allocation of memory out of a pool that's
// dynamically scoped.  When the heap is "reset", memory starts
// allocating from the beginning.  Performing a "new" on a class
// that derives from StoreObj above allocates off of the "current"
// dynamic heap on the top of the per-thread stack of heaps.  This
// dynamically scoped heap makes senses for situations in which the
// client knows that an objects useful lifetime is over by the time
// the "reset" is done.

//   Subclasses of the abstract dynamic heap object implement
// different allocation policies.  For instance, one will be a "System
// Heap", where everything is allocated off of the true system heap
// store, and "reset" has no effect.  Another will be the
// "TransientHeap", useful for objects with well-understood lifetimes,
// where "reset" actually does cause the memory for these objects to
// be re-used.

class ATL_NO_VTABLE DynamicHeap {
  public:

    // For defining deleters that will be invoked when the store is
    // deleted, provided they are registered via
    // RegisterDynamicDeleter below.
    class ATL_NO_VTABLE DynamicDeleter {
      public:
        virtual void DoTheDeletion() = 0;
    };

    virtual ~DynamicHeap();

    // Allocate memory off of this dynamic heap
#if _DEBUGMEM
    virtual void *Allocate(size_t size, char * szFileName, int nLine) = 0;
#else
    virtual void *Allocate(size_t size) = 0;
#endif

    // Return memory back to this dynamic heap
    virtual void  Deallocate(void *ptr) = 0;

    // Reset the store, and, if debugging AND clear == TRUE,
    // clear it out to a unique value.
    virtual void  Reset(Bool clear = TRUE) = 0;

    // Register a deleter.  When the store is reset, all the
    // registered deleter's will have their method invoked.  The
    // deleter itself will be deleted when reset is called as well.
    virtual void  RegisterDynamicDeleter(DynamicDeleter *deleter) = 0;

    virtual void  UnregisterDynamicDeleter(DynamicDeleter *deleter) = 0;

    virtual size_t PtrSize(void *ptr) = 0;

    virtual bool  IsTransientHeap() = 0;

#if DEVELOPER_DEBUG
    virtual bool  ValidateMemory(void *ptr) = 0;
    // For debugging
    virtual void  Dump() const = 0;
    virtual char *Name() const = 0;
       
    virtual size_t  BytesUsed() = 0;
#endif

};

template <class T>
class DynamicPtrDeleter : public DynamicHeap::DynamicDeleter
{
  public:
    DynamicPtrDeleter(T* p) : ptr(p) {}
    virtual void DoTheDeletion() { delete ptr; }
  private:
    T* ptr;
};


// For creating a transient heap.
extern DynamicHeap&   TransientHeap(char *name,
                                    size_t initial_size,
                                    Real  growth_rate = 1.5);
extern void           DestroyTransientHeap(DynamicHeap& heap);

extern DynamicHeap&   CreateWin32Heap(char *name,
                                      DWORD fOptions,
                                      DWORD dwInitialSize,
                                      DWORD dwMaxSize);
extern void           DestroyWin32Heap(DynamicHeap& heap);

// Push (pop) a dynamic heap onto (off of) the per-thread heap stack.
// new and delete from the StoreObj() class allocate from the
// dynamic heap on the top of the stack.
extern void           PushDynamicHeap(DynamicHeap& heap);
extern void           PopDynamicHeap();
extern void           ResetDynamicHeap(DynamicHeap& heap);

extern DynamicHeap&   GetSystemHeap();
extern DynamicHeap&   GetInitHeap();
extern DynamicHeap&   GetHeapOnTopOfStack();

#if DEVELOPER_DEBUG
extern size_t DynamicHeapBytesUsed();
#endif

class ImageDisplayDev;

// Not all classes need to be added here.  Only the classes which will
// need to be queried.  All others should return UNKNOWN_VTYPEID to
// indicate that they are not part of the enumeration

enum VALTYPEID {
    UNKNOWN_VTYPEID = 0,

    // Basic types
    PRIMOP_VTYPEID,
    PAIR_VTYPEID,
    SOUND_VTYPEID,
    ARRAY_VTYPEID,
    IMAGE_VTYPEID,
    GEOMETRY_VTYPEID,

    // Image subtypes
    SOLIDCOLORIMAGE_VTYPEID,
    CROPPEDIMAGE_VTYPEID,
    TRANSFORM2IMAGE_VTYPEID,
    DISCRETEIMAGE_VTYPEID,
    MOVIEIMAGE_VTYPEID,
    OVERLAYEDIMAGE_VTYPEID,
    OVERLAYEDARRAYIMAGE_VTYPEID,
    PROJECTEDGEOMIMAGE_VTYPEID,
    DIBIMAGE_VTYPEID,
    OPAQUEIMAGE_VTYPEID,
    PLUGINDECODERIMAGE_VTYPEID,
    HTMLIMAGE_VTYPEID,
    MOVIEIMAGEFRAME_VTYPEID,
    CACHEDIMAGE_VTYPEID,
    DIRECTDRAWSURFACEIMAGE_VTYPEID,

    // Geometry subtypes
    AGGREGATEGEOM_VTYPEID,
    MULTIAGGREGATEGEOM_VTYPEID,
    FULLATTRGEOM_VTYPEID,
    SOUNDGEOM_VTYPEID,
    RMVISUALGEOM_VTYPEID,
    LIGHTGEOM_VTYPEID,
    EMPTYGEOM_VTYPEID,
    SHADOWGEOM_VTYPEID,
    DXXFGEOM_VTYPEID
};

class RewriteOptimizationParam;
class CacheParam;

class ATL_NO_VTABLE AxAValueObj : public StoreObj
{
  public:
    AxAValueObj() : StoreObj() {}

    // TODO: Can we guarantee the same heap?
    virtual ~AxAValueObj() {}
    
    virtual void Render(GenericDevice& dev) {}

    // Compute and return cache for a value using the specified
    // device.  The 'cacheKey' parameter is a pointer to an AxAValue.
    // On input, it points to a value that can be used as the 'cache
    // key' for the value that can be reused.  On exit, it gets filled
    // in with a new cache key for use in subsequent calls.
    virtual AxAValue _Cache(CacheParam &param);

    // Client's entry point
    static AxAValue Cache(AxAValue obj, CacheParam &param);
    
    virtual void DestroyCache() { }

    virtual BOOL IsLazy() { return FALSE; }

    virtual void DoKids(GCFuncObj) {}

    // sound would return a special snapshot sound that won't render  
    virtual AxAValueObj *Snapshot() { return this; }

    virtual DXMTypeInfo GetTypeInfo() = 0;

    virtual VALTYPEID GetValTypeId() { return UNKNOWN_VTYPEID; }

    virtual AxAValue RewriteOptimization(RewriteOptimizationParam &param);

    virtual AxAValue ExtendedAttrib(char *attrib, VARIANT& val) {
        return this;
    }
};

class DynamicHeapPusher
{
  public:
    DynamicHeapPusher (DynamicHeap & heap)
    { PushDynamicHeap (heap) ; }
    ~DynamicHeapPusher ()
    { PopDynamicHeap () ; }
} ;

// This takes a heap and when deleted ensures it is freed.
// Putting this on the stack will handle exceptions well.
class DynamicHeapAllocator
{
  public:
    DynamicHeapAllocator (DynamicHeap & heap)
    : _heap(heap) {}
    ~DynamicHeapAllocator ()
    { DestroyTransientHeap (_heap) ; }

    DynamicHeap & GetHeap () { return _heap ; }
  protected:
    DynamicHeap & _heap ;
} ;

// Utility functions
#if _DEBUGMEM
#define StoreAllocate(heap,size) StoreAllocateFn(heap,size, __FILE__, __LINE__)
extern void *StoreAllocateFn(DynamicHeap& heap, size_t size, char * szFileName, int nLine);
#else
#define StoreAllocate(heap,size) StoreAllocateFn(heap,size)
extern void *StoreAllocateFn(DynamicHeap& heap, size_t size);
#endif  // _DEBUGMEM

extern void StoreDeallocate(DynamicHeap& heap, void *ptr);

#endif /* _STOREOBJ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\stream.h ===
#ifndef _STREAM_H_
#define _STREAM_H_

// TODO: remove the whole file

#ifdef DELETEME
#include "privinc/soundi.h"

class DSstreamingBufferElement;

class SinSynth : public LeafDirectSound {
  public:
    SinSynth(double newFreq=1.0);

    virtual SoundInstance *CreateSoundInstance(TimeXform tt);

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "SinSynth";
    }
#endif

  protected:
    double _sinFrequency;
};
#endif /* DELETEME */

#ifdef DONTDELETEMEI_HAVE_SYNC_CODE_EMBEDDED_IN_ME
class StreamPCMfile : public LeafDirectSound {
  public:
    StreamPCMfile(char *fileName);
    ~StreamPCMfile();

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "StreamPCMfile(";
    }
#endif /* _USE_PRINT */
    virtual void RenderNewBuffer(BufferElement *bufferElement,
                    MetaSoundDevice *metaDev);
    virtual void RenderAttributes(
                    MetaSoundDevice *metaDev, BufferElement *bufferElement);
    virtual void RenderStartAtLocation(MetaSoundDevice *metaDev,
                    BufferElement *bufferElement, double phase, Bool looping);
    virtual void RenderStop(MetaSoundDevice *metaDev,
                    BufferElement *bufferElement);
    virtual void RenderSamples(MetaSoundDevice *, BufferElement *);
    virtual void RenderSetMute(MetaSoundDevice *metaDev,
                    BufferElement *bufferElement);
    virtual Bool RenderCheckComplete(MetaSoundDevice *metaDev,
                    BufferElement *bufferElement);
    virtual void RenderCleanupBuffer(MetaSoundDevice *metaDev,
                    BufferElement *bufferElement);
    virtual bool StreamPCMfile::RenderPosition(MetaSoundDevice *metaDev,
                    BufferElement *bufferElement, double *mediaTime);
    virtual double GetLength() { 
        if(_soundFile)
            return(_soundFile->GetLength()); // pass the buck
        else
            return(-1.0); } // err

  protected:
    char    *_fileName;
    SndFile *_soundFile;
    int      _sampleRate;
    int      _numChannels;
    int      _bytesPerSample;

};
#endif

#ifdef DELETEME
class QuartzStreamPCM : public LeafDirectSound {
  public:
    QuartzStreamPCM(char *fileName);
    ~QuartzStreamPCM();

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "QuartzStreamPCM(";
    }
#endif

    virtual void RenderNewBuffer();
    virtual void RenderAttributes(BufferElement *bufferElement);
    virtual void RenderStartAtLocation(BufferElement *bufferElement, 
        double phase, Bool looping);
    virtual double GetLength();
    virtual void RenderStop(BufferElement *bufferElement);
    virtual void RenderSamples(MetaSoundDevice *, BufferElement *);
    virtual void RenderSetMute(BufferElement *bufferElement);
    virtual Bool RenderCheckComplete(BufferElement *bufferElement);
    virtual void RenderCleanupBuffer(BufferElement *bufferElement);

  protected:
    char    *_fileName;
    int      _sampleRate;
    int      _numChannels;
    int      _bytesPerSample;

};
#endif /* DELETEME */

#endif /* _STREAM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\textctx.h ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Context for gather text state during rendering

*******************************************************************************/


#ifndef _TEXTCTX_H
#define _TEXTCTX_H

#include "headers.h"
#include "appelles/common.h"
#include "appelles/color.h"
#include "appelles/text.h"
#include "privinc/imgdev.h"
#include "privinc/server.h"
#include "appelles/bbox2.h"
#include "texti.h"

class DirectDrawImageDevice;

class TextCtx {
  public:

    enum ForWhat {
        renderForReal,
        renderForColor,
        renderForBox,
        renderForPath
    };

    TextCtx(DirectDrawImageDevice *dev=NULL,
            Image *textImg=NULL) :
      _dev(dev),
      _textImg(textImg)
    {
        // Just set up the defaults...
        _col = white;
        _font = ff_serifProportional;

        _bold = FALSE;
        _italic = FALSE;
        _strikethrough = FALSE;
        _underline = FALSE;
        
        _fixedText = false;
        
        _weight = (double)(FW_NORMAL) / 1000.0;
        _antiAlias = 0.0;
        _fontSize = DEFAULT_TEXT_POINT_SIZE;
        _defaultColor = _col;
        _defaultFont = _font;

        _fontSet = false;
        _colorSet = false;

        _stashedBbox = NullBbox2;
        _stashedColor = NULL;

        _forWhat = renderForReal;

        _dc = NULL;
        _xform = NULL;
        _familyName = NULL;

        _characterTransform = NULL;
    }

    ~TextCtx() {}
    
    void  BeginRendering(ForWhat forWhat = renderForReal,
                         HDC dc=NULL,
                         Transform2 *xform=NULL) 
    { 
        _forWhat = forWhat; 
        _dc = dc;
        _xform = xform;
        Assert(_characterTransform == NULL);
    }
    void RenderString(WideString str);
    void  EndRendering() { }

    inline const Bbox2& GetStashedBbox() { 
        return _stashedBbox;
    }

    Color *GetStashedColor() {
        Assert(_stashedColor && "stashedBbox not derived in textctx!"); 
        return _stashedColor;
    }

    Color *GetColor() { return _col; }
    void    SetColor(Color *col) {
        if (!_colorSet) {
            _col = col;
            _colorSet = TRUE;
        }
    }
    void    ResetColor() { _col = _defaultColor; }


    FontFamilyEnum  GetFont() { return _font; }
    void    SetFont(FontFamilyEnum font) {
        if (!_fontSet) {
            _font = font;
            _fontSet = TRUE;
        }
    }

    WideString GetFontFamily() { return _familyName; }
    void SetFontFamily(WideString familyName) { _familyName = familyName; }
    
    void    ResetFont() {
        _font = _defaultFont;
        _familyName = NULL;
    }

    Bool    GetBold() { return _bold; }
    void    SetBold(Bool b) { _bold = b; }

    Bool    GetItalic() { return _italic; }
    void    SetItalic(Bool i) { _italic = i; }

    Bool    GetUnderline() { return _underline; }
    void    SetUnderline(Bool b) { _underline = b; }

    Bool    GetStrikethrough() { return _strikethrough; }
    void    SetStrikethrough(Bool b) { _strikethrough = b; }

    double  GetWeight() { return _weight; }
    void    SetWeight(double weight) { _weight = weight; }

    Real    GetAntiAlias() { return _antiAlias; }
    void    SetAntiAlias(Real aa) { _antiAlias = aa; }
    
    int     GetFontSize() { return _fontSize; }
    void    SetFontSize(int size) { _fontSize = size; }
    
    bool    GetFixedText() { return _fixedText; }
    void    SetFixedText(bool b) { _fixedText = b; }

    void    SetTextImageTopRight(Point2Value *topRight) { _topRight = topRight; }
    Point2Value *GetTextImageTopRight() { return _topRight;  }

    void    SetCharacterTransform(Transform2 *xf) { _characterTransform = xf;}
    Transform2 *GetCharacterTransform() { return _characterTransform; }
    
  protected:

    // purpose of ctx accumulation
    ForWhat _forWhat;

    // Traversal attributes.
    Color      *_col;
    Color      *_defaultColor;
    FontFamilyEnum  _font, _defaultFont;
    Bool        _bold;
    Bool        _underline;
    Bool        _strikethrough;
    Bool        _italic;
    bool        _fixedText;
    Real        _weight;
    Real        _antiAlias;
    int         _fontSize;

    WideString _familyName;

    // Top right corner of the un-transformed text
    Point2Value     *_topRight;

    // Per character transform.
    Transform2 *_characterTransform;
    
    // owning text
    //Text       *_text;
    Image    *_textImg;

    // Simple on/off bits to specify whether these attributes have
    // been set.
    bool        _fontSet;
    bool        _colorSet;

    // What rendering mode
    Bool        _deriveBbox;

    // Stashed info for non real rendering
    Bbox2      _stashedBbox;
    Color      *_stashedColor;

    // info for path accumulation
    HDC          _dc;
    Transform2  *_xform;

    // Image device we're created with
    DirectDrawImageDevice *_dev;
};

#endif /* _TEXTCTX_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\surfacemanager.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _SURFACEMANAGER_H
#define _SURFACEMANAGER_H

#include <privinc/ddsurf.h>

class DirectDrawViewport;
class DirectDrawImageDevice;
struct DDSurface;
class SurfaceCollection;
class SurfacePool;
class SurfaceMap;
class SurfaceManager;



// TODO: should either rename these guys to something more obvious (to
// easily demonstrate that they're global enums, OR put them in the
// DDSurface class.
    enum clear_enum { dontClear=0, doClear=1 };
    enum scratch_enum { notScratch=0, scratch=1 } ;
    enum vidmem_enum { notVidmem=0, vidmem=1 } ;
    enum except_enum { noExcept=0, except=1 } ;
    enum texture_enum { notTexture=0, isTexture=1 } ;

class SurfaceManager {

  public:
    
    SurfaceManager(DirectDrawViewport &ownerVp);
    
    ~SurfaceManager();

    SurfacePool *GetSurfacePool(DDPIXELFORMAT *pf);
    void AddSurfacePool(SurfacePool *sp);
    void RemoveSurfacePool(SurfacePool *sp);
    SurfaceMap *GetSurfaceMap(DDPIXELFORMAT *pf);
    void AddSurfaceMap(SurfaceMap *sm);
    void RemoveSurfaceMap(SurfaceMap *sm);

  private:

    typedef list<SurfaceCollection *> collection_t;
    
    void *Find(collection_t &sc, DDPIXELFORMAT *pf);
    bool Find(collection_t &sc, void *ptr, collection_t::iterator &i);
    void DeleteAll(collection_t &sc);

    collection_t  _pools;
    collection_t  _maps;

    bool          _doingDestruction;
    DirectDrawViewport &_owningViewport;
};


class SurfaceCollection {

  public:

    // need a copy of the pixel format... can you think
    // of a better way to pass it without using a ref or pointer ?
    // (neeed to make sure it's not NULL!)
    SurfaceCollection(SurfaceManager &mgr, DDPIXELFORMAT pf);

    virtual ~SurfaceCollection();

    bool IsSamePixelFormat(DDPIXELFORMAT *pf);

    inline DWORD GetDepth()     { return _pixelFormat.dwRGBBitCount; }
    inline DWORD GetRedMask()   { return _pixelFormat.dwRBitMask; }
    inline DWORD GetGreenMask() { return _pixelFormat.dwGBitMask; }
    inline DWORD GetBlueMask()  { return _pixelFormat.dwBBitMask; }

    inline SurfaceManager &GetSurfaceManager() { return _manager; }
    inline DDPIXELFORMAT &GetPixelFormat() { return _pixelFormat; }

  protected:
    virtual bool IsEmpty() = 0;

    #if _DEBUG
    void _debugonly_doAsserts( DDSurface *s ) {
        return;
        // this is good code, but too conservative.  catches good
        // stuff though, so keep around for later.. 
        //if( !(s->_debugonly_GetPixelFormat().dwFlags & DDPF_ZBUFFER) ) {
        //Assert(IsSamePixelFormat( &(s->_debugonly_GetPixelFormat() ) ));
        //}
    }
    #endif

  private:
    SurfaceManager &_manager;
    DDPIXELFORMAT _pixelFormat;

};

class SurfacePool : public SurfaceCollection {

    friend class CompositingStack;  // wish we could get per class scoping!

    #if _DEBUG
    friend class SurfaceTracker;
    #endif
    
  public:

    class ATL_NO_VTABLE DeletionNotifier {
      public:
        virtual void Advise(SurfacePool *pool) = 0;
    };

    SurfacePool(SurfaceManager &mgr, DDPIXELFORMAT &pf);

    virtual ~SurfacePool();

    // lends a copy of my reference. client needs to
    // make her own copy if she wants to keep a reference
    DDSurface *GetSizeCompatibleDDSurf(
        DDSurface *preferredSurf,       // Look for this surf first
        LONG width, LONG height,        // Surface Dimensions
        vidmem_enum vid,                // System or Video Memory
        LPDIRECTDRAWSURFACE surface);    // Specific Surface, or NULL for any

    // creates a reference for the client to keep
   void FindAndReleaseSizeCompatibleDDSurf(
        DDSurface *preferredSurf,       // Look for this surf first.
        LONG width, LONG height,        // Surface Dimensions
        vidmem_enum vid,                // System or Video Memory
        LPDIRECTDRAWSURFACE surface,    // Specific Surface, or NULL for any
        DDSurface **outSurf);
    
    void PopSurface(DDSurface **outSurf);
    void ReleaseAndEmpty();
    void ReleaseAndEmpty(int numSurfaces);
    void CopyAndEmpty(SurfacePool *srcPool);
    
    inline void AddSurface(DDSurface *ddsurf) {

        DebugCode( _debugonly_doAsserts( ddsurf ) );
        
        ADDREF_DDSURF(ddsurf, "SurfacePool::AddSurface", this);
        _pool.push_back(ddsurf);
    }

    void Erase(DDSurface *ddsurf);

    void RegisterDeletionNotifier(DeletionNotifier *delNotifier);
    void UnregisterDeletionNotifier(DeletionNotifier *delNotifier);

    //
    // iterator style methods
    //
    inline void Begin() { _i = _pool.begin(); }
    inline void Next() { _i++; }
    inline bool IsEnd() { return (_i == _pool.end()) ; }
    inline DDSurface *GetCurrentSurf() { return (*_i); }

    inline int  Size() { return _pool.size(); }

    #if _DEBUG
    void Report() {
      TraceTag((tagError, "SurfacePool(%x)  size: %d\n", this, Size()));
    }
    #endif
    
  protected:

    inline bool IsEmpty() { return _pool.empty(); }
    inline DDSurface  *Back() {
        Assert( (Size() > 0) && "SurfacePool::Back() size<=0!!");
        return _pool.back();
    }
    inline void PushBack(DDSurface *s) {
        DebugCode( _debugonly_doAsserts(s) );
        _pool.push_back(s);
    }
    inline void PopBack() {
        Assert( (Size() > 0) && "SurfacePool::PopBack() size<=0!!");
        _pool.pop_back();
    }

    bool Find(DDSurface *ddsurf);

    typedef list<DDSurface *> surfDeque_t;

    surfDeque_t::iterator _i;
    surfDeque_t     _pool;

    typedef set<DeletionNotifier *> deletionNotifiers_t;
    deletionNotifiers_t _deletionNotifiers;
    CritSect            _critSect;
};


class SurfaceMap : public SurfaceCollection {
    
  public:

    SurfaceMap(SurfaceManager &mgr,
               DDPIXELFORMAT &pf,
               texture_enum isTx=notTexture);
    virtual ~SurfaceMap();
    
    void DeleteImagesFromMap(bool skipmovies = true);

    DDSurface *LookupSurfaceFromImage(Image *image);

    void StashSurfaceUsingImage(Image *image, DDSurface *surf);

    void DeleteMapEntry(Image *image);

    #if _DEBUG
    void Report() {
      TraceTag((tagError, "map size: %d\n", _map.size()));
      //TraceTag((tagError, "surface collection size: %d\n", Size()));
    }
    #endif

  protected:

    bool IsEmpty() { return _map.empty(); }

  private:

    void ReleaseCurrentEntry();

    texture_enum    _isTexture;
    
    typedef map<Image *,
                DDSurface *,
                less<Image *> > imageMap_t;

    imageMap_t::iterator _i;
    imageMap_t  _map;
};


class CompositingStack : public SurfacePool {

  public:

    CompositingStack(DirectDrawViewport &vp, SurfacePool &sp);
    ~CompositingStack();

    void GetSurfaceFromFreePool(
        DDSurface **outSurf,
        clear_enum   clr,
        INT32 minW=-1, INT32 minH=-1,
        scratch_enum scr = notScratch,
        vidmem_enum  vid = notVidmem, 
        except_enum  exc = except);

    void PushCompositingSurface(
        clear_enum   clr,
        scratch_enum scr = notScratch,
        vidmem_enum  vid = notVidmem, 
        except_enum  exc = except);
        
    inline DDSurface *TargetDDSurface() {
        Assert( (Size() > 0) && "TargetDDSurface(): No surface available on CompositingStack!");
        return Back();  // won't get inlined, no code bloat
    }

    inline void PushTargetSurface(DDSurface *surface) {
        DebugCode( _debugonly_doAsserts( surface ) );
        ADDREF_DDSURF( surface, "CompositingStack::PushTargetSurface", this );
        PushBack(surface);
    }
    
    void PopTargetSurface();

    inline int TargetSurfaceCount() {
        return Size();
    }

    inline void ReturnSurfaceToFreePool(DDSurface *ddsurf) {
        _freeSurfacePool.AddSurface(ddsurf);
    }
    DDSurface *ScratchDDSurface(
        clear_enum cl = dontClear,
        INT32 minW=-1, INT32 minH=-1);  
    
    inline void ScratchDDSurface(
        DDSurface **outSurf,
        clear_enum cl = dontClear,
        INT32 minW=-1, INT32 minH=-1)
    {
        *outSurf = ScratchDDSurface(cl, minW, minH);
        ADDREF_DDSURF(*outSurf, "ScratchDDSurface (get ref version)", this);
    }
    inline DDSurface *GetScratchDDSurfacePtr() {
        return _scratchDDSurface;
    }
    inline void SetScratchDDSurface(DDSurface *surface) {
        _scratchDDSurface = surface;
    }

    void ReplaceAndReturnScratchSurface(DDSurface *surface);

    inline void ReleaseScratch() {
        _scratchDDSurface.Release();
    }
        
    #if _DEBUG
    void Report() {
      TraceTag((tagError, "Stack(%x)  size: %d\n", this, Size()));
      TraceTag((tagError, "Stack(%x)  pool: "));
      _freeSurfacePool.Report();
    }
    #endif

  private:

    DirectDrawViewport &_viewport;
    SurfacePool &_freeSurfacePool;
    DDSurfPtr<DDSurface> _scratchDDSurface;
};




//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  Surface Tracker:  keeps track of all allocated surfaces on a per viewport
//  basis for debugging.
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#if _DEBUG
class SurfaceTracker {
  public:
    SurfaceTracker() {}

    ~SurfaceTracker() {
        Report();
    }
    
    void NewSurface(DDSurface *s)
    {
        Assert( !Find(s));
        _pool.push_back(s);
    }
    
    void DeleteSurface(DDSurface *s)
    {
        if(Find(s)) {
            _pool.erase(_i);
        } else {
            TraceTag((tagError, "SurfaceTracker: possible multiple delete.  <false alarm if dxtransforms in sample>"));
        }
    }

    void Report() {
        TraceTag((tagDDSurfaceLeak, "-------- begin: Leaked Surfaces R E P O R T --------"));

        for(_i = _pool.begin(); _i != _pool.end(); _i++) {
            (*_i)->Report();
        }

        TraceTag((tagDDSurfaceLeak, "-------- end: SurfaceTracker R E P O R T --------"));
    }

    bool Find(DDSurface *ddsurf)
    {
        for(_i = _pool.begin(); _i != _pool.end(); _i++) {
            if( (*_i) == ddsurf ) {
                return true;
            }
        }
        return false;
    }

    // Use a list, deque has a bug!
    typedef list<DDSurface *> surfDeque_t;

    surfDeque_t::iterator _i;
    surfDeque_t     _pool;
};
#endif

#endif /* _SURFACEMANAGER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\textimg.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _TEXTIMG_H
#define _TEXTIMG_H

#include "privinc/storeobj.h"
#include "appelles/text.h"
#include "appelles/image.h"
#include "privinc/probe.h"
#include "privinc/texti.h"
#include "privinc/textctx.h"
#include "privinc/bbox2i.h"

class TextImage : public Image {
  public:
    TextImage(Text *t) : _text(t), _bbox(NullBbox2) {}

    void Render(GenericDevice& dev);

    const Bbox2 BoundingBox() {
        return DeriveBbox();
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        Transform2 *xf = bbctx.GetTransform();
        return TransformBbox2(xf, DeriveBbox());
    }
#endif  // BOUNDINGBOX_TIGHTER

    const Bbox2 OperateOn(const Bbox2 &box) { return box; }

    Bool  DetectHit(PointIntersectCtx& ctx) {
        Point2Value *lcPt = ctx.GetLcPoint();

        if (!lcPt) return FALSE; // singular transform
        
        return BoundingBox().Contains(Demote(*lcPt));
    }

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "RenderTextToImage(...)";
    }
#endif

    Bool GetColor(Color **color) {
        TextCtx ctx;
        
        ctx.BeginRendering(TextCtx::renderForColor);
        _text->RenderToTextCtx(ctx);
        ctx.EndRendering();

        *color = ctx.GetStashedColor();
        return TRUE;
    }

    Text *GetText() { return _text; }
    
    // Turn off text caching because of clear quality issues by making
    // Savings return 0.  Re-enable by making it return 2.
    int Savings(CacheParam& p) { return 0; }

    virtual void DoKids(GCFuncObj proc);

  protected:
    const Bbox2 DeriveBbox();
    Text *_text;
    Bbox2 _bbox;
};


#endif /* _TEXTIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\transimg.h ===
#ifndef _TRANSIMG_H
#define _TRANSIMG_H


/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    Transformed Image class header

-------------------------------------*/

#include "privinc/imagei.h"
#include "privinc/xform2i.h"
#include "privinc/bbox2i.h"

class Transform2Image : public AttributedImage {
  public:

    Transform2Image(Transform2 *xf, Image *img);

    void Render(GenericDevice& dev);

    const Bbox2 BoundingBox(void);

    Real DisjointBBoxAreas(DisjointCalcParam &param);

    void _CollectDirtyRects(DirtyRectCtx &ctx);
    
#if BOUNDINGBOX_TIGHTER
    Bbox2 *BoundingBoxTighter(Bbox2Ctx &bbctx) {
        Bbox2Ctx bbctxAccum(bbctx, _xform);
        return _image->BoundingBoxTighter(bbctxAccum);
    }
#endif  // BOUNDINGBOX_TIGHTER

#if _USE_PRINT
    // Print a representation to a stream.
    ostream& Print(ostream& os) {
        return os << "TransformImage("
                  << _xform << "," << _image << ")";
    }
#endif

    const Bbox2 OperateOn(const Bbox2 &box);

    Bool  DetectHit(PointIntersectCtx& ctx);

    DiscreteImage *IsPurelyTransformedDiscrete(Transform2 **theXform);

    Transform2 *GetTransform() { return _xform; }

    virtual VALTYPEID GetValTypeId() { return TRANSFORM2IMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == Transform2Image::GetValTypeId() ||
                AttributedImage::CheckImageTypeId(type));
    }

    virtual void DoKids(GCFuncObj proc) { 
        AttributedImage::DoKids(proc);
        (*proc)(_xform); 
    }

  protected:
    Transform2 *_xform;
};


#endif /* _TRANSIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\texti.h ===
#ifndef _TEXTI_H
#define _TEXTI_H


/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    texti.h

Abstract:

     Implements the Text class

--*/

#include "appelles/common.h"

enum textRenderStyle {
    textRenderStyle_invalid,
    textRenderStyle_filled,
    textRenderStyle_outline,
    textRenderStyle_filledOutline
};
    

#define DEFAULT_TEXT_POINT_SIZE 12.0

////////////
class TextCtx;

class ATL_NO_VTABLE Text : public AxAValueObj {
  public:
    virtual void RenderToTextCtx(TextCtx& ctx) = 0;
    virtual int GetCharacterCount() = 0;
    virtual WideString GetStringPtr() = 0;

    virtual DXMTypeInfo GetTypeInfo() { return TextType; }
};

////////////

// Need this in multiple places...

class FontFamily : public AxAValueObj {
  public:
    FontFamily(FontFamilyEnum f) : _ff(f), _familyName(NULL) {}

    FontFamily(AxAString * familyName)
    : _ff(ff_serifProportional), _familyName(familyName) {}
    
    FontFamilyEnum GetFontFamily() { return _ff; }

    AxAString * GetFontFamilyName() { return _familyName; }
    
    virtual DXMTypeInfo GetTypeInfo() { return FontFamilyType; }

    virtual void DoKids(GCFuncObj proc)
    { if (_familyName) (*proc)(_familyName); }
  private:
    FontFamilyEnum _ff;
    AxAString * _familyName;
};

#endif /* _TEXTI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\urlbuf.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _URLBUF_H
#define _URLBUF_H

#include <urlmon.h>
#include <wininet.h>
#include "dastream.h"

extern HINSTANCE hInst;

class CDXMBindStatusCallback : public IBindStatusCallback,
                               public IAuthenticate
{
  public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid,void ** ppv);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IBindStatusCallback methods
    STDMETHOD(OnStartBinding)(DWORD grfBSCOption, IBinding* pbinding);
    STDMETHOD(GetPriority)(LONG* pnPriority);
    STDMETHOD(OnLowResource)(DWORD dwReserved);
    STDMETHOD(OnProgress)(
                ULONG ulProgress,
                ULONG ulProgressMax,
                ULONG ulStatusCode,
                LPCWSTR pwzStatusText);
    STDMETHOD(OnStopBinding)(HRESULT hrResult, LPCWSTR szError);
    STDMETHOD(GetBindInfo)(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHOD(OnDataAvailable)(
                DWORD grfBSCF,
                DWORD dwSize,
                FORMATETC *pfmtetc,
                STGMEDIUM* pstgmed);
    STDMETHOD(OnObjectAvailable)(REFIID riid, IUnknown* punk);

    // IAuthenticate methods
    STDMETHOD(Authenticate)(
                HWND * phwnd,
                LPWSTR * pwszUser,
                LPWSTR * pwszPassword);

    // Constructors/destructors
    CDXMBindStatusCallback(void);
    virtual ~CDXMBindStatusCallback(void);

  private:
    IBinding*       m_pbinding;
    DWORD           m_cRef;
};

class CBSCWrapper
{
  public:
    CBSCWrapper(void);
    ~CBSCWrapper(void);

    CDXMBindStatusCallback *   _pbsc;
};

class daurlstream : public daolestream
{
  public:
    daurlstream(const char * name);
  protected:
    CBSCWrapper bsc;
};

class INetTempFile
{
  public:
    // This raises an exception on failure
    INetTempFile (LPCSTR szURL) ;
    INetTempFile () ;
    ~INetTempFile () ;

    // These do not raise exceptions

    BOOL Open (LPCSTR szURL) ;
    void Close () ;

    LPSTR GetTempFileName () { return _tmpfilename ; }
    LPSTR GetURL () { return _url ; }

    BOOL IsOpen() { return _url != NULL ; }
  protected:
    LPSTR _url ;
    LPSTR _tmpfilename ;
} ;


class URLRelToAbsConverter
{
  public:
    URLRelToAbsConverter(LPSTR baseURL, LPSTR relURL);

    LPSTR GetAbsoluteURL () { return _url ; }
  protected:
    char _url[INTERNET_MAX_URL_LENGTH + 1] ;
} ;

class URLCanonicalize
{
  public:
    URLCanonicalize(LPSTR path);

    LPSTR GetURL () { return _url ; }
  protected:
    char _url[INTERNET_MAX_URL_LENGTH + 1] ;
} ;

#endif /* _URLBUF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\urlimage.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _URLIMAGE_H
#define _URLIMAGE_H

#include <ddraw.h>
#include <dxhtml.h>

#include <privinc/comutil.h>
#include <privinc/discimg.h>

#include "privinc/probe.h"

class UrlImage : public DiscreteImage {

  public:

    UrlImage(IDirectXHTML *pDxhtml, AxAString *url);
    virtual ~UrlImage(){ CleanUp(); }

    void CleanUp() {
        _pDXHTML.Release();
        _pDXHTMLCallback.Release();
    }
    
    bool SetupDxHtml();
    IDirectXHTML  *GetDXHTML() { return _pDXHTML; }

    void OnWindowMessage(UINT msg,
                         WPARAM wParam,
                         LPARAM lParam);    
    void SetSampleTime(double t) {
        _lastTime = _curTime;
        _curTime = t;
        _isHit = false;
    }
        
    void OnCompletedDownload(SIZEL *docSize)
    {
        _downdLoadComplete = true;
        #if 0
        _width = docSize->cx;
        _height = docSize->cy;
        ::SetRect(&_rect, 0,0, _width, _height);

        _membersReady = TRUE;
        #endif
    }

    void Render(GenericDevice& dev);
    
    const Bbox2 BoundingBox() {

        /*
        if( _downdLoadComplete && !_bboxReady) {
            SetBbox( GetPixelWidth(),
                     GetPixelHeight(),
                     GetResolution() );
            _bboxReady = TRUE;
        }*/
        
        return _bbox;
    }

    void  SetBbox(int w, int h, Real res)
    {
        _bbox.min.Set(Real( - w ) * 0.5 / res,
                      Real( - h ) * 0.5 / res);
        _bbox.max.Set(Real( w ) * 0.5 / res,
                      Real( h ) * 0.5 / res);
        _bboxReady = TRUE;
    }

    void SetMembers( int w, int h )
    {
        _width = w;  _height = h;
        ::SetRect(&_rect, 0,0, _width, _height);
        _membersReady = TRUE;
    }
    
    Bool DetectHit(PointIntersectCtx& ctx);

    void InitializeWithDevice(ImageDisplayDev *dev, Real res);
    
    void InitIntoDDSurface(DDSurface *ddSurf, ImageDisplayDev *dev);

    VALTYPEID GetValTypeId() { return URLIMAGE_VTYPEID; }
    bool CheckImageTypeId(VALTYPEID type) {
        return (type == UrlImage::GetValTypeId() ||
                DiscreteImage::CheckImageTypeId(type));
    }

    // Ricky:  is this correct ??
    void DoKids(GCFuncObj proc) { 
        DiscreteImage::DoKids(proc);
        (*proc)(_url); 
    }

           
#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "(UrlImage @ " << (void *)this << ")";
    }   
#endif

    
  private:

    DebugCode( DDSurface *_initialDDSurf );

    AxAString *_url;
    DAAptComPtr<IDirectXHTML, &IID_IDirectXHTML> _pDXHTML;
    DAComPtr<IDirectXHTMLCallback>               _pDXHTMLCallback;

    ULONG         _lastHitX;
    ULONG         _lastHitY;
    
    double        _lastTime;
    double        _curTime;

    bool          _isHit;
    bool          _downdLoadComplete;
};
    
//**********************************************************************
// File name: DXHTMLCB.h
//
// Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//**********************************************************************

//
// Interface
//
class CDirectXHTMLCallback : public IDirectXHTMLCallback
{
private:
    UrlImage        *_urlImage;
    ULONG           m_cRef;

public:
    //
    // Constructor and Destructor
    //
    CDirectXHTMLCallback(UrlImage *);
    ~CDirectXHTMLCallback();

    //
    // IUnknown Interfaces
    //
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);

    //
    // Initialization methods
    //
    STDMETHODIMP OnSetTitleText( LPCWSTR lpszText );
    STDMETHODIMP OnSetProgressText( LPCWSTR lpszText );
    STDMETHODIMP OnSetStatusText( LPCWSTR lpszText );
    STDMETHODIMP OnSetProgressMax( const DWORD dwMax );
    STDMETHODIMP OnSetProgressPos( const DWORD dwPos );
    STDMETHODIMP OnCompletedDownload( void );
    STDMETHODIMP OnInvalidate( const RECT *lprc, DWORD dwhRgn, VARIANT_BOOL fErase );
};


#endif /* _URLIMAGE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\tls.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Structures on thread-local storage

*******************************************************************************/


#ifndef _TLS_H
#define _TLS_H

#include "except.h"

class DynamicHeap;


class ThreadLocalStructure : public AxAThrowingAllocatorClass {
  public:

    ThreadLocalStructure() {
        _bitmapCaching = NoPreference;
        _geometryBitmapCaching = NoPreference;
    }
    
    stack<DynamicHeap*> _stackOfHeaps;

    BoolPref _bitmapCaching;
    BoolPref _geometryBitmapCaching;
};

LPVOID CreateNewStructureForThread(DWORD tlsIndex);
extern DWORD localStructureTlsIndex;

// Make this function inlined, since it is called quite frequently.
// The elements of it that are called on process or thread creation
// only are not inlined.
inline ThreadLocalStructure *
GetThreadLocalStructure()
{
    // Grab what is stored in TLS at this index.
    LPVOID result = TlsGetValue(localStructureTlsIndex);

    // If null, then we haven't created the stack for this thread yet.
    // Do so.
    if (result == NULL) {
        Assert((GetLastError() == NO_ERROR) && "Error in TlsGetValue()");
        result = CreateNewStructureForThread(localStructureTlsIndex);
    }

    return (ThreadLocalStructure *)result;
}

#endif /* _TLS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\vec3i.h ===
#ifndef _VEC3I_H
#define _VEC3I_H

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 ) 

/*******************************************************************************
Copyright (c) 1995-96  Microsoft Corporation

    This header file contains the implementation of 3D geometric elements
    (points, vectors, rays, and planes), plus the operations on and between
    these elements.

*******************************************************************************/

#include "d3dtypes.h"
#include "appelles/vec2.h"
#include "privinc/storeobj.h"
#include "privinc/vecutil.h"


typedef enum _ClipCode {
    CLIPCODE_OUT = -1,
    CLIPCODE_STRADDLE = 0,
    CLIPCODE_IN = 1
} ClipCode;


#if 0
--------
    After reading Meyer's "More Effective C++", there are several things we
    should do with our math object classes when appopropriate.

    First of all, we should implement operator+=, operator-=, operator*= and so
    forth where appropriate (they should take const objects).

    We should implement operator+ (for example) like this:

        inline const Vector3 operator+ (const Vector3 A, const Vector3 B)
        {   return Vector3(A) += B;
        }

    This will enable the compiler to do the return value optimization (for
    unnamed temporary objects).

    This should also apply to mixed operations (e.g. Point3 + Vector3).
--------
#endif

class Vector3Value : public AxAValueObj
{
  public:

    Real x, y, z;

#if _USE_PRINT
    ostream& Print(ostream& os) {
      return os << "Vector3Value(" << x << "," << y << "," << z << ")";
    }
#endif

    Vector3Value (void) {}
    Vector3Value (Real r0, Real r1, Real r2) : x(r0), y(r1), z(r2) {}
    Vector3Value (ApuVector3 &V) : x(V.xyz[0]), y(V.xyz[1]), z(V.xyz[2]) {}
    Vector3Value (D3DVECTOR &V) : x(V.x), y(V.y), z(V.z) {}

    void Set (Real Vx, Real Vy, Real Vz) { x=Vx; y=Vy; z=Vz; }

    bool operator== (Vector3Value &other);

    inline bool operator!= (Vector3Value &other)  { return !(*this==other); }

    Vector3Value& operator*= (Real);

    inline Vector3Value& operator/= (Real s)  { return *this *= (1/s); }

    Real LengthSquared();

    inline Real Length()  { return sqrt (LengthSquared()); }

    Vector3Value& Normalize();

    void Transform (Transform3 *xf);

    inline Vector3Value& operator*= (Transform3 &xf)
    {   Transform(&xf);
        return *this;
    }

    virtual DXMTypeInfo GetTypeInfo() { return Vector3ValueType; }
};


class Vector3WithCreationSource : public Vector3Value
{
  public:
    bool _createdInPixelMode;
};


    // Vector Operations

void    Cross        (Vector3Value &result, Vector3Value &A, Vector3Value &B);
Vector3Value Cross        (Vector3Value&, Vector3Value&);
Real    Dot          (Vector3Value&, Vector3Value&);
Real    AngleBetween (Vector3Value&, Vector3Value&);

Vector3Value operator+ (Vector3Value&, Vector3Value&);
Vector3Value operator- (Vector3Value&, Vector3Value&);
Vector3Value operator- (Vector3Value&);
Vector3Value operator* (Real, Vector3Value&);
Vector3Value operator* (Transform3&, Vector3Value&);

Vector3Value *XyzVector3RRR (Real x, Real y, Real z);
Vector3Value *SphericalVector3RRR (Real azimuth,Real elevation,Real radius);
Vector3Value *ScaleRealVector3R (Real scalar, Vector3Value *V);
Vector3Value *DivideVector3RealR (Vector3Value *V, Real scalar);

inline Vector3Value operator* (Vector3Value &V, Real s)  { return s * V; }
inline Vector3Value operator/ (Vector3Value &V, Real d)  { return (1/d) * V; }

class Plane3;

class Point3Value : public AxAValueObj
{
  public:

    Real x, y, z;

#if _USE_PRINT
    ostream& Print(ostream& os) {
      return os << "Point3Value(" << x << "," << y << "," << z << ")";
    }
#endif
    
    Point3Value (void) {}
    Point3Value (Real r0, Real r1, Real r2) : x(r0), y(r1), z(r2) {}
    Point3Value (D3DVECTOR &V) : x(V.x), y(V.y), z(V.z) {}

    void Set (Real Px, Real Py, Real Pz) { x=Px; y=Py; z=Pz; }

    bool operator== (Point3Value &other);     // Compare This Point With Another
    inline bool operator!= (Point3Value &other) { return !(*this==other); }

    Point3Value& operator+= (Vector3Value&);
    Point3Value& operator-= (Vector3Value&);

    void Transform (Transform3 *xf);    // Transforms This Point

    inline Point3Value& operator*= (Transform3 &xf)
    {   Transform(&xf);
        return *this;
    }

    ClipCode Clip(Plane3 &plane);

    virtual DXMTypeInfo GetTypeInfo() { return Point3ValueType; }
};

class Point3WithCreationSource : public Point3Value
{
  public:
    bool _createdInPixelMode;
};


    // Point Operators

Point3Value *XyzPoint3RRR (Real x, Real y, Real z);
Point3Value *SphericalPoint3RRR (Real azimuth,Real elevation,Real radius);
Real DistanceSquared (Point3Value&, Point3Value&);
Real RDistancePoint3Point3 (Point3Value *P, Point3Value *Q);

inline Real Distance (Point3Value &P, Point3Value &Q)
    { return sqrt (DistanceSquared (P,Q)); }


    // Point-Vector Operators

Vector3Value operator- (Point3Value&, Point3Value&);
Point3Value  operator+ (Point3Value&, Vector3Value&);
Point3Value  operator- (Point3Value&, Vector3Value&);
Point3Value  operator* (Transform3&, Point3Value&);

inline Point3Value operator+ (Vector3Value &V, Point3Value &P)  { return P + V; }

inline Vector3Value* AsVector (Point3Value  &P) { return NEW Vector3Value (P.x, P.y, P.z); }
inline Point3Value*  AsPoint  (Vector3Value &V) { return NEW Point3Value (V.x, V.y, V.z); }



class Ray3 : public AxAValueObj
{
  public:

#if _USE_PRINT
    ostream& Print(ostream& os) {
      return os << "Ray3(" << orig << "," << dir << ")";
    }
#endif
    
    Ray3 (Point3Value &origin, Vector3Value &direction)
        : orig(origin), dir(direction) {}

    // Query Functions

    Point3Value  &Origin (void)     { return orig; }
    Vector3Value &Direction (void)  { return dir; }

    void Transform (Transform3*);

    // Evaluate the ray given a real-valued parameter.

    Point3Value Evaluate (Real t);

    // TODO: Not a type in avrtypes.h??
    virtual DXMTypeInfo GetTypeInfo() { return AxATrivialType; }

  private:

    Point3Value  orig;    // Ray Origin
    Vector3Value dir;     // Ray Direction
};



// The Plane3 class describes a plane of normal N, plane constant d.
// The implicit equation for the plane is Ax + By + Cz + d = 0.

class Plane3 : public AxAValueObj
{
  public:

#if _USE_PRINT
    ostream& Print(ostream& os) {
      return os << "Plane3(" << N << "," << d << ")";
    }
#endif
    
    Vector3Value N;   // Plane Normal
    Real    d;   // Plane Constant

    Plane3 (void) : N(0,0,1), d(0) {}
    Plane3 (Real A, Real B, Real C, Real D) : N(A,B,C), d(D) {}
    Plane3 (Real P[4]) : N(P[0],P[1],P[2]), d(P[3]) {}
    Plane3 (Vector3Value &V, Real D) : N(V), d(D) {}

    Plane3 (Vector3Value &V, Point3Value &P) : N(V), d(-Dot(V,*AsVector(P))) {}

    Plane3& operator*= (Transform3*);

    Plane3& Normalize (void);

    Vector3Value Normal (void);    // Return Plane Normal Vector
    Point3Value  Point (void);     // Return Point on Plane
    virtual DXMTypeInfo GetTypeInfo() { return AxATrivialType; }
};

    // Plane Functions

        // This function returns the signed distance from the plane to the
        // given point.  If the sign is positive, then the point lies on the
        // same side of the plane as the plane normal.  If the distance is
        // zero, the point lies on the plane.

Real Distance (Plane3&, Point3Value&);

inline Plane3 operator* (Transform3 *T, Plane3 &plane)
{   return Plane3(plane) *= T;
}

        // Returns the ray parameter for the intersection between the ray and
        // the plane (infinity if the ray is parallel to the plane).

Real Intersect (Ray3 &ray, Plane3 &plane);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\util.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Miscellaneous utility functions header
*******************************************************************************/

#ifndef _UTIL_H
#define _UTIL_H

#include "privinc/mutex.h"

// Conversion
RawString CopyWideString(WideString bstr);
WideString CopyRawString(RawString bstr);

// ANSI Copy functions

inline char * CopyString(const char *str) {
    char *newstr = NEW char [str?(lstrlen(str) + 1):1] ;
    if (newstr) lstrcpyA (newstr,str?str:"") ;
    return newstr ;
}

inline char * CopyStringFromStore(char *str, DynamicHeap & heap) {
#if _DEBUGMEM
    int size = (str?(lstrlen(str)+1):1) * sizeof(char);
    char *newstr = (char *)heap.Allocate(size, __FILE__, __LINE__);
#else
    char *newstr =
        (char *) heap.Allocate ((str?(lstrlen(str)+1):1)*sizeof(char))  ;
#endif // _DEBUGMEM
    lstrcpyA (newstr,str?str:"") ;
    return newstr ;
}

inline char * CopyStringFromStore(char *str) {
    return CopyStringFromStore(str,GetHeapOnTopOfStack()) ;
}

inline void FreeStringFromStore(char *str, DynamicHeap & heap) {
    if (str) heap.Deallocate (str) ;
}

inline void FreeStringFromStore(char *str) {
    FreeStringFromStore(str,GetHeapOnTopOfStack()) ;
}


// Unicode copy functions

inline WCHAR * CopyString(const WCHAR *str) {
    WCHAR *newstr = NEW WCHAR [str?(lstrlenW(str) + 1):1] ;
    if (newstr) StrCpyW (newstr,str?str:L"") ;
    return newstr ;
}

inline WCHAR * CopyStringFromStore(WCHAR *str, DynamicHeap & heap) {
#if _DEBUGMEM
    int size = (str?(lstrlenW(str)+1):1) * sizeof(WCHAR);
    WCHAR *newstr = (WCHAR *)heap.Allocate(size, __FILE__, __LINE__);
#else
    WCHAR *newstr =
        (WCHAR *) heap.Allocate ((str?(lstrlenW(str)+1):1)*sizeof(WCHAR))  ;
#endif // _DEBUGMEM
    StrCpyW (newstr,str?str:L"") ;
    return newstr ;
}

inline WCHAR * CopyStringFromStore(WCHAR *str) {
    return CopyStringFromStore(str,GetHeapOnTopOfStack()) ;
}

inline void FreeStringFromStore(WCHAR *str, DynamicHeap & heap) {
    if (str) heap.Deallocate (str) ;
}

inline void FreeStringFromStore(WCHAR *str) {
    FreeStringFromStore(str,GetHeapOnTopOfStack()) ;
}


    /***  Assorted Utility Functions  ***/

inline bool IsOdd (LONG n)
{
    return (n & 1);
}

bool MMX_Able (void);     // Report support for MMX instructions.

    // Return the smallest power of two that is >= number.

int CeilingPowerOf2 (int number);

#define fsaturate(min,max,n) clamp(double(n),double(min),double(max))
#define  saturate(min,max,n) clamp(long(n),long(min),long(max))

bool isNear(double value, double test, double epsilon);

bool IntersectHorzRightRay(Point2Value *rayToRight, Point2Value *a, Point2Value *b);

double GetCurrTime (void);
int operator== (RECT&, RECT&);

    // These functions decrement or increment the mantissa of the floating
    // point number.  Note that this works only for IEEE floats.  Underflow
    // and overflow are properly handled by adjusting the exponent accordingly.

float MantissaDecrement (float n, int decrement);
float MantissaIncrement (float n, int increment);

    // Generic Linear Interpolator

template <class element>
    inline element Lerp (element A, element B, double t)
    {
        return A + (B-A)*t;
    }

    // Cyclic-Redundancy Code (CRC32) generator.  This function calculates a
    // new or running CRC on the given code block.  If called on a new block,
    // use the default CRC parameter value.  If iterating toward a final CRC,
    // supply the intermediate value on subsequent calls.

unsigned int crc32 (void *buffer, size_t length, unsigned int curr_crc = 0);


DWORD GetPerfTickCount();
extern DWORD perfFrequency;

#if PERFORMANCE_REPORTING

    class PerformanceTimer {
      public:
        PerformanceTimer();
        void Start();
        HRESULT Stop (HRESULT result=0);
        void Reset();
        double GetTime();
        DWORD Ticks();

      protected:
        DWORD     _totalTicks;
        DWORD     _localStart;
        DWORD     _threadStartedOn;
        CritSect  _criticalSection;

        bool _isStarted;
    };

    // Start timer on entrance to scope, stop upon leaving scope.
    class PerformanceTimerScope {
      public:
        PerformanceTimerScope(PerformanceTimer &timer) : _timer(timer) {
            _timer.Start();
        }

        ~PerformanceTimerScope() {
            _timer.Stop();
        }

      protected:
        PerformanceTimer &_timer;
    };

    class GlobalTimers
    {
      public:
        // Global timers

        // Load time timers
        PerformanceTimer audioLoadTimer;
        PerformanceTimer imageLoadTimer;
        PerformanceTimer geometryLoadTimer;
        PerformanceTimer downloadTimer;
        PerformanceTimer importblockingTimer;

        // DirectX Rendering timers
        PerformanceTimer ddrawTimer;
        PerformanceTimer d3dTimer;
        PerformanceTimer dsoundTimer;
        PerformanceTimer gdiTimer;
        PerformanceTimer alphaTimer;
        PerformanceTimer dxxformTimer;
        PerformanceTimer dx2dTimer;
        PerformanceTimer customTimer;
    };
 
    extern void PerfPrintLine(char *format=NULL, ...);

    #define PERFPRINTF(x) PerfPrintf x
    #define PERFPRINTLINE(x) PerfPrintLine x

    #define TIME_SUBSYS(timer,statement) \
    (   GetCurrentTimers().timer.Start(),\
        GetCurrentTimers().timer.Stop(statement)\
    )

    #define TIME_DDRAW(statement)  TIME_SUBSYS(ddrawTimer, statement)
    #define TIME_D3D(statement)    TIME_SUBSYS(d3dTimer,   statement)
    #define TIME_DSOUND(statement) TIME_SUBSYS(dsoundTimer,statement)
    #define TIME_DXXFORM(statement) TIME_SUBSYS(dxxformTimer,statement)
    #define TIME_DX2D(statement) TIME_SUBSYS(dx2dTimer,statement)
    #define TIME_CUSTOM(statement) TIME_SUBSYS(customTimer,statement)

    #define  TIME_GDI(statement) \
    do { \
        PerformanceTimerScope __ptc(GetCurrentTimers().gdiTimer); \
        statement;                     \
    } while(0)

    #define  TIME_ALPHA(statement) \
    do { \
        PerformanceTimerScope __ptc(GetCurrentTimers().alphaTimer); \
        statement;                     \
    } while(0)
    
#else

    #define PERFPRINTF(x)
    #define PERFPRINTLINE(x)

    #define  TIME_DDRAW(statement)  statement
    #define  TIME_D3D(statement)    statement
    #define  TIME_DSOUND(statement) statement
    #define  TIME_GDI(statement)    statement
    #define  TIME_ALPHA(statement)  statement
    #define  TIME_DXXFORM(statement) statement
    #define  TIME_DX2D(statement) statement
    #define  TIME_CUSTOM(statement) statement

#endif  // PERFORMANCE_REPORTING

inline double Tick2Sec(DWORD tick)
{ return ((double) tick) / (double) perfFrequency; }

extern void PerfPrintf(char *format, ...);

void CatchWin32Faults (BOOL b) ;

class CatchWin32FaultCleanup
{
  public:
    CatchWin32FaultCleanup () {
        CatchWin32Faults (TRUE) ;
    }
    ~CatchWin32FaultCleanup () {
        CatchWin32Faults (FALSE) ;
    }
} ;

// Pixel stuff
extern double pixelConst;
extern double meterConst;

inline double PixelToNum(double d) {
    Assert (pixelConst != 0.0);
    return d * pixelConst;
}

inline double PixelYToNum(double d) {
    Assert (pixelConst != 0.0);
    return -d * pixelConst;
}

inline double NumToPixel(double d) {
    Assert (meterConst != 0.0);
    return d * meterConst;
}

inline double NumToPixelY(double d) {
    Assert (meterConst != 0.0);
    return -d * meterConst;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\xform2i.h ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation class for 2D transforms

*******************************************************************************/


#ifndef _XFORM2I_H
#define _XFORM2I_H

#include "appelles/xform2.h"
#include "appelles/common.h"
#include "privinc/storeobj.h"
#include "privinc/vec2i.h"
#include <dxtrans.h>

// Currently, this is just a dummy version of what will eventuall go
// here. 
class ATL_NO_VTABLE Transform2 : public AxAValueObj {
  public:
    enum Xform2Type {
        Identity,
        Translation,
        Scale,
        Shear,
        Rotation,
        TwoByTwo,
        Full
        };

#if _USE_PRINT
    virtual ostream& Print(ostream& os) = 0;
#endif
    virtual Xform2Type Type() = 0;
    
    // Fill m with all the matrix entries
    virtual void GetMatrix(Real m[6]) = 0;

    // Return a copy that's been allocated on the heap that's current
    // when this is called.
    virtual Transform2 *Copy() = 0;

    virtual DXMTypeInfo GetTypeInfo() { return Transform2Type; }

    virtual bool SwitchToNumbers(Xform2Type typeOfNewNumbers,
                                 Real      *numbers);
};

Point2 TransformPoint2(Transform2 *a, const Point2& pt);
Point2Value *TransformPoint2Value(Transform2 *a, Point2Value *pt);
Vector2 TransformVector2(Transform2 *xf, const Vector2& v);
Vector2Value *TransformVector2Value(Transform2 *a, Vector2Value *v);

Transform2 *ScaleRR(Real x, Real y);
Transform2 *Rotate2Radians(Real angle);
Transform2 *TranslateRR(Real tx, Real ty);
Transform2 *TranslateRRWithMode(Real tx, Real ty, bool pixelMode);
Transform2 *RotateRealR(Real angle);
Transform2 *XShear2R (Real xAmt);
Transform2 *YShear2R (Real yAmt);

Transform2 *FullXform(Real a00, Real a01, Real a02,
                      Real a10, Real a11, Real a12);


void 
TransformDXPoint2ArrayToGDISpace(Transform2 *a,
                               DXFPOINT *srcPts, 
                               POINT *gdiPts,
                               int numPts,
                               int width,
                               int height,
                               Real resolution);

void 
TransformPoint2ArrayToGDISpace(Transform2 *a,
                               Point2 *srcPts, 
                               POINT *gdiPts,
                               int numPts,
                               int width,
                               int height,
                               Real resolution);


#endif /* _XFORM2I_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\vecutil.h ===
#ifndef _VECUTIL_H
#define _VECUTIL_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Points

--*/

#include <math.h>

#ifndef AP_RAD_TO_DEG
#define AP_RAD_TO_DEG(x) (x * 57.2957795130823)
#endif /* AP_RAD_TO_DEG */

#ifndef AP_DEG_TO_RAD
#define AP_DEG_TO_RAD(x) (x / 57.2957795130823)
#endif /* AP_DEG_TO_RAD */

struct ApuVector3
{
  Real xyz[3];

  Real X() const { return xyz[0]; }
  Real Y() const { return xyz[1]; }
  Real Z() const { return xyz[2]; }
  Real operator[] (int i) const { return xyz[i]; }
  Real& operator[] (int i) { return xyz[i]; }
  void SetX(Real newx) { xyz[0] = newx; }
  void SetY(Real newy) { xyz[1] = newy; }
  void SetZ(Real newz) { xyz[2] = newz; }
  void Set(Real newx, Real newy, Real newz)
    { xyz[0] = newx; xyz[1] = newy; xyz[2] = newz; }

  Real Length() const;
  Real LengthSquared() const;

  void Normalize();

  operator Real *() { return &xyz[0]; }
  operator const Real *() const { return &xyz[0]; }
  void operator+=(const ApuVector3& rhs);
  void operator-=(const ApuVector3& rhs);
  void operator*=(Real rhs);
  void operator/=(Real rhs);

  void Negate();
  void Zero();

};

extern ApuVector3 apuXAxis3;         // (1, 0, 0)
extern ApuVector3 apuYAxis3;         // (0, 1, 0)
extern ApuVector3 apuZAxis3;         // (0, 0, 1)
extern ApuVector3 apuZero3;          // (0, 0, 0)

struct ApuBbox3
{
  ApuVector3 min;
  ApuVector3 max;
  void augment(Real x, Real y, Real z);
  void center(ApuVector3& result) const;
};

/*
 * Negative volume bbox used for initialization
 */
extern ApuBbox3 apuNegativeBbox3;

/*
 * The volume [0,1] x [0,1] x [0,1]
 */
extern ApuBbox3 apuUnitCubeBbox3;

/*
 * The volume [-1,1] x [-1,1] x [-1,1]
 */
extern ApuBbox3 apuTwoUnitCubeBbox3;

/*
 * Test for equality, within tolerance of epsilon.  Uses per
 * coordinate test, not true distance.
 */
Bool ApuEpsEq(Real value1, Real value2, Real epsilon);

/*
 * Test for equality, within tolerance of epsilon.  Uses per
 * coordinate test, not true distance.
 */
Bool ApuEpsEq(const ApuVector3& v1, const ApuVector3& v2,
                Real epsilon);

Real ApuDot(const ApuVector3& v1, const ApuVector3& v2);
Real ApuDistance(const ApuVector3& v1, const ApuVector3& v2);
Real ApuDistanceSquared(const ApuVector3& v1, const ApuVector3& v2);
void ApuCross(const ApuVector3& v1, const ApuVector3& v2, ApuVector3& result);

#endif /* _VECUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\viewport.h ===
#ifndef _VIEWPORT_H
#define _VIEWPORT_H

/*-------------------------------------
Copyright (c) 1996 Microsoft Corporation
-------------------------------------*/

#include "headers.h"

#include <math.h>
#include <ddraw.h>
#include <ddrawex.h>
#include <privinc/error.h>
#include <privinc/ddSurf.h>
#include <privinc/SurfaceManager.h>
#include <privinc/bbox2i.h>
#include <privinc/drect.h>
#include <privinc/discimg.h>
#include <privinc/gendev.h>    // DeviceType


void RectToBbox(LONG pw, LONG ph, Bbox2 &box, Real res);

typedef struct {
    // even though these are mutuall exlusive..
    // they should NOT be a union.
    DDSurfPtr<DDSurface>  _targetDDSurf;
    DDSurfPtr<GDISurface> _targetGDISurf;
    HWND           _targetHWND;
    bool           _alreadyOffset;

    targetEnum     _targetType;

    RECT          *_prcViewport;
    RECT          *_prcClip;
    RECT          *_prcInvalid;
    POINT          _offsetPt;

    bool           _composeToTarget;

    // accessor fcns
    bool IsHWND() { return _targetType == target_hwnd; }
    bool IsDdsurf() { return _targetType == target_ddsurf; }
    bool IsHdc() { return _targetType == target_hdc; }
    bool IsValid() { return _targetType != target_invalid; }

    #if LATER
    // if this is implemented, make sure to add reset code in Reset()
    HRGN           _oldClipRgn;
    HRGN           _clipRgn;
    HDC            _dcFromSurf;
    #endif

    void Reset(bool doDelete)
    {
        _targetType = target_invalid;
        _targetHWND = NULL;
        if(doDelete) {
            delete _prcViewport;
            delete _prcClip;
            delete _prcInvalid;
        }
        _prcViewport = _prcClip = _prcInvalid = NULL;
        _offsetPt.x = _offsetPt.y = 0;
        _composeToTarget = false;
        _alreadyOffset = false;
    }
        
} viewportTargetPackage_t;

// when we want to use ddraw3 exclusively
#define DDRAW3 0
#define DIRECTDRAW DirectDraw3()

#if _DEBUG
#define CREATESURF(desc, surfpp, punk, str) MyCreateSurface(desc, surfpp, punk, str);
#else
#define CREATESURF(desc, surfpp, punk, str) MyCreateSurface(desc, surfpp, punk);
#endif

// viewport functions.
HRESULT GetDirectDraw(IDirectDraw **ddraw1, IDirectDraw2 **ddraw2, IDirectDraw3 **ddraw3);
HRESULT GetPrimarySurface(IDirectDraw2 *ddraw2, IDirectDraw3 *ddraw3, IDDrawSurface **primary);

int BitsPerDisplayPixel (void);

HRESULT SetClipperOnPrimary(LPDIRECTDRAWCLIPPER clipper);

// debug helper functions
#if _DEBUG
extern void DrawRect(HDC dc, RECT *rect,
                     int r, int g, int b,
                     int a1=0, int a2=0, int a3=0);
extern void DrawRect(DDSurface *surf, RECT *rect,
                     int r, int g, int b,
                     int a1=0, int a2=0, int a3=0);
extern void DrawRect(DDSurface *surf, const Bbox2 &bbox,
                     int height, int width, Real res,
                     int r, int g, int b);
#else
#define DrawRect(a,b, d,e,f, g,h,i)
#endif

// Structures used in this class
class TargetDescriptor
{
  public:
    TargetDescriptor() { Reset(); }
    void Reset() {
        isReady = false;
        ZeroMemory(&_pixelFormat, sizeof(DDPIXELFORMAT));
        _redShift = _greenShift = _blueShift = 0;
        _redWidth = _greenWidth = _blueWidth = 0;
        _redTrunc = _greenTrunc = _blueTrunc = 0;
        _red = _green = _blue = 0;
    }

    inline DDPIXELFORMAT &GetPixelFormat() { return _pixelFormat; }
    
    bool isReady;
    DDPIXELFORMAT _pixelFormat;
    char _redShift,  _greenShift, _blueShift;
    char _redWidth, _greenWidth, _blueWidth;
    char _redTrunc, _greenTrunc, _blueTrunc;
    Real _red, _green, _blue;
};


// forward decls
class GeomRenderer;
class DirectDrawImageDevice;
class DibImageClass;
class TextCtx;
class CompositingSurfaceReturner;
struct ClipperReturner;
class SurfacePool;
class SurfaceMap;
class DAGDI;
class targetPackage_t;

class DirectDrawViewport : public GenericDevice {

    // TODO: These guys *should not* all have to be friends.  This is
    // really bogus.  The methods should be made public. 
    friend class  DirectDrawImageDevice;
    friend class  GeomRenderer;
    friend class  CompositingSurfaceReturner;
    friend class  OverlayedImage;
    friend class  CImageDecodeEventSink;
    friend struct ClipperReturner;
    friend class  TargetSurfacePusher;
    friend class  SurfaceArrayReturner;
    friend class  ApplyDXTransformImage;
    
  public:
    DirectDrawViewport();
   ~DirectDrawViewport();

    //
    // Must be called right after construction, ok ?
    //
    void PostConstructorInitialize();

    DeviceType GetDeviceType() { return(IMAGE_DEVICE); }
    
    void RenderImage(Image *image, DirtyRectState &d);
    void BeginRendering(Real topLevelOpac);
    void EndRendering(DirtyRectState &d);
    void Clear();

    bool SetTargetPackage(targetPackage_t *targetPackage);

    int Width() const { return _width; }
    int Height() const { return _height; }

    void SetWidth(int w)  { _width = w; }
    void SetHeight(int h) { _height = h; }

    // Return resolution, in pixels per meter.
    Real GetResolution() { return _resolution; }

    DWORD GetTargetBitDepth() { return _targetDepth; }
    DDPIXELFORMAT &GetTargetPixelFormat() {
        Assert( _targetPixelFormatIsSet );
        Assert( _compositingStack );
        Assert( _compositingStack->IsSamePixelFormat( &_targetDescriptor.GetPixelFormat()));
        return _compositingStack->GetPixelFormat();
    }
    TargetDescriptor &GetTargetDescriptor() { return _targetDescriptor; }
    
    IDirectDraw*  DirectDraw1 (void);
    IDirectDraw2* DirectDraw2 (void);

    #if DDRAW3
        IDirectDraw3* DirectDraw3 (void);
    #else
        inline IDirectDraw2* DirectDraw3 (void) { return DirectDraw2(); }
    #endif

    void DiscreteImageGoingAway(DiscreteImage *image);

    HRESULT MyCreateSurface(LPDDSURFACEDESC lpDesc,
                            LPDIRECTDRAWSURFACE FAR * lplpSurf,
                            IUnknown FAR *pUnk
    #if _DEBUG
                            ,char *whyWhy
    #endif
                            );
#if _DEBUGSURFACE // XXX Note: this code is incorrect due to the perf scoping
                  //           used for movies!
SurfaceTracker *_debugonly_surfaceTracker;
SurfaceTracker *Tracker() {return _debugonly_surfaceTracker;}
#endif


    // -- Win32 Event handling methods --

    void WindowResizeEvent(int width, int height) {  _windowResize = TRUE; }

    // Can this frame be displayed ?
    Bool CanDisplay() {
        return
            _canDisplay &&
            _deviceInitialized &&
            !OnDeathRow();
    }

    bool IsInitialized() { return _deviceInitialized; }
    bool IsWindowless() { return ! _targetPackage._targetHWND; }
    bool IsCompositeDirectly() {  return _targetPackage._composeToTarget;  }
    bool IsSurfMgrSet() { return _surfMgrSet; }
    
    void Stop() {
        _canDisplay = false;
        _canFinalBlit = false;
    }
    void MarkForDestruction() { _onDeathRow = true; }
    bool ICantGoOn() { return _onDeathRow; }
    bool OnDeathRow() { return _onDeathRow; }
    bool IsTargetViable();
    
    DirectDrawImageDevice *GetImageRenderer() {
        return _currentImageDev;
    }

    bool TargetsDiffer( targetPackage_t &a,
                        targetPackage_t &b );
    
    GeomRenderer* MainGeomRenderer (void);
    GeomRenderer* GetAnyGeomRenderer(void);
    void AddGeomDev(GeomRenderer *gdev) { _geomDevs.push_back(gdev);}
    void RemoveGeomDev(GeomRenderer *gdev) { _geomDevs.remove(gdev); }

    IDX2D *GetDX2d() { return _dx2d; }
    IDXTransformFactory *GetDXTransformFactory() { return _IDXTransformFactory; }
    IDXSurfaceFactory *GetDXSurfaceFactory() { return _IDXSurfaceFactory; }

    void CreateSizedDDSurface(DDSurface **ppSurf,
                              DDPIXELFORMAT &pf,
                              LONG width,
                              LONG height,
                              RECT *clipRect,
                              vidmem_enum vid=notVidmem);
    
  private:

    bool ReallySetTargetPackage(targetPackage_t *targetPackage);
    bool GetPixelFormatFromTargetPackage(targetPackage_t *targetStruct,DDPIXELFORMAT &targPf);
   
    void SetUpSurfaceManagement( DDPIXELFORMAT &ddpf );
    void ConstructDdrawMembers();
    void InitializeDevice();    // inits device, ddraw,
                                // deviceDescriptor, etc..
    void SetUpDx2D();
    DAComPtr<IDX2D> _dx2d;
    DAComPtr<IDXTransformFactory> _IDXTransformFactory;
    DAComPtr<IDXSurfaceFactory>   _IDXSurfaceFactory;
    
    // -- Device cache functions & members --
    list<DirectDrawImageDevice *> _deviceStack;
    DirectDrawImageDevice *_tmpDev;
    DirectDrawImageDevice *PopImageDevice();
    void PushImageDevice(DirectDrawImageDevice *dev);

    // -- Private helper functions --

    void UpdateWindowMembers();

    // Destroys surface if exists.  Creates surface
    // with width/height size and clipRect for clipping.
    void ReInitializeSurface(
        LPDDRAWSURFACE *surfPtrPtr,
        DDPIXELFORMAT &pf,
        LPDIRECTDRAWCLIPPER *clipperPtr,
        LONG width,
        LONG height,
        RECT *clipRect,
        vidmem_enum vid=notVidmem,
        except_enum exc=except);

    // Creates a clipper object if one doesn't exist already
    void CreateClipper(LPDIRECTDRAWCLIPPER *clipperPtr);

    // helper function for EndRendering

    void BlitToPrimary(POINT *p,RECT *destRect,RECT *srcRect);

    // Creates a vanilla offscreen surface of width/height
    void CreateOffscreenSurface(
        LPDDRAWSURFACE *surfPtrPtr,
        DDPIXELFORMAT &pf,      
        LONG width,
        LONG height,
        vidmem_enum vid=notVidmem,
        except_enum exc=except);

    // Creates a surface using the give specifications
    void CreateSpecialSurface(
        LPDDRAWSURFACE *surfPtrPtr,
        LPDDSURFACEDESC desc,
        char *errStr);

    // Attaches a ZBUFFER surface to the target, creates if nonexistent.
    // If a Zbuffer can't be created, then an exception is thrown if except
    // is true, otherwise it returns the error code.

    HRESULT AttachZBuffer (DDSurface *zbuff, except_enum exc=except);

    // Sets cliplist on surface of size 'rect'.
    void SetCliplistOnSurface(
        LPDDRAWSURFACE surface,
        LPDIRECTDRAWCLIPPER *clipper,
        RECT *rect);

    HPALETTE GethalftoneHPal();
    LPDIRECTDRAWPALETTE GethalftoneDDpalette();
    HPALETTE CreateHalftonePalettes();
    bool AttachFinalPalette(LPDDRAWSURFACE surface);
    void GetPaletteEntries(HPALETTE hPal, LPPALETTEENTRY palEntries);
    void CreateDDPaletteWithEntries(LPDIRECTDRAWPALETTE *palPtr, LPPALETTEENTRY palEntries);
    //void SelectDDPaleteIntoDC(HDC dc, LPDDRAWSURFACE surface, char *str, int times);
    void SetPaletteOnSurface(LPDDRAWSURFACE surface,
                             LPDIRECTDRAWPALETTE pal);

    void OneTimeDDrawMemberInitialization();
    void CreateSizeDependentTargDDMembers() {
        Assert(!_targetSurfaceClipper);
        //_targetSurfaceClipper = NULL;
        //
        // Create the surface and implicitly (also clipper)
        // Push on _targetSurfaceStack
        //
        PushFirstTargetSurface();
    }

    void RePrepareTargetSurfaces (void);
    //
    // Returns the geom device associated with the DDSurface
    // creates one if none exists.
    //
    GeomRenderer *GetGeomDevice(DDSurface *ddSurf);
    
    DWORD MapColorToDWORD(Color *color);
    DWORD MapColorToDWORD(COLORREF colorRef);

    void UpdateTargetBbox() {
        Real temp;
        temp = GetResolution();
        if (temp != 0)
        {
            Real w = Real(Width()) / temp;
            Real h = Real(Height()) / temp;
            _targetBbox.min.Set(-(w*0.5), -(h*0.5));
            _targetBbox.max.Set( (w*0.5),  (h*0.5));
        }
    }

  public:

    CompositingStack *GetCompositingStack() { return _compositingStack; }
    void AttachCurrentPalette (LPDDRAWSURFACE surface, bool bUsingXforms=false);
    bool IsNT5Windowed() { return (sysInfo.IsNT() && (sysInfo.OSVersionMajor() == 5) && _targetPackage.IsHWND()); }

    // Don't even think of holding on to this bbox!
    inline const Bbox2& GetTargetBbox(void) const 
    { 
        return _targetBbox; 
    }
    
  private:
    // Creates a logical font struct from description in textCtx
    void MakeLogicalFont(TextCtx &textCtx, LPLOGFONTW,
                         LONG width=0, LONG height=0);

    // Enumerates all systems fonts and chooses
    // reasonable fits for font needs
    //void SetUpFonts();

  public:
    void ClearSurface(DDSurface *dds, DWORD color, RECT *rect);
    void ClearDDSurfaceDefaultAndSetColorKey(DDSurface *dds)
    {
        ClearDDSurfaceDefaultAndSetColorKey(dds, _defaultColorKey);
    }
    
    void ClearDDSurfaceDefaultAndSetColorKey(DDSurface *dds, DWORD clrKey)
    {
        Assert( ( dds != _externalTargetDDSurface ) &&
                "trying to clear external target surface" );

        // Set the color key on the surface which stripps off any
        // offending alpha bits.  then get it back out to clear the
        // surace with...
        dds->SetColorKey( clrKey );
        // NOTE: DO NOT MOVE THE SETCOLORKEY AFTER THE CLEARSURFACE
        // CALL!
        // NOTE: DO NOT PASS IN A COLOR KEY TO THE CALL WITHOUT
        // GETTING THE KEY FROM THE SURFACE!!!
        ClearSurface(dds, dds->ColorKey(), dds->GetSurfRect());
        //dds->ClearInterestingRect();
    }

    // --------------------------------------------------
    //
    // Compositing & target surface management
    //
    // --------------------------------------------------

    void GetDDSurfaceForCompositing
        (SurfacePool &pool,
         DDSurface  **outSurf,
         INT32 w, INT32 h,
         clear_enum   clr,
         scratch_enum scr = notScratch,
         vidmem_enum  vid = notVidmem, 
         except_enum  exc = except);

    DWORD GetColorKey() { return _defaultColorKey; }
    void  SetColorKey(DWORD key) { _defaultColorKey = key; }
        
    targetPackage_t     _oldtargetPackage;

    bool GetAlreadyOffset(DDSurface * ddsurf);
    POINT GetOffset() { return _targetPackage._offsetPt; };
  
  private:

    void DestroyCompositingSurfaces() {
        if (_freeCompositingSurfaces) {
            _freeCompositingSurfaces->ReleaseAndEmpty();
        }
    }
    void CreateNewCompositingSurface
         (DDPIXELFORMAT &pf,
          DDSurface **outSurf,
          INT32 width = -1, INT32 height = -1,
          vidmem_enum vid=notVidmem,
          except_enum exc=except);
    
    void ColorKeyedCompose
         (DDSurface *destDDSurf,
          RECT *srcRect,
          DDSurface *srcDDSurf,
          RECT *destRect,
          DWORD clrKey);

    // @@@ ???  this doesn't count any more.
    // we need to decide who the rendering device is, prepare it's
    // compositing stack and surface pool, hand them to it and the let
    // it go.
    void PushFirstTargetSurface();

    void DestroyTargetSurfaces();
    void DestroySizeDependentDDMembers();

    viewportTargetPackage_t   _targetPackage;
    
    LPDIRECTDRAWCLIPPER _targetSurfaceClipper;
    DDSurfPtr<DDSurface> _externalTargetDDSurface;
    LPDIRECTDRAWCLIPPER _externalTargetDDSurfaceClipper;
    LPDIRECTDRAWCLIPPER _oldExternalTargetDDSurfaceClipper;
    bool                _opacityCompositionException;

    bool                _usingExternalDdraw;

    IUnknown     *_directDraw;
    IDirectDraw  *_directDraw1;
    IDirectDraw2 *_directDraw2;
    IDirectDraw3 *_directDraw3;
    IDDrawSurface      *_primSurface;

    IDDrawSurface      * GetMyPrimarySurface();

    void  ReleaseIDirectDrawObjects();
    
    LPDIRECTDRAWCLIPPER _primaryClipper;

    bool                _retreivedPrimaryPixelFormat;
    DDPIXELFORMAT       _primaryPixelFormat;
    bool                _targetPixelFormatIsSet;

    // -- Image/Surface Map members and functions --
    // Associates Images (that stick around across frames)
    // with surfaces dedicated to them.
    SurfaceManager *_surfaceManager;
    SurfaceMap  *_imageSurfaceMap;
    SurfaceMap  *_imageTextureSurfaceMap;
    SurfaceMap  *_imageUpsideDownTextureSurfaceMap;

    SurfacePool      *_freeCompositingSurfaces;
    SurfacePool      *_zbufferSurfaces;
    
    CompositingStack *_compositingStack;

    void AddZBufferDDSurface(DDSurface *surf) {
        _zbufferSurfaces->AddSurface(surf);
    }

    void DestroyZBufferSurfaces() {
        if (_zbufferSurfaces) {
            _zbufferSurfaces->ReleaseAndEmpty();
        }
    }

    //
    // List of Geometry devices: for picking
    //
    list<GeomRenderer *> _geomDevs;

    void NotifyGeomDevsOfSurfaceDeath(
        LPDDRAWSURFACE surface)
    {
        DDSurfPtr<DDSurface> dds;

        // XXX: factor out. see below!
        _freeCompositingSurfaces->Begin();
        while( !_freeCompositingSurfaces->IsEnd() ) {
            dds = _freeCompositingSurfaces->GetCurrentSurf();
            if(dds->GeomDevice()) {
                dds->GeomDevice()->SurfaceGoingAway(surface);
            }
            _freeCompositingSurfaces->Next();
        }

        dds = _compositingStack->GetScratchDDSurfacePtr();
        if(dds && dds->GeomDevice()) {
            dds->GeomDevice()->SurfaceGoingAway(surface);
        }


        // XXX: factor out. see above!
        // Do target surfaces
        _compositingStack->Begin();
        while( !_compositingStack->IsEnd() ) {
            dds = _compositingStack->GetCurrentSurf();
            if(dds->GeomDevice()) {
                dds->GeomDevice()->SurfaceGoingAway(surface);
            }
            _compositingStack->Next();
        }
    }

    // -- Viewport/window data members --
    Real          _resolution; // of dev, in pixels per meter
    int           _width;
    int           _height;
    DWORD         _targetDepth;      // Bits Per Pixel

    RECT         _clientRect;
    Bbox2        _targetBbox;

    LPDIRECTDRAWPALETTE _finalDDpalette;
    LPDIRECTDRAWPALETTE _halftoneDDpalette;
    HPALETTE            _halftoneHPal;

    bool         _canDisplay;
    bool         _windowResize;
    bool         _deviceInitialized;
    bool         _canFinalBlit;
    bool         _surfMgrSet;
    //
    // true if the device needs to be destroyed
    // next chance possible.  Used when the mode
    // changes
    //
    bool          _onDeathRow;

    DWORD        _defaultColorKey;

    TargetDescriptor    _targetDescriptor;

    DirectDrawImageDevice *_currentImageDev;
    DynamicHeap &_heapIWasCreatedOn;

    // -- commonly used vars that used to be globals --
    HRESULT _ddrval;
    DDBLTFX _bltFx;
};


//
// Helper classes
//
struct  ClipperReturner {
    ClipperReturner(DDSurface *surf,
                    LPDIRECTDRAWCLIPPER clip,
                    DirectDrawViewport &vp) :
    _surf(surf),
    _clip(clip),
    _vp(vp)
    {}

    ~ClipperReturner() {
        if (_clip && _surf) {
            if( _vp._targetPackage._composeToTarget ) {
                _vp.SetCliplistOnSurface(_surf->IDDSurface(), &_clip, NULL);
            }
        }
    }

    DDSurface *_surf;
    LPDIRECTDRAWCLIPPER _clip;
    DirectDrawViewport &_vp;
};



#endif /* _VIEWPORT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\retained\rmsound\sndbvr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation for retained mode sound

*******************************************************************************/

#include <headers.h>
#include "appelles/sound.h"
#include "appelles/axaprims.h"
#include "privinc/soundi.h"
#include "backend/bvr.h"
#include "backend/perf.h"
#include "backend/values.h"
#include "backend/sprite.h"
#include "privinc/bufferl.h"  // bufferList stuff
#include "privinc/helps.h"    // class Pan
#include "privinc/util.h"     // TimeTransform

extern Sound *ApplyGain(AxANumber *g, Sound *s);
extern Sound *ApplyPan(AxANumber *g, Sound *s);
extern Sound *ApplyLooping(Sound *s);


SoundSprite::SoundSprite(Sound* snd, MetaSoundDevice *metaDev, 
    Time t0, bool loop) : _snd(snd), _t0(t0), _gain(1.0),
                          _rate(1.0), _loop(loop) 
{
     // Create the sound buffer etc

    _pan = 0.0;

// #define REIMPLEMENT
#ifdef REIMPLEMENT
        // Initialy we are only implementing and assuming static sounds
        // soon we will subclass...
    // Hmm.  Wonder how much could be accomplished by calling the 
    //       LeafSound::Render* methods?

    // does the master buffer exist yet?
    StaticBufferList *staticBufferList = SAFE_CAST(StaticBufferList *,
        metaDev->_bufferListList->GetBufferList(_snd));
//#else // maybe we can call existing code????


    // well, I think we will only get leafSounds...  maybe we should take this
    // as a param instead??
    LeafSound *leafSound = SAFE_CAST(LeafSound *, _snd);
    leafSound->RenderNewBuffer(metaDev);
#endif


}


void 
SoundSprite::UpdateAttributes(double time, double gain, double pan,
    double rate) 
{
        // TODO: lock?
        _gain = gain;
        _pan  = pan;
        _rate = rate;
}


// XXX only wrote this because:
//     std::copy(source.begin(), source.end(), destination->begin());
// results in a bogus destination!
void CopyList(list<Perf>&source, list<Perf>&destination)
{
    list<Perf>::iterator index;
    for(index = source.begin(); index!=source.end(); index++)
        destination.push_back(*index);

}

#ifdef NEW_RRR
double calculateRate(TimeXform timeTransform, double time1, double time2)
{
    double localTime1 = TimeTransform(timeTransform, time1);
    double localTime2 = TimeTransform(timeTransform, time2);
    double rate = (localTime2 - localTime1) / (time2 - time1);
    return rate;
}
#endif


class SndSpriteCtx : public SpriteCtx {
  public:
    SndSpriteCtx(MetaSoundDevice *metaDev) : _metaDev(metaDev), _loop(false) {}

    virtual void Reset() {
        _loop = false;

        // Should be empty, guard against exception.
        _pan.erase(_pan.begin(), _pan.end());
        _gain.erase(_gain.begin(), _gain.end());
    }

    // TODO: share
    virtual Bvr GetEmptyBvr() { return ConstBvr(silence); }
    
    void PushGain(Perf gain) { _gain.push_back(gain); }
    void PopGain() { _gain.pop_back(); }

    void PushPan(Perf pan) { _pan.push_back(pan); }
    void PopPan() { _pan.pop_back(); }

    list<Perf>* CopyPanList() {
        list<Perf>* c = NEW list<Perf>;
        CopyList(_pan, *c);
        Assert(_pan.size() == c->size());
        return c;
    }

    list<Perf>* CopyGainList() {
        list<Perf>* c = NEW list<Perf>;
        CopyList(_gain, *c);
        Assert(_gain.size() == c->size());
        return c;
    }

    bool IsLooping() { return _loop; }
    void SetLooping(bool b) { _loop = b; }
    MetaSoundDevice *_metaDev;  // XXX make an accessor?

  private:
    list<Perf>       _pan;
    list<Perf>       _gain;
    bool             _loop;
};


// Need to set up buffer at some point
class RMSoundImpl : public RMImpl {
  public:
    RMSoundImpl(list<Perf>* pan, list<Perf>* gain,
                SoundSprite* s, TimeXform tt)
    : RMImpl(s), _pan(pan), _gain(gain), _sprite(s), _tt(tt) {}

    virtual ~RMSoundImpl() {
        delete _pan;
        delete _gain;
        //delete _sprite;
    }
    

    // XXX all of the accumulation code has to be re-addressed to handle dB...
    virtual void _Sample(Param& param) {
        list<Perf>::iterator i;
        
        double gain = 1.0; // nominal gain
        double  pan = 0.0; // center pan?
        double rate = 1.0; // nominal rate

        for (i=_gain->begin(); i!=_gain->end(); i++)
            gain += ValNumber((*i)->Sample(param));
        
        for (i=_pan->begin(); i!=_pan->end(); i++)
            pan += ValNumber((*i)->Sample(param));

        // XXX calculate the rate and phase!
        // TODO: Enable when we get back to Spritify
#if 0   
        if (_tt != NULL) {
            //localTime1 = (*_tt)(param);
            double time1 = param._time;
            double localTime1 = EvalLocalTime(_tt, time1);
            double epsilon = 0.01; // XXX for now...
            double time2 = time1 + epsilon;
            double localTime2 = EvalLocalTime(_tt, time2);

            _lastLocalTime = localTime1;
            rate = (localTime2 - localTime1) / (time2 - time1);
        }
#endif  

        _lastSampleTime = param._time;
        _sprite->UpdateAttributes(param._time, gain, pan, rate);

    } 

    virtual void DoKids(GCFuncObj proc) {
        list<Perf>::iterator i;

        for (i=_pan->begin(); i!=_pan->end(); i++)
            (*proc)(*i);
        
        for (i=_gain->begin(); i!=_gain->end(); i++)
            (*proc)(*i);
        
        (*proc)(_tt);

        RMImpl::DoKids(proc);
    }

  private:
    list<Perf>  *_pan;
    list<Perf>  *_gain;
    SoundSprite *_sprite;
    TimeXform    _tt;
};


#ifdef NEW_rrr
void
RMSoundImpl::_Sample(Param& param) 
{
    // XXX all of the accumulation code has to be re-addressed to handle dB...
    list<Perf>::iterator i;
    
    double gain = 1.0; // nominal gain
    double  pan = 0.0; // center pan?
    double rateRate = 0.0; // nominal rate change

    for (i=_gain->begin(); i!=_gain->end(); i++)
        gain += ValNumber((*i)->Sample(param));
    
    for (i=_pan->begin(); i!=_pan->end(); i++)
        pan += ValNumber((*i)->Sample(param));

    // XXX calculate the rate and phase!
    if (!_tt->IsShiftXform()) {
        double epsilon = 0.01; // XXX for now...
                       // but it should eventualy be similar to frame rate
        double time1 = param._time;
        double time2 = time1 + epsilon;
        double time3 = param._time + 0.1;
        double time4 = time3 + epsilon;


        //_lastLocalTime = localTime1;


        double rate1 = calculateRate(_tt, time1, time2);
        double rate2 = calculateRate(_tt, time3, time4);

        // XXX this should really be calculated based on current rate!
        //     maybe I should send the spriteEngine 2 known rates and
        //     let it decide how to get there?
        rateRate = (rate2-rate1)/(time3-time1);
    }

    _lastSampleTime = param._time;
    _sprite->UpdateAttributes(param._time, gain, pan, rateRate);
}
#endif

// TODO: Code factoring
class GainBvrImpl : public BvrImpl {
  public:
    GainBvrImpl(Bvr gain, Bvr snd) : _gain(gain), _snd(snd) {
        // For backward compatibility, TODO: share
        Sound *(*fp)(AxANumber *, Sound *) = ApplyGain;
        _gainBvr = PrimApplyBvr(ValPrimOp(fp, 2, "Gain", SoundType),
                                2, _gain, _snd);
    }
    
    virtual Perf _Perform(PerfParam& p)
    { return ::Perform(_gainBvr, p); }

    virtual RMImpl *Spritify(PerfParam& pp,
                             SpriteCtx* ctx,
                             SpriteNode** sNodeOut) {
        SndSpriteCtx* sCtx = SAFE_CAST(SndSpriteCtx *, ctx);

        sCtx->PushGain(::Perform(_gain, pp));
        RMImpl *p = _snd->Spritify(pp, ctx, sNodeOut);
        sCtx->PopGain();
        return p;
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_gain);
        (*proc)(_snd);
        (*proc)(_gainBvr);
    }

    virtual DXMTypeInfo GetTypeInfo () { return SoundType; }
    
    virtual Bvr EndEvent(Bvr b) {
        return _snd->EndEvent(b);
    }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _gainBvr; }
#endif
    
  private:
    Bvr _gain, _snd, _gainBvr;
};


Bvr ApplyGain(Bvr pan, Bvr snd)
{ return NEW GainBvrImpl(pan, snd); }


class PanBvrImpl : public BvrImpl {
  public:
    PanBvrImpl(Bvr pan, Bvr snd) : _pan(pan), _snd(snd) {
        // For backward compatibility
        Sound *(*fp)(AxANumber *, Sound *) = ApplyPan;
        _panBvr = PrimApplyBvr(ValPrimOp(fp, 2, "Pan",
                                         SoundType)
                               , 2, _pan, _snd);
    }
    
    virtual Perf _Perform(PerfParam& p) 
    { return ::Perform(_panBvr, p); }

    virtual RMImpl *Spritify(PerfParam& pp,
                             SpriteCtx* ctx,
                             SpriteNode** sNodeOut) {
        SndSpriteCtx* sCtx = SAFE_CAST(SndSpriteCtx *, ctx);

        sCtx->PushPan(::Perform(_pan, pp));
        RMImpl *p = _snd->Spritify(pp, ctx, sNodeOut);
        sCtx->PopPan();
        return p;
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_pan);
        (*proc)(_snd);
        (*proc)(_panBvr);
    }

    virtual DXMTypeInfo GetTypeInfo () { return SoundType; }
    
    virtual Bvr EndEvent(Bvr b) {
        return _snd->EndEvent(b);
    }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _panBvr; }
#endif
    
  private:
    Bvr _pan, _snd, _panBvr;
};


Bvr ApplyPan(Bvr pan, Bvr snd)
{ return NEW PanBvrImpl(pan, snd); }

class MixBvrImpl : public BvrImpl {
  public:
    MixBvrImpl(Bvr left, Bvr right) : _left(left), _right(right) {
        // For backward compatibility
        Sound *(*fp)(Sound *, Sound *) = Mix;
        _mix = PrimApplyBvr(ValPrimOp(fp, 2, "Mix", SoundType),
                                      2,
                                      _left, _right);
    }
    
    virtual Perf _Perform(PerfParam& p)
    { return ::Perform(_mix, p); }

    virtual RMImpl *Spritify(PerfParam& p,
                             SpriteCtx* ctx,
                             SpriteNode** s) {
        SndSpriteCtx* sCtx = SAFE_CAST(SndSpriteCtx *, ctx);

        SpriteNode *right;
        
        RMImpl *lsnd = _left->Spritify(p, ctx, s);

        lsnd->Splice(_right->Spritify(p, ctx, &right));

        (*s)->Splice(right);

        return lsnd;
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_left);
        (*proc)(_right);
        (*proc)(_mix);
    }

    virtual DXMTypeInfo GetTypeInfo () { return SoundType; }
    
    virtual Bvr EndEvent(Bvr b) {
        return _mix->EndEvent(b);
    }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _mix; }
#endif
    
  private:
    Bvr _left, _right, _mix;
};


Bvr SoundMix(Bvr sndLeft, Bvr sndRight)
{ return NEW MixBvrImpl(sndLeft, sndRight); }


class SoundLoopBvrImpl : public BvrImpl {
  public:
    SoundLoopBvrImpl(Bvr snd) : _snd(snd) {
        Sound *(*fp)(Sound*) = ApplyLooping;
        // For backward compatibility
        _loopBvr = PrimApplyBvr(ValPrimOp(fp, 1, "ApplyLooping",
                                          SoundType),
                                1, _snd);
    }

    virtual Perf _Perform(PerfParam& pp)
    { return ::Perform(_loopBvr, pp); }

    virtual RMImpl *Spritify(PerfParam& pp,
                             SpriteCtx* ctx,
                             SpriteNode** sNodeOut) {
        SndSpriteCtx* sCtx = SAFE_CAST(SndSpriteCtx *, ctx);

        bool oloop = sCtx->IsLooping();
        sCtx->SetLooping(true);
        RMImpl *p = _snd->Spritify(pp, ctx, sNodeOut);
        sCtx->SetLooping(oloop);
        return p;
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_snd);
        (*proc)(_loopBvr);
    }

    virtual DXMTypeInfo GetTypeInfo () { return SoundType; }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _loopBvr; }
#endif
    
  private:
    Bvr _loopBvr, _snd;
};


Bvr ApplyLooping(Bvr snd)
{ return NEW SoundLoopBvrImpl(snd); }


SpriteCtx *NewSoundCtx(MetaSoundDevice *metaDev)
{ return NEW SndSpriteCtx(metaDev); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\vec2i.h ===
#ifndef _VEC2I_H
#define _VEC2I_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Private implementation of 2D vectors and points

*******************************************************************************/


#include "appelles/common.h"
#include "privinc/storeobj.h"
#include "appelles/vec2.h"

// Vector2
//
// Class that implements a simple 2-element geometric vector
//

class Vector2
{

public:

    Real x, y;

    Vector2(void) {}
    Vector2(const Real _x, const Real _y) : x(_x), y(_y) {}
    
    inline void Set(const Real _x, const Real _y) 
    {
        x = _x;
        y = _y;
    }

    inline const bool operator==(const Vector2 &other) const 
    {
        return ((x == other.x) && (y == other.y));
    }

    inline Vector2& operator+=(const Vector2 &addend) 
    {
        x += addend.x;
        y += addend.y;

        return *this;
    }

    inline Vector2& operator-=(const Vector2 &subtrahend) 
    {
        x -= subtrahend.x;
        y -= subtrahend.y;

        return *this;
    }

    inline Vector2& operator*=(const Real scale) 
    {
        x *= scale;
        y *= scale;

        return *this;
    }

    inline Vector2& operator/=(const Real divisor) 
    {
        Real reciprocal = 1.0 / divisor;
        x *= reciprocal;
        y *= reciprocal;

        return *this;
    }

    inline const Real LengthSquared(void) const 
    {
        return (x * x + y * y);
    }

    inline const Real Length(void) const 
    {
        return sqrt(LengthSquared());
    }

    inline Vector2& Normalize(void) 
    {
        *this /= Length();

        return *this;
    }

#if _USE_PRINT
    inline ostream& Print(ostream& os) const {
        return os << "Vector2(" << x << "," << y << ")";
    }
#endif
};

inline const Vector2 operator-(const Vector2 &v)
{
    return Vector2(-v.x, -v.y);
}

inline const Vector2 operator+(const Vector2 &augend, const Vector2 &addend)
{
    return Vector2(augend.x + addend.x, augend.y + addend.y);
}

inline const Vector2 operator-(const Vector2 &minuend, const Vector2 &subtrahend)
{
    return Vector2(minuend.x - subtrahend.x, minuend.y - subtrahend.y);
}

inline const Vector2 operator*(const Vector2 &multiplicand, const Real multiplier)
{
    return Vector2(multiplicand.x * multiplier, multiplicand.y * multiplier);
}

inline const Vector2 operator*(const Real multiplier, const Vector2 &multiplicand)
{
    return Vector2(multiplicand.x * multiplier, multiplicand.y * multiplier);
}

inline const Vector2 operator/(const Vector2 &dividend, const Real divisor)
{
    return Vector2(dividend.x / divisor, dividend.y / divisor);
}

#if _USE_PRINT
inline ostream& operator<< (ostream& os, const Vector2& V)
{   return os << "<" << V.x << ", " << V.y << ">";
}
#endif

inline const Real Dot(const Vector2 &v1, const Vector2 &v2)
{   
    return (v1.x * v2.x) + (v1.y * v2.y);
}

inline const Real Cross(const Vector2 &v1, const Vector2 &v2)
{   
    return (v1.x * v2.y) - (v1.y * v2.x);
}

inline const Real AngleBetween(const Vector2 &v1, const Vector2 &v2)
{   
    return acos(Dot(v1,v2) / (v1.Length() * v2.Length()));
}


// Point2
//
// Class that implements a simple 2-element geometric point
//

class Point2
{

public:

    Real x, y;

    Point2(void) {}
    Point2(const Real _x, const Real _y) : x(_x), y(_y) {}
    
    inline void Set(const Real _x, const Real _y) 
    {
        x = _x;
        y = _y;
    }

    inline const bool operator==(const Point2 &other) const 
    {
        return ((x == other.x) && (y == other.y));
    }

    inline Point2& operator+=(const Vector2 &addend) 
    {
        x += addend.x;
        y += addend.y;

        return *this;
    }

    inline Point2& operator-=(const Vector2 &subtrahend) 
    {
        x -= subtrahend.x;
        y -= subtrahend.y;

        return *this;
    }

#if _USE_PRINT
    inline ostream& Print(ostream& os) const {
        return os << "Point2(" << x << "," << y << ")";
    }
#endif
};

inline const Point2 operator+(const Point2& augend, const Point2& addend)
{
    return Point2(augend.x + addend.x, augend.y + addend.y);
}

inline const Point2 operator+(const Point2& p, const Vector2& v)
{
    return Point2(p.x + v.x, p.y + v.y);
}

inline const Vector2 operator-(const Point2 &p1, const Point2 &p2)
{
    return Vector2(p1.x - p2.x, p1.y - p2.y);
}

inline const Point2 operator*(const Real multiplier, const Point2& multiplicand)
{
    return Point2(multiplicand.x * multiplier, multiplicand.y * multiplier);
}

inline const Point2 operator*(const Point2& multiplicand, const Real multiplier)
{
    return Point2(multiplicand.x * multiplier, multiplicand.y * multiplier);
}

#if _USE_PRINT
inline ostream& operator<< (ostream& os, const Point2& P)
{   return os << "<" << P.x << ", " << P.y << ">";
}
#endif

inline const Real DistanceSquared(const Point2 &p1, const Point2 &p2)
{
    Real dx = p2.x - p1.x,
         dy = p2.y - p1.y;

    return (dx * dx + dy * dy);
}

inline const Real Distance(const Point2 &p1, const Point2 &p2)
{
    return sqrt(DistanceSquared(p1,p2));
}



// Vector2Value
//
// Class that implements a 2-element geometric vector, as an AxAValue.
//

class Vector2Value : public AxAValueObj
{
  public:

    Real x, y;

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "Vector2Value(" << x << "," << y << ")";
    }
#endif
    
    Vector2Value (void) {}
    Vector2Value (Real _x, Real _y) : x(_x), y(_y) {}

    inline void Set (const Real Vx, const Real Vy) 
    {   x=Vx; y=Vy; 
    }

    inline const Real LengthSquared (void) const
    {   return x*x + y*y;
    }

    inline const Real Length (void) const
    {   return sqrt(LengthSquared()); 
    }

    inline Vector2Value& Normalize (void)
    {   return *this *= 1 / Length();
    }

    inline const bool operator== (const Vector2Value &other) const  // Test for Equality
    {   return (x == other.x) && (y == other.y);
    }

    inline Vector2Value& operator*= (const Real scalar)
    {   x *= scalar;
        y *= scalar;
        return *this;
    }

    inline Vector2Value& operator/= (const Real d)
    {   return *this *= (1/d); 
    }

    virtual DXMTypeInfo GetTypeInfo(void)
    {   return Vector2ValueType; 
    }
};

class Vector2WithCreationSource : public Vector2Value
{
  public:
    bool _createdInPixelMode;
};

class Point2Value : public AxAValueObj
{
  public:

    Real x, y;

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "Point2Value(" << x << "," << y << ")";
    }
#endif
    
    Point2Value (void) {}
    Point2Value (const Real _x, const Real _y) : x(_x), y(_y) {}

    void Set (const Real Px, const Real Py) 
    {   x=Px; y=Py; 
    }

    inline const bool operator== (const Point2Value &other) const      // Test for Equality
    {   return (x == other.x) && (y == other.y);
    }

    inline Point2Value& operator-= (const Vector2Value& V)
    {   x -= V.x;
        y -= V.y;
        return *this;
    }

    inline Point2Value& operator+= (const Vector2Value& V)
    {   x += V.x;
        y += V.y;
        return *this;
    }

    virtual DXMTypeInfo GetTypeInfo(void) 
    {   return Point2ValueType; 
    }
};

class Point2WithCreationSource : public Point2Value
{
  public:
    bool _createdInPixelMode;
};


    // Vector Operators

inline const Vector2Value operator- (const Vector2Value &A, const Vector2Value &B)
{   return Vector2Value (A.x - B.x, A.y - B.y);
}

inline const Vector2Value operator+ (const Vector2Value &A, const Vector2Value &B)
{   return Vector2Value (A.x + B.x, A.y + B.y);
}

inline const Vector2Value operator- (const Vector2Value &V)
{   return Vector2Value (-V.x, -V.y);
}

inline const Vector2Value operator* (const Real s, const Vector2Value &V)
{   return Vector2Value (s * V.x, s * V.y);
}

inline const Vector2Value operator* (const Vector2Value &V, const Real s)  
{   return s * V; 
}

inline const Vector2Value operator/ (const Vector2Value &V, const Real d)  
{   return V * (1/d); 
}

inline const Real Dot (const Vector2Value &A, const Vector2Value &B)
{   return (A.x * B.x) + (A.y * B.y);
}

inline const Real AngleBetween (const Vector2Value &A, const Vector2Value &B)
{   return acos(Dot(A,B) / (A.Length() * B.Length()));
}

inline const Real Cross (const Vector2Value &A, const Vector2Value &B)
{   return (A.x * B.y) - (A.y * B.x);
}



    // Vector External Interfaces

Vector2Value *XyVector2RR(Real x, Real y);
Vector2Value *PolarVector2RR(Real angle, Real radius);
Real RDotVector2Vector2 (Vector2Value *A, Vector2Value *B);
Vector2Value *ScaleRealVector2R (Real scalar, Vector2Value *v);
Vector2Value *DivideVector2RealR(Vector2Value *v, Real scalar);


    // Point Operators

inline const Real DistanceSquared (const Point2Value& P, const Point2Value&Q)
{
    Real dx = P.x - Q.x,
         dy = P.y - Q.y;

    return (dx*dx) + (dy*dy);
}

inline const Real Distance (const Point2Value &A, const Point2Value &B)
{ 
    return sqrt (DistanceSquared (A,B)); 
}


    // Point External Interfaces

Point2Value *XyPoint2RR (Real x, Real y);
Point2Value *PolarPoint2RR (Real angle, Real radius);


    // Point-Vector Operators

inline const Vector2Value operator- (const Point2Value &P, const Point2Value &Q)
{   return Vector2Value (P.x - Q.x, P.y - Q.y);
}

inline const Point2Value operator+ (const Point2Value &P, const Vector2Value &V)
{   return Point2Value (P.x + V.x, P.y + V.y);
}

inline const Point2Value operator- (const Point2Value &P, const Vector2Value &V)
{   return Point2Value (P.x - V.x, P.y - V.y);
}

inline const Point2Value operator+ (const Vector2Value &V, const Point2Value &P)  
{   return P + V; 
}



    // Promotion and demotion

inline const Vector2 Demote(const Vector2Value& v)
{
    return Vector2(v.x, v.y);
}

inline Vector2Value* Promote(const Vector2& v)
{
    return NEW Vector2Value(v.x, v.y);
}

inline const Point2 Demote(const Point2Value& v)
{
    return Point2(v.x, v.y);
}

inline Point2Value* Promote(const Point2& v)
{
    return NEW Point2Value(v.x, v.y);
}


    // Constants

const Vector2 XVector2(1,0);
const Vector2 YVector2(0,1);
const Vector2 ZeroVector2(0,0);
const Point2 Origin2(0,0);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\rsrc\makefile.inc ===
danim.rc : $(SDKDIR)\danim.tlb \
              dxactrl.rgs \
              dxactrl.bmp \
              dxactrlw.rgs \
              dxactrlw.bmp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\privinc\xformi.h ===
#ifndef _AV_XFORMI_H
#define _AV_XFORMI_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Implementation of abstract perspective transformation class

*******************************************************************************/

#include "appelles/common.h"
#include "appelles/valued.h"
#include "privinc/matutil.h"
#include "privinc/xform2i.h"
#include "privinc/storeobj.h"


// Forward Declarations

class Point3;
class Vector3;



class ATL_NO_VTABLE Transform3 : public AxAValueObj
{
  public:

    // Returns a reference to a 4x4 matrix.  Note that this breaks the
    // abstraction of general spatial transformations - if it COULD be
    // expressed as a 4x4 matrix, then it WOULD be.  We need to rip this
    // method out in the future and implement a cleaner abstraction.

    virtual const Apu4x4Matrix& Matrix() = 0;

    virtual Transform3 *Inverse ();
    virtual Bool        IsSingular();

    // Make a copy on the heap that is current when this is called.
    Transform3         *Copy();

    virtual DXMTypeInfo GetTypeInfo() { return Transform3Type; }

    virtual bool SwitchToNumbers(Transform2::Xform2Type typeOfNewNumbers,
                                 Real                  *numbers);
#if _USE_PRINT
    ostream& Print (ostream &os);
#endif

};


    // Instantiate a Transform3 from a utility matrix

Transform3 *Apu4x4XformImpl (const Apu4x4Matrix &matrix);

Transform3 *Transform3Matrix16 (Real m00, Real m01, Real m02, Real m03,
                                Real m10, Real m11, Real m12, Real m13,
                                Real m20, Real m21, Real m22, Real m23,
                                Real m30, Real m31, Real m32, Real m33);

Transform3 *TranslatePoint3 (Point3Value *new_origin);
Transform3 *Translate (Real Tx, Real Ty, Real Tz);
Transform3 *TranslateWithMode (Real Tx, Real Ty, Real Tz, bool pixelMode);

Transform3 *Scale (Real, Real, Real);

Transform3 *RotateXyz (Real angle, Real x, Real y, Real z);

Transform3 *RotateX (Real angle);
Transform3 *RotateY (Real angle);
Transform3 *RotateZ (Real angle);

    // Construct a 3D transform from the desired origin and 3 basis vectors.

Transform3 *TransformBasis
                (Point3Value *origin, Vector3Value *Bx, Vector3Value *By, Vector3Value *Bz);

extern Transform3 *CopyTransform3(Transform3 *xf);

    // Rotation using a Quaternion

#ifdef QUATERNIONS_REMOVED_FOR_NOW
Transform3 *RotateQuaternion (Quaternion *q);
#endif QUATERNIONS_REMOVED_FOR_NOW

    // Displaced Transform3 *does (xform(center + x) - center)

Transform3 *DisplacedXform (Point3Value *center, Transform3 *xform);

    // RollPitchHeading() places the object at 'position', rotated 'heading'
    // radians in the XZ plane, pitched up by 'pitch' radians, and rolled
    // about the viewing axis by 'roll' radians.

Transform3 *RollPitchHeading
                (Real *roll, Real *pitch, Real *heading, Point3Value *position);

    // PolarOrient() assumes that the target is located at the origin (in
    // modeling coordinates).  The object is moved 'radius' units along +Z,
    // rotated about +Z by 'twist' radians, rotated about -X by 'elevation'
    // radians, and finally rotated about +Y by 'azimuth' radians.
    // Normally, radius is in (0,infinity), elevation is in [-pi/2,+pi/2],
    // azimuth is in [0,2pi], and twist is in [-pi,+pi].

Transform3 *PolarOrient
                (Real *radius, Real *elevation, Real *azimuth, Real *twist);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\retained\rmsound\spritethread.cpp ===
/*******************************************************************************

Copyright (c) 1997 Microsoft Corporation

Abstract:

    Class which manages the sprite thread.

*******************************************************************************/

#include "headers.h"
#include "privinc/mutex.h"
#include "privinc/debug.h"          // tracetags
#include "privinc/bufferl.h"        // BufferElement, et. al.
#include "privinc/spriteThread.h"
#include "backend/sprite.h"         // RMImpl (lets put it somewhere better!)
#include "privinc/helps.h"          // linearTodB
#include "privinc/htimer.h"         // HiresTimer

// this is the fn() which is the embodiment of the sprite thread
LPTHREAD_START_ROUTINE renderSprites(void *ptr)
{
    SpriteThread *spriteThread = (SpriteThread *)ptr;
    MetaSoundDevice *metaDev = spriteThread->_metaDev;

    CoInitialize(NULL); // needed on each thread to be able to
                        // cocreate...

#ifdef LATER

    HiresTimer&  timer = CreateHiresTimer();

    // make this a hi-priority thread
    BOOL status =
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    // XXX should be able to block on a semiphore if there is nothing todo
    double currentTime = timer.GetTime();
    double lastTime = currentTime;
    double epsilon = 0.0000001;

    while(!spriteThread->_done) {
        currentTime = timer.GetTime();// get the current hires time
        double deltaTime = currentTime - lastTime; // time since last iteration
        if (deltaTime < epsilon)
            deltaTime = epsilon;
        lastTime = currentTime;

        SoundSprite *sprite = // first sprite
            SAFE_CAST(SoundSprite *, spriteThread->_updateTree->_sprite);
        while(sprite) { // traverse spritelist
            AVPath path = metaDev->GetPath();
            LeafSound *sound = SAFE_CAST(LeafSound *, sprite->_snd);

            // get the BufferElement off the BufferListList
            BufferElement *bufferElement = 
                metaDev->_bufferListList->GetBuffer(sound, path);

            // have my way with the sprite!

            if(!bufferElement->_playing) {
                sound->RenderStartAtLocation(metaDev, bufferElement,
                        0.0, sprite->_loop);
                bufferElement->_playing = TRUE;
            }

            // calculate predictive trends
            double deltaRate = sprite->_rate * deltaTime;
            double rate = metaDev->GetRate() + deltaRate;

            metaDev->SetGain(LinearTodB(sprite->_gain));
            metaDev->GetPan()->SetLinear(sprite->_pan);
            metaDev->SetRate(rate);
            sound->RenderAttributes(metaDev, bufferElement, 1.0, 0, 0.0);

            // this may be called rapidly (use ptr?)
            sprite = SAFE_CAST(SoundSprite *, sprite->Next());
        }

        Sleep(10);  // sleep in milliSeconds...
    }
#endif

    // cleanup and exit
    CoUninitialize();
    TraceTag((tagSoundDebug, "SpriteThread exiting"));
    return(0);
}


SpriteThread::SpriteThread(MetaSoundDevice *metaDev, RMImpl *updateTree) :
 _metaDev(metaDev), _updateTree(updateTree)
{
    _done          = 0;  // enable the thread

    _threadHandle = CreateThread(NULL, 0,
                                 (LPTHREAD_START_ROUTINE)renderSprites,
                                 this,
                                 0,
                                 &_threadID);

    TraceTag((tagSoundDebug, "SpriteThread instantiated"));
}


SpriteThread::~SpriteThread()
{
    TraceTag((tagSoundDebug, "SpriteThread destroyed"));

    // XXX well the correct thing to do is set done=1, wait for the thread
    // to die, if this times out, then kill the thread!


    if(_threadHandle) {
        _done = TRUE;    // tell the thread to kill itself

        // TODO: May need to address whether to kill the thread or not
        if(WaitForSingleObject(_threadHandle, 5000) == WAIT_TIMEOUT) {
            Assert(FALSE && "Sprite thread termination timed out");
            TerminateThread(_threadHandle, 0);
        }

        CloseHandle(_threadHandle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\axasrv.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _AXASRV_H
#define _AXASRV_H


#endif /* _AXASRV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\bvrclas0.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/

#include "headers.h"
#include "cbvr.h"
#include "srvprims.h"
#include "comcb.h"
#include "privinc/resource.h"
#include "bvrtypes.h"
#include "comconv.h"
#include "results.h"

#include "primmth0.h"

bool CreatePrim0(REFIID iid, void *fp  , void **ret);

bool CreatePrim1(REFIID iid, void *fp , IDABehavior * arg1 , void **ret);

bool CreatePrim2(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2 , void **ret);

bool CreatePrim3(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2, IDABehavior * arg3 , void **ret);

bool CreatePrim4(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2, IDABehavior * arg3, IDABehavior * arg4 , void **ret);

bool CreateVar(REFIID iid, CRBvrPtr var, void **ret);

STDMETHODIMP
CDABoolean::Extract(VARIANT_BOOL * ret)
{
    TraceTag((tagCOMEntry, "CDABoolean::Extract(%lx)", this));

    PRIMPRECODE1(ret) ;
    /* NOELRET */ *ret = boolToBOOL(::CRExtract((CRBoolean *) _bvr.p));
    PRIMPOSTCODE(S_OK) ;
}



CBvr * CDABooleanCreate(IDABehavior ** bvr)
{
    DAComObject<CDABoolean> * pNew ;

    DAComObject<CDABoolean>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDABoolean *) pNew;

    return pNew ;
}

STDMETHODIMP
CDABooleanFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRBOOLEAN_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAGeometry::RenderSound(IDAMicrophone *  arg1, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::RenderSound(%lx)", this));
    return CreatePrim2(IID_IDASound, (CRSound * (STDAPICALLTYPE *)(CRGeometry *, CRMicrophone *)) CRRenderSound , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::AddPickData(IUnknown * arg1, VARIANT_BOOL arg2, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::AddPickData(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAGeometry, (CRBvrPtr) (::CRAddPickData((CRGeometry *) _bvr.p, /* NOELARG */ arg1, /* NOELARG */ BOOLTobool(arg2))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAGeometry::Undetectable(IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::Undetectable(%lx)", this));
    return CreatePrim1(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *)) CRUndetectable , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::EmissiveColor(IDAColor *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::EmissiveColor(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRColor *)) CREmissiveColor , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::DiffuseColor(IDAColor *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::DiffuseColor(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRColor *)) CRDiffuseColor , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::SpecularColor(IDAColor *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::SpecularColor(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRColor *)) CRSpecularColor , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::SpecularExponent(double arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::SpecularExponent(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAGeometry, (CRBvrPtr) (::CRSpecularExponent((CRGeometry *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAGeometry::SpecularExponentAnim(IDANumber *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::SpecularExponentAnim(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRNumber *)) CRSpecularExponentAnim , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::Texture(IDAImage *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::Texture(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRImage *)) CRTexture , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::Opacity(double arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::Opacity(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAGeometry, (CRBvrPtr) (::CROpacity((CRGeometry *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAGeometry::OpacityAnim(IDANumber *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::OpacityAnim(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRNumber *)) CROpacity , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::Transform(IDATransform3 *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::Transform(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRTransform3 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::Shadow(IDAGeometry *  arg1, IDAPoint3 *  arg2, IDAVector3 *  arg3, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::Shadow(%lx)", this));
    return CreatePrim4(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRGeometry *, CRPoint3 *, CRVector3 *)) CRShadow , (IDA2Behavior *) (CBvr *)this, arg1, arg2, arg3, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::get_BoundingBox(IDABbox3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::get_BoundingBox(%lx)", this));
    return CreatePrim1(IID_IDABbox3, (CRBbox3 * (STDAPICALLTYPE *)(CRGeometry *)) CRBoundingBox , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::Render(IDACamera *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::Render(%lx)", this));
    return CreatePrim2(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRGeometry *, CRCamera *)) CRRender , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::LightColor(IDAColor *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::LightColor(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRColor *)) CRLightColor , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::LightRangeAnim(IDANumber *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::LightRangeAnim(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRNumber *)) CRLightRange , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::LightRange(double arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::LightRange(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAGeometry, (CRBvrPtr) (::CRLightRange((CRGeometry *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAGeometry::LightAttenuationAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::LightAttenuationAnim(%lx)", this));
    return CreatePrim4(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRNumber *, CRNumber *, CRNumber *)) CRLightAttenuation , (IDA2Behavior *) (CBvr *)this, arg0, arg1, arg2, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::LightAttenuation(double arg0, double arg1, double arg2, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::LightAttenuation(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAGeometry, (CRBvrPtr) (::CRLightAttenuation((CRGeometry *) _bvr.p, /* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAGeometry::BlendTextureDiffuse(IDABoolean *  arg1, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::BlendTextureDiffuse(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRBoolean *)) CRBlendTextureDiffuse , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::AmbientColor(IDAColor *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::AmbientColor(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRColor *)) CRAmbientColor , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::D3DRMTexture(IUnknown * arg1, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::D3DRMTexture(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAGeometry, (CRBvrPtr) (::CRD3DRMTexture((CRGeometry *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAGeometry::ModelClip(IDAPoint3 *  arg0, IDAVector3 *  arg1, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::ModelClip(%lx)", this));
    return CreatePrim3(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRPoint3 *, CRVector3 *)) CRModelClip , (IDA2Behavior *) (CBvr *)this, arg0, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::Lighting(IDABoolean *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::Lighting(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRBoolean *)) CRLighting , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::TextureImage(IDAImage *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::TextureImage(%lx)", this));
    return CreatePrim2 (IID_IDAGeometry, (CRGeometry* (STDAPICALLTYPE*)(CRGeometry*, CRImage*)) CRTextureImage, (IDA2Behavior*) (CBvr*)this, arg0, (void**) ret) ? S_OK : Error();
}

bool
PickableHelper(CRBvrPtr bvr,
               PickableType type,
               IDAPickableResult **ppResult)
{
    bool ok = false;
    
    CRPickableResultPtr res;

    switch (type) {
      case PT_IMAGE:
        res = CRPickable((CRImage *) bvr);
        break;
      case PT_IMAGE_OCCLUDED:
        res = CRPickableOccluded((CRImage *) bvr);
        break;
      case PT_GEOM:
        res = CRPickable((CRGeometry *) bvr);
        break;
      case PT_GEOM_OCCLUDED:
        res = CRPickableOccluded((CRGeometry *) bvr);
        break;
      default:
        Assert (!"Invalid type passed to PickableHelper");
        res = NULL;
        break;
    }

    if (res) {
        ok = CDAPickableResult::Create(res,
                                       ppResult);
    }

  done:
    return ok;
}

STDMETHODIMP
CDAGeometry::Pickable(IDAPickableResult **ppResult)
{
    PRIMPRECODE1(ppResult);
    PickableHelper(_bvr, PT_GEOM, ppResult);
    PRIMPOSTCODE1(ppResult);
}

STDMETHODIMP
CDAGeometry::PickableOccluded(IDAPickableResult **ppResult)
{
    PRIMPRECODE1(ppResult);
    PickableHelper(_bvr, PT_GEOM_OCCLUDED, ppResult);
    PRIMPOSTCODE1(ppResult);
}


STDMETHODIMP CDAGeometry::Billboard (IDAVector3 *axis, IDAGeometry **result)
{
    TraceTag ((tagCOMEntry, "CDAGeometry::Billboard(%lx)", this));
    return
      CreatePrim2 (
        IID_IDAGeometry,
        (CRGeometry* (STDAPICALLTYPE*)(CRGeometry*, CRVector3*)) CRBillboard,
        (IDA2Behavior*) (CBvr*)this, axis, (void**) result
      )
      ? S_OK : Error();
}


CBvr * CDAGeometryCreate(IDABehavior ** bvr)
{
    DAComObject<CDAGeometry> * pNew ;

    DAComObject<CDAGeometry>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAGeometry *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAGeometryFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRGEOMETRY_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAMicrophone::Transform(IDATransform3 *  arg0, IDAMicrophone *  * ret)
{
    TraceTag((tagCOMEntry, "CDAMicrophone::Transform(%lx)", this));
    return CreatePrim2(IID_IDAMicrophone, (CRMicrophone * (STDAPICALLTYPE *)(CRMicrophone *, CRTransform3 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}



CBvr * CDAMicrophoneCreate(IDABehavior ** bvr)
{
    DAComObject<CDAMicrophone> * pNew ;

    DAComObject<CDAMicrophone>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAMicrophone *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAMicrophoneFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRMICROPHONE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAPath2::Transform(IDATransform2 *  arg0, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPath2::Transform(%lx)", this));
    return CreatePrim2(IID_IDAPath2, (CRPath2 * (STDAPICALLTYPE *)(CRPath2 *, CRTransform2 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAPath2::BoundingBox(IDALineStyle *  arg0, IDABbox2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPath2::BoundingBox(%lx)", this));
    return CreatePrim2(IID_IDABbox2, (CRBbox2 * (STDAPICALLTYPE *)(CRPath2 *, CRLineStyle *)) CRBoundingBox , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAPath2::Fill(IDALineStyle *  arg0, IDAImage *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPath2::Fill(%lx)", this));
    return CreatePrim3(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRPath2 *, CRLineStyle *, CRImage *)) CRFill , (IDA2Behavior *) (CBvr *)this, arg0, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAPath2::Draw(IDALineStyle *  arg0, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPath2::Draw(%lx)", this));
    return CreatePrim2(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRPath2 *, CRLineStyle *)) CRDraw , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAPath2::Close(IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPath2::Close(%lx)", this));
    return CreatePrim1(IID_IDAPath2, (CRPath2 * (STDAPICALLTYPE *)(CRPath2 *)) CRClose , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}



CBvr * CDAPath2Create(IDABehavior ** bvr)
{
    DAComObject<CDAPath2> * pNew ;

    DAComObject<CDAPath2>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAPath2 *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAPath2Factory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRPATH2_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDASound::PhaseAnim(IDANumber *  arg0, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDASound::PhaseAnim(%lx)", this));
    return CreatePrim2(IID_IDASound, (CRSound * (STDAPICALLTYPE *)(CRSound *, CRNumber *)) CRPhase , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDASound::Phase(double arg0, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDASound::Phase(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDASound, (CRBvrPtr) (::CRPhase((CRSound *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDASound::RateAnim(IDANumber *  arg0, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDASound::RateAnim(%lx)", this));
    return CreatePrim2(IID_IDASound, (CRSound * (STDAPICALLTYPE *)(CRSound *, CRNumber *)) CRRate , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDASound::Rate(double arg0, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDASound::Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDASound, (CRBvrPtr) (::CRRate((CRSound *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDASound::PanAnim(IDANumber *  arg0, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDASound::PanAnim(%lx)", this));
    return CreatePrim2(IID_IDASound, (CRSound * (STDAPICALLTYPE *)(CRSound *, CRNumber *)) CRPan , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDASound::Pan(double arg0, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDASound::Pan(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDASound, (CRBvrPtr) (::CRPan((CRSound *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDASound::GainAnim(IDANumber *  arg0, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDASound::GainAnim(%lx)", this));
    return CreatePrim2(IID_IDASound, (CRSound * (STDAPICALLTYPE *)(CRSound *, CRNumber *)) CRGain , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDASound::Gain(double arg0, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDASound::Gain(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDASound, (CRBvrPtr) (::CRGain((CRSound *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDASound::Loop(IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDASound::Loop(%lx)", this));
    return CreatePrim1(IID_IDASound, (CRSound * (STDAPICALLTYPE *)(CRSound *)) CRLoop , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}



CBvr * CDASoundCreate(IDABehavior ** bvr)
{
    DAComObject<CDASound> * pNew ;

    DAComObject<CDASound>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDASound *) pNew;

    return pNew ;
}

STDMETHODIMP
CDASoundFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRSOUND_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDATransform3::Inverse(IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDATransform3::Inverse(%lx)", this));
    return CreatePrim1(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRTransform3 *)) CRInverse , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDATransform3::get_IsSingular(IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDATransform3::get_IsSingular(%lx)", this));
    return CreatePrim1(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRTransform3 *)) CRIsSingular , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDATransform3::ParallelTransform2(IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDATransform3::ParallelTransform2(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRTransform3 *)) CRParallelTransform2 , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}



CBvr * CDATransform3Create(IDABehavior ** bvr)
{
    DAComObject<CDATransform3> * pNew ;

    DAComObject<CDATransform3>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDATransform3 *) pNew;

    return pNew ;
}

STDMETHODIMP
CDATransform3Factory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRTRANSFORM3_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAFontStyle::Bold(IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::Bold(%lx)", this));
    return CreatePrim1(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRFontStyle *)) CRBold , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAFontStyle::Italic(IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::Italic(%lx)", this));
    return CreatePrim1(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRFontStyle *)) CRItalic , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAFontStyle::Underline(IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::Underline(%lx)", this));
    return CreatePrim1(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRFontStyle *)) CRUnderline , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAFontStyle::Strikethrough(IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::Strikethrough(%lx)", this));
    return CreatePrim1(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRFontStyle *)) CRStrikethrough , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAFontStyle::AntiAliasing(double arg0, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::AntiAliasing(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAFontStyle, (CRBvrPtr) (::CRAntiAliasing((CRFontStyle *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAFontStyle::Color(IDAColor *  arg1, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::Color(%lx)", this));
    return CreatePrim2(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRFontStyle *, CRColor *)) CRTextColor , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAFontStyle::FamilyAnim(IDAString *  arg1, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::FamilyAnim(%lx)", this));
    return CreatePrim2(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRFontStyle *, CRString *)) CRFamily , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAFontStyle::Family(BSTR arg1, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::Family(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAFontStyle, (CRBvrPtr) (::CRFamily((CRFontStyle *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAFontStyle::SizeAnim(IDANumber *  arg1, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::SizeAnim(%lx)", this));
    return CreatePrim2(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRFontStyle *, CRNumber *)) CRSize , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAFontStyle::Size(double arg1, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::Size(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAFontStyle, (CRBvrPtr) (::CRSize((CRFontStyle *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAFontStyle::Weight(double arg1, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::Weight(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAFontStyle, (CRBvrPtr) (::CRWeight((CRFontStyle *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAFontStyle::WeightAnim(IDANumber *  arg1, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::WeightAnim(%lx)", this));
    return CreatePrim2(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRFontStyle *, CRNumber *)) CRWeight , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAFontStyle::TransformCharacters(IDATransform2 *  arg1, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::TransformCharacters(%lx)", this));
    return CreatePrim2(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRFontStyle *, CRTransform2 *)) CRTransformCharacters , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error();

}



CBvr * CDAFontStyleCreate(IDABehavior ** bvr)
{
    DAComObject<CDAFontStyle> * pNew ;

    DAComObject<CDAFontStyle>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAFontStyle *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAFontStyleFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRFONTSTYLE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}



CBvr * CDAJoinStyleCreate(IDABehavior ** bvr)
{
    DAComObject<CDAJoinStyle> * pNew ;

    DAComObject<CDAJoinStyle>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAJoinStyle *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAJoinStyleFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRJOINSTYLE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDABbox3::get_Min(IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDABbox3::get_Min(%lx)", this));
    return CreatePrim1(IID_IDAPoint3, (CRPoint3 * (STDAPICALLTYPE *)(CRBbox3 *)) CRMin , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDABbox3::get_Max(IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDABbox3::get_Max(%lx)", this));
    return CreatePrim1(IID_IDAPoint3, (CRPoint3 * (STDAPICALLTYPE *)(CRBbox3 *)) CRMax , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}



CBvr * CDABbox3Create(IDABehavior ** bvr)
{
    DAComObject<CDABbox3> * pNew ;

    DAComObject<CDABbox3>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDABbox3 *) pNew;

    return pNew ;
}

STDMETHODIMP
CDABbox3Factory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRBBOX3_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAArray::NthAnim(IDANumber *  arg1, IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDAArray::NthAnim(%lx)", this));
    return CreatePrim2(IID_IDABehavior, (CRBvr * (STDAPICALLTYPE *)(CRArray *, CRNumber *)) CRNth , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAArray::Length(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAArray::Length(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRArray *)) CRLength , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAArray::AddElement(IDABehavior *  arg1, DWORD arg2, long * ret)
{
    TraceTag((tagCOMEntry, "CDAArray::AddElement(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRBvr * arg1VAL;
    arg1VAL = (CRBvr *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    /* NOELRET */ *ret = (::CRAddElement((CRArray *) _bvr.p, arg1VAL, /* NOELARG */ arg2));
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAArray::RemoveElement(long arg1)
{
    TraceTag((tagCOMEntry, "CDAArray::RemoveElement(%lx)", this));

    PRIMPRECODE0(ret) ;
    /* NOELRET */ ret = (::CRRemoveElement((CRArray *) _bvr.p, /* NOELARG */ arg1));
    PRIMPOSTCODE0(ret) ;
}

STDMETHODIMP
CDAArray::SetElement(long index, IDABehavior *  arg1, long flag)
{
    TraceTag((tagCOMEntry, "CDAArray::SetElement(%lx)", this));

    PRIMPRECODE0(ret) ;

    CRBvr * arg1VAL;
    arg1VAL = (CRBvr *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    /* NOELRET */ ret = (::CRSetElement((CRArray *) _bvr.p, index, arg1VAL, /* NOELARG */ flag));
    PRIMPOSTCODE0(ret) ;
}

STDMETHODIMP
CDAArray::GetElement(long index, IDABehavior **ret)
{
    TraceTag((tagCOMEntry, "CDAArray::GetElement(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDABehavior,
               (CRBvrPtr) ::CRGetElement((CRArray *) _bvr.p, index),
               (void **) ret);
    PRIMPOSTCODE1(ret) ;
}


CBvr * CDAArrayCreate(IDABehavior ** bvr)
{
    DAComObject<CDAArray> * pNew ;

    DAComObject<CDAArray>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAArray *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAArrayFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRARRAY_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}



CBvr * CDABehaviorCreate(IDABehavior ** bvr)
{
    DAComObject<CDABehavior> * pNew ;

    DAComObject<CDABehavior>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDA2Behavior *) pNew;

    return pNew ;
}

STDMETHODIMP
CDABehaviorFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRUNKNOWN_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\bvrclas1.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/

#include "headers.h"
#include "cbvr.h"
#include "srvprims.h"
#include "comcb.h"
#include "privinc/resource.h"
#include "bvrtypes.h"
#include "comconv.h"
#include "propanim.h"

#include "primmth1.h"

bool CreatePrim0(REFIID iid, void *fp  , void **ret);

bool CreatePrim1(REFIID iid, void *fp , IDABehavior * arg1 , void **ret);

bool CreatePrim2(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2 , void **ret);

bool CreatePrim3(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2, IDABehavior * arg3 , void **ret);

bool CreatePrim4(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2, IDABehavior * arg3, IDABehavior * arg4 , void **ret);

bool CreateVar(REFIID iid, CRBvrPtr var, void **ret);

STDMETHODIMP
CDACamera::Transform(IDATransform3 *  arg0, IDACamera *  * ret)
{
    TraceTag((tagCOMEntry, "CDACamera::Transform(%lx)", this));
    return CreatePrim2(IID_IDACamera, (CRCamera * (STDAPICALLTYPE *)(CRCamera *, CRTransform3 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDACamera::Depth(double arg0, IDACamera *  * ret)
{
    TraceTag((tagCOMEntry, "CDACamera::Depth(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDACamera, (CRBvrPtr) (::CRDepth((CRCamera *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDACamera::DepthAnim(IDANumber *  arg0, IDACamera *  * ret)
{
    TraceTag((tagCOMEntry, "CDACamera::DepthAnim(%lx)", this));
    return CreatePrim2(IID_IDACamera, (CRCamera * (STDAPICALLTYPE *)(CRCamera *, CRNumber *)) CRDepth , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDACamera::DepthResolution(double arg0, IDACamera *  * ret)
{
    TraceTag((tagCOMEntry, "CDACamera::DepthResolution(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDACamera, (CRBvrPtr) (::CRDepthResolution((CRCamera *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDACamera::DepthResolutionAnim(IDANumber *  arg0, IDACamera *  * ret)
{
    TraceTag((tagCOMEntry, "CDACamera::DepthResolutionAnim(%lx)", this));
    return CreatePrim2(IID_IDACamera, (CRCamera * (STDAPICALLTYPE *)(CRCamera *, CRNumber *)) CRDepthResolution , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}



CBvr * CDACameraCreate(IDABehavior ** bvr)
{
    DAComObject<CDACamera> * pNew ;
    
    DAComObject<CDACamera>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDACamera *) pNew;

    return pNew ;
}

STDMETHODIMP
CDACameraFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRCAMERA_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAImage::AddPickData(IUnknown * arg1, VARIANT_BOOL arg2, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::AddPickData(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRAddPickData((CRImage *) _bvr.p, /* NOELARG */ arg1, /* NOELARG */ BOOLTobool(arg2))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAImage::get_BoundingBox(IDABbox2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::get_BoundingBox(%lx)", this));
    return CreatePrim1(IID_IDABbox2, (CRBbox2 * (STDAPICALLTYPE *)(CRImage *)) CRBoundingBox , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAImage::Crop(IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::Crop(%lx)", this));
    return CreatePrim3(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRImage *, CRPoint2 *, CRPoint2 *)) CRCrop , (IDA2Behavior *) (CBvr *)this, arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAImage::Transform(IDATransform2 *  arg0, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::Transform(%lx)", this));
    return CreatePrim2(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRImage *, CRTransform2 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAImage::OpacityAnim(IDANumber *  arg0, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::OpacityAnim(%lx)", this));
    return CreatePrim2(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRImage *, CRNumber *)) CROpacity , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAImage::Opacity(double arg0, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::Opacity(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CROpacity((CRImage *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAImage::Undetectable(IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::Undetectable(%lx)", this));
    return CreatePrim1(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRImage *)) CRUndetectable , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAImage::Tile(IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::Tile(%lx)", this));
    return CreatePrim1(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRImage *)) CRTile , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAImage::Clip(IDAMatte *  arg0, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::Clip(%lx)", this));
    return CreatePrim2(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRImage *, CRMatte *)) CRClip , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAImage::MapToUnitSquare(IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::MapToUnitSquare(%lx)", this));
    return CreatePrim1(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRImage *)) CRMapToUnitSquare , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAImage::ClipPolygonImageEx(long sizearg0, IDAPoint2 *  arg0[], IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::ClipPolygonImageEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRClipPolygonImage((CRImage *) _bvr.p, arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAImage::ClipPolygonImage(VARIANT arg0, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::ClipPolygonImage(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRPOINT2_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRClipPolygonImage((CRImage *) _bvr.p, arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAImage::RenderResolution(long arg1, long arg2, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::RenderResolution(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRRenderResolution((CRImage *) _bvr.p, /* NOELARG */ arg1, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAImage::ImageQuality(DWORD arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::ImageQuality(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRImageQuality((CRImage *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAImage::ColorKey(IDAColor *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::ColorKey(%lx)", this));
    return CreatePrim2(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRImage *, CRColor *)) CRColorKey , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAImage::TransformColorRGB(IDATransform3 * arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::TransformColorRGB(%lx)", this));
    return CreatePrim2(IID_IDAImage,
                       (CRImage * (STDAPICALLTYPE *)(CRImage *, CRTransform3 *)) CRTransformColorRGB,
                       (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)
        ?S_OK:Error();     
}

STDMETHODIMP
CDAImage::Pickable(IDAPickableResult **ppResult)
{
    PRIMPRECODE1(ppResult);
    PickableHelper(_bvr, PT_IMAGE, ppResult);
    PRIMPOSTCODE1(ppResult);
}

STDMETHODIMP
CDAImage::PickableOccluded(IDAPickableResult **ppResult)
{
    PRIMPRECODE1(ppResult);
    PickableHelper(_bvr, PT_IMAGE_OCCLUDED, ppResult);
    PRIMPOSTCODE1(ppResult);
}


// OBSOLETE

STDMETHODIMP
CDAImage::ApplyBitmapEffect(IUnknown  *unkOfEffectToApply,
                            IDAEvent *firesWhenChanged,
                            IDAImage **bvr)
{
    if (!bvr) return E_POINTER;
    *bvr = NULL;
    return E_NOTIMPL;
}

CBvr * CDAImageCreate(IDABehavior ** bvr)
{
    DAComObject<CDAImage> * pNew ;
    
    DAComObject<CDAImage>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAImage *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAImageFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRIMAGE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAMontage::Render(IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAMontage::Render(%lx)", this));
    return CreatePrim1(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRMontage *)) CRRender , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}



CBvr * CDAMontageCreate(IDABehavior ** bvr)
{
    DAComObject<CDAMontage> * pNew ;
    
    DAComObject<CDAMontage>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAMontage *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAMontageFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRMONTAGE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAPoint2::get_X(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint2::get_X(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint2 *)) CRGetX , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint2::get_Y(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint2::get_Y(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint2 *)) CRGetY , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint2::get_PolarCoordAngle(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint2::get_PolarCoordAngle(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint2 *)) CRPolarCoordAngle , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint2::get_PolarCoordLength(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint2::get_PolarCoordLength(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint2 *)) CRPolarCoordLength , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint2::Transform(IDATransform2 *  arg0, IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint2::Transform(%lx)", this));
    return CreatePrim2(IID_IDAPoint2, (CRPoint2 * (STDAPICALLTYPE *)(CRPoint2 *, CRTransform2 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}


STDMETHODIMP
CDAPoint2::AnimateControlPosition(BSTR propertyPath,
                                  BSTR scriptingLanguage,
                                  VARIANT_BOOL invokeAsMethod,
                                  double minUpdateInterval,
                                  IDAPoint2 **newPt)
{
    // These ensure the return pointer is dealt with correctly
    return Point2AnimateControlPosition(this, propertyPath,
                                        scriptingLanguage,
                                        invokeAsMethod ? true : false,
                                        minUpdateInterval,
                                        newPt,
                             